[
    {
        "title": "Maximum Sum of Two Non-Overlapping Subarrays",
        "question_content": "Given an integer array nums and two integers firstLen and secondLen, return the maximum sum of elements in two non-overlapping subarrays with lengths firstLen and secondLen.\nThe array with length firstLen could occur before or after the array with length secondLen, but they have to be non-overlapping.\nA subarray is a contiguous part of an array.\n&nbsp;\nExample 1:\nInput: nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2\nOutput: 20\nExplanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.\nExample 2:\nInput: nums = [3,8,1,3,2,1,8,9,0], firstLen = 3, secondLen = 2\nOutput: 29\nExplanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.\nExample 3:\nInput: nums = [2,1,5,6,0,9,5,0,3,8], firstLen = 4, secondLen = 3\nOutput: 31\nExplanation: One choice of subarrays is [5,6,0,9] with length 4, and [0,3,8] with length 3.\n&nbsp;\nConstraints:\n\t1 <= firstLen, secondLen <= 1000\n\t2 <= firstLen + secondLen <= 1000\n\tfirstLen + secondLen <= nums.length <= 1000\n\t0 <= nums[i] <= 1000",
        "solutions": [
            {
                "id": 279221,
                "title": "java-python-3-two-easy-dp-codes-w-comment-time-o-n-no-change-of-input",
                "content": "**Q & A**\\n\\nQ1: How do you guarantee the two subarrays are not overlapping in your code?\\nA1: During traversal, the upper bound of the `L-length` left subarray is `i - M` inclusively, and the lower bound of the `M-length` right subarray is also `i - M` exclusively. Therefore, the two subarrays will never overlap.\\n\\nQ2: Why the roles of L and M has been swapped i.e 1st time number of L elements were before and followed by M and 2nd time its vice versa?\\nA2: Because there are two cases: L is ahead of M and M is ahead L; either could be the maximum. Therefore, we need to check both to find the maximum.\\n\\nQ3: Can\\'t we just use the input(given) array for storing prefix sum array so that solution 1 will be O(1) space solution?\\nA3: In most cases it is preferable to keep input array unchanged. Also, in strict sense, we should count into space cost the modified input array, so it actually cost space `O(n)`, which is often called **extra** space `O(1)`.\\n\\nQ4:  Why you use the `maxL` and `sumM` to calculate the `ans` and not `maxM` as well?\\nA4: That will result overlap of L-subarray and M-subarray. We traverse input array `A` from left to right, and the value of maxM could occur at part or whole of current L-subarray. E.g., \\n`A = [1,1,3,2,1], L = 2, M = 1`\\nWhen L-subarray = [3,2] and M-subarray = [1], then `maxM = 3`, and the `3` is from L-subarray [3,2].\\n\\nIn contrast, `maxL` will never occur at part or whole of **current** M-subarray hence will **NOT** cause overlap, because L-subarray has not included any element in M-subarray yet.\\n\\n**End of Q & A**\\n\\n----\\n\\nPlease refer to **@lionkingeatapple**\\'s diagram as follows:\\n![image](https://assets.leetcode.com/users/images/2eafddf3-c5d9-4fa3-8145-966f0a2cd63e_1605434988.6631174.png)\\n\\n\\n1. Scan the prefix sum array from index `L + M`, which is the first possible position;\\n2. update the max value of the `L-length` subarray; then update max value of the sum of the both;\\n3. we need to swap `L` and `M` to scan twice, since either subarray can occur before the other.\\n4. In private method, prefix sum difference `p[i - M] - p[i - M - L]` is `L-length` subarray from index `i - M - L` to `i - M - 1`, and `p[i] - p[i - M]` is `M-length` subarray from index `i - M` to `i - 1`. \\n\\n**Solution 1: Prefix Sum**\\n\\n```java\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int[] prefixSum = new int[A.length + 1];\\n        for (int i = 0; i < A.length; ++i) {\\n            prefixSum[i + 1] = prefixSum[i] + A[i];\\n        }\\n        return Math.max(maxSum(prefixSum, L, M), maxSum(prefixSum, M, L));\\n    }\\n    private int maxSum(int[] p, int L, int M) {\\n        int ans = 0;\\n        for (int i = L + M, maxL = 0; i < p.length; ++i) {\\n            maxL = Math.max(maxL, p[i - M] - p[i - M - L]); // update max of L-length subarray.\\n            ans = Math.max(ans, maxL + p[i] - p[i - M]); // update max of the sum of L-length & M-length subarrays.\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        \\n        def maxSum(L:int, M:int) -> int:\\n            maxL = ans = 0\\n            for i in range(L + M, len(prefixSum)):\\n                maxL = max(maxL, prefixSum[i - M] - prefixSum[i - L - M])\\n                ans = max(ans, maxL + prefixSum[i] - prefixSum[i - M])\\n            return ans\\n        \\n        prefixSum = [0] * (len(A) + 1)\\n        for i, a in enumerate(A):\\n            prefixSum[i + 1] = prefixSum[i] + a\\n        return max(maxSum(L, M), maxSum(M, L))\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = A.length`.\\n\\n----\\n\\n**Solution 2: Sliding Window**\\n\\nBased on **Solution 1**, we can further get rid of prefix sum array to implement the following space `O(1)` code. \\n\\n**Unfortunately, the boundary conditions are headache and fallible, please let me know if you can improve the readability, or at least make it concise.**\\n\\n```java\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max(maxSum(A, L, M), maxSum(A, M, L));\\n    }\\n    private int maxSum(int[] A, int L, int M) {\\n        int ans = 0; \\n        for (int i = 0, maxL = 0, sumL = 0, sumM = 0; i < A.length; ++i) {\\n            if (i < L || i >= L + M) { sumL += i < L ? A[i] : A[i - M]; } // first L-length subarray at index [0...L - 1], no update between index [L...L + M - 1].\\n            if (i >= L) { sumM += A[i]; } // first M-length subarray starts from index L to L + M - 1.\\n            if (i >= L + M) { sumL -= A[i - L - M]; } // deduct first item from current L-length subarray.\\n            if (i >= L + M) { sumM -= A[i - M]; } // deduct first item from current  M-length subarray.\\n            if (i >= L + M - 1) { maxL = Math.max(maxL, sumL); } // update max of L-length subarray.\\n            if (i >= L + M - 1) { ans = Math.max(ans, maxL + sumM); } // update max of L-length & M-length subarrays.\\n        }\\n        return ans;\\n    }\\n```\\n**Update with a more readable version:**\\n```java\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max(maxSum(A, L, M), maxSum(A, M, L));\\n    }\\n    private int maxSum(int[] A, int L, int M) {\\n        int sumL = 0, sumM = 0;\\n        for (int i = 0; i < L + M; ++i) { // compute the initial values of L & M length subarrays.\\n            if (i < L) sumL += A[i];\\n            else sumM += A[i];\\n        }\\n        int ans = sumM + sumL; // sum of sumL and sumM.\\n        for (int i = L + M, maxL = sumL; i < A.length; ++i) {\\n            sumL += A[i - M] - A[i - L - M]; // update sumL.\\n            sumM += A[i] - A[i - M]; // update sumM.\\n            maxL = Math.max(maxL, sumL); // update max value of L-length subarray.\\n            ans = Math.max(ans, maxL + sumM); // update max value of sum of L & M-length subarrays.\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        \\n        def maxSum(L:int, M:int) -> int:\\n            sumL = sumM = 0\\n            for i in range(0, L + M):\\n                if i < L:\\n                    sumL += A[i]\\n                else:\\n                    sumM += A[i]    \\n            maxL, ans = sumL, sumL + sumM\\n            for i in range(L + M, len(A)):\\n                sumL += A[i - M] - A[i - L - M]\\n                maxL = max(maxL, sumL)\\n                sumM += A[i] - A[i - M]\\n                ans = max(ans, maxL + sumM)\\n            return ans\\n        \\n        return max(maxSum(L, M), maxSum(M, L)) \\n```\\n**Analysis:**\\n\\nTime: `O(n)`, space: `O(1)`, where `n = A.length`.\\n\\n",
                "solutionTags": [],
                "code": "```java\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int[] prefixSum = new int[A.length + 1];\\n        for (int i = 0; i < A.length; ++i) {\\n            prefixSum[i + 1] = prefixSum[i] + A[i];\\n        }\\n        return Math.max(maxSum(prefixSum, L, M), maxSum(prefixSum, M, L));\\n    }\\n    private int maxSum(int[] p, int L, int M) {\\n        int ans = 0;\\n        for (int i = L + M, maxL = 0; i < p.length; ++i) {\\n            maxL = Math.max(maxL, p[i - M] - p[i - M - L]); // update max of L-length subarray.\\n            ans = Math.max(ans, maxL + p[i] - p[i - M]); // update max of the sum of L-length & M-length subarrays.\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        \\n        def maxSum(L:int, M:int) -> int:\\n            maxL = ans = 0\\n            for i in range(L + M, len(prefixSum)):\\n                maxL = max(maxL, prefixSum[i - M] - prefixSum[i - L - M])\\n                ans = max(ans, maxL + prefixSum[i] - prefixSum[i - M])\\n            return ans\\n        \\n        prefixSum = [0] * (len(A) + 1)\\n        for i, a in enumerate(A):\\n            prefixSum[i + 1] = prefixSum[i] + a\\n        return max(maxSum(L, M), maxSum(M, L))\\n```\n```java\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max(maxSum(A, L, M), maxSum(A, M, L));\\n    }\\n    private int maxSum(int[] A, int L, int M) {\\n        int ans = 0; \\n        for (int i = 0, maxL = 0, sumL = 0, sumM = 0; i < A.length; ++i) {\\n            if (i < L || i >= L + M) { sumL += i < L ? A[i] : A[i - M]; } // first L-length subarray at index [0...L - 1], no update between index [L...L + M - 1].\\n            if (i >= L) { sumM += A[i]; } // first M-length subarray starts from index L to L + M - 1.\\n            if (i >= L + M) { sumL -= A[i - L - M]; } // deduct first item from current L-length subarray.\\n            if (i >= L + M) { sumM -= A[i - M]; } // deduct first item from current  M-length subarray.\\n            if (i >= L + M - 1) { maxL = Math.max(maxL, sumL); } // update max of L-length subarray.\\n            if (i >= L + M - 1) { ans = Math.max(ans, maxL + sumM); } // update max of L-length & M-length subarrays.\\n        }\\n        return ans;\\n    }\\n```\n```java\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max(maxSum(A, L, M), maxSum(A, M, L));\\n    }\\n    private int maxSum(int[] A, int L, int M) {\\n        int sumL = 0, sumM = 0;\\n        for (int i = 0; i < L + M; ++i) { // compute the initial values of L & M length subarrays.\\n            if (i < L) sumL += A[i];\\n            else sumM += A[i];\\n        }\\n        int ans = sumM + sumL; // sum of sumL and sumM.\\n        for (int i = L + M, maxL = sumL; i < A.length; ++i) {\\n            sumL += A[i - M] - A[i - L - M]; // update sumL.\\n            sumM += A[i] - A[i - M]; // update sumM.\\n            maxL = Math.max(maxL, sumL); // update max value of L-length subarray.\\n            ans = Math.max(ans, maxL + sumM); // update max value of sum of L & M-length subarrays.\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        \\n        def maxSum(L:int, M:int) -> int:\\n            sumL = sumM = 0\\n            for i in range(0, L + M):\\n                if i < L:\\n                    sumL += A[i]\\n                else:\\n                    sumM += A[i]    \\n            maxL, ans = sumL, sumL + sumM\\n            for i in range(L + M, len(A)):\\n                sumL += A[i - M] - A[i - L - M]\\n                maxL = max(maxL, sumL)\\n                sumM += A[i] - A[i - M]\\n                ans = max(ans, maxL + sumM)\\n            return ans\\n        \\n        return max(maxSum(L, M), maxSum(M, L)) \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 278727,
                "title": "c-o-n-buy-sell-stock-2-times",
                "content": "Similar to [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/), but instead of maximum profit, we track maximum sum of ```N``` elements.\\n\\nLeft-to-right, track the maximum sum of ```L``` elements in ```left```. Right-to-left, track the maximum sum of ```M``` elements in ```right```.\\n\\nThen, find the split point where ```left[i] + right[i]``` gives us the maximum sum.\\n\\n**Note:** we need to do it twice for (L, M) and (M, L).\\n```\\nint maxTwoNoOverlap(vector<int>& A, int L, int M, int sz, int res = 0) {\\n  vector<int> left(sz + 1), right(sz + 1);\\n  for (int i = 0, j = sz - 1, s_r = 0, s_l = 0; i < sz; ++i, --j) {\\n    s_l += A[i], s_r += A[j];\\n    left[i + 1] = max(left[i], s_l);\\n    right[j] = max(right[j + 1], s_r);\\n    if (i + 1 >= L) s_l -= A[i + 1 - L];\\n    if (i + 1 >= M) s_r -= A[j + M - 1];\\n  }\\n  for (auto i = 0; i < A.size(); ++i) {\\n    res = max(res, left[i] + right[i]);\\n  }\\n  return res;\\n}\\nint maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n  return max(maxTwoNoOverlap(A, L, M, A.size()), maxTwoNoOverlap(A, M, L, A.size()));\\n}\\n```",
                "solutionTags": [],
                "code": "```N```\n```L```\n```left```\n```M```\n```right```\n```left[i] + right[i]```\n```\\nint maxTwoNoOverlap(vector<int>& A, int L, int M, int sz, int res = 0) {\\n  vector<int> left(sz + 1), right(sz + 1);\\n  for (int i = 0, j = sz - 1, s_r = 0, s_l = 0; i < sz; ++i, --j) {\\n    s_l += A[i], s_r += A[j];\\n    left[i + 1] = max(left[i], s_l);\\n    right[j] = max(right[j + 1], s_r);\\n    if (i + 1 >= L) s_l -= A[i + 1 - L];\\n    if (i + 1 >= M) s_r -= A[j + M - 1];\\n  }\\n  for (auto i = 0; i < A.size(); ++i) {\\n    res = max(res, left[i] + right[i]);\\n  }\\n  return res;\\n}\\nint maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n  return max(maxTwoNoOverlap(A, L, M, A.size()), maxTwoNoOverlap(A, M, L, A.size()));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 300029,
                "title": "python-breaking-down-lee215-s-solution",
                "content": "So the problem is essentially 2 separate cases.\\n\\nBut it\\'s important to keep in mind that the L+M maximum could be reached before L & M separate from each other\\nSo you cannot divide each case into simply 2 steps:\\n1. find the global maximum of the window on the left\\n2. find the maximum of the second window in the region to the right of the first window\\n\\n\\n\\ncase 1:      L-window comes before M-windows\\nOnce L-window reaches it\\'s global maximum, it will stop sliding but M window can keep going on\\n\\ncase 2:      M-window comes before L-windows\\nOnce M-window reaches it\\'s global maximum, it will stop sliding but L window can keep going on\\n\\n```\\n\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\n\\n        # do a CDF so that range sum can easily be calculated\\n        for i in range(1, len(A)):\\n            A[i] += A[i - 1]\\n\\n\\n        res, Lmax, Mmax = A[L + M - 1], A[L - 1], A[M - 1]\\n\\n\\n        # window  | --- L --- | --- M --- |\\n        for i in range(L + M, len(A)):\\n            Lmax = max(Lmax, A[i - M] - A[i - L - M])\\n            res = max(res, Lmax + A[i] - A[i - M])\\n\\n        # window  | --- M --- | --- L --- |\\n        for i in range(L + M, len(A)):\\n            Mmax = max(Mmax, A[i - L] - A[i - L - M])\\n            res = max(res, Mmax + A[i] - A[i - L])\\n\\n        return res\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\n\\n        # do a CDF so that range sum can easily be calculated\\n        for i in range(1, len(A)):\\n            A[i] += A[i - 1]\\n\\n\\n        res, Lmax, Mmax = A[L + M - 1], A[L - 1], A[M - 1]\\n\\n\\n        # window  | --- L --- | --- M --- |\\n        for i in range(L + M, len(A)):\\n            Lmax = max(Lmax, A[i - M] - A[i - L - M])\\n            res = max(res, Lmax + A[i] - A[i - M])\\n\\n        # window  | --- M --- | --- L --- |\\n        for i in range(L + M, len(A)):\\n            Mmax = max(Mmax, A[i - L] - A[i - L - M])\\n            res = max(res, Mmax + A[i] - A[i - L])\\n\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 581060,
                "title": "python-prefix-sum-with-diagram-explanation",
                "content": "![image](https://assets.leetcode.com/users/codingasiangirll/image_1586963971.png)\\n\\n\\n**Explanation**: Suppose we already have array of prefix sum, and we are at index `i`-th of `prefix_sum`. There are two possible ways to find maximum result:\\n(1) `maxL` + the last sum of `A`\\'s subarray of length == `M`. `maxL`:= maximum sum of `A`\\'s subarray of length == `L`, before the ending at `i`, and the last subarray with length == `M`. (In the diagram, possible result (1))\\n\\n(2) `maxM` + the last sum of `A`\\'s subarray of length == `L`. `maxM`:= maximum sum of `A`\\'s subarray of length == `M`, before the ending at `i`, and the last subarray with length == `L`. (In the diagram, possible result (2))\\n\\n**Complexity**: Time O(N), N is `len(A)`. Space O(1)\\n```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        if len(A) < L + M: return 0\\n        for i in range(1, len(A)):\\n            A[i] += A[i - 1]\\n        res, maxL, maxM = A[L + M - 1], A[L - 1], A[M - 1]\\n        for i in range(L + M, len(A)):\\n            maxL = max(maxL, A[i - M] - A[i - M - L])\\n            maxM = max(maxM, A[i - L] - A[i - L - M])\\n            res = max(res, maxL + A[i] - A[i - M], maxM + A[i] - A[i - L])\\n        return res\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        if len(A) < L + M: return 0\\n        for i in range(1, len(A)):\\n            A[i] += A[i - 1]\\n        res, maxL, maxM = A[L + M - 1], A[L - 1], A[M - 1]\\n        for i in range(L + M, len(A)):\\n            maxL = max(maxL, A[i - M] - A[i - M - L])\\n            maxM = max(maxM, A[i - L] - A[i - L - M])\\n            res = max(res, maxL + A[i] - A[i - M], maxM + A[i] - A[i - L])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 616171,
                "title": "readable-java-solution-with-o-n-time-and-o-n-space",
                "content": "The solution is not the most concise one, but it\\'s highly readable and easy to understand.\\nYou really have to calculate the indices very carefully to avoid array out of bound and to get correct result.\\n\\n```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // L and M could be at left or right\\n        // so we need to calculate the both to get the max non-overlapping sum of entire array\\n        return Math.max(calculate(A, L, M), calculate(A, M, L));\\n    }\\n    \\n    private int calculate(int[] A, int L, int M) {\\n        int sum = 0;\\n        int len = A.length;\\n        \\n        // calculate the prefix sum from A[0] to A[i]\\n        int[] prefixSum = new int[len];\\n        prefixSum[0] = A[0];\\n        for(int i = 1; i < len; i++) {\\n            prefixSum[i] = prefixSum[i-1] + A[i];\\n        }\\n        \\n        // calculate the maximum sum with length L with rightmost position at A[i], A[i] doesn\\'t have to be included\\n        int[] leftSum = new int[len];\\n        leftSum[L-1] = prefixSum[L-1];\\n        for(int i = L; i < len; i++) {\\n            leftSum[i] = Math.max(leftSum[i-1], prefixSum[i] - prefixSum[i-L]);\\n        }\\n        \\n        // calculate the suffix sum from A[i] to A[len-1]\\n        int[] suffixSum = new int[len];\\n        suffixSum[len-1] = A[len-1];\\n        for(int i = len-2; i >= 0; i--) {\\n            suffixSum[i] = suffixSum[i+1] + A[i];\\n        }\\n        \\n        // calcualte the maxisum sum with length M with leftmost position at A[i], A[i] doesn\\'t have to be included\\n        int[] rightSum = new int[len];\\n        rightSum[len-M] = suffixSum[len-M];\\n        for(int i = len-M-1; i >= 0; i--) {\\n            rightSum[i] = Math.max(rightSum[i+1], suffixSum[i] - suffixSum[i+M]);\\n        }\\n        \\n        // now we have all the data for max sum with length L from the left\\n        // and max sum with length M from the right\\n        // just iterate and add them up to find the max non-overlapping sum \\n        // note the i+1 index is for non-overlapping\\n        int res = Integer.MIN_VALUE;\\n        for(int i = L-1; i <= len-M-1; i++) {\\n            res = Math.max(leftSum[i] + rightSum[i+1], res);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // L and M could be at left or right\\n        // so we need to calculate the both to get the max non-overlapping sum of entire array\\n        return Math.max(calculate(A, L, M), calculate(A, M, L));\\n    }\\n    \\n    private int calculate(int[] A, int L, int M) {\\n        int sum = 0;\\n        int len = A.length;\\n        \\n        // calculate the prefix sum from A[0] to A[i]\\n        int[] prefixSum = new int[len];\\n        prefixSum[0] = A[0];\\n        for(int i = 1; i < len; i++) {\\n            prefixSum[i] = prefixSum[i-1] + A[i];\\n        }\\n        \\n        // calculate the maximum sum with length L with rightmost position at A[i], A[i] doesn\\'t have to be included\\n        int[] leftSum = new int[len];\\n        leftSum[L-1] = prefixSum[L-1];\\n        for(int i = L; i < len; i++) {\\n            leftSum[i] = Math.max(leftSum[i-1], prefixSum[i] - prefixSum[i-L]);\\n        }\\n        \\n        // calculate the suffix sum from A[i] to A[len-1]\\n        int[] suffixSum = new int[len];\\n        suffixSum[len-1] = A[len-1];\\n        for(int i = len-2; i >= 0; i--) {\\n            suffixSum[i] = suffixSum[i+1] + A[i];\\n        }\\n        \\n        // calcualte the maxisum sum with length M with leftmost position at A[i], A[i] doesn\\'t have to be included\\n        int[] rightSum = new int[len];\\n        rightSum[len-M] = suffixSum[len-M];\\n        for(int i = len-M-1; i >= 0; i--) {\\n            rightSum[i] = Math.max(rightSum[i+1], suffixSum[i] - suffixSum[i+M]);\\n        }\\n        \\n        // now we have all the data for max sum with length L from the left\\n        // and max sum with length M from the right\\n        // just iterate and add them up to find the max non-overlapping sum \\n        // note the i+1 index is for non-overlapping\\n        int res = Integer.MIN_VALUE;\\n        for(int i = L-1; i <= len-M-1; i++) {\\n            res = Math.max(leftSum[i] + rightSum[i+1], res);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365435,
                "title": "100-faster-solution-with-explaination",
                "content": "The idea is to find the max sum subbary of given size firstlen and seconlen seperately \\nFind prefix sum for firstlen and suffix sum for secondLen and vice-versa\\nDp1-> it will store the max sum of the subarray of size firstlen from 0th to ith index.\\nDp2-> it will store the max sum of the subarray from last index to ith index\\nand then check from a window of fisrstlen-1 to nums.size()- secondlen\\nwhich ever has the max sum will be our result\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&nums,int x,int y){\\n        int n=nums.size();\\n        vector<int>dp1(n,0),dp2(n,0);\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i<x){//when we haven\\'t considered x-size array\\n                sum+=nums[i]; \\n                dp1[i]=sum;\\n            }\\n            else{ //when we have a window of size x\\n                sum=sum+nums[i]-nums[i-x];\\n                dp1[i]=max(dp1[i-1],sum);\\n            }\\n        }\\n        sum=0;\\n        //check from right to left for Secondlen window and store maximum sum from ith index to last index keep updating at every point if the current window of size secondLen is max or dp2[i+1] has max whichever is max add that to dp[i]\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(i+y>n-1) { //case when we haven\\'t encountered a window of size secondlen ie. y\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }\\n            else{//when we have a window of size secondLen\\n                sum=sum+nums[i]-nums[i+y];\\n                dp2[i]=max(dp2[i+1],sum);\\n            }\\n        }\\n        int ans=0;\\n        //our ans window will be from x-1 to n-y\\n        for(int i=x-1;i<n-y;i++){\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen){\\n        return max(helper(nums, firstLen, secondLen),helper(nums, secondLen, firstLen));\\n    }\\n};\\n```\\n**comment if have doubts and do upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&nums,int x,int y){\\n        int n=nums.size();\\n        vector<int>dp1(n,0),dp2(n,0);\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i<x){//when we haven\\'t considered x-size array\\n                sum+=nums[i]; \\n                dp1[i]=sum;\\n            }\\n            else{ //when we have a window of size x\\n                sum=sum+nums[i]-nums[i-x];\\n                dp1[i]=max(dp1[i-1],sum);\\n            }\\n        }\\n        sum=0;\\n        //check from right to left for Secondlen window and store maximum sum from ith index to last index keep updating at every point if the current window of size secondLen is max or dp2[i+1] has max whichever is max add that to dp[i]\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(i+y>n-1) { //case when we haven\\'t encountered a window of size secondlen ie. y\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }\\n            else{//when we have a window of size secondLen\\n                sum=sum+nums[i]-nums[i+y];\\n                dp2[i]=max(dp2[i+1],sum);\\n            }\\n        }\\n        int ans=0;\\n        //our ans window will be from x-1 to n-y\\n        for(int i=x-1;i<n-y;i++){\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen){\\n        return max(helper(nums, firstLen, secondLen),helper(nums, secondLen, firstLen));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278723,
                "title": "analysis-maximum-sum-of-two-non-overlapping-subarrays",
                "content": "**Intuition and Algorithm**\\n\\n**Approach 1 (Brute Force)**\\nSimulate, check all the posibilites and get the maximum.\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(vector<int>v, int a,int b){\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t\\tfor(int j=i+a;j+b-1<v.size();j++){\\n\\t\\t\\t\\t\\tint sum1= accumulate(v.begin()+i,v.begin()+i+a,0);\\n\\t\\t\\t\\t\\tint sum2= accumulate(v.begin()+j,v.begin()+j+b,0);\\n\\t\\t\\t\\t\\tans = max(ans,sum1+sum2);\\n\\t\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n\\t\\t\\treturn max(f(A,L,M),f(A,M,L));\\n\\t\\t}\\n\\t};\\n</code>\\n\\n<b>Complexity time </b>\\n* O(n^3) where n is the length of A\\n\\n**Approach 2 (Preprocess accumulate)**\\nWe can optimize the previous algorithm, preprocessing sum between two index.\\nSUM(v[i]....v[j] ) =  ac[j+1]-ac[i]\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(vector<int>v, int a,int b){\\n\\t\\t\\tint ans=0;\\n\\t\\t\\t\\n\\t\\t\\tint ac[v.size()+1];\\n\\t\\t\\tmemset(ac,0,sizeof(ac));\\n\\t\\t\\tfor(int i=1;i<=v.size();i++)\\n\\t\\t\\t\\tac[i]= ac[i-1]+v[i-1];\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t\\tfor(int j=i+a;j+b-1<v.size();j++){\\n\\t\\t\\t\\t\\tint sum1= ac[i+a]-ac[i];\\n\\t\\t\\t\\t\\tint sum2= ac[j+b]-ac[j];\\n\\t\\t\\t\\t\\tans = max(ans,sum1+sum2);\\n\\t\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n\\t\\t\\treturn max(f(A,L,M),f(A,M,L));\\n\\t\\t}\\n\\t};\\n</code>\\n\\n<b>Complexity time </b>\\n* O(n^2) where n is the length of A\\n\\n**Approach 3 (Preprocess max prefix and max suffix)**\\nNow, we are going to get preprocess max prefix and max suffix.\\nFor example:  \\nGiven a function  f(v, 3,5)\\nwhere v= [3,4,2,5,7,8,1,2]\\n**check all prefix with length 3**\\nPrefix [3,4,2]-> sum 9 , index 2 \\n          [4,2,5]-> sum 11, index 3\\n\\t\\t  [2,5,7]-> sum 15 , index 4\\n\\t\\t  [5,7,8]-> sum 20 , index 5\\n\\t\\t  [7,8,1]-> sum 16 , index 6\\n\\t\\t  [8,1,2]-> sum 11 , index 7\\nOur prefix array with length 3 will be\\n<code> prefix [] = {-1,-1,9 ,11,15,20,16,11  } </code> \\nOur max prefix array with length 3 will be\\n<code> maxPrefix [] = {-1,-1,9 ,11,15,20,20,20  } </code>\\n\\nWe will do the same with suffix\\nGiven a function  f(v, 3,5)\\nwhere v= [3,4,2,5,7,8,1,2]\\n**check all suffix with length 5**\\nSuffix [5,7,8,1,2]-> sum 23 , index 3  (start index) \\n          [2,5,7,8,1]-> sum 23, index 2\\n\\t\\t  [4,2,5,7,8]-> sum 26 , index 1\\n\\t\\t  [3,4,2,5,7]-> sum 21 , index 0\\n\\nOur suffix array with length 5 will be\\n<code> suffix [] = {21,26,23,23, ..... } </code> \\nOur max suffix array with length 5 will be\\n<code> maxSuffix [] = {21,26,26,26, ....  } </code>\\n\\nWe can build suffix and preffix array in O(n)\\nThe solution of the problem will be  MAX(maxPrefix[i]+ maxSuffix[i+1] )\\nI did that in Contest :). \\n\\n**C++**\\n<code>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(vector<int>v, int a,int b){\\n\\t\\t\\tint max1[v.size()];\\n\\t\\t\\tmemset(max1,-1,sizeof(max1));\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=0;i<a-1;i++)\\n\\t\\t\\t\\tsum+=v[i];\\n\\t\\t\\t\\n\\t\\t\\tfor(int i=a-1;i<v.size();i++){\\n\\t\\t\\t\\tsum+=v[i];\\n\\t\\t\\t\\tif(i-1>=0)\\n\\t\\t\\t\\t\\tmax1[i]=max(max1[i-1],sum);\\n\\t\\t\\t\\telse \\n\\t\\t\\t\\t\\tmax1[i]=sum;\\n\\t\\t\\t\\tsum-=v[i-(a-1)];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tsum=0;\\n\\t\\t\\tfor(int i=v.size()-1;i>(int)v.size()-b;i--){\\n\\t\\t\\t\\tsum+=v[i];\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tint suf=-1;\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=(int)v.size()-b;i>0;i--){\\n\\t\\t\\t\\tsum+=v[i];    \\n\\t\\t\\t\\tsuf=max(sum,suf);\\n\\t\\t\\t\\tif(max1[i-1]!=-1){\\n\\t\\t\\t\\t\\tans=max(ans,max1[i-1]+suf);\\n\\t\\t\\t\\t}\\t\\n\\t\\t\\t\\tsum-=v[i+(b-1)];\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\t\\n\\t\\tint maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n\\t\\t\\treturn max(f(A,L,M),f(A,M,L));\\n\\t\\t}\\n\\t};\\n</code>\\n\\n<b>Complexity time </b>\\n* O(n) where n is the length of A",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(vector<int>v, int a,int b){\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<v.size();i++)\\n\\t\\t\\t\\tfor(int j=i+a;j+b-1<v.size();j++){\\n\\t\\t\\t\\t\\tint sum1= accumulate(v.begin()+i,v.begin()+i+a,0);\\n\\t\\t\\t\\t\\tint sum2= accumulate(v.begin()+j,v.begin()+j+b,0);\\n\\t\\t\\t\\t\\tans = max(ans,sum1+sum2);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 355352,
                "title": "full-explanation-and-idea-formation-java-beat-99",
                "content": "# Idea 1; Simple and intutive \\n<details>\\n\\n```\\n\\n\\n /**\\n     * This is really a mind twister for me at least.\\n     * the biggest problem here is \"L\" and \"M\" can be interchange in terms of sub-array position.\\n     * <p>\\n     * Let\\'s for a while forget about their interchangeability, as we can always run algorithm bi-directional [2\\'s ].\\n     * <p>\\n     * Now Lets first concentrate what would be the outcome when L comes first then M.\\n     * [0,6,5,2,2,5,1,9,4]\\n     * <p>\\n     * * if L array comes first of \"L\" size, we can simply build a pre-sum array using which we can easily find what is the sum of the current sub-array of L size.\\n     * * Similarly we can build the \"M\" size array from Back using pre-sum ( from back ).\\n     * * Since we need to make sure that choosing any them should not be overlap.\\n     * * as It can be seen that by building pre-Sum for L (from Left) and pre-Sum for M (from back) will make sure that at any index i, the value at LpreSum is a sub-array which is\\n     * not overlapping with a sub-array given by Mpre-Sum, assuming right boundary as 0.\\n     * <p>\\n     * Now, Once we know that, we can easily build the final sum, by joining both arrays.\\n     * <p>\\n     * Do it similarly for M come first then L. finally take the maximum of both.\\n     * <p>\\n     * If you look closely, it is similar to Buy-Sell stocks two times {@link Java.LeetCode.stockPrices.MaxProfitTwoTransaction}\\n     * Here we just change how we build the array.\\n     * <p>\\n     * Example:  [0,6,5,2,2,5,1,9,4] L=1, M=2\\n     * When L First and M next\\n     * LPreSum[i] =  Max ( LpreSum[i-1], LpreSum[i] - LPreSum[i-L] )\\n     * * [ 0 , 6, 6, 6 , 6, 6, 6, 9 , 9 ] L=1\\n     * *\\n     * MPreSum[i] =  Max ( MPreSum[i+1], MPreSum[i] - MPreSum[i+M] )\\n     * * [ 13 ,13, 13 , 13, 13 , 13, 13 , 4, 0 ] M=2\\n     * <p>\\n     * Max = 19\\n     * <p>\\n     * When M First and L next\\n     * MPreSum[i] =  Max ( MPreSum[i+1], MPreSum[i] - MPreSum[i+L] )\\n     * * [ 0 , 6, 11, 11 , 11, 11, 11, 11 , 13 ] M=2\\n     * *\\n     * LPreSum[i] =  Max ( LPreSum[i-1], LPreSum[i] - LPreSum[i-M] )\\n     * * [ 9 ,9, 9 , 9, 9 , 9, 9 , 4, 0 ] L=1\\n     * *\\n     * Max = 20\\n     * <p>\\n     * Overall Max = 20\\n     *\\n     * @return Runtime: 2 ms, faster than 46.94% of Java online submissions for Maximum Sum of Two Non-Overlapping Subarrays.\\n     * Memory Usage: 38.6 MB, less than 8.70% of Java online submissions for Maximum Sum of Two Non-Overlapping Subarrays.\\n     * <p>\\n     * https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/discuss/278727/C%2B%2B-O(N)-buysell-stock-2-times\\n     *\\n     *\\n     */\\n\\n    static class MaximumSumTwoNonOverlapUsingBuySellStocksIdea {\\n\\n        public static int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n\\n            if (null == nums || nums.length == 0 || nums.length < L + M)\\n                return -1;\\n\\n\\n            return Math.max(maxSum(nums, L, M), maxSum(nums, M, L));\\n\\n        }\\n\\n\\n        private static int maxSum(int nums[], int L, int M) {\\n\\n            int max = 0;\\n            int n = nums.length;\\n            int LPreSum[] = new int[n];\\n            int MPreSum[] = new int[n];\\n\\n\\n            int leftSum = nums[0];\\n            LPreSum[0] = nums[0];\\n\\n\\n            int rightSum = 0;\\n            MPreSum[n - 1] = 0; //right boundary as 0\\n\\n            for (int i = 1, j = n - 2; i < n && j >= 0; i++, j--) {\\n\\n\\n                leftSum += nums[i];\\n\\n\\n                if (i >= L)\\n                    leftSum -= nums[i - L];\\n\\n                LPreSum[i] = Math.max(LPreSum[i - 1], leftSum);\\n\\n\\n                rightSum += nums[j + 1];\\n                if (j + M + 1 < n) //outside of M window\\n                    rightSum -= nums[j + M + 1];\\n\\n                MPreSum[j] = Math.max(MPreSum[j + 1], rightSum);\\n\\n            }\\n\\n            for (int i = 0; i < n; i++)\\n                max = Math.max(max, LPreSum[i] + MPreSum[i]);\\n\\n            return max;\\n        }\\n\\n    }\\n```\\n\\n\\n</details>\\n\\n# Idea 2: Complex but efficient\\n![image](https://assets.leetcode.com/users/nits2010/image_1565450311.png)\\n\\nThe whole trick is to manipulate the whole array as contiguous L or M elements after M or L elements [ bit confusing i know] .\\n\\nNow since we have two things to do;\\nEither we take first L elements then M elements\\nOr we take first M elements then L elements;\\n\\nFor example;\\n3, 8, 1 ,4, 2, 7 and L = 3 & M=2\\n\\nso configuration is\\nEither we take first L elements then M elements => L[3,8,1] & M[2,7]\\nOr we take first M elements then L elements; => M[3,8] & L[1,4,2]\\nThis way we can avoid overlapping arrays.\\n\\nWe choose whatever configuration gives us the maximum Sum.\\n\\nNow, Here is a sample run of the idea;\\n8, 1, 4, 2, 7, 22, 9} L=3, M=2\\n\\n0\\t1\\t2\\t3\\t4\\t5\\t6\\t7\\n3\\t8\\t1\\t4\\t2\\t7\\t22\\t9\\n\\nCumulative Sum (CM)\\n\\n0\\t1\\t2\\t3\\t4\\t5\\t6\\t7\\n3\\t8\\t1\\t4\\t2\\t7\\t22\\t9\\n3\\t11\\t12\\t16\\t18\\t25\\t47\\t56 . -------> CM\\n\\nLMax : L contagious elements taken first\\nMMax: M contagious element taken first\\n\\nMax: Maximum sum for two non-overlapping sub-array\\n\\ni=0 {Here if you see Lmax and Mmax they will look overlapping but Max is already been make sure that they are not overlapping}\\nLMAx = CM[L-1] = CM[2] = 12 [ 3,8,1] ->\\nMMax = CM[M-1] = CM[1] = 11 [3,8]\\nMax = CM[L+M-1] = CM[4] = 18 { [3,8,1] & [4,2] }\\n\\nI=5\\nNext L Elements are [8,1,4]=13 and earlier [3,8,1] = 12 => 13\\nNext M elements are [8,1]= 9 and earlier [3,8] = 11 => 11\\nMax = {L elements + M elements , M elements + L elements } = {13 + {25-16}, 11+{25-12} } \\nAs {8,1,4} + [2,7] + {3,8} +[4,2,7]\\n={21, 24 } = 24\\nSince [8,1,4]=13 Gave maximum as compare to old [3,8,1]\\nAnd [3,8]=11 Gave maximum as compare to new [8,1].\\n\\nNow M elements after [8,1,4] are [2,7]=9\\nAnd Next L elements after [8,1] are [4,2,7]=13\\n\\nI=6\\nNext L elements are [1,4,2] = 8 and earlier [8,1,4] = 13 => 13\\nNext M elements are [1,4] = 5 and earlier [3,8] = 11 => 11\\n\\nNow M elements after [1,4,2] are [7,22]= 29\\nAnd L elements after [1,4] are [2,7,22]=31\\nMax = {L elements + M elements , M elements + L elements } = {13 + {47-18}, 11 + {47-16} } = = {13 + 29, 11 + 31 } = 42\\n\\nSince [1,4,2]=8 did not give maximum sum as compare to old [8,1,4]=13\\nAnd [1,4]=5 did not give maximum sum as compare to old [3,8]=11\\n\\nI =7\\nL-> [4,2,7]=13 ; old [8,1,4]=13 => 13\\nM -> [4,2]=7 , old [3,8]=11 => 11\\nMax = { 13 + 31, 11 + 38 } = 49\\nL-> Next M Elements [22,9]\\nM-> Next L elements [7,22,9]\\n\\u2026.\\nAns= 49\\n\\nCode \\n\\n<details>\\n\\n```\\n public static int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n\\n            if (null == nums || nums.length == 0 || nums.length < L + M)\\n                return -1;\\n\\n\\n            return maxSum(nums, L, M);\\n\\n        }\\n\\n        private static int maxSum(int[] nums, int L, int M) {\\n\\n            for (int i = 1; i < nums.length; ++i)\\n                nums[i] += nums[i - 1];\\n\\n            int res = nums[L + M - 1], Lmax = nums[L - 1], Mmax = nums[M - 1];\\n\\n            for (int i = L + M; i < nums.length; ++i) {\\n  \\n                //Lmax is the case when L contiguous elements are taken first\\n                Lmax = Math.max(Lmax, nums[i - M] - nums[i - L - M]);\\n  \\n                //Mmax is the case when M contiguous elements are taken first\\n                Mmax = Math.max(Mmax, nums[i - L] - nums[i - L - M]);\\n                int x = Lmax + nums[i] - nums[i - M];\\n                int y = Mmax + nums[i] - nums[i - L];\\n  \\n                res = Math.max(res, Math.max(x, y));\\n            }\\n            return res;\\n        }\\n```\\n</details>",
                "solutionTags": [],
                "code": "```\\n\\n\\n /**\\n     * This is really a mind twister for me at least.\\n     * the biggest problem here is \"L\" and \"M\" can be interchange in terms of sub-array position.\\n     * <p>\\n     * Let\\'s for a while forget about their interchangeability, as we can always run algorithm bi-directional [2\\'s ].\\n     * <p>\\n     * Now Lets first concentrate what would be the outcome when L comes first then M.\\n     * [0,6,5,2,2,5,1,9,4]\\n     * <p>\\n     * * if L array comes first of \"L\" size, we can simply build a pre-sum array using which we can easily find what is the sum of the current sub-array of L size.\\n     * * Similarly we can build the \"M\" size array from Back using pre-sum ( from back ).\\n     * * Since we need to make sure that choosing any them should not be overlap.\\n     * * as It can be seen that by building pre-Sum for L (from Left) and pre-Sum for M (from back) will make sure that at any index i, the value at LpreSum is a sub-array which is\\n     * not overlapping with a sub-array given by Mpre-Sum, assuming right boundary as 0.\\n     * <p>\\n     * Now, Once we know that, we can easily build the final sum, by joining both arrays.\\n     * <p>\\n     * Do it similarly for M come first then L. finally take the maximum of both.\\n     * <p>\\n     * If you look closely, it is similar to Buy-Sell stocks two times {@link Java.LeetCode.stockPrices.MaxProfitTwoTransaction}\\n     * Here we just change how we build the array.\\n     * <p>\\n     * Example:  [0,6,5,2,2,5,1,9,4] L=1, M=2\\n     * When L First and M next\\n     * LPreSum[i] =  Max ( LpreSum[i-1], LpreSum[i] - LPreSum[i-L] )\\n     * * [ 0 , 6, 6, 6 , 6, 6, 6, 9 , 9 ] L=1\\n     * *\\n     * MPreSum[i] =  Max ( MPreSum[i+1], MPreSum[i] - MPreSum[i+M] )\\n     * * [ 13 ,13, 13 , 13, 13 , 13, 13 , 4, 0 ] M=2\\n     * <p>\\n     * Max = 19\\n     * <p>\\n     * When M First and L next\\n     * MPreSum[i] =  Max ( MPreSum[i+1], MPreSum[i] - MPreSum[i+L] )\\n     * * [ 0 , 6, 11, 11 , 11, 11, 11, 11 , 13 ] M=2\\n     * *\\n     * LPreSum[i] =  Max ( LPreSum[i-1], LPreSum[i] - LPreSum[i-M] )\\n     * * [ 9 ,9, 9 , 9, 9 , 9, 9 , 4, 0 ] L=1\\n     * *\\n     * Max = 20\\n     * <p>\\n     * Overall Max = 20\\n     *\\n     * @return Runtime: 2 ms, faster than 46.94% of Java online submissions for Maximum Sum of Two Non-Overlapping Subarrays.\\n     * Memory Usage: 38.6 MB, less than 8.70% of Java online submissions for Maximum Sum of Two Non-Overlapping Subarrays.\\n     * <p>\\n     * https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/discuss/278727/C%2B%2B-O(N)-buysell-stock-2-times\\n     *\\n     *\\n     */\\n\\n    static class MaximumSumTwoNonOverlapUsingBuySellStocksIdea {\\n\\n        public static int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n\\n            if (null == nums || nums.length == 0 || nums.length < L + M)\\n                return -1;\\n\\n\\n            return Math.max(maxSum(nums, L, M), maxSum(nums, M, L));\\n\\n        }\\n\\n\\n        private static int maxSum(int nums[], int L, int M) {\\n\\n            int max = 0;\\n            int n = nums.length;\\n            int LPreSum[] = new int[n];\\n            int MPreSum[] = new int[n];\\n\\n\\n            int leftSum = nums[0];\\n            LPreSum[0] = nums[0];\\n\\n\\n            int rightSum = 0;\\n            MPreSum[n - 1] = 0; //right boundary as 0\\n\\n            for (int i = 1, j = n - 2; i < n && j >= 0; i++, j--) {\\n\\n\\n                leftSum += nums[i];\\n\\n\\n                if (i >= L)\\n                    leftSum -= nums[i - L];\\n\\n                LPreSum[i] = Math.max(LPreSum[i - 1], leftSum);\\n\\n\\n                rightSum += nums[j + 1];\\n                if (j + M + 1 < n) //outside of M window\\n                    rightSum -= nums[j + M + 1];\\n\\n                MPreSum[j] = Math.max(MPreSum[j + 1], rightSum);\\n\\n            }\\n\\n            for (int i = 0; i < n; i++)\\n                max = Math.max(max, LPreSum[i] + MPreSum[i]);\\n\\n            return max;\\n        }\\n\\n    }\\n```\n```\\n public static int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n\\n            if (null == nums || nums.length == 0 || nums.length < L + M)\\n                return -1;\\n\\n\\n            return maxSum(nums, L, M);\\n\\n        }\\n\\n        private static int maxSum(int[] nums, int L, int M) {\\n\\n            for (int i = 1; i < nums.length; ++i)\\n                nums[i] += nums[i - 1];\\n\\n            int res = nums[L + M - 1], Lmax = nums[L - 1], Mmax = nums[M - 1];\\n\\n            for (int i = L + M; i < nums.length; ++i) {\\n  \\n                //Lmax is the case when L contiguous elements are taken first\\n                Lmax = Math.max(Lmax, nums[i - M] - nums[i - L - M]);\\n  \\n                //Mmax is the case when M contiguous elements are taken first\\n                Mmax = Math.max(Mmax, nums[i - L] - nums[i - L - M]);\\n                int x = Lmax + nums[i] - nums[i - M];\\n                int y = Mmax + nums[i] - nums[i - L];\\n  \\n                res = Math.max(res, Math.max(x, y));\\n            }\\n            return res;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784911,
                "title": "c-faster-than-100-0-ms-o-n-time-and-o-1-space-improve-from-dp-approach",
                "content": "Without loss of generality, consider M before L: (M= firstlength, L = secondLength)\\n1. DP approach:\\n\\tLet call:\\n\\t- sumL[i] is the sum of subarray length L and end in i so :\\n\\t\\t\\t\\t\\t\\t\\t\\t`sumL[i] = A[i-L+1] +....+A[i] = sumL[i-1] + A[i] - A[i-L];`\\n\\t- sumM is the same with sumL but length M.\\n\\t- dpM [i] is the largest sum subarray of length M in the segment 0 -> i, so :\\n\\t`dpM[i] = max (sumM[i], dpM [i-1]);`\\n\\n\\tthen for each position i the result can be  sumL[i] + dpM [i-L]:\\n\\t`res = max(res, sumL[i] + dpM[i-L]);`\\n2. Reduce memory:\\n\\tWe can combine all of DP  function by using one loop for all of them, and you can see that the dpM[i] update from dpM[i-1], sumL[i] and sumM[i] also update from previous (sumL[i-1] and sumM[i-1]), so we can use one variable for each of those instead using vector. \\n\\n\\t\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        return max(help(A, L, M), help(A, M, L));\\n    }\\n    \\n    int help(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        int sMMax = 0;\\n        int sL = 0, sM = 0;\\n        int res = 0;\\n        for(int i = 0; i < n; i++) {\\n            sL += A[i];\\n            if(i >= L) {\\n                sL -= A[i-L];\\n                sM += A[i-L];\\n            }\\n            if(i-L >= M) {\\n                sM -= A[i-L-M];\\n            }\\n            sMMax = max(sMMax, sM);\\n            res = max(res, sL + sMMax);      \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        return max(help(A, L, M), help(A, M, L));\\n    }\\n    \\n    int help(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        int sMMax = 0;\\n        int sL = 0, sM = 0;\\n        int res = 0;\\n        for(int i = 0; i < n; i++) {\\n            sL += A[i];\\n            if(i >= L) {\\n                sL -= A[i-L];\\n                sM += A[i-L];\\n            }\\n            if(i-L >= M) {\\n                sM -= A[i-L-M];\\n            }\\n            sMMax = max(sMMax, sM);\\n            res = max(res, sL + sMMax);      \\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760194,
                "title": "python-clean-o-n-98",
                "content": "We have to check two scenarious, subarray M is before L, or after. To be able to compute sums of subarrays faster we calculate prefix sum first:\\n```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        prefix = [0]\\n        maxl = maxm = summ = 0\\n        for x in A:\\n            prefix.append(prefix[-1] + x)\\n        \\n        for x in range(M, len(prefix) - L):\\n            maxm = max(maxm, prefix[x] - prefix[x - M])\\n            summ = max(summ, maxm + prefix[x + L] - prefix[x])\\n        \\n        for x in range(L, len(prefix) - M):\\n            maxl = max(maxl, prefix[x] - prefix[x - L])\\n            summ = max(summ, maxl + prefix[x + M] - prefix[x])\\n        \\n        return summ\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        prefix = [0]\\n        maxl = maxm = summ = 0\\n        for x in A:\\n            prefix.append(prefix[-1] + x)\\n        \\n        for x in range(M, len(prefix) - L):\\n            maxm = max(maxm, prefix[x] - prefix[x - M])\\n            summ = max(summ, maxm + prefix[x + L] - prefix[x])\\n        \\n        for x in range(L, len(prefix) - M):\\n            maxl = max(maxl, prefix[x] - prefix[x - L])\\n            summ = max(summ, maxl + prefix[x + M] - prefix[x])\\n        \\n        return summ\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225993,
                "title": "very-very-easy-to-understand-explanation-javascript-o-n-prefix-sum-sliding-window",
                "content": "Been struggling with this question for almost whole day (yes I\\'m stupid)\\nI\\'m not smart enough to understand those code posted in discuss (They are good! It\\'s not their problem, it\\'s my level isn\\'t there yet)\\nFinally managed to solve this question.\\n### Key point:\\n1. Calculate prefix sum of input\\n2. Maintain 2 sliding window, 1 for L sized subarray, 1 for M sized subarray\\n3. There are 2 cases, L subarray is before M subarray, and M subarray is before L subarray\\n4. Traverse through array, ***L before M***, find maxium value of L subarray and fix to it, add this value to M subarray, compare with result to find max\\n5. Traverse through array, ***M before L***, find maxium value of M subarray and fix to it, add this value to L subarray, compare with result to find max\\n\\nIf you found this useful, please upvote or comment, thank you!\\n\\nCode are documented:\\n```\\nvar maxSumTwoNoOverlap = function(A, L, M) {\\n    \\n    let prefixSum = []\\n    let result = 0\\n    \\n    for (let i=0; i<=A.length - 1; i++) {\\n        if (prefixSum.length == 0) {\\n            prefixSum.push(A[i])\\n        } else {\\n            prefixSum.push(A[i] + prefixSum[i - 1])\\n        }\\n    }\\n    /*\\n    Add a zero to first of prefix sum to conveniently calculate first appeared prefix sum\\n    For example: nums = [1,2,3,4,5,6,7], L=3, M=2\\n    normal prefix sum:  [1,3,6,10,15,21,28]\\n    If we want to calculate L subarray 1+2+3=6 \\n    According to the algorithm is: prefixSum[i - M] - prefixSum[i - M - L] which will be 10-1=9 which is incorrect\\n    But if we add 0 to prefix sum:  [0,1,3,6,10,15,21,28], it\\'ll be 6-0 = 6\\n    */\\n    prefixSum.unshift(0)\\n    \\n    let lMax = 0\\n    \\n    // 1. Maintain sliding window, L subarray before M subarray, it is guaranteed that two subarray won\\'t overlap\\n    for (let i=L+M; i<= prefixSum.length -1; i++) {\\n        // 2. Calculate L & M subarray sum\\n        const rangeLSum = prefixSum[i - M] - prefixSum[i - M - L]\\n        const rangeMSum = prefixSum[i] - prefixSum[i - M]\\n        \\n        // 3. Maintain current maxiumn of L sub-array in order to maximize the result the M sub-array\\n        lMax = Math.max(lMax, rangeLSum)\\n        result = Math.max(result, lMax + rangeMSum)\\n    }\\n    \\n    // Same as previous, just M sub-array appear before L subarray\\n    let mMax = 0 \\n    for (let i=L+M; i<= prefixSum.length -1; i++) {\\n        const rangeMSum = prefixSum[i - L] - prefixSum[i - M - L]\\n        const rangeLSum = prefixSum[i] - prefixSum[i - L]\\n        mMax = Math.max(mMax, rangeMSum)\\n        result = Math.max(result, mMax + rangeLSum)\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxSumTwoNoOverlap = function(A, L, M) {\\n    \\n    let prefixSum = []\\n    let result = 0\\n    \\n    for (let i=0; i<=A.length - 1; i++) {\\n        if (prefixSum.length == 0) {\\n            prefixSum.push(A[i])\\n        } else {\\n            prefixSum.push(A[i] + prefixSum[i - 1])\\n        }\\n    }\\n    /*\\n    Add a zero to first of prefix sum to conveniently calculate first appeared prefix sum\\n    For example: nums = [1,2,3,4,5,6,7], L=3, M=2\\n    normal prefix sum:  [1,3,6,10,15,21,28]\\n    If we want to calculate L subarray 1+2+3=6 \\n    According to the algorithm is: prefixSum[i - M] - prefixSum[i - M - L] which will be 10-1=9 which is incorrect\\n    But if we add 0 to prefix sum:  [0,1,3,6,10,15,21,28], it\\'ll be 6-0 = 6\\n    */\\n    prefixSum.unshift(0)\\n    \\n    let lMax = 0\\n    \\n    // 1. Maintain sliding window, L subarray before M subarray, it is guaranteed that two subarray won\\'t overlap\\n    for (let i=L+M; i<= prefixSum.length -1; i++) {\\n        // 2. Calculate L & M subarray sum\\n        const rangeLSum = prefixSum[i - M] - prefixSum[i - M - L]\\n        const rangeMSum = prefixSum[i] - prefixSum[i - M]\\n        \\n        // 3. Maintain current maxiumn of L sub-array in order to maximize the result the M sub-array\\n        lMax = Math.max(lMax, rangeLSum)\\n        result = Math.max(result, lMax + rangeMSum)\\n    }\\n    \\n    // Same as previous, just M sub-array appear before L subarray\\n    let mMax = 0 \\n    for (let i=L+M; i<= prefixSum.length -1; i++) {\\n        const rangeMSum = prefixSum[i - L] - prefixSum[i - M - L]\\n        const rangeLSum = prefixSum[i] - prefixSum[i - L]\\n        mMax = Math.max(mMax, rangeMSum)\\n        result = Math.max(result, mMax + rangeLSum)\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 287238,
                "title": "c-11l-ine",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        vector<int> sum = {0};\\n        for(auto x:A) sum.push_back(sum.back()+x);\\n        return max(help(sum, L, M), help(sum, M,L));\\n    }\\n    \\n    int help(const vector<int>& sum, int L, int M) {\\n        int maxSumL = sum[L], maxSumLM = sum[L+M];\\n        for(int i=L+M+1;i<sum.size();i++){\\n            int curSumL = sum[i-M] - sum[i-M-L];\\n            int curSumM = sum[i]-sum[i-M];\\n            maxSumL = max(maxSumL, curSumL);\\n            maxSumLM = max(maxSumLM, maxSumL + curSumM);\\n        }\\n        return maxSumLM;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        vector<int> sum = {0}",
                "codeTag": "Java"
            },
            {
                "id": 279433,
                "title": "java-two-pass",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int len = A.length;\\n        int[] sum = new int[len];\\n        sum[0] = A[0];\\n        \\n        for (int i = 1; i < len; ++i) {\\n            sum[i] = sum[i - 1] + A[i];\\n        }\\n        \\n        int res = 0;\\n        int Lmax = sum[L - 1], Mmax = sum[M - 1];\\n        for (int i = 0; i < len; ++i) {\\n            if (i >= L && i + M - 1 < len) {\\n                res = Math.max(res, Lmax + sum[i + M - 1] - sum[i - 1]);\\n            }\\n            \\n            if (i >= M && i + L - 1 < len) {\\n                res = Math.max(res, Mmax + sum[i + L - 1] - sum[i - 1]);\\n            }\\n            \\n            if (i >= L) {\\n                Lmax = Math.max(Lmax, sum[i] - sum[i - L]);\\n            }\\n            \\n            if (i >= M) {\\n                Mmax = Math.max(Mmax, sum[i] - sum[i - M]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int len = A.length;\\n        int[] sum = new int[len];\\n        sum[0] = A[0];\\n        \\n        for (int i = 1; i < len; ++i) {\\n            sum[i] = sum[i - 1] + A[i];\\n        }\\n        \\n        int res = 0;\\n        int Lmax = sum[L - 1], Mmax = sum[M - 1];\\n        for (int i = 0; i < len; ++i) {\\n            if (i >= L && i + M - 1 < len) {\\n                res = Math.max(res, Lmax + sum[i + M - 1] - sum[i - 1]);\\n            }\\n            \\n            if (i >= M && i + L - 1 < len) {\\n                res = Math.max(res, Mmax + sum[i + L - 1] - sum[i - 1]);\\n            }\\n            \\n            if (i >= L) {\\n                Lmax = Math.max(Lmax, sum[i] - sum[i - L]);\\n            }\\n            \\n            if (i >= M) {\\n                Mmax = Math.max(Mmax, sum[i] - sum[i - M]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541977,
                "title": "easy-c-solution-with-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int Max_Sum(vector<int>& nums, int firstLen, int secondLen) {\\n        \\n        \\n        // Just a Sliding Window thing of fixed window size\\n        \\n        int Left_Sum = 0, Right_Sum = 0;\\n        \\n        for(int i = 0; i < firstLen ; i++) Left_Sum += nums[i];\\n        for(int i = firstLen ; i < firstLen + secondLen ; i++) Right_Sum += nums[i];\\n        \\n        int Left_Max_Till = Left_Sum;\\n        \\n        int  ans = Left_Sum + Right_Sum; // answer\\n        \\n        int i = 0 , j = firstLen , k = firstLen + secondLen;\\n        \\n    \\n        \\n        while(k < nums.size()) {\\n            \\n            Left_Sum -= nums[i];\\n            Left_Sum += nums[j];\\n            \\n            Right_Sum -= nums[j];\\n            Right_Sum += nums[k];\\n            \\n           // All previous left subarrays before and including the current one\\n          // will never overlap with the current right subarray so we will be taking \\n          //the maximum value of sum among all left subarrys then will look for the \\n          // right subarry which will maximize the current total sum\\n\\n            Left_Max_Till = max(Left_Max_Till , Left_Sum);\\n            \\n            ans = max(ans , Left_Max_Till + Right_Sum);\\n            \\n            i++;\\n            j++;\\n            k++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        \\n        // As there are two possibilities \\n        // First, The subarray having size firstLen will be the left subarry\\n        // Second, The subarray having size secondLen will be the right subarray\\n        \\n        return max(Max_Sum(nums , firstLen , secondLen) , Max_Sum(nums , secondLen , firstLen));\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int Max_Sum(vector<int>& nums, int firstLen, int secondLen) {\\n        \\n        \\n        // Just a Sliding Window thing of fixed window size\\n        \\n        int Left_Sum = 0, Right_Sum = 0;\\n        \\n        for(int i = 0; i < firstLen ; i++) Left_Sum += nums[i];\\n        for(int i = firstLen ; i < firstLen + secondLen ; i++) Right_Sum += nums[i];\\n        \\n        int Left_Max_Till = Left_Sum;\\n        \\n        int  ans = Left_Sum + Right_Sum; // answer\\n        \\n        int i = 0 , j = firstLen , k = firstLen + secondLen;\\n        \\n    \\n        \\n        while(k < nums.size()) {\\n            \\n            Left_Sum -= nums[i];\\n            Left_Sum += nums[j];\\n            \\n            Right_Sum -= nums[j];\\n            Right_Sum += nums[k];\\n            \\n           // All previous left subarrays before and including the current one\\n          // will never overlap with the current right subarray so we will be taking \\n          //the maximum value of sum among all left subarrys then will look for the \\n          // right subarry which will maximize the current total sum\\n\\n            Left_Max_Till = max(Left_Max_Till , Left_Sum);\\n            \\n            ans = max(ans , Left_Max_Till + Right_Sum);\\n            \\n            i++;\\n            j++;\\n            k++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        \\n        // As there are two possibilities \\n        // First, The subarray having size firstLen will be the left subarry\\n        // Second, The subarray having size secondLen will be the right subarray\\n        \\n        return max(Max_Sum(nums , firstLen , secondLen) , Max_Sum(nums , secondLen , firstLen));\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913234,
                "title": "o-n-thought-process-java",
                "content": "The below documents a thought process to arrive at a solution with `~O(N)` time and `~O(N)` space where `N` is the length if the input array.\\n\\nA brute force approach would be:\\n\\n* pick a starting position for L, calculate the sum\\n* pick a starting position for M, calculate the sum\\n* calculate the sum of the sums. Keep track of the maximum thus far.\\n* Repeat by picking other starting positions\\n\\nHow can we do better? One bottleneck is that to calculate the sum of subarray with a length `M`, it takes `M` array access, and we have to repeat the process multiple times. We can get around it by doing using a previously calculated sum to calculate a new sum. The idea is similar to rolling hash in Rabin-Karp substring matching algorithm.\\n\\nLet\\'s define two arrays `Ls` and `Ms`, where `i`th value is the sum of the subarray of size `L` and `M`, respectively, that begins at `i`.\\n\\nFor an input of `[3,8,1,3,2,1,8,9,0]`, `L=3`, `M=2`,  let\\'s consider `Ls` and `Ms`.\\n\\n| A | 3| 8  | 1  | 3  | 2  | 1  | 8  | 9  | 0  |  \\n|---|---|---|---|---|---|---|---|---|---|\\n| Ls | 12  | 12  |6   | 6  | 11  | 18  | 17  | 0  | 0  |\\n| Ms |  11 | 9  | 4  | 5  | 3  | 9  | 17  |9   |0   |\\n\\nHow can we calculate those entries efficiently? If we know the current entry at `Ls[i]`, the next entry is `Ls[i] - A[i-1] + A[i+L-1]`. We discard the leading value, and add the new value at the tail.\\n\\nGiven `Ls` and `Ms`, we can find our answer by the following process\\n\\n* Pick a position in `Ls[i]`, and find the maximum value in `Ms[i+L ... end]`. Add values.\\n* Pick a position in `Ms[i]`, and find the maximum value in `Ls[i+L ... end]`. Add values.\\n\\nWhat is the bottleneck? The bottleneck is that, to find the maximum value in the remaining eligible subarrays, we need to keep iterating. How can we do better?\\n\\nLet\\'s simply keep track of the maximum `Ms` and `Ls` in `Ms[i...end]` and `Ls[i...end]`. We can use an array to keep track of these values. Let\\'s call them `mmax` and `lmax`.\\n\\n| A | 3| 8  | 1  | 3  | 2  | 1  | 8  | 9  | 0  |  \\n|---|---|---|---|---|---|---|---|---|---|\\n| Ls | 12  | 12  |6   | 6  | 11  | 18  | 17  | 0  | 0  |\\n| Ms |  11 | 9  | 4  | 5  | 3  | 9  | 17  |9   |0   |\\n| lmax |  18 | 18  | 18  | 18  | 18  | 17  | 0  | 0   |0   |\\n| mmax |  17 | 17  | 17  | 17  | 17  |17  | 9  |0   |0   |\\n\\nNow, we can pick a starting position of subarray with length `L`, and instantly locate two things that we need to calculate the possible answer:\\n\\n* the sum of the subarray of length `L`, that begins at the chosen position\\n* the maximum subarray sum for the eligible subarray with length `M`.\\n\\nWe can apply the same logic by for fixing a starting position of subarray with length `M`.\\n\\nBelow is an implementation of this idea.\\n\\n```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (L + M > n) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int[] Ls = new int[n];\\n        int[] Ms = new int[n];\\n        \\n        int lSum = 0;\\n        int mSum = 0;\\n        \\n        for (int i = 0; i <= n - L; i++) {\\n            if (i == 0) {\\n                for (int j = 0; j < L; j++) {\\n                    lSum += A[j];\\n                }\\n            } else {\\n                lSum = lSum - A[i-1] + A[i+L-1];\\n            }\\n            \\n            Ls[i] = lSum;\\n        }\\n        \\n        for (int i = 0; i <= n - M; i++) {\\n            if (i == 0) {\\n                for (int j = 0; j < M; j++) {\\n                    mSum += A[j];\\n                }\\n            } else {\\n                mSum = mSum - A[i-1] + A[i+M-1];\\n            }\\n            \\n            Ms[i] = mSum;\\n        }\\n        \\n        int[] lmax = new int[n+1];\\n        int[] mmax = new int[n+1];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            lmax[i] = Math.max(lmax[i+1], Ls[i]);\\n            mmax[i] = Math.max(mmax[i+1], Ms[i]);\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i <= n - L - 1; i++) {\\n            ans = Math.max(ans, Ls[i] + mmax[i+L]);\\n        }\\n        for (int i = 0; i <= n - M - 1; i++) {\\n            ans = Math.max(ans, Ms[i] + lmax[i+M]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```\\n\\nLet `N` be the length of `A`, then the code above takes `~O(N)` time and `~O(N)` space.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        if (n == 0) {\\n            return 0;\\n        }\\n        if (L + M > n) {\\n            throw new IllegalArgumentException();\\n        }\\n        \\n        int[] Ls = new int[n];\\n        int[] Ms = new int[n];\\n        \\n        int lSum = 0;\\n        int mSum = 0;\\n        \\n        for (int i = 0; i <= n - L; i++) {\\n            if (i == 0) {\\n                for (int j = 0; j < L; j++) {\\n                    lSum += A[j];\\n                }\\n            } else {\\n                lSum = lSum - A[i-1] + A[i+L-1];\\n            }\\n            \\n            Ls[i] = lSum;\\n        }\\n        \\n        for (int i = 0; i <= n - M; i++) {\\n            if (i == 0) {\\n                for (int j = 0; j < M; j++) {\\n                    mSum += A[j];\\n                }\\n            } else {\\n                mSum = mSum - A[i-1] + A[i+M-1];\\n            }\\n            \\n            Ms[i] = mSum;\\n        }\\n        \\n        int[] lmax = new int[n+1];\\n        int[] mmax = new int[n+1];\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            lmax[i] = Math.max(lmax[i+1], Ls[i]);\\n            mmax[i] = Math.max(mmax[i+1], Ms[i]);\\n        }\\n\\n        int ans = 0;\\n        for (int i = 0; i <= n - L - 1; i++) {\\n            ans = Math.max(ans, Ls[i] + mmax[i+L]);\\n        }\\n        for (int i = 0; i <= n - M - 1; i++) {\\n            ans = Math.max(ans, Ms[i] + lmax[i+M]);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489581,
                "title": "java-easy-to-understand-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int sums[] = new int[A.length+1];\\n        \\n        for(int i=1;i<=A.length;i++)\\n            sums[i] = A[i-1]+sums[i-1];\\n        \\n        int maxLval = 0;\\n        int ans=0;\\n        for(int i=L;i<=A.length-M;i++)\\n        {\\n            maxLval = Math.max(maxLval,sums[i]-sums[i-L]);\\n            ans = Math.max(ans,sums[i+M]-sums[i]+maxLval);\\n        }\\n        int maxRval = 0 ;\\n        for(int i=M;i<=A.length-L;i++)\\n        {\\n            maxRval = Math.max(maxRval,sums[i]-sums[i-M]);\\n            ans = Math.max(ans,sums[i+L]-sums[i]+maxRval);\\n        }\\n        return ans;\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int sums[] = new int[A.length+1];\\n        \\n        for(int i=1;i<=A.length;i++)\\n            sums[i] = A[i-1]+sums[i-1];\\n        \\n        int maxLval = 0;\\n        int ans=0;\\n        for(int i=L;i<=A.length-M;i++)\\n        {\\n            maxLval = Math.max(maxLval,sums[i]-sums[i-L]);\\n            ans = Math.max(ans,sums[i+M]-sums[i]+maxLval);\\n        }\\n        int maxRval = 0 ;\\n        for(int i=M;i<=A.length-L;i++)\\n        {\\n            maxRval = Math.max(maxRval,sums[i]-sums[i-M]);\\n            ans = Math.max(ans,sums[i+L]-sums[i]+maxRval);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291528,
                "title": "c-prefix-sum-and-then-trying-all-combinations",
                "content": "## Approach\\nThis question in itself is very easy to solve naively, but the bottleneck lies in the operation of calculating the sum of the subarrays.\\nThis O(n) operation can be made O(1) by using a prefix sum array.\\nPrefix sum is a common approach which makes taking sum of subarrays very easy and fast. There are n+1 elements in the array, each corresponding to the sum of all the elements coming before that index in the array.\\n\\nAny element of the prefix sum array follows this recurrence relation:\\n```prefixSum[i] = prefixSum[i-1] + nums[i-1], prefixSum[0] = 0```\\n\\nNow any subarray sum can be calculated in O(1).\\nLet the subarray be from index i to j (inclusive). Then the subarray sum is given as ```sum  = prefixSum[j+1] - prefixSum[i+1]```.\\n\\nNow we iterate over the array and choose our l-length subarray first. Then we search for the maximum sum of any m-length subarray to the left or to the right of the current l-subarray. Then we take the maximum of lsum + rsum over these cases, and return the answer.\\n<br />\\n\\n## Code\\nThe code for the above approach is given as follows:\\n```\\nint maxSumTwoNoOverlap(vector<int>& nums, int l, int m) {\\n\\tint n = nums.size();\\n\\tvector<int> prefixSum(n+1, 0);\\n\\tint maxSum = 0;\\n\\t\\n\\t//building the prefix sums\\n\\tprefixSum[0] = 0;\\n\\tfor(int i = 1; i<=n; i++) {\\n\\t\\tprefixSum[i] = prefixSum[i-1] + nums[i-1];\\n\\t}\\n\\t\\n\\t//selecting the l length subarray\\n\\tfor(int i = 0; i<=n-l; i++) {\\n\\t\\tint lsum = prefixSum[i+l] - prefixSum[i];\\n\\t\\t\\n\\t\\t//looking left\\n\\t\\tfor(int j = 0; j<=i-m; j++) {\\n\\t\\t\\tint msum = prefixSum[j+m] - prefixSum[j];\\n\\t\\t\\tmaxSum = max(maxSum, lsum + msum);\\n\\t\\t}\\n\\t\\t\\n\\t\\t//looking right \\n\\t\\tfor(int j = i+l; j<=n-m; j++) {\\n\\t\\t\\tint msum = prefixSum[j+m] - prefixSum[j];\\n\\t\\t\\tmaxSum = max(maxSum, lsum + msum);\\n\\t\\t}\\n\\t}\\n\\treturn maxSum;\\n}\\n```\\n\\nFeel free to ask any doubts or suggest any corrections/improvements in the comments. Please upvote if you liked this post.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```prefixSum[i] = prefixSum[i-1] + nums[i-1], prefixSum[0] = 0```\n```sum  = prefixSum[j+1] - prefixSum[i+1]```\n```\\nint maxSumTwoNoOverlap(vector<int>& nums, int l, int m) {\\n\\tint n = nums.size();\\n\\tvector<int> prefixSum(n+1, 0);\\n\\tint maxSum = 0;\\n\\t\\n\\t//building the prefix sums\\n\\tprefixSum[0] = 0;\\n\\tfor(int i = 1; i<=n; i++) {\\n\\t\\tprefixSum[i] = prefixSum[i-1] + nums[i-1];\\n\\t}\\n\\t\\n\\t//selecting the l length subarray\\n\\tfor(int i = 0; i<=n-l; i++) {\\n\\t\\tint lsum = prefixSum[i+l] - prefixSum[i];\\n\\t\\t\\n\\t\\t//looking left\\n\\t\\tfor(int j = 0; j<=i-m; j++) {\\n\\t\\t\\tint msum = prefixSum[j+m] - prefixSum[j];\\n\\t\\t\\tmaxSum = max(maxSum, lsum + msum);\\n\\t\\t}\\n\\t\\t\\n\\t\\t//looking right \\n\\t\\tfor(int j = i+l; j<=n-m; j++) {\\n\\t\\t\\tint msum = prefixSum[j+m] - prefixSum[j];\\n\\t\\t\\tmaxSum = max(maxSum, lsum + msum);\\n\\t\\t}\\n\\t}\\n\\treturn maxSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 288993,
                "title": "java-dp-solution",
                "content": "Extend Kadane\\'s algorithm for two non-overlapping subarrays with L & M in length\\n```\\n    /*\\n          |---L--| <- prior maxL\\n\\t\\t     |---L--| <- sum[i-M]-sum[i-M-L]\\n                    |---M----| \\n--------------------|--------i\\n\\n\\n         |--M---| <- maxM  at i-L position \\n                    |---L----| \\n--------------------|--------i\\n    */\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n     if (A==null || A.length < L+M) return 0;   \\n     int []sum = new int[A.length];\\n    \\n     // leetcode 53, Maximum Subarray (Kadane\\'s Algorithm) \\n     sum[0]=A[0];    \\n     for(int i=1; i< A.length;i++){\\n        sum[i] = Math.max(A[i],sum[i-1] + A[i]);  \\n     }\\n\\n     int maxL = sum[L-1]; // initial value\\n     int maxM = sum[M-1]; // initial value\\n     int res = sum[L+M-1];  // initial value\\n     for(int i=L+M; i < sum.length; i++){\\n        maxL = Math.max(maxL, sum[i-M]-sum[i-M-L]); // maxL at i-M position\\n        maxM = Math.max(maxM, sum[i-L]-sum[i-M-L]); //maxM at i-L position  \\n        res = Math.max(res, Math.max(maxL + sum[i] - sum[i-M],\\n                                     maxM + sum[i] - sum[i-L]));\\n     }   \\n     return res;   \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    /*\\n          |---L--| <- prior maxL\\n\\t\\t     |---L--| <- sum[i-M]-sum[i-M-L]\\n                    |---M----| \\n--------------------|--------i\\n\\n\\n         |--M---| <- maxM  at i-L position \\n                    |---L----| \\n--------------------|--------i\\n    */\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n     if (A==null || A.length < L+M) return 0;   \\n     int []sum = new int[A.length];\\n    \\n     // leetcode 53, Maximum Subarray (Kadane\\'s Algorithm) \\n     sum[0]=A[0];    \\n     for(int i=1; i< A.length;i++){\\n        sum[i] = Math.max(A[i],sum[i-1] + A[i]);  \\n     }\\n\\n     int maxL = sum[L-1]; // initial value\\n     int maxM = sum[M-1]; // initial value\\n     int res = sum[L+M-1];  // initial value\\n     for(int i=L+M; i < sum.length; i++){\\n        maxL = Math.max(maxL, sum[i-M]-sum[i-M-L]); // maxL at i-M position\\n        maxM = Math.max(maxM, sum[i-L]-sum[i-M-L]); //maxM at i-L position  \\n        res = Math.max(res, Math.max(maxL + sum[i] - sum[i-M],\\n                                     maxM + sum[i] - sum[i-L]));\\n     }   \\n     return res;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2079844,
                "title": "c-single-pass-o-n-constant-memory-o-1-sliding-window-easy-to-understand-solution",
                "content": "I read a bunch of solutions here and came up with this idea. It\\'s easy to understand. Have to say though that this was a tough nut to crack :) Kudos to people who figured this out on their own.\\n\\nThe basic idea is that the solution to a given input can be either of the following two case:\\n1. The first length subarray could be on the left side and the second length subarray on the right side.\\n\\n......|firstLength|....|secondLength|....\\n\\n2. The first length subarray could be on the right side and the second length subarray on the left side.\\n\\n.....|secondLength|....|firstLength|....\\n\\nWe have to check both of these cases as the answer could be one of these. To check either of these cases, what we can do is to slide the two windows together. Suppose L1 is the firstLength window on the left and M1 is the secondLength window on the right.\\n\\nThen it is possible to find the max L1 + M1  subarrays in linear time. We just have to keep track of the maximum window to the left and every time we update the right most window, we just have to add the M1 subarray to the max L1 window we have seen so far.\\n\\nNow, checking both the cases. First case where first length subarray is on the left and the second length subarray is on the right as well as the second case where first length subarray is on the right and second length subarray is on the left, can be done simultaneously. Meaning the whole problem can be solved in linear time.\\n\\nCode:\\n```\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int L1 = 0, M1 = 0, M2 = 0, L2 = 0;        \\n        int n = nums.size();\\n\\n       // This is our initial setup.\\n      // |firstLen||secondLen|...................|secondLen||firstLen|\\n\\n\\t\\t// Add up the left most window first.\\n       // |firstLen|.................................\\n        for(int i = 0; i < firstLen; i++) {\\n            L1 += nums[i];\\n        }\\n        // Next we add up the first right window.\\n\\t\\t// .......|secondLen|......................\\n        for(int i = firstLen; i < firstLen + secondLen; i++) {\\n            M1 += nums[i];\\n        }\\n        \\n\\t\\t// Next we add up the right most window.\\n\\t\\t//........................................|firstLen|\\n        for(int i = n - firstLen; i < n; i++) {\\n            L2 += nums[i];\\n        }\\n        \\n\\t\\t// Finally, we add up the second right window. \\n\\t\\t// ............................|secondLen|..............\\n        for(int i = n - firstLen - secondLen; i < n - firstLen; i++) {\\n            M2 += nums[i];\\n        }\\n        \\n        int lmax = L1, rmax = L2, res = max(L1 + M1, L2 + M2);\\n        for(int i = firstLen + secondLen; i < n; i++) {\\n\\t\\t   // we have moved one element to the right.\\n\\t\\t   // |oldElement||firstLen||secondLen||nextElement|.............................\\n\\t\\t   // we have to update our slidding windows accordingly.\\n           // Each of these windows need to add an element to the right and remove an element from the left.\\n            L1 += nums[i - secondLen] - nums[i - secondLen - firstLen];\\n            M1 += nums[i] - nums[i - secondLen];\\n            \\n            \\n            lmax = max(L1, lmax);\\n            res = max(res, lmax + M1);\\n            \\n\\t\\t\\t// As we have moved one element to the right, we can use the same i to say that our second case has also moved one element to the left.\\n\\t\\t\\t// ...................|nextElement||secondLen||firstLen||oldElement|\\t\\t\\t\\n\\t\\t   // we have to update our slidding windows accordingly.\\n\\t\\t   // Each of these windows need to add an element to the left and remove an element from the right.\\n            L2 += nums[n - i - 1 + secondLen] - nums[n - i + firstLen + secondLen - 1];\\n            M2 += nums[n - i - 1] - nums[n - i + secondLen - 1];\\n            \\n            rmax = max(L2, rmax);\\n            res = max(res, rmax + M2);\\n        }\\n        return res;  \\n    }\\n```\\n\\nThat\\'s it. Simple solution :) Wish I could take credit for it.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int L1 = 0, M1 = 0, M2 = 0, L2 = 0;        \\n        int n = nums.size();\\n\\n       // This is our initial setup.\\n      // |firstLen||secondLen|...................|secondLen||firstLen|\\n\\n\\t\\t// Add up the left most window first.\\n       // |firstLen|.................................\\n        for(int i = 0; i < firstLen; i++) {\\n            L1 += nums[i];\\n        }\\n        // Next we add up the first right window.\\n\\t\\t// .......|secondLen|......................\\n        for(int i = firstLen; i < firstLen + secondLen; i++) {\\n            M1 += nums[i];\\n        }\\n        \\n\\t\\t// Next we add up the right most window.\\n\\t\\t//........................................|firstLen|\\n        for(int i = n - firstLen; i < n; i++) {\\n            L2 += nums[i];\\n        }\\n        \\n\\t\\t// Finally, we add up the second right window. \\n\\t\\t// ............................|secondLen|..............\\n        for(int i = n - firstLen - secondLen; i < n - firstLen; i++) {\\n            M2 += nums[i];\\n        }\\n        \\n        int lmax = L1, rmax = L2, res = max(L1 + M1, L2 + M2);\\n        for(int i = firstLen + secondLen; i < n; i++) {\\n\\t\\t   // we have moved one element to the right.\\n\\t\\t   // |oldElement||firstLen||secondLen||nextElement|.............................\\n\\t\\t   // we have to update our slidding windows accordingly.\\n           // Each of these windows need to add an element to the right and remove an element from the left.\\n            L1 += nums[i - secondLen] - nums[i - secondLen - firstLen];\\n            M1 += nums[i] - nums[i - secondLen];\\n            \\n            \\n            lmax = max(L1, lmax);\\n            res = max(res, lmax + M1);\\n            \\n\\t\\t\\t// As we have moved one element to the right, we can use the same i to say that our second case has also moved one element to the left.\\n\\t\\t\\t// ...................|nextElement||secondLen||firstLen||oldElement|\\t\\t\\t\\n\\t\\t   // we have to update our slidding windows accordingly.\\n\\t\\t   // Each of these windows need to add an element to the left and remove an element from the right.\\n            L2 += nums[n - i - 1 + secondLen] - nums[n - i + firstLen + secondLen - 1];\\n            M2 += nums[n - i - 1] - nums[n - i + secondLen - 1];\\n            \\n            rmax = max(L2, rmax);\\n            res = max(res, rmax + M2);\\n        }\\n        return res;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 402171,
                "title": "c-0ms-o-n-solution-for-1031-maximum-sum-of-two-non-overlapping-subarrays",
                "content": "This is a nice problem but it is nicer when we try to do it in O(n). \\n\\nIt can be confusing to some who are trying to achieve O(n). So, I am going to explain my code a bit.\\n\\nWe make sure L < M. If not, we swap them. Next, we store the following in the arrays:\\n  \\n  mtms[i] - sum of M window i.e { p[ i - M - 1 ] ... p[ i ] }\\n  ltms[i] - sum of L window i.e { p[ i - L - 1 ] ... p[ i ] }\\n  mtmx[i] - maximum sum of M window seen so far till index i\\n  ltmx[i] - maximum sum of L window seen so far till index i\\n  \\n  \\n For every iteration, in the line:\\n \\n ```\\n mx = max(mx, max(mtms[i] + ltmx[i - M], ltms[i] + mtmx[i - L]));\\n ```\\n \\nwe simply compute the max of:\\n\\n  * sum of current M window + max sum of L window seen before start of M window\\n  * sum of current L window + max sum of M window seen before start of L window\\n\\nand store that in mx. The max mx becomes the answer. \\n\\nNote that we could make the arrays smaller i.e to size M+1 and use modulo - making space complexity O(M+1).\\n\\nAs an example, let\\'s take the test case:\\n\\n```\\n[2,1,5,6,0,9,5,0,3,8]\\n4\\n3\\n```\\n\\nand uncomment the cout in the code. We will see the columns i, mtms[i], ltms[i], mtmx[i] and ltmx[i] printed as follows:\\n\\n```\\n0  0  0  0  0\\n1  0  0  0  0\\n2  0  8  0  8\\n3 14 12 14 12\\n4 12 11 14 12\\n5 20 15 20 15x\\n6 20 14 20y15\\n7 14 14 20 15\\n8 17  8 20 15\\n9 16x11y20 15\\n```\\n\\nI have marked two pairs - x and y in the cout output. (mtms[9] =) 16 + (ltmx[9-M] =) 15 OR (ltms[9]=) 11 + (mtmx[9-L]=) 20. They are the following two pairs ending at index 9 & 5 and 9 & 6 that yield 31 which is the answer.\\n\\n```\\n[2, 1, 5, 6, 0, 9, 5, 0, 3, 8]\\n          --15---  ----16----\\n            L          M\\n\\n[2, 1, 5, 6, 0, 9, 5, 0, 3, 8]\\n          -20-------  --11---\\n           M            L\\n```\\n\\nHopefully it helps some folks. Rock on!\\n\\n```\\n/* LeetCode: tktripathy */\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& p, int L, int M) {\\n        int sz = p.size(), lt = 0, ltm = 0, mt = 0, mtm = 0, res = 0, mx = 0;\\n        if (L > M) { int t = M; M = L; L = t; }\\n        int mtmx[sz], ltmx[sz], mtms[sz], ltms[sz];\\n        for (int i = 0; i < sz; i++) {\\n            p[i] = p[i] + (i ? p[i - 1] : 0);\\n            if (i >= M - 1) { mt = p[i] - (i < M ? 0 : p[i - M]); mtm = max(mtm, mt); }\\n            if (i >= L - 1) { lt = p[i] - (i < L ? 0 : p[i - L]); ltm = max(ltm, lt); }\\n            mtms[i] = mt; ltms[i] = lt; mtmx[i] = mtm; ltmx[i] = ltm;\\n            // cout << i << \" \" << mt << \" \" << lt << \" \" << mtm << \" \" << ltm << endl;\\n            if (i >= M) {\\n                mx = max(mx, max(mtms[i] + ltmx[i - M], ltms[i] + mtmx[i - L]));\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n mx = max(mx, max(mtms[i] + ltmx[i - M], ltms[i] + mtmx[i - L]));\\n ```\n```\\n[2,1,5,6,0,9,5,0,3,8]\\n4\\n3\\n```\n```\\n0  0  0  0  0\\n1  0  0  0  0\\n2  0  8  0  8\\n3 14 12 14 12\\n4 12 11 14 12\\n5 20 15 20 15x\\n6 20 14 20y15\\n7 14 14 20 15\\n8 17  8 20 15\\n9 16x11y20 15\\n```\n```\\n[2, 1, 5, 6, 0, 9, 5, 0, 3, 8]\\n          --15---  ----16----\\n            L          M\\n\\n[2, 1, 5, 6, 0, 9, 5, 0, 3, 8]\\n          -20-------  --11---\\n           M            L\\n```\n```\\n/* LeetCode: tktripathy */\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& p, int L, int M) {\\n        int sz = p.size(), lt = 0, ltm = 0, mt = 0, mtm = 0, res = 0, mx = 0;\\n        if (L > M) { int t = M; M = L; L = t; }\\n        int mtmx[sz], ltmx[sz], mtms[sz], ltms[sz];\\n        for (int i = 0; i < sz; i++) {\\n            p[i] = p[i] + (i ? p[i - 1] : 0);\\n            if (i >= M - 1) { mt = p[i] - (i < M ? 0 : p[i - M]); mtm = max(mtm, mt); }\\n            if (i >= L - 1) { lt = p[i] - (i < L ? 0 : p[i - L]); ltm = max(ltm, lt); }\\n            mtms[i] = mt; ltms[i] = lt; mtmx[i] = mtm; ltmx[i] = ltm;\\n            // cout << i << \" \" << mt << \" \" << lt << \" \" << mtm << \" \" << ltm << endl;\\n            if (i >= M) {\\n                mx = max(mx, max(mtms[i] + ltmx[i - M], ltms[i] + mtmx[i - L]));\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 951563,
                "title": "c-easy-implementation-using-prefix-sum",
                "content": "Two Cases :\\n  1.) lMax is the case when L contiguous elements are taken first\\n  2.) mMax is the case when M contiguous elements are taken first\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        for(int i = 1; i < n; i++)\\n            A[i] += A[i-1];\\n        int res = A[L+M-1], lMax = A[L-1], mMax = A[M-1];\\n        for(int i = L+M; i < n; i++){\\n            lMax = max(lMax, A[i-M] - A[i - (L+M)]);\\n            mMax = max(mMax, A[i-L] - A[i - (L+M)]);\\n            res = max(res, max(lMax + A[i] - A[i-M], mMax + A[i] - A[i-L]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        for(int i = 1; i < n; i++)\\n            A[i] += A[i-1];\\n        int res = A[L+M-1], lMax = A[L-1], mMax = A[M-1];\\n        for(int i = L+M; i < n; i++){\\n            lMax = max(lMax, A[i-M] - A[i - (L+M)]);\\n            mMax = max(mMax, A[i-L] - A[i - (L+M)]);\\n            res = max(res, max(lMax + A[i] - A[i-M], mMax + A[i] - A[i-L]));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863374,
                "title": "simple-easy-to-understand-verbose-python-code-with-comments",
                "content": "```\\nclass Solution(object):\\n    def maxSumTwoNoOverlap(self, A, L, M):\\n        \"\"\"\\n        :type A: List[int]\\n        :type L: int\\n        :type M: int\\n        :rtype: int\\n        \"\"\"\\n        nums = A[:] # We don\\'t really need to deepcopy here, we can use A instead of nums.\\n        for i in range(1,len(A)):\\n            nums[i]+=nums[i-1] # nums value at index i is the total sum from beginning to index i\\n        # initializing the variables\\n        lmax, mmax,res = 0,0,0\\n        nums.insert(0,0) # adding a dummy 0 value at the beginning of the list to make boundary coding simpler\\n        # L before M. We keep on moving the M sized window and for each position check the max sum valued L window till now and update the total value for each move\\n        for i in range(L+1, len(nums)-M+1): # check the boundaries by drawing array diag on paper with some example\\n            msum = nums[i+M-1] - nums[i-1]\\n            lmax = max(lmax, nums[i-1]-nums[i-1-L])\\n            res = max(res,msum+lmax)\\n        # M before L. We keep on moving L sized window at each step and calculate the max sum val of M sized windows lying before it.and update the total value for each move\\n        for i in range(M+1, len(nums)-L+1): # check the boundaries by drawing array diag on paper with some example\\n            lsum = nums[i+L-1] - nums[i-1]\\n            mmax = max(mmax, nums[i-1]-nums[i-1-M])\\n            res = max(res,lsum+mmax)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def maxSumTwoNoOverlap(self, A, L, M):\\n        \"\"\"\\n        :type A: List[int]\\n        :type L: int\\n        :type M: int\\n        :rtype: int\\n        \"\"\"\\n        nums = A[:] # We don\\'t really need to deepcopy here, we can use A instead of nums.\\n        for i in range(1,len(A)):\\n            nums[i]+=nums[i-1] # nums value at index i is the total sum from beginning to index i\\n        # initializing the variables\\n        lmax, mmax,res = 0,0,0\\n        nums.insert(0,0) # adding a dummy 0 value at the beginning of the list to make boundary coding simpler\\n        # L before M. We keep on moving the M sized window and for each position check the max sum valued L window till now and update the total value for each move\\n        for i in range(L+1, len(nums)-M+1): # check the boundaries by drawing array diag on paper with some example\\n            msum = nums[i+M-1] - nums[i-1]\\n            lmax = max(lmax, nums[i-1]-nums[i-1-L])\\n            res = max(res,msum+lmax)\\n        # M before L. We keep on moving L sized window at each step and calculate the max sum val of M sized windows lying before it.and update the total value for each move\\n        for i in range(M+1, len(nums)-L+1): # check the boundaries by drawing array diag on paper with some example\\n            lsum = nums[i+L-1] - nums[i-1]\\n            mmax = max(mmax, nums[i-1]-nums[i-1-M])\\n            res = max(res,lsum+mmax)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596595,
                "title": "c-o-n-solution-using-prefix-sum",
                "content": "The approach here is based on sliding a window by fixing L sized and M sized subarrays. \\n1. Keep a **prefix sum** array to get the sums in O(1) when answer is calculated. \\n2. Loop from **i = (L + M) to Array.size()**\\n\\t * Fix an **M** sized subarray at index **i - 1**. Find the maximum sized **L** sized subarray before the fixed subarray.\\n\\t * Fix an **L** sized subarray at index **i - 1**. Find the maximum sized **M** sized subarray before the fixed subarray.\\n\\t * Update result with maximum sum of **L** and **M** sized subarray uptil now.\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n\\t\\t// maximum sum of L sized, maximum sum of M sized, maximum of (L sized + M sized) \\n        int lMax, mMax, result;\\n        vector<int> prefixSum(A.size());\\n        \\n\\t\\t// fill the prefix sum array\\n        for(int i = 0; i < A.size(); i++) {\\n            prefixSum[i] = (i == 0) ? A[i] : prefixSum[i - 1] + A[i];\\n        }\\n        \\n        lMax = mMax = result = INT_MIN;\\n        \\n        for(int i = (L + M); i <= A.size(); i++) {\\n\\t\\t\\t// fix M sized subarray, and find maximum sum of L sized subarray uptil now\\n            lMax = (i == (L + M)) ? prefixSum[L - 1] : max(lMax, prefixSum[i - M - 1] - prefixSum[i - L - M - 1]);\\n\\t\\t\\t// fix L sized subarray, and find maximum sum of M sized subarray uptil now\\n            mMax = (i == (L + M)) ? prefixSum[M - 1] : max(mMax, prefixSum[i - L - 1] - prefixSum[i - L - M - 1]);\\n            \\n\\t\\t\\t// update maximum of (L sized + M sized) uptil now\\n            result = max({result, \\n                          prefixSum[i - 1] - prefixSum[i - L - 1] + mMax,\\n                          prefixSum[i - 1] - prefixSum[i - M - 1] + lMax\\n                         });\\n        }\\n        \\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n\\t\\t// maximum sum of L sized, maximum sum of M sized, maximum of (L sized + M sized) \\n        int lMax, mMax, result;\\n        vector<int> prefixSum(A.size());\\n        \\n\\t\\t// fill the prefix sum array\\n        for(int i = 0; i < A.size(); i++) {\\n            prefixSum[i] = (i == 0) ? A[i] : prefixSum[i - 1] + A[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 736925,
                "title": "clean-python-high-speed-o-n-time-o-1-space",
                "content": "**Clean Python | High Speed | O(n) time, O(1) space**\\n\\n**A) High Speed Version: O(n) time, O(1) space**\\n\\nThis Solution is based on the auxiliary function \"Trail\", which simulates two sliding windows (a,b) running one after the other. The best sum (for the configuration considered) is found in O(n) time and O(1) space by remembering the best result for the sliding window \"A\", and adding this to the current result for the sliding window \"b\".\\n\\nThe global answer is the maximum value after considering the configurations Trail(L,M) and Trail(M,L).\\n\\n```\\nclass Solution:\\n    def trail(self,A,a,b):\\n        sa = ba = sum(A[:a]) # sum from beggining\\n        sb = sum(A[a:b+a])   # sum right after \"sa\"\\n        best = ba+sb\\n        for i in range(b+a,len(A)):\\n            sb += A[i]  - A[i-b]\\n            sa += A[i-b]- A[i-b-a]\\n            ba = max( ba, sa ) # window sum of sb runs with best from \"sa\"\\n            if ba+sb > best:\\n                best = ba+sb\\n        return best\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        trail = self.trail\\n        return max( trail(A,L,M) , trail(A,M,L) )\\n```\\n\\n**B) Modularized Code: O(n) time/space**\\n\\nThis is an early attempt that I made for this problem. It assumes that the array is split in two pieces, and we wish to find the best sums for siliding windows of sizes \"a\" and \"b\" at each side. This process uses 4 auxiliar arrays, but it manages to run in linear time :). The sizes of the sliding windows (a,b) are flipped as before between (L,M) and (M,L).\\n\\nDespite the extra space usage, it achieves a High Speed rating on LeetCode. It also includes a nice Poem to understand the indexing. I hope the code is helpful. Cheers,\\n```\\ndef winsum(A,k):\\n    s   = sum(A[:k])\\n    arr = [s]\\n    for i in range(k,len(A)):\\n        s += A[i] - A[i-k]\\n        arr.append(s)\\n    return arr\\n#\\ndef maxleft(arr):\\n    best = [arr[0]]\\n    for x in arr[1:]:\\n        best.append( max(x,best[-1]) )\\n    return best\\n#\\ndef maxright(arr):\\n    return maxleft(arr[::-1])[::-1]\\n#\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        # \\n        aL= winsum(A,L)\\n        aM= winsum(A,M)\\n        #\\n        best = 0\\n        #\\n        arr1,a = aL,L\\n        arr2,b = aM,M\\n        #\\n        for _ in range(2):\\n            best1,best2 = maxleft(arr1),maxright(arr2)\\n            for i,s1 in enumerate(best1):\\n                # ******** Poem ********\\n                # The first sums at all are [0,a-1], and [0,b-1]\\n                # To get stated with sum = [0,a-1], we would need a second sum [a,a+b-1]\\n                # for the current sum [i,i+a-1], we would need [i+a,i+a+b-1]\\n                # so we need arr2[i+a]\\n                if i+a < len(best2):\\n                    s2 = best2[ i + a ]\\n                    if s1+s2 > best:\\n                        best = s1+s2\\n                else:\\n                    break\\n            # Now flip order\\n            arr1, arr2 = arr2, arr1\\n            a   , b    = b   , a\\n        return best\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def trail(self,A,a,b):\\n        sa = ba = sum(A[:a]) # sum from beggining\\n        sb = sum(A[a:b+a])   # sum right after \"sa\"\\n        best = ba+sb\\n        for i in range(b+a,len(A)):\\n            sb += A[i]  - A[i-b]\\n            sa += A[i-b]- A[i-b-a]\\n            ba = max( ba, sa ) # window sum of sb runs with best from \"sa\"\\n            if ba+sb > best:\\n                best = ba+sb\\n        return best\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        trail = self.trail\\n        return max( trail(A,L,M) , trail(A,M,L) )\\n```\n```\\ndef winsum(A,k):\\n    s   = sum(A[:k])\\n    arr = [s]\\n    for i in range(k,len(A)):\\n        s += A[i] - A[i-k]\\n        arr.append(s)\\n    return arr\\n#\\ndef maxleft(arr):\\n    best = [arr[0]]\\n    for x in arr[1:]:\\n        best.append( max(x,best[-1]) )\\n    return best\\n#\\ndef maxright(arr):\\n    return maxleft(arr[::-1])[::-1]\\n#\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        # \\n        aL= winsum(A,L)\\n        aM= winsum(A,M)\\n        #\\n        best = 0\\n        #\\n        arr1,a = aL,L\\n        arr2,b = aM,M\\n        #\\n        for _ in range(2):\\n            best1,best2 = maxleft(arr1),maxright(arr2)\\n            for i,s1 in enumerate(best1):\\n                # ******** Poem ********\\n                # The first sums at all are [0,a-1], and [0,b-1]\\n                # To get stated with sum = [0,a-1], we would need a second sum [a,a+b-1]\\n                # for the current sum [i,i+a-1], we would need [i+a,i+a+b-1]\\n                # so we need arr2[i+a]\\n                if i+a < len(best2):\\n                    s2 = best2[ i + a ]\\n                    if s1+s2 > best:\\n                        best = s1+s2\\n                else:\\n                    break\\n            # Now flip order\\n            arr1, arr2 = arr2, arr1\\n            a   , b    = b   , a\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 426096,
                "title": "python-simple-solution-w-explanation",
                "content": "Simple easy to understand solution based on the hint, but inefficient runtime (very efficient memory usage though, at 12.8MB beating 100% of Python submissions).\\n\\nSliding window implementation.\\nouter loop:  `[|  L  | -->           ]`\\ninner loop: `[|  L  | | M | ->    ]`\\nSum each interval as you slide both through the array.\\nCompare against current max, and update it if needed.\\nThen repeat in the reverse direction.\\n\\n```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        def findMaxSum(A: List[int], L: int, M: int) -> int:\\n            max_num = 0\\n            for i in range(len(A)-L):\\n                L_slice = A[i:L+i]\\n                L_sum = sum(L_slice)\\n                for j in range(L+i,len(A)-M+1):\\n                    M_slice = A[j:M+j]\\n                    M_sum = sum(M_slice)\\n                    max_num = max(L_sum + M_sum, max_num)\\n            return max_num\\n        \\n        forwards_sum = findMaxSum(A,L,M)\\n        A.reverse()\\n        backwards_sum = findMaxSum(A,L,M)\\n        return max(forwards_sum,backwards_sum)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        def findMaxSum(A: List[int], L: int, M: int) -> int:\\n            max_num = 0\\n            for i in range(len(A)-L):\\n                L_slice = A[i:L+i]\\n                L_sum = sum(L_slice)\\n                for j in range(L+i,len(A)-M+1):\\n                    M_slice = A[j:M+j]\\n                    M_sum = sum(M_slice)\\n                    max_num = max(L_sum + M_sum, max_num)\\n            return max_num\\n        \\n        forwards_sum = findMaxSum(A,L,M)\\n        A.reverse()\\n        backwards_sum = findMaxSum(A,L,M)\\n        return max(forwards_sum,backwards_sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2019495,
                "title": "python-sol-very-simple-explained-sliding-window",
                "content": "\\n# EXPLANATION\\n```\\nFor every firstLen subarray find the maximum sum secondLen size subarray\\n\\nSay we have arr = [1,2,3,4,5,6,7,8,9,10] firstLen = 3 , secondLen = 4\\n\\nWe took the subarray with firstLen : [5,6,7]\\nNow the secondLen subarray with max sum can be in\\n1. [1,2,3,4]\\n2. [8,9,10]\\n\\n\\n\\n```\\n\\n# CODE\\n```\\nclass Solution:\\n    def getMaxSubarraySum(self,arr,size):\\n        n = len(arr)\\n        if n < size: return 0\\n        best = tmp = sum(arr[:size])\\n        for i in range(1,n-size+1):\\n            tmp = tmp + arr[i+size-1] - arr[i-1]\\n            if tmp > best:best = tmp\\n        return best\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        n = len(nums)\\n        summ = sum(nums[:firstLen])\\n        ans = summ  + self.getMaxSubarraySum(nums[firstLen:],secondLen)   \\n        for i in range(1,n-firstLen+1):\\n            summ = summ + nums[i+firstLen-1] - nums[i-1]\\n            a = self.getMaxSubarraySum(nums[:i],secondLen)\\n            b = self.getMaxSubarraySum(nums[i+firstLen:],secondLen)\\n            m = a if a > b else b\\n            if summ + m > ans: ans = summ + m\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nFor every firstLen subarray find the maximum sum secondLen size subarray\\n\\nSay we have arr = [1,2,3,4,5,6,7,8,9,10] firstLen = 3 , secondLen = 4\\n\\nWe took the subarray with firstLen : [5,6,7]\\nNow the secondLen subarray with max sum can be in\\n1. [1,2,3,4]\\n2. [8,9,10]\\n\\n\\n\\n```\n```\\nclass Solution:\\n    def getMaxSubarraySum(self,arr,size):\\n        n = len(arr)\\n        if n < size: return 0\\n        best = tmp = sum(arr[:size])\\n        for i in range(1,n-size+1):\\n            tmp = tmp + arr[i+size-1] - arr[i-1]\\n            if tmp > best:best = tmp\\n        return best\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        n = len(nums)\\n        summ = sum(nums[:firstLen])\\n        ans = summ  + self.getMaxSubarraySum(nums[firstLen:],secondLen)   \\n        for i in range(1,n-firstLen+1):\\n            summ = summ + nums[i+firstLen-1] - nums[i-1]\\n            a = self.getMaxSubarraySum(nums[:i],secondLen)\\n            b = self.getMaxSubarraySum(nums[i+firstLen:],secondLen)\\n            m = a if a > b else b\\n            if summ + m > ans: ans = summ + m\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678961,
                "title": "c-easy-to-understand-dynamic-programming-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &nums,int x,int y)\\n    {\\n        int n=nums.size();\\n        vector<int> dp1(n,0),dp2(n,0);\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           if(i<x)\\n           {\\n               sum+=nums[i];\\n               dp1[i]=sum;\\n           }\\n           else\\n           {\\n               sum+=nums[i]-nums[i-x];\\n               dp1[i]=max(sum,dp1[i-1]);\\n           }\\n        }\\n        sum=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+y>=n)\\n            {\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }\\n            else\\n            {\\n                 sum+=nums[i]-nums[i+y];\\n                 dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=x-1;i<n-y;i++)\\n        {\\n           ans=max(ans,dp1[i]+dp2[i+1]); \\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        return max(helper(nums,firstLen,secondLen),helper(nums,secondLen,firstLen));\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int> &nums,int x,int y)\\n    {\\n        int n=nums.size();\\n        vector<int> dp1(n,0),dp2(n,0);\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n           if(i<x)\\n           {\\n               sum+=nums[i];\\n               dp1[i]=sum;\\n           }\\n           else\\n           {\\n               sum+=nums[i]-nums[i-x];\\n               dp1[i]=max(sum,dp1[i-1]);\\n           }\\n        }\\n        sum=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+y>=n)\\n            {\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }\\n            else\\n            {\\n                 sum+=nums[i]-nums[i+y];\\n                 dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=x-1;i<n-y;i++)\\n        {\\n           ans=max(ans,dp1[i]+dp2[i+1]); \\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        return max(helper(nums,firstLen,secondLen),helper(nums,secondLen,firstLen));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788895,
                "title": "java-prefix-sum-o-n",
                "content": "prefix sum tc =O(n), sc=O(n)\\n```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] a, int l, int m) {\\n        int n = a.length;\\n        int[] prefix = new int[n];\\n        prefix[0]=a[0];\\n        for(int i =1;i<n;i++) \\n            prefix[i]=a[i]+prefix[i-1];\\n        \\n        return Math.max(maxSum(prefix,l,m),maxSum(prefix,m,l));\\n    }\\n    \\n    private int maxSum(int[] prefix,int l,int m) {\\n        int max_sum=subArraySum(prefix,0,l-1)+subArraySum(prefix,l,l+m-1);\\n        int max_first=subArraySum(prefix,0,l-1);\\n        //[0..l-1][l,l+m-1]\\n        for(int i=l+m-1;i<prefix.length;i++) {\\n            int first = subArraySum(prefix,i-l-m+1,i-m);\\n            max_first = Math.max(max_first,first);\\n\\n            int sum= max_first + subArraySum(prefix,i-m+1,i);\\n            max_sum = Math.max(max_sum,sum);\\n        }\\n        \\n        return max_sum;  \\n    }\\n    \\n    //a[3]+a[4]+a[5]=prefix[5]-prefix[2]\\n    private int subArraySum(int[] prefix,int from, int to) {\\n        if (from ==0) return prefix[to];\\n        else return prefix[to]-prefix[from-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] a, int l, int m) {\\n        int n = a.length;\\n        int[] prefix = new int[n];\\n        prefix[0]=a[0];\\n        for(int i =1;i<n;i++) \\n            prefix[i]=a[i]+prefix[i-1];\\n        \\n        return Math.max(maxSum(prefix,l,m),maxSum(prefix,m,l));\\n    }\\n    \\n    private int maxSum(int[] prefix,int l,int m) {\\n        int max_sum=subArraySum(prefix,0,l-1)+subArraySum(prefix,l,l+m-1);\\n        int max_first=subArraySum(prefix,0,l-1);\\n        //[0..l-1][l,l+m-1]\\n        for(int i=l+m-1;i<prefix.length;i++) {\\n            int first = subArraySum(prefix,i-l-m+1,i-m);\\n            max_first = Math.max(max_first,first);\\n\\n            int sum= max_first + subArraySum(prefix,i-m+1,i);\\n            max_sum = Math.max(max_sum,sum);\\n        }\\n        \\n        return max_sum;  \\n    }\\n    \\n    //a[3]+a[4]+a[5]=prefix[5]-prefix[2]\\n    private int subArraySum(int[] prefix,int from, int to) {\\n        if (from ==0) return prefix[to];\\n        else return prefix[to]-prefix[from-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716063,
                "title": "two-solutions-with-full-explanation-optimized-one-after-another",
                "content": "**Solution-1**\\nTime: `O(n^2)`\\nSpace: `O(n)`\\n\\n**Idea:**\\n* This problem includes a \"sum\" and a \"contiguous subarray\", hence, maintain a prefixSum array to quickly get the sum of the numbers of the subarray.\\n* We can define the `lEnd` - indicating the end idx of the subarray of length `L`\\n* and `mStart` - indicating the start idx of the subarray of length `M`\\n* `lEnd` can go from `l-1` to `n-m-1` (both inclusive)\\n* `mStart` can go from `lEnd + 1` to `n-m` (both inclusive)\\n* Calculate the sum of both subarrays for each combination of `lEnd` and `mStart` and return the max result.\\n* At last, let\\'s take into consideration that subarray of length `L` can also be on the right side of `M`. So, we will run our function twice and return the max of both the permutations of `L` and `M`.\\n\\n```\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\tint n = A.length;\\n\\tint[] prefix = new int[n];\\n\\tint runningSum = 0;\\n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\trunningSum += A[i];\\n\\t\\tprefix[i] = runningSum;\\n\\t}\\n\\n\\treturn Math.max(helper(A, L, M, prefix), helper(A, M, L, prefix));\\n}\\n\\nprivate int helper(int[] A, int l, int m, int[] prefix) { \\n\\tint n = A.length,\\n\\t\\tans = Integer.MIN_VALUE; \\n\\n\\tfor (int lEnd = l-1; lEnd <= n - m - 1; lEnd++) {\\n\\t\\tfor (int mStart = n-m; mStart >= lEnd + 1; mStart--) { \\n\\t\\t\\tint sum1 = lEnd > l-1\\n\\t\\t\\t\\t\\t? prefix[lEnd] - prefix[lEnd - l]\\n\\t\\t\\t\\t\\t: prefix[lEnd],\\n\\n\\t\\t\\t\\tsum2 = prefix[mStart + m - 1] - prefix[mStart - 1];\\n\\n\\t\\t\\tans = Math.max(ans, sum1 + sum2);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\\n\\n**Solution-2**\\nTime: `O(n)`\\nSpace: `O(n)`\\n\\n**Idea:**\\n* Treat the problem similar to buy and sell stock 2 times.\\n* Maintain a prefix sum (same as solution-1)\\n* `lMaxTill` - an array where `lMaxTill[i]` indicates max subarray sum of length `L` till index `i`\\n* `mMaxFrom` - an array where `mMaxFrom[j]` indicates max subarray sum of length `M` starting from idx `j`\\n* Iterate over above two arrays to find the maximum result. \\n\\n```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        int[] prefix = new int[n];\\n        int runningSum = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            runningSum += A[i];\\n            prefix[i] = runningSum;\\n        }\\n        \\n        return Math.max(helper(A, L, M, prefix), helper(A, M, L, prefix));\\n    }\\n    \\n    private int helper(int[] A, int l, int m, int[] prefix) { \\n        int n = A.length, // 9\\n            ans = Integer.MIN_VALUE; // 13\\n        \\n        int[] lMaxTill = new int[n],\\n            mMaxFrom = new int[n]; // we don\\'t need to initialize these arrays with integer.min_value because the input numbers in the array are \"non-negative\" so, it\\'s okay to let the default values as 0.\\n        \\n        for (int i = l - 1; i < n - m; i++) { // i = 4\\n            lMaxTill[i] = i == l-1\\n                ? prefix[i]\\n                : Math.max(lMaxTill[i-1], prefix[i] - prefix[i - l]);\\n        }\\n        \\n        for (int j = n - m; j >= l; j--) {\\n            mMaxFrom[j] = j == n-m\\n                ? prefix[j+m-1] - prefix[j-1]\\n                : Math.max(mMaxFrom[j+1], prefix[j+m-1] - prefix[j-1]); \\n        }\\n        \\n        for (int i = 0; i < n-1; i++) {\\n            ans = Math.max(ans, lMaxTill[i] + mMaxFrom[i+1]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\tint n = A.length;\\n\\tint[] prefix = new int[n];\\n\\tint runningSum = 0;\\n\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\trunningSum += A[i];\\n\\t\\tprefix[i] = runningSum;\\n\\t}\\n\\n\\treturn Math.max(helper(A, L, M, prefix), helper(A, M, L, prefix));\\n}\\n\\nprivate int helper(int[] A, int l, int m, int[] prefix) { \\n\\tint n = A.length,\\n\\t\\tans = Integer.MIN_VALUE; \\n\\n\\tfor (int lEnd = l-1; lEnd <= n - m - 1; lEnd++) {\\n\\t\\tfor (int mStart = n-m; mStart >= lEnd + 1; mStart--) { \\n\\t\\t\\tint sum1 = lEnd > l-1\\n\\t\\t\\t\\t\\t? prefix[lEnd] - prefix[lEnd - l]\\n\\t\\t\\t\\t\\t: prefix[lEnd],\\n\\n\\t\\t\\t\\tsum2 = prefix[mStart + m - 1] - prefix[mStart - 1];\\n\\n\\t\\t\\tans = Math.max(ans, sum1 + sum2);\\n\\t\\t}\\n\\t}\\n\\treturn ans;\\n}\\n```\n```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        int[] prefix = new int[n];\\n        int runningSum = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            runningSum += A[i];\\n            prefix[i] = runningSum;\\n        }\\n        \\n        return Math.max(helper(A, L, M, prefix), helper(A, M, L, prefix));\\n    }\\n    \\n    private int helper(int[] A, int l, int m, int[] prefix) { \\n        int n = A.length, // 9\\n            ans = Integer.MIN_VALUE; // 13\\n        \\n        int[] lMaxTill = new int[n],\\n            mMaxFrom = new int[n]; // we don\\'t need to initialize these arrays with integer.min_value because the input numbers in the array are \"non-negative\" so, it\\'s okay to let the default values as 0.\\n        \\n        for (int i = l - 1; i < n - m; i++) { // i = 4\\n            lMaxTill[i] = i == l-1\\n                ? prefix[i]\\n                : Math.max(lMaxTill[i-1], prefix[i] - prefix[i - l]);\\n        }\\n        \\n        for (int j = n - m; j >= l; j--) {\\n            mMaxFrom[j] = j == n-m\\n                ? prefix[j+m-1] - prefix[j-1]\\n                : Math.max(mMaxFrom[j+1], prefix[j+m-1] - prefix[j-1]); \\n        }\\n        \\n        for (int i = 0; i < n-1; i++) {\\n            ans = Math.max(ans, lMaxTill[i] + mMaxFrom[i+1]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278862,
                "title": "easy-python-o-n",
                "content": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        def solve(l,m):\\n            left = p = sum(A[:l]) \\n            c = sum(A[l:l+m])\\n            ans = left + c\\n            for i in range(l, len(A) - m):\\n                p += A[i] - A[i-l]\\n                c += A[i+m] - A[i]\\n                left = max(left, p)\\n                ans = max(c + left, ans) \\n            return ans \\n        return max(solve(L,M), solve(M, L))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        def solve(l,m):\\n            left = p = sum(A[:l]) \\n            c = sum(A[l:l+m])\\n            ans = left + c\\n            for i in range(l, len(A) - m):\\n                p += A[i] - A[i-l]\\n                c += A[i+m] - A[i]\\n                left = max(left, p)\\n                ans = max(c + left, ans) \\n            return ans \\n        return max(solve(L,M), solve(M, L))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3649604,
                "title": "python-3-7-lines-sliding-ptrs-t-m-83-56",
                "content": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n\\n        nums = list(accumulate(nums, initial = 0))\\n        mx1 = mx2 = mx3 = 0\\n        \\n        for sm0,sm1,sm2,sm3 in zip(nums, \\n                                   nums[firstLen:],\\n                                   nums[secondLen:],\\n                                   nums[firstLen+secondLen:]):\\n\\n            mx1 = max(mx1, sm1 - sm0)\\n            mx2 = max(mx2, sm2 - sm0)\\n            mx3 = max(mx3, max(mx1 + sm3-sm1, mx2 + sm3-sm2))\\n            \\n        return mx3\\n```\\n[https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/submissions/973518314/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*), in which *N* ~`len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n\\n        nums = list(accumulate(nums, initial = 0))\\n        mx1 = mx2 = mx3 = 0\\n        \\n        for sm0,sm1,sm2,sm3 in zip(nums, \\n                                   nums[firstLen:],\\n                                   nums[secondLen:],\\n                                   nums[firstLen+secondLen:]):\\n\\n            mx1 = max(mx1, sm1 - sm0)\\n            mx2 = max(mx2, sm2 - sm0)\\n            mx3 = max(mx3, max(mx1 + sm3-sm1, mx2 + sm3-sm2))\\n            \\n        return mx3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576216,
                "title": "java-sliding-window-prefix-sum-with-explanation",
                "content": "```\\n/*\\n1) Initially we are creating a prefixSum array, storing all the prefix sums\\n2) We stored the initial result as sum of (firstLen+secondLen-1) as it represents the first n+p\\nelements\\n3) After that we are moving the window and at each time we are checking new sum of firstlen and\\nsecondlen and comparing it with the already stored result\\n4) We applied FindMaxSum method twice because first time we are looking for combination where\\nfirst len is element is before second len element and 2nd time for the combinations where\\nsecond len element is before first len element\\n\\n*/\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int[] prefixSums = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n                prefixSums[i] = nums[i];\\n            else\\n                prefixSums[i] = prefixSums[i-1]+nums[i];\\n        }\\n        \\n        int max1 = FindMaxSum(prefixSums, firstLen, secondLen);\\n        int max2 = FindMaxSum(prefixSums, secondLen, firstLen);\\n        \\n        return Math.max(max1, max2);\\n    }\\n    \\n    int FindMaxSum(int[] prefixSums, int firstLen, int secondLen)\\n    {\\n        int globalMax = prefixSums[firstLen+secondLen-1];\\n        int max1 = prefixSums[firstLen-1];\\n        for(int i=0;i<prefixSums.length-firstLen-secondLen;i++)\\n        {\\n            int sum1 = prefixSums[i+firstLen]-prefixSums[i];\\n            int sum2 = prefixSums[i+firstLen+secondLen] - prefixSums[i+firstLen];\\n            max1 = Math.max(max1,sum1);\\n            globalMax = Math.max(globalMax, max1+sum2);\\n        }\\n        return globalMax;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\n/*\\n1) Initially we are creating a prefixSum array, storing all the prefix sums\\n2) We stored the initial result as sum of (firstLen+secondLen-1) as it represents the first n+p\\nelements\\n3) After that we are moving the window and at each time we are checking new sum of firstlen and\\nsecondlen and comparing it with the already stored result\\n4) We applied FindMaxSum method twice because first time we are looking for combination where\\nfirst len is element is before second len element and 2nd time for the combinations where\\nsecond len element is before first len element\\n\\n*/\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int[] prefixSums = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            if(i==0)\\n                prefixSums[i] = nums[i];\\n            else\\n                prefixSums[i] = prefixSums[i-1]+nums[i];\\n        }\\n        \\n        int max1 = FindMaxSum(prefixSums, firstLen, secondLen);\\n        int max2 = FindMaxSum(prefixSums, secondLen, firstLen);\\n        \\n        return Math.max(max1, max2);\\n    }\\n    \\n    int FindMaxSum(int[] prefixSums, int firstLen, int secondLen)\\n    {\\n        int globalMax = prefixSums[firstLen+secondLen-1];\\n        int max1 = prefixSums[firstLen-1];\\n        for(int i=0;i<prefixSums.length-firstLen-secondLen;i++)\\n        {\\n            int sum1 = prefixSums[i+firstLen]-prefixSums[i];\\n            int sum2 = prefixSums[i+firstLen+secondLen] - prefixSums[i+firstLen];\\n            max1 = Math.max(max1,sum1);\\n            globalMax = Math.max(globalMax, max1+sum2);\\n        }\\n        return globalMax;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135468,
                "title": "c-o-n-suffix-sum-3ms-beats-91",
                "content": "![image](https://assets.leetcode.com/users/images/136c7016-425e-42e7-b95f-a788d21339f2_1654874400.370137.png)\\nWe need to meet 2 conditions :\\n1. **Non-overlapping subarrays**\\n2. **Max Sum**\\n\\n***For condition 1:***\\n\\t\\t\\tWhile traversal subarrays considered are adjacent to each other, so they don\\'t overlap.\\n***For condition 2:***\\n Firstly, there can be **two situations**, firstLen subarray placed before secondLen subarray in the original array, and the opposite i.e. secondLen subarray placed before firstLen subarray. \\n * To deal with this we can simply check maxsum for both cases parallely, and return maximum of the 2 sums.\\n * As the logic remains the same for both the cases, without loss of generality, we can consider either case (let\\'s consider first):\\n\\n\\t\\tWhile traversal we maintain 2 variants, (maxfirstLen) maximum suffix sum of firstLen subarray from the current index  and,\\n\\t\\t(max1) maximum total sum of maxfirstLen and current suffix sum of secondLen subarray (stored in s2).\\n\\t\\t\\n**Explanation:**\\n*This works because for a given element of s2 (which is suffix sum of secondLen subarray from the current index), maximum firstLen subarray sum maximizes the total sum for the current s2. \\nAND while traversing we find the maximum of these total sums with respect to every s2.\\nSimilarly for every element in s1.*\\n\\n**Code:**\\n```\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int ret=0, n=nums.size();\\n        //suffix sum upto next firstLen and secondLen elements respectively\\n        vector<int> s1(n-firstLen+1,0), s2(n-secondLen+1,0);\\n        s1[0], s2[0]=0;\\n        for(int j=0; j<firstLen; j++) s1[0]+=nums[j];\\n        for(int i=0; i<n-firstLen; i++){\\n            s1[i+1] = s1[i] - nums[i];\\n            s1[i+1] += nums[i+firstLen];\\n        }//filled suffix sum of firstLen elements from each index\\n        for(int j=0; j<secondLen; j++) s2[0]+=nums[j];\\n        for(int k=0; k<n-secondLen; k++){\\n            s2[k+1] = s2[k] - nums[k];\\n            s2[k+1] += nums[k+secondLen];\\n        }//filled suffix sum of secondLen elements from each index\\n        int max1=0, max2=0, maxfirstLen=0, maxsecondLen=0;\\n        for(int i=0; i<=n - firstLen - secondLen; i++){\\n            maxfirstLen = max(maxfirstLen, s1[i]);//maxsum of firstLen subarray\\n            max1 = max(max1, maxfirstLen + s2[i+firstLen]);//maxsum when firstLen subarray is before secondLen subarray\\n            maxsecondLen = max(maxsecondLen, s2[i]);//maxsum of secondLen subarray\\n            max2 = max(max2, maxsecondLen + s1[i+secondLen]);//maxsum when secondLen subarray is before firstLen subarray\\n        }\\n        return max(max1, max2);\\n}\\n```\\n\\nThanks \\u270C",
                "solutionTags": [],
                "code": "```\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int ret=0, n=nums.size();\\n        //suffix sum upto next firstLen and secondLen elements respectively\\n        vector<int> s1(n-firstLen+1,0), s2(n-secondLen+1,0);\\n        s1[0], s2[0]=0;\\n        for(int j=0; j<firstLen; j++) s1[0]+=nums[j];\\n        for(int i=0; i<n-firstLen; i++){\\n            s1[i+1] = s1[i] - nums[i];\\n            s1[i+1] += nums[i+firstLen];\\n        }//filled suffix sum of firstLen elements from each index\\n        for(int j=0; j<secondLen; j++) s2[0]+=nums[j];\\n        for(int k=0; k<n-secondLen; k++){\\n            s2[k+1] = s2[k] - nums[k];\\n            s2[k+1] += nums[k+secondLen];\\n        }//filled suffix sum of secondLen elements from each index\\n        int max1=0, max2=0, maxfirstLen=0, maxsecondLen=0;\\n        for(int i=0; i<=n - firstLen - secondLen; i++){\\n            maxfirstLen = max(maxfirstLen, s1[i]);//maxsum of firstLen subarray\\n            max1 = max(max1, maxfirstLen + s2[i+firstLen]);//maxsum when firstLen subarray is before secondLen subarray\\n            maxsecondLen = max(maxsecondLen, s2[i]);//maxsum of secondLen subarray\\n            max2 = max(max2, maxsecondLen + s1[i+secondLen]);//maxsum when secondLen subarray is before firstLen subarray\\n        }\\n        return max(max1, max2);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1494050,
                "title": "c-solution-with-intuition-and-optimization-0ms-time-whiteboard-and-code",
                "content": "**Intuition :** Since we have to find the maximum sum of 2 non overlapping subarrays why not iteratively divide the array into 2 halfs (left and right) in search of the maximum sum subarray(MSS) of len1 and len2. There can be 2 cases :\\n\\n\\t1. The MSS of length len1 is on the left (0 to i) and  MSS of length len2 is on the right. (i+1 to n-1)\\n\\t2. The MSS of lenght len2 is on the left (0 to i) and MSS of length len1 is on the right. (i+1 to n-1)\\n\\nLets understand this by an example where :\\narr : [0 6 5 2 2 5 1 9 4]     \\nlen1 = 1    \\nlen2 = 2\\n\\n**Case 1 : Find the MSS of size 1 on the left and MSS of size 2 on the right.**\\n\\n![image](https://assets.leetcode.com/users/images/3d5b2ed7-d07b-4b33-8b52-1be09875fefc_1632943857.606115.png)\\n\\n**Case 2 : Find the MSS of size 2 on the left and MSS of size 1 on the right.**\\n\\n![image](https://assets.leetcode.com/users/images/46528a55-2591-4598-835a-d6d3bde5e4f5_1632944018.0631604.png)\\n\\nThe answer is max(Case1 and Case2)\\n\\n**BRUTE FORCE : (Quadratic Time)**\\n\\n![image](https://assets.leetcode.com/users/images/0c7bd99b-3807-45e0-a15c-de7f7b63cc04_1632944213.8682492.png)\\n\\n**OPTIMIZATION : (Linear TIme)**\\n\\n![image](https://assets.leetcode.com/users/images/8f0a5d95-05a0-4c14-af3e-d9d92dde8512_1632944292.354702.png)\\n\\n**Code :**\\n\\n```\\npublic:\\n    int F(vector<int>& arr, int a, int b)\\n    {\\n        int n = arr.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n       \\n        // sliding window to populate left array where left[i] stores the max subarray sum of len \\'a\\' from 0 to i\\n       int i = 0, j = 0, sum = 0;\\n       while(a--)\\n            sum += arr[i++];\\n        left[i-1] = sum;\\n        while(i < n)\\n        {\\n            sum -= arr[j++];\\n            sum += arr[i];\\n            left[i] = max(left[i-1], sum);\\n            i++;\\n        }\\n        \\n        // sliding window to populate left array where right[i] stores the max subarray sum of len \\'b\\' from i+1 to n-1.\\n        i = n-1; j = n-1; sum = 0;\\n        while(b--)\\n            sum += arr[i--];\\n        right[i+1] = sum;\\n        while(i >= 0)\\n        {\\n            sum -= arr[j--];\\n            sum += arr[i];\\n            right[i] = max(right[i+1], sum);\\n            i--;\\n        }\\n        \\n        // sum of non overlapping left and right subarrays.\\n        int max_sum = 0;\\n        for(int x = 0; x<n-1; x++)\\n            max_sum = max(max_sum, left[x] + right[x+1]);        \\n        \\n        return max_sum;\\n        \\n    }\\n    int maxSumTwoNoOverlap(vector<int>& arr, int len1, int len2) {\\n        /*\\n            Case 1: max subarray sum of len1 left\\n                    max subarray sum of len2 right\\n                    \\n            Case 2: max subarray sum of len2 left\\n                    max subarray sum of len1 right\\n        */\\n        int case1 = F(arr, len1, len2);\\n        int case2 = F(arr, len2, len1);\\n        return max(case1, case2);\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Two Pointers",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\npublic:\\n    int F(vector<int>& arr, int a, int b)\\n    {\\n        int n = arr.size();\\n        vector<int> left(n);\\n        vector<int> right(n);\\n       \\n        // sliding window to populate left array where left[i] stores the max subarray sum of len \\'a\\' from 0 to i\\n       int i = 0, j = 0, sum = 0;\\n       while(a--)\\n            sum += arr[i++];\\n        left[i-1] = sum;\\n        while(i < n)\\n        {\\n            sum -= arr[j++];\\n            sum += arr[i];\\n            left[i] = max(left[i-1], sum);\\n            i++;\\n        }\\n        \\n        // sliding window to populate left array where right[i] stores the max subarray sum of len \\'b\\' from i+1 to n-1.\\n        i = n-1; j = n-1; sum = 0;\\n        while(b--)\\n            sum += arr[i--];\\n        right[i+1] = sum;\\n        while(i >= 0)\\n        {\\n            sum -= arr[j--];\\n            sum += arr[i];\\n            right[i] = max(right[i+1], sum);\\n            i--;\\n        }\\n        \\n        // sum of non overlapping left and right subarrays.\\n        int max_sum = 0;\\n        for(int x = 0; x<n-1; x++)\\n            max_sum = max(max_sum, left[x] + right[x+1]);        \\n        \\n        return max_sum;\\n        \\n    }\\n    int maxSumTwoNoOverlap(vector<int>& arr, int len1, int len2) {\\n        /*\\n            Case 1: max subarray sum of len1 left\\n                    max subarray sum of len2 right\\n                    \\n            Case 2: max subarray sum of len2 left\\n                    max subarray sum of len1 right\\n        */\\n        int case1 = F(arr, len1, len2);\\n        int case2 = F(arr, len2, len1);\\n        return max(case1, case2);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1433466,
                "title": "c-o-n-100-faster-prefixes-with-comments-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int f, int s) {\\n        int n =nums.size();\\n        vector<int> pre(n),pre1(n,0),pre2(n,0);\\n        \\n        //prefix sum\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        \\n        //pre1[i] = maximum contiguous sum of length f until ith index\\n        pre1[f-1]=pre[f-1];\\n        for(int i=f;i<n;i++){\\n            pre1[i]=max(pre1[i-1],pre[i]-pre[i-f]);\\n        }\\n        \\n        //pre2[i] = maximum contiguous sum of length s until ith index\\n        pre2[s-1]=pre[s-1];\\n        for(int i=s;i<n;i++){\\n            pre2[i]=max(pre2[i-1],pre[i]-pre[i-s]);\\n        }\\n        \\n        \\n        int res=INT_MIN;\\n        for(int i=f+s-1;i<n;i++){\\n            //take maximum(contiguous sum of length s ending at i + pre1[i-s] , contiguous sum of length f ending at i + pre1[i-f])\\n            res=max(res,max((pre[i]-pre[i-s])+pre1[i-s],(pre[i]-pre[i-f])+pre2[i-f]));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int f, int s) {\\n        int n =nums.size();\\n        vector<int> pre(n),pre1(n,0),pre2(n,0);\\n        \\n        //prefix sum\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        \\n        //pre1[i] = maximum contiguous sum of length f until ith index\\n        pre1[f-1]=pre[f-1];\\n        for(int i=f;i<n;i++){\\n            pre1[i]=max(pre1[i-1],pre[i]-pre[i-f]);\\n        }\\n        \\n        //pre2[i] = maximum contiguous sum of length s until ith index\\n        pre2[s-1]=pre[s-1];\\n        for(int i=s;i<n;i++){\\n            pre2[i]=max(pre2[i-1],pre[i]-pre[i-s]);\\n        }\\n        \\n        \\n        int res=INT_MIN;\\n        for(int i=f+s-1;i<n;i++){\\n            //take maximum(contiguous sum of length s ending at i + pre1[i-s] , contiguous sum of length f ending at i + pre1[i-f])\\n            res=max(res,max((pre[i]-pre[i-s])+pre1[i-s],(pre[i]-pre[i-f])+pre2[i-f]));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104144,
                "title": "java-prefix-sum-dp-0ms-beats-100-t-c-o-a-length-s-c-o-a-length",
                "content": "\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int omax = Integer.MIN_VALUE, len = A.length, lmax = 0, mmax = 0, sum = 0;\\n\\t\\tint[] prefix = new int[len];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tsum += A[i];\\n\\t\\t\\tprefix[i] = sum;\\n\\t\\t}\\n\\n\\t\\tlmax = prefix[L - 1];\\n\\t\\tmmax = prefix[M - 1];\\n                \\n\\t\\tomax = prefix[L + M - 1];\\n\\n\\t\\tfor (int i = L + M; i < len; i++) {\\n\\t\\t\\tmmax = Math.max(mmax, prefix[i - L] - prefix[i - L - M]);\\n\\t\\t\\tlmax = Math.max(lmax, prefix[i - M] - prefix[i - M - L]);\\n\\t\\t\\tomax = Math.max(omax, prefix[i] - prefix[i - L] + mmax);\\n\\t\\t\\tomax = Math.max(omax, prefix[i] - prefix[i - M] + lmax);\\n\\t\\t}\\n\\n\\t\\treturn omax;\\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int omax = Integer.MIN_VALUE, len = A.length, lmax = 0, mmax = 0, sum = 0;\\n\\t\\tint[] prefix = new int[len];\\n\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tsum += A[i];\\n\\t\\t\\tprefix[i] = sum;\\n\\t\\t}\\n\\n\\t\\tlmax = prefix[L - 1];\\n\\t\\tmmax = prefix[M - 1];\\n                \\n\\t\\tomax = prefix[L + M - 1];\\n\\n\\t\\tfor (int i = L + M; i < len; i++) {\\n\\t\\t\\tmmax = Math.max(mmax, prefix[i - L] - prefix[i - L - M]);\\n\\t\\t\\tlmax = Math.max(lmax, prefix[i - M] - prefix[i - M - L]);\\n\\t\\t\\tomax = Math.max(omax, prefix[i] - prefix[i - L] + mmax);\\n\\t\\t\\tomax = Math.max(omax, prefix[i] - prefix[i - M] + lmax);\\n\\t\\t}\\n\\n\\t\\treturn omax;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 923574,
                "title": "python-4-simple-steps-using-presum-arrays",
                "content": "```python\\ndef maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\n\\t# 1. Build a presum array from A to find the sum of a range in O(1) time\\n\\tA = [0] + A + [0]\\n\\tfor i in range(1, len(A)):\\n\\t\\tA[i] += A[i-1]\\n\\n\\t# 2. For each index i, record the largest array of size L or M that is to the LEFT of index i (NOT including i)\\n\\tl_left = [0]\\n\\tm_left = [0]\\n\\tfor i in range(1, len(A)):\\n\\t\\tl_left.append(max(l_left[-1], A[i] - A[i-L]) if i >= L else 0)\\n\\t\\tm_left.append(max(m_left[-1], A[i] - A[i-M]) if i >= M else 0)\\n\\n\\t# 3. For each index i, record the largest array of size L or M that is to the RIGHT of index i (including i)\\n\\tl_right = [0]*len(A)\\n\\tm_right = [0]*len(A)\\n\\tfor i in range(len(A) - 2, -1, -1):\\n\\t\\tl_right[i] = max(l_right[i+1], A[i+L] - A[i] if i + L < len(A) else 0)\\n\\t\\tm_right[i] = max(m_right[i+1], A[i+M] - A[i] if i + M < len(A) else 0)\\n\\n\\t# 4. Return the largest combination of (l_left[i] and m_right[i]) OR (l_right[i] and m_left[i])\\n\\treturn max(max(l_left[i] + m_right[i], l_right[i] + m_left[i]) for i in range(1, len(A) - 1))\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\n\\t# 1. Build a presum array from A to find the sum of a range in O(1) time\\n\\tA = [0] + A + [0]\\n\\tfor i in range(1, len(A)):\\n\\t\\tA[i] += A[i-1]\\n\\n\\t# 2. For each index i, record the largest array of size L or M that is to the LEFT of index i (NOT including i)\\n\\tl_left = [0]\\n\\tm_left = [0]\\n\\tfor i in range(1, len(A)):\\n\\t\\tl_left.append(max(l_left[-1], A[i] - A[i-L]) if i >= L else 0)\\n\\t\\tm_left.append(max(m_left[-1], A[i] - A[i-M]) if i >= M else 0)\\n\\n\\t# 3. For each index i, record the largest array of size L or M that is to the RIGHT of index i (including i)\\n\\tl_right = [0]*len(A)\\n\\tm_right = [0]*len(A)\\n\\tfor i in range(len(A) - 2, -1, -1):\\n\\t\\tl_right[i] = max(l_right[i+1], A[i+L] - A[i] if i + L < len(A) else 0)\\n\\t\\tm_right[i] = max(m_right[i+1], A[i+M] - A[i] if i + M < len(A) else 0)\\n\\n\\t# 4. Return the largest combination of (l_left[i] and m_right[i]) OR (l_right[i] and m_left[i])\\n\\treturn max(max(l_left[i] + m_right[i], l_right[i] + m_left[i]) for i in range(1, len(A) - 1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 288665,
                "title": "java-running-sum",
                "content": "```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // L .. M ..\\n        // M ... L ...\\n        int[] runningSum = getRunningSum(A);\\n        return Math.max(find(runningSum, L, M), find(runningSum, M, L));\\n    }\\n\\n    private int find(int[] runningSum, int L, int M) {\\n        int ans = runningSum[L + M - 1];\\n        int maxL = runningSum[L - 1];\\n        for (int i = L + M; i < runningSum.length; i++) {\\n            maxL = Math.max(maxL, runningSum[i - M] - runningSum[i - M - L]);\\n            int sumM = runningSum[i] - runningSum[i - M];\\n            ans = Math.max(ans, maxL + sumM);\\n        }\\n        return ans;\\n    }\\n\\n    private int[] getRunningSum(int[] arr) {\\n        for (int i = 1; i < arr.length; i++) {\\n            arr[i] += arr[i - 1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // L .. M ..\\n        // M ... L ...\\n        int[] runningSum = getRunningSum(A);\\n        return Math.max(find(runningSum, L, M), find(runningSum, M, L));\\n    }\\n\\n    private int find(int[] runningSum, int L, int M) {\\n        int ans = runningSum[L + M - 1];\\n        int maxL = runningSum[L - 1];\\n        for (int i = L + M; i < runningSum.length; i++) {\\n            maxL = Math.max(maxL, runningSum[i - M] - runningSum[i - M - L]);\\n            int sumM = runningSum[i] - runningSum[i - M];\\n            ans = Math.max(ans, maxL + sumM);\\n        }\\n        return ans;\\n    }\\n\\n    private int[] getRunningSum(int[] arr) {\\n        for (int i = 1; i < arr.length; i++) {\\n            arr[i] += arr[i - 1];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634482,
                "title": "easy-pythonic-solution-sliding-window",
                "content": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums, firstLen: int, secondLen: int) -> int:\\n        maxSum = 0\\n        i, j = 0, 0\\n        max1, max2 = 0, 0\\n        while i < len(nums) - firstLen + 1:\\n            max1 = sum(nums[i:i + firstLen])\\n            if secondLen <= i:\\n                j = 0\\n                while j + secondLen <= i:\\n                    max2 = sum(nums[j:j + secondLen])\\n                    maxSum = max(maxSum, max1 + max2)\\n                    j += 1\\n\\n            if len(nums) - (i + 1) >= secondLen:\\n                j = 0\\n                while j + i + secondLen <= len(nums):\\n                    max2 = sum(nums[i + j + firstLen:i + j + firstLen + secondLen])\\n                    maxSum = max(maxSum, max1 + max2)\\n                    j += 1\\n            i += 1\\n        return maxSum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums, firstLen: int, secondLen: int) -> int:\\n        maxSum = 0\\n        i, j = 0, 0\\n        max1, max2 = 0, 0\\n        while i < len(nums) - firstLen + 1:\\n            max1 = sum(nums[i:i + firstLen])\\n            if secondLen <= i:\\n                j = 0\\n                while j + secondLen <= i:\\n                    max2 = sum(nums[j:j + secondLen])\\n                    maxSum = max(maxSum, max1 + max2)\\n                    j += 1\\n\\n            if len(nums) - (i + 1) >= secondLen:\\n                j = 0\\n                while j + i + secondLen <= len(nums):\\n                    max2 = sum(nums[i + j + firstLen:i + j + firstLen + secondLen])\\n                    maxSum = max(maxSum, max1 + max2)\\n                    j += 1\\n            i += 1\\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480494,
                "title": "c-easy-to-understand-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int firstLen, int secondLen){\\n        int fi = 0 , fj = 0 , currSum = 0 , ans = 0;\\n        while(fj != firstLen){\\n            currSum+=nums[fj++];\\n        }\\n        fj--;\\n        while(fj != nums.size()-secondLen){\\n            int sum = 0 , si = fj+1 , sj = fj+1 , secSum = 0;\\n            while(sj != nums.size()){\\n                secSum+=nums[sj];\\n                if(sj-si+1 != secondLen) sj++;\\n                else{\\n                    sum = max(secSum , sum);\\n                    secSum-=nums[si++];\\n                    sj++;\\n                }\\n            }\\n            ans = max(ans , (sum+currSum));\\n            currSum-=nums[fi++];\\n            currSum+=nums[++fj];\\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        cout<<helper(nums , firstLen , secondLen)<<\" \"<< helper(nums , secondLen , firstLen)<<endl;\\n        return max(helper(nums , firstLen , secondLen) , helper(nums , secondLen , firstLen));\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int helper(vector<int>& nums, int firstLen, int secondLen){\\n        int fi = 0 , fj = 0 , currSum = 0 , ans = 0;\\n        while(fj != firstLen){\\n            currSum+=nums[fj++];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1894571,
                "title": "java-intuitive-o-n-prefix-max-sliding-window",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n      \\n  //Intution - 3 step Solution --> Lengthy But Easy To Get --> Just 3 iterations\\n        \\n  // 1 Find prefix max value array for any given length L (with help of sliding window)\\n  //2 similarly find sufix max value array for the same length. \\n //Max value means at any index i, the maximum sum till now of the subarray of length L\\n   \\n   // 3 After this just iterate over given array and take a sliding window of size M \\n   // For that particular window, chk for prefixMax value in i-1 index \\n   // and sufixMax value in i+1 index.. Now just store your result..\\uD83D\\uDCAF \\n        \\n        int n = A.length;\\n        int[] prefixMax = new int[n];\\n        int i = 0, j = 0, sum = 0;\\n        while(j < n) {  \\n             sum += A[j];\\n             if(j == L -1) {\\n                prefixMax[j] = sum;\\n            }\\n            else if(j > L-1) {\\n                sum = sum - A[i];  //subtracting previous value from sliding window\\n                prefixMax[j] = Math.max(prefixMax[j-1], sum);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\t\\t\\n        int[] sufixMax = new int[n];\\n        j = i = n-1;\\n        sum = 0;\\n        while(j >=0) {  //For sufix max, iterate in reverse direction\\n             sum += A[j];\\n             if(j == n- L) {\\n                sufixMax[j] = sum;\\n            }\\n            else if(j < n-L) {\\n                sum = sum - A[i];\\n                sufixMax[j] = Math.max(sufixMax[j+1], sum);\\n                i--;\\n            }\\n            j--;\\n        }   \\n   \\n       int res = Integer.MIN_VALUE;  //result\\n       i = j = sum = 0;\\n        while(j < n) {\\n            sum += A[j];\\n            if(j == M-1) {\\n                res = Math.max(res, sum + sufixMax[j+1]);\\n            }\\n            else if(j > M-1) {\\n                sum = sum - A[i];\\n                int op1 = sum + prefixMax[i];\\n                int op2 = sum + (j != n-1 ? sufixMax[j+1] : 0);\\n                res = Math.max(res, Math.max(op1, op2));\\n                i++;\\n            }\\n               j++;\\n        }\\n    \\n               return res;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n      \\n  //Intution - 3 step Solution --> Lengthy But Easy To Get --> Just 3 iterations\\n        \\n  // 1 Find prefix max value array for any given length L (with help of sliding window)\\n  //2 similarly find sufix max value array for the same length. \\n //Max value means at any index i, the maximum sum till now of the subarray of length L\\n   \\n   // 3 After this just iterate over given array and take a sliding window of size M \\n   // For that particular window, chk for prefixMax value in i-1 index \\n   // and sufixMax value in i+1 index.. Now just store your result..\\uD83D\\uDCAF \\n        \\n        int n = A.length;\\n        int[] prefixMax = new int[n];\\n        int i = 0, j = 0, sum = 0;\\n        while(j < n) {  \\n             sum += A[j];\\n             if(j == L -1) {\\n                prefixMax[j] = sum;\\n            }\\n            else if(j > L-1) {\\n                sum = sum - A[i];  //subtracting previous value from sliding window\\n                prefixMax[j] = Math.max(prefixMax[j-1], sum);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\t\\t\\n        int[] sufixMax = new int[n];\\n        j = i = n-1;\\n        sum = 0;\\n        while(j >=0) {  //For sufix max, iterate in reverse direction\\n             sum += A[j];\\n             if(j == n- L) {\\n                sufixMax[j] = sum;\\n            }\\n            else if(j < n-L) {\\n                sum = sum - A[i];\\n                sufixMax[j] = Math.max(sufixMax[j+1], sum);\\n                i--;\\n            }\\n            j--;\\n        }   \\n   \\n       int res = Integer.MIN_VALUE;  //result\\n       i = j = sum = 0;\\n        while(j < n) {\\n            sum += A[j];\\n            if(j == M-1) {\\n                res = Math.max(res, sum + sufixMax[j+1]);\\n            }\\n            else if(j > M-1) {\\n                sum = sum - A[i];\\n                int op1 = sum + prefixMax[i];\\n                int op2 = sum + (j != n-1 ? sufixMax[j+1] : 0);\\n                res = Math.max(res, Math.max(op1, op2));\\n                i++;\\n            }\\n               j++;\\n        }\\n    \\n               return res;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867188,
                "title": "2-o-n",
                "content": "<pre><code>class Solution {\\npublic:\\n    int helper(vector<int>&nums,int x,int y){\\n        int n=nums.size();\\n        \\n        vector<int>dp1(n,-1),dp2(n,-1);\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(i<x){\\n                sum+=nums[i];\\n                dp1[i]=sum;\\n            }\\n            else{\\n                sum+=nums[i]-nums[i-x];\\n                dp1[i]=max(dp1[i-1],sum);\\n            }\\n        }\\n        \\n        sum=0;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            if(i+y>=n){\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }\\n            else{\\n                sum+=nums[i]-nums[i+y];\\n                dp2[i]=max(dp2[i+1],sum);\\n            }\\n        }\\n        \\n        int ans=0;\\n        \\n        for(int i=x;i+y<n;i++){\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        return ans;\\n        \\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int x, int y) {\\n        \\n       return max(helper(nums,x,y),helper(nums,y,x));\\n    }\\n};</code></pre>",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int helper(vector<int>&nums,int x,int y){\\n        int n=nums.size();\\n        \\n        vector<int>dp1(n,-1),dp2(n,-1);\\n        \\n        int sum=0;\\n        \\n        for(int i=0;i<n;i++){\\n            if(i<x){\\n                sum+=nums[i];\\n                dp1[i]=sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1827427,
                "title": "c-solution-clean-code-intutions-explained",
                "content": "\\n  \\n            \\n            \\n\\t\\t\\t// Intutition :-\\n        //We will use 2 array for storing the f-length window sum for left to right\\n            // for firstlen\\n\\t\\t\\t// for secondlen we will store the sum of window size s from right to left\\n            // while storing check for max sum previously occured \\n            \\n            // for firstlen  dp1[i]=max(dp1[i-1],currsum);\\n            // for second len dp2[i]=max(dp2[i+1],currsum);\\n            \\n            // finally we will iterate from f-1 to n-s-1 ans =max(ans , dp1[i]+dp2[i+1]);\\n        int func(vector<int>& nums, int f, int s)\\n        {\\n                  int n=nums.size();\\n            \\n            vector<int> dp1(n,0),dp2(n,0);\\n            int currsum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                    if(i<f)\\n                    {\\n                            currsum+=nums[i];\\n                            dp1[i]=currsum;\\n                    }\\n                    else\\n                    {\\n                            currsum=currsum-nums[i-f]+nums[i];\\n                            dp1[i]=max(dp1[i-1],currsum);\\n                    }\\n            }\\n            currsum=0;\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                    if(i+s>n-1)\\n                    {\\n                            currsum+=nums[i];\\n                            dp2[i]=currsum;\\n                    }\\n                    else\\n                    {\\n                            currsum=currsum-nums[i+s]+nums[i];\\n                            dp2[i]=max(dp2[i+1],currsum);\\n                    }\\n            }\\n            \\n            int ans=0;\\n            for(int i=f-1;i<n-s;i++)\\n            {\\n                    ans=max(ans , dp1[i]+dp2[i+1]);\\n            }\\n            return ans;\\n        }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int f, int s) {\\n           \\n        return max(func(nums , f,s),func(nums , s,f));\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "\\n  \\n            \\n            \\n\\t\\t\\t// Intutition :-\\n        //We will use 2 array for storing the f-length window sum for left to right\\n            // for firstlen\\n\\t\\t\\t// for secondlen we will store the sum of window size s from right to left\\n            // while storing check for max sum previously occured \\n            \\n            // for firstlen  dp1[i]=max(dp1[i-1],currsum);\\n            // for second len dp2[i]=max(dp2[i+1],currsum);\\n            \\n            // finally we will iterate from f-1 to n-s-1 ans =max(ans , dp1[i]+dp2[i+1]);\\n        int func(vector<int>& nums, int f, int s)\\n        {\\n                  int n=nums.size();\\n            \\n            vector<int> dp1(n,0),dp2(n,0);\\n            int currsum=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                    if(i<f)\\n                    {\\n                            currsum+=nums[i];\\n                            dp1[i]=currsum;\\n                    }\\n                    else\\n                    {\\n                            currsum=currsum-nums[i-f]+nums[i];\\n                            dp1[i]=max(dp1[i-1],currsum);\\n                    }\\n            }\\n            currsum=0;\\n            for(int i=n-1;i>=0;i--)\\n            {\\n                    if(i+s>n-1)\\n                    {\\n                            currsum+=nums[i];\\n                            dp2[i]=currsum;\\n                    }\\n                    else\\n                    {\\n                            currsum=currsum-nums[i+s]+nums[i];\\n                            dp2[i]=max(dp2[i+1],currsum);\\n                    }\\n            }\\n            \\n            int ans=0;\\n            for(int i=f-1;i<n-s;i++)\\n            {\\n                    ans=max(ans , dp1[i]+dp2[i+1]);\\n            }\\n            return ans;\\n        }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int f, int s) {\\n           \\n        return max(func(nums , f,s),func(nums , s,f));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1675031,
                "title": "o-n-time-o-1-space-no-modification-of-original-array",
                "content": "Here we have two cases-: \\n1. I am moving secondLen subArray and maintaining max value of firstLen subarray.\\n2. I am moving firstLen subArray and maintaining max value of secondLen subarray.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int i=0, j = firstLen;\\n        int n = nums.size();\\n        int sum1=0,sum2=0,summax=0,fmax=0,smax=0;\\n        for(; i<n && j<n;) {\\n            if(i< firstLen) {\\n                sum1 += nums[i];\\n                i++;\\n            }\\n            else if(j < firstLen + secondLen) {\\n                sum2 += nums[j];\\n                j++;\\n            }\\n            else {\\n                sum1 -= nums[i-firstLen];\\n                sum1 += nums[i];\\n                sum2 -= nums[j-secondLen];\\n                sum2 += nums[j];\\n                i++; \\n                j++;\\n            }\\n            summax = max(sum1, summax);\\n            fmax = max(summax+sum2, fmax);\\n        }\\n        i=0; j = secondLen;\\n        sum1=0; sum2 =0; summax=0;\\n        for(; i<n && j<n;) {\\n            if(i< secondLen) {\\n                sum1 += nums[i];\\n                i++;\\n            }\\n            else if(j < firstLen + secondLen) {\\n                sum2 += nums[j];\\n                j++;\\n            }\\n            else {\\n                sum1 -= nums[i-secondLen];\\n                sum1 += nums[i];\\n                sum2 -= nums[j-firstLen];\\n                sum2 += nums[j];\\n                i++;\\n                j++;\\n            }\\n            summax = max(sum1, summax);\\n            smax = max(summax+sum2, smax);\\n        }\\n        return fmax> smax ? fmax:smax;\\n    }\\n};\\n```\\n\\nPlease upvote if found useful.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int i=0, j = firstLen;\\n        int n = nums.size();\\n        int sum1=0,sum2=0,summax=0,fmax=0,smax=0;\\n        for(; i<n && j<n;) {\\n            if(i< firstLen) {\\n                sum1 += nums[i];\\n                i++;\\n            }\\n            else if(j < firstLen + secondLen) {\\n                sum2 += nums[j];\\n                j++;\\n            }\\n            else {\\n                sum1 -= nums[i-firstLen];\\n                sum1 += nums[i];\\n                sum2 -= nums[j-secondLen];\\n                sum2 += nums[j];\\n                i++; \\n                j++;\\n            }\\n            summax = max(sum1, summax);\\n            fmax = max(summax+sum2, fmax);\\n        }\\n        i=0; j = secondLen;\\n        sum1=0; sum2 =0; summax=0;\\n        for(; i<n && j<n;) {\\n            if(i< secondLen) {\\n                sum1 += nums[i];\\n                i++;\\n            }\\n            else if(j < firstLen + secondLen) {\\n                sum2 += nums[j];\\n                j++;\\n            }\\n            else {\\n                sum1 -= nums[i-secondLen];\\n                sum1 += nums[i];\\n                sum2 -= nums[j-firstLen];\\n                sum2 += nums[j];\\n                i++;\\n                j++;\\n            }\\n            summax = max(sum1, summax);\\n            smax = max(summax+sum2, smax);\\n        }\\n        return fmax> smax ? fmax:smax;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294583,
                "title": "python-simple-sliding-window-99",
                "content": "```\\nclass Solution:\\n    def trail(self, A, a, b):\\n        # We want to find the largest value of sa, \\n        # and then the corresponding sb that gives largest result\\n        \\n        sa = ba = sum(A[:a]) # sum from beggining\\n        sb = sum(A[a:b+a])   # sum right after \"sa\"\\n        \\n        best = ba+sb\\n        \\n        for i in range(b+a,len(A)):\\n            sa += A[i-b]- A[i-b-a] # Sum of sa\\n            sb += A[i]  - A[i-b] # Sum of sb\\n            \\n            ba = max( ba, sa ) # This will retain the best sa window\\n            \\n            best = max( best, ba+sb) # Next, we just have to find the largest sb with that best sa\\n\\n        return best\\n    \\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        max_LM_sum = self.trail(A,L,M) # when L is first, followed by M\\n        max_ML_sum = self.trail(A,M,L) # when M is first, followed by L\\n        return max(max_LM_sum, max_ML_sum)\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def trail(self, A, a, b):\\n        # We want to find the largest value of sa, \\n        # and then the corresponding sb that gives largest result\\n        \\n        sa = ba = sum(A[:a]) # sum from beggining\\n        sb = sum(A[a:b+a])   # sum right after \"sa\"\\n        \\n        best = ba+sb\\n        \\n        for i in range(b+a,len(A)):\\n            sa += A[i-b]- A[i-b-a] # Sum of sa\\n            sb += A[i]  - A[i-b] # Sum of sb\\n            \\n            ba = max( ba, sa ) # This will retain the best sa window\\n            \\n            best = max( best, ba+sb) # Next, we just have to find the largest sb with that best sa\\n\\n        return best\\n    \\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        max_LM_sum = self.trail(A,L,M) # when L is first, followed by M\\n        max_ML_sum = self.trail(A,M,L) # when M is first, followed by L\\n        return max(max_LM_sum, max_ML_sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1287923,
                "title": "easy-solution-prefixsum-java",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] n, int f, int s) {\\n        int[] p=new int[n.length+1];\\n        for (int i=0;i<n.length;i++){\\n            p[i+1]=p[i]+n[i];\\n        }\\n        return Math.max(maxSum(p,f,s),maxSum(p,s,f));\\n    }\\n    public int maxSum(int[] p,int f,int s){\\n        int ans=0;\\n        int temp=0;\\n        for (int i=f+s; i<p.length;i++){\\n            temp=Math.max(temp, p[i-f]-p[i-f-s]);\\n            ans=Math.max(ans, temp+p[i]-p[i-f]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] n, int f, int s) {\\n        int[] p=new int[n.length+1];\\n        for (int i=0;i<n.length;i++){\\n            p[i+1]=p[i]+n[i];\\n        }\\n        return Math.max(maxSum(p,f,s),maxSum(p,s,f));\\n    }\\n    public int maxSum(int[] p,int f,int s){\\n        int ans=0;\\n        int temp=0;\\n        for (int i=f+s; i<p.length;i++){\\n            temp=Math.max(temp, p[i-f]-p[i-f-s]);\\n            ans=Math.max(ans, temp+p[i]-p[i-f]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012572,
                "title": "python3-dp-prefix-sum",
                "content": "**Algo**\\nKeep track of max of `M`-sum and `L-sum` so far, and update `ans` with maximum of `M`-sum and current `L`-sum and maximum of `L`-sum and current `M`-sum if larger than existing. \\n\\n**Implementation** \\n```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        prefix = [0]\\n        for x in A: prefix.append(prefix[-1] + x) # prefix sum w/ leading 0\\n        ans = lmx = mmx = -inf \\n        for i in range(M+L, len(A)+1): \\n            lmx = max(lmx, prefix[i-M] - prefix[i-L-M])\\n            mmx = max(mmx, prefix[i-L] - prefix[i-L-M])\\n            ans = max(ans, lmx + prefix[i] - prefix[i-M], mmx + prefix[i] - prefix[i-L])\\n        return ans \\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(1)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        prefix = [0]\\n        for x in A: prefix.append(prefix[-1] + x) # prefix sum w/ leading 0\\n        ans = lmx = mmx = -inf \\n        for i in range(M+L, len(A)+1): \\n            lmx = max(lmx, prefix[i-M] - prefix[i-L-M])\\n            mmx = max(mmx, prefix[i-L] - prefix[i-L-M])\\n            ans = max(ans, lmx + prefix[i] - prefix[i-M], mmx + prefix[i] - prefix[i-L])\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 898385,
                "title": "java-sliding-window",
                "content": "```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int len = A.length;\\n        int[][] lss = slideSum(A, L);\\n        int[][] mss = slideSum(A, M);\\n        \\n        int res = 0;\\n        for (int i = 0; i < A.length-L-M+1; i++) {\\n            res = Math.max(res, Math.max(lss[0][i] + mss[1][i+L], mss[0][i] + lss[1][i+M]));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // slideSum[0][i] is the sliding window sum arr[i] + ... + arr[i+num-1]\\n    // slideSum[1][i] is the max sliding window sum with length of num start from arr[i]\\n    private int[][] slideSum(int[] arr, int num) {\\n        int len = arr.length;\\n        int[][] res = new int[2][len];\\n    \\n        for (int i = len-1; i >= len-num; i--) {\\n            res[0][len-num] += arr[i];\\n            res[1][len-num] += arr[i];\\n        }\\n        \\n        for (int i = len-num-1; i >= 0; i--) {\\n            res[0][i] = res[0][i+1] + arr[i] - arr[i+num];\\n            res[1][i] = Math.max(res[0][i], res[1][i+1]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```java\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int len = A.length;\\n        int[][] lss = slideSum(A, L);\\n        int[][] mss = slideSum(A, M);\\n        \\n        int res = 0;\\n        for (int i = 0; i < A.length-L-M+1; i++) {\\n            res = Math.max(res, Math.max(lss[0][i] + mss[1][i+L], mss[0][i] + lss[1][i+M]));\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // slideSum[0][i] is the sliding window sum arr[i] + ... + arr[i+num-1]\\n    // slideSum[1][i] is the max sliding window sum with length of num start from arr[i]\\n    private int[][] slideSum(int[] arr, int num) {\\n        int len = arr.length;\\n        int[][] res = new int[2][len];\\n    \\n        for (int i = len-1; i >= len-num; i--) {\\n            res[0][len-num] += arr[i];\\n            res[1][len-num] += arr[i];\\n        }\\n        \\n        for (int i = len-num-1; i >= 0; i--) {\\n            res[0][i] = res[0][i+1] + arr[i] - arr[i+num];\\n            res[1][i] = Math.max(res[0][i], res[1][i+1]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882633,
                "title": "easy-step-by-step-solution-with-whiteboard-pictures-o-n",
                "content": "```\\n/*\\n* Really tricky problem but not too hard once you see the method\\n* here is how I see it lets say you have the following array\\n*       [2 , 1 , 5 , 6 , 0 , 9 , 5 , 0 , 3 , 8] with L = 3 M 2\\n* now lets look for our answer when M comes before L we will need to iterate the array like this\\n*       [2 , 1 , 5 , 6 , 0 , 9 , 5 , 0 , 3 ]\\n*       [   M  ][    L     ]\\n*           [   M   ][     L   ]\\n*               [   M  ][    L   ] \\n*                   [   M  ][    L   ]\\n*                      [   M  ][    L   ] \\n* \\n*   where we keep track of the MMax and at every iteration we sum up the mMax and the current L and keep track of the maxValue\\n*   the reasoning behind this is that since the arrays cant intercept mMax will keep track of greatest value of M before our current L\\n* \\n* once we do it one way we now run the algorithm with M and L reversed \\n* \\n* */\\nfun maxSumTwoNoOverlap(A: IntArray, L: Int, M: Int): Int {\\n    val pfsArr = Array(A.size){0}\\n    /*\\n    * We first create a prefix sum array it helps us find the sum between ranges with just a look up\\n    * */\\n    A.forEachIndexed { i, value ->\\n        if(i == 0) pfsArr[i] = value\\n        else{\\n            pfsArr[i] = pfsArr[i-1]+value\\n        }\\n    }\\n    //we call our getMaxVal twice once with M leading and once with M behind\\n    return Math.max(getMaxVal(pfsArr, M , L), getMaxVal(pfsArr, L, M))\\n\\n}\\n\\nfun getMaxVal(pfsArray: Array<Int>, leftSize:Int, rightSize:Int):Int{\\n    val totalLength = leftSize + rightSize\\n    var maxLeft = 0\\n    var rightVal = 0\\n    var maxVal = 0\\n    for(index in leftSize + rightSize - 1 until pfsArray.size){\\n        //keep track of the maxLeft value \\n        maxLeft = Math.max(maxLeft, getRangePfs(pfsArray, index - (totalLength - 1), index - rightSize))\\n        // our current rightValue \\n        rightVal = getRangePfs(pfsArray, index - (rightSize - 1), index)\\n        maxVal = Math.max(maxVal, maxLeft+rightVal)\\n    }\\n    return maxVal\\n}\\n\\n//Helper function to get the sum between ranges \\nfun getRangePfs(pfsArray: Array<Int>, start: Int, end:Int): Int {\\n    if(start == 0) return pfsArray[end]\\n    return pfsArray[end] - pfsArray[start - 1]\\n}\\n\\n//PS. In an interview draw it out its really easy to mess up indexes but its much easier to figure them our when you can see them\\n```\\n\\n![image](https://assets.leetcode.com/users/images/782b5dbe-b205-425a-8be4-a248fac7bebc_1602026927.4240017.png)\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\n/*\\n* Really tricky problem but not too hard once you see the method\\n* here is how I see it lets say you have the following array\\n*       [2 , 1 , 5 , 6 , 0 , 9 , 5 , 0 , 3 , 8] with L = 3 M 2\\n* now lets look for our answer when M comes before L we will need to iterate the array like this\\n*       [2 , 1 , 5 , 6 , 0 , 9 , 5 , 0 , 3 ]\\n*       [   M  ][    L     ]\\n*           [   M   ][     L   ]\\n*               [   M  ][    L   ] \\n*                   [   M  ][    L   ]\\n*                      [   M  ][    L   ] \\n* \\n*   where we keep track of the MMax and at every iteration we sum up the mMax and the current L and keep track of the maxValue\\n*   the reasoning behind this is that since the arrays cant intercept mMax will keep track of greatest value of M before our current L\\n* \\n* once we do it one way we now run the algorithm with M and L reversed \\n* \\n* */\\nfun maxSumTwoNoOverlap(A: IntArray, L: Int, M: Int): Int {\\n    val pfsArr = Array(A.size){0}\\n    /*\\n    * We first create a prefix sum array it helps us find the sum between ranges with just a look up\\n    * */\\n    A.forEachIndexed { i, value ->\\n        if(i == 0) pfsArr[i] = value\\n        else{\\n            pfsArr[i] = pfsArr[i-1]+value\\n        }\\n    }\\n    //we call our getMaxVal twice once with M leading and once with M behind\\n    return Math.max(getMaxVal(pfsArr, M , L), getMaxVal(pfsArr, L, M))\\n\\n}\\n\\nfun getMaxVal(pfsArray: Array<Int>, leftSize:Int, rightSize:Int):Int{\\n    val totalLength = leftSize + rightSize\\n    var maxLeft = 0\\n    var rightVal = 0\\n    var maxVal = 0\\n    for(index in leftSize + rightSize - 1 until pfsArray.size){\\n        //keep track of the maxLeft value \\n        maxLeft = Math.max(maxLeft, getRangePfs(pfsArray, index - (totalLength - 1), index - rightSize))\\n        // our current rightValue \\n        rightVal = getRangePfs(pfsArray, index - (rightSize - 1), index)\\n        maxVal = Math.max(maxVal, maxLeft+rightVal)\\n    }\\n    return maxVal\\n}\\n\\n//Helper function to get the sum between ranges \\nfun getRangePfs(pfsArray: Array<Int>, start: Int, end:Int): Int {\\n    if(start == 0) return pfsArray[end]\\n    return pfsArray[end] - pfsArray[start - 1]\\n}\\n\\n//PS. In an interview draw it out its really easy to mess up indexes but its much easier to figure them our when you can see them\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 846478,
                "title": "o-n-time-and-space-complexity-prefixsum-explanation",
                "content": "We need 2 subarrays which are non-overlapping with size M and L. \\nLets Suppose the 2 subarrays are **\\'A\\' and \\'B\\'** with window size M and L respectively.\\n\\nThere can only be 2 cases possible **A starts and completes before B** (that is, A = [i, i+M] , B = [j, j+L] where i+M < j )\\nor **A start and end after B** (that is, A = [i, i+M] , B = [j, j+L] where j+L < i ).\\nCalculate prefixSum in both the directions, namely prefixSum and prefixSumReverse. \\n\\n**For Case1.**\\nIn the solution we will only use these 2 facts, first we will consider **A is the subarray with smaller size -> min(M,L)** and **B is the subarray with bigger size -> max(M, L)**. \\n\\nTake i from L+M-1 till size of array. (We took i as L+M-1 so that both B and A subarray can fit in < i. ). B size subarray sum will be  **[i-max(L-1,M-1),i]** and we will add it with the max Sum we have find for **A subarray** before i of size min(M-1, L-1). \\n\\n**Similarly for case 2, loop in opposite direction,**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        vector<int> prefixSum(n, 0);\\n        prefixSum[0] = A[0];\\n        \\n        for(int i=1; i<n; i++) {\\n            prefixSum[i] = prefixSum[i-1] + A[i];\\n        }\\n        \\n        vector<int> prefixSumReverse(n, 0);\\n        prefixSumReverse[n-1] = A[n-1];\\n        for(int i=n-2; i>=0; i--) {\\n            prefixSumReverse[i] = prefixSumReverse[i+1] + A[i];\\n        }\\n        \\n        int maxAns = 0;\\n        \\n        int i = M+L-1;\\n        int j = min(M-1, L-1);\\n        int maxSecond = prefixSum[j];\\n        \\n        for(; i<n; i++) {\\n            maxAns = max(prefixSum[i] - prefixSum[j] + maxSecond, maxAns);\\n            j++;\\n            maxSecond = max(maxSecond, prefixSum[j] - prefixSum[j - min(M, L)]);\\n        }\\n        \\n        i = (n-1) - (M+L-1);\\n        j = (n-1) - min(M-1, L-1);\\n        maxSecond = prefixSumReverse[j];\\n        for(; i>=0; i--) {\\n            maxAns = max(prefixSumReverse[i] - prefixSumReverse[j] + maxSecond, maxAns);\\n            j--;\\n            maxSecond = max(maxSecond, prefixSumReverse[j] - prefixSumReverse[j + min(M, L)]);\\n        }\\n        return maxAns;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        vector<int> prefixSum(n, 0);\\n        prefixSum[0] = A[0];\\n        \\n        for(int i=1; i<n; i++) {\\n            prefixSum[i] = prefixSum[i-1] + A[i];\\n        }\\n        \\n        vector<int> prefixSumReverse(n, 0);\\n        prefixSumReverse[n-1] = A[n-1];\\n        for(int i=n-2; i>=0; i--) {\\n            prefixSumReverse[i] = prefixSumReverse[i+1] + A[i];\\n        }\\n        \\n        int maxAns = 0;\\n        \\n        int i = M+L-1;\\n        int j = min(M-1, L-1);\\n        int maxSecond = prefixSum[j];\\n        \\n        for(; i<n; i++) {\\n            maxAns = max(prefixSum[i] - prefixSum[j] + maxSecond, maxAns);\\n            j++;\\n            maxSecond = max(maxSecond, prefixSum[j] - prefixSum[j - min(M, L)]);\\n        }\\n        \\n        i = (n-1) - (M+L-1);\\n        j = (n-1) - min(M-1, L-1);\\n        maxSecond = prefixSumReverse[j];\\n        for(; i>=0; i--) {\\n            maxAns = max(prefixSumReverse[i] - prefixSumReverse[j] + maxSecond, maxAns);\\n            j--;\\n            maxSecond = max(maxSecond, prefixSumReverse[j] - prefixSumReverse[j + min(M, L)]);\\n        }\\n        return maxAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687930,
                "title": "python3-one-pass-o-1-space-o-n-time",
                "content": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\t\\t# 1 is the case that L precedes M\\n\\t\\t# 2 is the case that M precedes L\\n        total1L, total1M, total2M, total2L = 0, 0, 0, 0\\n        N = len(A)\\n        total = 0\\n\\t\\t# For initial L + M elements, find the total\\n        for i in range(L + M):\\n            total += A[i]\\n            if i == L - 1:\\n                total1L = total\\n            if i == M - 1:\\n                total2M = total\\n        total1M, total2L = total - total1L, total - total2M\\n\\t\\t# res1 is the maximum sum of L subarry before the last M elements\\n\\t\\t# res2 is the maximum sum of M subarry before the last L elements\\n        res1, res2 = total1L, total2M\\n\\t\\t# res is the final result, initially it is the sum of the first L + M elements\\n        res = total\\n        for i in range(L + M, N):\\n            total1M += A[i] - A[i-M]\\n            total2L += A[i] - A[i-L]\\n            total1L += A[i-M] - A[i-L-M]\\n            res1 = max(res1, total1L)\\n            total2M += A[i-L] - A[i-L-M]\\n            res2 = max(res2, total2M)\\n            res = max(res, total1M + res1, total2L + res2)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\t\\t# 1 is the case that L precedes M\\n\\t\\t# 2 is the case that M precedes L\\n        total1L, total1M, total2M, total2L = 0, 0, 0, 0\\n        N = len(A)\\n        total = 0\\n\\t\\t# For initial L + M elements, find the total\\n        for i in range(L + M):\\n            total += A[i]\\n            if i == L - 1:\\n                total1L = total\\n            if i == M - 1:\\n                total2M = total\\n        total1M, total2L = total - total1L, total - total2M\\n\\t\\t# res1 is the maximum sum of L subarry before the last M elements\\n\\t\\t# res2 is the maximum sum of M subarry before the last L elements\\n        res1, res2 = total1L, total2M\\n\\t\\t# res is the final result, initially it is the sum of the first L + M elements\\n        res = total\\n        for i in range(L + M, N):\\n            total1M += A[i] - A[i-M]\\n            total2L += A[i] - A[i-L]\\n            total1L += A[i-M] - A[i-L-M]\\n            res1 = max(res1, total1L)\\n            total2M += A[i-L] - A[i-L-M]\\n            res2 = max(res2, total2M)\\n            res = max(res, total1M + res1, total2L + res2)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683082,
                "title": "c-o-1-space-o-n-time",
                "content": "```\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n     \\n     //Create a prefix sum array\\n     for(int i=1; i<A.size(); i++)\\n         A[i] += A[i-1];\\n        \\n     //We\\'ll start from left and see what is the maximum sum window of length L, Lmax\\n     //also starting from left and see what is the maximum sum window of length M, Mmax\\n     //Now we have two candidates that can form max sum :\\n     //   1.  Lmax + (maximum sum window of length M to right of Lmax)\\n     //   2.  Mmax + (maximum sum window of length L to right of Mmax)\\n     //  (remember Lmax and Mmax are independent and have nothing to do with each other)\\n     //   \\n     //Why we formed prefix sum array ?\\n     //-> so that we can get these sums like, A[L-1], A[M-1], etc. in O(1) time\\n        \\n     int Lmax = A[L-1];         //initially we keep, Lmax = sum of L length window from [0, L-1]\\n     int Mmax = A[M-1];         //initially we keep, Mmax = sum of M length window from [0, M-1] \\n     int maxSum = A[L+M-1];     //for convenience we are initially keeping maxSum = sum of window from [0, L+M-1]\\n        \\n     for(int i=L+M; i<A.size(); i++) {\\n        //Now we are sliding windows to right \\n        Lmax = max(Lmax, A[i-M] - A[i-L-M]);\\n        Mmax = max(Mmax, A[i-L] - A[i-L-M]); \\n       \\n       maxSum = max(maxSum, max(Lmax + A[i] - A[i-M], Mmax + A[i] - A[i-L]));  \\n     }   \\n    return maxSum;\\n    }\\n\\t\\n\\t//this solution is referenced from Lee\\'s solution",
                "solutionTags": [],
                "code": "```\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n     \\n     //Create a prefix sum array\\n     for(int i=1; i<A.size(); i++)\\n         A[i] += A[i-1];\\n        \\n     //We\\'ll start from left and see what is the maximum sum window of length L, Lmax\\n     //also starting from left and see what is the maximum sum window of length M, Mmax\\n     //Now we have two candidates that can form max sum :\\n     //   1.  Lmax + (maximum sum window of length M to right of Lmax)\\n     //   2.  Mmax + (maximum sum window of length L to right of Mmax)\\n     //  (remember Lmax and Mmax are independent and have nothing to do with each other)\\n     //   \\n     //Why we formed prefix sum array ?\\n     //-> so that we can get these sums like, A[L-1], A[M-1], etc. in O(1) time\\n        \\n     int Lmax = A[L-1];         //initially we keep, Lmax = sum of L length window from [0, L-1]\\n     int Mmax = A[M-1];         //initially we keep, Mmax = sum of M length window from [0, M-1] \\n     int maxSum = A[L+M-1];     //for convenience we are initially keeping maxSum = sum of window from [0, L+M-1]\\n        \\n     for(int i=L+M; i<A.size(); i++) {\\n        //Now we are sliding windows to right \\n        Lmax = max(Lmax, A[i-M] - A[i-L-M]);\\n        Mmax = max(Mmax, A[i-L] - A[i-L-M]); \\n       \\n       maxSum = max(maxSum, max(Lmax + A[i] - A[i-M], Mmax + A[i] - A[i-L]));  \\n     }   \\n    return maxSum;\\n    }\\n\\t\\n\\t//this solution is referenced from Lee\\'s solution",
                "codeTag": "Unknown"
            },
            {
                "id": 632215,
                "title": "simple-java-solution-beats-100-o-n-and-o-n-with-comments",
                "content": "```\\n// prefix sum array for quick lookup\\n// two cases: case 1 - M before L; case 2 - L before M. \\n// take L before M as an example: maintain max L length subarray sum, and enumerate all the non-overlapping M length subarray sum, and \\n// calculate the max sum.\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        int[] prefix = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                prefix[i] = A[i];\\n                continue;\\n            }\\n            prefix[i] = prefix[i - 1] + A[i];\\n        }\\n\\t\\t// initialize max sum for L length and M length subarrays respectively\\n        int lmax = prefix[L - 1], mmax = prefix[M - 1];\\n\\t\\t//initialize max sum for case 1 and case 2\\n        int max1 = 0, max2 = 0;\\n\\t\\t//L before M. enumerate all the M length subarray sums, while maintaining max L length subarray sum\\n        for (int i = L; i <= n - M; i++) {\\n            int mSum = prefix[i + M - 1] - prefix[i] + A[i];\\n            max1 = Math.max(max1, mSum + lmax);\\n            lmax = Math.max(lmax, prefix[i] - prefix[i - L]);\\n        }\\n\\t\\t//M before L. enumerate all the L length subarray sums, while maintaining max M length subarray sum\\n        for (int i = M; i <= n - L; i++) {\\n            int lSum = prefix[i + L - 1] - prefix[i] + A[i];\\n            max2 = Math.max(max2, lSum + mmax);\\n            mmax = Math.max(mmax, prefix[i] - prefix[i - M]);\\n        }\\n        return Math.max(max1, max2);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n// prefix sum array for quick lookup\\n// two cases: case 1 - M before L; case 2 - L before M. \\n// take L before M as an example: maintain max L length subarray sum, and enumerate all the non-overlapping M length subarray sum, and \\n// calculate the max sum.\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        int[] prefix = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            if (i == 0) {\\n                prefix[i] = A[i];\\n                continue;\\n            }\\n            prefix[i] = prefix[i - 1] + A[i];\\n        }\\n\\t\\t// initialize max sum for L length and M length subarrays respectively\\n        int lmax = prefix[L - 1], mmax = prefix[M - 1];\\n\\t\\t//initialize max sum for case 1 and case 2\\n        int max1 = 0, max2 = 0;\\n\\t\\t//L before M. enumerate all the M length subarray sums, while maintaining max L length subarray sum\\n        for (int i = L; i <= n - M; i++) {\\n            int mSum = prefix[i + M - 1] - prefix[i] + A[i];\\n            max1 = Math.max(max1, mSum + lmax);\\n            lmax = Math.max(lmax, prefix[i] - prefix[i - L]);\\n        }\\n\\t\\t//M before L. enumerate all the L length subarray sums, while maintaining max M length subarray sum\\n        for (int i = M; i <= n - L; i++) {\\n            int lSum = prefix[i + L - 1] - prefix[i] + A[i];\\n            max2 = Math.max(max2, lSum + mmax);\\n            mmax = Math.max(mmax, prefix[i] - prefix[i - M]);\\n        }\\n        return Math.max(max1, max2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 540693,
                "title": "c-use-prefix-sum-array-to-facilitate-sliding-window-analysis-91-speed-100-memory",
                "content": "Pre-calculate a prefix sum array to enable access to the sum of all elements before any position i in the original vector. Iterate over all possible L-length, continuous sub-array sums; at each iteration, iterate over all possible M-length sub-arrays located before and after the current L array (such that there is no overlap), store the maximum L+M sum found.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        \\n        vector<int> prefixSum(A.size()+1, 0);         //at position i, sum of all numbers before i\\n        int max = -1;\\n        \\n        for (int i = 1; i < prefixSum.size(); ++i) {  //precalculate prefix sums, to speed up sliding\\n            prefixSum[i] = prefixSum[i-1]+A[i-1];     //window calcs\\n        }\\n        \\n        for (int i = L; i < prefixSum.size(); ++i) {   //Iterating over all possible L subarrays\\n            int lSum = prefixSum[i]-prefixSum[i-L];    //Get the LSum\\n            \\n            for (int j = M; j < i-L; ++j) {            //Iterate over all possible M\\'s before the current L\\n                int mSum = prefixSum[j]-prefixSum[j-M];\\n                if (lSum + mSum > max) {               //If we found a new max L+M, store it\\n                    max = lSum + mSum;\\n                }\\n            }\\n            \\n            for (int j = i + M; j < prefixSum.size(); ++j) { //Iterate over all possible M\\'s after the L\\n                int mSum = prefixSum[j] - prefixSum[j-M];\\n                if (lSum + mSum > max) {              //If we found a new max L+M, store it\\n                    max = lSum + mSum;\\n                }\\n            }\\n        }\\n        \\n        return max;                         //return the max\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        \\n        vector<int> prefixSum(A.size()+1, 0);         //at position i, sum of all numbers before i\\n        int max = -1;\\n        \\n        for (int i = 1; i < prefixSum.size(); ++i) {  //precalculate prefix sums, to speed up sliding\\n            prefixSum[i] = prefixSum[i-1]+A[i-1];     //window calcs\\n        }\\n        \\n        for (int i = L; i < prefixSum.size(); ++i) {   //Iterating over all possible L subarrays\\n            int lSum = prefixSum[i]-prefixSum[i-L];    //Get the LSum\\n            \\n            for (int j = M; j < i-L; ++j) {            //Iterate over all possible M\\'s before the current L\\n                int mSum = prefixSum[j]-prefixSum[j-M];\\n                if (lSum + mSum > max) {               //If we found a new max L+M, store it\\n                    max = lSum + mSum;\\n                }\\n            }\\n            \\n            for (int j = i + M; j < prefixSum.size(); ++j) { //Iterate over all possible M\\'s after the L\\n                int mSum = prefixSum[j] - prefixSum[j-M];\\n                if (lSum + mSum > max) {              //If we found a new max L+M, store it\\n                    max = lSum + mSum;\\n                }\\n            }\\n        }\\n        \\n        return max;                         //return the max\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534911,
                "title": "faster-than-100-prefix-sum-o-n",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int[] p = getPresum(A);\\n        return Math.max(findMaxSumOfSubarraysInSequence(p,A,L,M),                                             findMaxSumOfSubarraysInSequence(p,A,M,L));\\n    }\\n    \\n    //first select L and then M on right of L\\n    private int findMaxSumOfSubarraysInSequence(int[] p, int[] A, int L, int M){\\n        int max = p[L+M-1]; //first case will be L starting at 0 and then M\\n        int lsum = p[L-1];\\n        for(int i=L+M; i<A.length; i++){\\n            lsum = Math.max(lsum, p[i-M]-p[i-L-M]); //take max lsum till now\\n            max = Math.max(max, lsum+p[i]-p[i-M]);\\n        }\\n        return max;\\n    }\\n    \\n    private int[] getPresum(int[] arr){\\n        int[] p = new int[arr.length];\\n        int sum = 0;\\n        for(int i=0; i<arr.length; i++){\\n            sum+=arr[i];\\n            p[i] = sum;\\n        }\\n        return p;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int[] p = getPresum(A);\\n        return Math.max(findMaxSumOfSubarraysInSequence(p,A,L,M),                                             findMaxSumOfSubarraysInSequence(p,A,M,L));\\n    }\\n    \\n    //first select L and then M on right of L\\n    private int findMaxSumOfSubarraysInSequence(int[] p, int[] A, int L, int M){\\n        int max = p[L+M-1]; //first case will be L starting at 0 and then M\\n        int lsum = p[L-1];\\n        for(int i=L+M; i<A.length; i++){\\n            lsum = Math.max(lsum, p[i-M]-p[i-L-M]); //take max lsum till now\\n            max = Math.max(max, lsum+p[i]-p[i-M]);\\n        }\\n        return max;\\n    }\\n    \\n    private int[] getPresum(int[] arr){\\n        int[] p = new int[arr.length];\\n        int sum = 0;\\n        for(int i=0; i<arr.length; i++){\\n            sum+=arr[i];\\n            p[i] = sum;\\n        }\\n        return p;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 290299,
                "title": "java-o-n-very-easy-to-understand-solution",
                "content": "1, build a prefixSum table for easy calculation of regional sum \\n2, build regional sum max table, from left, from right \\n3, calculate the max from two direction \\n\\n```\\nclass Solution {\\n    public  int maxSumTwoNoOverlap(int[] a, int l, int m) {\\n\\n        int len = a.length;\\n        int[] ps = new int[len];\\n        ps[0] = a[0];\\n        for (int i = 1; i < len; i++) {\\n            ps[i] = ps[i - 1] + a[i];\\n        }\\n\\n        if (l + m == len) return ps[len - 1];\\n        return Math.max(h(a, ps, l, m, len), h(a, ps, m, l, len));\\n    }\\n\\n    private  int h(int[] a, int[] ps, int left, int right, int len) {\\n\\n        int[] leftMax = new int[len];\\n        int[] rightMax = new int[len];\\n\\n        for (int i = left - 1; i < len; i++) {\\n            int tmp = ps[i] - ps[i - left + 1] + a[i - left + 1];\\n            if (i == left - 1) {\\n                leftMax[i] = tmp;\\n            } else {\\n                leftMax[i] = Math.max(leftMax[i - 1], tmp);\\n            }\\n        }\\n\\n        for (int i = len - right; i >= 0; i--) {\\n            int tmp = ps[i + right - 1] - ps[i] + a[i];\\n            if (i == len - right) {\\n                rightMax[i] = tmp;\\n            } else {\\n                rightMax[i] = Math.max(rightMax[i + 1], tmp);\\n            }\\n        }\\n\\n        int sum = Integer.MIN_VALUE;\\n\\n        for (int i = left - 1; i < len - right; i++) {\\n            sum = Math.max(sum, leftMax[i] + rightMax[i + 1]);\\n        }\\n\\n        return sum;\\n\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public  int maxSumTwoNoOverlap(int[] a, int l, int m) {\\n\\n        int len = a.length;\\n        int[] ps = new int[len];\\n        ps[0] = a[0];\\n        for (int i = 1; i < len; i++) {\\n            ps[i] = ps[i - 1] + a[i];\\n        }\\n\\n        if (l + m == len) return ps[len - 1];\\n        return Math.max(h(a, ps, l, m, len), h(a, ps, m, l, len));\\n    }\\n\\n    private  int h(int[] a, int[] ps, int left, int right, int len) {\\n\\n        int[] leftMax = new int[len];\\n        int[] rightMax = new int[len];\\n\\n        for (int i = left - 1; i < len; i++) {\\n            int tmp = ps[i] - ps[i - left + 1] + a[i - left + 1];\\n            if (i == left - 1) {\\n                leftMax[i] = tmp;\\n            } else {\\n                leftMax[i] = Math.max(leftMax[i - 1], tmp);\\n            }\\n        }\\n\\n        for (int i = len - right; i >= 0; i--) {\\n            int tmp = ps[i + right - 1] - ps[i] + a[i];\\n            if (i == len - right) {\\n                rightMax[i] = tmp;\\n            } else {\\n                rightMax[i] = Math.max(rightMax[i + 1], tmp);\\n            }\\n        }\\n\\n        int sum = Integer.MIN_VALUE;\\n\\n        for (int i = left - 1; i < len - right; i++) {\\n            sum = Math.max(sum, leftMax[i] + rightMax[i + 1]);\\n        }\\n\\n        return sum;\\n\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282773,
                "title": "straightforward-o-n-max-contagious-array-solution-with-comments",
                "content": "```\\n//         Lmax, max sum of contiguous L elements before the last M elements.\\n// Mmax, max sum of contiguous M elements before the last L elements/\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        //get the presum array\\n        int preSum[] = new int[A.length];\\n        preSum[0] = A[0];\\n        for(int i = 1; i < A.length; i++) {\\n            preSum[i] = preSum[i - 1] + A[i];\\n        }\\n        int result = preSum[L+M - 1];\\n        int LMax = preSum[L - 1];\\n        int MMax = preSum[M - 1];\\n       // System.out.println()\\n        for(int i = L + M; i < A.length; i++) {\\n           LMax = Math.max(LMax, preSum[i - M] - preSum[i - M - L]);\\n           MMax = Math.max(MMax, preSum[i - L] - preSum[i - L - M]);\\n           result = Math.max(result, Math.max(preSum[i] - preSum[i - M] + LMax, preSum[i] - preSum[i - L] + MMax));\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n//         Lmax, max sum of contiguous L elements before the last M elements.\\n// Mmax, max sum of contiguous M elements before the last L elements/\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        //get the presum array\\n        int preSum[] = new int[A.length];\\n        preSum[0] = A[0];\\n        for(int i = 1; i < A.length; i++) {\\n            preSum[i] = preSum[i - 1] + A[i];\\n        }\\n        int result = preSum[L+M - 1];\\n        int LMax = preSum[L - 1];\\n        int MMax = preSum[M - 1];\\n       // System.out.println()\\n        for(int i = L + M; i < A.length; i++) {\\n           LMax = Math.max(LMax, preSum[i - M] - preSum[i - M - L]);\\n           MMax = Math.max(MMax, preSum[i - L] - preSum[i - L - M]);\\n           result = Math.max(result, Math.max(preSum[i] - preSum[i - M] + LMax, preSum[i] - preSum[i - L] + MMax));\\n\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278791,
                "title": "use-two-sliding-windows",
                "content": "```\\n public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int max=0;\\n        int sum1=0,sum2=0;\\n        int n =A.length;\\n\\n        for (int i=0;i<L;i++)\\n            sum1+= A[i];\\n        int temp1=sum1;\\n        for (int i=0;i<M;i++)\\n            sum2+= A[i];\\n        int temp2=sum2;\\n        for (int i= L-1;i<n;i++){\\n            if (i!=L-1)\\n            sum1=sum1+A[i]-A[i-L];\\n            for (int j=M-1;j<n;j++){\\n                if (j!=M-1)\\n                sum2=sum2+A[j]-A[j-M];\\n                if (j<i-L+1||j-M+1>i){\\n                    max=Math.max(max,(i==L-1?temp1:sum1)+(j==M-1?temp2:sum2));}\\n            }\\n            sum2=temp2;\\n        }\\n        return max;\\n    }",
                "solutionTags": [],
                "code": "```\\n public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int max=0;\\n        int sum1=0,sum2=0;\\n        int n =A.length;\\n\\n        for (int i=0;i<L;i++)\\n            sum1+= A[i];\\n        int temp1=sum1;\\n        for (int i=0;i<M;i++)\\n            sum2+= A[i];\\n        int temp2=sum2;\\n        for (int i= L-1;i<n;i++){\\n            if (i!=L-1)\\n            sum1=sum1+A[i]-A[i-L];\\n            for (int j=M-1;j<n;j++){\\n                if (j!=M-1)\\n                sum2=sum2+A[j]-A[j-M];\\n                if (j<i-L+1||j-M+1>i){\\n                    max=Math.max(max,(i==L-1?temp1:sum1)+(j==M-1?temp2:sum2));}\\n            }\\n            sum2=temp2;\\n        }\\n        return max;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2652494,
                "title": "c-solution-with-explanation",
                "content": "**Explanation**\\nYou can either have firstLen elements on the left and secondLen elements on the right or vice versa.\\n\\nUse two vectors to calculate the results of both sliding windows with the index of the vector indicating the start location of the sliding window.\\n\\nThe max sum is then trivially computable by considering either firstLen first or secondLen first.\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(const vector<int>& nums, int firstLen, int secondLen) {\\n        const auto get_possibilities = [&nums](const int length){\\n            std::vector<int> possibilities;\\n            int window_sum{0};\\n            for(int i = 0; i < length; ++i) {\\n                window_sum += nums[i];\\n            }\\n            possibilities.push_back(window_sum);\\n            for(int i = length; i < nums.size(); ++i) {\\n                window_sum = window_sum - nums[i - length] + nums[i];\\n                possibilities.push_back(window_sum);\\n            }   \\n            return possibilities;\\n        };\\n        \\n        const auto first_possibilities = get_possibilities(firstLen);\\n        const auto second_possibilities = get_possibilities(secondLen);\\n        \\n        const auto get_max_sum = [&nums](const std::vector<int>& first, const int firstLen, const std::vector<int>& second) {\\n            int max_sum = std::numeric_limits<int>::min();\\n            for(int i = 0; i < first.size(); ++i) {\\n                for(int j = i + firstLen; j < second.size(); ++j) {\\n                    int sum = first[i] + second[j];\\n                    max_sum = std::max(max_sum, sum);\\n                }\\n            }\\n            return max_sum;\\n        };\\n        \\n        const auto left_first = get_max_sum(first_possibilities, firstLen, second_possibilities);\\n        const auto left_second = get_max_sum(second_possibilities, secondLen, first_possibilities);\\n        \\n        return std::max(left_first, left_second); \\n\\t}\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(const vector<int>& nums, int firstLen, int secondLen) {\\n        const auto get_possibilities = [&nums](const int length){\\n            std::vector<int> possibilities;\\n            int window_sum{0}",
                "codeTag": "Java"
            },
            {
                "id": 2225496,
                "title": "python-easy-to-understand",
                "content": "```\\n def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        \\n        n=len(nums)\\n        \\n        firstPrefix=[0]*n\\n        secondPrefix=[0]*n\\n        p1=p2=0\\n        mx1=mx2=0\\n        \\n        firstSufix=[0]*n\\n        secondSufix=[0]*n\\n        s1=s2=0\\n        smx1=smx2=0\\n        \\n        ans=0\\n        \\n        #prefix sum of firstlen\\n        for i in range(n):\\n            if i<firstLen:\\n                p1+=nums[i]\\n                firstPrefix[i]=p1\\n            else:\\n                p1=nums[i]+p1-nums[i-firstLen]\\n                #print(p1,p1,nums[i],nums[i-firstLen])\\n                mx1=max(p1,mx1)\\n                firstPrefix[i]=mx1\\n        #print(firstPrefix)\\n        \\n        #Sufix sum of Secondtlen\\n        for i in range(n-1,-1,-1):\\n            if i>=n-secondLen:\\n                s2+=nums[i]\\n                secondSufix[i]=s2\\n                #print(s2)\\n                smx2=s2\\n            else:\\n                s2=nums[i]+s2-nums[i+secondLen]\\n                #print(p1,p1,nums[i],nums[i-firstLen])\\n                smx2=max(s2,smx2)\\n                secondSufix[i]=smx2\\n        #print(secondSufix)\\n        \\n        #Sufix sum of firstlen\\n        for i in range(n-1,-1,-1):\\n            if i>=n-firstLen:\\n                s1+=nums[i]\\n                firstSufix[i]=s1\\n                smx1=s1\\n            else:\\n                s1=nums[i]+s1-nums[i+firstLen]\\n                #print(p1,p1,nums[i],nums[i-firstLen])\\n                smx1=max(s1,smx1)\\n                firstSufix[i]=smx1\\n        #print(firstSufix)\\n        \\n        #prefix sum of secondlen\\n        for i in range(n):\\n            if i<secondLen:\\n                p2+=nums[i]\\n                secondPrefix[i]=p2\\n            else:\\n                p2=nums[i]+p2-nums[i-secondLen]\\n                #print(p1,p1,nums[i],nums[i-secondLen])\\n                mx2=max(p2,mx2)\\n                secondPrefix[i]=mx2\\n        #print(secondPrefix)\\n        \\n        #maximum sum\\n        for i in range(n-1):\\n            ans=max(ans,firstPrefix[i]+secondSufix[i+1],secondPrefix[i]+firstSufix[i+1])\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        \\n        n=len(nums)\\n        \\n        firstPrefix=[0]*n\\n        secondPrefix=[0]*n\\n        p1=p2=0\\n        mx1=mx2=0\\n        \\n        firstSufix=[0]*n\\n        secondSufix=[0]*n\\n        s1=s2=0\\n        smx1=smx2=0\\n        \\n        ans=0\\n        \\n        #prefix sum of firstlen\\n        for i in range(n):\\n            if i<firstLen:\\n                p1+=nums[i]\\n                firstPrefix[i]=p1\\n            else:\\n                p1=nums[i]+p1-nums[i-firstLen]\\n                #print(p1,p1,nums[i],nums[i-firstLen])\\n                mx1=max(p1,mx1)\\n                firstPrefix[i]=mx1\\n        #print(firstPrefix)\\n        \\n        #Sufix sum of Secondtlen\\n        for i in range(n-1,-1,-1):\\n            if i>=n-secondLen:\\n                s2+=nums[i]\\n                secondSufix[i]=s2\\n                #print(s2)\\n                smx2=s2\\n            else:\\n                s2=nums[i]+s2-nums[i+secondLen]\\n                #print(p1,p1,nums[i],nums[i-firstLen])\\n                smx2=max(s2,smx2)\\n                secondSufix[i]=smx2\\n        #print(secondSufix)\\n        \\n        #Sufix sum of firstlen\\n        for i in range(n-1,-1,-1):\\n            if i>=n-firstLen:\\n                s1+=nums[i]\\n                firstSufix[i]=s1\\n                smx1=s1\\n            else:\\n                s1=nums[i]+s1-nums[i+firstLen]\\n                #print(p1,p1,nums[i],nums[i-firstLen])\\n                smx1=max(s1,smx1)\\n                firstSufix[i]=smx1\\n        #print(firstSufix)\\n        \\n        #prefix sum of secondlen\\n        for i in range(n):\\n            if i<secondLen:\\n                p2+=nums[i]\\n                secondPrefix[i]=p2\\n            else:\\n                p2=nums[i]+p2-nums[i-secondLen]\\n                #print(p1,p1,nums[i],nums[i-secondLen])\\n                mx2=max(p2,mx2)\\n                secondPrefix[i]=mx2\\n        #print(secondPrefix)\\n        \\n        #maximum sum\\n        for i in range(n-1):\\n            ans=max(ans,firstPrefix[i]+secondSufix[i+1],secondPrefix[i]+firstSufix[i+1])\\n            \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1966972,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sliding Window***\\n\\n* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<int>& nums, int x, int y)\\n    {\\n        int n = nums.size();\\n        \\n        vector<int> dp_left_max(n, 0);\\n        \\n        vector<int> dp_right_max(n, 0);\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < x)\\n            {\\n                sum += nums[i];\\n                \\n                dp_left_max[i] = sum;\\n            }\\n            else if(i >= x)\\n            {\\n                sum += nums[i] - nums[i - x];\\n                \\n                dp_left_max[i] = max(dp_left_max[i - 1], sum);\\n            }\\n        }\\n        \\n        sum = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(i >= n - y)\\n            {\\n                sum += nums[i];\\n                \\n                dp_right_max[i] = sum;\\n            }\\n            else\\n            {\\n                sum += nums[i] - nums[i + y];\\n                \\n                dp_right_max[i] = max(dp_right_max[i + 1], sum);\\n            }\\n        }\\n        \\n        int ans = INT_MIN;\\n        \\n        for(int i = x - 1; i < n - y; i++)\\n        {\\n            ans = max(ans, dp_left_max[i] + dp_right_max[i + 1]);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& nums, int x, int y) {\\n        \\n        int n = nums.size();\\n        \\n        int max1 = helper(nums, x, y);\\n        \\n        int max2 = helper(nums, y, x);\\n        \\n        return max(max1, max2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int helper(vector<int>& nums, int x, int y)\\n    {\\n        int n = nums.size();\\n        \\n        vector<int> dp_left_max(n, 0);\\n        \\n        vector<int> dp_right_max(n, 0);\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < x)\\n            {\\n                sum += nums[i];\\n                \\n                dp_left_max[i] = sum;\\n            }\\n            else if(i >= x)\\n            {\\n                sum += nums[i] - nums[i - x];\\n                \\n                dp_left_max[i] = max(dp_left_max[i - 1], sum);\\n            }\\n        }\\n        \\n        sum = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(i >= n - y)\\n            {\\n                sum += nums[i];\\n                \\n                dp_right_max[i] = sum;\\n            }\\n            else\\n            {\\n                sum += nums[i] - nums[i + y];\\n                \\n                dp_right_max[i] = max(dp_right_max[i + 1], sum);\\n            }\\n        }\\n        \\n        int ans = INT_MIN;\\n        \\n        for(int i = x - 1; i < n - y; i++)\\n        {\\n            ans = max(ans, dp_left_max[i] + dp_right_max[i + 1]);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& nums, int x, int y) {\\n        \\n        int n = nums.size();\\n        \\n        int max1 = helper(nums, x, y);\\n        \\n        int max2 = helper(nums, y, x);\\n        \\n        return max(max1, max2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911608,
                "title": "python-simple-clean-solution-with-a-single-loop-o-n-40ms-easy-to-understand",
                "content": "**Simple and clean solution with a single loop**\\n\\nTime complexity: O(N)\\n\\n```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        acc_sum = [0] * (len(nums) + 1)\\n        max_1st, max_2nd, mx_ans = -1, -1, -1\\n\\n        for index in range(1, len(acc_sum)):\\n            acc_sum[index] = acc_sum[index - 1] + nums[index - 1]\\n\\n            if index >= firstLen + secondLen:\\n                max_1st = max(max_1st, acc_sum[index - secondLen] - acc_sum[index - secondLen - firstLen])\\n                max_2nd = max(max_2nd, acc_sum[index - firstLen] - acc_sum[index - firstLen - secondLen])\\n\\n                first_second = max_1st + acc_sum[index] - acc_sum[index - secondLen]\\n                second_first = max_2nd + acc_sum[index] - acc_sum[index - firstLen]\\n                mx_ans = max(mx_ans, first_second, second_first)\\n\\n        return mx_ans\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        acc_sum = [0] * (len(nums) + 1)\\n        max_1st, max_2nd, mx_ans = -1, -1, -1\\n\\n        for index in range(1, len(acc_sum)):\\n            acc_sum[index] = acc_sum[index - 1] + nums[index - 1]\\n\\n            if index >= firstLen + secondLen:\\n                max_1st = max(max_1st, acc_sum[index - secondLen] - acc_sum[index - secondLen - firstLen])\\n                max_2nd = max(max_2nd, acc_sum[index - firstLen] - acc_sum[index - firstLen - secondLen])\\n\\n                first_second = max_1st + acc_sum[index] - acc_sum[index - secondLen]\\n                second_first = max_2nd + acc_sum[index] - acc_sum[index - firstLen]\\n                mx_ans = max(mx_ans, first_second, second_first)\\n\\n        return mx_ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668230,
                "title": "java-o-n-time-complexity-dynamic-programming-explanation-in-detail-easy-to-understand",
                "content": "We need to find the 2 subarrays, so two cases are possible-\\n   1. first subArray appear before the second subArray\\n   2. second subArray appear before first subArray\\nand so, I will be solving this problem using dynamic programming and also using prefix and suffix sum concept to reduce the complexity.\\nand I will define 2 arrays for each case\\n--> Evaluate the prefix sum and suffix sum of the given array.       // you can also use 2 pointer instead of prefix and suffix to save space/memory.\\n    EXAMPLE:  nums = [0,6,5,2,2,5,1,9,4], firstLen = 1, secondLen = 2\\n               prefixSum=[0, 6, 11, 13, 15, 20, 21, 30, 34]\\n               suffixSum=[34, 34, 28, 23, 21, 19, 14, 13, 4]\\n\\nConsidering case 1 - first subArray appear before the second subArray \\n                     Create two arrays ,\\n                       leftSubarraymax=[0, 6, 6, 6, 6, 6, 6, 9, 9]    // stores the maximum sum of first subarray with length firstLen using prefixSum array.\\n                                             // ith position represents the maximum first subarray sum from 0 till ith index.\\n                       rightSubarraymax=[13, 13, 13, 13, 13, 13, 13, 13, 0]\\n   // stores the maximum sum of second subarray with length secondLen using suffixSum array.\\n                                             // ith position represents the maximum second subarray sum from ith index till last index.\\n\\nnow iterate and find the maximum of  ( leftSubarraymax[i] + rightSubarraymax[i+1] ) , max1. \\n\\nSimillarly do it for the case 2 and find the max2\\nfinally the answer is maximum of max1 and max2.\\n   \\n\\n   \\n```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int[] prefixSum=new int[nums.length];\\n        int[] suffixSum=new int[nums.length];\\n    \\n        for(int i=0;i<prefixSum.length;i++){\\n            if(i==0){\\n                prefixSum[0]=nums[0];\\n            }else{\\n                prefixSum[i]=prefixSum[i-1]+nums[i];\\n            }\\n        }\\n        for(int i=suffixSum.length-1;i>=0;i--){\\n            if(i==suffixSum.length-1){\\n                suffixSum[i]=nums[i];\\n            }else{\\n                suffixSum[i]=suffixSum[i+1]+nums[i];\\n            }\\n        }   \\n        // case 1 :\\n        int[] leftSubarrayMax=new int[nums.length];\\n        int[] rightSubarrayMax=new int[nums.length];\\n        for(int i=0;i<leftSubarrayMax.length;i++){\\n            if(i<firstLen-1){\\n                leftSubarrayMax[i]=0;\\n            }else if(i==firstLen-1){\\n                leftSubarrayMax[i]=prefixSum[i];\\n            }else{\\n                 leftSubarrayMax[i]=Math.max(leftSubarrayMax[i-1],prefixSum[i]-prefixSum[i-firstLen]);\\n            }\\n        }\\n         for(int i=rightSubarrayMax.length-1;i>=0;i--){\\n            if(i>rightSubarrayMax.length-secondLen){\\n                rightSubarrayMax[i]=0;\\n            }else if(i==rightSubarrayMax.length-secondLen){\\n                rightSubarrayMax[i]=suffixSum[i];\\n            }else{\\n                 rightSubarrayMax[i]=Math.max(rightSubarrayMax[i+1],suffixSum[i]-suffixSum[i+secondLen]);\\n            }\\n        }\\n        \\n        int max1=0;\\n        for(int i=firstLen-1;i<nums.length-secondLen;i++){\\n            int val=leftSubarrayMax[i]+rightSubarrayMax[i+1];\\n            if(val>max1) max1=val;\\n        }\\n        \\n         // case 2 :\\n        leftSubarrayMax=new int[nums.length];\\n        rightSubarrayMax=new int[nums.length];\\n        for(int i=0;i<leftSubarrayMax.length;i++){\\n            if(i<secondLen-1){\\n                leftSubarrayMax[i]=0;\\n            }else if(i==secondLen-1){\\n                leftSubarrayMax[i]=prefixSum[i];\\n            }else{\\n                 leftSubarrayMax[i]=Math.max(leftSubarrayMax[i-1],prefixSum[i]-prefixSum[i-secondLen]);\\n            }\\n        }\\n         for(int i=rightSubarrayMax.length-1;i>=0;i--){\\n            if(i>rightSubarrayMax.length-firstLen){\\n                rightSubarrayMax[i]=0;\\n            }else if(i==rightSubarrayMax.length-firstLen){\\n                rightSubarrayMax[i]=suffixSum[i];\\n            }else{\\n                 rightSubarrayMax[i]=Math.max(rightSubarrayMax[i+1],suffixSum[i]-suffixSum[i+firstLen]);\\n            }\\n        }\\n        int max2=0;\\n        for(int i=secondLen-1;i<nums.length-firstLen;i++){\\n            int val=leftSubarrayMax[i]+rightSubarrayMax[i+1];\\n            if(val>max2) max2=val;\\n        }\\n        return Math.max(max1,max2);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int[] prefixSum=new int[nums.length];\\n        int[] suffixSum=new int[nums.length];\\n    \\n        for(int i=0;i<prefixSum.length;i++){\\n            if(i==0){\\n                prefixSum[0]=nums[0];\\n            }else{\\n                prefixSum[i]=prefixSum[i-1]+nums[i];\\n            }\\n        }\\n        for(int i=suffixSum.length-1;i>=0;i--){\\n            if(i==suffixSum.length-1){\\n                suffixSum[i]=nums[i];\\n            }else{\\n                suffixSum[i]=suffixSum[i+1]+nums[i];\\n            }\\n        }   \\n        // case 1 :\\n        int[] leftSubarrayMax=new int[nums.length];\\n        int[] rightSubarrayMax=new int[nums.length];\\n        for(int i=0;i<leftSubarrayMax.length;i++){\\n            if(i<firstLen-1){\\n                leftSubarrayMax[i]=0;\\n            }else if(i==firstLen-1){\\n                leftSubarrayMax[i]=prefixSum[i];\\n            }else{\\n                 leftSubarrayMax[i]=Math.max(leftSubarrayMax[i-1],prefixSum[i]-prefixSum[i-firstLen]);\\n            }\\n        }\\n         for(int i=rightSubarrayMax.length-1;i>=0;i--){\\n            if(i>rightSubarrayMax.length-secondLen){\\n                rightSubarrayMax[i]=0;\\n            }else if(i==rightSubarrayMax.length-secondLen){\\n                rightSubarrayMax[i]=suffixSum[i];\\n            }else{\\n                 rightSubarrayMax[i]=Math.max(rightSubarrayMax[i+1],suffixSum[i]-suffixSum[i+secondLen]);\\n            }\\n        }\\n        \\n        int max1=0;\\n        for(int i=firstLen-1;i<nums.length-secondLen;i++){\\n            int val=leftSubarrayMax[i]+rightSubarrayMax[i+1];\\n            if(val>max1) max1=val;\\n        }\\n        \\n         // case 2 :\\n        leftSubarrayMax=new int[nums.length];\\n        rightSubarrayMax=new int[nums.length];\\n        for(int i=0;i<leftSubarrayMax.length;i++){\\n            if(i<secondLen-1){\\n                leftSubarrayMax[i]=0;\\n            }else if(i==secondLen-1){\\n                leftSubarrayMax[i]=prefixSum[i];\\n            }else{\\n                 leftSubarrayMax[i]=Math.max(leftSubarrayMax[i-1],prefixSum[i]-prefixSum[i-secondLen]);\\n            }\\n        }\\n         for(int i=rightSubarrayMax.length-1;i>=0;i--){\\n            if(i>rightSubarrayMax.length-firstLen){\\n                rightSubarrayMax[i]=0;\\n            }else if(i==rightSubarrayMax.length-firstLen){\\n                rightSubarrayMax[i]=suffixSum[i];\\n            }else{\\n                 rightSubarrayMax[i]=Math.max(rightSubarrayMax[i+1],suffixSum[i]-suffixSum[i+firstLen]);\\n            }\\n        }\\n        int max2=0;\\n        for(int i=secondLen-1;i<nums.length-firstLen;i++){\\n            int val=leftSubarrayMax[i]+rightSubarrayMax[i+1];\\n            if(val>max2) max2=val;\\n        }\\n        return Math.max(max1,max2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1467794,
                "title": "java-concise-solution-using-prefix-sum",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int[] prefixSum = new int[nums.length + 1];\\n        prefixSum[0] = 0;\\n        for (int i = 1; i <= nums.length; i++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i-1];\\n        int maxBefore = 0;\\n        int sum = 0;\\n        for (int i = secondLen + firstLen; i < prefixSum.length; i++){\\n            int curNum = prefixSum[i] - prefixSum[i-secondLen];\\n            maxBefore = Math.max(maxBefore, prefixSum[i-secondLen] - prefixSum[i-secondLen-firstLen]);\\n            sum = Math.max(sum, curNum + maxBefore);\\n        }\\n        int maxAfter = 0;\\n        for (int i = prefixSum.length - secondLen - firstLen; i >= 1; i--){\\n            int curNum = prefixSum[i+secondLen-1] - prefixSum[i-1];\\n            maxAfter = Math.max(maxAfter, prefixSum[i+secondLen+firstLen - 1] - prefixSum[i+secondLen-1]);\\n            sum = Math.max(sum, curNum + maxAfter);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int[] prefixSum = new int[nums.length + 1];\\n        prefixSum[0] = 0;\\n        for (int i = 1; i <= nums.length; i++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i-1];\\n        int maxBefore = 0;\\n        int sum = 0;\\n        for (int i = secondLen + firstLen; i < prefixSum.length; i++){\\n            int curNum = prefixSum[i] - prefixSum[i-secondLen];\\n            maxBefore = Math.max(maxBefore, prefixSum[i-secondLen] - prefixSum[i-secondLen-firstLen]);\\n            sum = Math.max(sum, curNum + maxBefore);\\n        }\\n        int maxAfter = 0;\\n        for (int i = prefixSum.length - secondLen - firstLen; i >= 1; i--){\\n            int curNum = prefixSum[i+secondLen-1] - prefixSum[i-1];\\n            maxAfter = Math.max(maxAfter, prefixSum[i+secondLen+firstLen - 1] - prefixSum[i+secondLen-1]);\\n            sum = Math.max(sum, curNum + maxAfter);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1451292,
                "title": "simple-approach-in-c-using-prefix-sliding-window-easiest-way",
                "content": "class Solution {\\npublic:\\n\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstlen, int secondlen) \\n    {\\n        int n=nums.size(),pre[n+1],ans=0;\\n        pre[0]=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            pre[i+1]=pre[i]+nums[i];\\n        }\\n        int left=0;\\n       for(int i=firstlen;i+secondlen<=n;i++)//firstlen ,secondlen\\n       {\\n            left=max(left,pre[i]-pre[i-firstlen]);\\n           ans=max(ans,left+pre[i+secondlen]-pre[i]);\\n       }\\n        left=0;\\n       for(int i=secondlen;i+firstlen<=n;i++)//secondlen ,firstlen\\n       {\\n            left=max(left,pre[i]-pre[i-secondlen]);\\n           ans=max(ans,left+pre[i+firstlen]-pre[i]);\\n       }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstlen, int secondlen) \\n    {\\n        int n=nums.size(),pre[n+1],ans=0;\\n        pre[0]=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            pre[i+1]=pre[i]+nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1162902,
                "title": "java-o-n-time-easy-to-understand",
                "content": "```\\n\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\t\\t//for any sum of subarray question, we must get prefix Sum array first\\n        int[] sums = new int[A.length + 1];\\n        for(int i = 1; i <= A.length; i++) sums[i] = A[i - 1] + sums[i - 1];\\n        \\n        int ans = 0;\\n        \\n        //If array L is on the left side of M\\n        int maxLVal = 0;\\n        for(int i = L; i <= A.length - M; i++) {\\n            maxLVal = Math.max(maxLVal, sums[i] - sums[i - L]);\\n            ans = Math.max(ans, sums[i + M] - sums[i] + maxLVal);\\n        }\\n\\n        //If array M is on the left side of L  <=> array L is on the right side of M\\n        int maxMVal = 0;\\n        for(int i = M; i <= A.length - L; i++) {\\n            maxMVal = Math.max(maxMVal, sums[i] - sums[i - M]);\\n            ans = Math.max(ans, sums[i + L] - sums[i] + maxMVal);\\n        }\\n\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\t\\t//for any sum of subarray question, we must get prefix Sum array first\\n        int[] sums = new int[A.length + 1];\\n        for(int i = 1; i <= A.length; i++) sums[i] = A[i - 1] + sums[i - 1];\\n        \\n        int ans = 0;\\n        \\n        //If array L is on the left side of M\\n        int maxLVal = 0;\\n        for(int i = L; i <= A.length - M; i++) {\\n            maxLVal = Math.max(maxLVal, sums[i] - sums[i - L]);\\n            ans = Math.max(ans, sums[i + M] - sums[i] + maxLVal);\\n        }\\n\\n        //If array M is on the left side of L  <=> array L is on the right side of M\\n        int maxMVal = 0;\\n        for(int i = M; i <= A.length - L; i++) {\\n            maxMVal = Math.max(maxMVal, sums[i] - sums[i - M]);\\n            ans = Math.max(ans, sums[i + L] - sums[i] + maxMVal);\\n        }\\n\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 991183,
                "title": "python3-simple-greedy-solution-99-speed-and-o-1-memory",
                "content": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        A.insert(0,0)\\n        for i in range(1, len(A)):\\n            A[i] += A[i-1]\\n    \\n        lmax, mmax = 0,0\\n        ans = 0\\n        \\n        ## L -> M\\n        n = len(A)\\n        for i in range(L + M, n):\\n            m = 0\\n            lmax = max(lmax, A[i - M] - A[i - L - M])\\n            ans = max(ans, lmax + A[i] - A[i-M])\\n        \\n        ## M -> L\\n        for i in range(L+M, n):\\n            l = 0\\n            mmax = max(mmax, A[i - L] - A[i - L - M])\\n            ans = max(ans, mmax + A[i] - A[i-L])\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        A.insert(0,0)\\n        for i in range(1, len(A)):\\n            A[i] += A[i-1]\\n    \\n        lmax, mmax = 0,0\\n        ans = 0\\n        \\n        ## L -> M\\n        n = len(A)\\n        for i in range(L + M, n):\\n            m = 0\\n            lmax = max(lmax, A[i - M] - A[i - L - M])\\n            ans = max(ans, lmax + A[i] - A[i-M])\\n        \\n        ## M -> L\\n        for i in range(L+M, n):\\n            l = 0\\n            mmax = max(mmax, A[i - L] - A[i - L - M])\\n            ans = max(ans, mmax + A[i] - A[i-L])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923374,
                "title": "java-o-n-o-1-space-faster-than-100-step-by-step-explained",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n        // case 1 -> L before M , case 2 -> M before L \\n        // for every 2nd(R) subarray find the subarray to its left with maximum sum( the best candidate )\\n        // and the ans is -> for every R subarray with sumR : max(maxTotal , sumR + maxL)\\n        return Math.max(helper(nums , L , M), helper(nums , M , L));\\n    }\\n    private static int helper(int [] nums , int L , int M){\\n        \\n        int sumR = 0 ,sumL = 0 ;\\n        int maxSum = 0 ;\\n        int maxL = 0 ;\\n        \\n        // limiters of the initial windows\\n        int lStart = 0 ,lEnd = L - 1;\\n        int rStart = lEnd + 1 , rEnd = rStart + M - 1;\\n        \\n        // create the first windows , in a way that they do not overlap [l],[r],[rest of the array]\\n        for(int i = 0 ; i <= lEnd ;  i++)\\n            sumL += nums[i];\\n        for(int i = rStart ; i <= rEnd; i++)\\n            sumR += nums[i];\\n        \\n        maxL = sumL; // maximum sum of the first left subarray  \\n        maxSum = sumL + sumR; // when L + M == nums.length , OR when the sum of 1st windows has the desired ans \\n        \\n        // begin sliding both of them , and for every Right subarray get the max sum of the subarray to its left \\n        // ie - the best possible candidate for the right subarray and sum them up and record the global max \\n        // among all such right subarrays \\n        \\n        // and since we are using sliding window technique , sliding both by 1 elt at a time we will stop \\n        // when we cannot slide the right window anymore , thus ensuring L and R never overlap \\n        \\n        for(int i = rEnd + 1 ; i < nums.length ; i++){\\n            sumL = sumL - nums[lStart++] + nums[rStart];\\n            sumR = sumR - nums[rStart++] + nums[i];\\n            maxL = Math.max(maxL , sumL);  // kepp updating the maximum sum of left subarray seen till now \\n            maxSum = Math.max(maxSum , sumR + maxL);\\n        }\\n        return maxSum ; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n        // case 1 -> L before M , case 2 -> M before L \\n        // for every 2nd(R) subarray find the subarray to its left with maximum sum( the best candidate )\\n        // and the ans is -> for every R subarray with sumR : max(maxTotal , sumR + maxL)\\n        return Math.max(helper(nums , L , M), helper(nums , M , L));\\n    }\\n    private static int helper(int [] nums , int L , int M){\\n        \\n        int sumR = 0 ,sumL = 0 ;\\n        int maxSum = 0 ;\\n        int maxL = 0 ;\\n        \\n        // limiters of the initial windows\\n        int lStart = 0 ,lEnd = L - 1;\\n        int rStart = lEnd + 1 , rEnd = rStart + M - 1;\\n        \\n        // create the first windows , in a way that they do not overlap [l],[r],[rest of the array]\\n        for(int i = 0 ; i <= lEnd ;  i++)\\n            sumL += nums[i];\\n        for(int i = rStart ; i <= rEnd; i++)\\n            sumR += nums[i];\\n        \\n        maxL = sumL; // maximum sum of the first left subarray  \\n        maxSum = sumL + sumR; // when L + M == nums.length , OR when the sum of 1st windows has the desired ans \\n        \\n        // begin sliding both of them , and for every Right subarray get the max sum of the subarray to its left \\n        // ie - the best possible candidate for the right subarray and sum them up and record the global max \\n        // among all such right subarrays \\n        \\n        // and since we are using sliding window technique , sliding both by 1 elt at a time we will stop \\n        // when we cannot slide the right window anymore , thus ensuring L and R never overlap \\n        \\n        for(int i = rEnd + 1 ; i < nums.length ; i++){\\n            sumL = sumL - nums[lStart++] + nums[rStart];\\n            sumR = sumR - nums[rStart++] + nums[i];\\n            maxL = Math.max(maxL , sumL);  // kepp updating the maximum sum of left subarray seen till now \\n            maxSum = Math.max(maxSum , sumR + maxL);\\n        }\\n        return maxSum ; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 773645,
                "title": "explanation-simple-sliding-window-o-n-time-o-1-space-c",
                "content": "\\n1st Loop: Slide from right to left:\\n* \\t(Sliding Window of length M) ... (Sliding Window of length L)\\n* \\tsum1 = sum of window M\\n* \\tsum2 = sum of window L\\n* \\tmax_sum2 = max(max_sum2, sum2)\\n* \\tres = max(res, sum1+max_sum2)\\n\\n\\n2nd Loop: Slide from left to right\\n* \\t(Sliding Window of length L) ... (Sliding Window of length M)\\n* \\tsum1 = sum of window M\\n* \\tsum2 = sum of window L\\n* \\tmax_sum2 = max(max_sum2, sum2)\\n* \\tres = max(res, sum1+max_sum2)\\n\\nreturn res\\n\\n```\\nint maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        if(n == 0 || L+M > n) return 0;\\n        if(L > M) swap(L, M);\\n        \\n        int leftMax = 0, res = 0, right = 0;                \\n        for(int i = n-1; i >= n-L; i--) leftMax += A[i];\\n        for(int i = n-L-1; i >= n-L-M; i--) right += A[i];\\n        int left = leftMax;\\n        res = right+leftMax;\\n        int i = n-L-M, j =  n-L-1;\\n        int l = n-L, r = n-1;\\n        while(i > 0) {\\n            i--;\\n            j--;\\n            l--;\\n            r--;\\n            right = right-A[j+1]+A[i];\\n            left = left+A[l]-A[r+1];\\n            leftMax = max(leftMax, left);\\n            res = max(res, right+leftMax);\\n        }\\n        leftMax = 0, right = 0;                \\n        for(int i = 0; i < L; i++) leftMax += A[i];\\n        for(int i = L; i < L+M; i++) right += A[i];\\n        left = leftMax;\\n        res = max(res, right+leftMax);\\n        i = L, j =  L+M-1;\\n        l = 0, r = L-1;\\n        while(j < n-1) {\\n            i++;\\n            j++;\\n            l++;\\n            r++;\\n            right = right+A[j]-A[i-1];\\n            left = left-A[l-1]+A[r];\\n            leftMax = max(leftMax, left);\\n            res = max(res, right+leftMax);\\n        }\\n        return res;\\n    }  \\n```",
                "solutionTags": [],
                "code": "```\\nint maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        if(n == 0 || L+M > n) return 0;\\n        if(L > M) swap(L, M);\\n        \\n        int leftMax = 0, res = 0, right = 0;                \\n        for(int i = n-1; i >= n-L; i--) leftMax += A[i];\\n        for(int i = n-L-1; i >= n-L-M; i--) right += A[i];\\n        int left = leftMax;\\n        res = right+leftMax;\\n        int i = n-L-M, j =  n-L-1;\\n        int l = n-L, r = n-1;\\n        while(i > 0) {\\n            i--;\\n            j--;\\n            l--;\\n            r--;\\n            right = right-A[j+1]+A[i];\\n            left = left+A[l]-A[r+1];\\n            leftMax = max(leftMax, left);\\n            res = max(res, right+leftMax);\\n        }\\n        leftMax = 0, right = 0;                \\n        for(int i = 0; i < L; i++) leftMax += A[i];\\n        for(int i = L; i < L+M; i++) right += A[i];\\n        left = leftMax;\\n        res = max(res, right+leftMax);\\n        i = L, j =  L+M-1;\\n        l = 0, r = L-1;\\n        while(j < n-1) {\\n            i++;\\n            j++;\\n            l++;\\n            r++;\\n            right = right+A[j]-A[i-1];\\n            left = left-A[l-1]+A[r];\\n            leftMax = max(leftMax, left);\\n            res = max(res, right+leftMax);\\n        }\\n        return res;\\n    }  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 678868,
                "title": "java-simple-two-pass",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        \\n        int n = A.length;\\n        for(int i = 1 ; i < n ; i++)\\n            A[i] += A[i-1];\\n        \\n        int res = 0;\\n        \\n        int l_max = A[L-1];\\n        int m_max = A[M-1];\\n        \\n        for(int i = L ; i + M - 1 < n ; i++) {\\n            res = Math.max(res, l_max + A[i+M-1] - A[i-1]);\\n            l_max = Math.max(l_max, A[i] - A[i-L]);\\n        }\\n        \\n        l_max = A[L-1];\\n        m_max = A[M-1];\\n        \\n        for(int i = M ; i + L - 1 < n ; i++) {\\n            res = Math.max(res, m_max + A[i+L-1] - A[i-1]);\\n            m_max = Math.max(m_max, A[i] - A[i-M]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\nRef https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/discuss/279433/Java-Two-pass",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        \\n        int n = A.length;\\n        for(int i = 1 ; i < n ; i++)\\n            A[i] += A[i-1];\\n        \\n        int res = 0;\\n        \\n        int l_max = A[L-1];\\n        int m_max = A[M-1];\\n        \\n        for(int i = L ; i + M - 1 < n ; i++) {\\n            res = Math.max(res, l_max + A[i+M-1] - A[i-1]);\\n            l_max = Math.max(l_max, A[i] - A[i-L]);\\n        }\\n        \\n        l_max = A[L-1];\\n        m_max = A[M-1];\\n        \\n        for(int i = M ; i + L - 1 < n ; i++) {\\n            res = Math.max(res, m_max + A[i+L-1] - A[i-1]);\\n            m_max = Math.max(m_max, A[i] - A[i-M]);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613723,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max (calculate(A, L, M), calculate(A, M, L));\\n    }\\n    \\n    public int calculate(int[] A, int L, int M) {\\n        \\n        int[] left = new int[A.length+1];\\n        int[] right = new int[A.length+1];\\n        int res = 0;\\n        \\n        int sum_l =0, sum_r=0;\\n        for(int i=0,j=A.length-1;i<A.length;i++,j--) {\\n            \\n            sum_l += A[i];\\n            sum_r += A[j];\\n            \\n            left[i+1] = Math.max(left[i], sum_l);\\n            right[j] = Math.max(right[j+1], sum_r);\\n            \\n            if(i+1 >= L)\\n                sum_l -= A[i+1-L];\\n            if(i+1 >= M)\\n                sum_r  -= A[j+M-1];\\n            \\n        }\\n        \\n        for(int i=1;i<A.length;i++) {\\n            \\n            res = Math.max(res, left[i]+right[i]);\\n        }\\n        return res;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max (calculate(A, L, M), calculate(A, M, L));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 600728,
                "title": "python-3-o-n-solution-with-clear-comments",
                "content": "```\\nclass Solution:\\n    \\'\\'\\'\\n    L length subarray. Suppose it starts at index i. Then it ends at index i + L - 1\\n    prefixSum[i + L - 1] - prefixSum[i] + A[i] gives the sum of L subarray\\n    \\n    DP1[i] := maximum sum of M subarray to the right of i (including i)\\n    DP1[i] := max(A[i:i+M], DP1[i+1])\\n    \\n    DP2[i] := maximum sum of M subarray to the left of i (including i)\\n    DP2[i] := max(sum(A[i-M+1:i+1]), DP2[i-1])\\n\\n    A[i:i+M] = prefixSum[i + M - 1] - prefixSum[i] + A[i]\\n    A[i-M+1:i+1] = prefixSum[i] - prefixSum[i - M + 1] + A[i - M + 1]\\n    \\n    DP1[i] => 0 <= i <= len(A) - M\\n    DP2[i] => M - 1 <= i <= len(A) - 1\\n    \\n    Base cases:\\n    DP1[len(A) - M] = prefixSum[len(A) - 1] - prefixSum[len(A) - M] + A[len(A) - M]\\n    DP2[M - 1] = prefixSum[M - 1]\\n    \\n    \\'\\'\\'\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        prefixSum = []\\n        total = 0\\n        maxSum = float(\\'-inf\\')\\n        DP1, DP2 = {}, {}\\n        \\n        for i in range(len(A)):\\n            total += A[i]\\n            prefixSum.append(total)\\n        \\n        DP1[len(A) - M] = prefixSum[len(A) - 1] - prefixSum[len(A) - M] + A[len(A) - M]\\n        DP2[M - 1] = prefixSum[M - 1]\\n        \\n        for i in range(len(A) - M - 1, -1, -1):\\n            DP1[i] = max(DP1[i + 1], prefixSum[i + M - 1] - prefixSum[i] + A[i])\\n            \\n        for i in range(M, len(A)):\\n            DP2[i] = max(DP2[i - 1], prefixSum[i] - prefixSum[i - M + 1] + A[i - M + 1])\\n            \\n        \\n        for i in range(len(A) - L + 1):\\n            L_sum = prefixSum[i + L - 1] - prefixSum[i] + A[i]\\n            right = DP1[i + L] if i + L in DP1 else float(\\'-inf\\')\\n            left = DP2[i - 1] if i - 1 in DP2 else float(\\'-inf\\')\\n            maxSum = max(maxSum, L_sum + max(left, right))\\n        \\n        return maxSum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\'\\'\\'\\n    L length subarray. Suppose it starts at index i. Then it ends at index i + L - 1\\n    prefixSum[i + L - 1] - prefixSum[i] + A[i] gives the sum of L subarray\\n    \\n    DP1[i] := maximum sum of M subarray to the right of i (including i)\\n    DP1[i] := max(A[i:i+M], DP1[i+1])\\n    \\n    DP2[i] := maximum sum of M subarray to the left of i (including i)\\n    DP2[i] := max(sum(A[i-M+1:i+1]), DP2[i-1])\\n\\n    A[i:i+M] = prefixSum[i + M - 1] - prefixSum[i] + A[i]\\n    A[i-M+1:i+1] = prefixSum[i] - prefixSum[i - M + 1] + A[i - M + 1]\\n    \\n    DP1[i] => 0 <= i <= len(A) - M\\n    DP2[i] => M - 1 <= i <= len(A) - 1\\n    \\n    Base cases:\\n    DP1[len(A) - M] = prefixSum[len(A) - 1] - prefixSum[len(A) - M] + A[len(A) - M]\\n    DP2[M - 1] = prefixSum[M - 1]\\n    \\n    \\'\\'\\'\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        prefixSum = []\\n        total = 0\\n        maxSum = float(\\'-inf\\')\\n        DP1, DP2 = {}, {}\\n        \\n        for i in range(len(A)):\\n            total += A[i]\\n            prefixSum.append(total)\\n        \\n        DP1[len(A) - M] = prefixSum[len(A) - 1] - prefixSum[len(A) - M] + A[len(A) - M]\\n        DP2[M - 1] = prefixSum[M - 1]\\n        \\n        for i in range(len(A) - M - 1, -1, -1):\\n            DP1[i] = max(DP1[i + 1], prefixSum[i + M - 1] - prefixSum[i] + A[i])\\n            \\n        for i in range(M, len(A)):\\n            DP2[i] = max(DP2[i - 1], prefixSum[i] - prefixSum[i - M + 1] + A[i - M + 1])\\n            \\n        \\n        for i in range(len(A) - L + 1):\\n            L_sum = prefixSum[i + L - 1] - prefixSum[i] + A[i]\\n            right = DP1[i + L] if i + L in DP1 else float(\\'-inf\\')\\n            left = DP2[i - 1] if i - 1 in DP2 else float(\\'-inf\\')\\n            maxSum = max(maxSum, L_sum + max(left, right))\\n        \\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515807,
                "title": "python-sliding-windows-with-double-ended-queue-o-n-and-commented",
                "content": "The methodology here is to use two sliding windows, one on the left (l) and one on the right (m), to cover the array provided, and keep track of the highest sum under the left window, and the highest sum total. Note that we can\\'t keep track of the highest sum under the right window, because with each slide the left window will take an item from the right window, so if we kept both sum maxes instead of the left sum max and the overall sum max, we could be double dipping.\\n\\nBy the time we\\'ve advanced each window all the way to the right, we\\'ve got the maximum sums for each as if we\\'d stopped advancing each window when it was over the ideal subarray.\\n\\nEach window is represented as a double-ended queue (Python\\'s `deque` implementation under `collections`). Time complexity is O(n) though we run through `A` twice, and space complexity is O(n+l+m) accounting for both the input and the two double-ended queues.\\n\\nFinal important point before we get into the code: **the two windows could appear in either order (l then m or m then l), but our algorithm assumes l is to the left, so we run it twice with l and m switched the second time**.\\n\\nCode time:\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def slidingWindows(self, A: List[int], L: int, M: int) -> int:\\n        # Create deques and starting sums for the \\'l\\' and \\'m\\' sliding windows\\n        lQ = deque(maxlen=L)\\n        mQ = deque(maxlen=M)\\n        lSum = 0\\n        mSum = 0\\n        \\n        # Fill deques and sums with their appropriate starter values, l then m\\n        for i in range(L):\\n            lQ.append(A[i])\\n            lSum += A[i]\\n            \\n        for j in range(i+1, i+1+M):\\n            mQ.append(A[j])\\n            mSum += A[j]\\n            \\n        # Slide windows, retaining the max sums for the left (l) deque and overall\\n        maxLSum = lSum\\n        maxOverall = maxLSum + mSum\\n        for k in range(j+1, len(A)):\\n            # Shift the leftmost elem from mQ into lQ and the next elem into mQ\\n            shiftedFromM = mQ.popleft()\\n            shiftedFromL = lQ.popleft()\\n            lQ.append(shiftedFromM)\\n            mQ.append(A[k])\\n            \\n            # Update the deque sums to account for the shifts in and out\\n            lSum = lSum - shiftedFromL + shiftedFromM\\n            mSum = mSum - shiftedFromM + A[k]\\n            \\n            # Update the max sums for the left deque and overall\\n            maxLSum = max(maxLSum, lSum)\\n            maxOverall = max(maxOverall, maxLSum + mSum)\\n            \\n        return maxOverall\\n        \\n        \\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\t    # Take the best result of the two possible orders for the l and m windows\\n        return max(self.slidingWindows(A, L, M), self.slidingWindows(A, M, L))\\n```\\n\\n*Creds to [jaithrik\\'s Java solution](https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/discuss/465172/O(n)-Deque-solution-2-passes), which inspired mine.*",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def slidingWindows(self, A: List[int], L: int, M: int) -> int:\\n        # Create deques and starting sums for the \\'l\\' and \\'m\\' sliding windows\\n        lQ = deque(maxlen=L)\\n        mQ = deque(maxlen=M)\\n        lSum = 0\\n        mSum = 0\\n        \\n        # Fill deques and sums with their appropriate starter values, l then m\\n        for i in range(L):\\n            lQ.append(A[i])\\n            lSum += A[i]\\n            \\n        for j in range(i+1, i+1+M):\\n            mQ.append(A[j])\\n            mSum += A[j]\\n            \\n        # Slide windows, retaining the max sums for the left (l) deque and overall\\n        maxLSum = lSum\\n        maxOverall = maxLSum + mSum\\n        for k in range(j+1, len(A)):\\n            # Shift the leftmost elem from mQ into lQ and the next elem into mQ\\n            shiftedFromM = mQ.popleft()\\n            shiftedFromL = lQ.popleft()\\n            lQ.append(shiftedFromM)\\n            mQ.append(A[k])\\n            \\n            # Update the deque sums to account for the shifts in and out\\n            lSum = lSum - shiftedFromL + shiftedFromM\\n            mSum = mSum - shiftedFromM + A[k]\\n            \\n            # Update the max sums for the left deque and overall\\n            maxLSum = max(maxLSum, lSum)\\n            maxOverall = max(maxOverall, maxLSum + mSum)\\n            \\n        return maxOverall\\n        \\n        \\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n\\t    # Take the best result of the two possible orders for the l and m windows\\n        return max(self.slidingWindows(A, L, M), self.slidingWindows(A, M, L))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423018,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max(inorderMaxSumTowNoOverlap(A, L, M), inorderMaxSumTowNoOverlap(A, M, L));\\n    }\\n    \\n    private int inorderMaxSumTowNoOverlap(int[] A, int L, int M) {\\n        int sum = 0;\\n        int[] leftSum = new int[A.length], rightSum = new int[A.length];\\n        int[] maxLeftL = new int[A.length], maxRightM = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            leftSum[i] = i == 0 ? A[i] : A[i] + leftSum[i - 1];\\n        }\\n        \\n        for (int j = A.length - 1; j >= 0; j--) {\\n            rightSum[j] = j == A.length - 1 ? A[j] : A[j] + rightSum[j + 1];\\n        }\\n        \\n        for (int i = L-1; i < A.length; i++) {\\n            int v = leftSum[i] - (i == L-1 ? 0 : leftSum[i - L]);\\n            maxLeftL[i] = i == 0 ? v : Math.max(maxLeftL[i - 1], v);  \\n        }   \\n        \\n        for (int j = A.length - M; j >= 0; j--) {\\n            int v = rightSum[j] - (j == A.length - M ? 0 : rightSum[j + M]);\\n            maxRightM[j] = j == A.length - 1 ? v : Math.max(maxRightM[j + 1], v);  \\n        }    \\n        \\n        int res = 0;\\n        for (int i = L-1; i < A.length - M; i++) {\\n            res = Math.max(res, maxLeftL[i] + maxRightM[i + 1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        return Math.max(inorderMaxSumTowNoOverlap(A, L, M), inorderMaxSumTowNoOverlap(A, M, L));\\n    }\\n    \\n    private int inorderMaxSumTowNoOverlap(int[] A, int L, int M) {\\n        int sum = 0;\\n        int[] leftSum = new int[A.length], rightSum = new int[A.length];\\n        int[] maxLeftL = new int[A.length], maxRightM = new int[A.length];\\n        \\n        for (int i = 0; i < A.length; i++) {\\n            leftSum[i] = i == 0 ? A[i] : A[i] + leftSum[i - 1];\\n        }\\n        \\n        for (int j = A.length - 1; j >= 0; j--) {\\n            rightSum[j] = j == A.length - 1 ? A[j] : A[j] + rightSum[j + 1];\\n        }\\n        \\n        for (int i = L-1; i < A.length; i++) {\\n            int v = leftSum[i] - (i == L-1 ? 0 : leftSum[i - L]);\\n            maxLeftL[i] = i == 0 ? v : Math.max(maxLeftL[i - 1], v);  \\n        }   \\n        \\n        for (int j = A.length - M; j >= 0; j--) {\\n            int v = rightSum[j] - (j == A.length - M ? 0 : rightSum[j + M]);\\n            maxRightM[j] = j == A.length - 1 ? v : Math.max(maxRightM[j + 1], v);  \\n        }    \\n        \\n        int res = 0;\\n        for (int i = L-1; i < A.length - M; i++) {\\n            res = Math.max(res, maxLeftL[i] + maxRightM[i + 1]);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354821,
                "title": "cpp-o-n-solution-with-partitial-sums",
                "content": "**Solution 1**\\nThe same idea as in the https://leetcode.com/problems/best-time-to-buy-and-sell-stock/ task. Main idea here is to calculate partitial sums O(n), to get sum on interval in O(1) time. \\n\\nThen we  assume that L-size interval is the first one, store maximal L-size interval sum and calculate result as maximal (maximal L-size interval sum + current right M-size interval sum). Then we do the same trick with M-size interval on the left.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int maxSumTwoNoOverlap(vector<int>& a, int L, int M) {\\n        vector<int> sums(a.size()+1, 0);\\n        partial_sum(a.begin(), a.end(), sums.begin()+1);\\n        \\n        auto get_sum = [&sums](int i, int size) { \\n            if (i < 0) i = sums.size() - 1 + i;\\n            return sums[i+1] - sums[i + 1 - size]; \\n        };\\n    \\n        int result = 0;\\n        int maxleft = 0;\\n        for (int i = L - 1; i < a.size() - M; ++i) {\\n            maxleft = max(maxleft, get_sum(i, L));\\n            if (maxleft + get_sum(i+M, M) > result) {\\n                result = maxleft + get_sum(i+M, M);\\n            }\\n        }\\n        \\n        maxleft = 0;\\n        for (int i = M-1; i < a.size() - L; ++i) {\\n            maxleft = max(maxleft, get_sum(i,M));\\n            if (maxleft + get_sum(i+L,L) > result) {\\n                result = maxleft + get_sum(i+L,L);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int maxSumTwoNoOverlap(vector<int>& a, int L, int M) {\\n        vector<int> sums(a.size()+1, 0);\\n        partial_sum(a.begin(), a.end(), sums.begin()+1);\\n        \\n        auto get_sum = [&sums](int i, int size) { \\n            if (i < 0) i = sums.size() - 1 + i;\\n            return sums[i+1] - sums[i + 1 - size]; \\n        };\\n    \\n        int result = 0;\\n        int maxleft = 0;\\n        for (int i = L - 1; i < a.size() - M; ++i) {\\n            maxleft = max(maxleft, get_sum(i, L));\\n            if (maxleft + get_sum(i+M, M) > result) {\\n                result = maxleft + get_sum(i+M, M);\\n            }\\n        }\\n        \\n        maxleft = 0;\\n        for (int i = M-1; i < a.size() - L; ++i) {\\n            maxleft = max(maxleft, get_sum(i,M));\\n            if (maxleft + get_sum(i+L,L) > result) {\\n                result = maxleft + get_sum(i+L,L);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279447,
                "title": "c-o-n-solution",
                "content": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int ans = 0;\\n        int k = 0;\\n        int nums[1005] = {0};\\n        for(int i = 0; i < A.size(); i++){\\n            nums[i+1] = nums[i] + A[i];\\n        }\\n        int length = A.size();\\n        for(int i = M; i + L <= length; i++){\\n            k = max(k, nums[i] - nums[i-M]);\\n            ans = max(ans, k + nums[i+L] - nums[i]);\\n        }\\n        k = 0;\\n        for(int i = L; i + M <= length; i++){\\n            k = max(k, nums[i] - nums[i-L]);\\n            ans = max(ans, k + nums[i+M] - nums[i]); \\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int ans = 0;\\n        int k = 0;\\n        int nums[1005] = {0}",
                "codeTag": "Java"
            },
            {
                "id": 279207,
                "title": "java-brute-force-while-easy-to-understand",
                "content": "```\\n\\tpublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\t\\tint N = A.length;\\n\\t\\tint[] sums = new int[N + 1];\\n\\t\\tfor (int i = 1; i <= N; i++) {\\n\\t\\t\\tsums[i] = sums[i - 1] + A[i - 1];\\n\\t\\t}\\n\\t\\tint sumL = 0, sum = 0;\\n\\t\\tfor (int i = 0; i < N + 1 - L; ++i) {\\n\\t\\t\\tsumL = sums[i + L] - sums[i];\\n\\t\\t\\tfor (int j = 0; j < N + 1 - M; ++j) {\\n\\t\\t\\t\\tif (j + M <= i || i + L <= j) {\\n\\t\\t\\t\\t\\tint sumM = sums[j + M] - sums[j];\\n\\t\\t\\t\\t\\tif (sumM + sumL > sum) {\\n\\t\\t\\t\\t\\t\\tsum = sumM + sumL;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\t\\tint N = A.length;\\n\\t\\tint[] sums = new int[N + 1];\\n\\t\\tfor (int i = 1; i <= N; i++) {\\n\\t\\t\\tsums[i] = sums[i - 1] + A[i - 1];\\n\\t\\t}\\n\\t\\tint sumL = 0, sum = 0;\\n\\t\\tfor (int i = 0; i < N + 1 - L; ++i) {\\n\\t\\t\\tsumL = sums[i + L] - sums[i];\\n\\t\\t\\tfor (int j = 0; j < N + 1 - M; ++j) {\\n\\t\\t\\t\\tif (j + M <= i || i + L <= j) {\\n\\t\\t\\t\\t\\tint sumM = sums[j + M] - sums[j];\\n\\t\\t\\t\\t\\tif (sumM + sumL > sum) {\\n\\t\\t\\t\\t\\t\\tsum = sumM + sumL;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn sum;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 278710,
                "title": "java-solution-o-n",
                "content": "leftM[i] as of 0..i, the max subarray sum with size M\\nrightM[i], as of N-1...i, the max subarray sum with size M\\n\\nSo, the answer is the maximum of all subarrays with size L plus the max M array before or after it.\\n\\n\\n```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int N = A.length;\\n        int[] preSum = new int[N + 1];\\n        for (int i = 1; i <= N; i++) {\\n            preSum[i] = preSum[i - 1] + A[i - 1];\\n        }\\n        \\n        int[] leftM = new int[N];\\n        int[] rightM = new int[N];\\n        \\n\\n        int curM = Integer.MIN_VALUE;\\n        for (int i = 0; i < N; i++) {\\n            leftM[i] = Integer.MIN_VALUE;\\n            \\n            if (i >= M - 1) {\\n                leftM[i] = Math.max(curM, preSum[i + 1] - preSum[i + 1 - M]);\\n                curM = Math.max(curM, leftM[i]);\\n            }\\n        }\\n        \\n        curM = Integer.MIN_VALUE;\\n        \\n        for (int i = N - 1; i >= 0; i--) {\\n            rightM[i] = Integer.MIN_VALUE;\\n            \\n            if (i <= N - M) {\\n                rightM[i] = Math.max(curM, preSum[i + M] - preSum[i]);\\n                curM = Math.max(curM, rightM[i]);\\n            }\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n        for (int i = L - 1; i < N; i++) {\\n            int tempL = preSum[i + 1] - preSum[i + 1 - L];            \\n            \\n            int pl = i - L;\\n            int pM = pl >= 0 ? leftM[pl] : Integer.MIN_VALUE;\\n            \\n            int nl = i + 1;\\n            int nM = nl < N ? rightM[nl] : Integer.MIN_VALUE;\\n            \\n            res = Math.max(res, Math.max(pM, nM) + tempL);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int N = A.length;\\n        int[] preSum = new int[N + 1];\\n        for (int i = 1; i <= N; i++) {\\n            preSum[i] = preSum[i - 1] + A[i - 1];\\n        }\\n        \\n        int[] leftM = new int[N];\\n        int[] rightM = new int[N];\\n        \\n\\n        int curM = Integer.MIN_VALUE;\\n        for (int i = 0; i < N; i++) {\\n            leftM[i] = Integer.MIN_VALUE;\\n            \\n            if (i >= M - 1) {\\n                leftM[i] = Math.max(curM, preSum[i + 1] - preSum[i + 1 - M]);\\n                curM = Math.max(curM, leftM[i]);\\n            }\\n        }\\n        \\n        curM = Integer.MIN_VALUE;\\n        \\n        for (int i = N - 1; i >= 0; i--) {\\n            rightM[i] = Integer.MIN_VALUE;\\n            \\n            if (i <= N - M) {\\n                rightM[i] = Math.max(curM, preSum[i + M] - preSum[i]);\\n                curM = Math.max(curM, rightM[i]);\\n            }\\n        }\\n        \\n        int res = Integer.MIN_VALUE;\\n        for (int i = L - 1; i < N; i++) {\\n            int tempL = preSum[i + 1] - preSum[i + 1 - L];            \\n            \\n            int pl = i - L;\\n            int pM = pl >= 0 ? leftM[pl] : Integer.MIN_VALUE;\\n            \\n            int nl = i + 1;\\n            int nM = nl < N ? rightM[nl] : Integer.MIN_VALUE;\\n            \\n            res = Math.max(res, Math.max(pM, nM) + tempL);\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454067,
                "title": "o-n-using-prefix-and-dp",
                "content": "# Intuition\\nwhile reading the problem we get two know 2 things->\\n1) subarrays needs to be overlapping , so it means if first subarray ends at ith index, then second subarray can start at i+1 th index.\\n2) occurence of firstLen subarray can be after secondLen subarray.\\n\\n\\nNow as we get to know about these 2 things we can proceed further.\\nconstraints->length of nums<=10^4, so our program time complexity can be only be o(n). By above all conditions I deviced the approach given below\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) First we build a prefix array called pre. This will save us time to calculate sum of subarray from ith index to jth index.\\n2) Now we make a dp vector, in which ith index gives the maximum subarray of secondLen starting from ith or any other index after ith index. By using this array we can get greatest subbaarray sum of SecondLen after or at a particular index.\\n3) Now we again travese again through nums and starting at evey index i we take sum of firstLen subbarray. Now since we want secondLen subbary which is not overlapping ,it is given by dp[i+firstLen]. we take max sum of both and store it in answer.\\n4) Now as we know firstLen subbarray can occur after seconLen subarray we, again do we process but values of secondLen,firstLen swapped. \\n5)WE GET OUR FINAL ANSWER.\\n\\nNOTE-> we can a make a function which can take nums vector both lengths.\\nwe can do step 3 in that fuction.\\nand for step  we can swap values. This will save a lot of space.\\n\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- o(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        vector<int>pre;\\n        pre.push_back(0);\\n        for(int i=1;i<=nums.size();i++)\\n          pre.push_back(pre[i-1]+nums[i-1]);\\n          int n=nums.size();\\n          vector<int>dp(n,0);\\n          int m=0;\\n//constructing a dp array to store max subarray of len after or ith index\\n          for(int i=n-secondLen;i>=0;i--)\\n          {\\n              m=max(pre[i+secondLen]-pre[i],m);\\n              dp[i]=m;\\n\\n          }\\n          int ans=0;\\n          for(int i=0;i+firstLen-1<n;i++)\\n          {\\n              if(i+firstLen<=n-secondLen)\\n              {\\n                  ans=max(ans,pre[i+firstLen]-pre[i]+dp[i+firstLen]);\\n                  \\n                  \\n              }\\n\\n          }\\n/* Now we do above process gain with swapped values. This is done firstLen subbarry can come after also*/\\n          vector<int>dp1(n,0);\\n          m=0;\\n           for(int i=n-firstLen;i>=0;i--)\\n          {\\n              m=max(pre[i+firstLen]-pre[i],m);\\n              dp1[i]=m;\\n\\n          }\\n        \\n          for(int i=0;i+secondLen-1<n;i++)\\n          {\\n              if(i+secondLen<=n-firstLen)\\n              {\\n                  ans=max(ans,pre[i+secondLen]-pre[i]+dp1[i+secondLen]);\\n                  \\n                  \\n              }\\n\\n          }\\n      \\n          return(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        vector<int>pre;\\n        pre.push_back(0);\\n        for(int i=1;i<=nums.size();i++)\\n          pre.push_back(pre[i-1]+nums[i-1]);\\n          int n=nums.size();\\n          vector<int>dp(n,0);\\n          int m=0;\\n//constructing a dp array to store max subarray of len after or ith index\\n          for(int i=n-secondLen;i>=0;i--)\\n          {\\n              m=max(pre[i+secondLen]-pre[i],m);\\n              dp[i]=m;\\n\\n          }\\n          int ans=0;\\n          for(int i=0;i+firstLen-1<n;i++)\\n          {\\n              if(i+firstLen<=n-secondLen)\\n              {\\n                  ans=max(ans,pre[i+firstLen]-pre[i]+dp[i+firstLen]);\\n                  \\n                  \\n              }\\n\\n          }\\n/* Now we do above process gain with swapped values. This is done firstLen subbarry can come after also*/\\n          vector<int>dp1(n,0);\\n          m=0;\\n           for(int i=n-firstLen;i>=0;i--)\\n          {\\n              m=max(pre[i+firstLen]-pre[i],m);\\n              dp1[i]=m;\\n\\n          }\\n        \\n          for(int i=0;i+secondLen-1<n;i++)\\n          {\\n              if(i+secondLen<=n-firstLen)\\n              {\\n                  ans=max(ans,pre[i+secondLen]-pre[i]+dp1[i+secondLen]);\\n                  \\n                  \\n              }\\n\\n          }\\n      \\n          return(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416769,
                "title": "sliding-window-brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int n = nums.size();\\n        vector<pair<int, int>> first, second;\\n\\n        int s = 0, x = 0, ans1 = 0, ans2 = 0;\\n        for(int i=0; i<n; i++) {\\n            s += nums[i];\\n            if(i - x + 1 == firstLen) first.push_back({s, i}), s -= nums[x++];\\n        }\\n        s = 0, x = 0;\\n        for(int i=0; i<n; i++) {\\n            s += nums[i];\\n            if(i - x + 1 == secondLen) second.push_back({s, i}), s -= nums[x++];\\n        }\\n        \\n        for(int i=0; i<first.size(); i++) {\\n            int val = first[i].first, end = first[i].second;\\n            for(int j=0; j<second.size(); j++) {\\n                if(end < second[j].second - secondLen + 1) ans1 = max(ans1, val + second[j].first);\\n            }\\n        }\\n        for(int i=0; i<second.size(); i++) {\\n            int val = second[i].first, end = second[i].second;\\n            for(int j=0; j<first.size(); j++) {\\n                if(end < first[j].second - firstLen + 1) ans2 = max(ans2, val + first[j].first);\\n            }\\n        }\\n        return max(ans1, ans2);\\n    }\\n    // (0,0) (6,1) (5,2) (2,3) (2,4) (5,5) (1,6) (9,7) (4,8)\\n    // (6,1) (11,2) (7,3) (4,4) (7,5) (6,6) (10,7) (13,8)\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int n = nums.size();\\n        vector<pair<int, int>> first, second;\\n\\n        int s = 0, x = 0, ans1 = 0, ans2 = 0;\\n        for(int i=0; i<n; i++) {\\n            s += nums[i];\\n            if(i - x + 1 == firstLen) first.push_back({s, i}), s -= nums[x++];\\n        }\\n        s = 0, x = 0;\\n        for(int i=0; i<n; i++) {\\n            s += nums[i];\\n            if(i - x + 1 == secondLen) second.push_back({s, i}), s -= nums[x++];\\n        }\\n        \\n        for(int i=0; i<first.size(); i++) {\\n            int val = first[i].first, end = first[i].second;\\n            for(int j=0; j<second.size(); j++) {\\n                if(end < second[j].second - secondLen + 1) ans1 = max(ans1, val + second[j].first);\\n            }\\n        }\\n        for(int i=0; i<second.size(); i++) {\\n            int val = second[i].first, end = second[i].second;\\n            for(int j=0; j<first.size(); j++) {\\n                if(end < first[j].second - firstLen + 1) ans2 = max(ans2, val + first[j].first);\\n            }\\n        }\\n        return max(ans1, ans2);\\n    }\\n    // (0,0) (6,1) (5,2) (2,3) (2,4) (5,5) (1,6) (9,7) (4,8)\\n    // (6,1) (11,2) (7,3) (4,4) (7,5) (6,6) (10,7) (13,8)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032509,
                "title": "c-brute-force-in-one-go",
                "content": "# Intuition\\nWhen first f length subarray formed then search for second using same s size subarray with maximum sum\\n\\n\\n# Approach\\nBrute Force\\n\\n# Complexity\\n- Time complexity:\\nO(n2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve(vector<int>& nums, int p, int q)\\n{\\n    int k=p;\\n    int sum1=0;\\n    int maxi=0,total=0;\\n    int i=0,j=0;\\n    while(j<nums.size())\\n    {\\n         sum1+=nums[j];\\n         if(j-i+1<k)\\n        {\\n            \\n            j++;\\n        }\\n        else\\n        {\\n            // cout<<j<<\" \";\\n            int smax=0;\\n            int sum2=0;\\n            int x=j+1,y=j+1;\\n            while(y<nums.size())\\n            {\\n                sum2+=nums[y];\\n                if(y-x+1<q)\\n                {\\n                    y++;\\n                }\\n                else\\n                {\\n                    smax=max(smax,sum2);\\n                    sum2-=nums[x];\\n                    x++;\\n                    y++;\\n                }\\n            }\\n            // if(j==0)\\n            maxi=max(maxi,smax+sum1);\\n            sum1-=nums[i];\\n            i++;\\n            j++;\\n        }\\n    }\\n    return maxi;\\n}\\n    int maxSumTwoNoOverlap(vector<int>& nums, int p, int q) {\\n        int ans=solve(nums,p,q);\\n        int sol=solve(nums,q,p);\\n        return max(sol,ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve(vector<int>& nums, int p, int q)\\n{\\n    int k=p;\\n    int sum1=0;\\n    int maxi=0,total=0;\\n    int i=0,j=0;\\n    while(j<nums.size())\\n    {\\n         sum1+=nums[j];\\n         if(j-i+1<k)\\n        {\\n            \\n            j++;\\n        }\\n        else\\n        {\\n            // cout<<j<<\" \";\\n            int smax=0;\\n            int sum2=0;\\n            int x=j+1,y=j+1;\\n            while(y<nums.size())\\n            {\\n                sum2+=nums[y];\\n                if(y-x+1<q)\\n                {\\n                    y++;\\n                }\\n                else\\n                {\\n                    smax=max(smax,sum2);\\n                    sum2-=nums[x];\\n                    x++;\\n                    y++;\\n                }\\n            }\\n            // if(j==0)\\n            maxi=max(maxi,smax+sum1);\\n            sum1-=nums[i];\\n            i++;\\n            j++;\\n        }\\n    }\\n    return maxi;\\n}\\n    int maxSumTwoNoOverlap(vector<int>& nums, int p, int q) {\\n        int ans=solve(nums,p,q);\\n        int sol=solve(nums,q,p);\\n        return max(sol,ans);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2769012,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n int n;\\n    vector<int> st;\\n    \\n    void build(vector<int> &nums){\\n        st=vector<int> (2*n,0);\\n        for(int i=n;i<2*n;i++){\\n            st[i]=nums[i-n];\\n        }\\n        for(int i=n-1;i>0;--i){\\n            st[i]=st[i<<1]+st[i<<1|1];\\n        }\\n    }\\n    \\n    int getSum(int l,int r){\\n        int res=0;\\n        for(l+=n,r+=n;l<r;l>>=1,r>>=1){\\n            if(l&1) res+=st[l++];\\n            if(r&1) res+=st[--r];\\n        }\\n        return res;\\n    }\\n    \\n    \\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int fl, int sl) {\\n        n=nums.size();\\n       \\n        build(nums);\\n        int ans=0;\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        swap(fl,sl);\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n int n;\\n    vector<int> st;\\n    \\n    void build(vector<int> &nums){\\n        st=vector<int> (2*n,0);\\n        for(int i=n;i<2*n;i++){\\n            st[i]=nums[i-n];\\n        }\\n        for(int i=n-1;i>0;--i){\\n            st[i]=st[i<<1]+st[i<<1|1];\\n        }\\n    }\\n    \\n    int getSum(int l,int r){\\n        int res=0;\\n        for(l+=n,r+=n;l<r;l>>=1,r>>=1){\\n            if(l&1) res+=st[l++];\\n            if(r&1) res+=st[--r];\\n        }\\n        return res;\\n    }\\n    \\n    \\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int fl, int sl) {\\n        n=nums.size();\\n       \\n        build(nums);\\n        int ans=0;\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        swap(fl,sl);\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686460,
                "title": "simple-c-solution-using-segment-tree",
                "content": "\\n\\n```\\nclass Solution {\\n    \\n    int n;\\n    vector<int> st;\\n    \\n    void build(vector<int> &nums){\\n        st=vector<int> (2*n,0);\\n        for(int i=n;i<2*n;i++){\\n            st[i]=nums[i-n];\\n        }\\n        for(int i=n-1;i>0;--i){\\n            st[i]=st[i<<1]+st[i<<1|1];\\n        }\\n    }\\n    \\n    int getSum(int l,int r){\\n        int res=0;\\n        for(l+=n,r+=n;l<r;l>>=1,r>>=1){\\n            if(l&1) res+=st[l++];\\n            if(r&1) res+=st[--r];\\n        }\\n        return res;\\n    }\\n    \\n    \\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int fl, int sl) {\\n        n=nums.size();\\n       \\n        build(nums);\\n        int ans=0;\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        swap(fl,sl);\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int n;\\n    vector<int> st;\\n    \\n    void build(vector<int> &nums){\\n        st=vector<int> (2*n,0);\\n        for(int i=n;i<2*n;i++){\\n            st[i]=nums[i-n];\\n        }\\n        for(int i=n-1;i>0;--i){\\n            st[i]=st[i<<1]+st[i<<1|1];\\n        }\\n    }\\n    \\n    int getSum(int l,int r){\\n        int res=0;\\n        for(l+=n,r+=n;l<r;l>>=1,r>>=1){\\n            if(l&1) res+=st[l++];\\n            if(r&1) res+=st[--r];\\n        }\\n        return res;\\n    }\\n    \\n    \\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int fl, int sl) {\\n        n=nums.size();\\n       \\n        build(nums);\\n        int ans=0;\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        swap(fl,sl);\\n        for(int i=0;i<n-fl;i++){\\n            for(int j=i+fl;j<=n-sl;j++){\\n                ans=max(ans,getSum(i,i+fl)+getSum(j,j+sl));\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654851,
                "title": "super-long-c-solution-very-readable-o-n",
                "content": "```\\nclass Solution {\\npublic:\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int n=nums.size();\\n        vector<int> a(n,-1), b(n,-1), c(n+1,-1), d(n+1,-1);\\n        int i=0, j=0, sum=0, len=0, mxSum=0;\\n        while(i<n){\\n            sum+=nums[i]; len++;\\n            if(len>firstLen){ sum-=nums[j++]; len--; }\\n            if(len==firstLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            a[i]=(len==firstLen)?mxSum:-1;\\n            i++;\\n        }\\n        i=0, j=0, sum=0, len=0, mxSum=0;\\n        while(i<n){\\n            sum+=nums[i]; len++;\\n            if(len>secondLen){ sum-=nums[j++]; len--; }\\n            if(len==secondLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            b[i]=(len==secondLen)?mxSum:-1;\\n            i++;\\n        }\\n        i=n-1, j=n-1, sum=0, len=0, mxSum=0;\\n        while(i>=0){\\n            sum+=nums[i]; len++;\\n            if(len>firstLen){ sum-=nums[j--]; len--; }\\n            if(len==firstLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            c[i]=(len==firstLen)?mxSum:-1;\\n            i--;\\n        }\\n        i=n-1, j=n-1, sum=0, len=0, mxSum=0;\\n        while(i>=0){\\n            sum+=nums[i]; len++;\\n            if(len>secondLen){ sum-=nums[j--]; len--; }\\n            if(len==secondLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            d[i]=(len==secondLen)?mxSum:-1;\\n            i--;\\n        }\\n\\n\\t\\tint ans=0;\\n        for(int i=0; i<n; i++){\\n            if(a[i]!=-1 && d[i+1]!=-1){ ans=max(ans,a[i]+d[i+1]); }\\n            if(b[i]!=-1 && c[i+1]!=-1){ ans=max(ans,b[i]+c[i+1]); }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int n=nums.size();\\n        vector<int> a(n,-1), b(n,-1), c(n+1,-1), d(n+1,-1);\\n        int i=0, j=0, sum=0, len=0, mxSum=0;\\n        while(i<n){\\n            sum+=nums[i]; len++;\\n            if(len>firstLen){ sum-=nums[j++]; len--; }\\n            if(len==firstLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            a[i]=(len==firstLen)?mxSum:-1;\\n            i++;\\n        }\\n        i=0, j=0, sum=0, len=0, mxSum=0;\\n        while(i<n){\\n            sum+=nums[i]; len++;\\n            if(len>secondLen){ sum-=nums[j++]; len--; }\\n            if(len==secondLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            b[i]=(len==secondLen)?mxSum:-1;\\n            i++;\\n        }\\n        i=n-1, j=n-1, sum=0, len=0, mxSum=0;\\n        while(i>=0){\\n            sum+=nums[i]; len++;\\n            if(len>firstLen){ sum-=nums[j--]; len--; }\\n            if(len==firstLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            c[i]=(len==firstLen)?mxSum:-1;\\n            i--;\\n        }\\n        i=n-1, j=n-1, sum=0, len=0, mxSum=0;\\n        while(i>=0){\\n            sum+=nums[i]; len++;\\n            if(len>secondLen){ sum-=nums[j--]; len--; }\\n            if(len==secondLen){\\n                mxSum=max(mxSum,sum);\\n            }\\n            d[i]=(len==secondLen)?mxSum:-1;\\n            i--;\\n        }\\n\\n\\t\\tint ans=0;\\n        for(int i=0; i<n; i++){\\n            if(a[i]!=-1 && d[i+1]!=-1){ ans=max(ans,a[i]+d[i+1]); }\\n            if(b[i]!=-1 && c[i+1]!=-1){ ans=max(ans,b[i]+c[i+1]); }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640066,
                "title": "sliding-window-prefix-sum-python3-solution-o-1-space",
                "content": "```\\nclass Solution:\\n    # O(n^2) time,\\n    # O(1) space,\\n    # Approach: prefix sum\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        n = len(nums)\\n        max_sum = 0\\n        \\n        for i in range(1, n):\\n            nums[i] += nums[i-1]\\n            \\n        def findSubarraySum(l: int, r: int) -> int:\\n            if l == 0:\\n                return nums[r]\\n            \\n            return nums[r] - nums[l-1]\\n        \\n        for i in range(0, n-firstLen+1):\\n            first_tot = findSubarraySum(i, i+firstLen-1)\\n            for j in range(0, i-secondLen+1):\\n                second_tot = findSubarraySum(j, j+secondLen-1)\\n                max_sum = max(max_sum, second_tot + first_tot)\\n                \\n            for j in range(i+firstLen, n-secondLen+1):\\n                second_tot = findSubarraySum(j, j+secondLen-1)\\n                max_sum = max(max_sum, second_tot + first_tot)\\n                \\n        return max_sum\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    # O(n^2) time,\\n    # O(1) space,\\n    # Approach: prefix sum\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        n = len(nums)\\n        max_sum = 0\\n        \\n        for i in range(1, n):\\n            nums[i] += nums[i-1]\\n            \\n        def findSubarraySum(l: int, r: int) -> int:\\n            if l == 0:\\n                return nums[r]\\n            \\n            return nums[r] - nums[l-1]\\n        \\n        for i in range(0, n-firstLen+1):\\n            first_tot = findSubarraySum(i, i+firstLen-1)\\n            for j in range(0, i-secondLen+1):\\n                second_tot = findSubarraySum(j, j+secondLen-1)\\n                max_sum = max(max_sum, second_tot + first_tot)\\n                \\n            for j in range(i+firstLen, n-secondLen+1):\\n                second_tot = findSubarraySum(j, j+secondLen-1)\\n                max_sum = max(max_sum, second_tot + first_tot)\\n                \\n        return max_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449594,
                "title": "1031-maximum-sum-of-two-non-overlapping-subarrays-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        \\n        \\n        vector<int>prefix(nums.size(),0);\\n        int temp = 0;\\n        for(int i = 0 ; i < firstLen ; i++)\\n            temp+=nums[i];\\n        \\n        prefix[firstLen-1] = temp;\\n        int  k = 0;\\n        int curr_max = temp;\\n        int idx1 = firstLen -1;\\n      \\n        for(int i = firstLen ; i < nums.size() ; i++ ){\\n            int temp_sum = prefix[i-1] +  nums[i] - nums[k++];\\n            if(curr_max < temp_sum){\\n                curr_max = temp_sum;\\n                idx1 = i;\\n            }\\n            \\n            prefix[i] =  temp_sum;\\n        }\\n   \\n        //second part\\n        reverse(nums.begin(),nums.end());\\n        vector<int>prefix2(nums.size(),0);\\n        temp = 0;\\n        for(int i = 0 ; i < secondLen ; i++)\\n            temp+=nums[i];\\n        \\n        prefix2[secondLen-1] = temp;\\n        k = 0;\\n        int curr_max2 = temp;\\n        int idx2 = firstLen -1;\\n        \\n        \\n        for(int i = secondLen ; i < nums.size() ; i++ ){\\n            int temp_sum = prefix2[i-1] +  nums[i] - nums[k++];\\n            if(curr_max2< temp_sum ){\\n                curr_max2 = temp_sum;\\n                idx2 = i;\\n            }\\n            prefix2[i] =  temp_sum;\\n        }\\n        \\n        //main logic\\n        reverse(prefix2.begin(),prefix2.end());\\n        int cur=0;\\n        int res=0;\\n        for(int i=firstLen-1;i<nums.size();i++){\\n            for(int j=0;j<=i-firstLen-secondLen+1;j++){\\n                cur=prefix[i]+prefix2[j];\\n                if(cur>res){\\n                    res=cur;\\n                 }\\n            }\\n            for(int j=i+1;j<nums.size();j++){\\n                cur=prefix[i]+prefix2[j];\\n                if(cur>res){\\n                    res=cur;\\n                }\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        \\n        \\n        vector<int>prefix(nums.size(),0);\\n        int temp = 0;\\n        for(int i = 0 ; i < firstLen ; i++)\\n            temp+=nums[i];\\n        \\n        prefix[firstLen-1] = temp;\\n        int  k = 0;\\n        int curr_max = temp;\\n        int idx1 = firstLen -1;\\n      \\n        for(int i = firstLen ; i < nums.size() ; i++ ){\\n            int temp_sum = prefix[i-1] +  nums[i] - nums[k++];\\n            if(curr_max < temp_sum){\\n                curr_max = temp_sum;\\n                idx1 = i;\\n            }\\n            \\n            prefix[i] =  temp_sum;\\n        }\\n   \\n        //second part\\n        reverse(nums.begin(),nums.end());\\n        vector<int>prefix2(nums.size(),0);\\n        temp = 0;\\n        for(int i = 0 ; i < secondLen ; i++)\\n            temp+=nums[i];\\n        \\n        prefix2[secondLen-1] = temp;\\n        k = 0;\\n        int curr_max2 = temp;\\n        int idx2 = firstLen -1;\\n        \\n        \\n        for(int i = secondLen ; i < nums.size() ; i++ ){\\n            int temp_sum = prefix2[i-1] +  nums[i] - nums[k++];\\n            if(curr_max2< temp_sum ){\\n                curr_max2 = temp_sum;\\n                idx2 = i;\\n            }\\n            prefix2[i] =  temp_sum;\\n        }\\n        \\n        //main logic\\n        reverse(prefix2.begin(),prefix2.end());\\n        int cur=0;\\n        int res=0;\\n        for(int i=firstLen-1;i<nums.size();i++){\\n            for(int j=0;j<=i-firstLen-secondLen+1;j++){\\n                cur=prefix[i]+prefix2[j];\\n                if(cur>res){\\n                    res=cur;\\n                 }\\n            }\\n            for(int j=i+1;j<nums.size();j++){\\n                cur=prefix[i]+prefix2[j];\\n                if(cur>res){\\n                    res=cur;\\n                }\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448562,
                "title": "java-leftmax-and-rightmax-array-approach-clean-code-5-m-s",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int max1 = getMax(nums,firstLen,secondLen);\\n        int max2 = getMax(nums,secondLen,firstLen);\\n        return Math.max(max1,max2);\\n    }\\n    \\n    public int getMax(int[]nums,int fl,int sl){\\n        int []left = new int[nums.length];\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n            \\n            if(i == fl - 1){\\n                left[i] = sum;\\n            }else if(i >= fl){\\n                sum -=  nums[i - fl];\\n                left[i] = Math.max(sum,left[i-1]);\\n            }\\n        }\\n        \\n        int[]right = new int[nums.length];\\n        sum = 0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            sum += nums[i];\\n             \\n            if(i == nums.length - sl){\\n                right[i] = sum;\\n            }else if(i <= nums.length - sl){\\n                sum -= nums[i + sl];\\n                right[i] = Math.max(sum,right[i+1]);\\n            }\\n        }\\n        \\n        \\n        int max = Integer.MIN_VALUE;\\n        for(int i=fl-1;i<nums.length-sl;i++){\\n            max = Math.max(max,left[i] + right[i+1]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int max1 = getMax(nums,firstLen,secondLen);\\n        int max2 = getMax(nums,secondLen,firstLen);\\n        return Math.max(max1,max2);\\n    }\\n    \\n    public int getMax(int[]nums,int fl,int sl){\\n        int []left = new int[nums.length];\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum += nums[i];\\n            \\n            if(i == fl - 1){\\n                left[i] = sum;\\n            }else if(i >= fl){\\n                sum -=  nums[i - fl];\\n                left[i] = Math.max(sum,left[i-1]);\\n            }\\n        }\\n        \\n        int[]right = new int[nums.length];\\n        sum = 0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            sum += nums[i];\\n             \\n            if(i == nums.length - sl){\\n                right[i] = sum;\\n            }else if(i <= nums.length - sl){\\n                sum -= nums[i + sl];\\n                right[i] = Math.max(sum,right[i+1]);\\n            }\\n        }\\n        \\n        \\n        int max = Integer.MIN_VALUE;\\n        for(int i=fl-1;i<nums.length-sl;i++){\\n            max = Math.max(max,left[i] + right[i+1]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426862,
                "title": "java-sliding-window-one-loop-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int firstLeft=0;\\n        int secLeft=0;\\n        int firstRight=0;\\n        int secRight=0;\\n        \\n        for(int i=0;i<Math.max(firstLen,secondLen);i++){\\n            if(i<firstLen){\\n                firstLeft+=nums[i];\\n            }\\n            if(i<secondLen){\\n                secLeft+=nums[i];\\n            }\\n        }\\n        \\n        for(int i=Math.min(firstLen,secondLen);i<secondLen+firstLen;i++){\\n            if(i>=secondLen){\\n                firstRight+=nums[i];\\n            }\\n            if(i>=firstLen){\\n                secRight+=nums[i];\\n            }\\n        }\\n        \\n        int end=firstLen+secondLen;\\n        int res=firstRight+secLeft;\\n        int firstLmax=firstLeft; //max left sum of size firstlen\\n        int secLmax=secLeft;    //max left sum of size seclen\\n        //mainitain running left(firstLeft and  secLeft) sum and max lefts both separatley, since while computing we will use max lefts but to find max we need running ones\\n        \\n        while(end<nums.length){\\n            firstRight+=nums[end]-nums[end-firstLen];\\n            secRight+=nums[end]-nums[end-secondLen];\\n            \\n            \\n            firstLeft=firstLeft+nums[end-secondLen]-nums[end-secondLen-firstLen];\\n            firstLmax=Math.max(firstLmax,firstLeft);\\n            \\n            secLeft=secLeft+nums[end-firstLen]-nums[end-firstLen-secondLen];\\n            secLmax=Math.max(secLeft,secLmax);\\n            \\n            res=Math.max(res,firstLmax+secRight);\\n            res=Math.max(res,secLmax+firstRight);\\n            \\n            end++;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int firstLeft=0;\\n        int secLeft=0;\\n        int firstRight=0;\\n        int secRight=0;\\n        \\n        for(int i=0;i<Math.max(firstLen,secondLen);i++){\\n            if(i<firstLen){\\n                firstLeft+=nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2414686,
                "title": "sliding-window-array-reversal-simple-logic-clean-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int fun(vector<int>& nums, int firstLen, int secondLen){\\n        int sumf = 0;\\n        int maxi = INT_MIN;\\n\\n        for(int i=0; i<firstLen; i++){\\n            sumf += nums[i];\\n        }\\n\\n        for(int i=firstLen; i<nums.size(); i++){\\n            int curr_win_sum = 0;\\n            int j = i;\\n            int val = j + secondLen;\\n            while(j < val && j < nums.size()){\\n                curr_win_sum += nums[j++];\\n            }\\n            maxi = max(maxi, sumf + curr_win_sum);\\n            while(j < nums.size()){\\n                curr_win_sum += nums[j];\\n                curr_win_sum -= nums[j-secondLen];\\n                maxi = max(maxi, sumf + curr_win_sum);\\n                j++;\\n            }\\n            sumf += nums[i];\\n            sumf -= nums[i - firstLen];\\n        }\\n        return maxi;\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int f = fun(nums, firstLen, secondLen);\\n        reverse(nums.begin(), nums.end());\\n        int s = fun(nums, firstLen, secondLen);\\n        return max(f, s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int fun(vector<int>& nums, int firstLen, int secondLen){\\n        int sumf = 0;\\n        int maxi = INT_MIN;\\n\\n        for(int i=0; i<firstLen; i++){\\n            sumf += nums[i];\\n        }\\n\\n        for(int i=firstLen; i<nums.size(); i++){\\n            int curr_win_sum = 0;\\n            int j = i;\\n            int val = j + secondLen;\\n            while(j < val && j < nums.size()){\\n                curr_win_sum += nums[j++];\\n            }\\n            maxi = max(maxi, sumf + curr_win_sum);\\n            while(j < nums.size()){\\n                curr_win_sum += nums[j];\\n                curr_win_sum -= nums[j-secondLen];\\n                maxi = max(maxi, sumf + curr_win_sum);\\n                j++;\\n            }\\n            sumf += nums[i];\\n            sumf -= nums[i - firstLen];\\n        }\\n        return maxi;\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int f = fun(nums, firstLen, secondLen);\\n        reverse(nums.begin(), nums.end());\\n        int s = fun(nums, firstLen, secondLen);\\n        return max(f, s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406747,
                "title": "python-similar-to-buy-sell-stock-iii-easy-explaination-o-n",
                "content": "\\tclass Solution:\\n\\t\\tdef maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n\\t\\t\\tn=len(nums)\\n\\n\\t\\t\\tdef fir_sum(l,r):\\n\\t\\t\\t\\tfirst_sum=[0]*n #store the maximum prefix sum at an index i of subarray of length firstlen\\n\\t\\t\\t\\tfirst_sum[r]=sum(nums[:r+1])\\n\\t\\t\\t\\tcur_sum=sum(nums[:r+1])\\n\\t\\t\\t\\twhile r<n:\\n\\t\\t\\t\\t\\tr+=1\\n\\t\\t\\t\\t\\tif r<n:\\n\\t\\t\\t\\t\\t\\tcur_sum+=nums[r]-nums[l]\\n\\t\\t\\t\\t\\t\\tfirst_sum[r]=max(first_sum[r-1],cur_sum)\\n\\t\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\treturn first_sum\\n\\n\\t\\t\\tdef second_sum(l,r):\\n\\t\\t\\t\\tsec_sum=[0]*n #store the maximum suffix sum at an index i till i+secondlen\\n\\t\\t\\t\\tsec_sum[l]=sum(nums[l:])\\n\\t\\t\\t\\tcur_sum=sum(nums[l:])\\n\\t\\t\\t\\twhile l>=0:\\n\\t\\t\\t\\t\\tl-=1\\n\\t\\t\\t\\t\\tif l>=0:\\n\\t\\t\\t\\t\\t\\tcur_sum+=nums[l]-nums[r]\\n\\t\\t\\t\\t\\t\\tsec_sum[l]=max(sec_sum[l+1],cur_sum)\\n\\t\\t\\t\\t\\tr-=1\\n\\t\\t\\t\\treturn sec_sum\\n\\n\\t\\t\\tfirst_sum=fir_sum(0,firstLen-1)\\n\\t\\t\\tsec_sum=second_sum(n-secondLen,n-1)\\n\\n\\t\\t\\tmax_val=float(\"-inf\")\\n\\n\\t\\t\\tfor r in range(firstLen-1,n-secondLen):\\n\\t\\t\\t\\tmax_val=max(max_val,first_sum[r]+sec_sum[r+1])\\n\\n\\t\\t\\tfirst_sum=fir_sum(0,secondLen-1)\\n\\t\\t\\tsec_sum=second_sum(n-firstLen,n-1)\\n\\n\\n\\t\\t\\tfor r in range(secondLen-1,n-firstLen):\\n\\t\\t\\t\\tmax_val=max(max_val,first_sum[r]+sec_sum[r+1])\\n\\n\\t\\t\\treturn max_val\\n\\n\\n",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n\\t\\t\\tn=len(nums)\\n\\n\\t\\t\\tdef fir_sum(l,r):\\n\\t\\t\\t\\tfirst_sum=[0]*n #store the maximum prefix sum at an index i of subarray of length firstlen\\n\\t\\t\\t\\tfirst_sum[r]=sum(nums[:r+1])\\n\\t\\t\\t\\tcur_sum=sum(nums[:r+1])\\n\\t\\t\\t\\twhile r<n:\\n\\t\\t\\t\\t\\tr+=1\\n\\t\\t\\t\\t\\tif r<n:\\n\\t\\t\\t\\t\\t\\tcur_sum+=nums[r]-nums[l]\\n\\t\\t\\t\\t\\t\\tfirst_sum[r]=max(first_sum[r-1],cur_sum)\\n\\t\\t\\t\\t\\tl+=1\\n\\t\\t\\t\\treturn first_sum\\n\\n\\t\\t\\tdef second_sum(l,r):\\n\\t\\t\\t\\tsec_sum=[0]*n #store the maximum suffix sum at an index i till i+secondlen\\n\\t\\t\\t\\tsec_sum[l]=sum(nums[l:])\\n\\t\\t\\t\\tcur_sum=sum(nums[l:])\\n\\t\\t\\t\\twhile l>=0:\\n\\t\\t\\t\\t\\tl-=1\\n\\t\\t\\t\\t\\tif l>=0:\\n\\t\\t\\t\\t\\t\\tcur_sum+=nums[l]-nums[r]\\n\\t\\t\\t\\t\\t\\tsec_sum[l]=max(sec_sum[l+1],cur_sum)\\n\\t\\t\\t\\t\\tr-=1\\n\\t\\t\\t\\treturn sec_sum\\n\\n\\t\\t\\tfirst_sum=fir_sum(0,firstLen-1)\\n\\t\\t\\tsec_sum=second_sum(n-secondLen,n-1)\\n\\n\\t\\t\\tmax_val=float(\"-inf\")\\n\\n\\t\\t\\tfor r in range(firstLen-1,n-secondLen):\\n\\t\\t\\t\\tmax_val=max(max_val,first_sum[r]+sec_sum[r+1])\\n\\n\\t\\t\\tfirst_sum=fir_sum(0,secondLen-1)\\n\\t\\t\\tsec_sum=second_sum(n-firstLen,n-1)\\n\\n\\n\\t\\t\\tfor r in range(secondLen-1,n-firstLen):\\n\\t\\t\\t\\tmax_val=max(max_val,first_sum[r]+sec_sum[r+1])\\n\\n\\t\\t\\treturn max_val\\n\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2317955,
                "title": "c-sliding-window-array-partition-easy-to-follow",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // choosing first in left and second in right subarray\\n            int p=fun(nums,0,i,firstLen);// left subarray ( 0 to i-1 ) \\n            int q=fun(nums,i,nums.size(),secondLen);// right subarray ( i to num.length -1)\\n            \\n            // choosing first in right and second in left subarray\\n            int r=fun(nums,0,i,secondLen);// left subarray ( 0 to i-1 )\\n            int s=fun(nums,i,nums.size(),firstLen);// right subarray ( i to num.length -1)\\n            \\n            res=max(res,p+q);// left,right\\n            res=max(res,r+s);// right,left\\n        }\\n        return res;\\n    }\\n    int fun(vector<int>& nums,int i,int j,int len)\\n    {\\n        if(j-i<len)// in-sufficient size\\n            return 0;\\n        \\n        int res=0;\\n        int sum=0;\\n        int k=i;\\n        while(len--)\\n        {\\n            sum+=nums[i];\\n            i++;\\n        }\\n        while(i<j)\\n        {\\n            res=max(res,sum);\\n            sum+=nums[i++];\\n            sum-=nums[k++];\\n        }\\n        res=max(res,sum);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int res=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            // choosing first in left and second in right subarray\\n            int p=fun(nums,0,i,firstLen);// left subarray ( 0 to i-1 ) \\n            int q=fun(nums,i,nums.size(),secondLen);// right subarray ( i to num.length -1)\\n            \\n            // choosing first in right and second in left subarray\\n            int r=fun(nums,0,i,secondLen);// left subarray ( 0 to i-1 )\\n            int s=fun(nums,i,nums.size(),firstLen);// right subarray ( i to num.length -1)\\n            \\n            res=max(res,p+q);// left,right\\n            res=max(res,r+s);// right,left\\n        }\\n        return res;\\n    }\\n    int fun(vector<int>& nums,int i,int j,int len)\\n    {\\n        if(j-i<len)// in-sufficient size\\n            return 0;\\n        \\n        int res=0;\\n        int sum=0;\\n        int k=i;\\n        while(len--)\\n        {\\n            sum+=nums[i];\\n            i++;\\n        }\\n        while(i<j)\\n        {\\n            res=max(res,sum);\\n            sum+=nums[i++];\\n            sum-=nums[k++];\\n        }\\n        res=max(res,sum);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2286248,
                "title": "c-easy-code-sliding-window-with-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int fan(vector<int>&nums,int A,int B)\\n    {\\n        int n=nums.size();\\n        vector<int>x(n,0),y(n,0);\\n        int sum=0;\\n       for(int i=0;i<n;i++)                 //for initialize dp x left to right with A size window  \\n       {\\n           if(i<A)\\n           {\\n              sum+=nums[i];\\n              x[i]=sum;\\n           } \\n           else\\n           {\\n               sum+=nums[i]-nums[i-A];\\n               x[i]=max(x[i-1],sum);\\n           }\\n       }\\n        sum=0;\\n       for(int i=n-1;i>=0;i--)               //for initialize dp y right to left with B size window\\n        {\\n            if(n-i<=B)\\n            {\\n                sum+=nums[i];\\n                y[i]=sum;\\n            }\\n            else\\n            {\\n               sum+=nums[i]-nums[i+B];\\n               y[i]=max(y[i+1],sum); \\n            }\\n        }\\n        int ans=0,maxj=0;\\n        \\n       for(int j=A-1;j<n-B;j++)             //add the max left dp with max right dp \\n       {\\n            maxj=x[j]+y[j+1];\\n            ans=max(ans,maxj);              //find Maximum sum\\n       }\\n        return ans;\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& nums, int first, int second)\\n    {\\n       return max(fan(nums,first,second),fan(nums,second,first));\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int fan(vector<int>&nums,int A,int B)\\n    {\\n        int n=nums.size();\\n        vector<int>x(n,0),y(n,0);\\n        int sum=0;\\n       for(int i=0;i<n;i++)                 //for initialize dp x left to right with A size window  \\n       {\\n           if(i<A)\\n           {\\n              sum+=nums[i];\\n              x[i]=sum;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 2239725,
                "title": "c-solution-o-n-n-s-n",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) \\n    {\\n        std::vector<int> sum(nums.begin(), nums.end());\\n        for (int i = 1; i < sum.size(); i++)\\n        {\\n            sum[i] += sum[i - 1];\\n        }\\n        \\n        if (firstLen + secondLen == nums.size())\\n            return sum.back();\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i <= nums.size() - firstLen - secondLen; i++)\\n        {\\n            for (int j = i + firstLen; j <= nums.size() - secondLen; j++)\\n            {\\n                res = std::max(\\n                    res, \\n                    (sum[i + firstLen - 1] - sum[i] + nums[i]) + (sum[j + secondLen - 1] - sum[j] + nums[j])\\n                );\\n            }\\n        }\\n        \\n        if (firstLen == secondLen)\\n            return res;\\n        \\n        std::swap(firstLen, secondLen);\\n        for (int i = 0; i <= nums.size() - firstLen - secondLen; i++)\\n        {\\n            for (int j = i + firstLen; j <= nums.size() - secondLen; j++)\\n            {\\n                res = std::max(\\n                    res, \\n                    (sum[i + firstLen - 1] - sum[i] + nums[i]) + (sum[j + secondLen - 1] - sum[j] + nums[j])\\n                );\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) \\n    {\\n        std::vector<int> sum(nums.begin(), nums.end());\\n        for (int i = 1; i < sum.size(); i++)\\n        {\\n            sum[i] += sum[i - 1];\\n        }\\n        \\n        if (firstLen + secondLen == nums.size())\\n            return sum.back();\\n        \\n        int res = 0;\\n        \\n        for (int i = 0; i <= nums.size() - firstLen - secondLen; i++)\\n        {\\n            for (int j = i + firstLen; j <= nums.size() - secondLen; j++)\\n            {\\n                res = std::max(\\n                    res, \\n                    (sum[i + firstLen - 1] - sum[i] + nums[i]) + (sum[j + secondLen - 1] - sum[j] + nums[j])\\n                );\\n            }\\n        }\\n        \\n        if (firstLen == secondLen)\\n            return res;\\n        \\n        std::swap(firstLen, secondLen);\\n        for (int i = 0; i <= nums.size() - firstLen - secondLen; i++)\\n        {\\n            for (int j = i + firstLen; j <= nums.size() - secondLen; j++)\\n            {\\n                res = std::max(\\n                    res, \\n                    (sum[i + firstLen - 1] - sum[i] + nums[i]) + (sum[j + secondLen - 1] - sum[j] + nums[j])\\n                );\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205777,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        vector<int> sumvect;int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {sum+=nums[i]; sumvect.push_back(sum);}\\n        if(firstLen+secondLen==nums.size())\\n            return sum;\\n        int res=0;\\n        for(int i=firstLen-1;i<nums.size();i++)\\n        {int temp=0,temp2=0,maxsum=0;\\n            if(i==firstLen-1)\\n                temp=sumvect[i];\\n         else\\n             temp=sumvect[i]-sumvect[i-firstLen];\\n            if(secondLen+firstLen<=i)\\n            {\\n                for(int j=secondLen-1;j<=i-firstLen;j++)\\n                {  if(j==secondLen-1)\\n                temp2=sumvect[j];\\n         else\\n             temp2=sumvect[j]-sumvect[j-secondLen];\\n                 maxsum=max(temp+temp2,maxsum);\\n                }   \\n            }\\n         for(int j=i+secondLen;j<nums.size();j++)\\n         {\\n             if(j-secondLen>=0)\\n                 maxsum=max(maxsum,temp+sumvect[j]-sumvect[j-secondLen]);\\n         }\\n         res=max(maxsum,res);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        vector<int> sumvect;int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {sum+=nums[i]; sumvect.push_back(sum);}",
                "codeTag": "Java"
            },
            {
                "id": 2161169,
                "title": "c-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        \\n        int n=A.size();\\n        vector<int>first(n-L+1),second(n-M+1);\\n         int k=0,p=0;\\n        int f=n-L+1,s=n-M+1;\\n        int fmaxi = INT_MIN,smaxi = INT_MIN,ind1=0,ind2=0;\\n        if(L==1)\\n        {\\n           first[0]=A[0];\\n            fmaxi = A[0];\\n            k++;\\n        }\\n        if(M==1)\\n        {\\n            second[0]=A[0];\\n            smaxi = A[0];\\n            p++;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n             A[i]+=A[i-1];\\n            if(i>=(L-1))\\n            {\\n                if((i-L)>=0)\\n                    first[k]= A[i]-A[i-L];\\n                else\\n                    first[k]=A[i];\\n                if(fmaxi <= first[k])\\n                {\\n                    fmaxi = first[k]; \\n                    ind1 = k;\\n                }\\n                k++;\\n            }\\n            if(i>=(M-1))\\n            {\\n                if((i-M)>=0)\\n                    second[p]=A[i]-A[i-M];\\n                else\\n                  second[p]=A[i]; \\n                if(smaxi <= second[p])\\n                {\\n                    smaxi = second[p]; \\n                    ind2 = p;\\n                }\\n                p++;\\n            }            \\n        }\\n        int x=-1,ans=INT_MIN;\\n        for(int i=0;i<(f-M);i++)\\n        {\\n            if(ind2 >= (i+L))\\n            {\\n                    ans = max(ans,smaxi+first[i]);\\n            }\\n            else\\n            {\\n                smaxi=-1;\\n               for(int j=(i+L);j<(n-M+1);j++)\\n                {\\n\\n                    if(smaxi<=second[j])\\n                    {\\n                        smaxi=second[j];\\n                        ind2=j;\\n                    }                   \\n                }\\n                ans = max(ans,smaxi+first[i]);\\n            }\\n        }\\n         for(int i=0;i<(s-L);i++)\\n        {\\n            if(ind1 >= (i+M))\\n            {\\n                    ans = max(ans,fmaxi+second[i]);\\n            }\\n            else\\n            {\\n                fmaxi=-1;\\n               for(int j=(i+M);j<(n-L+1);j++)\\n                {\\n\\n                    if(fmaxi<=first[j])\\n                    {\\n                        fmaxi=first[j];\\n                        ind1=j;\\n                    }                   \\n                }\\n                ans = max(ans,fmaxi+second[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        \\n        int n=A.size();\\n        vector<int>first(n-L+1),second(n-M+1);\\n         int k=0,p=0;\\n        int f=n-L+1,s=n-M+1;\\n        int fmaxi = INT_MIN,smaxi = INT_MIN,ind1=0,ind2=0;\\n        if(L==1)\\n        {\\n           first[0]=A[0];\\n            fmaxi = A[0];\\n            k++;\\n        }\\n        if(M==1)\\n        {\\n            second[0]=A[0];\\n            smaxi = A[0];\\n            p++;\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n             A[i]+=A[i-1];\\n            if(i>=(L-1))\\n            {\\n                if((i-L)>=0)\\n                    first[k]= A[i]-A[i-L];\\n                else\\n                    first[k]=A[i];\\n                if(fmaxi <= first[k])\\n                {\\n                    fmaxi = first[k]; \\n                    ind1 = k;\\n                }\\n                k++;\\n            }\\n            if(i>=(M-1))\\n            {\\n                if((i-M)>=0)\\n                    second[p]=A[i]-A[i-M];\\n                else\\n                  second[p]=A[i]; \\n                if(smaxi <= second[p])\\n                {\\n                    smaxi = second[p]; \\n                    ind2 = p;\\n                }\\n                p++;\\n            }            \\n        }\\n        int x=-1,ans=INT_MIN;\\n        for(int i=0;i<(f-M);i++)\\n        {\\n            if(ind2 >= (i+L))\\n            {\\n                    ans = max(ans,smaxi+first[i]);\\n            }\\n            else\\n            {\\n                smaxi=-1;\\n               for(int j=(i+L);j<(n-M+1);j++)\\n                {\\n\\n                    if(smaxi<=second[j])\\n                    {\\n                        smaxi=second[j];\\n                        ind2=j;\\n                    }                   \\n                }\\n                ans = max(ans,smaxi+first[i]);\\n            }\\n        }\\n         for(int i=0;i<(s-L);i++)\\n        {\\n            if(ind1 >= (i+M))\\n            {\\n                    ans = max(ans,fmaxi+second[i]);\\n            }\\n            else\\n            {\\n                fmaxi=-1;\\n               for(int j=(i+M);j<(n-L+1);j++)\\n                {\\n\\n                    if(fmaxi<=first[j])\\n                    {\\n                        fmaxi=first[j];\\n                        ind1=j;\\n                    }                   \\n                }\\n                ans = max(ans,fmaxi+second[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156643,
                "title": "easy-one-pass-dp-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int l1, int l2) {\\n        int n = nums.size(), res = 0;\\n        vector <int> dp1(n, 0), dp2(n, 0);\\n\\t\\t\\n\\t\\t// dp1[i] stores the maximum sub-array sum of len l1 until i\\n\\t\\t// dp2[i] stores the maximum sub-array sum of len l2 until i\\n        \\n        if(l1 == 1) {\\n            dp1[0] = nums[0];\\n        }\\n        if(l2 == 1) {\\n            dp2[0] = nums[0];\\n        }\\n        \\n        for(int i = 1; i < nums.size(); i++) {\\n            nums[i] += nums[i - 1];\\n            \\n            if(i >= l1 - 1) {\\n                int r1 = nums[i], r2 = (i - l1) >= 0 ? nums[i - l1] : 0;\\n                dp1[i] = max(dp1[i - 1], r1 - r2);\\n            }\\n            \\n            if(i >= l2 - 1) {\\n                int r1 = nums[i], r2 = (i - l2) >= 0 ? nums[i - l2] : 0;\\n                dp2[i] = max(dp2[i - 1], r1 - r2);\\n            }\\n            \\n\\t\\t\\t// Actual answer is max of Case1 and Case2 as shown in the image below:\\n            if(i >= l1 + l2 - 1) {\\n                int m1 = (nums[i] - nums[i - l1]) + dp2[i - l1];\\n                int m2 = (nums[i] - nums[i - l2]) + dp1[i - l2];\\n                \\n                res = max(res, max(m1, m2));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/45f1248b-75c3-44d9-8b7d-1a1991cf07c9_1655338484.914251.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int l1, int l2) {\\n        int n = nums.size(), res = 0;\\n        vector <int> dp1(n, 0), dp2(n, 0);\\n\\t\\t\\n\\t\\t// dp1[i] stores the maximum sub-array sum of len l1 until i\\n\\t\\t// dp2[i] stores the maximum sub-array sum of len l2 until i\\n        \\n        if(l1 == 1) {\\n            dp1[0] = nums[0];\\n        }\\n        if(l2 == 1) {\\n            dp2[0] = nums[0];\\n        }\\n        \\n        for(int i = 1; i < nums.size(); i++) {\\n            nums[i] += nums[i - 1];\\n            \\n            if(i >= l1 - 1) {\\n                int r1 = nums[i], r2 = (i - l1) >= 0 ? nums[i - l1] : 0;\\n                dp1[i] = max(dp1[i - 1], r1 - r2);\\n            }\\n            \\n            if(i >= l2 - 1) {\\n                int r1 = nums[i], r2 = (i - l2) >= 0 ? nums[i - l2] : 0;\\n                dp2[i] = max(dp2[i - 1], r1 - r2);\\n            }\\n            \\n\\t\\t\\t// Actual answer is max of Case1 and Case2 as shown in the image below:\\n            if(i >= l1 + l2 - 1) {\\n                int m1 = (nums[i] - nums[i - l1]) + dp2[i - l1];\\n                int m2 = (nums[i] - nums[i - l2]) + dp1[i - l2];\\n                \\n                res = max(res, max(m1, m2));\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109360,
                "title": "c-o-n-2-no-need-to-use-brain-just-for-openning-mind",
                "content": "--[BBBB----------AAA]--\\n----[AAA-----BBBB]-----\\nAAA: means the first part\\nBBBB: means the second part\\nwe can see both two parts and its innner part as a whole subarray\\nso, two cases:\\n1. ... first .... second ...\\n2. ... second .... first ...\\n\\ntime complexity: O(n^2)\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int n = nums.size();\\n        vector<int> presum(n+1, 0);\\n        for(int i = 1; i <= n; i++){\\n            presum[i] = presum[i-1] + nums[i-1]; // presum[i]: sum of nums[0...i-1]\\n        }\\n        \\n        int ans = 0;\\n        // num[i...j] -- [first...second]\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(j - i + 1 >= firstLen + secondLen){\\n                    // sum1 = [i...i+firstLen - 1]  sum2 = [j-secondLen+1...j]\\n                    ans = max(ans, presum[i+firstLen] - presum[i] + presum[j+1] - presum[j-secondLen + 1]);\\n                    ans = max(ans, presum[i+secondLen] - presum[i] + presum[j+1] - presum[j-firstLen + 1]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nAnd it\\'s time to learn others\\' O(n) solution",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int n = nums.size();\\n        vector<int> presum(n+1, 0);\\n        for(int i = 1; i <= n; i++){\\n            presum[i] = presum[i-1] + nums[i-1]; // presum[i]: sum of nums[0...i-1]\\n        }\\n        \\n        int ans = 0;\\n        // num[i...j] -- [first...second]\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < n; j++){\\n                if(j - i + 1 >= firstLen + secondLen){\\n                    // sum1 = [i...i+firstLen - 1]  sum2 = [j-secondLen+1...j]\\n                    ans = max(ans, presum[i+firstLen] - presum[i] + presum[j+1] - presum[j-secondLen + 1]);\\n                    ans = max(ans, presum[i+secondLen] - presum[i] + presum[j+1] - presum[j-firstLen + 1]);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003024,
                "title": "java-1-ms-beats-95-with-comments",
                "content": "First we\\'ll calculate prefix sum.\\n\\nThen calculate LMax value by considering L at leftmost, M at rightmost and in the next pass vice versa.\\n\\n**By keeping L and M at the ends of the array is what makes the sub-arrays non-overlapping.**\\n\\n```\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int sums[] = new int[A.length+1];\\n        int maxLval = 0;\\n        int maxRval = 0;\\n        int result = 0;\\n        \\n        for(int i=1;i<=A.length;i++)\\n            sums[i] = A[i-1]+sums[i-1];\\n        \\n        //L is at Leftmost, M is at RightMost\\n        for(int i=L;i<=A.length-M;i++)\\n        {\\n            int currLVal = sums[i]-sums[i-L];\\n            int currMVal = sums[i+M]-sums[i];\\n            maxLval = Math.max(maxLval,currLVal);\\n            result = Math.max(result,currMVal+maxLval);\\n        }\\n\\n        //M is at LeftMost, L is at RightMost\\n        for(int i=M;i<=A.length-L;i++)\\n        {\\n            int currMVal = sums[i]-sums[i-M];\\n            int currLVal = sums[i+L]-sums[i];\\n            maxRval = Math.max(maxRval,currMVal);\\n            result = Math.max(result,currLVal+maxRval);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int sums[] = new int[A.length+1];\\n        int maxLval = 0;\\n        int maxRval = 0;\\n        int result = 0;\\n        \\n        for(int i=1;i<=A.length;i++)\\n            sums[i] = A[i-1]+sums[i-1];\\n        \\n        //L is at Leftmost, M is at RightMost\\n        for(int i=L;i<=A.length-M;i++)\\n        {\\n            int currLVal = sums[i]-sums[i-L];\\n            int currMVal = sums[i+M]-sums[i];\\n            maxLval = Math.max(maxLval,currLVal);\\n            result = Math.max(result,currMVal+maxLval);\\n        }\\n\\n        //M is at LeftMost, L is at RightMost\\n        for(int i=M;i<=A.length-L;i++)\\n        {\\n            int currMVal = sums[i]-sums[i-M];\\n            int currLVal = sums[i+L]-sums[i];\\n            maxRval = Math.max(maxRval,currMVal);\\n            result = Math.max(result,currLVal+maxRval);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1933459,
                "title": "easy-c-83-space",
                "content": "```\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n    int i,j,result=0,first,second;\\n    cout<<nums.size();\\n    vector<int> nums_sum(nums.size()+1,0);\\n    for(i=0;i<nums.size();++i) nums_sum[i+1] = nums_sum[i]+nums[i];\\n    int n = nums_sum.size();\\n    --firstLen, --secondLen;\\n    for(i=1; i+firstLen+secondLen+1<n ;++i){\\n\\n        first = nums_sum[i+firstLen]-nums_sum[i-1];\\n        second = 0;\\n        for(j=i+firstLen+1;j<n-secondLen;++j)\\n            second = max(second,nums_sum[j+secondLen]-nums_sum[j-1]);\\n        result = max(result, first+second);\\n        \\n        second = nums_sum[i+secondLen]-nums_sum[i-1];\\n        first = 0;\\n        for(j=i+secondLen+1;j<n-firstLen;++j)\\n            first = max(first,nums_sum[j+firstLen]-nums_sum[j-1]);\\n        result = max(result, first+second);\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nint maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n    int i,j,result=0,first,second;\\n    cout<<nums.size();\\n    vector<int> nums_sum(nums.size()+1,0);\\n    for(i=0;i<nums.size();++i) nums_sum[i+1] = nums_sum[i]+nums[i];\\n    int n = nums_sum.size();\\n    --firstLen, --secondLen;\\n    for(i=1; i+firstLen+secondLen+1<n ;++i){\\n\\n        first = nums_sum[i+firstLen]-nums_sum[i-1];\\n        second = 0;\\n        for(j=i+firstLen+1;j<n-secondLen;++j)\\n            second = max(second,nums_sum[j+secondLen]-nums_sum[j-1]);\\n        result = max(result, first+second);\\n        \\n        second = nums_sum[i+secondLen]-nums_sum[i-1];\\n        first = 0;\\n        for(j=i+secondLen+1;j<n-firstLen;++j)\\n            first = max(first,nums_sum[j+firstLen]-nums_sum[j-1]);\\n        result = max(result, first+second);\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1903590,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity : O(N)***\\n* ***Space Complexity : O(N)***\\n\\n```\\n    int helper(vector<int>& nums, int x, int y)\\n    {\\n        int n = nums.size();\\n        \\n        vector<int> dp1(n, 0);\\n        \\n        vector<int> dp2(n, 0);\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < x)\\n            {\\n                sum += nums[i];\\n                \\n                dp1[i] = sum;\\n            }\\n            else\\n            {\\n                sum += nums[i] - nums[i - x];\\n                \\n                dp1[i] = max(dp1[i - 1], sum);\\n            }\\n        }\\n        \\n        sum = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(i >= n - y)\\n            {\\n                sum += nums[i];\\n                \\n                dp2[i] = sum;\\n            }\\n            else\\n            {\\n                sum += nums[i] - nums[i + y];\\n                \\n                dp2[i] = max(dp2[i + 1], sum);\\n            }\\n        }\\n        \\n        int ans = INT_MIN;\\n        \\n        for(int i = x - 1; i < n - y; i++)\\n        {\\n            ans = max(ans, dp1[i] + dp2[i + 1]);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& nums, int x, int y) {\\n        \\n        int n = nums.size();\\n        \\n        int max1 = helper(nums, x, y);\\n        \\n        int max2 = helper(nums, y, x);\\n        \\n        return max(max1, max2);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\n    int helper(vector<int>& nums, int x, int y)\\n    {\\n        int n = nums.size();\\n        \\n        vector<int> dp1(n, 0);\\n        \\n        vector<int> dp2(n, 0);\\n        \\n        int sum = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(i < x)\\n            {\\n                sum += nums[i];\\n                \\n                dp1[i] = sum;\\n            }\\n            else\\n            {\\n                sum += nums[i] - nums[i - x];\\n                \\n                dp1[i] = max(dp1[i - 1], sum);\\n            }\\n        }\\n        \\n        sum = 0;\\n        \\n        for(int i = n - 1; i >= 0; i--)\\n        {\\n            if(i >= n - y)\\n            {\\n                sum += nums[i];\\n                \\n                dp2[i] = sum;\\n            }\\n            else\\n            {\\n                sum += nums[i] - nums[i + y];\\n                \\n                dp2[i] = max(dp2[i + 1], sum);\\n            }\\n        }\\n        \\n        int ans = INT_MIN;\\n        \\n        for(int i = x - 1; i < n - y; i++)\\n        {\\n            ans = max(ans, dp1[i] + dp2[i + 1]);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& nums, int x, int y) {\\n        \\n        int n = nums.size();\\n        \\n        int max1 = helper(nums, x, y);\\n        \\n        int max2 = helper(nums, y, x);\\n        \\n        return max(max1, max2);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1742418,
                "title": "c-concise-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int len = nums.size();\\n        for (int i = 1; i < len; i++) {\\n            nums[i] += nums[i - 1];\\n        }\\n        int A = getMaxSum(nums, len, firstLen, secondLen);\\n        int B = getMaxSum(nums, len, secondLen, firstLen);\\n        return max(A, B);\\n    }\\n    \\n    int getMaxSum(vector<int> &nums, int &len, int f, int s) {\\n        int maxFirstWindowSum = 0, maxSum = 0;\\n        for (int i = 0; (i + f + s - 1) < len; i++) {\\n            maxFirstWindowSum = max(maxFirstWindowSum, nums[i + f - 1] - (i - 1 >= 0 ? nums[i - 1] : 0));\\n            int secondWindowCurSum = nums[i + f + s - 1] - ((i + f - 1) >= 0 ? nums[i + f - 1] : 0);\\n            maxSum = max(maxSum, maxFirstWindowSum + secondWindowCurSum);\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        int len = nums.size();\\n        for (int i = 1; i < len; i++) {\\n            nums[i] += nums[i - 1];\\n        }\\n        int A = getMaxSum(nums, len, firstLen, secondLen);\\n        int B = getMaxSum(nums, len, secondLen, firstLen);\\n        return max(A, B);\\n    }\\n    \\n    int getMaxSum(vector<int> &nums, int &len, int f, int s) {\\n        int maxFirstWindowSum = 0, maxSum = 0;\\n        for (int i = 0; (i + f + s - 1) < len; i++) {\\n            maxFirstWindowSum = max(maxFirstWindowSum, nums[i + f - 1] - (i - 1 >= 0 ? nums[i - 1] : 0));\\n            int secondWindowCurSum = nums[i + f + s - 1] - ((i + f - 1) >= 0 ? nums[i + f - 1] : 0);\\n            maxSum = max(maxSum, maxFirstWindowSum + secondWindowCurSum);\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716710,
                "title": "100-faster-solution-with-explaination",
                "content": "```\\nclass Solution {\\npublic:\\n    int checker(vector<int>& nums, int f, int s){\\n        int n=nums.size();\\n        vector<int>dp1(n);\\n        vector<int>dp2(n);\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i<f){\\n                sum+=nums[i];\\n                dp1[i]=sum;\\n            }else{\\n                sum+=nums[i]-nums[i-f];\\n                dp1[i]=max(sum,dp1[i-1]);\\n            }\\n        }\\n        sum=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(i+s>=n){\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }else{\\n                sum+=nums[i]-nums[i+s];\\n                dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=f-1;i<n-s;i++){\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int f, int s) {\\n        return max(checker(nums,f,s),checker(nums,s,f));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int checker(vector<int>& nums, int f, int s){\\n        int n=nums.size();\\n        vector<int>dp1(n);\\n        vector<int>dp2(n);\\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(i<f){\\n                sum+=nums[i];\\n                dp1[i]=sum;\\n            }else{\\n                sum+=nums[i]-nums[i-f];\\n                dp1[i]=max(sum,dp1[i-1]);\\n            }\\n        }\\n        sum=0;\\n        for(int i=n-1;i>=0;i--){\\n            if(i+s>=n){\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }else{\\n                sum+=nums[i]-nums[i+s];\\n                dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        int ans=0;\\n        for(int i=f-1;i<n-s;i++){\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int f, int s) {\\n        return max(checker(nums,f,s),checker(nums,s,f));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1621533,
                "title": "python-simple-time-o-n-space-o-1-84-06",
                "content": "Success\\nRuntime: 48 ms, faster than 84.06% of Python3 online submissions for Maximum Sum of Two Non-Overlapping Subarrays.\\nMemory Usage: 14.4 MB, less than 77.76% of Python3 online submissions for Maximum Sum of Two Non-Overlapping Subarrays.\\n\\n```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        # calculate prefix sum\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i-1]\\n        \\n        # for simplicity\\n        f,s = firstLen, secondLen\\n        \\n        # initialization: maxfirst, maxsecond, maxtotal\\n        maxf, maxs, maxt = nums[f-1], nums[s-1], nums[f+s-1]\\n        \\n        for i in range(f+s, len(nums)):\\n            # find the maximum subarray of length f\\n            maxf = max(maxf, nums[i-s] - nums[i-s-f])\\n            # find the maximum subarray of length s\\n            maxs = max(maxs, nums[i-f] - nums[i-f-s])\\n            # find the maximum subarray of length f+s\\n            maxt = max(maxt, \\n                      max(maxf + nums[i]-nums[i-s], maxs + nums[i]-nums[i-f]))\\n        return maxt\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        # calculate prefix sum\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i-1]\\n        \\n        # for simplicity\\n        f,s = firstLen, secondLen\\n        \\n        # initialization: maxfirst, maxsecond, maxtotal\\n        maxf, maxs, maxt = nums[f-1], nums[s-1], nums[f+s-1]\\n        \\n        for i in range(f+s, len(nums)):\\n            # find the maximum subarray of length f\\n            maxf = max(maxf, nums[i-s] - nums[i-s-f])\\n            # find the maximum subarray of length s\\n            maxs = max(maxs, nums[i-f] - nums[i-f-s])\\n            # find the maximum subarray of length f+s\\n            maxt = max(maxt, \\n                      max(maxf + nums[i]-nums[i-s], maxs + nums[i]-nums[i-f]))\\n        return maxt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586003,
                "title": "using-sliding-window-prefix-sum",
                "content": "```\\n\\nint n=a.size(),sum=0;\\n        int dp1[n],dp2[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<f){\\n                sum+=a[i];\\n                dp1[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i-f];\\n                dp1[i]=max(sum,dp1[i-1]);\\n            }\\n        }\\n        sum=0;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+s>=n)\\n            {\\n                sum+=a[i];\\n                dp2[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i+s];\\n                dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        \\n        int ans=INT_MIN;\\n        for(int i=f-1;i<n-s;i++)\\n        {\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        //Case 2.\\n        sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<s){\\n                sum+=a[i];\\n                dp1[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i-s];\\n                dp1[i]=max(sum,dp1[i-1]);\\n            }\\n        }\\n        sum=0;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+f>=n)\\n            {\\n                sum+=a[i];\\n                dp2[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i+f];\\n                dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        \\n        \\n        for(int i=s-1;i<n-f;i++)\\n        {\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        \\n        return ans;",
                "solutionTags": [],
                "code": "```\\n\\nint n=a.size(),sum=0;\\n        int dp1[n],dp2[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<f){\\n                sum+=a[i];\\n                dp1[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i-f];\\n                dp1[i]=max(sum,dp1[i-1]);\\n            }\\n        }\\n        sum=0;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+s>=n)\\n            {\\n                sum+=a[i];\\n                dp2[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i+s];\\n                dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        \\n        int ans=INT_MIN;\\n        for(int i=f-1;i<n-s;i++)\\n        {\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        //Case 2.\\n        sum=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(i<s){\\n                sum+=a[i];\\n                dp1[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i-s];\\n                dp1[i]=max(sum,dp1[i-1]);\\n            }\\n        }\\n        sum=0;\\n        \\n        for(int i=n-1;i>=0;i--)\\n        {\\n            if(i+f>=n)\\n            {\\n                sum+=a[i];\\n                dp2[i]=sum;\\n            }\\n            else\\n            {\\n                sum+=a[i]-a[i+f];\\n                dp2[i]=max(sum,dp2[i+1]);\\n            }\\n        }\\n        \\n        \\n        for(int i=s-1;i<n-f;i++)\\n        {\\n            ans=max(ans,dp1[i]+dp2[i+1]);\\n        }\\n        \\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1443913,
                "title": "python-o-n-beginner-friendly-solution-with-detail-explanation",
                "content": "There\\'re only 2 case:\\n* The First sub-array is on the **left** of the Second sub-array\\n* The First sub-array is on the **right** of the Second sub-array\\n\\nThe idea is to keep track of the maximum of sub_array in the left (from 0 -> i) and in the right (from i to n)\\nFor example: 0  6  5  2  2  5  1  9  4 \\n\\n![image](https://assets.leetcode.com/users/images/e4f01a22-55a0-4855-80ea-c3e9a933dc93_1630762997.5839343.png)\\n\\n\\n\\n* X is on the left of Y\\nResult = **maximum** of (index **i** -> **first_max_left**[i] + **second_max_right**[i+1])\\n* X is on the right of Y\\nResult = **maximum** of (index **i** -> **second_max_left**[i] +  **first_max_right**[i+1])\\n\\n\\n```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        first_max_left = self.sumSubArray(nums, firstLen)\\n        first_max_right = self.sumSubArray(nums, firstLen, reverse=True)\\n        second_max_left = self.sumSubArray(nums, secondLen)\\n        second_max_right = self.sumSubArray(nums, secondLen, reverse=True)\\n        \\n        result = float(\"-inf\")\\n        for i in range(0, len(nums)-1):\\n            result = max(result, first_max_left[i] + second_max_right[i+1], second_max_left[i] + first_max_right[i+1])\\n        return result\\n    \\n    def sumSubArray(self, nums: List[int], k: int, reverse=False):\\n        sum_arr = [float(\"-inf\")] * (k - 1)\\n        arr = nums if not reverse else list(reversed(nums))\\n        cur_sum = sum(arr[:k-1])\\n        max_sum = float(\"-inf\")\\n        i = k - 1\\n        while i < len(arr):\\n            cur_sum += arr[i]\\n            max_sum = max(max_sum, cur_sum)\\n            sum_arr.append(max_sum)\\n            i += 1\\n            cur_sum -= arr[i-k]\\n        return sum_arr if not reverse else list(reversed(sum_arr))\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, nums: List[int], firstLen: int, secondLen: int) -> int:\\n        first_max_left = self.sumSubArray(nums, firstLen)\\n        first_max_right = self.sumSubArray(nums, firstLen, reverse=True)\\n        second_max_left = self.sumSubArray(nums, secondLen)\\n        second_max_right = self.sumSubArray(nums, secondLen, reverse=True)\\n        \\n        result = float(\"-inf\")\\n        for i in range(0, len(nums)-1):\\n            result = max(result, first_max_left[i] + second_max_right[i+1], second_max_left[i] + first_max_right[i+1])\\n        return result\\n    \\n    def sumSubArray(self, nums: List[int], k: int, reverse=False):\\n        sum_arr = [float(\"-inf\")] * (k - 1)\\n        arr = nums if not reverse else list(reversed(nums))\\n        cur_sum = sum(arr[:k-1])\\n        max_sum = float(\"-inf\")\\n        i = k - 1\\n        while i < len(arr):\\n            cur_sum += arr[i]\\n            max_sum = max(max_sum, cur_sum)\\n            sum_arr.append(max_sum)\\n            i += 1\\n            cur_sum -= arr[i-k]\\n        return sum_arr if not reverse else list(reversed(sum_arr))\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1440046,
                "title": "c-easy-to-understand-faster-than-100",
                "content": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int x, int y) {\\n        \\n        int n=nums.size();\\n        \\n        int sum=0;\\n        \\n        vector<int>dp1(n,0);\\n        vector<int>dp2(n,0);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(i<x){\\n                sum+=nums[i];\\n                dp1[i]=sum;\\n            }\\n            \\n            else{\\n                sum+=(nums[i]-nums[i-x]);\\n                dp1[i]=max(dp1[i-1],sum);\\n            }\\n            \\n        }\\n        \\n        sum=0;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            if(i+y>=n){\\n                sum+=nums[i];\\n                dp2[i]=sum;\\n            }\\n            \\n            else{\\n                sum+=(nums[i]-nums[i+y]);\\n                dp2[i]=max(dp2[i+1],sum);\\n            }\\n            \\n        }\\n        \\n        int maxx1=0;\\n        \\n        for(int i=x-1;i<n-y;i++){\\n            maxx1=max(maxx1,dp1[i]+dp2[i+1]);\\n        }\\n        \\n       \\n        \\n        sum=0;\\n        \\n        vector<int>dp3(n,0);\\n        vector<int>dp4(n,0);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(i<y){\\n                sum+=nums[i];\\n                dp3[i]=sum;\\n            }\\n            \\n            else{\\n                sum+=(nums[i]-nums[i-y]);\\n                dp3[i]=max(dp3[i-1],sum);\\n            }\\n            \\n        }\\n        \\n        sum=0;\\n        \\n        for(int i=n-1;i>=0;i--){\\n            \\n            if(i+x>=n){\\n                sum+=nums[i];\\n                dp4[i]=sum;\\n            }\\n            \\n            else{\\n                sum+=(nums[i]-nums[i+x]);\\n                dp4[i]=max(dp4[i+1],sum);\\n            }\\n            \\n        }\\n        \\n        int maxx2=0;\\n        \\n        for(int i=y-1;i<n-x;i++){\\n            maxx2=max(maxx2,dp3[i]+dp4[i+1]);\\n        }\\n        \\n        return max(maxx1,maxx2);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& nums, int x, int y) {\\n        \\n        int n=nums.size();\\n        \\n        int sum=0;\\n        \\n        vector<int>dp1(n,0);\\n        vector<int>dp2(n,0);\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(i<x){\\n                sum+=nums[i];\\n                dp1[i]=sum;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1439956,
                "title": "c-easy-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int a, int b){\\n        int n=nums.size();\\n        vector<int>va(n,0),vb(n,0);\\n        //va[i] stores the maximum sum of subarray of size a till index i (from start)\\n        //vb[i] stores the maximum sum of subarray of size b till index i (from end)\\n        //ans will be the maximum of va[i]+vb[i+1]\\n        int sum=0;\\n        for(int i=0;i<a;i++){\\n            sum+=nums[i];\\n        }\\n        va[a-1]=sum;\\n        for(int i=a;i<n;i++){\\n            sum-=nums[i-a];\\n            sum+=nums[i];\\n            va[i]=max(va[i-1],sum);\\n        }\\n        \\n        sum=0;\\n        for(int i=n-1;i>=n-b;i--){\\n            sum+=nums[i];\\n        }\\n        vb[n-b]=sum;\\n        for(int i=n-b-1;i>=0;i--){\\n            sum-=nums[i+b];\\n            sum+=nums[i];\\n            vb[i]=max(vb[i+1],sum);\\n        }\\n        int ans=0;\\n        for(int i=a-1;i<n-b;i++){\\n            ans=max(ans,va[i]+vb[i+1]);\\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int a, int b) {\\n        int ans=max(solve(nums,a,b),solve(nums,b,a));\\n        return ans; \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& nums, int a, int b){\\n        int n=nums.size();\\n        vector<int>va(n,0),vb(n,0);\\n        //va[i] stores the maximum sum of subarray of size a till index i (from start)\\n        //vb[i] stores the maximum sum of subarray of size b till index i (from end)\\n        //ans will be the maximum of va[i]+vb[i+1]\\n        int sum=0;\\n        for(int i=0;i<a;i++){\\n            sum+=nums[i];\\n        }\\n        va[a-1]=sum;\\n        for(int i=a;i<n;i++){\\n            sum-=nums[i-a];\\n            sum+=nums[i];\\n            va[i]=max(va[i-1],sum);\\n        }\\n        \\n        sum=0;\\n        for(int i=n-1;i>=n-b;i--){\\n            sum+=nums[i];\\n        }\\n        vb[n-b]=sum;\\n        for(int i=n-b-1;i>=0;i--){\\n            sum-=nums[i+b];\\n            sum+=nums[i];\\n            vb[i]=max(vb[i+1],sum);\\n        }\\n        int ans=0;\\n        for(int i=a-1;i<n-b;i++){\\n            ans=max(ans,va[i]+vb[i+1]);\\n        }\\n        return ans;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int a, int b) {\\n        int ans=max(solve(nums,a,b),solve(nums,b,a));\\n        return ans; \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421606,
                "title": "javascript-window-with-comments",
                "content": "*** an outer while loop to find sum of values for firstLen - once that length is found slice the nums array and feed that new array into a nested while loop to find the sum of values for secondLen. Combine those values to find largest sum with no overlap\\n\\n```\\nvar maxSumTwoNoOverlap = function(nums, firstLen, secondLen) {\\n\\n    return helper(nums, firstLen, secondLen);\\n\\n};\\n\\nlet helper = function(nums, firstLen, secondLen){\\n\\n    let outerLeft = 0;\\n    \\n    let outerRight  = 0;\\n    \\n    let outerLoopSum = 0;\\n    \\n    let combinedSum = 0;\\n    \\n    while(outerRight < nums.length){\\n        \\n        outerLoopSum += nums[outerRight];\\n        \\n        if(outerRight - outerLeft + 1 === firstLen){\\n            \\n            let firstNum = nums.slice(0, outerLeft);\\n            let secondNum = nums.slice(outerRight + 1);\\n            let combinedNum = firstNum.concat(secondNum);\\n            \\n            let innerLeft = 0;\\n    \\n            let innerRight = 0;\\n            \\n            let innerLoopSum = 0;\\n            \\n            while(innerRight < combinedNum.length) {\\n                \\n                innerLoopSum += combinedNum[innerRight];\\n                \\n                if(innerRight - innerLeft + 1 === secondLen){\\n                    \\n                    combinedSum = Math.max(combinedSum, outerLoopSum + innerLoopSum);\\n                    \\n                    innerLoopSum-= combinedNum[innerLeft];\\n                    \\n                    innerLeft++;\\n                }\\n                \\n                innerRight++;\\n             }\\n    \\n            outerLoopSum -= nums[outerLeft];\\n            \\n            outerLeft++;\\n        }\\n        outerRight++;\\n    }\\n    \\n    return combinedSum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxSumTwoNoOverlap = function(nums, firstLen, secondLen) {\\n\\n    return helper(nums, firstLen, secondLen);\\n\\n};\\n\\nlet helper = function(nums, firstLen, secondLen){\\n\\n    let outerLeft = 0;\\n    \\n    let outerRight  = 0;\\n    \\n    let outerLoopSum = 0;\\n    \\n    let combinedSum = 0;\\n    \\n    while(outerRight < nums.length){\\n        \\n        outerLoopSum += nums[outerRight];\\n        \\n        if(outerRight - outerLeft + 1 === firstLen){\\n            \\n            let firstNum = nums.slice(0, outerLeft);\\n            let secondNum = nums.slice(outerRight + 1);\\n            let combinedNum = firstNum.concat(secondNum);\\n            \\n            let innerLeft = 0;\\n    \\n            let innerRight = 0;\\n            \\n            let innerLoopSum = 0;\\n            \\n            while(innerRight < combinedNum.length) {\\n                \\n                innerLoopSum += combinedNum[innerRight];\\n                \\n                if(innerRight - innerLeft + 1 === secondLen){\\n                    \\n                    combinedSum = Math.max(combinedSum, outerLoopSum + innerLoopSum);\\n                    \\n                    innerLoopSum-= combinedNum[innerLeft];\\n                    \\n                    innerLeft++;\\n                }\\n                \\n                innerRight++;\\n             }\\n    \\n            outerLoopSum -= nums[outerLeft];\\n            \\n            outerLeft++;\\n        }\\n        outerRight++;\\n    }\\n    \\n    return combinedSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1309475,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(int x1, int x2, int y1, int y2) {\\n  return (x1 >= y1 && x1 <= y2) ||\\n         (x2 >= y1 && x2 <= y2) ||\\n         (y1 >= x1 && y1 <= x2) ||\\n         (y2 >= x1 && y2 <= x2);\\n}\\n    int maxSumTwoNoOverlap(vector<int>& a, int f, int s) {\\n        int n = a.size();\\n        vector<int>pre1(n-f+1 , 0 ) ;\\n        vector<int>pre2(n-s+1 , 0) ; \\n        \\n        int sum = 0;\\n        for(int i = 0; i < f;i++)\\n         sum+=a[i];\\n        pre1[0] = sum;\\n        \\n        // fill the prefix sum\\n        int k = 1 ;\\n        for(int i = f , j = 0 ; i < n ;i++,j++)\\n        {\\n            \\n            pre1[k] = pre1[k-1] + a[i] - a[j];\\n            k++;\\n        }\\n        // fill the prefix array for len second\\n        sum = 0 ; k = 1 ;\\n        for(int i = 0 ; i < s;i++)\\n            sum+=a[i];\\n        pre2[0]  = sum ;\\n        \\n        for(int i = s , j = 0 ; i < n ; i++,j++)\\n        {\\n            \\n            pre2[k] = pre2[k-1] + a[i] - a[j];\\n            k++;\\n        }\\n        \\n        // now iterate in o(n^2)\\n        int ans = 0 ;\\n        for(int i = 0 ; i < pre1.size();i++)\\n        {\\n            int f1 = i ;\\n            int f2 = i + f - 1;\\n            for(int j = 0 ;j < pre2.size() ;j++)\\n            {\\n                int s1 = j ;\\n                int s2 = j + s - 1;\\n                if(check(f1 , f2 , s1 , s2) == false)\\n                {\\n                    int r = pre1[i] + pre2[j];\\n                    ans  =  max(ans , r);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool check(int x1, int x2, int y1, int y2) {\\n  return (x1 >= y1 && x1 <= y2) ||\\n         (x2 >= y1 && x2 <= y2) ||\\n         (y1 >= x1 && y1 <= x2) ||\\n         (y2 >= x1 && y2 <= x2);\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1259484,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n   \\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n     \\n      int n=A.size();\\n      int pre[n];\\n      pre[0]=A[0];\\n      //prefix sum\\n      for(int i=1;i<n;i++){\\n        pre[i]=pre[i-1]+A[i];\\n      }\\n      int ans=0;\\n      pair<int,int> dp[n];\\n      \\n      \\n      for(int i=0;i<n;i++){\\n        // for each index check left subarrays with len= L and len=M\\n        if(i+1>=L){\\n          if(i+1==L){\\n           dp[i].first= pre[i];\\n            }else{\\n            dp[i].first= pre[i]-pre[i-L];\\n          }\\n          //calculating answer\\n          if(i+1>L){\\n          ans =max(ans, pre[i]-pre[i-L]+ dp[i-L].second);\\n            }\\n        }\\n        \\n        if(i+1>=M){\\n          \\n           if(i+1==M){\\n            dp[i].second= pre[i];\\n            }else{\\n            dp[i].second= pre[i]-pre[i-M];\\n          }\\n          \\n          if(i+1>M){\\n            ans =max( ans,pre[i]-pre[i-M]+ dp[i-M].first);\\n          } \\n        }\\n        \\n        if(i>0){\\n          \\n         dp[i].first= max(dp[i-1].first,dp[i].first);\\n         dp[i].second= max(dp[i-1].second,dp[i].second);\\n        \\n          }\\n        \\n      }\\n      \\n      return ans;\\n      \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n     \\n      int n=A.size();\\n      int pre[n];\\n      pre[0]=A[0];\\n      //prefix sum\\n      for(int i=1;i<n;i++){\\n        pre[i]=pre[i-1]+A[i];\\n      }\\n      int ans=0;\\n      pair<int,int> dp[n];\\n      \\n      \\n      for(int i=0;i<n;i++){\\n        // for each index check left subarrays with len= L and len=M\\n        if(i+1>=L){\\n          if(i+1==L){\\n           dp[i].first= pre[i];\\n            }else{\\n            dp[i].first= pre[i]-pre[i-L];\\n          }\\n          //calculating answer\\n          if(i+1>L){\\n          ans =max(ans, pre[i]-pre[i-L]+ dp[i-L].second);\\n            }\\n        }\\n        \\n        if(i+1>=M){\\n          \\n           if(i+1==M){\\n            dp[i].second= pre[i];\\n            }else{\\n            dp[i].second= pre[i]-pre[i-M];\\n          }\\n          \\n          if(i+1>M){\\n            ans =max( ans,pre[i]-pre[i-M]+ dp[i-M].first);\\n          } \\n        }\\n        \\n        if(i>0){\\n          \\n         dp[i].first= max(dp[i-1].first,dp[i].first);\\n         dp[i].second= max(dp[i-1].second,dp[i].second);\\n        \\n          }\\n        \\n      }\\n      \\n      return ans;\\n      \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1186455,
                "title": "c-o-n-complexity",
                "content": "```\\n//we always considering Lmax is left on Mmax in maxsum func.\\n//but in case of maxSumTwoNoOverlap we find the values via interchanging L and M this will help us to calculate the max sum wheater the L-length subarray could occur before or after the M-length subarray.\\n\\n//the initution behind this quetion is little bit of tricky ;)\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n=A.size();\\n        vector<int> psum(n+1,0);\\n        for(int i=0;i<n;i++)\\n            psum[i+1]=psum[i]+A[i];\\n        return max(maxsum(psum,L,M),maxsum(psum,M,L) );\\n    }\\n    int maxsum(vector<int>& pre,int L ,int M){\\n        int sumL=0,ans=0;\\n        for(int i=L+M;i<pre.size();i++){\\n            sumL=max(sumL,pre[i-M]-pre[i-L-M]);\\n            ans=max(ans,sumL+pre[i]-pre[i-M]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//we always considering Lmax is left on Mmax in maxsum func.\\n//but in case of maxSumTwoNoOverlap we find the values via interchanging L and M this will help us to calculate the max sum wheater the L-length subarray could occur before or after the M-length subarray.\\n\\n//the initution behind this quetion is little bit of tricky ;)\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n=A.size();\\n        vector<int> psum(n+1,0);\\n        for(int i=0;i<n;i++)\\n            psum[i+1]=psum[i]+A[i];\\n        return max(maxsum(psum,L,M),maxsum(psum,M,L) );\\n    }\\n    int maxsum(vector<int>& pre,int L ,int M){\\n        int sumL=0,ans=0;\\n        for(int i=L+M;i<pre.size();i++){\\n            sumL=max(sumL,pre[i-M]-pre[i-L-M]);\\n            ans=max(ans,sumL+pre[i]-pre[i-M]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1156926,
                "title": "c-recursive-dp-approach",
                "content": "**There is a better iterative solution , But why not try this recursively. Code is lengthy but easy\\nRuntime : 0-4 ms**\\n//Mtaken - true means we\\'ve got a subarray of length m\\n//Ltaken - true means we\\'ve got a subarray of length l\\n```\\nclass Solution {\\npublic:\\n    int dp[1001][2][2];\\n    int solve(vector<int> &ar, int i, bool Ltaken, bool Mtaken, int l, int m) {\\n        if(Ltaken && Mtaken) return 0;\\n\\n        if(i >= ar.size() || i+l >= ar.size() && !Ltaken || i+m >= ar.size() && !Mtaken) return -10e4;\\n\\n        if(dp[i][Ltaken][Mtaken]!=-1) return dp[i][Ltaken][Mtaken];\\n        \\n        if(Ltaken && i+m < ar.size())\\n        return dp[i][Ltaken][Mtaken] = max(solve(ar,i+m+1,Ltaken,true,l,m)+(ar[i+m]-ar[i-1]), solve(ar, i+1, Ltaken,Mtaken,l, m));\\n        else if(Mtaken && i+l < ar.size())\\n        return dp[i][Ltaken][Mtaken] = max(solve(ar,i+l+1,true,Mtaken,l, m)+(ar[i+l]-ar[i-1]), solve(ar, i+1,Ltaken,Mtaken, l, m));\\n        else\\n        return dp[i][Ltaken][Mtaken] = max({\\n            solve(ar, i+l+1,true,Mtaken, l, m)+(ar[i+l]-ar[i-1]),\\n            solve(ar, i+m+1,Ltaken,true, l, m)+(ar[i+m]-ar[i-1]),\\n            solve(ar,i+1,Ltaken,Mtaken,l,m)});\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& ar, int l, int m) {\\n        vector<int> prefix{0};\\n        int sum=0;\\n        for(int i:ar) sum+=i, prefix.push_back(sum);\\n\\n        memset(dp,-1,sizeof dp);\\n        return solve(prefix,1,false,false,l-1,m-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[1001][2][2];\\n    int solve(vector<int> &ar, int i, bool Ltaken, bool Mtaken, int l, int m) {\\n        if(Ltaken && Mtaken) return 0;\\n\\n        if(i >= ar.size() || i+l >= ar.size() && !Ltaken || i+m >= ar.size() && !Mtaken) return -10e4;\\n\\n        if(dp[i][Ltaken][Mtaken]!=-1) return dp[i][Ltaken][Mtaken];\\n        \\n        if(Ltaken && i+m < ar.size())\\n        return dp[i][Ltaken][Mtaken] = max(solve(ar,i+m+1,Ltaken,true,l,m)+(ar[i+m]-ar[i-1]), solve(ar, i+1, Ltaken,Mtaken,l, m));\\n        else if(Mtaken && i+l < ar.size())\\n        return dp[i][Ltaken][Mtaken] = max(solve(ar,i+l+1,true,Mtaken,l, m)+(ar[i+l]-ar[i-1]), solve(ar, i+1,Ltaken,Mtaken, l, m));\\n        else\\n        return dp[i][Ltaken][Mtaken] = max({\\n            solve(ar, i+l+1,true,Mtaken, l, m)+(ar[i+l]-ar[i-1]),\\n            solve(ar, i+m+1,Ltaken,true, l, m)+(ar[i+m]-ar[i-1]),\\n            solve(ar,i+1,Ltaken,Mtaken,l,m)});\\n    }\\n    \\n    int maxSumTwoNoOverlap(vector<int>& ar, int l, int m) {\\n        vector<int> prefix{0};\\n        int sum=0;\\n        for(int i:ar) sum+=i, prefix.push_back(sum);\\n\\n        memset(dp,-1,sizeof dp);\\n        return solve(prefix,1,false,false,l-1,m-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1085686,
                "title": "c-greedy-algorithm-solution-using-sliding-window",
                "content": "1. Setup a accumulative sum array (accum[i]):\\n - The problem is asking for the maximum sum of two non-overlapping subarray that each has a fixed length. This means we will need to frequently calculate the sum for given range of a subarray.\\nTherefore a accumulative sum array can reduce time complexity when calculating subarray sum, and also, we reuse the input array to store accumulative sum to reduce space complexity.\\n\\n2. Apply L+M-Length Sliding Windows:\\nInitaily, we spilt the sliding window into two subwindow:\\n- \"L -length left window\"\\n- \"M-length right window\"\\n\\n3. Greedy Algoruthm\\nWhen the sliding window run through the \"accum\" array, we always keep track of the maximum sum of left window and add it with the sum of right windows which ends at current index i.\\n\\n- Above operation guarantees left window  with maximum sum doesn\\'t overlapp with right window.\\n- But it only calculates the result in the case of left window size is L.\\n\\n4. Back to Step #2, this time, we swap the window size, that is, left window size is M, right window size is L, to get the result when left window size is M.\\n\\nKeep track of the maximum sum in step #2 & #4 which would is the answer.\\n\\n\\n```\\nfor(int i = 1 ; i < A.size(); i++)\\n            A[i] += A[i - 1];\\n        int L_max = INT_MIN;\\n        int M_max = INT_MIN;\\n        int ret = INT_MIN;\\n        \\n        for(int i = L + M - 1; i < A.size(); i++) {\\n            int L_sum = (i == L + M - 1) ? (A[i - M]) : ( A[i - M] - A[i - L - M]);\\n            L_max = max(L_max, L_sum);\\n            ret = max(ret, L_max + A[i] - A[i - M]);\\n            \\n            int M_sum = (i == L + M - 1) ? (A[i - L]) : ( A[i - L] - A[i - L - M]);\\n            M_max = max(M_max, M_sum);\\n            ret = max(ret, M_max + A[i] - A[i - L]);\\n        }\\n        return ret;\\n```",
                "solutionTags": [],
                "code": "```\\nfor(int i = 1 ; i < A.size(); i++)\\n            A[i] += A[i - 1];\\n        int L_max = INT_MIN;\\n        int M_max = INT_MIN;\\n        int ret = INT_MIN;\\n        \\n        for(int i = L + M - 1; i < A.size(); i++) {\\n            int L_sum = (i == L + M - 1) ? (A[i - M]) : ( A[i - M] - A[i - L - M]);\\n            L_max = max(L_max, L_sum);\\n            ret = max(ret, L_max + A[i] - A[i - M]);\\n            \\n            int M_sum = (i == L + M - 1) ? (A[i - L]) : ( A[i - L] - A[i - L - M]);\\n            M_max = max(M_max, M_sum);\\n            ret = max(ret, M_max + A[i] - A[i - L]);\\n        }\\n        return ret;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1036499,
                "title": "c-dp-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        // DP: let dpl[i] be the maximum sum of length L for the subarray ending at i,\\n        // and dpm[i] be the maximum sum of length M for the subarray ending at index i,\\n        // dp[i] be the maximum sum of considering both L and M for the subarray ending at i.\\n        // We need to calculate dpl and dpm first in order to get dp[i].\\n        int size = A.size();\\n        vector<int> dpl(size + 1, 0), dpm(size + 1, 0), dp(size + 1, 0);\\n        \\n        // calculate dpl\\n        for (int i = L - 1; i < size; ++i)\\n        {\\n            int sum = accumulate(A.begin() + i - L + 1, A.begin() + i + 1, 0);\\n            dpl[i + 1] = sum > dpl[i] ? sum : dpl[i];\\n        }\\n        \\n        // calculate dpm\\n        for (int i = M - 1; i < size; ++i)\\n        {\\n\\n            int sum = accumulate(A.begin() + i - M + 1, A.begin() + i + 1, 0);\\n            dpm[i + 1] = sum > dpm[i] ? sum : dpm[i];\\n        }\\n        \\n        // calculate dp\\n        for (int i = L + M - 1; i < size; ++i)\\n        {\\n            int sum1 = accumulate(A.begin() + i - L + 1, A.begin() + i + 1, 0) + dpm[i - L + 1];\\n            int sum2 = accumulate(A.begin() + i - M + 1, A.begin() + i + 1, 0) + dpl[i - M + 1];\\n            dp[i + 1] = sum1 > sum2 ? sum1 : sum2;\\n            dp[i + 1] = dp[i + 1] > dp[i] ? dp[i + 1] : dp[i];\\n        }\\n        \\n        return dp[size];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        // DP: let dpl[i] be the maximum sum of length L for the subarray ending at i,\\n        // and dpm[i] be the maximum sum of length M for the subarray ending at index i,\\n        // dp[i] be the maximum sum of considering both L and M for the subarray ending at i.\\n        // We need to calculate dpl and dpm first in order to get dp[i].\\n        int size = A.size();\\n        vector<int> dpl(size + 1, 0), dpm(size + 1, 0), dp(size + 1, 0);\\n        \\n        // calculate dpl\\n        for (int i = L - 1; i < size; ++i)\\n        {\\n            int sum = accumulate(A.begin() + i - L + 1, A.begin() + i + 1, 0);\\n            dpl[i + 1] = sum > dpl[i] ? sum : dpl[i];\\n        }\\n        \\n        // calculate dpm\\n        for (int i = M - 1; i < size; ++i)\\n        {\\n\\n            int sum = accumulate(A.begin() + i - M + 1, A.begin() + i + 1, 0);\\n            dpm[i + 1] = sum > dpm[i] ? sum : dpm[i];\\n        }\\n        \\n        // calculate dp\\n        for (int i = L + M - 1; i < size; ++i)\\n        {\\n            int sum1 = accumulate(A.begin() + i - L + 1, A.begin() + i + 1, 0) + dpm[i - L + 1];\\n            int sum2 = accumulate(A.begin() + i - M + 1, A.begin() + i + 1, 0) + dpl[i - M + 1];\\n            dp[i + 1] = sum1 > sum2 ? sum1 : sum2;\\n            dp[i + 1] = dp[i + 1] > dp[i] ? dp[i + 1] : dp[i];\\n        }\\n        \\n        return dp[size];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 867712,
                "title": "easy-o-n-js-solution",
                "content": "```\\nvar maxSumTwoNoOverlap = function(A, L, M) {\\n    return Math.max(traverse(L,M), traverse(M,L));\\n    \\n    function traverse(a, b) {\\n        let res = 0;\\n        for (let i = 0; i <= A.length-a-b; i++) {\\n            let sum = A.slice(i,i+a+b).reduce((acc,cur) => acc+cur);\\n            let l = i+a, r = l+b;\\n            res = Math.max(res, sum);\\n            while (r < A.length) {\\n                sum = sum-A[l]+A[r];\\n                res = Math.max(res, sum)\\n                l++, r++;\\n            }\\n        }\\n        return res;\\n    }\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxSumTwoNoOverlap = function(A, L, M) {\\n    return Math.max(traverse(L,M), traverse(M,L));\\n    \\n    function traverse(a, b) {\\n        let res = 0;\\n        for (let i = 0; i <= A.length-a-b; i++) {\\n            let sum = A.slice(i,i+a+b).reduce((acc,cur) => acc+cur);\\n            let l = i+a, r = l+b;\\n            res = Math.max(res, sum);\\n            while (r < A.length) {\\n                sum = sum-A[l]+A[r];\\n                res = Math.max(res, sum)\\n                l++, r++;\\n            }\\n        }\\n        return res;\\n    }\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 780707,
                "title": "c-faster-than-99-12-less-then-99-12-mem-o-n",
                "content": "Runtime: 88 ms\\nMemory Usage: 24.4 MB\\n```\\n    public int MaxSumTwoNoOverlap(int[] A, int L, int M) {\\n        \\n        return Math.Max(MaxValue(A, L, M), MaxValue(A, M, L));\\n    }\\n    \\n    private int MaxValue(int[] A, int L, int M)\\n    {\\n        int[] dpL = MaxSumLeftToRight(A, L);\\n        int[] dpM = MaxSumRightToLeft(A, M);\\n        \\n        int result = 0;\\n        \\n        for(int i=L-1; i < A.Length-M; i++)\\n        {\\n            if (result < dpL[i] + dpM[i+1])\\n            {\\n                result = dpL[i] + dpM[i+1];\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int[] MaxSumLeftToRight(int[] A, int L)\\n    {\\n        int[] dp = new int[A.Length];\\n        int count = 0;\\n        \\n        for(int i=0; i< L-1; i++)\\n        {\\n            count += A[i];            \\n        }\\n        \\n        for(int i=L-1; i < A.Length; i++)\\n        {\\n            count += A[i];\\n            dp[i] = (i>0)? Math.Max(dp[i-1], count): count;\\n            count -= A[i-L+1];            \\n        }\\n        return dp;\\n    }\\n    \\n    private int[] MaxSumRightToLeft(int[] A, int L)\\n    {\\n        int[] dp = new int[A.Length];\\n        int count = 0;\\n        \\n        for(int i=A.Length-1; i > A.Length-L; i--)\\n        {\\n            count += A[i];            \\n        }\\n        \\n        for(int i=A.Length-L; i >=0; i--)\\n        {\\n            count += A[i];\\n            dp[i] = (i < A.Length-1)? Math.Max(dp[i+1], count): count;\\n            count -= A[i+L-1];            \\n        }\\n        return dp;\\n    }",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "Runtime: 88 ms\\nMemory Usage: 24.4 MB\\n```\\n    public int MaxSumTwoNoOverlap(int[] A, int L, int M) {\\n        \\n        return Math.Max(MaxValue(A, L, M), MaxValue(A, M, L));\\n    }\\n    \\n    private int MaxValue(int[] A, int L, int M)\\n    {\\n        int[] dpL = MaxSumLeftToRight(A, L);\\n        int[] dpM = MaxSumRightToLeft(A, M);\\n        \\n        int result = 0;\\n        \\n        for(int i=L-1; i < A.Length-M; i++)\\n        {\\n            if (result < dpL[i] + dpM[i+1])\\n            {\\n                result = dpL[i] + dpM[i+1];\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    private int[] MaxSumLeftToRight(int[] A, int L)\\n    {\\n        int[] dp = new int[A.Length];\\n        int count = 0;\\n        \\n        for(int i=0; i< L-1; i++)\\n        {\\n            count += A[i];            \\n        }\\n        \\n        for(int i=L-1; i < A.Length; i++)\\n        {\\n            count += A[i];\\n            dp[i] = (i>0)? Math.Max(dp[i-1], count): count;\\n            count -= A[i-L+1];            \\n        }\\n        return dp;\\n    }\\n    \\n    private int[] MaxSumRightToLeft(int[] A, int L)\\n    {\\n        int[] dp = new int[A.Length];\\n        int count = 0;\\n        \\n        for(int i=A.Length-1; i > A.Length-L; i--)\\n        {\\n            count += A[i];            \\n        }\\n        \\n        for(int i=A.Length-L; i >=0; i--)\\n        {\\n            count += A[i];\\n            dp[i] = (i < A.Length-1)? Math.Max(dp[i+1], count): count;\\n            count -= A[i+L-1];            \\n        }\\n        return dp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 766097,
                "title": "c-simple-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void f(vector<int>&ll, vector<int>& lr, int L, const vector<int>& sum) {\\n        ll[L-1] = sum[L-1];\\n        for(int i = L;i<sum.size();i++) {\\n            ll[i] = sum[i] - sum[i-L];\\n            ll[i] = max(ll[i],ll[i-1]);\\n        }\\n        lr[sum.size()-L] = sum.back() - ((sum.size()>L)?sum[sum.size()-L-1]:0);\\n        for(int i = sum.size()-L-1;i>=0;i--){\\n            lr[i] = sum[i+L-1] - ((i-1>=0)?sum[i-1]:0);\\n            lr[i] = max(lr[i],lr[i+1]);\\n        }\\n    } \\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        vector<int> sum(A.size(),0);\\n        sum[0] = A[0];\\n        for(int i = 1;i < A.size();i++) {\\n            sum[i] = sum[i-1] + A[i];\\n        }\\n        vector<int> ll(A.size(),0), lr(A.size(),0),ml(A.size(),0),mr(A.size(),0);\\n        f(ll,lr,L,sum);\\n        f(ml,mr,M,sum);\\n        int ret = 0;\\n        for(int i = 0;i<A.size()-1;i++) {\\n            ret = max(ret,ll[i] + mr[i+1]);\\n            ret = max(ret,ml[i] + lr[i+1]);\\n        }\\n        return ret; \\n        \\n       \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void f(vector<int>&ll, vector<int>& lr, int L, const vector<int>& sum) {\\n        ll[L-1] = sum[L-1];\\n        for(int i = L;i<sum.size();i++) {\\n            ll[i] = sum[i] - sum[i-L];\\n            ll[i] = max(ll[i],ll[i-1]);\\n        }\\n        lr[sum.size()-L] = sum.back() - ((sum.size()>L)?sum[sum.size()-L-1]:0);\\n        for(int i = sum.size()-L-1;i>=0;i--){\\n            lr[i] = sum[i+L-1] - ((i-1>=0)?sum[i-1]:0);\\n            lr[i] = max(lr[i],lr[i+1]);\\n        }\\n    } \\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        vector<int> sum(A.size(),0);\\n        sum[0] = A[0];\\n        for(int i = 1;i < A.size();i++) {\\n            sum[i] = sum[i-1] + A[i];\\n        }\\n        vector<int> ll(A.size(),0), lr(A.size(),0),ml(A.size(),0),mr(A.size(),0);\\n        f(ll,lr,L,sum);\\n        f(ml,mr,M,sum);\\n        int ret = 0;\\n        for(int i = 0;i<A.size()-1;i++) {\\n            ret = max(ret,ll[i] + mr[i+1]);\\n            ret = max(ret,ml[i] + lr[i+1]);\\n        }\\n        return ret; \\n        \\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761119,
                "title": "java-o-n-solution",
                "content": "Solution below uses these steps:\\n1. Calculate the sums for L and M and save them in array\\n2. Find max sum such that max L sum is on the left side and max R sum is on the right side of the orig array\\n3. Find max sum such that max R sum is on the left side and max L sum is on the right side of the orig array\\n\\n```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // calculate L sums and M sums\\n        int n = A.length, lSum = 0, mSum = 0;\\n        int[] lSumArr = new int[n];\\n        int[] mSumArr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            lSum += A[i];\\n            if (i == L - 1) {\\n                lSumArr[i] = lSum;\\n            } else if (i >= L) {\\n                lSum -= A[i - L];\\n                lSumArr[i] = lSum;\\n            }\\n            \\n            mSum += A[i];\\n            if (i == M - 1) {\\n                mSumArr[i] = mSum;\\n            } else if (i >= M) {\\n                mSum -= A[i - M];\\n                mSumArr[i] = mSum;\\n            }\\n        }\\n        \\n        // keep a max-stack for M\\n        Deque<Integer> maxStack = new ArrayDeque<>();\\n        for (int i = n - 1; i >= L + M - 1; i--) {\\n            if (maxStack.isEmpty() || maxStack.peekFirst() <= mSumArr[i]) {\\n                maxStack.offerFirst(mSumArr[i]);\\n            }\\n        }\\n        \\n        // L goes left -> right and M goes left <- right\\n        int max = 0, maxL = 0, maxM = 0;\\n        for (int i = L - 1; i < n - M; i++) {\\n            maxL = Math.max(maxL, lSumArr[i]);\\n            maxM = maxStack.peekFirst();\\n            max = Math.max(max, maxL + maxM);\\n            if (mSumArr[i + M] == maxStack.peekFirst()) {\\n                maxStack.pollFirst();\\n            }\\n        }\\n        \\n        // keep a max-stack for L\\n        for (int i = n - 1; i >= L + M - 1; i--) {\\n            if (maxStack.isEmpty() || maxStack.peekFirst() <= lSumArr[i]) {\\n                maxStack.offerFirst(lSumArr[i]);\\n            }\\n        }\\n        \\n        // M goes left -> right and L goes left <- right\\n        maxL = 0;\\n        maxM = 0;\\n        for (int i = M - 1; i < n - L; i++) {\\n            maxL = maxStack.peekFirst();\\n            maxM = Math.max(maxM, mSumArr[i]);\\n            max = Math.max(max, maxL + maxM);\\n            if (lSumArr[i + L] == maxStack.peekFirst()) {\\n                maxStack.pollFirst();\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // calculate L sums and M sums\\n        int n = A.length, lSum = 0, mSum = 0;\\n        int[] lSumArr = new int[n];\\n        int[] mSumArr = new int[n];\\n        for (int i = 0; i < n; i++) {\\n            lSum += A[i];\\n            if (i == L - 1) {\\n                lSumArr[i] = lSum;\\n            } else if (i >= L) {\\n                lSum -= A[i - L];\\n                lSumArr[i] = lSum;\\n            }\\n            \\n            mSum += A[i];\\n            if (i == M - 1) {\\n                mSumArr[i] = mSum;\\n            } else if (i >= M) {\\n                mSum -= A[i - M];\\n                mSumArr[i] = mSum;\\n            }\\n        }\\n        \\n        // keep a max-stack for M\\n        Deque<Integer> maxStack = new ArrayDeque<>();\\n        for (int i = n - 1; i >= L + M - 1; i--) {\\n            if (maxStack.isEmpty() || maxStack.peekFirst() <= mSumArr[i]) {\\n                maxStack.offerFirst(mSumArr[i]);\\n            }\\n        }\\n        \\n        // L goes left -> right and M goes left <- right\\n        int max = 0, maxL = 0, maxM = 0;\\n        for (int i = L - 1; i < n - M; i++) {\\n            maxL = Math.max(maxL, lSumArr[i]);\\n            maxM = maxStack.peekFirst();\\n            max = Math.max(max, maxL + maxM);\\n            if (mSumArr[i + M] == maxStack.peekFirst()) {\\n                maxStack.pollFirst();\\n            }\\n        }\\n        \\n        // keep a max-stack for L\\n        for (int i = n - 1; i >= L + M - 1; i--) {\\n            if (maxStack.isEmpty() || maxStack.peekFirst() <= lSumArr[i]) {\\n                maxStack.offerFirst(lSumArr[i]);\\n            }\\n        }\\n        \\n        // M goes left -> right and L goes left <- right\\n        maxL = 0;\\n        maxM = 0;\\n        for (int i = M - 1; i < n - L; i++) {\\n            maxL = maxStack.peekFirst();\\n            maxM = Math.max(maxM, mSumArr[i]);\\n            max = Math.max(max, maxL + maxM);\\n            if (lSumArr[i + L] == maxStack.peekFirst()) {\\n                maxStack.pollFirst();\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718148,
                "title": "python-brute-force",
                "content": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        res = float(\\'-inf\\')\\n        \\n        currMaxL, currMaxM = 0, 0\\n        i = 0\\n        max_M_For_CurrL = float(\\'-inf\\')\\n        while i < len(A):\\n            if i >= L:  # if subarray size is bigger than L, slide window to right\\n                currMaxL -= A[i-L] \\n            currMaxL += A[i] # add current item\\n            \\n            j = i - L # start subArray of size M only after considering first L items\\n            if j >= 0:\\n                currMaxM += A[j]\\n            \\n            if j >= M-1: \\n                max_M_For_CurrL = max(max_M_For_CurrL, currMaxM)\\n                currMaxM -= A[j-M+1] # slide window\\n                \\n                res = max(res, currMaxL + max_M_For_CurrL)\\n            \\n            i += 1\\n        \\n        currMaxL, currMaxM = 0, 0\\n        max_L_For_CurrM = float(\\'-inf\\')\\n        i = 0\\n        while i < len(A):\\n            if i >= M:     # if subarray size is bigger than M, slide window to right\\n                currMaxM -= A[i-M]\\n            currMaxM += A[i] # add current item\\n            \\n            j = i - M # start subArray of size L only after considering first M items\\n            if j >= 0:\\n                currMaxL += A[j]\\n            \\n            if j >= L-1: \\n                max_L_For_CurrM = max(max_L_For_CurrM, currMaxL)\\n                currMaxL -= A[j-L+1] # slide window\\n                \\n                res = max(res, currMaxM + max_L_For_CurrM)\\n            \\n            i += 1\\n        \\n        return res\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        res = float(\\'-inf\\')\\n        \\n        currMaxL, currMaxM = 0, 0\\n        i = 0\\n        max_M_For_CurrL = float(\\'-inf\\')\\n        while i < len(A):\\n            if i >= L:  # if subarray size is bigger than L, slide window to right\\n                currMaxL -= A[i-L] \\n            currMaxL += A[i] # add current item\\n            \\n            j = i - L # start subArray of size M only after considering first L items\\n            if j >= 0:\\n                currMaxM += A[j]\\n            \\n            if j >= M-1: \\n                max_M_For_CurrL = max(max_M_For_CurrL, currMaxM)\\n                currMaxM -= A[j-M+1] # slide window\\n                \\n                res = max(res, currMaxL + max_M_For_CurrL)\\n            \\n            i += 1\\n        \\n        currMaxL, currMaxM = 0, 0\\n        max_L_For_CurrM = float(\\'-inf\\')\\n        i = 0\\n        while i < len(A):\\n            if i >= M:     # if subarray size is bigger than M, slide window to right\\n                currMaxM -= A[i-M]\\n            currMaxM += A[i] # add current item\\n            \\n            j = i - M # start subArray of size L only after considering first M items\\n            if j >= 0:\\n                currMaxL += A[j]\\n            \\n            if j >= L-1: \\n                max_L_For_CurrM = max(max_L_For_CurrM, currMaxL)\\n                currMaxL -= A[j-L+1] # slide window\\n                \\n                res = max(res, currMaxM + max_L_For_CurrM)\\n            \\n            i += 1\\n        \\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708608,
                "title": "python-brute-force-solution",
                "content": "```python\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        m = 0\\n        \\n        for i in range(0, len(A) - L - M + 1):\\n            sub1 = sum(A[i:i+L])\\n            for j in range(i + L, len(A) - M + 1):\\n                tot = sum(A[j:j+M]) + sub1\\n                if tot > m: \\n                    m = tot\\n                    \\n        A.reverse()\\n        \\n        for i in range(0, len(A) - L - M + 1):\\n            sub1 = sum(A[i:i+L])\\n            for j in range(i + L, len(A) - M + 1):\\n                tot = sum(A[j:j+M]) + sub1\\n                if tot > m: \\n                    m = tot           \\n        \\n        return m\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        m = 0\\n        \\n        for i in range(0, len(A) - L - M + 1):\\n            sub1 = sum(A[i:i+L])\\n            for j in range(i + L, len(A) - M + 1):\\n                tot = sum(A[j:j+M]) + sub1\\n                if tot > m: \\n                    m = tot\\n                    \\n        A.reverse()\\n        \\n        for i in range(0, len(A) - L - M + 1):\\n            sub1 = sum(A[i:i+L])\\n            for j in range(i + L, len(A) - M + 1):\\n                tot = sum(A[j:j+M]) + sub1\\n                if tot > m: \\n                    m = tot           \\n        \\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695208,
                "title": "c-o-n-time-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        //time complexity: O(n); space: O(n)\\n        //two non-overlapping contiguous arrays where L comes first and then M\\n        int LthenM = maxSum(A, L, M);\\n        //two non-overlapping contiguous arrays where M comes first and then L\\n        int MthenL = maxSum(A, M, L);\\n        int result = max(LthenM, MthenL);\\n        return result;\\n    }\\n    int maxSum(vector<int>& A, int L, int M) {\\n        //left[0] = 0 && and right[A.size() - 1] = 0 to calculate non-overlapping sums when\\n        //adding left[i] + right[i]\\n        vector<int> left(A.size() + 1, 0);\\n        vector<int> right(A.size() + 1, 0);\\n        int sumleft = 0, sumright = 0, result = 0;\\n        //calculare sum values from left for size L\\n        for(int i = 0; i < A.size(); ++i) {\\n            sumleft += A[i];\\n            //store only max sliding window sum of length L, in every i upto i\\n            left[i+1] = max(left[i], sumleft);\\n            if(i + 1 >= L) {\\n                //you have L size values of sum, now remove the first element\\n                //from the sliding window\\n                sumleft -= A[i + 1 - L];\\n            }\\n        }\\n        //calculate sum values from right for size M\\n        for(int j = A.size() - 1; j >= 0; --j) {\\n            sumright += A[j];\\n            right[j] = max(right[j + 1], sumright);\\n            int val = (A.size() - 1) - (j - 1);\\n            if(val >= M) {\\n                sumright -= A[j - 1 + M];\\n            }\\n        }\\n        //we don\\'t care about the sum values that are less than the size of\\n        //L or M. So start from smallest of (L, M)\\n        int val = min(L, M); \\n        for(int i = val; i < A.size(); ++i) {\\n            result = max(result, left[i] + right[i]);\\n        }\\n        return result;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        //time complexity: O(n); space: O(n)\\n        //two non-overlapping contiguous arrays where L comes first and then M\\n        int LthenM = maxSum(A, L, M);\\n        //two non-overlapping contiguous arrays where M comes first and then L\\n        int MthenL = maxSum(A, M, L);\\n        int result = max(LthenM, MthenL);\\n        return result;\\n    }\\n    int maxSum(vector<int>& A, int L, int M) {\\n        //left[0] = 0 && and right[A.size() - 1] = 0 to calculate non-overlapping sums when\\n        //adding left[i] + right[i]\\n        vector<int> left(A.size() + 1, 0);\\n        vector<int> right(A.size() + 1, 0);\\n        int sumleft = 0, sumright = 0, result = 0;\\n        //calculare sum values from left for size L\\n        for(int i = 0; i < A.size(); ++i) {\\n            sumleft += A[i];\\n            //store only max sliding window sum of length L, in every i upto i\\n            left[i+1] = max(left[i], sumleft);\\n            if(i + 1 >= L) {\\n                //you have L size values of sum, now remove the first element\\n                //from the sliding window\\n                sumleft -= A[i + 1 - L];\\n            }\\n        }\\n        //calculate sum values from right for size M\\n        for(int j = A.size() - 1; j >= 0; --j) {\\n            sumright += A[j];\\n            right[j] = max(right[j + 1], sumright);\\n            int val = (A.size() - 1) - (j - 1);\\n            if(val >= M) {\\n                sumright -= A[j - 1 + M];\\n            }\\n        }\\n        //we don\\'t care about the sum values that are less than the size of\\n        //L or M. So start from smallest of (L, M)\\n        int val = min(L, M); \\n        for(int i = val; i < A.size(); ++i) {\\n            result = max(result, left[i] + right[i]);\\n        }\\n        return result;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640723,
                "title": "simple-c-solution-o-n-time-o-1-space",
                "content": "the code is self explanatory.\\n```\\nint findMaxSum3(vector<int>& A,int n,int L,int M,int start,int end){\\n    int maxSum = INT_MIN;\\n    int left = start-1;\\n    for(int i=M-1+start;i<=end;i++){\\n        int temp = 0;\\n        temp = A[i] - A[left];\\n        left++;\\n        if(temp > maxSum){\\n            maxSum = temp;\\n        }\\n    }\\n    return maxSum;\\n}\\n\\nint findMaxSum(vector<int>& A,int n,int L,int M){\\n    //care about the bound also\\n    int left = -1;\\n    int maxSum = INT_MIN;\\n    for(int i=L-1;i<n;i++){\\n        int temp = 0;\\n        if(left != -1){\\n            temp = A[i] - A[left]; \\n        }else{\\n            temp = A[i];\\n        }\\n        left++;\\n        \\n        int opt = findMaxSum3(A,n,L,M,i+1,n-1);\\n        if(opt == INT_MIN)  break;\\n        maxSum = max(maxSum,temp+opt);\\n    }\\n    return maxSum;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        \\n        for(int i=1;i<n;i++){\\n            A[i] += A[i-1];\\n        }\\n        return max(findMaxSum(A,n,L,M),findMaxSum(A,n,M,L));\\n    }\\n};\\n```\\nhope it helps!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint findMaxSum3(vector<int>& A,int n,int L,int M,int start,int end){\\n    int maxSum = INT_MIN;\\n    int left = start-1;\\n    for(int i=M-1+start;i<=end;i++){\\n        int temp = 0;\\n        temp = A[i] - A[left];\\n        left++;\\n        if(temp > maxSum){\\n            maxSum = temp;\\n        }\\n    }\\n    return maxSum;\\n}\\n\\nint findMaxSum(vector<int>& A,int n,int L,int M){\\n    //care about the bound also\\n    int left = -1;\\n    int maxSum = INT_MIN;\\n    for(int i=L-1;i<n;i++){\\n        int temp = 0;\\n        if(left != -1){\\n            temp = A[i] - A[left]; \\n        }else{\\n            temp = A[i];\\n        }\\n        left++;\\n        \\n        int opt = findMaxSum3(A,n,L,M,i+1,n-1);\\n        if(opt == INT_MIN)  break;\\n        maxSum = max(maxSum,temp+opt);\\n    }\\n    return maxSum;\\n}\\n\\n\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        \\n        for(int i=1;i<n;i++){\\n            A[i] += A[i-1];\\n        }\\n        return max(findMaxSum(A,n,L,M),findMaxSum(A,n,M,L));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 592472,
                "title": "java-simple-two-pointers-sum-array-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        if (L + M > A.length) {\\n            return -1;\\n        }\\n\\n        return Math.max(calcMaxSumTwoNoOverlap(A, L, M), calcMaxSumTwoNoOverlap(A, M, L));\\n    }\\n\\n    private int calcMaxSumTwoNoOverlap(int[] A, int window1, int window2) {\\n        int totalSum = Integer.MIN_VALUE;\\n        List<Integer> bucket1Sum = new ArrayList<>();\\n        List<Integer> bucket2Sum = new ArrayList<>();\\n\\n        // Construct sum array for L and M\\n        for (int i = 0; i <= A.length - window1 - window2; ++i) {\\n            int window1Left = i;\\n            int window1Right = i + window1;\\n\\n            int window2Left = i + window1;\\n            int window2Right = (i + window1) + window2;\\n\\n            int sum1 = calcSum(A, window1Left, window1Right);\\n            int sum2 = calcSum(A, window2Left, window2Right);\\n\\n            bucket1Sum.add(sum1);\\n            bucket2Sum.add(sum2);\\n        }\\n\\n        // Get best sum for L and M\\n        for (int i = 0; i < bucket1Sum.size(); ++i) {\\n            for (int j = i; j < bucket2Sum.size(); ++j) {\\n                if (totalSum < (bucket1Sum.get(i) + bucket2Sum.get(j))) {\\n                    totalSum = bucket1Sum.get(i) + bucket2Sum.get(j);\\n                }\\n            }\\n        }\\n\\n        return totalSum;\\n    }\\n\\n    private int calcSum(int[] A, int from, int to) {\\n        int sum = 0;\\n\\n        for (int i = from; i < to; ++i) {\\n            sum += A[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        if (L + M > A.length) {\\n            return -1;\\n        }\\n\\n        return Math.max(calcMaxSumTwoNoOverlap(A, L, M), calcMaxSumTwoNoOverlap(A, M, L));\\n    }\\n\\n    private int calcMaxSumTwoNoOverlap(int[] A, int window1, int window2) {\\n        int totalSum = Integer.MIN_VALUE;\\n        List<Integer> bucket1Sum = new ArrayList<>();\\n        List<Integer> bucket2Sum = new ArrayList<>();\\n\\n        // Construct sum array for L and M\\n        for (int i = 0; i <= A.length - window1 - window2; ++i) {\\n            int window1Left = i;\\n            int window1Right = i + window1;\\n\\n            int window2Left = i + window1;\\n            int window2Right = (i + window1) + window2;\\n\\n            int sum1 = calcSum(A, window1Left, window1Right);\\n            int sum2 = calcSum(A, window2Left, window2Right);\\n\\n            bucket1Sum.add(sum1);\\n            bucket2Sum.add(sum2);\\n        }\\n\\n        // Get best sum for L and M\\n        for (int i = 0; i < bucket1Sum.size(); ++i) {\\n            for (int j = i; j < bucket2Sum.size(); ++j) {\\n                if (totalSum < (bucket1Sum.get(i) + bucket2Sum.get(j))) {\\n                    totalSum = bucket1Sum.get(i) + bucket2Sum.get(j);\\n                }\\n            }\\n        }\\n\\n        return totalSum;\\n    }\\n\\n    private int calcSum(int[] A, int from, int to) {\\n        int sum = 0;\\n\\n        for (int i = from; i < to; ++i) {\\n            sum += A[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 590486,
                "title": "cpp-presum-simple-dp-beat-100-submission",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) { // o(n) o(n)\\n        int ret = 0;\\n        int m = A.size();\\n        if(m < L || m < M) return 0;\\n        vector<int> sum(m, 0); sum[0] = A[0];\\n        for(int i = 1; i < A.size(); i++) sum[i] = sum[i - 1] + A[i];\\n        vector<int> dpL(m, 0); dpL[L - 1] = sum[L - 1];\\n        vector<int> dpM(m, 0); dpM[M - 1] = sum[M - 1];\\n        for(int i = 0; i < m; i++) {\\n            if(i > L - 1) dpL[i] = max(dpL[i - 1], sum[i] - sum[i - L]);\\n            if(i > M - 1) dpM[i] = max(dpM[i - 1], sum[i] - sum[i - M]);\\n        }\\n        for(int i = L + M - 1; i < m; i++) {\\n            ret = max(ret, sum[i] - sum[i - L] + dpM[i - L]);\\n            ret = max(ret, sum[i] - sum[i - M] + dpL[i - M]);\\n        }\\n        return ret;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) { // o(n) o(n)\\n        int ret = 0;\\n        int m = A.size();\\n        if(m < L || m < M) return 0;\\n        vector<int> sum(m, 0); sum[0] = A[0];\\n        for(int i = 1; i < A.size(); i++) sum[i] = sum[i - 1] + A[i];\\n        vector<int> dpL(m, 0); dpL[L - 1] = sum[L - 1];\\n        vector<int> dpM(m, 0); dpM[M - 1] = sum[M - 1];\\n        for(int i = 0; i < m; i++) {\\n            if(i > L - 1) dpL[i] = max(dpL[i - 1], sum[i] - sum[i - L]);\\n            if(i > M - 1) dpM[i] = max(dpM[i - 1], sum[i] - sum[i - M]);\\n        }\\n        for(int i = L + M - 1; i < m; i++) {\\n            ret = max(ret, sum[i] - sum[i - L] + dpM[i - L]);\\n            ret = max(ret, sum[i] - sum[i - M] + dpL[i - M]);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 567891,
                "title": "o-n-space-o-n-time-solution-with-readable-code",
                "content": "```c++\\nclass Solution {\\n public:\\n  int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n    // sumL[a] = sum(A[a:a+L])\\n    // maxL[a] = max(sumL[a::])\\n    // sumM[a] = sum(A[a:a+M])\\n    // maxM[a] = max(sumM[a::])\\n    // tsum[a] = max(sumL[a] + maxM[a+L], sumM[a] + maxL[a+M]) \\n    // res = max(tsum[::])\\n    auto sumL = initSumv(A, L);\\n    auto sumM = initSumv(A, M);\\n    auto maxL = initMaxv(sumL);\\n    auto maxM = initMaxv(sumM);\\n    int res = 0;\\n    for (int i = 0; i+L+M <= A.size(); ++i) {\\n      res = max(res, sumL[i]+maxM[i+L]);\\n      res = max(res, sumM[i]+maxL[i+M]);\\n    }\\n    return res;\\n  }\\n \\n private:\\n  vector<int> initSumv(const vector<int>& A, int l) {\\n    vector<int> sumv(A.size()+1, 0);\\n    for (int i = 0; i < l; ++i)\\n      sumv[0] += A[i];\\n    for (int i = 1; i <= A.size()-l; ++i)\\n      sumv[i] = sumv[i-1] - A[i-1] + A[i+l-1];\\n    return sumv;\\n  }\\n\\n  vector<int> initMaxv(const vector<int>& S) {\\n    vector<int> maxv(S.size()+1, 0);\\n    for (int i = S.size()-1; i >= 0; --i) \\n      maxv[i] = max(maxv[i+1], S[i]);\\n    return maxv;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\n public:\\n  int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n    // sumL[a] = sum(A[a:a+L])\\n    // maxL[a] = max(sumL[a::])\\n    // sumM[a] = sum(A[a:a+M])\\n    // maxM[a] = max(sumM[a::])\\n    // tsum[a] = max(sumL[a] + maxM[a+L], sumM[a] + maxL[a+M]) \\n    // res = max(tsum[::])\\n    auto sumL = initSumv(A, L);\\n    auto sumM = initSumv(A, M);\\n    auto maxL = initMaxv(sumL);\\n    auto maxM = initMaxv(sumM);\\n    int res = 0;\\n    for (int i = 0; i+L+M <= A.size(); ++i) {\\n      res = max(res, sumL[i]+maxM[i+L]);\\n      res = max(res, sumM[i]+maxL[i+M]);\\n    }\\n    return res;\\n  }\\n \\n private:\\n  vector<int> initSumv(const vector<int>& A, int l) {\\n    vector<int> sumv(A.size()+1, 0);\\n    for (int i = 0; i < l; ++i)\\n      sumv[0] += A[i];\\n    for (int i = 1; i <= A.size()-l; ++i)\\n      sumv[i] = sumv[i-1] - A[i-1] + A[i+l-1];\\n    return sumv;\\n  }\\n\\n  vector<int> initMaxv(const vector<int>& S) {\\n    vector<int> maxv(S.size()+1, 0);\\n    for (int i = S.size()-1; i >= 0; --i) \\n      maxv[i] = max(maxv[i+1], S[i]);\\n    return maxv;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 508984,
                "title": "c-short-solution",
                "content": "```\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        for(int i = 1; i < A.size(); i++) A[i] += A[i-1];\\n        int res = A[L+M-1], Lmax = A[L-1], Mmax = A[M-1];\\n        for(int i = L + M; i < A.size(); i++) {\\n            Lmax = max(Lmax, A[i-M]-A[i-M-L]);\\n            Mmax = max(Mmax, A[i-L]-A[i-M-L]);\\n            res = max(res, A[i]-A[i-M] + Lmax);\\n            res = max(res, A[i]-A[i-L] + Mmax);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        for(int i = 1; i < A.size(); i++) A[i] += A[i-1];\\n        int res = A[L+M-1], Lmax = A[L-1], Mmax = A[M-1];\\n        for(int i = L + M; i < A.size(); i++) {\\n            Lmax = max(Lmax, A[i-M]-A[i-M-L]);\\n            Mmax = max(Mmax, A[i-L]-A[i-M-L]);\\n            res = max(res, A[i]-A[i-M] + Lmax);\\n            res = max(res, A[i]-A[i-L] + Mmax);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506654,
                "title": "java-sliding-window-easy-to-understand-with-example-o-1-space-o-n-time",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int R) {\\n        /*\\n        note that not overlap means index overlap, not value\\n        (can use prefix sum)\\n        solution: sliding windows 2 passes: l -> r then r -> l\\n        each pass: keep track of the main window and the max sub window\\n        ex: [0, 6, 5, 2, 9, 1], L = 1, R = 2\\n        start with index L + R\\n        -> [(0), (6, 5), 2, 9, 1] -> maxL = 0, R = 11 -> res = 11\\n        -> [0, (6), (5, 2), 9, 1] -> maxL = 6, R = 7  -> res = 13\\n        -> [0, 6, (5), (2, 9), 1] -> maxL = 6, R = 11 -> res = 17\\n        -> [0, 6, 5, (2), (9, 1)] -> maxL = 6, R = 10 -> res = 17 (17 > 16)\\n        -> first pass: 17\\n        second pass: go the opposite way or flip L & R;\\n        */\\n        return Math.max(maxSumLR(A, L, R), maxSumLR(A, R, L));\\n    }\\n    \\n    // helper funtion sliding window left to right\\n    private int maxSumLR(int[] A, int L, int R) {\\n        // start with L + R\\n        int i = 0;\\n        int sumL = 0, sumR = 0;\\n        // start with i = L + R\\n        while (i < L) sumL += A[i++];\\n        while (i < L + R) sumR += A[i++];\\n        int maxL = sumL, res = maxL + sumR;\\n        for (; i < A.length; i++) {\\n            // update the windows\\n            sumR += A[i] - A[i-R]; \\n            sumL += A[i-R] - A[i - L - R];\\n            maxL = Math.max(maxL, sumL);\\n            res = Math.max(res, maxL + sumR);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int R) {\\n        /*\\n        note that not overlap means index overlap, not value\\n        (can use prefix sum)\\n        solution: sliding windows 2 passes: l -> r then r -> l\\n        each pass: keep track of the main window and the max sub window\\n        ex: [0, 6, 5, 2, 9, 1], L = 1, R = 2\\n        start with index L + R\\n        -> [(0), (6, 5), 2, 9, 1] -> maxL = 0, R = 11 -> res = 11\\n        -> [0, (6), (5, 2), 9, 1] -> maxL = 6, R = 7  -> res = 13\\n        -> [0, 6, (5), (2, 9), 1] -> maxL = 6, R = 11 -> res = 17\\n        -> [0, 6, 5, (2), (9, 1)] -> maxL = 6, R = 10 -> res = 17 (17 > 16)\\n        -> first pass: 17\\n        second pass: go the opposite way or flip L & R;\\n        */\\n        return Math.max(maxSumLR(A, L, R), maxSumLR(A, R, L));\\n    }\\n    \\n    // helper funtion sliding window left to right\\n    private int maxSumLR(int[] A, int L, int R) {\\n        // start with L + R\\n        int i = 0;\\n        int sumL = 0, sumR = 0;\\n        // start with i = L + R\\n        while (i < L) sumL += A[i++];\\n        while (i < L + R) sumR += A[i++];\\n        int maxL = sumL, res = maxL + sumR;\\n        for (; i < A.length; i++) {\\n            // update the windows\\n            sumR += A[i] - A[i-R]; \\n            sumL += A[i-R] - A[i - L - R];\\n            maxL = Math.max(maxL, sumL);\\n            res = Math.max(res, maxL + sumR);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 497983,
                "title": "java-easy-understand-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n        int leftsums[]=new int[nums.length];\\n        int rightsums[]=new int[nums.length];\\n        int sum=0;int ans=0;\\n        int leftmax[]=new int[nums.length];\\n        int rightmax[]=new int[nums.length];\\n        int max=-1;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            leftsums[i]=sum;\\n        }\\n        sum=0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            sum+=nums[i];\\n            rightsums[i]=sum;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(i+1<M){\\n                continue;\\n            }\\n            if(i-M<0){\\n                max=Math.max(max,leftsums[i]);\\n            }else{\\n                max=Math.max(max,leftsums[i]-leftsums[i-M]);\\n            }\\n            leftmax[i]=max;\\n        }\\n        max=-1;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums.length-i<M){\\n                continue;\\n            }\\n            if(i+M>=nums.length){\\n                max=Math.max(max,rightsums[i]);\\n            }else{\\n                max=Math.max(max,rightsums[i]-rightsums[i+M]);\\n            }\\n            rightmax[i]=max;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(i+1<L){\\n                continue;\\n            }\\n            if(i-L+1==0){\\n                ans=Math.max(ans,leftsums[i]+rightmax[i+1]);\\n                continue;\\n            }\\n            if(i==nums.length-1){\\n                ans=Math.max(ans,leftsums[i]-leftsums[i-L]+leftmax[i-L]);\\n                continue;\\n            }\\n            ans=Math.max(ans,leftsums[i]-leftsums[i-L]+leftmax[i-L]);\\n            ans=Math.max(ans,leftsums[i]-leftsums[i-L]+rightmax[i+1]);   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int L, int M) {\\n        int leftsums[]=new int[nums.length];\\n        int rightsums[]=new int[nums.length];\\n        int sum=0;int ans=0;\\n        int leftmax[]=new int[nums.length];\\n        int rightmax[]=new int[nums.length];\\n        int max=-1;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            leftsums[i]=sum;\\n        }\\n        sum=0;\\n        for(int i=nums.length-1;i>=0;i--){\\n            sum+=nums[i];\\n            rightsums[i]=sum;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(i+1<M){\\n                continue;\\n            }\\n            if(i-M<0){\\n                max=Math.max(max,leftsums[i]);\\n            }else{\\n                max=Math.max(max,leftsums[i]-leftsums[i-M]);\\n            }\\n            leftmax[i]=max;\\n        }\\n        max=-1;\\n        for(int i=nums.length-1;i>=0;i--){\\n            if(nums.length-i<M){\\n                continue;\\n            }\\n            if(i+M>=nums.length){\\n                max=Math.max(max,rightsums[i]);\\n            }else{\\n                max=Math.max(max,rightsums[i]-rightsums[i+M]);\\n            }\\n            rightmax[i]=max;\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(i+1<L){\\n                continue;\\n            }\\n            if(i-L+1==0){\\n                ans=Math.max(ans,leftsums[i]+rightmax[i+1]);\\n                continue;\\n            }\\n            if(i==nums.length-1){\\n                ans=Math.max(ans,leftsums[i]-leftsums[i-L]+leftmax[i-L]);\\n                continue;\\n            }\\n            ans=Math.max(ans,leftsums[i]-leftsums[i-L]+leftmax[i-L]);\\n            ans=Math.max(ans,leftsums[i]-leftsums[i-L]+rightmax[i+1]);   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479199,
                "title": "c",
                "content": "```\\npublic int MaxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\tvar n = A.Length;\\n\\tint lMax = 0, mMax = 0, lSum = 0, mSum = 0;\\n\\tvar ls = new int[n]; var ms = new int[n];\\n\\tvar le = new int[n]; var me = new int[n];\\n\\tfor (var i = 0; i < L; i++) lSum += A[i];\\n\\tfor (var i = 0; i < M; i++) mSum += A[i];\\n\\tfor (var i = 0; i < n - L; i++) { ls[i] = lSum; lSum += A[i + L] - A[i]; }\\n\\tfor (var i = 0; i < n - M; i++) { ms[i] = mSum; mSum += A[i + M] - A[i]; }\\n\\tls[n - L] = lSum; ms[n - M] = mSum;\\n\\tfor (var i = n - 1; i >= L; i--) { le[i] = lSum; lSum -= A[i] - A[i - L]; }\\n\\tfor (var i = n - 1; i >= M; i--) { me[i] = mSum; mSum -= A[i] - A[i - M]; }\\n\\tle[L - 1] = lSum; me[M - 1] = mSum;\\n\\tfor (var i = n - 1; i >= 0; i--) { if (ls[i] > lMax) lMax = ls[i]; ls[i] = lMax; }\\n\\tfor (var i = n - 1; i >= 0; i--) { if (ms[i] > mMax) mMax = ms[i]; ms[i] = mMax; }\\n\\tlMax = mMax = 0;\\n\\tfor (var i = 0; i < n; i++) { if (le[i] > lMax) lMax = le[i]; le[i] = lMax; }\\n\\tfor (var i = 0; i < n; i++) { if (me[i] > mMax) mMax = me[i]; me[i] = mMax; }\\n\\tlMax = mMax = 0;\\n\\tfor (var i = 0; i < n - 1; i++) { var l = le[i] + ms[i + 1]; if (l > lMax) lMax = l; }\\n\\tfor (var i = 0; i < n - 1; i++) { var m = me[i] + ls[i + 1]; if (m > mMax) mMax = m; }\\n\\treturn lMax > mMax ? lMax : mMax;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int MaxSumTwoNoOverlap(int[] A, int L, int M) {\\n\\tvar n = A.Length;\\n\\tint lMax = 0, mMax = 0, lSum = 0, mSum = 0;\\n\\tvar ls = new int[n]; var ms = new int[n];\\n\\tvar le = new int[n]; var me = new int[n];\\n\\tfor (var i = 0; i < L; i++) lSum += A[i];\\n\\tfor (var i = 0; i < M; i++) mSum += A[i];\\n\\tfor (var i = 0; i < n - L; i++) { ls[i] = lSum; lSum += A[i + L] - A[i]; }\\n\\tfor (var i = 0; i < n - M; i++) { ms[i] = mSum; mSum += A[i + M] - A[i]; }\\n\\tls[n - L] = lSum; ms[n - M] = mSum;\\n\\tfor (var i = n - 1; i >= L; i--) { le[i] = lSum; lSum -= A[i] - A[i - L]; }\\n\\tfor (var i = n - 1; i >= M; i--) { me[i] = mSum; mSum -= A[i] - A[i - M]; }\\n\\tle[L - 1] = lSum; me[M - 1] = mSum;\\n\\tfor (var i = n - 1; i >= 0; i--) { if (ls[i] > lMax) lMax = ls[i]; ls[i] = lMax; }\\n\\tfor (var i = n - 1; i >= 0; i--) { if (ms[i] > mMax) mMax = ms[i]; ms[i] = mMax; }\\n\\tlMax = mMax = 0;\\n\\tfor (var i = 0; i < n; i++) { if (le[i] > lMax) lMax = le[i]; le[i] = lMax; }\\n\\tfor (var i = 0; i < n; i++) { if (me[i] > mMax) mMax = me[i]; me[i] = mMax; }\\n\\tlMax = mMax = 0;\\n\\tfor (var i = 0; i < n - 1; i++) { var l = le[i] + ms[i + 1]; if (l > lMax) lMax = l; }\\n\\tfor (var i = 0; i < n - 1; i++) { var m = me[i] + ls[i + 1]; if (m > mMax) mMax = m; }\\n\\treturn lMax > mMax ? lMax : mMax;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 478809,
                "title": "java-sliding-window-14-lines-0ms",
                "content": "For each M elements on the right, take the maximum of L elements on the left.\\nRepeat after swapping L and M.\\n```\\n\\tpublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        for(int i = 1; i < n; ++i) {\\n            A[i] += A[i-1];\\n        }\\n        int result = A[L + M - 1];\\n        int lmax = A[L - 1];\\n        int mmax = A[M - 1];\\n        for(int i = 0, j = L + M; j < n; ++i, ++j) {\\n            lmax = Math.max(lmax, A[i + L] - A[i]);\\n            mmax = Math.max(mmax, A[i + M] - A[i]);\\n            result = Math.max(result, lmax + A[j] - A[i + L]);\\n            result = Math.max(result, mmax + A[j] - A[i + M]);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int n = A.length;\\n        for(int i = 1; i < n; ++i) {\\n            A[i] += A[i-1];\\n        }\\n        int result = A[L + M - 1];\\n        int lmax = A[L - 1];\\n        int mmax = A[M - 1];\\n        for(int i = 0, j = L + M; j < n; ++i, ++j) {\\n            lmax = Math.max(lmax, A[i + L] - A[i]);\\n            mmax = Math.max(mmax, A[i + M] - A[i]);\\n            result = Math.max(result, lmax + A[j] - A[i + L]);\\n            result = Math.max(result, mmax + A[j] - A[i + M]);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 465172,
                "title": "o-n-deque-solution-2-passes",
                "content": "```\\nclass Solution \\n{\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) \\n    {\\n        return Math.max(compute(A, L, M), compute(reverse(A), L, M));\\n    }\\n    \\n    private int compute(int[] A, int l, int m)\\n    {\\n        Deque<Integer> mq = new LinkedList<Integer>();\\n        Deque<Integer> lq = new LinkedList<Integer>();\\n        \\n        int i=0, msum=0, lsum=0;\\n        \\n        while(i<A.length && i<l+m)\\n        {\\n            if(i<m)\\n            {\\n                msum += A[i];\\n                mq.offer(A[i]);\\n            }\\n            else\\n            {\\n                lsum += A[i];\\n                lq.offer(A[i]);\\n            }\\n            \\n            i++;\\n        }\\n        \\n        int mmax = msum;        \\n        int ans = mmax + lsum;\\n        \\n        while(i<A.length)\\n        {\\n            int mpoll = mq.pollFirst();\\n            int lpoll = lq.pollFirst();\\n            \\n            mq.offerLast(lpoll);\\n            lq.offerLast(A[i]);\\n            \\n            msum = msum - mpoll + lpoll;\\n            lsum = lsum - lpoll + A[i];\\n            \\n            mmax = Math.max(mmax, msum);\\n            ans = Math.max(ans, mmax + lsum);\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int[] reverse(int[] a)\\n    {\\n        for(int i=0; i<a.length/2; i++)\\n        {\\n            int temp = a[a.length-1-i];\\n            a[a.length-1-i] = a[i];\\n            a[i] = temp;\\n        }\\n        \\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) \\n    {\\n        return Math.max(compute(A, L, M), compute(reverse(A), L, M));\\n    }\\n    \\n    private int compute(int[] A, int l, int m)\\n    {\\n        Deque<Integer> mq = new LinkedList<Integer>();\\n        Deque<Integer> lq = new LinkedList<Integer>();\\n        \\n        int i=0, msum=0, lsum=0;\\n        \\n        while(i<A.length && i<l+m)\\n        {\\n            if(i<m)\\n            {\\n                msum += A[i];\\n                mq.offer(A[i]);\\n            }\\n            else\\n            {\\n                lsum += A[i];\\n                lq.offer(A[i]);\\n            }\\n            \\n            i++;\\n        }\\n        \\n        int mmax = msum;        \\n        int ans = mmax + lsum;\\n        \\n        while(i<A.length)\\n        {\\n            int mpoll = mq.pollFirst();\\n            int lpoll = lq.pollFirst();\\n            \\n            mq.offerLast(lpoll);\\n            lq.offerLast(A[i]);\\n            \\n            msum = msum - mpoll + lpoll;\\n            lsum = lsum - lpoll + A[i];\\n            \\n            mmax = Math.max(mmax, msum);\\n            ans = Math.max(ans, mmax + lsum);\\n            \\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private int[] reverse(int[] a)\\n    {\\n        for(int i=0; i<a.length/2; i++)\\n        {\\n            int temp = a[a.length-1-i];\\n            a[a.length-1-i] = a[i];\\n            a[i] = temp;\\n        }\\n        \\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 446258,
                "title": "share-my-solution-clean-java",
                "content": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int N = A.length;\\n        int[] preSum = new int[N];\\n        int[] postSum = new int[N];\\n        preSum[0] = A[0];\\n        for (int i = 1; i < N; i++) {\\n            preSum[i] = preSum[i - 1] + A[i];\\n        }\\n        postSum[N - 1] = A[N - 1];\\n        for (int i = N - 2; i >= 0; i--) {\\n            postSum[i] = postSum[i + 1] + A[i];\\n        }\\n        return Math.max(findMax(preSum, postSum, L, M), findMax(preSum, postSum, M, L));\\n    }\\n    \\n    public int findMax(int[] preSum, int[] postSum, int L, int M) {\\n        int N = preSum.length;\\n        int[] dp1 = new int[N];\\n        int[] dp2 = new int[N];\\n        dp1[L - 1] = preSum[L - 1];\\n        for (int i = L; i < N; i++) {\\n            dp1[i] = Math.max(dp1[i - 1], preSum[i] - preSum[i - L]);\\n        }\\n        dp2[N - M] = postSum[N - M];\\n        for (int i = N - M - 1; i >= 0; i--) {\\n            dp2[i] = Math.max(dp2[i + 1], postSum[i] - postSum[i + M]);\\n        }\\n        int max = 0;\\n        for (int i = L - 1; i < N - M; i++) {\\n            max = Math.max(dp1[i] + dp2[i + 1], max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        int N = A.length;\\n        int[] preSum = new int[N];\\n        int[] postSum = new int[N];\\n        preSum[0] = A[0];\\n        for (int i = 1; i < N; i++) {\\n            preSum[i] = preSum[i - 1] + A[i];\\n        }\\n        postSum[N - 1] = A[N - 1];\\n        for (int i = N - 2; i >= 0; i--) {\\n            postSum[i] = postSum[i + 1] + A[i];\\n        }\\n        return Math.max(findMax(preSum, postSum, L, M), findMax(preSum, postSum, M, L));\\n    }\\n    \\n    public int findMax(int[] preSum, int[] postSum, int L, int M) {\\n        int N = preSum.length;\\n        int[] dp1 = new int[N];\\n        int[] dp2 = new int[N];\\n        dp1[L - 1] = preSum[L - 1];\\n        for (int i = L; i < N; i++) {\\n            dp1[i] = Math.max(dp1[i - 1], preSum[i] - preSum[i - L]);\\n        }\\n        dp2[N - M] = postSum[N - M];\\n        for (int i = N - M - 1; i >= 0; i--) {\\n            dp2[i] = Math.max(dp2[i + 1], postSum[i] - postSum[i + M]);\\n        }\\n        int max = 0;\\n        for (int i = L - 1; i < N - M; i++) {\\n            max = Math.max(dp1[i] + dp2[i + 1], max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400935,
                "title": "c-dp-solution-o-n-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        vector<int> Asum(n+1, 0), maxL(n+1, 0), maxM(n+1, 0), sum(n+1, 0);\\n        for(int i=0; i<n; ++i){\\n            Asum[i+1] = A[i] + Asum[i];\\n            if(i+1 >= L) maxL[i+1] = max(maxL[i], Asum[i+1] - Asum[i+1-L]);\\n            if(i+1 >= M) maxM[i+1] = max(maxM[i], Asum[i+1] - Asum[i+1-M]);\\n            if(i+1 >= L+M) sum[i+1] = max(sum[i], \\n                    max(maxL[i+1-M]+Asum[i+1]-Asum[i+1-M], maxM[i+1-L]+Asum[i+1]-Asum[i+1-L]));\\n        }\\n        return sum[n];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        int n = A.size();\\n        vector<int> Asum(n+1, 0), maxL(n+1, 0), maxM(n+1, 0), sum(n+1, 0);\\n        for(int i=0; i<n; ++i){\\n            Asum[i+1] = A[i] + Asum[i];\\n            if(i+1 >= L) maxL[i+1] = max(maxL[i], Asum[i+1] - Asum[i+1-L]);\\n            if(i+1 >= M) maxM[i+1] = max(maxM[i], Asum[i+1] - Asum[i+1-M]);\\n            if(i+1 >= L+M) sum[i+1] = max(sum[i], \\n                    max(maxL[i+1-M]+Asum[i+1]-Asum[i+1-M], maxM[i+1-L]+Asum[i+1]-Asum[i+1-L]));\\n        }\\n        return sum[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373345,
                "title": "python-o-n-30ms-solution-with-explaination",
                "content": "```\\nclass Solution(object):\\n    def maxSumTwoNoOverlap(self, A, L, M):\\n        \"\"\"\\n        :type A: List[int]\\n        :type L: int\\n        :type M: int\\n        :rtype: int\\n        \"\"\"\\n        length = len(A)\\n\\t\\t\\n\\t\\t### Case 1: Array L on left, Array M on right  \\n\\t\\t\\n\\t\\t### Find maximum sum of M size array starting from right and store in DP\\n        dp,mysum = [0]*length,sum(A[-M:])\\n        mymax,dp[-M] = mysum,mysum\\n        for i in range(length-M-1,-1,-1):\\n            mysum += A[i]-A[i+M] \\n            mymax = max(mymax,mysum)\\n            dp[i] = mymax              \\n\\t\\t\\t\\n\\t\\t### Find maximum sum of L size array starting from left.\\n\\t\\t### Add maxL+ maxM(from dp) and track the maximum result.\\n        mysum = sum(A[:L])\\n        mymax,result = mysum,mysum+dp[L]\\n        for i in range(L,length-M):\\n            mysum += A[i]-A[i-L]\\n            mymax = max(mymax,mysum)\\n            result = max(result,mymax+dp[i+1])\\n\\n        ### Case 2: Array L on right, Array M on left. Repeat above logic \\n\\n        ### Find maximum sum of L size array starting from right and store in DP\\n        dp,mysum = [0]*length,sum(A[-L:])\\n        mymax,dp[-L] = mysum,mysum\\n        for i in range(length-L-1,-1,-1):\\n            mysum += A[i]-A[i+L]\\n            mymax = max(mymax,mysum)\\n            dp[i] = mymax\\n\\t\\t\\t\\n\\t\\t### Find maximum sum of M size array starting from left.\\n\\t\\t### Add maxM+ maxL(from dp) and track the maximum result.\\n        mysum = sum(A[:M])\\n        mymax,result = mysum,max(result,mysum+dp[M]) \\n        for i in range(M,length-L):\\n            mysum += A[i]-A[i-M]\\n            mymax = max(mymax,mysum)\\n            result = max(result,mymax+dp[i+1])\\n        return result\\n```\\n            \\n\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSumTwoNoOverlap(self, A, L, M):\\n        \"\"\"\\n        :type A: List[int]\\n        :type L: int\\n        :type M: int\\n        :rtype: int\\n        \"\"\"\\n        length = len(A)\\n\\t\\t\\n\\t\\t### Case 1: Array L on left, Array M on right  \\n\\t\\t\\n\\t\\t### Find maximum sum of M size array starting from right and store in DP\\n        dp,mysum = [0]*length,sum(A[-M:])\\n        mymax,dp[-M] = mysum,mysum\\n        for i in range(length-M-1,-1,-1):\\n            mysum += A[i]-A[i+M] \\n            mymax = max(mymax,mysum)\\n            dp[i] = mymax              \\n\\t\\t\\t\\n\\t\\t### Find maximum sum of L size array starting from left.\\n\\t\\t### Add maxL+ maxM(from dp) and track the maximum result.\\n        mysum = sum(A[:L])\\n        mymax,result = mysum,mysum+dp[L]\\n        for i in range(L,length-M):\\n            mysum += A[i]-A[i-L]\\n            mymax = max(mymax,mysum)\\n            result = max(result,mymax+dp[i+1])\\n\\n        ### Case 2: Array L on right, Array M on left. Repeat above logic \\n\\n        ### Find maximum sum of L size array starting from right and store in DP\\n        dp,mysum = [0]*length,sum(A[-L:])\\n        mymax,dp[-L] = mysum,mysum\\n        for i in range(length-L-1,-1,-1):\\n            mysum += A[i]-A[i+L]\\n            mymax = max(mymax,mysum)\\n            dp[i] = mymax\\n\\t\\t\\t\\n\\t\\t### Find maximum sum of M size array starting from left.\\n\\t\\t### Add maxM+ maxL(from dp) and track the maximum result.\\n        mysum = sum(A[:M])\\n        mymax,result = mysum,max(result,mysum+dp[M]) \\n        for i in range(M,length-L):\\n            mysum += A[i]-A[i-M]\\n            mymax = max(mymax,mysum)\\n            result = max(result,mymax+dp[i+1])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300929,
                "title": "java-beat-99-brute-force",
                "content": "```\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n    int len = A.length, maxSum = -2147483648;\\n    if(L < M){\\n        int temp = L; L = M; M = temp;\\n    }\\n    int sum = 0;\\n    for(int i = 0; i < L; ++i){\\n        sum += A[i];\\n    }\\n    for(int i = L - 1; i < len; ++i){\\n        if(i >= L){\\n            sum = sum - A[i - L] + A[i];\\n        }\\n        int twoSum = sum + Math.max(maxSumHelper(A, 0, i - L, M), maxSumHelper(A, i + 1, len, M));\\n        if(twoSum > maxSum){\\n            maxSum = twoSum;\\n        }\\n    }\\n    return maxSum;\\n}\\n    \\nprivate int maxSumHelper(int[] A, int begin, int end, int L){\\n    if(end - begin < L){\\n        return -2147483648;\\n    }\\n    int sum = 0;\\n    int nextBegin = begin + L;\\n    for(int i = begin; i < nextBegin; ++i){\\n        sum += A[i];\\n    }\\n    int maxSum = sum;\\n    for(int i = nextBegin; i < end; ++i){\\n        sum = sum + A[i] - A[i - L];\\n        if(sum > maxSum){\\n            maxSum = sum;\\n        }\\n    }\\n    return maxSum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n    int len = A.length, maxSum = -2147483648;\\n    if(L < M){\\n        int temp = L; L = M; M = temp;\\n    }\\n    int sum = 0;\\n    for(int i = 0; i < L; ++i){\\n        sum += A[i];\\n    }\\n    for(int i = L - 1; i < len; ++i){\\n        if(i >= L){\\n            sum = sum - A[i - L] + A[i];\\n        }\\n        int twoSum = sum + Math.max(maxSumHelper(A, 0, i - L, M), maxSumHelper(A, i + 1, len, M));\\n        if(twoSum > maxSum){\\n            maxSum = twoSum;\\n        }\\n    }\\n    return maxSum;\\n}\\n    \\nprivate int maxSumHelper(int[] A, int begin, int end, int L){\\n    if(end - begin < L){\\n        return -2147483648;\\n    }\\n    int sum = 0;\\n    int nextBegin = begin + L;\\n    for(int i = begin; i < nextBegin; ++i){\\n        sum += A[i];\\n    }\\n    int maxSum = sum;\\n    for(int i = nextBegin; i < end; ++i){\\n        sum = sum + A[i] - A[i - L];\\n        if(sum > maxSum){\\n            maxSum = sum;\\n        }\\n    }\\n    return maxSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293027,
                "title": "retweet-if-golang-makes-you-hate-heaps-too",
                "content": "This beats 100 percent. I\\'m not saying I\\'m \"like\" a big deal, \\nI\\'m saying I\\'m a big deal. \\n#stayHumble\\n\\n```\\nimport (\\n    \"container/heap\"\\n)\\n\\ntype Heap []int\\n\\nfunc (h Heap) Len() int { \\n    return len(h) \\n}\\nfunc (h Heap) Less(i, j int) bool {\\n    return h[i] > h[j]\\n}\\n\\nfunc (h Heap) Swap(i, j int) {\\n    h[i], h[j] = h[j], h[i]\\n}\\n\\nfunc (h *Heap) Push(x interface{}) {\\n    *h = append(*h, x.(int))\\n}\\n\\nfunc (h *Heap) Pop() interface{} {\\n    poo := *h\\n    item := poo[len(poo) - 1]\\n    *h = poo[0: len(poo) - 1]\\n    return item\\n}\\n\\nfunc maxSumTwoNoOverlap(A []int, L int, M int) int {\\n    L_sums, M_sums := []int{}, []int{}\\n    for i, num := range A {\\n        if i == 0 {\\n            L_sums = append(L_sums, num)\\n            M_sums = append(M_sums, num)\\n        } else {\\n            L_new := L_sums[i - 1] + num\\n            M_new := M_sums[i - 1] + num\\n            if i >= L {\\n                L_new -= A[i - L]\\n            }\\n            if i >= M {\\n                M_new -= A[i - M]\\n            }\\n            L_sums = append(L_sums, L_new)\\n            M_sums = append(M_sums, M_new)\\n        }\\n    }\\n    L_sums, M_sums = L_sums[L - 1:], M_sums[M - 1:]\\n    arrs := [][]int{L_sums, M_sums}\\n    lens := []int{L, M} \\n    res := 0\\n    for i, arr := range arrs {\\n        var others Heap\\n        heap.Init(&others)\\n        for j, sum := range arrs[1 - i] {\\n            if j + lens[1 - i] >= len(arr) {\\n                break\\n            }\\n            heap.Push(&others, sum)\\n            poss := others[0] + arr[j + lens[1 - i]]\\n            if poss > res {\\n                res = poss\\n            }   \\n        }        \\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport (\\n    \"container/heap\"\\n)\\n\\ntype Heap []int\\n\\nfunc (h Heap) Len() int { \\n    return len(h) \\n}\\nfunc (h Heap) Less(i, j int) bool {\\n    return h[i] > h[j]\\n}\\n\\nfunc (h Heap) Swap(i, j int) {\\n    h[i], h[j] = h[j], h[i]\\n}\\n\\nfunc (h *Heap) Push(x interface{}) {\\n    *h = append(*h, x.(int))\\n}\\n\\nfunc (h *Heap) Pop() interface{} {\\n    poo := *h\\n    item := poo[len(poo) - 1]\\n    *h = poo[0: len(poo) - 1]\\n    return item\\n}\\n\\nfunc maxSumTwoNoOverlap(A []int, L int, M int) int {\\n    L_sums, M_sums := []int{}, []int{}\\n    for i, num := range A {\\n        if i == 0 {\\n            L_sums = append(L_sums, num)\\n            M_sums = append(M_sums, num)\\n        } else {\\n            L_new := L_sums[i - 1] + num\\n            M_new := M_sums[i - 1] + num\\n            if i >= L {\\n                L_new -= A[i - L]\\n            }\\n            if i >= M {\\n                M_new -= A[i - M]\\n            }\\n            L_sums = append(L_sums, L_new)\\n            M_sums = append(M_sums, M_new)\\n        }\\n    }\\n    L_sums, M_sums = L_sums[L - 1:], M_sums[M - 1:]\\n    arrs := [][]int{L_sums, M_sums}\\n    lens := []int{L, M} \\n    res := 0\\n    for i, arr := range arrs {\\n        var others Heap\\n        heap.Init(&others)\\n        for j, sum := range arrs[1 - i] {\\n            if j + lens[1 - i] >= len(arr) {\\n                break\\n            }\\n            heap.Push(&others, sum)\\n            poss := others[0] + arr[j + lens[1 - i]]\\n            if poss > res {\\n                res = poss\\n            }   \\n        }        \\n    }\\n    return res\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 287988,
                "title": "straight-forward-sliding-window-java-solution",
                "content": "```\\n\\nclass Solution {\\n    class Window {\\n        int start, end;\\n        int sum;\\n        int len;\\n        public Window(int s, int e, int sum) {\\n            start = s;\\n            end = e;\\n            this.sum = sum;\\n            this.len = end - start + 1;\\n        }\\n    }\\n\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        List<Window> Ls = getWindows(A, L);\\n        List<Window> Ms = getWindows(A, M);\\n        int res = 0;\\n        for (int i = 0; i < Ls.size(); i++) {\\n            for (int j = 0; j < Ms.size(); j++) {\\n                if (notIntersacte(Ls.get(i), Ms.get(j))) {\\n                    res = Math.max(res, Ls.get(i).sum + Ms.get(j).sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private List<Window> getWindows(int[] A, int len) {\\n        List<Window> windows = new ArrayList<>();\\n        int start = 0, end = 0, sum = 0;\\n        while (end < len) {\\n            sum += A[end];\\n            end++;\\n        }\\n        end--;\\n        while (end < A.length) {\\n            windows.add(new Window(start, end, sum));\\n            // System.out.println(len + \",\" + sum);\\n            sum -= A[start];\\n            start++;\\n            end++;\\n            if (end == A.length) break;\\n            sum += A[end];\\n        }\\n        Collections.sort(windows, (a, b) -> b.sum - a.sum);\\n        return windows;\\n    }\\n    \\n    private boolean notIntersacte(Window w1, Window w2) {\\n        int s = Math.max(w1.start, w2.start);\\n        int e = Math.min(w1.end, w2.end);\\n        // System.out.println(w1.start + \" \" + w2.start + \" \" + w1.end + \" \" + w2.end);\\n        return e < s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    class Window {\\n        int start, end;\\n        int sum;\\n        int len;\\n        public Window(int s, int e, int sum) {\\n            start = s;\\n            end = e;\\n            this.sum = sum;\\n            this.len = end - start + 1;\\n        }\\n    }\\n\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        List<Window> Ls = getWindows(A, L);\\n        List<Window> Ms = getWindows(A, M);\\n        int res = 0;\\n        for (int i = 0; i < Ls.size(); i++) {\\n            for (int j = 0; j < Ms.size(); j++) {\\n                if (notIntersacte(Ls.get(i), Ms.get(j))) {\\n                    res = Math.max(res, Ls.get(i).sum + Ms.get(j).sum);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    private List<Window> getWindows(int[] A, int len) {\\n        List<Window> windows = new ArrayList<>();\\n        int start = 0, end = 0, sum = 0;\\n        while (end < len) {\\n            sum += A[end];\\n            end++;\\n        }\\n        end--;\\n        while (end < A.length) {\\n            windows.add(new Window(start, end, sum));\\n            // System.out.println(len + \",\" + sum);\\n            sum -= A[start];\\n            start++;\\n            end++;\\n            if (end == A.length) break;\\n            sum += A[end];\\n        }\\n        Collections.sort(windows, (a, b) -> b.sum - a.sum);\\n        return windows;\\n    }\\n    \\n    private boolean notIntersacte(Window w1, Window w2) {\\n        int s = Math.max(w1.start, w2.start);\\n        int e = Math.min(w1.end, w2.end);\\n        // System.out.println(w1.start + \" \" + w2.start + \" \" + w1.end + \" \" + w2.end);\\n        return e < s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287427,
                "title": "java-time-o-n-space-o-1-with-brain-storming-process-and-comments",
                "content": "```\\nclass Solution {\\n    /**\\n    Brain storming:\\n        - Prefix sum: to calculate n-length continuous sub array easily\\n        - We can seperate this problem to 2 small sub problems. This solution basically combine 2 sub problems into one. Formula: Max(Max(c, a), Max(c, b)) = Max(c, Max(a, b))\\n            - L before M\\n            - M before L\\n            Then get the max result\\n        - Find max L-length sub array, find M-length sub array, then get the max result (resultA)\\n        - Find max M-length sub array, find L-length sub array, then get the max result (resultB)\\n        - Then get max of resultA and resultB\\n    */\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // Construct prefix sum\\n        for (int i = 1; i < A.length; i++) {\\n            A[i] = A[i - 1] + A[i];\\n        }\\n        \\n        // Assign initial values so we can skip 1st run in below for loop\\n        int res = A[L + M - 1], maxL = A[L - 1], maxM = A[M - 1];\\n        \\n        // Either L before M or M before L, start this loop at index L + M\\n        for (int i = L + M; i < A.length; i++) {\\n            // Keep track maxL so far\\n            // L before M: A[i - M] - A[i - M - L] is sum of L-length sub array\\n            maxL = Math.max(maxL, A[i - M] - A[i - M - L]);\\n            // Keep track maxM so far\\n            // M before L: A[i - M] - A[i - L - M] is sum of M-length sub array\\n            maxM = Math.max(maxM, A[i - L] - A[i - L - M]);\\n            // Keep track res so far\\n            // maxL + (A[i] - A[i - M]): Sum of max L-length sub array and current M-length sub array\\n            // maxM + (A[i] - A[i - L]): Sum of max M-length sub array and current L-length sub array\\n            res = Math.max(res, Math.max(maxL + (A[i] - A[i - M]), maxM + (A[i] - A[i - L])));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    /**\\n    Brain storming:\\n        - Prefix sum: to calculate n-length continuous sub array easily\\n        - We can seperate this problem to 2 small sub problems. This solution basically combine 2 sub problems into one. Formula: Max(Max(c, a), Max(c, b)) = Max(c, Max(a, b))\\n            - L before M\\n            - M before L\\n            Then get the max result\\n        - Find max L-length sub array, find M-length sub array, then get the max result (resultA)\\n        - Find max M-length sub array, find L-length sub array, then get the max result (resultB)\\n        - Then get max of resultA and resultB\\n    */\\n    public int maxSumTwoNoOverlap(int[] A, int L, int M) {\\n        // Construct prefix sum\\n        for (int i = 1; i < A.length; i++) {\\n            A[i] = A[i - 1] + A[i];\\n        }\\n        \\n        // Assign initial values so we can skip 1st run in below for loop\\n        int res = A[L + M - 1], maxL = A[L - 1], maxM = A[M - 1];\\n        \\n        // Either L before M or M before L, start this loop at index L + M\\n        for (int i = L + M; i < A.length; i++) {\\n            // Keep track maxL so far\\n            // L before M: A[i - M] - A[i - M - L] is sum of L-length sub array\\n            maxL = Math.max(maxL, A[i - M] - A[i - M - L]);\\n            // Keep track maxM so far\\n            // M before L: A[i - M] - A[i - L - M] is sum of M-length sub array\\n            maxM = Math.max(maxM, A[i - L] - A[i - L - M]);\\n            // Keep track res so far\\n            // maxL + (A[i] - A[i - M]): Sum of max L-length sub array and current M-length sub array\\n            // maxM + (A[i] - A[i - L]): Sum of max M-length sub array and current L-length sub array\\n            res = Math.max(res, Math.max(maxL + (A[i] - A[i - M]), maxM + (A[i] - A[i - L])));\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 283759,
                "title": "javascript-o-n",
                "content": "```\\nvar maxSumTwoNoOverlap = function(A, L, M) {\\n    let len = A.length;\\n    for(let i = 1; i < len; i++) {\\n        A[i] += A[i - 1];\\n    }\\n    \\n    let LMax = A[L - 1], MMax = A[M-1];\\n    let res = A[M + L - 1];\\n    for(let i = M + L ; i< len ; i++) {\\n        // update LMax to i - M; \\n        LMax = Math.max(LMax, A[i - M ] - A[i - M - L]);\\n        MMax = Math.max(MMax, A[i - L ] - A[i - M - L]);\\n        res = Math.max(res,\\n            LMax + A[i] - A[i - M],\\n            MMax + A[i] - A[i - L]\\n        )\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxSumTwoNoOverlap = function(A, L, M) {\\n    let len = A.length;\\n    for(let i = 1; i < len; i++) {\\n        A[i] += A[i - 1];\\n    }\\n    \\n    let LMax = A[L - 1], MMax = A[M-1];\\n    let res = A[M + L - 1];\\n    for(let i = M + L ; i< len ; i++) {\\n        // update LMax to i - M; \\n        LMax = Math.max(LMax, A[i - M ] - A[i - M - L]);\\n        MMax = Math.max(MMax, A[i - L ] - A[i - M - L]);\\n        res = Math.max(res,\\n            LMax + A[i] - A[i - M],\\n            MMax + A[i] - A[i - L]\\n        )\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 282720,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        \\n        cumsums = []\\n        cumsum = 0\\n        cumsums.append(cumsum)\\n        for num in A:\\n            cumsum += num\\n            cumsums.append(cumsum)\\n        n = len(A)\\n        ans = -float(\\'inf\\')\\n        print(cumsums)\\n        for i in range(0, n - L - M + 1):\\n            for j in range(i + L, n - M + 1):\\n                ans = max(ans, cumsums[i + L] - cumsums[i] + cumsums[j + M] - cumsums[j])\\n        for i in range(0, n - M - L + 1):\\n            for j in range(i + M, n - L + 1):\\n                ans = max(ans, cumsums[i + M] - cumsums[i] + cumsums[j + L] - cumsums[j])\\n        return ans\\n\\t\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumTwoNoOverlap(self, A: List[int], L: int, M: int) -> int:\\n        \\n        cumsums = []\\n        cumsum = 0\\n        cumsums.append(cumsum)\\n        for num in A:\\n            cumsum += num\\n            cumsums.append(cumsum)\\n        n = len(A)\\n        ans = -float(\\'inf\\')\\n        print(cumsums)\\n        for i in range(0, n - L - M + 1):\\n            for j in range(i + L, n - M + 1):\\n                ans = max(ans, cumsums[i + L] - cumsums[i] + cumsums[j + M] - cumsums[j])\\n        for i in range(0, n - M - L + 1):\\n            for j in range(i + M, n - L + 1):\\n                ans = max(ans, cumsums[i + M] - cumsums[i] + cumsums[j + L] - cumsums[j])\\n        return ans\\n\\t\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 281514,
                "title": "c-solution-beats-100",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        // Size of array\\n        int size = A.size();\\n        \\n        // Partial sum\\n        vector<int> psum(size);\\n        partial_sum(A.begin(), A.end(), psum.begin());\\n        \\n        // Best L sum on LHS\\n        vector<int> llsum(size, 0);\\n        for (int i = L - 1; i < size; ++i) {\\n            llsum[i] = max(psum[i] - (i >= L ? psum[i - L] : 0), i ? llsum[i - 1] : 0);\\n        }\\n        \\n        // Best L sum on RHS\\n        vector<int> lrsum(size, 0);\\n        for (int i = size - L; i >= 0; --i) {\\n            lrsum[i] = max(psum[i + L - 1] - (i ? psum[i - 1] : 0), i < size - 1 ? lrsum[i + 1] : 0);\\n        }\\n        \\n        // Compute L and M sums\\n        int maxSum = psum[M - 1] + lrsum[M];\\n        for (int i = M; i < size; ++i) {\\n            int otherSum = max(i - M > L - 1 ? llsum[i - M] : 0, i < size - L ? lrsum[i + 1] : 0);\\n            \\n            if (otherSum == 0) {\\n                continue;\\n            }\\n            \\n            maxSum = max(maxSum, otherSum + psum[i] - psum[i - M]);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        // Size of array\\n        int size = A.size();\\n        \\n        // Partial sum\\n        vector<int> psum(size);\\n        partial_sum(A.begin(), A.end(), psum.begin());\\n        \\n        // Best L sum on LHS\\n        vector<int> llsum(size, 0);\\n        for (int i = L - 1; i < size; ++i) {\\n            llsum[i] = max(psum[i] - (i >= L ? psum[i - L] : 0), i ? llsum[i - 1] : 0);\\n        }\\n        \\n        // Best L sum on RHS\\n        vector<int> lrsum(size, 0);\\n        for (int i = size - L; i >= 0; --i) {\\n            lrsum[i] = max(psum[i + L - 1] - (i ? psum[i - 1] : 0), i < size - 1 ? lrsum[i + 1] : 0);\\n        }\\n        \\n        // Compute L and M sums\\n        int maxSum = psum[M - 1] + lrsum[M];\\n        for (int i = M; i < size; ++i) {\\n            int otherSum = max(i - M > L - 1 ? llsum[i - M] : 0, i < size - L ? lrsum[i + 1] : 0);\\n            \\n            if (otherSum == 0) {\\n                continue;\\n            }\\n            \\n            maxSum = max(maxSum, otherSum + psum[i] - psum[i - M]);\\n        }\\n        \\n        return maxSum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281078,
                "title": "python-two-pointer-ish-solution",
                "content": "Assume the sub-array with length L is in front of the one with length M (call them `front` and `back`).  Have a pointer `i` at the end of `back`. Iterate all possible `i`,  use variable `front_best`  to hold the max value of sum of the `front` sub-array at each step. \\n\\n```\\nclass Solution(object):\\n    def maxSumTwoNoOverlap(self, A, L, M):\\n        \"\"\"\\n        :type A: List[int]\\n        :type L: int\\n        :type M: int\\n        :rtype: int\\n        \"\"\"\\n        A2 = [0] + A[:]\\n        for i in range(1, len(A2)):\\n            A2[i] = A2[i] + A2[i-1]\\n            \\n        def run(L, M):\\n            front_best = 0\\n            ans = 0\\n            for i in range(L+M, len(A2)):\\n                front = A2[i-M] - A2[i-M-L]\\n                back = A2[i] - A2[i-M]\\n                \\n                front_best = max(front, front_best)\\n                ans = max(back + front_best, ans)\\n            return ans\\n        \\n        return max(run(L, M), run(M, L))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxSumTwoNoOverlap(self, A, L, M):\\n        \"\"\"\\n        :type A: List[int]\\n        :type L: int\\n        :type M: int\\n        :rtype: int\\n        \"\"\"\\n        A2 = [0] + A[:]\\n        for i in range(1, len(A2)):\\n            A2[i] = A2[i] + A2[i-1]\\n            \\n        def run(L, M):\\n            front_best = 0\\n            ans = 0\\n            for i in range(L+M, len(A2)):\\n                front = A2[i-M] - A2[i-M-L]\\n                back = A2[i] - A2[i-M]\\n                \\n                front_best = max(front, front_best)\\n                ans = max(back + front_best, ans)\\n            return ans\\n        \\n        return max(run(L, M), run(M, L))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279537,
                "title": "c-clean-soln-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        vector<int> prefixSums;\\n        int sum = 0;\\n        prefixSums.push_back(sum);\\n        for (auto i : A) {\\n            sum += i;\\n            prefixSums.push_back(sum);\\n        }\\n        \\n        int result = -1;\\n        for (int i = L; i < prefixSums.size(); i++) {\\n            // subarray sum of len L:\\n            auto lsum = prefixSums[i] - prefixSums[i-L];\\n            // for this prefix array of [i,i+L-1], find the prefix array of size\\n            // [j,j+M-1] where j is before and after i without overlap\\n            \\n            // 1. after:\\n            int msum = -1;\\n            for (int j = i + M; j < prefixSums.size(); j++) {\\n                // add subarray sum of len M to sum:\\n                msum = max(msum, prefixSums[j] - prefixSums[j-M]);\\n            }\\n            \\n            // 2. before:\\n            for (int j = M; j < i - L + 1; j++) {\\n                // add subarray sum of len M to sum:\\n                msum = max(msum, prefixSums[j] - prefixSums[j-M]);\\n            }\\n            result = max(result, lsum + msum);\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxSumTwoNoOverlap(vector<int>& A, int L, int M) {\\n        vector<int> prefixSums;\\n        int sum = 0;\\n        prefixSums.push_back(sum);\\n        for (auto i : A) {\\n            sum += i;\\n            prefixSums.push_back(sum);\\n        }\\n        \\n        int result = -1;\\n        for (int i = L; i < prefixSums.size(); i++) {\\n            // subarray sum of len L:\\n            auto lsum = prefixSums[i] - prefixSums[i-L];\\n            // for this prefix array of [i,i+L-1], find the prefix array of size\\n            // [j,j+M-1] where j is before and after i without overlap\\n            \\n            // 1. after:\\n            int msum = -1;\\n            for (int j = i + M; j < prefixSums.size(); j++) {\\n                // add subarray sum of len M to sum:\\n                msum = max(msum, prefixSums[j] - prefixSums[j-M]);\\n            }\\n            \\n            // 2. before:\\n            for (int j = M; j < i - L + 1; j++) {\\n                // add subarray sum of len M to sum:\\n                msum = max(msum, prefixSums[j] - prefixSums[j-M]);\\n            }\\n            result = max(result, lsum + msum);\\n        }\\n        \\n        return result;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278962,
                "title": "c-solutoin-o-n-with-explanation",
                "content": "### z-array (technical name=partial sum array):- array containing sum of all previous + current elements;\\n\\n* there is a function called \"partial_sum\" in c++ with the help of this you can make partial sum array in O(n) time complexity.\\n* syntax for partial_sum\\n```\\npartial_sum( v1.begin(),v1.end(),v2.begin() ); // this will make partial sum array of v1 and store the resulting array in v2\\n```\\n```\\nclass Solution {\\npublic:   \\n    int maxSumTwoNoOverlap(vector<int>& ar, int l, int m) {\\n    vector<int> zarray;\\n\\tint sum=0;\\n\\tfor(int x:ar)\\n\\t{\\n\\t\\tsum+=x;\\n\\t\\tzarray.push_back(sum);\\t\\t\\t\\t//making z-array\\n\\t}\\n\\t\\t/*\\n\\t\\t\\t or i can simple use partial_sum to make zarray as follow-\\n\\t\\t\\t partial_sum(ar.begin(),ar.end(),zarray.begin());\\n\\t\\t*/\\n\\t\\n\\tint lmax,mmax,res;\\n\\tres = zarray[m+l-1];\\t\\t\\t\\t\\t// first ans will be 0 - l and l+1 to m+l-1 or 0 - m and m+1 to m+l -1 as for the first ans order doesn\\'t matter \\n\\tlmax = zarray[l-1];\\t\\t\\t\\t\\t\\t// lmax if we start with 0th element\\n\\tmmax = zarray[m-1];\\t\\t\\t\\t\\t\\t// mmax if we start with 0th element\\n\\tfor(int i =l+m;i<zarray.size();i++)\\n\\t{\\n\\t\\tlmax = max(lmax,zarray[i-m]- zarray[i-m-l]);// finding lmax (comparing lmax with lmax(1,2,3,4) i,e,. with lmax value if we start with 1th ,2nd..element \\n\\t\\tmmax = max(mmax,zarray[i-l]-zarray[i-m-l]);//doing same as above\\n\\t\\tres = max (res,max(lmax + zarray[i]-zarray[i-m],mmax + zarray[i]-zarray[i-l]));\\t// comparing res(max value) with result obtain when \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//\"l is before m\" and result obtain when \"m is before l\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//i,e,.  in other word we assume \"m\\'s subarray\" to be at end of resultant subarray and choose lmax then find the resultant sum\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// then do the same with assuming \"l\\'s subarray\" at the end.. and finally compare these two results with the current max res.\\n\\n\\t}\\n\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\npartial_sum( v1.begin(),v1.end(),v2.begin() ); // this will make partial sum array of v1 and store the resulting array in v2\\n```\n```\\nclass Solution {\\npublic:   \\n    int maxSumTwoNoOverlap(vector<int>& ar, int l, int m) {\\n    vector<int> zarray;\\n\\tint sum=0;\\n\\tfor(int x:ar)\\n\\t{\\n\\t\\tsum+=x;\\n\\t\\tzarray.push_back(sum);\\t\\t\\t\\t//making z-array\\n\\t}\\n\\t\\t/*\\n\\t\\t\\t or i can simple use partial_sum to make zarray as follow-\\n\\t\\t\\t partial_sum(ar.begin(),ar.end(),zarray.begin());\\n\\t\\t*/\\n\\t\\n\\tint lmax,mmax,res;\\n\\tres = zarray[m+l-1];\\t\\t\\t\\t\\t// first ans will be 0 - l and l+1 to m+l-1 or 0 - m and m+1 to m+l -1 as for the first ans order doesn\\'t matter \\n\\tlmax = zarray[l-1];\\t\\t\\t\\t\\t\\t// lmax if we start with 0th element\\n\\tmmax = zarray[m-1];\\t\\t\\t\\t\\t\\t// mmax if we start with 0th element\\n\\tfor(int i =l+m;i<zarray.size();i++)\\n\\t{\\n\\t\\tlmax = max(lmax,zarray[i-m]- zarray[i-m-l]);// finding lmax (comparing lmax with lmax(1,2,3,4) i,e,. with lmax value if we start with 1th ,2nd..element \\n\\t\\tmmax = max(mmax,zarray[i-l]-zarray[i-m-l]);//doing same as above\\n\\t\\tres = max (res,max(lmax + zarray[i]-zarray[i-m],mmax + zarray[i]-zarray[i-l]));\\t// comparing res(max value) with result obtain when \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//\"l is before m\" and result obtain when \"m is before l\"\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//i,e,.  in other word we assume \"m\\'s subarray\" to be at end of resultant subarray and choose lmax then find the resultant sum\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// then do the same with assuming \"l\\'s subarray\" at the end.. and finally compare these two results with the current max res.\\n\\n\\t}\\n\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278757,
                "title": "c-8-line-solution",
                "content": "1. parial_sum gives us the ability to get the sum of a range form index i to j in O(1) time (by subtract p[i] - p[j])\\n2. Then we can just brute force in quadratic time all the different combinations of ranges (seeing as the length of array is only 10^3)\\n\\nVideo eplanation std::partial_sum here: https://youtu.be/Mf90cdF2N-o\\n```\\nint maxSumTwoNoOverlap(vector<int>& v, int L, int M) {\\n    int n = v.size(), ans = 0;\\n    vector<int> p(n+1, 0);\\n    partial_sum(v.begin(), v.end(), p.begin()+1); // partial sum give us O(1) sum of range\\n    for (int i = L, j = 0; i < n+1; ++i, ++j)\\n        for (int x = M, y = 0; x < n+1; ++x, ++y)\\n            if (x <= j || y >= i) // avoid overlap\\n                ans = max(ans, p[i] - p[j] + p[x] - p[y]); \\n    return ans;\\n};",
                "solutionTags": [],
                "code": "1. parial_sum gives us the ability to get the sum of a range form index i to j in O(1) time (by subtract p[i] - p[j])\\n2. Then we can just brute force in quadratic time all the different combinations of ranges (seeing as the length of array is only 10^3)\\n\\nVideo eplanation std::partial_sum here: https://youtu.be/Mf90cdF2N-o\\n```\\nint maxSumTwoNoOverlap(vector<int>& v, int L, int M) {\\n    int n = v.size(), ans = 0;\\n    vector<int> p(n+1, 0);\\n    partial_sum(v.begin(), v.end(), p.begin()+1); // partial sum give us O(1) sum of range\\n    for (int i = L, j = 0; i < n+1; ++i, ++j)\\n        for (int x = M, y = 0; x < n+1; ++x, ++y)\\n            if (x <= j || y >= i) // avoid overlap\\n                ans = max(ans, p[i] - p[j] + p[x] - p[y]); \\n    return ans;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 4099861,
                "title": "easy-understanding-dp-prefix-sum-memoization-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int fun(int i,int k,int prev,int l1,int l2,vector<int> &nums, vector<vector<vector<int>>> &dp,vector<int> &prefix)\\n    {\\n        int n = nums.size();\\n        if (k == 0 || i == n)\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][k][prev+1] != -1)\\n        {\\n            return dp[i][k][prev+1];\\n        }\\n\\n        int sum1 = 0;\\n        int maxi = 0;\\n        if ((prev == -1 || prev == 1) && i+l1<=n)\\n        {\\n\\n            sum1 = prefix[i+l1]-prefix[i];\\n\\n    \\n\\n            int pick = sum1 + fun(i+l1,k-1,2,l1,l2,nums,dp,prefix);\\n            maxi = max(maxi,pick);\\n        }\\n\\n        int sum2 = 0;\\n        if ((prev == 2 || prev == -1) && i+l2<=n)\\n        {\\n            \\n            sum2 = prefix[i+l2]-prefix[i];\\n\\n\\n            int pick = sum2 + fun(i+l2,k-1,1,l1,l2,nums,dp,prefix);\\n            maxi = max(maxi,pick);\\n        }\\n        int notpick = fun(i+1,k,prev,l1,l2,nums,dp,prefix);\\n\\n        maxi = max(maxi,notpick);\\n        return dp[i][k][prev+1]=maxi;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        vector<vector<vector<int>>> dp(nums.size()+1,vector<vector<int>>(3,vector<int>(4,-1)));\\n        int n = nums.size();\\n        vector<int> prefix(n+1,0);\\n        prefix[0] = 0;\\n        for (int i = 1;i<=n;i++)\\n        {\\n            prefix[i] = prefix[i-1] + nums[i-1];\\n        }\\n        return fun(0,2,-1,firstLen,secondLen,nums,dp,prefix);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int fun(int i,int k,int prev,int l1,int l2,vector<int> &nums, vector<vector<vector<int>>> &dp,vector<int> &prefix)\\n    {\\n        int n = nums.size();\\n        if (k == 0 || i == n)\\n        {\\n            return 0;\\n        }\\n\\n        if (dp[i][k][prev+1] != -1)\\n        {\\n            return dp[i][k][prev+1];\\n        }\\n\\n        int sum1 = 0;\\n        int maxi = 0;\\n        if ((prev == -1 || prev == 1) && i+l1<=n)\\n        {\\n\\n            sum1 = prefix[i+l1]-prefix[i];\\n\\n    \\n\\n            int pick = sum1 + fun(i+l1,k-1,2,l1,l2,nums,dp,prefix);\\n            maxi = max(maxi,pick);\\n        }\\n\\n        int sum2 = 0;\\n        if ((prev == 2 || prev == -1) && i+l2<=n)\\n        {\\n            \\n            sum2 = prefix[i+l2]-prefix[i];\\n\\n\\n            int pick = sum2 + fun(i+l2,k-1,1,l1,l2,nums,dp,prefix);\\n            maxi = max(maxi,pick);\\n        }\\n        int notpick = fun(i+1,k,prev,l1,l2,nums,dp,prefix);\\n\\n        maxi = max(maxi,notpick);\\n        return dp[i][k][prev+1]=maxi;\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        vector<vector<vector<int>>> dp(nums.size()+1,vector<vector<int>>(3,vector<int>(4,-1)));\\n        int n = nums.size();\\n        vector<int> prefix(n+1,0);\\n        prefix[0] = 0;\\n        for (int i = 1;i<=n;i++)\\n        {\\n            prefix[i] = prefix[i-1] + nums[i-1];\\n        }\\n        return fun(0,2,-1,firstLen,secondLen,nums,dp,prefix);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091034,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    void subArray(vector<int>& nums,int l,vector<int>&arr){\\n        int sum = 0;\\n        int j = 0;\\n        for(int i = 0;i < l && i < n;i++)\\n            sum += nums[i];\\n        arr[j++] = sum;\\n        for(int i = l;i<n;i++){\\n            sum += nums[i];\\n            sum -= nums[i - l];\\n            arr[j++] = sum;\\n        }\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        n = nums.size();\\n        vector<int>arr1(n-firstLen+1,0);\\n        vector<int>arr2(n-secondLen+1,0);\\n        subArray(nums,firstLen,arr1);\\n        subArray(nums,secondLen,arr2);\\n        int ans = 0;\\n        for(int i = 0;i <= n-firstLen;i++){\\n            int sum = arr1[i];\\n            for(int j = 0; j < i;j++)\\n                if(i > j + secondLen-1 )\\n                    ans = max(ans,sum+arr2[j]);\\n            for(int j = i + firstLen;j <= n - secondLen;j++)\\n                ans = max(ans,sum+arr2[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    void subArray(vector<int>& nums,int l,vector<int>&arr){\\n        int sum = 0;\\n        int j = 0;\\n        for(int i = 0;i < l && i < n;i++)\\n            sum += nums[i];\\n        arr[j++] = sum;\\n        for(int i = l;i<n;i++){\\n            sum += nums[i];\\n            sum -= nums[i - l];\\n            arr[j++] = sum;\\n        }\\n    }\\n    int maxSumTwoNoOverlap(vector<int>& nums, int firstLen, int secondLen) {\\n        n = nums.size();\\n        vector<int>arr1(n-firstLen+1,0);\\n        vector<int>arr2(n-secondLen+1,0);\\n        subArray(nums,firstLen,arr1);\\n        subArray(nums,secondLen,arr2);\\n        int ans = 0;\\n        for(int i = 0;i <= n-firstLen;i++){\\n            int sum = arr1[i];\\n            for(int j = 0; j < i;j++)\\n                if(i > j + secondLen-1 )\\n                    ans = max(ans,sum+arr2[j]);\\n            for(int j = i + firstLen;j <= n - secondLen;j++)\\n                ans = max(ans,sum+arr2[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051624,
                "title": "java-o-n",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        \\n        int first[] = new int[nums.length+1] , second[] = new int[nums.length+1] ;\\n        int n = nums.length  , sum1 = 0 ,sum2 = 0 ;\\n        for( int i = n-1 ; i > -1 ; i--){\\n            sum1 += nums[i];\\n            sum2 += nums[i];\\n            if( n - i  >= firstLen){\\n                sum1-= ( n-i == firstLen ? 0 :  nums[i+firstLen]);\\n                first[i] = Math.max( first[i+1] , sum1);\\n            }\\n            if( n-i >= secondLen){\\n                sum2-= ( n-i == secondLen ? 0 :  nums[i+secondLen]);\\n                second[i] = Math.max( second[i+1] , sum2);\\n            }\\n        }\\n\\n        return Math.max( algo(firstLen , nums , second) , algo( secondLen ,nums ,first));\\n    \\n    }\\n    public int algo( int len , int nums[],int arr[]){\\n        int res = 0  , sumd = 0;\\n        for( int i = 0 ; i <nums.length ; i++ ){\\n            sumd += nums[i];\\n            if( i >= len-1){\\n                int l = ( i == len-1 ? 0 : nums[i-len]);\\n                sumd -= l ;\\n                res = Math.max( res , sumd + arr[i+1]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        \\n        int first[] = new int[nums.length+1] , second[] = new int[nums.length+1] ;\\n        int n = nums.length  , sum1 = 0 ,sum2 = 0 ;\\n        for( int i = n-1 ; i > -1 ; i--){\\n            sum1 += nums[i];\\n            sum2 += nums[i];\\n            if( n - i  >= firstLen){\\n                sum1-= ( n-i == firstLen ? 0 :  nums[i+firstLen]);\\n                first[i] = Math.max( first[i+1] , sum1);\\n            }\\n            if( n-i >= secondLen){\\n                sum2-= ( n-i == secondLen ? 0 :  nums[i+secondLen]);\\n                second[i] = Math.max( second[i+1] , sum2);\\n            }\\n        }\\n\\n        return Math.max( algo(firstLen , nums , second) , algo( secondLen ,nums ,first));\\n    \\n    }\\n    public int algo( int len , int nums[],int arr[]){\\n        int res = 0  , sumd = 0;\\n        for( int i = 0 ; i <nums.length ; i++ ){\\n            sumd += nums[i];\\n            if( i >= len-1){\\n                int l = ( i == len-1 ? 0 : nums[i-len]);\\n                sumd -= l ;\\n                res = Math.max( res , sumd + arr[i+1]);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038099,
                "title": "go-sliding-window-o-n2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maxSumTwoNoOverlap(nums []int, firstLen int, secondLen int) int {\\n  \\n\\n    return max(findMaxSum(nums, firstLen, secondLen), findMaxSum(nums, secondLen, firstLen))\\n}\\n\\nfunc findMaxSum(nums []int, firstLen int, secondLen int) int{\\n  n := len(nums)\\n    fs := 0 \\n    fe := 0 \\n  \\n    maxSum := 0 \\n    sum := 0 \\n\\n    for fe < n - secondLen  {\\n      sum += nums[fe]\\n\\n      if fe - fs + 1 == firstLen {\\n\\n          ss := fe + 1\\n          se := fe + 1\\n          secondSum := 0\\n\\n          for se < n {\\n            secondSum += nums[se]\\n\\n            if se - ss + 1 == secondLen {\\n              if sum + secondSum > maxSum {\\n                maxSum = sum + secondSum\\n              }\\n\\n              // Slide the second subarray window by one. \\n              secondSum -= nums[ss]\\n              ss++\\n              se++\\n            }else {\\n              se++\\n            }\\n          }\\n\\n          // Now slide the first window \\n          sum -= nums[fs]\\n          fs++\\n          fe++\\n\\n      }else {\\n        fe++\\n      }\\n    }\\n\\n    return maxSum\\n}\\n\\nfunc max(a int, b int) int {\\n  if a > b {\\n    return a\\n  }else {\\n    return b\\n  }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxSumTwoNoOverlap(nums []int, firstLen int, secondLen int) int {\\n  \\n\\n    return max(findMaxSum(nums, firstLen, secondLen), findMaxSum(nums, secondLen, firstLen))\\n}\\n\\nfunc findMaxSum(nums []int, firstLen int, secondLen int) int{\\n  n := len(nums)\\n    fs := 0 \\n    fe := 0 \\n  \\n    maxSum := 0 \\n    sum := 0 \\n\\n    for fe < n - secondLen  {\\n      sum += nums[fe]\\n\\n      if fe - fs + 1 == firstLen {\\n\\n          ss := fe + 1\\n          se := fe + 1\\n          secondSum := 0\\n\\n          for se < n {\\n            secondSum += nums[se]\\n\\n            if se - ss + 1 == secondLen {\\n              if sum + secondSum > maxSum {\\n                maxSum = sum + secondSum\\n              }\\n\\n              // Slide the second subarray window by one. \\n              secondSum -= nums[ss]\\n              ss++\\n              se++\\n            }else {\\n              se++\\n            }\\n          }\\n\\n          // Now slide the first window \\n          sum -= nums[fs]\\n          fs++\\n          fe++\\n\\n      }else {\\n        fe++\\n      }\\n    }\\n\\n    return maxSum\\n}\\n\\nfunc max(a int, b int) int {\\n  if a > b {\\n    return a\\n  }else {\\n    return b\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982077,
                "title": "java-o-n-easy-to-understand-commented-explanation-1ms",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int prefix[]=new int[nums.length];\\n        int sum=0;\\n        int ans=0;\\n    // creating prefix sum array\\n        for(int i =0;i<nums.length;i++)\\n            {prefix[i]=sum+nums[i];\\n            sum=sum+nums[i];}\\n            \\n         int f=firstLen;\\n         int s=secondLen;\\n\\n        //first firstlen and then secondlen\\n        //what happens in this loop is \\n        //considering nums[i] in s length sub-array\\n        //what is max value of f length sub-array in nums[i-s]\\n         int maxf=prefix[f-1];\\n         int maxs=prefix[(s+f)-1]-prefix[f-1];\\n         int ans_fs=maxf+maxs;\\n         for(int i =(f+s);i<prefix.length;i++)\\n         {    maxf=Math.max(maxf,prefix[i-s]-prefix[i-(s+f)]);\\n              maxs=prefix[i]-prefix[i-s];\\n              ans_fs=Math.max(ans_fs,maxf+maxs);\\n         }\\n\\n         //first secondlen and then firstlen\\n         //what happens in this loop is \\n         //considering nums[i] in f length sub-array\\n         //what is max value of s length sub-array in nums[i-f]\\n         maxs=prefix[s-1];\\n         maxf=prefix[(s+f)-1]-prefix[s-1];\\n         int ans_sf=maxs+maxf;\\n         for(int i=(f+s);i<prefix.length;i++)\\n         { maxs=Math.max(maxs,prefix[i-f]-prefix[i-(s+f)]);\\n           maxf=prefix[i]-prefix[i-f];\\n           ans_sf=Math.max(ans_sf,maxs+maxf);\\n         }\\n        \\n         ans=Math.max(ans_sf,ans_fs);\\n         return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maxSumTwoNoOverlap(int[] nums, int firstLen, int secondLen) {\\n        int prefix[]=new int[nums.length];\\n        int sum=0;\\n        int ans=0;\\n    // creating prefix sum array\\n        for(int i =0;i<nums.length;i++)\\n            {prefix[i]=sum+nums[i];\\n            sum=sum+nums[i];}\\n            \\n         int f=firstLen;\\n         int s=secondLen;\\n\\n        //first firstlen and then secondlen\\n        //what happens in this loop is \\n        //considering nums[i] in s length sub-array\\n        //what is max value of f length sub-array in nums[i-s]\\n         int maxf=prefix[f-1];\\n         int maxs=prefix[(s+f)-1]-prefix[f-1];\\n         int ans_fs=maxf+maxs;\\n         for(int i =(f+s);i<prefix.length;i++)\\n         {    maxf=Math.max(maxf,prefix[i-s]-prefix[i-(s+f)]);\\n              maxs=prefix[i]-prefix[i-s];\\n              ans_fs=Math.max(ans_fs,maxf+maxs);\\n         }\\n\\n         //first secondlen and then firstlen\\n         //what happens in this loop is \\n         //considering nums[i] in f length sub-array\\n         //what is max value of s length sub-array in nums[i-f]\\n         maxs=prefix[s-1];\\n         maxf=prefix[(s+f)-1]-prefix[s-1];\\n         int ans_sf=maxs+maxf;\\n         for(int i=(f+s);i<prefix.length;i++)\\n         { maxs=Math.max(maxs,prefix[i-f]-prefix[i-(s+f)]);\\n           maxf=prefix[i]-prefix[i-f];\\n           ans_sf=Math.max(ans_sf,maxs+maxf);\\n         }\\n        \\n         ans=Math.max(ans_sf,ans_fs);\\n         return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1799476,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Man this question is hard"
                    },
                    {
                        "username": "the_arc_knight_24",
                        "content": "[8,20,6,2,20,17,6,3,20,8,12]\\nfirstLen=5 secondLen=4\\n\\nNot able to understand how thtis question is returning 108 as per the logic it should give 102. 66 for subarray of length 5 and 36 from subarray of length 4.\\n"
                    },
                    {
                        "username": "yash161220",
                        "content": "Right ans is 108 bec.. 5 length subarray sum is 65 (20+6+2+20+17) and 4 length sum is 43 (3+20+8+12) so total = 108"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "The subarray of length 5 starting at the first \"20\" has sum 65, and the subarray of length 4 ending at \"12\" has sum 43. "
                    },
                    {
                        "username": "guptadipanshu0001",
                        "content": "same doubt how is 108 coming max to max 102 will come\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is pretty tricky on the thinking part only - how you approach to a solution. Once you are there and figure out the very first point, the ride is a lot smooth down the next instant. Keep on thinking! You will definitely get a lot of positive energy solving this one."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Think about fixed length sliding window. \\nFix one window and move another window until the end is reached.\\n\\nThen slide the first window and repeat step 1."
                    }
                ]
            },
            {
                "id": 1835365,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Man this question is hard"
                    },
                    {
                        "username": "the_arc_knight_24",
                        "content": "[8,20,6,2,20,17,6,3,20,8,12]\\nfirstLen=5 secondLen=4\\n\\nNot able to understand how thtis question is returning 108 as per the logic it should give 102. 66 for subarray of length 5 and 36 from subarray of length 4.\\n"
                    },
                    {
                        "username": "yash161220",
                        "content": "Right ans is 108 bec.. 5 length subarray sum is 65 (20+6+2+20+17) and 4 length sum is 43 (3+20+8+12) so total = 108"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "The subarray of length 5 starting at the first \"20\" has sum 65, and the subarray of length 4 ending at \"12\" has sum 43. "
                    },
                    {
                        "username": "guptadipanshu0001",
                        "content": "same doubt how is 108 coming max to max 102 will come\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is pretty tricky on the thinking part only - how you approach to a solution. Once you are there and figure out the very first point, the ride is a lot smooth down the next instant. Keep on thinking! You will definitely get a lot of positive energy solving this one."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Think about fixed length sliding window. \\nFix one window and move another window until the end is reached.\\n\\nThen slide the first window and repeat step 1."
                    }
                ]
            },
            {
                "id": 1927453,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Man this question is hard"
                    },
                    {
                        "username": "the_arc_knight_24",
                        "content": "[8,20,6,2,20,17,6,3,20,8,12]\\nfirstLen=5 secondLen=4\\n\\nNot able to understand how thtis question is returning 108 as per the logic it should give 102. 66 for subarray of length 5 and 36 from subarray of length 4.\\n"
                    },
                    {
                        "username": "yash161220",
                        "content": "Right ans is 108 bec.. 5 length subarray sum is 65 (20+6+2+20+17) and 4 length sum is 43 (3+20+8+12) so total = 108"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "The subarray of length 5 starting at the first \"20\" has sum 65, and the subarray of length 4 ending at \"12\" has sum 43. "
                    },
                    {
                        "username": "guptadipanshu0001",
                        "content": "same doubt how is 108 coming max to max 102 will come\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is pretty tricky on the thinking part only - how you approach to a solution. Once you are there and figure out the very first point, the ride is a lot smooth down the next instant. Keep on thinking! You will definitely get a lot of positive energy solving this one."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Think about fixed length sliding window. \\nFix one window and move another window until the end is reached.\\n\\nThen slide the first window and repeat step 1."
                    }
                ]
            },
            {
                "id": 2055487,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "Man this question is hard"
                    },
                    {
                        "username": "the_arc_knight_24",
                        "content": "[8,20,6,2,20,17,6,3,20,8,12]\\nfirstLen=5 secondLen=4\\n\\nNot able to understand how thtis question is returning 108 as per the logic it should give 102. 66 for subarray of length 5 and 36 from subarray of length 4.\\n"
                    },
                    {
                        "username": "yash161220",
                        "content": "Right ans is 108 bec.. 5 length subarray sum is 65 (20+6+2+20+17) and 4 length sum is 43 (3+20+8+12) so total = 108"
                    },
                    {
                        "username": "mycoolhairison",
                        "content": "The subarray of length 5 starting at the first \"20\" has sum 65, and the subarray of length 4 ending at \"12\" has sum 43. "
                    },
                    {
                        "username": "guptadipanshu0001",
                        "content": "same doubt how is 108 coming max to max 102 will come\\n"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This question is pretty tricky on the thinking part only - how you approach to a solution. Once you are there and figure out the very first point, the ride is a lot smooth down the next instant. Keep on thinking! You will definitely get a lot of positive energy solving this one."
                    },
                    {
                        "username": "prakhar__dixit",
                        "content": "Think about fixed length sliding window. \\nFix one window and move another window until the end is reached.\\n\\nThen slide the first window and repeat step 1."
                    }
                ]
            }
        ]
    }
]