[
    {
        "title": "Minimum Cost Tree From Leaf Values",
        "question_content": "Given an array arr of positive integers, consider all binary trees such that:\n\n\tEach node has either 0 or 2 children;\n\tThe values of arr correspond to the values of each leaf in an in-order traversal of the tree.\n\tThe value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.\n\nAmong all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer.\nA node is a leaf if and only if it has zero children.\n&nbsp;\nExample 1:\n\nInput: arr = [6,2,4]\nOutput: 32\nExplanation: There are two possible trees shown.\nThe first has a non-leaf node sum 36, and the second has non-leaf node sum 32.\n\nExample 2:\n\nInput: arr = [4,11]\nOutput: 44\n\n&nbsp;\nConstraints:\n\n\t2 <= arr.length <= 40\n\t1 <= arr[i] <= 15\n\tIt is guaranteed that the answer fits into a 32-bit signed integer (i.e., it is less than 231).",
        "solutions": [
            {
                "id": 339959,
                "title": "one-pass-o-n-time-and-space",
                "content": "# DP Solution\\nFind the cost for the interval `[i,j]`.\\nTo build up the interval `[i,j]`,\\nwe need to split it into left subtree and sub tree,\\n`dp[i, j] = dp[i, k] + dp[k + 1, j] + max(A[i, k]) * max(A[k + 1, j])`\\n\\nIf you don\\'t understand dp solution,\\nI won\\'t explain it more and you won\\'t find the answer here.\\nTake your time,\\nread any other <Easy DP> solutions,\\nand come back at your own will.\\n\\nIf you got it, continue to read.\\n\\n# DP Complexity\\nSecond question after this dp solution,\\n**what\\'s the complexity?**\\n`N^2` states and `O(N)` to find each.\\nSo this solution is `O(N^3)` time and `O(N^2)` space.\\n\\nYou thought it\\'s fine.\\nAfter several nested for loop, you got a happy green accepted.\\nYou smiled and released a sigh as a winner.\\n\\nWhat a great practice for DP skill!\\nThen you noticed it\\'s medium.\\nThat\\'s it, just a standard medium problem of dp.\\nNothing can stop you. Even dp problem.\\n<br>\\n\\n# True story\\nSo you didn\\'t **Read** and **Upvote** this post.\\n(upvote is a good mark of having read)\\nOne day, you meet exactly the same solution during an interview.\\nYour heart welled over with joy,\\nand you bring up your solution with confidence.\\n\\nOne week later, you receive an email.\\nThe second paragraph starts with a key word \"Unfortunately\".\\n\\n**What the heck!?**\\nYou solved the interview problem perfectly,\\nbut the company didn\\'t appreciate your talent.\\nWhat\\'s more on earth did they want?\\n**WHY?**\\n<br>\\n\\n# **Why**\\nHere is the reason.\\nThis is not a dp problem at all.\\n\\nBecause dp solution test all ways to build up the tree,\\nincluding many unnecessay tries.\\nHonestly speaking, it\\'s kinda of brute force.\\nYes, brute force testing, with memorization.\\n<br>\\n\\n# **Intuition**\\nLet\\'s review the problem again.\\n\\nWhen we build a node in the tree, we compared the two numbers `a` and `b`.\\nIn this process,\\nthe smaller one is removed and we won\\'t use it anymore,\\nand the bigger one actually stays.\\n\\nThe problem can translated as following:\\nGiven an array `A`, choose two neighbors in the array `a` and `b`,\\nwe can remove the smaller one `min(a,b)` and the cost is `a * b`.\\nWhat is the minimum cost to remove the whole array until only one left?\\n\\nTo remove a number `a`, it needs a cost `a * b`, where `b >= a`.\\nSo `a` has to be removed by a bigger number.\\nWe want minimize this cost, so we need to minimize `b`.\\n\\n`b` has two candidates, the first bigger number on the left,\\nthe first bigger number on the right.\\n\\nThe cost to remove `a` is `a * min(left, right)`.\\n<br>\\n\\n# **Solution 1**\\nWith the intuition above in mind,\\nthe explanation is short to go.\\n\\nWe remove the element form the smallest to bigger.\\nWe check the `min(left, right)`,\\nFor each element `a`, `cost = min(left, right) * a`\\n\\nTime `O(N^2)`\\nSpace `O(N)`\\n\\n**Python**\\n```py\\n    def mctFromLeafValues(self, A):\\n        res = 0\\n        while len(A) > 1:\\n            i = A.index(min(A))\\n            res += min(A[i - 1:i] + A[i + 1:i + 2]) * A.pop(i)\\n        return res\\n```\\n<br>\\n\\n# **Solution 2: Stack Soluton**\\nwe decompose a hard problem into reasonable easy one:\\nJust find the next greater element in the array, on the left and one right.\\nRefer to the problem [503. Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n<br>\\n\\nTime `O(N)` for one pass\\nSpace `O(N)` for stack in the worst cases\\n<br>\\n\\n**Java:**\\n```java\\n    public int mctFromLeafValues(int[] A) {\\n        int res = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        for (int a : A) {\\n            while (stack.peek() <= a) {\\n                int mid = stack.pop();\\n                res += mid * Math.min(stack.peek(), a);\\n            }\\n            stack.push(a);\\n        }\\n        while (stack.size() > 2) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int mctFromLeafValues(vector<int>& A) {\\n        int res = 0;\\n        vector<int> stack = {INT_MAX};\\n        for (int a : A) {\\n            while (stack.back() <= a) {\\n                int mid = stack.back();\\n                stack.pop_back();\\n                res += mid * min(stack.back(), a);\\n            }\\n            stack.push_back(a);\\n        }\\n        for (int i = 2; i < stack.size(); ++i) {\\n            res += stack[i] * stack[i - 1];\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def mctFromLeafValues(self, A):\\n        res = 0\\n        stack = [float(\\'inf\\')]\\n        for a in A:\\n            while stack[-1] <= a:\\n                mid = stack.pop()\\n                res += mid * min(stack[-1], a)\\n            stack.append(a)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        return res\\n```\\n<br>\\n\\n# More Good Stack Problems\\nHere are some problems that impressed me.\\nGood luck and have fun.\\n\\n- 1130. [Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\n- 907. [Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/C++JavaPython-Stack-Solution)\\n- 901. [Online Stock Span](https://leetcode.com/problems/online-stock-span/discuss/168311/C++JavaPython-O(1))\\n- 856. [Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/discuss/141777/C++JavaPython-O(1)-Space)\\n- 503. [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n- 496.  Next Greater Element I\\n- 84. Largest Rectangle in Histogram\\n- 42. Trapping Rain Water\\n",
                "solutionTags": [],
                "code": "```py\\n    def mctFromLeafValues(self, A):\\n        res = 0\\n        while len(A) > 1:\\n            i = A.index(min(A))\\n            res += min(A[i - 1:i] + A[i + 1:i + 2]) * A.pop(i)\\n        return res\\n```\n```java\\n    public int mctFromLeafValues(int[] A) {\\n        int res = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        for (int a : A) {\\n            while (stack.peek() <= a) {\\n                int mid = stack.pop();\\n                res += mid * Math.min(stack.peek(), a);\\n            }\\n            stack.push(a);\\n        }\\n        while (stack.size() > 2) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int mctFromLeafValues(vector<int>& A) {\\n        int res = 0;\\n        vector<int> stack = {INT_MAX};\\n        for (int a : A) {\\n            while (stack.back() <= a) {\\n                int mid = stack.back();\\n                stack.pop_back();\\n                res += mid * min(stack.back(), a);\\n            }\\n            stack.push_back(a);\\n        }\\n        for (int i = 2; i < stack.size(); ++i) {\\n            res += stack[i] * stack[i - 1];\\n        }\\n        return res;\\n    }\\n```\n```python\\n    def mctFromLeafValues(self, A):\\n        res = 0\\n        stack = [float(\\'inf\\')]\\n        for a in A:\\n            while stack[-1] <= a:\\n                mid = stack.pop()\\n                res += mid * min(stack[-1], a)\\n            stack.append(a)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 478708,
                "title": "rz-summary-of-all-the-solutions-i-have-learned-from-discuss-in-python",
                "content": "**1. Dynamic programming approach**\\nWe are given a list of all the leaf nodes values for certain binary trees, but we do not know which leaf nodes belong to left subtree and which leaf nodes belong to right subtree. Since the given leaf nodes are result of inorder traversal, we know there will be pivots that divide arr into left and right, nodes in the left build left subtree and nodes in the right build right subtree. For each subtree, if we know the minimum sum, we can use it to build the result of the parent tree, so the problem can be divided into subproblems, and we have the following general transition equation (res(i, j) means the minimum non-leaf nodes sum with leaf nodes from arr[i] to arr[j]):\\n\\n```\\nfor k from i to j\\n    res(i, j) = min(res(i, k) + res(k + 1, j) + max(arr[i] ... arr[k]) * max(arr[k + 1] ... arr[j]))\\n```\\n\\n**Top down code with memorization ---> O(n ^ 3)**\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        return self.helper(arr, 0, len(arr) - 1, {})\\n        \\n    def helper(self, arr, l, r, cache):\\n        if (l, r) in cache:\\n            return cache[(l, r)]\\n        if l >= r:\\n            return 0\\n        \\n        res = float(\\'inf\\')\\n        for i in range(l, r):\\n            rootVal = max(arr[l:i+1]) * max(arr[i+1:r+1])\\n            res = min(res, rootVal + self.helper(arr, l, i, cache) + self.helper(arr, i + 1, r, cache))\\n        \\n        cache[(l, r)] = res\\n        return res\\n```\\n\\n**Bottom up code ---> O(n ^ 3)**\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [[float(\\'inf\\') for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = 0\\n        \\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                j = i + l - 1\\n                for k in range(i, j):\\n                    rootVal = max(arr[i:k+1]) * max(arr[k+1:j+1])\\n                    dp[i][j] = min(dp[i][j], rootVal + dp[i][k] + dp[k + 1][j])\\n        return dp[0][n - 1]\\n```\\n\\n**2. Greedy approach ---> O(n ^ 2)**\\nAbove approach is kind of like brute force since we calculate and compare the results all possible pivots. To achieve a better time complexity, one important observation is that when we build each level of the binary tree, it is the max left leaf node and max right lead node that are being used, so we would like to put big leaf nodes close to the root. Otherwise, taking the leaf node with max value in the array as an example, if its level is deep, for each level above it, its value will be used to calculate the non-leaf node value, which will result in a big total sum.\\n\\nWith above observation, the greedy approach is to find the smallest value in the array, use it and its smaller neighbor to build a non-leaf node, then we can safely delete it from the array since it has a smaller value than its neightbor so it will never be used again. Repeat this process until there is only one node left in the array (which means we cannot build a new level any more)\\n\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        while len(arr) > 1:\\n            index = arr.index(min(arr))\\n            if 0 < index < len(arr) - 1:\\n                res += arr[index] * min(arr[index - 1], arr[index + 1])\\n            else:\\n                res += arr[index] * (arr[index + 1] if index == 0 else arr[index - 1])\\n            arr.pop(index)\\n        return res\\n```\\n\\n**3. Monotonic stack approach ---> O(n)**\\nIn the greedy approach of 2), every time we delete the current minimum value, we need to start over and find the next smallest value again, so repeated operations are more or less involved. To further accelerate it, one observation is that for each leaf node in the array, when it becomes the minimum value in the remaining array, its left and right neighbors will be the first bigger value in the original array to its left and right. This observation is a clue of a possible monotonic stack solution as follows.\\n\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        stack = [float(\\'inf\\')]\\n        res = 0\\n        for num in arr:\\n            while stack and stack[-1] <= num:\\n                cur = stack.pop()\\n                if stack:\\n                    res += cur * min(stack[-1], num)\\n            stack.append(num)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nfor k from i to j\\n    res(i, j) = min(res(i, k) + res(k + 1, j) + max(arr[i] ... arr[k]) * max(arr[k + 1] ... arr[j]))\\n```\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        return self.helper(arr, 0, len(arr) - 1, {})\\n        \\n    def helper(self, arr, l, r, cache):\\n        if (l, r) in cache:\\n            return cache[(l, r)]\\n        if l >= r:\\n            return 0\\n        \\n        res = float(\\'inf\\')\\n        for i in range(l, r):\\n            rootVal = max(arr[l:i+1]) * max(arr[i+1:r+1])\\n            res = min(res, rootVal + self.helper(arr, l, i, cache) + self.helper(arr, i + 1, r, cache))\\n        \\n        cache[(l, r)] = res\\n        return res\\n```\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [[float(\\'inf\\') for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = 0\\n        \\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                j = i + l - 1\\n                for k in range(i, j):\\n                    rootVal = max(arr[i:k+1]) * max(arr[k+1:j+1])\\n                    dp[i][j] = min(dp[i][j], rootVal + dp[i][k] + dp[k + 1][j])\\n        return dp[0][n - 1]\\n```\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        while len(arr) > 1:\\n            index = arr.index(min(arr))\\n            if 0 < index < len(arr) - 1:\\n                res += arr[index] * min(arr[index - 1], arr[index + 1])\\n            else:\\n                res += arr[index] * (arr[index + 1] if index == 0 else arr[index - 1])\\n            arr.pop(index)\\n        return res\\n```\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        stack = [float(\\'inf\\')]\\n        res = 0\\n        for num in arr:\\n            while stack and stack[-1] <= num:\\n                cur = stack.pop()\\n                if stack:\\n                    res += cur * min(stack[-1], num)\\n            stack.append(num)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340014,
                "title": "greedy-python-solution",
                "content": "The thought is quite straight forward.\\n1. Pick up the leaf node with minimum value.\\n2. Combine it with its inorder neighbor which has smaller value between neighbors.\\n3. Once we get the new generated non-leaf node, the node with minimum value is useless (For the new generated subtree will be represented with the largest leaf node value.)\\n4. Repeat it until there is only one node.\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        while len(arr) > 1:\\n            mini_idx = arr.index(min(arr))\\n            if 0 < mini_idx < len(arr) - 1:\\n                res += min(arr[mini_idx - 1], arr[mini_idx + 1]) * arr[mini_idx]\\n            else:\\n                res += arr[1 if mini_idx == 0 else mini_idx - 1] * arr[mini_idx]\\n            arr.pop(mini_idx)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        while len(arr) > 1:\\n            mini_idx = arr.index(min(arr))\\n            if 0 < mini_idx < len(arr) - 1:\\n                res += min(arr[mini_idx - 1], arr[mini_idx + 1]) * arr[mini_idx]\\n            else:\\n                res += arr[1 if mini_idx == 0 else mini_idx - 1] * arr[mini_idx]\\n            arr.pop(mini_idx)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340033,
                "title": "c-with-comments",
                "content": "**Intuition and Algorithm**\\nGiven an array <code>arr</code> return the smallest possible sum of the values of each non-leaf node.\\nThe value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.\\n\\nFor example:\\narr= [3, 6, 4, 7, 2, 5]\\n\\n![image](https://assets.leetcode.com/users/hamlet_fiis/image_1563683100.png)\\n\\n\\n\\nThis is one distribution, we are going to solve that from top to bottom with dynammic programming\\n\\n**Approach 1 (DP)**\\nIn the image the root, their left subtree contains indexes [0-3] and their right subtree cointains indexes [4-5]. Then their value will be max(arr[0-3])* max(arr[4-5]).\\n\\nIn general:\\n<code> dp(left, right )=  min(   max(arr[left .. i] ) * max(arr[i+1 .. right]) + dp(left,i) +dp(i+1,right) )</code> where <code>i</code> go from <code>left </code>to <code>right-1</code>\\n\\nIn our previous formula <code>i</code> divide the root in [left .. i] left subtree and [i+1.. right]  right subtree.\\n\\n```\\nclass Solution {\\npublic:\\n    int memo[41][41];\\n    int maxi[41][41];\\n    \\n    int dp(int left,int right){\\n        if(left==right)return 0; //leaf node\\n        if(memo[left][right]!=-1)return memo[left][right];\\n        \\n        int ans = 1<<30;\\n        \\n        for(int i=left;i<right;i++)\\n            ans= min(ans, maxi[left][i] * maxi[i+1][right] + dp(left,i) + dp(i+1,right) );\\n        \\n        memo[left][right]=ans;\\n        return ans;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        memset(memo,-1,sizeof(memo));\\n        for(int i=0;i<arr.size();i++){\\n            maxi[i][i] = arr[i];\\n            for(int j=i+1;j<arr.size();j++)\\n                maxi[i][j] = max(maxi[i][j-1], arr[j]);\\n        }\\n        \\n        return dp(0,arr.size()-1);\\n    }\\n};\\n```\\n\\n<b>Complexity Analysis </b>\\n* Time Complexity: O(n* n * n) where n is the length of arr\\n* Space Complexity: O(n*n) where n is the length of arr\\n\\n**Approach 2 (Greedy+ Linked list)**\\n<ol>\\n<li>Pick up the minimum element in the array (val1)</li>\\n<li>Check their neighbors (left and right) and choose the minimum value betweem them (val2)</li>\\n<li>Accumulate this product to your answer (ans+=val1*val2) then delete the element (val1) in step 1.\\n<li>Repeat it until there is one element in the array.\\n</ol>\\n\\n**How can I do it efficiently?**\\nIt\\'s possible to do it in O(n* log(n)) sorting the array, but it has small values, arr[i]<=15. (counting sort is enough)\\nI need to know the neighbors of an element, after each delete operation (uses Linked list)\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        vector<int>adj[16];\\n        int n= arr.size();\\n        \\n        for(int i=0;i<n;i++)\\n            adj[arr[i]].push_back(i);\\n        \\n        int left[n];\\n        for(int i=0;i<n;i++)left[i]=i-1;\\n        int right[n];\\n        for(int i=0;i<n;i++)right[i]=i+1;\\n        \\n        int ans=0;\\n        \\n        for(int i=1;i<=15;i++){\\n            for(int j=0;j<adj[i].size();j++){\\n                int id= adj[i][j]; // index id in our array arr, global minimum\\n                int next_greater=0; // minimum element between their neighbor (first check if they are valid)\\n                if(left[id]==-1 && right[id]!=n){\\n                    next_greater=arr[right[id]];\\n                }else if(left[id]!=-1 && right[id]==n){\\n                    next_greater=arr[left[id]];\\n                }else if(left[id]!=-1 && right[id]!=n){\\n                    next_greater=min(arr[left[id]],arr[right[id]]);\\n                }\\n                \\n\\t\\t\\t\\t//delete index id in our Linked list\\n                if(right[id]!=n)\\n                    left[right[id]]= left[id];\\n                if(left[id]!=-1)\\n                    right[left[id]]= right[id];\\n\\t\\t\\t\\t\\t\\n                ans+=next_greater*i;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n<b>Complexity Analysis </b>\\n* Time Complexity: O(n) where n is the length of arr\\n* Space Complexity: O(n) where n is the length of arr\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo[41][41];\\n    int maxi[41][41];\\n    \\n    int dp(int left,int right){\\n        if(left==right)return 0; //leaf node\\n        if(memo[left][right]!=-1)return memo[left][right];\\n        \\n        int ans = 1<<30;\\n        \\n        for(int i=left;i<right;i++)\\n            ans= min(ans, maxi[left][i] * maxi[i+1][right] + dp(left,i) + dp(i+1,right) );\\n        \\n        memo[left][right]=ans;\\n        return ans;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        memset(memo,-1,sizeof(memo));\\n        for(int i=0;i<arr.size();i++){\\n            maxi[i][i] = arr[i];\\n            for(int j=i+1;j<arr.size();j++)\\n                maxi[i][j] = max(maxi[i][j-1], arr[j]);\\n        }\\n        \\n        return dp(0,arr.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        vector<int>adj[16];\\n        int n= arr.size();\\n        \\n        for(int i=0;i<n;i++)\\n            adj[arr[i]].push_back(i);\\n        \\n        int left[n];\\n        for(int i=0;i<n;i++)left[i]=i-1;\\n        int right[n];\\n        for(int i=0;i<n;i++)right[i]=i+1;\\n        \\n        int ans=0;\\n        \\n        for(int i=1;i<=15;i++){\\n            for(int j=0;j<adj[i].size();j++){\\n                int id= adj[i][j]; // index id in our array arr, global minimum\\n                int next_greater=0; // minimum element between their neighbor (first check if they are valid)\\n                if(left[id]==-1 && right[id]!=n){\\n                    next_greater=arr[right[id]];\\n                }else if(left[id]!=-1 && right[id]==n){\\n                    next_greater=arr[left[id]];\\n                }else if(left[id]!=-1 && right[id]!=n){\\n                    next_greater=min(arr[left[id]],arr[right[id]]);\\n                }\\n                \\n\\t\\t\\t\\t//delete index id in our Linked list\\n                if(right[id]!=n)\\n                    left[right[id]]= left[id];\\n                if(left[id]!=-1)\\n                    right[left[id]]= right[id];\\n\\t\\t\\t\\t\\t\\n                ans+=next_greater*i;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398420,
                "title": "java-dp-solution-very-easy-to-understand",
                "content": "```java\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length;\\n        int[][] dp = new int[n][n];\\n        return dfs(arr, 0, n - 1, dp);\\n    }\\n    \\n    public int dfs(int[] arr, int s, int e, int[][] dp) {\\n        if (s == e) return 0;\\n        if (dp[s][e] > 0) return dp[s][e];\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = s; i < e; i++) {\\n            int left = dfs(arr, s, i, dp);\\n            int right = dfs(arr, i + 1, e, dp);\\n            int maxLeft = 0, maxRight = 0;\\n            for (int j = s; j <= i; j++) maxLeft = Math.max(maxLeft, arr[j]);\\n            for (int j = i + 1; j <= e; j++) maxRight = Math.max(maxRight, arr[j]);\\n            ans = Math.min(ans, left + right + maxLeft * maxRight);\\n        }\\n        dp[s][e] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length;\\n        int[][] dp = new int[n][n];\\n        return dfs(arr, 0, n - 1, dp);\\n    }\\n    \\n    public int dfs(int[] arr, int s, int e, int[][] dp) {\\n        if (s == e) return 0;\\n        if (dp[s][e] > 0) return dp[s][e];\\n        int ans = Integer.MAX_VALUE;\\n        for (int i = s; i < e; i++) {\\n            int left = dfs(arr, s, i, dp);\\n            int right = dfs(arr, i + 1, e, dp);\\n            int maxLeft = 0, maxRight = 0;\\n            for (int j = s; j <= i; j++) maxLeft = Math.max(maxLeft, arr[j]);\\n            for (int j = i + 1; j <= e; j++) maxRight = Math.max(maxRight, arr[j]);\\n            ans = Math.min(ans, left + right + maxLeft * maxRight);\\n        }\\n        dp[s][e] = ans;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 476513,
                "title": "java-mono-stack-98-example-to-explain",
                "content": "```\\nclass Solution {\\n    // Use stack. Similar to trapping the rain water problem and the largest rectangle under histogram\\n    // Use stack to keep a decreasing order by adding smaller values, while there is bigger value \\n    //arr[i] than the peek, pop it and store as mid and calculate the multiplication mid*min(arr[i],  \\n    //stack.peek()).\\n    \\n    // NOTE: if we observe the number array, in order to obtain the smallest sum of all non-leaf\\n    // values, we want to merge those small values first. In order words, the smaller a value\\n    // is, the lower leaf it should stay because this way as we are building the tree up, \\n    // we are building smaller multiplication/parent node first as it is only going to get bigger\\n\\t// as we build the tree up. \\n    \\n    // Ex: 4 3 2 1 5\\n    // There are many ways we can build a tree following the problem\\'s requirement. However, to \\n    // gain smallest sum. We need to merge 2 and 1 first as they are the two smallest ones. To\\n\\t// do that, we use the stack mentioned above as a decreasing order. After\\n    // that we get a parent node with value 2. This node could be a left or right child of its parent\\n    // but what we want is that its parent needs also be as small as possible. We also know that its\\n    // parent has one mutiplier already: 2. Note: this 2 is not from the product of 1 * 2, but from the max  of child\\n    // 1 and 2 as the problem requires. So, we see what values next to the leaf 2 could be a \\n\\t// candidate. Obviously, 3 since it is the smallest one in the stack Then, 3\\n    // becomes the left child and 1*2 = 2 becomes right child. See below: \\n    //  ...\\n    //  / \\\\\\n    // 3   2\\n    //    / \\\\\\n    //   2   1\\n    // \\n    \\n    // If we observe carefully, 3 2 1 is decreasing... So how about every time we see a \"dip\" point\\n    // in the array we calculate its multiplication. To do that, say we are at arr[i] and their \\n    // relations are arr[i-1] <= arr[i] <= arr[i+1]. The min multiplication is a[i] * min(arr[i-1], \\n    // arr[i+1]). Then the example above is arr[i] = 1, arr[i-1] = 2, arr[i+1] = 5\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n          if(arr == null || arr.length < 2){\\n              return 0;\\n          }\\n          \\n          int res = 0;\\n          Stack<Integer> stack = new Stack<>();          \\n          for(int num : arr){\\n              \\n             // while num is bigger than peek(), pop and calculate\\n             while(!stack.isEmpty() && stack.peek() <= num){\\n                 int mid = stack.pop();\\n                 if(stack.isEmpty()) \\n                     res += mid * num;\\n                 else\\n                    res += mid * Math.min(stack.peek(), num);\\n             }\\n             \\n             stack.push(num); // if num is smaller, push into stack\\n         }\\n         \\n         // if there are values left in the stack, they sure will be mutiplied anyway\\n         // and added to the result. \\n         while(stack.size() > 1){ // > 1 because we have a peek() after pop() below\\n             res += stack.pop() * stack.peek();\\n         }\\n         \\n         return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Use stack. Similar to trapping the rain water problem and the largest rectangle under histogram\\n    // Use stack to keep a decreasing order by adding smaller values, while there is bigger value \\n    //arr[i] than the peek, pop it and store as mid and calculate the multiplication mid*min(arr[i],  \\n    //stack.peek()).\\n    \\n    // NOTE: if we observe the number array, in order to obtain the smallest sum of all non-leaf\\n    // values, we want to merge those small values first. In order words, the smaller a value\\n    // is, the lower leaf it should stay because this way as we are building the tree up, \\n    // we are building smaller multiplication/parent node first as it is only going to get bigger\\n\\t// as we build the tree up. \\n    \\n    // Ex: 4 3 2 1 5\\n    // There are many ways we can build a tree following the problem\\'s requirement. However, to \\n    // gain smallest sum. We need to merge 2 and 1 first as they are the two smallest ones. To\\n\\t// do that, we use the stack mentioned above as a decreasing order. After\\n    // that we get a parent node with value 2. This node could be a left or right child of its parent\\n    // but what we want is that its parent needs also be as small as possible. We also know that its\\n    // parent has one mutiplier already: 2. Note: this 2 is not from the product of 1 * 2, but from the max  of child\\n    // 1 and 2 as the problem requires. So, we see what values next to the leaf 2 could be a \\n\\t// candidate. Obviously, 3 since it is the smallest one in the stack Then, 3\\n    // becomes the left child and 1*2 = 2 becomes right child. See below: \\n    //  ...\\n    //  / \\\\\\n    // 3   2\\n    //    / \\\\\\n    //   2   1\\n    // \\n    \\n    // If we observe carefully, 3 2 1 is decreasing... So how about every time we see a \"dip\" point\\n    // in the array we calculate its multiplication. To do that, say we are at arr[i] and their \\n    // relations are arr[i-1] <= arr[i] <= arr[i+1]. The min multiplication is a[i] * min(arr[i-1], \\n    // arr[i+1]). Then the example above is arr[i] = 1, arr[i-1] = 2, arr[i+1] = 5\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n          if(arr == null || arr.length < 2){\\n              return 0;\\n          }\\n          \\n          int res = 0;\\n          Stack<Integer> stack = new Stack<>();          \\n          for(int num : arr){\\n              \\n             // while num is bigger than peek(), pop and calculate\\n             while(!stack.isEmpty() && stack.peek() <= num){\\n                 int mid = stack.pop();\\n                 if(stack.isEmpty()) \\n                     res += mid * num;\\n                 else\\n                    res += mid * Math.min(stack.peek(), num);\\n             }\\n             \\n             stack.push(num); // if num is smaller, push into stack\\n         }\\n         \\n         // if there are values left in the stack, they sure will be mutiplied anyway\\n         // and added to the result. \\n         while(stack.size() > 1){ // > 1 because we have a peek() after pop() below\\n             res += stack.pop() * stack.peek();\\n         }\\n         \\n         return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 474188,
                "title": "i-think-i-able-to-explain-it-to-myself-and-to-you-java-dp-complexity-is-in-the-question",
                "content": "I borrow the solution from this user https://leetcode.com/qixu\\nThank you, dear!\\nBut I changed names and added explanations (see the code below, run it, it shows some things on the run, also read my comments in the code):\\n\\n1.\\nThe idea is to slide over the array, looking into the each variant of leaves distribution between the left and the right sub-tree\\nFor example, with the array 6,2,4 \\nwe look at following variants:\\n(a)Left : 6, Right: 2,4\\n(b)Left: 6, 2 Right 4\\n\\nThe variant (a) in its right part is not demanding further subtrees, because we have only 2 leaves 2 and 4,\\nand according to the condition of the task, we can have only 0 or 2 leaves per not leaf node, so those 2 will certainly be children of the 1 non-leaf node. But, if you imagine a larger array and if you have on the right like 3 numbers, for example 3,4,5, in such case you will be required to divide this right sub-tree into the smaller sub-sub-trees, like\\n(a.a) Left : 3, Right 4,5\\n(a.b) Left: 3,4, Right 5\\n\\nYou got the idea?\\n\\nYou sort of slide over the array and take all possible variants of leaves distribution....entering the recursion, if the remaining array could be divided further.\\n\\nExample array:\\n1,2,3,4\\n\\nVariants\\n1  and 2,3,4\\n1,2 and 3,4\\n1,2,3 and 4\\n\\n1-st variant divided further in its right part on 2 variants\\n2 and 3,4\\n2,3 and 4\\n\\n3-d variant divided on 2 in its left part\\n1 and 2,3\\n2,3 and 1\\n\\nYou see? Sub-trees of trees? This is where recursion works...\\n\\n\\n\\n2)\\nYou remember the fact, that non-leaf node value formed from the MAX(of all leaf values left of me) and MAX ( of all leaf values right of me) , put it shorter MAX(left leaves) * MAX (right leaves) , remember that!\\nIf you are the lowest node, but not a leaf, you must have 2 leaves! Thus, your value will be formed by \\nMAX (my left child alone) * MAX (my right child alone)\\n\\n3)\\nIf you are the TOP non leaf node, the highest one, your value is also \\nMAX(left leaves) * MAX (right leaves)\\nAnd if you wish to sum the all NON-LEAF nodes you take yourself: MAX(left leaves) * MAX (right leaves)\\nand add to that all values(of all non leaves) that you recursively got from left and from right, thus:\\n\\nSUM(of all non leaf) = TOP_NON_LEAF + left_non_leaves + right_non_leaves = \\n(in short and as in the code below)\\nvalueOfTheNonLeafNode + left + right\\n\\n4)\\nmemo[][] we use to memorize previously computed values for subtrees\\n\\nif we had only 2 nodes , for example 1 and 2\\nmemo would be 2x2 matrix\\ni=0, j=1 cell is keeping the computation result of the variant , where start=0 and end =1\\nIt is the all results this short array[]{1,2} able to produce\\ni=0, j=0 is also tried in the int left = minSumOfNonLeafNodes(arr, startIndex, i, memo);\\nbut it returns 0 from that call and never gets to insert into memo[][] , the value retuurned here:\\n        \\n\\t\\t```\\n\\t   if (startIndex >= endIndex) {\\n            return 0;\\n        }\\n\\t```\\n\\nbut wider arrays, like that:\\n6,2,4\\nproduce some memo, like:\\nmemo=[1][2]=8\\nmemo=[0][1]=12\\nmemo=[0][2]=32\\nDo we understand why?\\nLet\\'s try;\\nIndexes: 0  1   2\\nValues:    6  2   4\\nmemo[1][2] formed by 2, 4 - here we see that examined 2 and 4, when they are both in the right sub tree\\nmemo[0][1] formed by 6, 2 - here we see that examined 6 and 2, when they are both in the left sub tree        \\nmemo[0][2] formed by 6, 2, 4  - it is the result of 2 aforementioned variants combined:\\n6  and 2,4 (this variant gives 32)\\nand\\n6,2 and 4 (this variant gives 36)\\n32 is selected from both.\\n\\n\\n\\n\\n5.\\nComplexity\\nWith space it is N^2\\n\\nWith time, I\\'m not sure, if you know - tell us\\nI think we have n possible recursive branches\\nAnd the max depth of the branch is N-2\\nThus it looks for me that O( n ^ (n-2)), which is O(N^N)\\nBut this is without memo...\\nWith memo...this is the question...\\nI only able to practically establish that for\\n10 elements 241 memo calculated\\n100 elements 5047 memo  calculated\\n1000 elements 500497 memo  calculated\\nIt looks like N^2 ...But I do not know will that change above 1000, cause I have stack overfolow\\n\\n\\nWhat do you think?\\n\\n\\n\\n```\\npublic int mctFromLeafValues(int[] arr) {\\n\\n        if (arr == null || arr.length == 0) {\\n            return 0;\\n        }\\n\\n        int[][] memo = new int[arr.length][arr.length];\\n\\n        return minSumOfNonLeafNodes(arr, 0, arr.length - 1, memo);\\n\\n    }\\n\\n    private int minSumOfNonLeafNodes(int[] arr, int startIndex, int endIndex, int[][] memo) {\\n\\n        //$$$ - note, here recursion stops, start==end\\n        if (startIndex >= endIndex) {\\n            return 0;\\n        }\\n\\n        if (memo[startIndex][endIndex]  !=  0) {\\n            return memo[startIndex][endIndex];\\n        }\\n\\n\\n        int res = Integer.MAX_VALUE;\\n\\n        for (int i = startIndex; i < endIndex; i++) {\\n            //first time it returns 0, when recursion stops at $$$\\n            int left = minSumOfNonLeafNodes(arr, startIndex, i, memo);\\n            //first time it returns 0, when recursion stops at $$$\\n            int right = minSumOfNonLeafNodes(arr, i + 1, endIndex, memo);\\n\\n            int maxLeft = 0;\\n\\n            int maxRight = 0;\\n\\n            for (int j = startIndex; j <= i; j++) {\\n                maxLeft = Math.max(maxLeft, arr[j]);\\n            }\\n\\n            for (int j = i + 1; j <= endIndex; j++) {\\n                maxRight = Math.max(maxRight, arr[j]);\\n            }\\n\\n            int valueOfTheNonLeafNode = maxLeft * maxRight;\\n\\n            //first time left==0 and right==0, we have only valueOfTheNonLeafNode present - \\n            //it means we are in the lowest NOT LEAF NODE\\n            res = Math.min(res, valueOfTheNonLeafNode + left + right);\\n        }\\n        memo[startIndex][endIndex] = res;\\n        System.out.println(\"memo=[\"+startIndex+\"][\"+endIndex+\"]=\"+res);\\n\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t   if (startIndex >= endIndex) {\\n            return 0;\\n        }\\n\\t```\n```\\npublic int mctFromLeafValues(int[] arr) {\\n\\n        if (arr == null || arr.length == 0) {\\n            return 0;\\n        }\\n\\n        int[][] memo = new int[arr.length][arr.length];\\n\\n        return minSumOfNonLeafNodes(arr, 0, arr.length - 1, memo);\\n\\n    }\\n\\n    private int minSumOfNonLeafNodes(int[] arr, int startIndex, int endIndex, int[][] memo) {\\n\\n        //$$$ - note, here recursion stops, start==end\\n        if (startIndex >= endIndex) {\\n            return 0;\\n        }\\n\\n        if (memo[startIndex][endIndex]  !=  0) {\\n            return memo[startIndex][endIndex];\\n        }\\n\\n\\n        int res = Integer.MAX_VALUE;\\n\\n        for (int i = startIndex; i < endIndex; i++) {\\n            //first time it returns 0, when recursion stops at $$$\\n            int left = minSumOfNonLeafNodes(arr, startIndex, i, memo);\\n            //first time it returns 0, when recursion stops at $$$\\n            int right = minSumOfNonLeafNodes(arr, i + 1, endIndex, memo);\\n\\n            int maxLeft = 0;\\n\\n            int maxRight = 0;\\n\\n            for (int j = startIndex; j <= i; j++) {\\n                maxLeft = Math.max(maxLeft, arr[j]);\\n            }\\n\\n            for (int j = i + 1; j <= endIndex; j++) {\\n                maxRight = Math.max(maxRight, arr[j]);\\n            }\\n\\n            int valueOfTheNonLeafNode = maxLeft * maxRight;\\n\\n            //first time left==0 and right==0, we have only valueOfTheNonLeafNode present - \\n            //it means we are in the lowest NOT LEAF NODE\\n            res = Math.min(res, valueOfTheNonLeafNode + left + right);\\n        }\\n        memo[startIndex][endIndex] = res;\\n        System.out.println(\"memo=[\"+startIndex+\"][\"+endIndex+\"]=\"+res);\\n\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 346487,
                "title": "greedy-o-n-2-solution-clean-c-code-with-description",
                "content": "**Description**\\n\\n* Until the size of the array is more than 1;\\n  * Find the least a[i] * a[i+1] product and accumulate it;\\n  * Remove the least element which is min of the multipliers\\n  \\n ```\\n   int mctFromLeafValues(vector<int>& a) \\n    {\\n        int sum = 0;\\n        while(a.size() > 1)\\n        {\\n            int min_product = INT_MAX;   // min(a[0]*a[1], ... a[N-1]*a[N])\\n            int me_index = -1;           // min(a[i], a[i+1])\\n            \\n            for(int i = 1; i < a.size(); ++i)\\n            {\\n                if( min_product > a[i-1]*a[i])\\n                {\\n                    me_index = a[i-1] < a[i] ? i - 1 : i;\\n                    min_product = a[i-1]*a[i];\\n                }\\n            }\\n            sum += min_product;\\n            a.erase(a.begin() + me_index);\\n        }\\n        \\n        return sum;\\n    }\\n```\\n\\t\\nPlease, upvote if you find my post useful.",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n   int mctFromLeafValues(vector<int>& a) \\n    {\\n        int sum = 0;\\n        while(a.size() > 1)\\n        {\\n            int min_product = INT_MAX;   // min(a[0]*a[1], ... a[N-1]*a[N])\\n            int me_index = -1;           // min(a[i], a[i+1])\\n            \\n            for(int i = 1; i < a.size(); ++i)\\n            {\\n                if( min_product > a[i-1]*a[i])\\n                {\\n                    me_index = a[i-1] < a[i] ? i - 1 : i;\\n                    min_product = a[i-1]*a[i];\\n                }\\n            }\\n            sum += min_product;\\n            a.erase(a.begin() + me_index);\\n        }\\n        \\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340027,
                "title": "java-dp-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[][] dp = new int[arr.length][arr.length];\\n        int[][] max = new int[arr.length][arr.length];\\n        for(int i = 0; i < arr.length; i ++) {\\n            int localMax = 0;\\n            for(int j = i; j < arr.length; j ++) {\\n                if(arr[j] > localMax) {\\n                    localMax = arr[j];\\n                }\\n                max[i][j] = localMax;\\n            }\\n        }\\n        for(int len = 1; len < arr.length; len ++) {\\n            for(int left = 0; left + len < arr.length; left ++) {\\n                int right = left + len;\\n                dp[left][right] = Integer.MAX_VALUE;\\n                if(len == 1) {\\n                    dp[left][right] = arr[left]*arr[right];\\n                } else {\\n                    for(int k = left; k < right; k ++) {\\n                        dp[left][right] = Math.min(dp[left][right], dp[left][k] + dp[k+1][right] + max[left][k]*max[k+1][right]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][arr.length-1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[][] dp = new int[arr.length][arr.length];\\n        int[][] max = new int[arr.length][arr.length];\\n        for(int i = 0; i < arr.length; i ++) {\\n            int localMax = 0;\\n            for(int j = i; j < arr.length; j ++) {\\n                if(arr[j] > localMax) {\\n                    localMax = arr[j];\\n                }\\n                max[i][j] = localMax;\\n            }\\n        }\\n        for(int len = 1; len < arr.length; len ++) {\\n            for(int left = 0; left + len < arr.length; left ++) {\\n                int right = left + len;\\n                dp[left][right] = Integer.MAX_VALUE;\\n                if(len == 1) {\\n                    dp[left][right] = arr[left]*arr[right];\\n                } else {\\n                    for(int k = left; k < right; k ++) {\\n                        dp[left][right] = Math.min(dp[left][right], dp[left][k] + dp[k+1][right] + max[left][k]*max[k+1][right]);\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0][arr.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340004,
                "title": "python-easy-dp",
                "content": "When we check root, we find that the value of root only depends on how we divide the left arr and right arr. Thus dp(i,j) = dp(i,k) + dp(k+1,j) + value of root.\\nUse the relation, and we have this dp solution.\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        self.memo = {}\\n        def dp(i,j):\\n            if j<=i:\\n                return 0\\n            if (i,j) not in self.memo:\\n                res = float(\\'inf\\')\\n                for k in range(i+1,j+1):\\n                    res = min(dp(i,k-1)+dp(k,j)+max(arr[i:k])*max(arr[k:j+1]),res)\\n                self.memo[(i,j)] = res\\n            return self.memo[(i,j)]\\n        return dp(0,len(arr)-1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        self.memo = {}\\n        def dp(i,j):\\n            if j<=i:\\n                return 0\\n            if (i,j) not in self.memo:\\n                res = float(\\'inf\\')\\n                for k in range(i+1,j+1):\\n                    res = min(dp(i,k-1)+dp(k,j)+max(arr[i:k])*max(arr[k:j+1]),res)\\n                self.memo[(i,j)] = res\\n            return self.memo[(i,j)]\\n        return dp(0,len(arr)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340080,
                "title": "dp-solution-explained-c-priority-queue",
                "content": "**Approach :**\\n* Approach towards the solution is to partition the leaf nodes at all possible places, calculate the cost for each partition and return the minimum sum of both part.\\n\\n* Non-leaf cost from any subarray from i to j (product of two maximum val) is always same. No matter how you partition the subarray.\\n\\n* We split the leaf nodes A<sub>i</sub>, A<sub>i+1</sub>, ..... , A<sub>j-1</sub>, A<sub>j</sub> between A<sub>k</sub> and A<sub>k+1</sub> where i<k<j then compute the sub problem for A<sub>i</sub>, .... , A<sub>k</sub> and A<sub>k+1</sub>, ... , A<sub>j</sub> and add both result plus the cost of multiplying two largest value in A<sub>i</sub>, ... , A<sub>j</sub>.\\n```\\n         leaf nodes :  [3,4,2,5,3,7]\\n         We can partition it in following ways:\\n         [3] | [4,2,5,3,7]\\n         [3,4] | [2,5,3,7]\\n         [3,4,2] | [5,3,7]\\n         [3,4,2,5] | [3,7]\\n         [3,4,2,5,3] | [7]\\n```\\n* Since we can see overlapping subproblems easily.\\n```\\n1. [3,4] | [2,5,3,7] ---> [3,4] || [2] | [5,3,7]\\n2. [3,4,2] | [5,3,7] \\n\\n[5,3,7] is example of overlapping subproblem.\\n```\\n\\n* We can use a 2D array to store minimum non-leaf sum from any index i to j to avoid solving repeatedly.\\n\\n* Question is similar like [MIXTURES on SPOJ](https://www.spoj.com/problems/MIXTURES/), this [explaination](https://www.youtube.com/watch?v=XHjjIJxnAJY) may help.\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return solve(arr,0,n-1,dp);\\n    }\\n    \\n    int solve(vector<int>&arr, int low, int high,vector<vector<int>> &dp){\\n        // if we have a single leaf node, then smallest possible sum\\n        // of non-leaf node is zero.\\n        if(low == high) return 0;\\n        \\n        // dp[i][j] --> smallest possible sum of value of each non-leaf node of\\n        // subarray from i to j both inclusive\\n        if(dp[low][high] != -1) return dp[low][high];\\n        \\n        // priority_queue is being used to find two max values in range [i...j]\\n        priority_queue<int> pq(arr.begin()+low, arr.begin()+high+1);\\n        int a = pq.top();\\n        pq.pop();\\n        int b = pq.top();\\n        pq.pop();\\n\\t\\t\\n        // maxProduct hold product of two maximum values in given range\\n        int maxProduct = a*b;\\n        \\n        int minSum = INT_MAX;\\n        for(int i=low; i<high; i++){\\n            minSum = min(minSum, solve(arr,low,i,dp) + solve(arr,i+1,high,dp));\\n        }\\n        return dp[low][high] = minSum + maxProduct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n         leaf nodes :  [3,4,2,5,3,7]\\n         We can partition it in following ways:\\n         [3] | [4,2,5,3,7]\\n         [3,4] | [2,5,3,7]\\n         [3,4,2] | [5,3,7]\\n         [3,4,2,5] | [3,7]\\n         [3,4,2,5,3] | [7]\\n```\n```\\n1. [3,4] | [2,5,3,7] ---> [3,4] || [2] | [5,3,7]\\n2. [3,4,2] | [5,3,7] \\n\\n[5,3,7] is example of overlapping subproblem.\\n```\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<vector<int>> dp(n,vector<int>(n,-1));\\n        return solve(arr,0,n-1,dp);\\n    }\\n    \\n    int solve(vector<int>&arr, int low, int high,vector<vector<int>> &dp){\\n        // if we have a single leaf node, then smallest possible sum\\n        // of non-leaf node is zero.\\n        if(low == high) return 0;\\n        \\n        // dp[i][j] --> smallest possible sum of value of each non-leaf node of\\n        // subarray from i to j both inclusive\\n        if(dp[low][high] != -1) return dp[low][high];\\n        \\n        // priority_queue is being used to find two max values in range [i...j]\\n        priority_queue<int> pq(arr.begin()+low, arr.begin()+high+1);\\n        int a = pq.top();\\n        pq.pop();\\n        int b = pq.top();\\n        pq.pop();\\n\\t\\t\\n        // maxProduct hold product of two maximum values in given range\\n        int maxProduct = a*b;\\n        \\n        int minSum = INT_MAX;\\n        for(int i=low; i<high; i++){\\n            minSum = min(minSum, solve(arr,low,i,dp) + solve(arr,i+1,high,dp));\\n        }\\n        return dp[low][high] = minSum + maxProduct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510611,
                "title": "greedy-approach-97-faster-well-explained",
                "content": "## IDEA :\\n**The key idea is to choose the minimum value leaf node and combine it with its neighbour which gives minimum product.**\\n\\nExample Taken from https://leetcode.com/swapnilsingh421\\narr = [5,2,3,4]\\n\\'\\'\\'\\n\\n\\t\\t  ( ) p1 \\t\\t \\t\\t\\t\\t\\t         (  ) p1\\n\\t\\t /   \\\\           \\t\\t\\t\\t\\t\\t    /    \\\\\\n\\t\\t5     ( ) p2\\t\\t\\t\\t\\t\\tp2    ( )     ( )  p3\\n\\t\\t\\t  /  \\\\ \\t\\t\\t\\t\\t\\t\\t     /   \\\\\\t  /  \\\\\\n\\t\\t p3 ( )   4 \\t\\t\\t\\t\\t\\t    5     2  3    4\\t\\n\\t\\t   /   \\\\\\n\\t\\t  2     3\\n\\n* Consider node 2 which has minimum value , it has 2 options.\\n\\n* Combine with 3 as in first diagram or combine with 5 as in second diagram. So it will go for that option which gives minimum product that is 2*3 < 2*5.\\n\\n* So it choose 1st diagram and p3 = 6 . Now we remove the node 2 from array as to compute value for node p2 only node 3 is required because 3>2 and we want max of left leaf node and max of right leaf node So only greater node proceeds.\\n* Array becomes [5,3,4] . Again we find minimum and repeat the process.\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        \\n        arr = [float(\\'inf\\')] + arr + [float(\\'inf\\')]\\n        n, res = len(arr), 0\\n        \\n        while n>3:\\n            mi = min(arr)\\n            ind = arr.index(mi)\\n            \\n            if arr[ind-1]<arr[ind+1]:\\n                res+=arr[ind-1]*arr[ind]\\n            else:\\n                res+=arr[ind+1]*arr[ind]\\n            \\n            arr.remove(mi)\\n            n = len(arr)\\n        \\n        return res\\n\\n**Thanks & Upvote If you like the Idea!!** \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy"
                ],
                "code": "## IDEA :\\n**The key idea is to choose the minimum value leaf node and combine it with its neighbour which gives minimum product.**\\n\\nExample Taken from https://leetcode.com/swapnilsingh421\\narr = [5,2,3,4]\\n\\'\\'\\'\\n\\n\\t\\t  ( ) p1 \\t\\t \\t\\t\\t\\t\\t         (  ) p1\\n\\t\\t /   \\\\           \\t\\t\\t\\t\\t\\t    /    \\\\\\n\\t\\t5     ( ) p2\\t\\t\\t\\t\\t\\tp2    ( )     ( )  p3\\n\\t\\t\\t  /  \\\\ \\t\\t\\t\\t\\t\\t\\t     /   \\\\\\t  /  \\\\\\n\\t\\t p3 ( )   4 \\t\\t\\t\\t\\t\\t    5     2  3    4\\t\\n\\t\\t   /   \\\\\\n\\t\\t  2     3\\n\\n* Consider node 2 which has minimum value , it has 2 options.\\n\\n* Combine with 3 as in first diagram or combine with 5 as in second diagram. So it will go for that option which gives minimum product that is 2*3 < 2*5.\\n\\n* So it choose 1st diagram and p3 = 6 . Now we remove the node 2 from array as to compute value for node p2 only node 3 is required because 3>2 and we want max of left leaf node and max of right leaf node So only greater node proceeds.\\n* Array becomes [5,3,4] . Again we find minimum and repeat the process.\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        \\n        arr = [float(\\'inf\\')] + arr + [float(\\'inf\\')]\\n        n, res = len(arr), 0\\n        \\n        while n>3:\\n            mi = min(arr)\\n            ind = arr.index(mi)\\n            \\n            if arr[ind-1]<arr[ind+1]:\\n                res+=arr[ind-1]*arr[ind]\\n            else:\\n                res+=arr[ind+1]*arr[ind]\\n            \\n            arr.remove(mi)\\n            n = len(arr)\\n        \\n        return res\\n\\n**Thanks & Upvote If you like the Idea!!** \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 349098,
                "title": "from-o-n-2-to-o-n-greedy",
                "content": "First thought: \\nEach time we cacluate a value for a non-leaf node, we discard the smaller leave and keep the large leave, because the smaller leave will be \"shadowed\" by the large leave forever. To minimize the cost, we want to save the large leaves to the last, and use the small leaves first. \\n\\nImplementation of above idea : \\nPick a pair with smallest product in remaining leaves, add product to sum and remove small leave until there is only one leave.\\nn <= 40 is small so I just erase the leave.\\n\\nGreedy :\\n```\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        while(arr.size() > 1) {\\n            int to_delete = 0;\\n            int min_product = INT_MAX;\\n            for(int i = 0; i < arr.size()-1; ++i) {\\n                if(arr[i]*arr[i+1] < min_product) {\\n                    to_delete = i;\\n                    min_product = arr[i]*arr[i+1];\\n                }\\n            }\\n            sum += min_product;\\n            if(arr[to_delete] > arr[to_delete+1]) {\\n                to_delete += 1;\\n            }\\n            arr.erase(arr.begin()+to_delete);\\n        }\\n        return sum;\\n    }\\n```\\n\\nThis solution is O(N^2). not bad for N <= 40. \\nWhile searching for the smallest product pair, we do a lot of recompuation for product.  lee215 \\'s solution eliminates the recomputation by maintaining a monotonic decreasing array. \\nI am here to provide some insignt maybe how he reaches this idea. \\n1. Why decreasing ? \\nBecause we use small leave once and discard them, large leave stays. \\n2. When we met a small leave, like ` [..b, a, c..] `with` b > a` and `a < c`, can we remove `a` and get product `a*min(b,c)` ?  \\nIt seems not guaranteed to be the smallest product pair in the remaining leaves at first glance. But yes it\\'s safe to do so.  Let\\'s consider the general case, after some removal the array looks like:   ` [..a, c, d..] `. If d < a , then d will get removed and c stays. if `d > a`, then `a*c < c*d`, `pair(a,c)` will have higher priority in the original greedy solution and thus to be removed first. \\n\\nLet\\'s code it up :\\n```\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        vector<int> st = {INT_MAX};\\n        for(auto& x : arr) {\\n            while(st.back() <= x) {\\n                int small = st.back();\\n                st.pop_back();\\n                sum += small * min(st.back(), x);\\n            }\\n            st.push_back(x);\\n        }\\n        for(int i = st.size()-1; i >= 2; --i) {\\n            sum += st[i] * st[i-1];\\n        }\\n        return sum; \\n    }\\n```\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        while(arr.size() > 1) {\\n            int to_delete = 0;\\n            int min_product = INT_MAX;\\n            for(int i = 0; i < arr.size()-1; ++i) {\\n                if(arr[i]*arr[i+1] < min_product) {\\n                    to_delete = i;\\n                    min_product = arr[i]*arr[i+1];\\n                }\\n            }\\n            sum += min_product;\\n            if(arr[to_delete] > arr[to_delete+1]) {\\n                to_delete += 1;\\n            }\\n            arr.erase(arr.begin()+to_delete);\\n        }\\n        return sum;\\n    }\\n```\n```\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        vector<int> st = {INT_MAX};\\n        for(auto& x : arr) {\\n            while(st.back() <= x) {\\n                int small = st.back();\\n                st.pop_back();\\n                sum += small * min(st.back(), x);\\n            }\\n            st.push_back(x);\\n        }\\n        for(int i = st.size()-1; i >= 2; --i) {\\n            sum += st[i] * st[i-1];\\n        }\\n        return sum; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 705054,
                "title": "c-code-with-detailed-explantion",
                "content": "Finally..after spending hours trying to understand this..i finally got it :).\\nQuestion comes under the specific type of merging intervals which is a pattern of dp.---\\nhttps://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns\\n\\nGeneral Pattern--\\n```\\nfor(int l = 1; l<n; l++) {\\n   for(int i = 0; i<n-l; i++) {\\n       int j = i+l;\\n       for(int k = i; k<j; k++) {\\n           dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);\\n       }\\n   }\\n}\\nreturn dp[0][n-1];\\n```\\n\\nBasically dp value of a subarray depends on how we split it.As a particular value result[k] depends on it.\\n\\nNow in this problem, lets start with the initial array.\\n\\nNOTE---THE GIVEN ARRAY REPRESENT THE ENTIRE TREE, EACH SUBARRAY(i to j) REPRESENTS SUBTREE WITH LEAVES(i to j)\\n\\narr= [3,4,1,2,6,5]\\n\\nThe array itself is its subarray.Now choosing a value of k will split it into 2 subtrees..First will have leaves from 0 to k and other will have leaves from k+1 to n-1.\\n\\nNow we could think greedily and say branch it out into 2 subtrees such that (3,4,1) comes in 1 subtree and (2,6,5) comes under 2nd subtree,so that one subtree has 1 and other subtree has 2. This is so that the quantity we are trying to minimize-*(min(leaves in left subtree)* * *min(leaves in right subtree)* becomes minimum.\\n\\nBut that need not be true since we have to know the value for other non leaf nodes.(think dp, not greedy!)\\n\\ndp[left,right[ is the sum(minimum) of all non leaf nodes from left to right\\ndp[left,right]=dp[left,k]+dp[k+1,right]+(value of the node that splits the subtree \\'left to right\\' into subtrees \\'left to k\\' and \\'k+1 to right\\'=min(max(left,k) * max(k+1,right))\\ndp[left,k] will compute the sum of non leaf nodes of the subarray with leaves from [left,k].similary dp[right,k]\\n\\nSimple!Loop through every subarray and just keep choosing k to minimize dp[i][j].dp[0][n-1] denotes the entire tree.return that!\\n\\nNow we need to keep track of max of each subarray also.\\nNotation used in code--\\nwe will use vector<vector<pair<int,int>>> dp;\\ndp[i][j].first=sum(minimum) of all non leaf nodes from left to right\\ndp[i][j].second=max of subarray \\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<pair<int,int>>> dp(n,vector<pair<int,int>>(n,{0,0}));\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i].second=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                dp[i][j].second=max(dp[i][j-1].second,arr[j]);\\n            }\\n        }\\n        for(int l=2;l<=n;l++)\\n            for(int i=0;i<n-l+1;i++)\\n            {\\n                int j=i+l-1;\\n                dp[i][j].first=INT_MAX;\\n                for(int k=i;k<j;k++)\\n                {\\n                    if(dp[i][j].first>dp[i][k].first+dp[k+1][j].first+dp[i][k].second*dp[k+1][j].second)\\n                    {\\n                        dp[i][j].first=dp[i][k].first+dp[k+1][j].first+dp[i][k].second*dp[k+1][j].second;   \\n                    }\\n            }\\n            }\\n        \\n        return dp[0][n-1].first;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nfor(int l = 1; l<n; l++) {\\n   for(int i = 0; i<n-l; i++) {\\n       int j = i+l;\\n       for(int k = i; k<j; k++) {\\n           dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+1][j]);\\n       }\\n   }\\n}\\nreturn dp[0][n-1];\\n```\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<pair<int,int>>> dp(n,vector<pair<int,int>>(n,{0,0}));\\n        for(int i=0;i<n;i++)\\n        {\\n            dp[i][i].second=arr[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                dp[i][j].second=max(dp[i][j-1].second,arr[j]);\\n            }\\n        }\\n        for(int l=2;l<=n;l++)\\n            for(int i=0;i<n-l+1;i++)\\n            {\\n                int j=i+l-1;\\n                dp[i][j].first=INT_MAX;\\n                for(int k=i;k<j;k++)\\n                {\\n                    if(dp[i][j].first>dp[i][k].first+dp[k+1][j].first+dp[i][k].second*dp[k+1][j].second)\\n                    {\\n                        dp[i][j].first=dp[i][k].first+dp[k+1][j].first+dp[i][k].second*dp[k+1][j].second;   \\n                    }\\n            }\\n            }\\n        \\n        return dp[0][n-1].first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385034,
                "title": "recursive-solutioin-beat-98-c-java",
                "content": "```\\nprivate int m_iSum = 0;\\n\\npublic int MctFromLeafValues(int[] arr) {\\n    helper(arr, 0, arr.Length - 1);\\n    return m_iSum;\\n}\\n\\nprivate int helper(int[] arr, int piStart, int piEnd) {\\n    if ( piEnd < piStart )\\n        return 0;\\n    if ( piStart == piEnd ) {\\n        return arr[piStart];\\n    } else {\\n        int liMax = piStart;\\n        for ( int i = piStart + 1; i <= piEnd; ++i )\\n            if ( arr[i] > arr[liMax] )\\n                liMax = i;\\n\\n        int liLeft = helper(arr, piStart, liMax - 1);\\n        int liRight = helper(arr, liMax + 1, piEnd);\\n\\n        m_iSum += arr[liMax] * ( liLeft + liRight );\\n        return arr[liMax];\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nprivate int m_iSum = 0;\\n\\npublic int MctFromLeafValues(int[] arr) {\\n    helper(arr, 0, arr.Length - 1);\\n    return m_iSum;\\n}\\n\\nprivate int helper(int[] arr, int piStart, int piEnd) {\\n    if ( piEnd < piStart )\\n        return 0;\\n    if ( piStart == piEnd ) {\\n        return arr[piStart];\\n    } else {\\n        int liMax = piStart;\\n        for ( int i = piStart + 1; i <= piEnd; ++i )\\n            if ( arr[i] > arr[liMax] )\\n                liMax = i;\\n\\n        int liLeft = helper(arr, piStart, liMax - 1);\\n        int liRight = helper(arr, liMax + 1, piEnd);\\n\\n        m_iSum += arr[liMax] * ( liLeft + liRight );\\n        return arr[liMax];\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 762413,
                "title": "simple-c-dp-using-memoization-64-ms",
                "content": "```\\nint find_max(int l,int h, vector <int>&ar){\\n        int maxi=0;\\n        for(int i=l;i<=h;i++){\\n            maxi=max(ar[i],maxi);\\n        }\\n        return maxi;\\n    }\\n    int fun(int l,int h, vector <int>&ar,vector <vector <int>> &dp){\\n        if(l==h)\\n            return dp[l][h]=0;\\n        if(h-l==1)\\n            return dp[l][h]=ar[l]*ar[h];\\n        int ans=INT_MAX,a,b,temp;\\n        if(dp[l][h]!=-1)\\n            return dp[l][h];\\n        for(int i=l;i<h;i++){\\n            a=find_max(l,i,ar);\\n            b=find_max(i+1,h,ar);\\n            temp=fun(l,i,ar,dp)+fun(i+1,h,ar,dp);\\n            ans=min(ans,(a*b)+temp);\\n        }\\n        return dp[l][h]=ans;\\n    }\\n    int mctFromLeafValues(vector<int>& ar) {\\n        int n=ar.size();\\n        vector <vector <int>> dp(n+1, vector <int>(n+1,-1));\\n        return fun(0,n-1,ar,dp);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nint find_max(int l,int h, vector <int>&ar){\\n        int maxi=0;\\n        for(int i=l;i<=h;i++){\\n            maxi=max(ar[i],maxi);\\n        }\\n        return maxi;\\n    }\\n    int fun(int l,int h, vector <int>&ar,vector <vector <int>> &dp){\\n        if(l==h)\\n            return dp[l][h]=0;\\n        if(h-l==1)\\n            return dp[l][h]=ar[l]*ar[h];\\n        int ans=INT_MAX,a,b,temp;\\n        if(dp[l][h]!=-1)\\n            return dp[l][h];\\n        for(int i=l;i<h;i++){\\n            a=find_max(l,i,ar);\\n            b=find_max(i+1,h,ar);\\n            temp=fun(l,i,ar,dp)+fun(i+1,h,ar,dp);\\n            ans=min(ans,(a*b)+temp);\\n        }\\n        return dp[l][h]=ans;\\n    }\\n    int mctFromLeafValues(vector<int>& ar) {\\n        int n=ar.size();\\n        vector <vector <int>> dp(n+1, vector <int>(n+1,-1));\\n        return fun(0,n-1,ar,dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1256514,
                "title": "simple-dp-solution-based-on-matrix-chain-multiplication",
                "content": "```\\nclass Solution {\\npublic:\\n    int soln(vector<int> a,int s,int e,vector<vector<int>> &dp)\\n    {\\n        if(s==e)\\n            return dp[s][e]=0;\\n        if(dp[s][e]!=-1)\\n            return dp[s][e];\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=s;i<e;i++)\\n        {\\n            int one=soln(a,s,i,dp);\\n            int two=soln(a,i+1,e,dp);\\n            int tmp=one+two+(*max_element(a.begin()+s,a.begin()+i+1))*(*max_element(a.begin()+i+1,a.begin()+e+1));\\n            \\n            ans=min(ans,tmp);\\n        }\\n        \\n        return dp[s][e]=ans;\\n    }\\n        \\n    int mctFromLeafValues(vector<int>& arr)\\n    {\\n        vector<vector<int>> dp(50,vector<int>(50,-1));\\n        return soln(arr,0,arr.size()-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int soln(vector<int> a,int s,int e,vector<vector<int>> &dp)\\n    {\\n        if(s==e)\\n            return dp[s][e]=0;\\n        if(dp[s][e]!=-1)\\n            return dp[s][e];\\n        \\n        int ans=INT_MAX;\\n        \\n        for(int i=s;i<e;i++)\\n        {\\n            int one=soln(a,s,i,dp);\\n            int two=soln(a,i+1,e,dp);\\n            int tmp=one+two+(*max_element(a.begin()+s,a.begin()+i+1))*(*max_element(a.begin()+i+1,a.begin()+e+1));\\n            \\n            ans=min(ans,tmp);\\n        }\\n        \\n        return dp[s][e]=ans;\\n    }\\n        \\n    int mctFromLeafValues(vector<int>& arr)\\n    {\\n        vector<vector<int>> dp(50,vector<int>(50,-1));\\n        return soln(arr,0,arr.size()-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 646785,
                "title": "greedy-approach-optimal-merge-pattern-python",
                "content": "**Procedure**\\n\\t\\t1. \\tFind out minimum value from the list and compare it with its neighbour to get minimum product (**a non-leaf node**).\\n\\t\\t2. \\tRemove both value and insert new value in the list while maintaining the order.\\n\\t\\t3. \\tRepeat step 1 and step 2 till we left with single value in the list and that will be root node of newly constructed Tree.\\n\\t\\t4. \\tReturn list that will contain a single value(**Your Answer**).\\n```\\n def mctFromLeafValues(self, arr):\\n        ans = 0\\n        while len(arr) > 1:\\n            minIndex = arr.index(min(arr))\\n            if 0 < minIndex < len(arr) - 1:\\n                ans += min(arr[minIndex - 1], arr[minIndex + 1]) * arr[minIndex]\\n            else:  #handle corner cases : when minimun value is either first value or last value of the list\\n                ans += arr[1 if minIndex == 0 else minIndex - 1] * arr[minIndex]\\n            arr.pop(minIndex)\\n        return ans # OR return arr[0]\\n```\\n\\n**Application:**   Merge n files into a single large file such that it get merge in minimum number of overhead movement.",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\n def mctFromLeafValues(self, arr):\\n        ans = 0\\n        while len(arr) > 1:\\n            minIndex = arr.index(min(arr))\\n            if 0 < minIndex < len(arr) - 1:\\n                ans += min(arr[minIndex - 1], arr[minIndex + 1]) * arr[minIndex]\\n            else:  #handle corner cases : when minimun value is either first value or last value of the list\\n                ans += arr[1 if minIndex == 0 else minIndex - 1] * arr[minIndex]\\n            arr.pop(minIndex)\\n        return ans # OR return arr[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 929961,
                "title": "java-solution-using-stack-time-o-n-space-o-n",
                "content": "```\\nThis solution is easy to understand.\\nTake array [6,2,4,5] as an example.\\nActually what we do is:\\nFor[6,2,4,5], 2 is the smallest, 2 * Math.min(6, 4) = 2 * 4 = 8;\\nFor[6, 4, 5], 4 is the samllest, 4 * Math.min(6, 5) = 4 * 5 = 20;\\nFor[6,5], 6*5 = 30.\\nSo result = 8 + 20 + 30 = 58.\\nThe key is that if one element e is smaller than its two neighbors, result adds e * Math.min(two neighbors).\\n\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        int res = 0;\\n        for(int i = 0; i < arr.length; i++) {\\n            while(stack.peek() <= arr[i]) {\\n                res += stack.pop() * Math.min(arr[i], stack.peek());\\n            }\\n            stack.push(arr[i]);\\n        }\\n        while(stack.size() > 2) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nThis solution is easy to understand.\\nTake array [6,2,4,5] as an example.\\nActually what we do is:\\nFor[6,2,4,5], 2 is the smallest, 2 * Math.min(6, 4) = 2 * 4 = 8;\\nFor[6, 4, 5], 4 is the samllest, 4 * Math.min(6, 5) = 4 * 5 = 20;\\nFor[6,5], 6*5 = 30.\\nSo result = 8 + 20 + 30 = 58.\\nThe key is that if one element e is smaller than its two neighbors, result adds e * Math.min(two neighbors).\\n\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        int res = 0;\\n        for(int i = 0; i < arr.length; i++) {\\n            while(stack.peek() <= arr[i]) {\\n                res += stack.pop() * Math.min(arr[i], stack.peek());\\n            }\\n            stack.push(arr[i]);\\n        }\\n        while(stack.size() > 2) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479412,
                "title": "c-dp-variation-of-classical-dp-problem-mcm",
                "content": "Slight Concept of trees and Matrix Chain Multiplication\\n\\n```\\nclass Solution {\\n    \\n    int max(vector<int> &arr, int s ,int e)\\n    {\\n        int mx = 0;\\n        \\n        for(int i=s ;i<=e ;i++)\\n        {\\n            mx = std::max(arr[i] , mx);\\n        }\\n        \\n        return mx;\\n    }\\n    \\n    int dp[50][50];\\n    \\n    int solve(vector<int> &arr, int s, int e)\\n    {\\n        if(s==e)\\n        {\\n            return 0;\\n        }\\n        \\n        if(dp[s][e]!=-1) return dp[s][e];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i=s;i < e; i++)\\n        {\\n            int lsum = max(arr, s , i);\\n            int rsum = max(arr , i+1 , e);\\n                \\n            ans = min( ans, solve(arr, s, i) + solve(arr , i+1 , e) + lsum*rsum);\\n        }\\n        \\n        return dp[s][e] = ans;\\n    }\\n    \\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        memset(dp, -1 , sizeof(dp));\\n        return solve(arr, 0 , arr.size()-1);\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int max(vector<int> &arr, int s ,int e)\\n    {\\n        int mx = 0;\\n        \\n        for(int i=s ;i<=e ;i++)\\n        {\\n            mx = std::max(arr[i] , mx);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 803891,
                "title": "c-stack-beats-100",
                "content": "General idea: \\nFor each element in the array, if may belong to either its left side or right side, once an element is multiplied by a number greater than it, it will no longer be used.\\n\\nSolution:\\nMaintain a decreasing stack. \\nFor `int a : arr` :\\nIf `a <= st.top()`, just push it to the stack.\\nIf `a > st.top()`, make a comparison between the new element `a` and the second top element in stack, multiply the smaller one by `st.top()` and add it to the `sum`. The top element is popped out of the stack, which means it  will no longer be used in later calculation. Repeatedly pop and make comparison until we can push `a` into the decreasing stack.\\nAfter iteration through the array, iterate through the remaining stack and add the product of adjacent elements to the sum until the stack becomes empty.\\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        stack<int> st;\\n        int sum = 0;\\n        int t;\\n        for (int a : arr) {\\n            while (!st.empty() && a > st.top()) {\\n                t = st.top();\\n                st.pop();\\n                if (st.empty()) sum += t*a;\\n                else sum += t*min(st.top(), a);\\n            }\\n            st.push(a);\\n        }\\n        while (!st.empty()) {\\n            t = st.top();\\n            st.pop();\\n            if (!st.empty()) sum += st.top()*t;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        stack<int> st;\\n        int sum = 0;\\n        int t;\\n        for (int a : arr) {\\n            while (!st.empty() && a > st.top()) {\\n                t = st.top();\\n                st.pop();\\n                if (st.empty()) sum += t*a;\\n                else sum += t*min(st.top(), a);\\n            }\\n            st.push(a);\\n        }\\n        while (!st.empty()) {\\n            t = st.top();\\n            st.pop();\\n            if (!st.empty()) sum += st.top()*t;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410634,
                "title": "javascript-recursion-memo-stack-3-solutions-explained",
                "content": "This post has** 3 solutions**, whose complexity improves gradually.\\n\\nSolution1 and solution 2: (Recursive Partition)\\nEach partion is a simulation of the problem. Each partition is a unique ways to build a tree. Each tree has a cost. The minimum cost is calculated by comparing all the partition possibilites. \\n\\n**Solution 1** TLEs due to dupication in calculation. \\n**Solution 2** passes by using a memo array to record the cost of subtrees and reuse them.\\n**Solution 3** is a O(n) stack solution. \\n\\nSolution 3: How did I think of it? I did not. I had to refer to [Lee\\'s answer](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space). He already explained it very well. \\n\\nLet me explain it again:\\n- Let\\'s visualize this from **bottom up**.\\n- Two neighboring nodes (a, b) can from a mini tree.\\n- The cost of this minitree is the product of the neighbors (a * b). \\n- (Actually, every non-leaf node\\'s cost is the product of 2 elements)\\n- After a mini tree is formed, bigger trees will form. \\n- The bigger tree\\'s cost is the product of it\\'s max left and max right leaf value.\\n- What happens to the smaller nodes? They become invisible. \\n\\nThis problem is an **erase small numbers with minimum cost** problem.\\n\\nA node (a) can form a tree with it\\'s left neighbor (l) or right neighbor(r). \\ncost = a * l OR a * r\\nHow to get the min cost?\\nminCost = a * Math.min(l, r) \\n \\nNow it becomes a stack problem, which can be solved by a descending stack. This is smilar to [42. trapping rain water](https://leetcode.com/problems/trapping-rain-water) problem now. , and also similar to the [503. find next great element II ](https://leetcode.com/problems/next-greater-element-ii/)problem, like Lee said. The code is at the bottom.\\n \\nSolution 1: recursion TLE - O(N^3)\\n\\n```\\nvar mctFromLeafValues = function(arr) {\\n     \\n    return calcMctFromLeafValues(arr, 0, arr.length-1);\\n    \\n    function calcMctFromLeafValues(arr, l, r){\\n        // leaf node, don\\'t add to sum        \\n        if (l===r) {\\n            return 0;\\n        }\\n        // init minSum to be Infinity so that it can be easily overwritten later\\n        let minSum = Infinity;\\n\\n        // p stands for partition, cuts after p, so p needs to be smaller than r\\n        // e.g. in the array [0, 1] and l = 0, r = 1\\n        // p can only be 0, that means cuts in between\\n        for (let p = l; p < r; p++) {\\n            \\n            const leftMaxLeaf = Math.max(...arr.slice(l, p + 1));\\n            const rightMaxLeaf = Math.max(...arr.slice(p + 1, r + 1));\\n\\n            let leftSubtreeSum = calcMctFromLeafValues(arr, l, p);\\n            let rightSubtreeSum = calcMctFromLeafValues(arr, p+1, r);\\n            \\n            //tally the final result\\n            minSum = Math.min(minSum, leftMaxLeaf*rightMaxLeaf + leftSubtreeSum + rightSubtreeSum);\\n        }\\n        return minSum;\\n    }\\n}\\n\\n```\\n\\nSolution 2: solution 1 + memo (better)\\n\\n```\\nvar mctFromLeafValues = function(arr) {\\n    const memo = [... new Array(arr.length)].map(() => new Array(arr.length).fill(0))\\n    \\n    return calcMctFromLeafValues(arr, 0, arr.length-1);\\n    \\n    function calcMctFromLeafValues(arr, l, r){\\n        if (memo[l][r] !== 0) {\\n            return memo[l][r];\\n        }\\n        // leaf node, don\\'t add to sum        \\n        if (l===r) {\\n            return 0;\\n        }\\n        \\n        // init minSum to be Infinity so that it can be easily overwritten later\\n        let minSum = Infinity;\\n\\n        // p stands for partition, cuts after p, so p needs to be smaller than r\\n        // e.g. in the array [0, 1] and l = 0, r = 1\\n        // p can only be 0, that means cuts in between\\n        for (let p = l; p < r; p++) {\\n            \\n            const leftMaxLeaf = Math.max(...arr.slice(l, p + 1));\\n            const rightMaxLeaf = Math.max(...arr.slice(p + 1, r + 1));\\n\\n            let leftSubtreeSum = calcMctFromLeafValues(arr, l, p);\\n            let rightSubtreeSum = calcMctFromLeafValues(arr, p+1, r);\\n            \\n            //tally the final result\\n            minSum = Math.min(minSum, leftMaxLeaf*rightMaxLeaf + leftSubtreeSum + rightSubtreeSum);\\n        }\\n        memo[l][r] = minSum;\\n        return minSum;\\n    }\\n}\\n```\\n\\nsolution 3: monotonic stack O(N)\\n\\n```\\nvar mctFromLeafValues = function(arr) {\\n    const desStack = [];\\n    let res = 0;\\n    for (let curNode of arr){\\n        while (desStack.length && curNode >= desStack[desStack.length - 1]) {\\n            const smallNode = desStack.pop();\\n            const slighterLargerNode = !desStack.length ? curNode : Math.min(desStack[desStack.length - 1], curNode);\\n            res += smallNode * slighterLargerNode\\n        }\\n        desStack.push(curNode);\\n    }\\n    while(desStack.length >= 2) {   // check size\\n        res += desStack.pop() * desStack[desStack.length - 1];\\n    }\\n    return res;\\n};\\n```\\n \\n",
                "solutionTags": [],
                "code": "```\\nvar mctFromLeafValues = function(arr) {\\n     \\n    return calcMctFromLeafValues(arr, 0, arr.length-1);\\n    \\n    function calcMctFromLeafValues(arr, l, r){\\n        // leaf node, don\\'t add to sum        \\n        if (l===r) {\\n            return 0;\\n        }\\n        // init minSum to be Infinity so that it can be easily overwritten later\\n        let minSum = Infinity;\\n\\n        // p stands for partition, cuts after p, so p needs to be smaller than r\\n        // e.g. in the array [0, 1] and l = 0, r = 1\\n        // p can only be 0, that means cuts in between\\n        for (let p = l; p < r; p++) {\\n            \\n            const leftMaxLeaf = Math.max(...arr.slice(l, p + 1));\\n            const rightMaxLeaf = Math.max(...arr.slice(p + 1, r + 1));\\n\\n            let leftSubtreeSum = calcMctFromLeafValues(arr, l, p);\\n            let rightSubtreeSum = calcMctFromLeafValues(arr, p+1, r);\\n            \\n            //tally the final result\\n            minSum = Math.min(minSum, leftMaxLeaf*rightMaxLeaf + leftSubtreeSum + rightSubtreeSum);\\n        }\\n        return minSum;\\n    }\\n}\\n\\n```\n```\\nvar mctFromLeafValues = function(arr) {\\n    const memo = [... new Array(arr.length)].map(() => new Array(arr.length).fill(0))\\n    \\n    return calcMctFromLeafValues(arr, 0, arr.length-1);\\n    \\n    function calcMctFromLeafValues(arr, l, r){\\n        if (memo[l][r] !== 0) {\\n            return memo[l][r];\\n        }\\n        // leaf node, don\\'t add to sum        \\n        if (l===r) {\\n            return 0;\\n        }\\n        \\n        // init minSum to be Infinity so that it can be easily overwritten later\\n        let minSum = Infinity;\\n\\n        // p stands for partition, cuts after p, so p needs to be smaller than r\\n        // e.g. in the array [0, 1] and l = 0, r = 1\\n        // p can only be 0, that means cuts in between\\n        for (let p = l; p < r; p++) {\\n            \\n            const leftMaxLeaf = Math.max(...arr.slice(l, p + 1));\\n            const rightMaxLeaf = Math.max(...arr.slice(p + 1, r + 1));\\n\\n            let leftSubtreeSum = calcMctFromLeafValues(arr, l, p);\\n            let rightSubtreeSum = calcMctFromLeafValues(arr, p+1, r);\\n            \\n            //tally the final result\\n            minSum = Math.min(minSum, leftMaxLeaf*rightMaxLeaf + leftSubtreeSum + rightSubtreeSum);\\n        }\\n        memo[l][r] = minSum;\\n        return minSum;\\n    }\\n}\\n```\n```\\nvar mctFromLeafValues = function(arr) {\\n    const desStack = [];\\n    let res = 0;\\n    for (let curNode of arr){\\n        while (desStack.length && curNode >= desStack[desStack.length - 1]) {\\n            const smallNode = desStack.pop();\\n            const slighterLargerNode = !desStack.length ? curNode : Math.min(desStack[desStack.length - 1], curNode);\\n            res += smallNode * slighterLargerNode\\n        }\\n        desStack.push(curNode);\\n    }\\n    while(desStack.length >= 2) {   // check size\\n        res += desStack.pop() * desStack[desStack.length - 1];\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 746404,
                "title": "explanation-of-the-two-o-n-2-greedy-algorithms",
                "content": "**Algorithm1**:  ([https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space])\\nWe remove the element form the smallest to bigger.\\nWe check the min(left, right),\\nFor each element a, cost = min(left, right) * a\\n\\n**explaination**\\nThis algorithm is looking for \"V\" shape in the array and remove value at the bottom of the \"V\".\\n\\nTo better understand it, let\\'s first find out the minium (denoted by M) in the array and split the array into three parts:  ```left_array, [M], right_array```. Let\\'s compare the optimal tree on ```left_array+[M] +right_array ``` with the tree on ```left_array + right_array```.  \\n\\nLet\\'s assume the optimal algorithm on ```left_array+[M] +right_array``` pops out min at step k+1.\\nAfter K step,  we have ```left_array(k) +[M] +right_array(k)``` in the optimal algorithm and we can exactly mimic this process on ```left_array + right_array``` and after k step we have ```left_array(k)+ right_array(k)```. At step K+1, we pop [M], and the array becomes ```left_array(k) +[M] +right_array(k) -> left_array(k) + right_array(k)``` and the cost of this step is ```M * min(left_array(k)[-1], right_array(k)[0])```. \\n\\nNote that the ```min(left_array(k)[-1], right_array(k)[0])``` is **greater or equal** to ```min(left_array[-1], right_array[0])```. Now let\\'s consider the following K+1 step on ```left_array, [M], right_array```:\\nstep 1: remove [M] with cost ```M*min(left_array[-1], right_array[0])``` \\nfor step 2:k+1: we follow the K steps obtained above for ```left_array+ right_array -> left_array(k) + right_array(k)```. We know this process costs smaller or equal to the optimal process. Therefore we could always remove the samllest element with the cost``` M*min(left_array[-1], right_array[0])``` at step 1 and do it iteratively.\\n\\n\\n**Algorithm2**: \\n1 find the pair of adjacent elements with the smallest product  P in the array and add p to the total cost\\n2 remove the smaller one from the array\\n3 repeat step 1 and 2 recusively \\n\\n**Proof**\\nThe proof is based on mathematical induction. I\\'ll show that the greedy algorithm works for arr with length n based on the assumption that the algorihtm works for any arr with length less than n.\\n\\n**First**, we need to check if greedy algirthm holds for the simple cases. iIt\\'s trivial when the len(arr) = 1 or 2. When the len(arr) = 3, there are three cases  [2,1,3] : middle element is the smallest, [1,2,3]: middle element is the second smallest, [1,3,2]: the middle element is the largest. When the middle element is the smallest or the largest, the order of merging leaves doesn\\'t matter. While the second smallest element is in the middle, greedy merging strategy does yield smallest cost.\\n\\n**second**, for a array with length L, let\\'s check and compare the left subtree and right subtree of the root node from the optimal tree structure and the tree structure derived by the greedy algorithm. We know that the leaves from the optimal left subtree are corrsponding to arr[:b_opt] and leaves from the right subtree are from arr[b_opt: ] while the their counterparts from the greedy algorithm are arr[:b_greedy] and arr[b_greedy:].  For the optimal tree, left subtree and right subtree must be optimal as well for arr[:b_opt] and arr[b_opt: ] (since the root value is detemined by b_opt). Since we assume that greedy algorithm works for array with length <= n-1 then we know greedy algorithm works for arr[:b_opt] and arr[:b_opt]. \\n\\nThen let\\'s compare the optimal algorithm with the greedy algorithm. The optimal algorithm will use greedy algorithm within arr[:b_opt] and arr[b_opt: ], which means initially, it will find the smallest product for adjacent pairs except for arr[b_opt-1] and arr[b_opt]. If the smallest product is not from pair (arr[b_opt-1] and arr[b_opt]), then optimal algorithm and greedy algorithm will be the same for this specific step. They will have the same value for the non leaf node and remove the same element in the array. Therefore, without lose of generality, we could safely assume that if greedy algorithm is not the optimal one, then these two algorithms would differ at the first step.\\n\\nLet\\'s denote the first pair from the optimal algorithm as arr[opt-1] and arr[opt]. There are two cases: \\n\\n**case 1**: neither opt-1 nor opt is in posiiton [b_opt-1, b_opt], which means the pair from the optimal algorithm is not overlapped with the pair from the greedy algorithm. After running the algorithm for 1 step\\n\\n**optimal**: [ ...,leaf(opt-1), leaf(opt),..., leaf(b_opt-1), leaf(b_opt),...] -> [...,max(leaf(opt-1), leaf(opt)),..., leaf(b_opt-1), leaf(b_opt)...]\\n\\n**greedy**: [ ...,leaf(opt-1), leaf(opt),..., leaf(b_opt-1), leaf(b_opt),...] -> [..., leaf(opt-1), leaf(opt),..., max(leaf(b_opt-1), leaf(b_opt))...]\\n\\nNote, right now the length of the array is n-1, so we now that greedy algorithm is optimal for the n-1 array. Therefore, the optimal array sequence would be like the following:\\n\\n**optimal**:  [ ...,leaf(opt-1), leaf(opt),..., leaf(b_opt-1), leaf(b_opt),...] -> [...,max(leaf(opt-1), leaf(opt)),..., leaf(b_opt-1), leaf(b_opt)...] ->   [...,max(leaf(opt-1), leaf(opt)),...,  max(leaf(b_opt-1), leaf(b_opt)) ...] \\n\\nNow let\\'s look at the greedy one. It will be the same since leaf(opt-1) * leaf(opt)  < leaf(b_opt)*leaf(b_opt+1) <  max(leaf(b_opt-1), leaf(b_opt))*leaf(b_opt+1)   and leaf(opt-1) * leaf(opt)  < leaf(b_opt-1)*leaf(b_opt) <  max(leaf(b_opt-1), leaf(b_opt))*leaf(b_opt-1), we know that greedy algorithm will merge  leaf(opt-1) and leaf(opt).\\n**greedy**:[ ...,leaf(opt-1), leaf(opt),..., leaf(b_opt-1), leaf(b_opt),...] -> [...,max(leaf(opt-1), leaf(opt)),..., leaf(b_opt-1), leaf(b_opt)...] ->   [...,max(leaf(opt-1), leaf(opt)),...,  max(leaf(b_opt-1), leaf(b_opt)) ...] \\n\\nSo we know for case 1, greedy algorithm is the optimal.\\n\\n**case 2**: opt-1 or opt is overlapped with b_opt-1 or b_opt. Without loss of generality, let\\'s assume  opt = b_op-1\\n\\n**optimal**: [ ...,leaf(opt-1), leaf(opt = b_opt-1), leaf(b_opt),...] -> [ ..., max (leaf(opt-1), leaf(opt)), leaf(b_opt),...]\\n\\n**greedy**: [ ...,leaf(opt-1), leaf(opt = b_opt-1), leaf(b_opt),...] -> [ ..., leaf(opt-1), max(leaf(b_opt-1), leaf(b_opt) ),...]\\n\\nthere are another two situations:\\n\\n**case 2.1** leaf(opt = b_opt-1) < leaf(b_opt). Note that in this case leaf(opt-1) < leaf(opt) since leaf(opt) > leaf(b_opt) otherwise leaf(b_opt)*leaf(opt) won\\'t be the samllest pair.  [  max (leaf(opt-1), leaf(opt)), leaf(b_opt)] = [ leaf(opt-1),leaf(b_opt)] and [ leaf(opt-1), max(leaf(b_opt-1),leaf(b_opt) ))] = [ leaf(opt-1),leaf(b_opt)] . In this case, two algorithms remove the same value but greedy algorithm yield smaller costs, which is contradict with the fact that optimal algorithm has the smallest costs. Therefore we know greedy algorithm is the optimal one for this case.\\n\\n**case 2.2** leaf(opt = b_opt-1) > leaf(b_opt). In this case, apply greedy algorithm on the right hand array with length = n-1 will yield the following sequence:\\n\\n**optimal** [ ...,leaf(opt-1), leaf(opt = b_opt-1), leaf(b_opt),...] -> [ ..., max (leaf(opt-1), leaf(opt)), leaf(b_opt),...] -> [ ..., max (leaf(opt-1), leaf(opt)),...]\\n\\nThe key observation is that max (leaf(opt-1), leaf(opt)) * leaf(b_opt) will be the smallest pair since leaf(opt-1) * leaf(opt) is the second smallest pair and max (leaf(opt-1), leaf(opt)) * leaf(b_opt) < leaf(opt-1) * leaf(opt).\\n\\nSimilarly, greedy algorithm will yeild the exactly the same array for the second step while has smaller cost among these three consecutive elements.\\n**greedy**: [ ...,leaf(opt-1), leaf(opt = b_opt-1), leaf(b_opt),...] -> [ ..., leaf(opt-1), leaf(opt),...] -> [ ..., max (leaf(opt-1), leaf(opt)),...]\\n\\nThis imples greedy algorithm has smaller cost. Combine case 1 and case 2, we know greedy algorithm is the optimal algorithm.\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```left_array, [M], right_array```\n```left_array+[M] +right_array ```\n```left_array + right_array```\n```left_array+[M] +right_array```\n```left_array(k) +[M] +right_array(k)```\n```left_array + right_array```\n```left_array(k)+ right_array(k)```\n```left_array(k) +[M] +right_array(k) -> left_array(k) + right_array(k)```\n```M * min(left_array(k)[-1], right_array(k)[0])```\n```min(left_array(k)[-1], right_array(k)[0])```\n```min(left_array[-1], right_array[0])```\n```left_array, [M], right_array```\n```M*min(left_array[-1], right_array[0])```\n```left_array+ right_array -> left_array(k) + right_array(k)```\n``` M*min(left_array[-1], right_array[0])```",
                "codeTag": "Unknown"
            },
            {
                "id": 514108,
                "title": "c-greedy-algorithm-with-comments-explanation-worst-time-o-n-2",
                "content": "The problem asks us to find the **smallest possible sum** of the values of each non-leaf node. We know that each **non-leaf node is a product of two leaf nodes** and we only get to use the biggest value in the left/right subtree. This means we want to start with the smallest number possible and we only get to use it once (since it will be replaced after one iteration)\\n\\nAn easier problem would be if order does not matter:\\n**Ex:** if we have [4,2,3,1]\\nIn this example, we can sort the array to get [1,2,3,4]\\nThen we just need to take the sum of (1 * 2) + (2 * 3) + (3 * 4)  = 20\\n(note: we only used 1 once then since 2 is bigger, we chose 2 as our next smallest number)\\n\\nUltimately, we want to find a way to find the smallest product from the array at each iteration\\nThen, delete the smaller value from the pair after each iteration\\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        while(arr.size() > 1){\\n\\t\\t\\t// for each iteration, we want the minimal product\\n            int minPrd = INT_MAX; \\n            int minIdx  = -1;\\n            for(int i = 0; i < arr.size() - 1; i++){\\n                int temp = arr[i] * arr[i + 1];\\n                if(temp < minPrd){\\n                    minPrd = temp;\\n                    minIdx = i;\\n                }\\n            }\\n            res += minPrd;\\n            // leave the bigger number of the two and erase the smaller one\\n\\t\\t\\tarr[minIdx] = max(arr[minIdx], arr[minIdx + 1]);\\n            arr.erase(arr.begin() + (minIdx + 1));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        while(arr.size() > 1){\\n\\t\\t\\t// for each iteration, we want the minimal product\\n            int minPrd = INT_MAX; \\n            int minIdx  = -1;\\n            for(int i = 0; i < arr.size() - 1; i++){\\n                int temp = arr[i] * arr[i + 1];\\n                if(temp < minPrd){\\n                    minPrd = temp;\\n                    minIdx = i;\\n                }\\n            }\\n            res += minPrd;\\n            // leave the bigger number of the two and erase the smaller one\\n\\t\\t\\tarr[minIdx] = max(arr[minIdx], arr[minIdx + 1]);\\n            arr.erase(arr.begin() + (minIdx + 1));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 457914,
                "title": "javascript-solution-dp-greedy",
                "content": "### The idea - DP/DFS/Recursion\\n1. Use divide and conquer methodolgy, the cost of building 1 node can be calculated by the cost of building nodes in the left part + the cost of building nodes in the right part + the cost of the root node (product of the maximun number to its left and right).\\n2. We can try every slice point to split the array in to left and right until there\\'s only 1 element left\\n``` javascript\\nvar mctFromLeafValuesDFS = function(arr) {\\n    let dp = [];\\n    let dfs = function(i, j) {\\n        if (!dp[i]) dp[i] = []; // initialize\\n        if (j<=i) return 0; // only 1 element\\n        if (dp[i][j]) return dp[i][j];\\n        let res = Number.MAX_VALUE;\\n        for (let k=i+1;k<=j;k++) { // try different slicing point\\n            res = Math.min(dfs(i, k-1) + dfs(k, j) + Math.max(...arr.slice(i,k)) * Math.max(...arr.slice(k, j+1)), res);\\n        }\\n        dp[i][j] = res;\\n        return dp[i][j];\\n    }\\n    return dfs(0, arr.length-1);\\n};\\n```\\n### The idea - Merge Intervals DP\\n Can be translated into:\\n Give some piles of nodes, merge them into 1 pile.\\n You can only merge adjacent piles, the cost is the product of the largest nodes in the two piles.\\n```\\nvar mctFromLeafValues = function(arr) {\\n    const N = arr.length;\\n    let dp = new Array(N).fill(0).map(()=>new Array(N).fill(0));\\n    \\n    for (let l=2;l<=N;l++) { // merge l piles to 1 pile\\n        for (let i = 0; i <= N - l;i++) { // start position \\n            let j = i + l - 1; // end position\\n            dp[i][j] = Number.MAX_VALUE; // initialize\\n            for (let k=i;k<j;k++) { // split point\\n                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k+1][j] + Math.max(...arr.slice(i,k+1)) * Math.max(...arr.slice(k+1, j+1)));\\n            }\\n        }\\n    }\\n    return dp[0][arr.length-1];\\n}\\n```\\n### The idea - Greedy\\n1. In order the minimize the final cost, we want to minimize the repetitive calculations for large numbers.\\n2. The idea is to always combine the smallest product pair for the current array, and remove the smaller number from the array since it will never be used again.\\n``` javascript\\nvar mctFromLeafValuesGreedy = function(arr) {\\n    let cost = 0;\\n    while (arr.length>1) {\\n        let minProduct = Number.MAX_VALUE;\\n        let minId = -1;\\n        for (let i=0;i<arr.length-1;i++) {\\n            let curProduct = arr[i] * arr[i+1];\\n            if (curProduct < minProduct) {\\n                minProduct = curProduct;\\n                minId = arr[i]<arr[i+1]?i:i+1;\\n            }\\n        }\\n        cost+=minProduct;\\n        arr.splice(minId, 1);\\n    }\\n    return cost;\\n} \\n```\\n### Version 2\\n``` javascript\\nvar mctFromLeafValues = function(arr) {\\n    let cost = 0;\\n    while (arr.length > 1) {\\n        let minNum = Math.min(...arr);\\n        let minId = arr.indexOf(minNum);\\n        if (minId==0) cost+= arr[minId+1] * arr[minId];\\n        else if (minId==arr.length-1) cost+=arr[minId-1] * arr[minId];\\n        else cost+=arr[minId] * Math.min(arr[minId-1], arr[minId+1]); \\n        arr.splice(minId, 1);\\n    }\\n    return cost;\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javascript\\nvar mctFromLeafValuesDFS = function(arr) {\\n    let dp = [];\\n    let dfs = function(i, j) {\\n        if (!dp[i]) dp[i] = []; // initialize\\n        if (j<=i) return 0; // only 1 element\\n        if (dp[i][j]) return dp[i][j];\\n        let res = Number.MAX_VALUE;\\n        for (let k=i+1;k<=j;k++) { // try different slicing point\\n            res = Math.min(dfs(i, k-1) + dfs(k, j) + Math.max(...arr.slice(i,k)) * Math.max(...arr.slice(k, j+1)), res);\\n        }\\n        dp[i][j] = res;\\n        return dp[i][j];\\n    }\\n    return dfs(0, arr.length-1);\\n};\\n```\n```\\nvar mctFromLeafValues = function(arr) {\\n    const N = arr.length;\\n    let dp = new Array(N).fill(0).map(()=>new Array(N).fill(0));\\n    \\n    for (let l=2;l<=N;l++) { // merge l piles to 1 pile\\n        for (let i = 0; i <= N - l;i++) { // start position \\n            let j = i + l - 1; // end position\\n            dp[i][j] = Number.MAX_VALUE; // initialize\\n            for (let k=i;k<j;k++) { // split point\\n                dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k+1][j] + Math.max(...arr.slice(i,k+1)) * Math.max(...arr.slice(k+1, j+1)));\\n            }\\n        }\\n    }\\n    return dp[0][arr.length-1];\\n}\\n```\n``` javascript\\nvar mctFromLeafValuesGreedy = function(arr) {\\n    let cost = 0;\\n    while (arr.length>1) {\\n        let minProduct = Number.MAX_VALUE;\\n        let minId = -1;\\n        for (let i=0;i<arr.length-1;i++) {\\n            let curProduct = arr[i] * arr[i+1];\\n            if (curProduct < minProduct) {\\n                minProduct = curProduct;\\n                minId = arr[i]<arr[i+1]?i:i+1;\\n            }\\n        }\\n        cost+=minProduct;\\n        arr.splice(minId, 1);\\n    }\\n    return cost;\\n} \\n```\n``` javascript\\nvar mctFromLeafValues = function(arr) {\\n    let cost = 0;\\n    while (arr.length > 1) {\\n        let minNum = Math.min(...arr);\\n        let minId = arr.indexOf(minNum);\\n        if (minId==0) cost+= arr[minId+1] * arr[minId];\\n        else if (minId==arr.length-1) cost+=arr[minId-1] * arr[minId];\\n        else cost+=arr[minId] * Math.min(arr[minId-1], arr[minId+1]); \\n        arr.splice(minId, 1);\\n    }\\n    return cost;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1041415,
                "title": "c-short-o-n-time-o-1-space-stack-solution-take-it-or-leave-it",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& a) {\\n        int i = 0, ret = 0;\\n        for (auto &x : a) {\\n            while (i && a[i - 1] < x) \\n                ret += a[--i] * ((i && a[i - 1] < x) ? a[i - 1] : x);\\n            a[i++] = x;\\n        }\\n        while (i > 1)  \\n            ret += a[--i] * a[i - 1];\\n        return ret;\\n    }\\n};\\n```\\n\\n**Edit**\\nI don\\'t know how much you know about this problem, but the solution is the same as any other here, just the code may look ... shorter. It is a greedy approach: find minimum pair and combine them.\\n\\nSome great explanations you can always find in the top upvoted discussion, they do a great job :), that\\'s why they are upvoted lul. Here, I will only provide some ideas that are used for this code.\\n\\n* * Greedy approach, implicit stack implementation.\\n* Implicit stack is the reused input vector. You might find similar ideas elsewhere, the whole point is to use input vector to store stack elements. For that here I just introduce pointer ```i``` to keep track how many elements I have in the stack. ```a[i-1]``` is my last element in the stack and obviously if ```i==0``` means I have no elements.\\n* The whole point of the greedy approach is to combine two close elements. In fact you can freely combine any local minima with next lowest element. E.g. :: [5,4,3,6,2,5]. In this example, 3 and 2 are local minima. Why? Cause elements next to them are larger; 3 has 4 on the left and 6 on the right; 2 has 6 on the left and 5 on the right. The whole idea is that you can combine either of them and remove it form the array. So let\\'s say I combine 3 and 4 (cause 4 < 6, gives me less value), then remove 3 from the array  and we end up with [5,4,6,2,5]. And so on, just proceed with the same greedy approach. \\n* If you do bruteforce greedy, you\\'d do O(N^2): just seach for some local minima, then delete that element. But luckily you can use stack for some quick check if that element is a some local minima. And well remove it from the stack if it turns out to be so in O(1).\\n*   So example: [10,9,8,7,6,5,4,2,11,1]. In this example you can keep all those elements in decreasing order up to 2 and then when you see 11 you\\'ll realize it is bigger than 2 right? and because you\\'re keeping stack in decreasing order you know that 2 is the smallest element and the element before it is bigger too. That must mean that 2 is the local minima! That\\'s it just check if previous element is smaller than currrent, 4 < 11? Sure, 4 is smaller, then do 4 * 2 and add to your return answer. Oh, and update your stack: [10,9,8,7,6,5,4], cur = 11. You can notice that 4 is now the local minima... well just repeat.\\n*   A note about the line ```ret += a[--i] * ((i && a[i - 1] < x) ? a[i - 1] : x)```. As I was trying to tell ```a``` with a pointer ```i``` is my implicit stack. Thus, what it says here is that ```a[--i]``` is just me popping top element from the stack. Then I check whether the current ```a[i-1]``` top element in my stack is smaller or larger than ```x``` current element in the array ```a[i-1] < x ?```. If it is smaller then use it to multiply to the popped element, otherwise use ```x``` to multiply. Do that while ```x``` is bigger than the elements in the stack.\\n*   ```a[i++] = x``` is just adding element into a stack.\\n*   ```while (i > 1) ret += a[--i] * a[i - 1];``` This line is basically there cause could be a day when all numbers left are decreasing in the end, but I still need to combine them. So pop top and multiply by the previous element.\\n*  That\\'s it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& a) {\\n        int i = 0, ret = 0;\\n        for (auto &x : a) {\\n            while (i && a[i - 1] < x) \\n                ret += a[--i] * ((i && a[i - 1] < x) ? a[i - 1] : x);\\n            a[i++] = x;\\n        }\\n        while (i > 1)  \\n            ret += a[--i] * a[i - 1];\\n        return ret;\\n    }\\n};\\n```\n```i```\n```a[i-1]```\n```i==0```\n```ret += a[--i] * ((i && a[i - 1] < x) ? a[i - 1] : x)```\n```a```\n```i```\n```a[--i]```\n```a[i-1]```\n```x```\n```a[i-1] < x ?```\n```x```\n```x```\n```a[i++] = x```\n```while (i > 1) ret += a[--i] * a[i - 1];```",
                "codeTag": "Java"
            },
            {
                "id": 982863,
                "title": "c-recursion-with-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int memo_on_tree(vector<int>&arr, int sidx,int eidx,vector<vector<int>>&dp)\\n    {\\n        if(sidx == eidx)\\n        {\\n            return 0;\\n        }\\n        int mn = INT_MAX;\\n        if( dp[sidx][eidx]!=0 )\\n        {\\n            return dp[sidx][eidx];\\n        }\\n        for( int j=sidx;j<eidx;j++ )\\n        {\\n        int l = memo_on_tree(arr ,sidx ,j ,dp);\\n        int r = memo_on_tree(arr ,j+1 ,eidx ,dp);\\n        int t = l + r + *max_element(arr.begin()+sidx ,arr.begin()+j+1 ) * *max_element(arr.begin()+j+1 ,arr.begin()+eidx+1);\\n        mn = min(mn ,t);\\n        dp[sidx][eidx] = mn;\\n        }\\n        return mn;\\n        \\n    }\\n    int mctFromLeafValues(vector<int>& arr) \\n    {\\n     vector<vector<int>> dp( 40 , vector<int>(40,0));\\n     return memo_on_tree( arr ,0 ,arr.size()-1,dp );\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int memo_on_tree(vector<int>&arr, int sidx,int eidx,vector<vector<int>>&dp)\\n    {\\n        if(sidx == eidx)\\n        {\\n            return 0;\\n        }\\n        int mn = INT_MAX;\\n        if( dp[sidx][eidx]!=0 )\\n        {\\n            return dp[sidx][eidx];\\n        }\\n        for( int j=sidx;j<eidx;j++ )\\n        {\\n        int l = memo_on_tree(arr ,sidx ,j ,dp);\\n        int r = memo_on_tree(arr ,j+1 ,eidx ,dp);\\n        int t = l + r + *max_element(arr.begin()+sidx ,arr.begin()+j+1 ) * *max_element(arr.begin()+j+1 ,arr.begin()+eidx+1);\\n        mn = min(mn ,t);\\n        dp[sidx][eidx] = mn;\\n        }\\n        return mn;\\n        \\n    }\\n    int mctFromLeafValues(vector<int>& arr) \\n    {\\n     vector<vector<int>> dp( 40 , vector<int>(40,0));\\n     return memo_on_tree( arr ,0 ,arr.size()-1,dp );\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 784307,
                "title": "java-recursion-memoization",
                "content": "```\\n- What are we trying to find in each of the recursive call?\\n\\t- We are trying to find the most optimal partition of our current array into \\'left/right\\' subarrays\\n\\t- The most optimal partition will give us the least possible sum of the values of each non-leaf node\\n\\t  and also the value of the largest leaf node\\n```\\n```\\npublic class MinimumCostTreeFromLeafValuesRecursiveApproach {\\n    private static final int MAX_LEAF = 0;\\n    private static final int MIN_SUM = 1;\\n\\n    public int mctFromLeafValues(int[] arr) {\\n        int[] result = mctFromLeafValues(0, arr.length - 1, arr);\\n        return result[MIN_SUM];\\n    }\\n\\n    private int[] mctFromLeafValues(int left, int right, int[] arr) {\\n        if (left == right) return new int[] { arr[left], 0 };\\n\\n        int maxLeaf = Integer.MIN_VALUE, minSum = Integer.MAX_VALUE;\\n\\n        for (int i = left; i < right; i++) {\\n            int[] leftSide = mctFromLeafValues(left, i, arr);\\n            int[] rightSide = mctFromLeafValues(i + 1, right, arr);\\n\\n            minSum = Math.min(minSum, leftSide[MIN_SUM] + rightSide[MIN_SUM] + leftSide[MAX_LEAF] * rightSide[MAX_LEAF]);\\n            maxLeaf = Math.max(maxLeaf, Math.max(leftSide[MAX_LEAF], rightSide[MAX_LEAF]));\\n        }\\n\\n        return new int[] { maxLeaf, minSum };\\n    }\\n}\\n```\\n```\\npublic class MinimumCostTreeFromLeafValuesMemoizationApproach {\\n    private class Node {\\n        public int minSum;\\n        public int maxLeaf;\\n\\n        public Node(int maxLeaf, int minSum) {\\n            this.maxLeaf = maxLeaf;\\n            this.minSum = minSum;\\n        }\\n    }\\n\\n    public int mctFromLeafValues(int[] arr) {\\n        Node result = mctFromLeafValues(0, arr.length - 1, arr, new Node[arr.length][arr.length]);\\n        return result.minSum;\\n    }\\n\\n    private Node mctFromLeafValues(int left, int right, int[] arr, Node[][] memo) {\\n        if (left == right) return new Node(arr[left], 0);\\n        if (memo[left][right] != null) return memo[left][right];\\n\\n        int maxLeaf = Integer.MIN_VALUE, minSum = Integer.MAX_VALUE;\\n\\n        for (int i = left; i < right; i++) {\\n            Node leftSide = mctFromLeafValues(left, i, arr, memo);\\n            Node rightSide = mctFromLeafValues(i + 1, right, arr, memo);\\n\\n            minSum = Math.min(minSum, leftSide.minSum + rightSide.minSum + leftSide.maxLeaf * rightSide.maxLeaf);\\n            maxLeaf = Math.max(maxLeaf, Math.max(leftSide.maxLeaf, rightSide.maxLeaf));\\n        }\\n\\n        memo[left][right] = new Node(maxLeaf, minSum);\\n        return memo[left][right];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n- What are we trying to find in each of the recursive call?\\n\\t- We are trying to find the most optimal partition of our current array into \\'left/right\\' subarrays\\n\\t- The most optimal partition will give us the least possible sum of the values of each non-leaf node\\n\\t  and also the value of the largest leaf node\\n```\n```\\npublic class MinimumCostTreeFromLeafValuesRecursiveApproach {\\n    private static final int MAX_LEAF = 0;\\n    private static final int MIN_SUM = 1;\\n\\n    public int mctFromLeafValues(int[] arr) {\\n        int[] result = mctFromLeafValues(0, arr.length - 1, arr);\\n        return result[MIN_SUM];\\n    }\\n\\n    private int[] mctFromLeafValues(int left, int right, int[] arr) {\\n        if (left == right) return new int[] { arr[left], 0 };\\n\\n        int maxLeaf = Integer.MIN_VALUE, minSum = Integer.MAX_VALUE;\\n\\n        for (int i = left; i < right; i++) {\\n            int[] leftSide = mctFromLeafValues(left, i, arr);\\n            int[] rightSide = mctFromLeafValues(i + 1, right, arr);\\n\\n            minSum = Math.min(minSum, leftSide[MIN_SUM] + rightSide[MIN_SUM] + leftSide[MAX_LEAF] * rightSide[MAX_LEAF]);\\n            maxLeaf = Math.max(maxLeaf, Math.max(leftSide[MAX_LEAF], rightSide[MAX_LEAF]));\\n        }\\n\\n        return new int[] { maxLeaf, minSum };\\n    }\\n}\\n```\n```\\npublic class MinimumCostTreeFromLeafValuesMemoizationApproach {\\n    private class Node {\\n        public int minSum;\\n        public int maxLeaf;\\n\\n        public Node(int maxLeaf, int minSum) {\\n            this.maxLeaf = maxLeaf;\\n            this.minSum = minSum;\\n        }\\n    }\\n\\n    public int mctFromLeafValues(int[] arr) {\\n        Node result = mctFromLeafValues(0, arr.length - 1, arr, new Node[arr.length][arr.length]);\\n        return result.minSum;\\n    }\\n\\n    private Node mctFromLeafValues(int left, int right, int[] arr, Node[][] memo) {\\n        if (left == right) return new Node(arr[left], 0);\\n        if (memo[left][right] != null) return memo[left][right];\\n\\n        int maxLeaf = Integer.MIN_VALUE, minSum = Integer.MAX_VALUE;\\n\\n        for (int i = left; i < right; i++) {\\n            Node leftSide = mctFromLeafValues(left, i, arr, memo);\\n            Node rightSide = mctFromLeafValues(i + 1, right, arr, memo);\\n\\n            minSum = Math.min(minSum, leftSide.minSum + rightSide.minSum + leftSide.maxLeaf * rightSide.maxLeaf);\\n            maxLeaf = Math.max(maxLeaf, Math.max(leftSide.maxLeaf, rightSide.maxLeaf));\\n        }\\n\\n        memo[left][right] = new Node(maxLeaf, minSum);\\n        return memo[left][right];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 766002,
                "title": "java-dp-without-recursion",
                "content": "```\\nclass Solution {\\n    public int findMax(int l, int h, int[]arr){\\n        int tmp = -1;\\n        for (int i = l; i <= h; i++) tmp = Math.max(tmp, arr[i]);\\n        return tmp;\\n    }\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        if (arr == null || arr.length <= 1) return 0;\\n        \\n        int[][] dp = new int[arr.length][arr.length];\\n        \\n        for (int j = 0; j < arr.length; j++){\\n            for (int i = j; i >= 0; i--){\\n                for (int k = i; k < j; k++){\\n                    int tmp = dp[i][k] + dp[k+1][j] + findMax(i,k,arr) * findMax(k+1,j,arr);\\n                    if (dp[i][j] == 0) \\n                        dp[i][j] = tmp;\\n                    else \\n                        dp[i][j] = Math.min(dp[i][j], tmp);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][arr.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int findMax(int l, int h, int[]arr){\\n        int tmp = -1;\\n        for (int i = l; i <= h; i++) tmp = Math.max(tmp, arr[i]);\\n        return tmp;\\n    }\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        if (arr == null || arr.length <= 1) return 0;\\n        \\n        int[][] dp = new int[arr.length][arr.length];\\n        \\n        for (int j = 0; j < arr.length; j++){\\n            for (int i = j; i >= 0; i--){\\n                for (int k = i; k < j; k++){\\n                    int tmp = dp[i][k] + dp[k+1][j] + findMax(i,k,arr) * findMax(k+1,j,arr);\\n                    if (dp[i][j] == 0) \\n                        dp[i][j] = tmp;\\n                    else \\n                        dp[i][j] = Math.min(dp[i][j], tmp);\\n                }\\n            }\\n        }\\n        \\n        return dp[0][arr.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 425261,
                "title": "python-heap-solution",
                "content": "There are numerous ways to solve this problem, but I didn\\'t see anyone do it with a heap. The basic premise is to walk through the array using a minheap to track the smallest leaf seen essentially and collapse it with a larger leaf strategically until we end up with just one node. \\n\\n```\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n  cost, heap = 0, [float(\\'inf\\')]\\n  for leaf in arr:\\n    while heap[0] < leaf: # join the cheapest possible leaves\\n      cost += heapq.heappop(heap) * min(leaf, heap[0])\\n    heapq.heappush(heap, leaf)\\n  while len(heap) > 2: # no choice but to join the remaining leaves\\n    cost += heapq.heappop(heap) * heap[0]\\n  return cost\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n  cost, heap = 0, [float(\\'inf\\')]\\n  for leaf in arr:\\n    while heap[0] < leaf: # join the cheapest possible leaves\\n      cost += heapq.heappop(heap) * min(leaf, heap[0])\\n    heapq.heappush(heap, leaf)\\n  while len(heap) > 2: # no choice but to join the remaining leaves\\n    cost += heapq.heappop(heap) * heap[0]\\n  return cost\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2146236,
                "title": "c-gap-strategy-dp-complete-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int dp[arr.size()][arr.size()];\\n        int m[arr.size()][arr.size()];\\n        memset(m,0,sizeof(m));\\n        for(int g = 0;g<arr.size();g++){\\n            for(int i=0,j=g;j<arr.size();i++,j++){\\n                if(g==0){\\n                    m[i][j] = arr[i];\\n                }else{\\n                    m[i][j] = max(m[i][j-1],m[i+1][j]);\\n                }\\n            }\\n        }\\n    \\n        \\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int g = 0;g<arr.size();g++){\\n            for(int i=0,j=g;j<arr.size();i++,j++){\\n                if(g==0){\\n                    dp[i][j] = 0;\\n                }else if(g == 1){\\n                    dp[i][j] = arr[i]*arr[j];\\n                }else{\\n                    int ans = INT_MAX;\\n                    for(int k = i;k < j;k++){\\n                         ans = min(ans,dp[i][k] + (m[i][k]*m[k+1][j]) + dp[k+1][j]);\\n                    }\\n                    dp[i][j] = ans;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][arr.size()-1];\\n    }\\n};\\n\\n    ```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int dp[arr.size()][arr.size()];\\n        int m[arr.size()][arr.size()];\\n        memset(m,0,sizeof(m));\\n        for(int g = 0;g<arr.size();g++){\\n            for(int i=0,j=g;j<arr.size();i++,j++){\\n                if(g==0){\\n                    m[i][j] = arr[i];\\n                }else{\\n                    m[i][j] = max(m[i][j-1],m[i+1][j]);\\n                }\\n            }\\n        }\\n    \\n        \\n        memset(dp,0,sizeof(dp));\\n        \\n        for(int g = 0;g<arr.size();g++){\\n            for(int i=0,j=g;j<arr.size();i++,j++){\\n                if(g==0){\\n                    dp[i][j] = 0;\\n                }else if(g == 1){\\n                    dp[i][j] = arr[i]*arr[j];\\n                }else{\\n                    int ans = INT_MAX;\\n                    for(int k = i;k < j;k++){\\n                         ans = min(ans,dp[i][k] + (m[i][k]*m[k+1][j]) + dp[k+1][j]);\\n                    }\\n                    dp[i][j] = ans;\\n                }\\n            }\\n        }\\n        \\n        return dp[0][arr.size()-1];\\n    }\\n};\\n\\n    ```",
                "codeTag": "Java"
            },
            {
                "id": 1249592,
                "title": "java-solution-o-n-time-o-n-space",
                "content": "```\\npublic int mctFromLeafValues(int[] arr) {\\n        int result=0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        for(int a: arr){\\n            while(stack.peek()<=a){\\n                int mid=stack.pop();\\n                result+=mid*Math.min(stack.peek(),a);\\n            }\\n            stack.push(a);\\n        }\\n        while(stack.size()>2){\\n            result+=stack.pop()*stack.peek();\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int mctFromLeafValues(int[] arr) {\\n        int result=0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        for(int a: arr){\\n            while(stack.peek()<=a){\\n                int mid=stack.pop();\\n                result+=mid*Math.min(stack.peek(),a);\\n            }\\n            stack.push(a);\\n        }\\n        while(stack.size()>2){\\n            result+=stack.pop()*stack.peek();\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 832100,
                "title": "c-o-n-2-solution-both-greedy-optimized-with-comment-beats-100-runtime",
                "content": "Runtime: 4 ms, faster than 82.56% of C++ online submissions for Minimum Cost Tree From Leaf Values.\\nMemory Usage: 8.3 MB, less than 93.24% of C++ online submissions for Minimum Cost Tree From Leaf Values.\\n\\nIterate through the array and pick the min product of consicuitive elements of array and add it to sum. Remove the minimum element. Do this until array has only one element. \\n\\nTask is to get minimum sum of internal nodes and so we pick minimum products (internal nodes) in each iteration. Also the internal node value depends on large leaf node values and so we remove the small leaf elements from array. \\n\\nSome useful testcases:\\n[6, 2]\\n[6, 2, 4, 1, 7]\\n[6, 2, 4, 1, 7, 9]\\n[6, 2, 4, 1, 7, 4, 1, 9]\\n[6, 2, 4, 1, 7, 10, 1, 9]\\n[11,7,11,11,11,13]\\n[6,15,5,2]\\n\\n**[There is a better explanation](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/349098/From-O(N2)-to-O(n).-Greedy)**\\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n\\n        int n = arr.size();\\n        int sum = 0;\\n\\t\\t// Loop till array has more than 1 element\\n        while(arr.size()>1)\\n        {\\n            int x;\\n            int min = INT_MAX;\\n            int v;\\n\\t\\t\\t// Find minimum product between any 2 consiquitive element\\n            for(int i=0;i<arr.size()-1;i++)\\n            {\\n\\t\\t\\t   // find product between 2 consiquitive element\\n                v = arr[i] * arr[i+1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// find minimum product\\n                if(min>v)\\n                {\\n                    min = v;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// find the index of minimum product\\'s minimum number\\n                    x = arr[i]<arr[i+1]?i:(i+1);\\n                }\\n            }\\n            \\n\\t\\t\\t// minimum products generates the internal node values\\n            sum += min;\\n\\t\\t\\t\\n\\t\\t\\t// remove index of the minimum element of minimum product\\n            arr.erase(arr.begin() + x);\\n        }\\n        \\n\\t\\t// minimum value of the sum of all internal nodes\\n        return sum;\\n    }\\n};\\n```\\n.\\n.\\n.\\n**Optimized Solution: Still close to O (N ^ 2) but avoided same product re-computation**\\n\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Minimum Cost Tree From Leaf Values.\\nMemory Usage: 8.4 MB, less than 86.37% of C++ online submissions for Minimum Cost Tree From Leaf Values.\\n.\\n.\\n`Here we get the minmum product of consecutive elements in a different way. \\n1. If three element [b,a,c] are in array such that  b >= a and a <= c then min product = a * min(b,c) and remove a from list. \\n2. Also if A[0] <= A[1] then min product = A[0] * A[1] and remove A[0] from  list. \\n3. Again if A[n-2] >= A[n-1] then min product = A[n-1] * A[n-2] and remove A[n-1] from list\\n\\nAs we are using Linked List, remove operation takes O(1) time.`\\n.\\n.\\n.\\n```\\nclass Solution {\\npublic:\\n    struct Node{\\n        int val;\\n        Node * next;\\n    };\\n    \\n    Node * createNode(int val)\\n    {\\n        Node * node = new Node();\\n        node->val = val;\\n        node->next = NULL;\\n        \\n        return node;\\n    }\\n        \\n    int mctFromLeafValues(vector<int>& arr) {\\n\\n        int n = arr.size();\\n        int sum = 0;\\n        Node * head = NULL;\\n        Node * tail = NULL;\\n        \\n        // Create LinkedList of the array items\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(head==NULL)\\n            {\\n                head = createNode(arr[i]);\\n                tail = head;\\n            }\\n            else\\n            {\\n                tail->next = createNode(arr[i]);\\n                tail = tail->next;\\n            }\\n        }\\n        \\n\\n        // Loop until linked list has 2 items\\n        while(head->next!=NULL && head->next->next!=NULL)\\n        {\\n            Node * pnode = NULL;\\n            Node * cnode = head;\\n            \\n            // Loop until the end of linked list\\n            while(cnode!=NULL && cnode->next!=NULL)\\n            {\\n                // Get min product A[0] * A[1], if A[0] <= A[1] and remove A[0]\\n                if(pnode==NULL && cnode->val<=cnode->next->val)\\n                {\\n                    sum+= (cnode->val*cnode->next->val);\\n                    head = cnode->next;\\n                    delete(cnode);\\n                    cnode = head;\\n                }\\n                \\n                // Get min product A[n-2] * A[n-1], if A[n-2] >= A[n-1] and remove A[n-1]\\n                else if(pnode!=NULL && cnode->next->next==NULL && cnode->val >= cnode->next->val)\\n                {\\n                    sum += (cnode->val * cnode->next->val);\\n                    delete(cnode->next);\\n                    cnode->next = NULL;\\n                }  \\n                \\n                // Get min product A[i] * min(A[i-1],A[i+1]), if A[i-1] >= A[i] && A[i] <= A[i+1] and remove A[i]\\n                else if(pnode!=NULL && cnode->next!=NULL && pnode->val>=cnode->val && cnode->val <= cnode->next->val)\\n                {\\n                    sum += (cnode->val * min(pnode->val,cnode->next->val));\\n                    pnode->next = cnode->next;\\n                    delete(cnode);\\n                    cnode = pnode->next;\\n                }                \\n                \\n                // Otherwise increment iterator\\n                else\\n                {\\n                    pnode = cnode;\\n                    cnode = cnode->next;\\n                }\\n            }\\n            \\n        }\\n        \\n        //Get product of last 2 items\\n        if(head->next!=NULL)\\n        {\\n            sum+= (head->val * head->next->val);\\n        } \\n        \\n        // Minimum sum of all internal nodes\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n\\n        int n = arr.size();\\n        int sum = 0;\\n\\t\\t// Loop till array has more than 1 element\\n        while(arr.size()>1)\\n        {\\n            int x;\\n            int min = INT_MAX;\\n            int v;\\n\\t\\t\\t// Find minimum product between any 2 consiquitive element\\n            for(int i=0;i<arr.size()-1;i++)\\n            {\\n\\t\\t\\t   // find product between 2 consiquitive element\\n                v = arr[i] * arr[i+1];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// find minimum product\\n                if(min>v)\\n                {\\n                    min = v;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t// find the index of minimum product\\'s minimum number\\n                    x = arr[i]<arr[i+1]?i:(i+1);\\n                }\\n            }\\n            \\n\\t\\t\\t// minimum products generates the internal node values\\n            sum += min;\\n\\t\\t\\t\\n\\t\\t\\t// remove index of the minimum element of minimum product\\n            arr.erase(arr.begin() + x);\\n        }\\n        \\n\\t\\t// minimum value of the sum of all internal nodes\\n        return sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    struct Node{\\n        int val;\\n        Node * next;\\n    };\\n    \\n    Node * createNode(int val)\\n    {\\n        Node * node = new Node();\\n        node->val = val;\\n        node->next = NULL;\\n        \\n        return node;\\n    }\\n        \\n    int mctFromLeafValues(vector<int>& arr) {\\n\\n        int n = arr.size();\\n        int sum = 0;\\n        Node * head = NULL;\\n        Node * tail = NULL;\\n        \\n        // Create LinkedList of the array items\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(head==NULL)\\n            {\\n                head = createNode(arr[i]);\\n                tail = head;\\n            }\\n            else\\n            {\\n                tail->next = createNode(arr[i]);\\n                tail = tail->next;\\n            }\\n        }\\n        \\n\\n        // Loop until linked list has 2 items\\n        while(head->next!=NULL && head->next->next!=NULL)\\n        {\\n            Node * pnode = NULL;\\n            Node * cnode = head;\\n            \\n            // Loop until the end of linked list\\n            while(cnode!=NULL && cnode->next!=NULL)\\n            {\\n                // Get min product A[0] * A[1], if A[0] <= A[1] and remove A[0]\\n                if(pnode==NULL && cnode->val<=cnode->next->val)\\n                {\\n                    sum+= (cnode->val*cnode->next->val);\\n                    head = cnode->next;\\n                    delete(cnode);\\n                    cnode = head;\\n                }\\n                \\n                // Get min product A[n-2] * A[n-1], if A[n-2] >= A[n-1] and remove A[n-1]\\n                else if(pnode!=NULL && cnode->next->next==NULL && cnode->val >= cnode->next->val)\\n                {\\n                    sum += (cnode->val * cnode->next->val);\\n                    delete(cnode->next);\\n                    cnode->next = NULL;\\n                }  \\n                \\n                // Get min product A[i] * min(A[i-1],A[i+1]), if A[i-1] >= A[i] && A[i] <= A[i+1] and remove A[i]\\n                else if(pnode!=NULL && cnode->next!=NULL && pnode->val>=cnode->val && cnode->val <= cnode->next->val)\\n                {\\n                    sum += (cnode->val * min(pnode->val,cnode->next->val));\\n                    pnode->next = cnode->next;\\n                    delete(cnode);\\n                    cnode = pnode->next;\\n                }                \\n                \\n                // Otherwise increment iterator\\n                else\\n                {\\n                    pnode = cnode;\\n                    cnode = cnode->next;\\n                }\\n            }\\n            \\n        }\\n        \\n        //Get product of last 2 items\\n        if(head->next!=NULL)\\n        {\\n            sum+= (head->val * head->next->val);\\n        } \\n        \\n        // Minimum sum of all internal nodes\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 626917,
                "title": "java-0ms-beats-100-with-explanation",
                "content": "Idea is to split the given array in two parts such that the current maximum number is not used for multiplication operation.\\nKeep splitting the array till you are left with two elements. Multiply them and return the max of them.\\n\\nE.g.\\nInput => \\n[2, 8, 10, 3, 2, 12]\\n\\n\\nFirst split (index =5) divides the array in two parts [2, 8, 10, 3, 2] and  [12]\\nAfter second split => [2, 8], [10] and [3, 2]\\n\\n[2, 8] => sum += 2 * 8 and returns max(2, 8)\\n[3, 2] => sum += 3 * 2 and returns max(3, 2)\\n\\n[10] => Got max as 8 from left and 3 from right. At this point sum is already 22\\nsum += 10 * 8\\nsum += 10 * 3\\n\\n[12] => Got max as 10 from left. Sum already 132 at this time\\nsum += 12 * 10\\n\\nTotal min sum = 132 + 120 = 252\\n\\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[] sum = new int[1];\\n        \\n        int max = evaluate(arr, 0, arr.length - 1, sum);\\n        \\n        return sum[0];\\n        \\n    }\\n    \\n    private int evaluate(int[] arr, int i, int j, int[] sum) {\\n        if(i > j || i < 0 || j < 0 || i >= arr.length || j >= arr.length) return 0;\\n        \\n        if(i == j - 1) {\\n            sum[0] += arr[i] * arr[j];\\n            return Math.max(arr[i], arr[j]);\\n        }\\n        \\n        int maxIndex = i;\\n        \\n        for(int k = i; k <= j; k++) {\\n            if(arr[k] >= arr[maxIndex]) {\\n                maxIndex = k;\\n            }\\n        }\\n        \\n        int max1 = evaluate(arr, i, maxIndex - 1, sum);\\n        int max2 = evaluate(arr, maxIndex + 1, j, sum);\\n        \\n        if(max1 > 0) sum[0] += arr[maxIndex] * max1;\\n        if(max2 > 0) sum[0] += arr[maxIndex] * max2;\\n        \\n        int max = Math.max(max1, max2);\\n        \\n        return Math.max(arr[maxIndex], max);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[] sum = new int[1];\\n        \\n        int max = evaluate(arr, 0, arr.length - 1, sum);\\n        \\n        return sum[0];\\n        \\n    }\\n    \\n    private int evaluate(int[] arr, int i, int j, int[] sum) {\\n        if(i > j || i < 0 || j < 0 || i >= arr.length || j >= arr.length) return 0;\\n        \\n        if(i == j - 1) {\\n            sum[0] += arr[i] * arr[j];\\n            return Math.max(arr[i], arr[j]);\\n        }\\n        \\n        int maxIndex = i;\\n        \\n        for(int k = i; k <= j; k++) {\\n            if(arr[k] >= arr[maxIndex]) {\\n                maxIndex = k;\\n            }\\n        }\\n        \\n        int max1 = evaluate(arr, i, maxIndex - 1, sum);\\n        int max2 = evaluate(arr, maxIndex + 1, j, sum);\\n        \\n        if(max1 > 0) sum[0] += arr[maxIndex] * max1;\\n        if(max2 > 0) sum[0] += arr[maxIndex] * max2;\\n        \\n        int max = Math.max(max1, max2);\\n        \\n        return Math.max(arr[maxIndex], max);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 493454,
                "title": "from-recursion-to-top-down-dp",
                "content": "**Recursion**\\n```\\nminSumNonLeaf with leaf nodes (l, r) for from index l to index r both inclusive\\n= min(\\n\\tminSumNonLeaf(l, m-1) \\n\\t+ minSumNonLeaf(m, r) \\n\\t+ max(arr[l], ..., arr[m-1]) * max(arr[m], ..., arr[r])\\n)      \\n```\\n\\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        return mctFromLeafValues(arr, 0, arr.length - 1);\\n    }\\n    \\n    private int mctFromLeafValues(int[] arr, int l, int r) {\\n        int mct = Integer.MAX_VALUE;\\n        for (int m = l + 1; m <= r; m++) {\\n            mct = Math.min( \\n                mct,\\n                mctFromLeafValues(arr, l, m - 1)\\n                    + mctFromLeafValues(arr, m, r)\\n                    + max(arr, l, m - 1) * max(arr, m, r));\\n        }\\n        return mct == Integer.MAX_VALUE ? 0 : mct;\\n    }\\n    \\n    private int max(int[] arr, int l, int r) {\\n        int maxVal = Integer.MIN_VALUE;\\n        for (int k = l; k <= r; k++) {\\n            maxVal = Math.max(maxVal, arr[k]);\\n        }\\n        return maxVal;\\n    }\\n}\\n```\\n**Top-down DP**\\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[][] memo = new int[arr.length][arr.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            Arrays.fill(memo[i], Integer.MAX_VALUE);\\n        }\\n        return mctFromLeafValues(arr, 0, arr.length - 1, memo);\\n    }\\n    \\n    private int mctFromLeafValues(int[] arr, int l, int r, int[][] memo) {\\n        if (memo[l][r] != Integer.MAX_VALUE) {\\n            return memo[l][r];\\n        } else {\\n            for (int m = l + 1; m <= r; m++) {\\n                memo[l][r] = Math.min( \\n                    memo[l][r],\\n                    mctFromLeafValues(arr, l, m - 1, memo)\\n                        + mctFromLeafValues(arr, m, r, memo)\\n                        + max(arr, l, m - 1) * max(arr, m, r));\\n            }\\n            memo[l][r] = memo[l][r] == Integer.MAX_VALUE ? 0 : memo[l][r];\\n            return memo[l][r];\\n        }\\n    }\\n    \\n    private int max(int[] arr, int l, int r) {\\n        int maxVal = Integer.MIN_VALUE;\\n        for (int k = l; k <= r; k++) {\\n            maxVal = Math.max(maxVal, arr[k]);\\n        }\\n        return maxVal;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nminSumNonLeaf with leaf nodes (l, r) for from index l to index r both inclusive\\n= min(\\n\\tminSumNonLeaf(l, m-1) \\n\\t+ minSumNonLeaf(m, r) \\n\\t+ max(arr[l], ..., arr[m-1]) * max(arr[m], ..., arr[r])\\n)      \\n```\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        return mctFromLeafValues(arr, 0, arr.length - 1);\\n    }\\n    \\n    private int mctFromLeafValues(int[] arr, int l, int r) {\\n        int mct = Integer.MAX_VALUE;\\n        for (int m = l + 1; m <= r; m++) {\\n            mct = Math.min( \\n                mct,\\n                mctFromLeafValues(arr, l, m - 1)\\n                    + mctFromLeafValues(arr, m, r)\\n                    + max(arr, l, m - 1) * max(arr, m, r));\\n        }\\n        return mct == Integer.MAX_VALUE ? 0 : mct;\\n    }\\n    \\n    private int max(int[] arr, int l, int r) {\\n        int maxVal = Integer.MIN_VALUE;\\n        for (int k = l; k <= r; k++) {\\n            maxVal = Math.max(maxVal, arr[k]);\\n        }\\n        return maxVal;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[][] memo = new int[arr.length][arr.length];\\n        for (int i = 0; i < arr.length; i++) {\\n            Arrays.fill(memo[i], Integer.MAX_VALUE);\\n        }\\n        return mctFromLeafValues(arr, 0, arr.length - 1, memo);\\n    }\\n    \\n    private int mctFromLeafValues(int[] arr, int l, int r, int[][] memo) {\\n        if (memo[l][r] != Integer.MAX_VALUE) {\\n            return memo[l][r];\\n        } else {\\n            for (int m = l + 1; m <= r; m++) {\\n                memo[l][r] = Math.min( \\n                    memo[l][r],\\n                    mctFromLeafValues(arr, l, m - 1, memo)\\n                        + mctFromLeafValues(arr, m, r, memo)\\n                        + max(arr, l, m - 1) * max(arr, m, r));\\n            }\\n            memo[l][r] = memo[l][r] == Integer.MAX_VALUE ? 0 : memo[l][r];\\n            return memo[l][r];\\n        }\\n    }\\n    \\n    private int max(int[] arr, int l, int r) {\\n        int maxVal = Integer.MIN_VALUE;\\n        for (int k = l; k <= r; k++) {\\n            maxVal = Math.max(maxVal, arr[k]);\\n        }\\n        return maxVal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 460743,
                "title": "python-o-n-beat-95-100-with-explanation",
                "content": "```\\n\\'\\'\\'\\nThen to minimize value of each non-leaf node requires find min arr[i]*arr[i+1] for i in range(len(arr)-1).\\nAfter building a node from arr[i] and arr[i+1], the max(arr[i], arr[i+1]) is still useful to build parent nodes.\\nSo we kick off min(arr[i], arr[i+1]) but keep max(arr[i], arr[i+1]).\\nFor example, [6,2,4,7] -> [6,4,7], res += 2*4 -> [6,7], res += 4*6 -> [7], res += 6*7, final res = 74\\nMono-decreasing stack is used. When a larger number comes in, kick off all small numbers before it and update res:\\ncur, stack, res\\n 6    [6]    0\\n 2   [6,2]   0\\n 4   [6,4]   8\\n 7    [7]    8+4*6+6*7\\nWhen a smaller number is kicked off, res is updated by stack[-1] * min(stack[-2], new large number)\\nFinally, pop out each node in stack to calculate final results.\\nTime: O(n)\\nSpace: O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        if not arr or len(arr) < 2:\\n            return 0\\n        arr_len = len(arr)\\n        my_stack = [arr[0]]\\n        res = 0\\n        for i, n in enumerate(arr[1:]):\\n            while my_stack and n > my_stack[-1]:\\n                sm = my_stack.pop()\\n                if my_stack:\\n                    res += sm * min(my_stack[-1], n)\\n                else:\\n                    res += sm * n\\n            my_stack.append(n)\\n        while len(my_stack) >= 2:\\n            sm = my_stack.pop()\\n            res += sm * my_stack[-1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n\\'\\'\\'\\nThen to minimize value of each non-leaf node requires find min arr[i]*arr[i+1] for i in range(len(arr)-1).\\nAfter building a node from arr[i] and arr[i+1], the max(arr[i], arr[i+1]) is still useful to build parent nodes.\\nSo we kick off min(arr[i], arr[i+1]) but keep max(arr[i], arr[i+1]).\\nFor example, [6,2,4,7] -> [6,4,7], res += 2*4 -> [6,7], res += 4*6 -> [7], res += 6*7, final res = 74\\nMono-decreasing stack is used. When a larger number comes in, kick off all small numbers before it and update res:\\ncur, stack, res\\n 6    [6]    0\\n 2   [6,2]   0\\n 4   [6,4]   8\\n 7    [7]    8+4*6+6*7\\nWhen a smaller number is kicked off, res is updated by stack[-1] * min(stack[-2], new large number)\\nFinally, pop out each node in stack to calculate final results.\\nTime: O(n)\\nSpace: O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        if not arr or len(arr) < 2:\\n            return 0\\n        arr_len = len(arr)\\n        my_stack = [arr[0]]\\n        res = 0\\n        for i, n in enumerate(arr[1:]):\\n            while my_stack and n > my_stack[-1]:\\n                sm = my_stack.pop()\\n                if my_stack:\\n                    res += sm * min(my_stack[-1], n)\\n                else:\\n                    res += sm * n\\n            my_stack.append(n)\\n        while len(my_stack) >= 2:\\n            sm = my_stack.pop()\\n            res += sm * my_stack[-1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353111,
                "title": "o-n-time-solution-explanation",
                "content": "Let\\'s first consider an alternate solution, which recuesively removes the smallest number in the array.\\nAssume ai is the current smallest number in the array,1<= i <= arr.length. It can be proved that the brother of ai must be a_{i-1} or a_{i+1}:\\n1. Suppose aj is the brother of ai. \\n2. If (j > i+1 and aj > a_{i+1}) or (j < i-1 and aj > a_{i-1}), then aj must not be the brother of ai because aj would be dropped out during the tree construction as the given array is in in-order traversal.\\n3. Thus, if we select aj (j < i-1), then the sum value of the subtree (al...aj...ai) = aj * ai + tree(al...aj...ai)  is less than the case when combine ai-1 and ai = ai-1 * ai + tree(al...aj...ai). When j > i+1, the proof is the same.\\n4. Also, we could conclude from the above formula that ai must combine with the smaller treenode between a_{i-1} and a_{i+1}.\\n\\nThen, we will show that the proposed algorithm has the same effect as the above process.\\nSuppose the current picked number is ai. It is obvious that the numbers in the stack are in descending order. Thus, if ai is less than the last number in the stack, we simply push ai into stack. Otherwise, we pop the last number in the stack, e.g., aj. Now, aj could be regarded as the smallest number in the array. Then, the nearest greater number to the right of aj is ai while the nearest greater number to the left is the last number in the stack. Thus, aj is combined with min(ai, last number in the stack), as shown in the proposed code. \\n\\nNote that a great insight in this problem is that ai is better to combine with the nearest and smallest number in the arrary.\\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        vector<int> st = {INT_MAX};\\n        for (int i=0; i<arr.size(); i++) {\\n            int tmp = 0;\\n            while (st.back() <= arr[i]) \\n                tmp = st.back(), st.pop_back(), res += min(st.back(), arr[i]) * tmp;\\n            st.push_back(arr[i]);\\n        }\\n        for (int i=1; i<st.size()-1; i++)\\n            res += st[i] * st[i+1];\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        vector<int> st = {INT_MAX};\\n        for (int i=0; i<arr.size(); i++) {\\n            int tmp = 0;\\n            while (st.back() <= arr[i]) \\n                tmp = st.back(), st.pop_back(), res += min(st.back(), arr[i]) * tmp;\\n            st.push_back(arr[i]);\\n        }\\n        for (int i=1; i<st.size()-1; i++)\\n            res += st[i] * st[i+1];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594574,
                "title": "o-n-java-with-comments",
                "content": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        \\n        /*\\n        Remove small element i and the cost is arr[i] * Math.min(arr[i-1], arr[i+1]). minimum cost happens between smaller values of i-1 and i+1.\\n\\nRemove until there is only one element and sum of cost is the answer.\\n\\nUse stack to maintain decreasing order, when there is bigger value num, then pop small value arr[i] and acculate the cost arr[i] * Math.min(num, stk.peek()).\\n*/\\n        \\n        if(arr == null || arr.length < 2) return 0;\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        int result =0;\\n        \\n        stack.push(Integer.MAX_VALUE);\\n        \\n        for(int num: arr){\\n         \\n            while(stack.peek() <= num){\\n                int smallValue = stack.pop();\\n                result = result + smallValue*Math.min(stack.peek(),num);\\n            }\\n            stack.push(num);\\n        }\\n        \\n        \\n        while(stack.size() > 2){\\n            result = result + stack.pop()*stack.peek();\\n        }\\n        \\n        return result;\\n    }\\n    \\n}\\n```\\n\\nplease upvote my solution",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        \\n        /*\\n        Remove small element i and the cost is arr[i] * Math.min(arr[i-1], arr[i+1]). minimum cost happens between smaller values of i-1 and i+1.\\n\\nRemove until there is only one element and sum of cost is the answer.\\n\\nUse stack to maintain decreasing order, when there is bigger value num, then pop small value arr[i] and acculate the cost arr[i] * Math.min(num, stk.peek()).\\n*/\\n        \\n        if(arr == null || arr.length < 2) return 0;\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        int result =0;\\n        \\n        stack.push(Integer.MAX_VALUE);\\n        \\n        for(int num: arr){\\n         \\n            while(stack.peek() <= num){\\n                int smallValue = stack.pop();\\n                result = result + smallValue*Math.min(stack.peek(),num);\\n            }\\n            stack.push(num);\\n        }\\n        \\n        \\n        while(stack.size() > 2){\\n            result = result + stack.pop()*stack.peek();\\n        }\\n        \\n        return result;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903392,
                "title": "java-simple-dp-with-explanation-2ms-runtime",
                "content": "class pair{\\n    int val;\\n    int max;\\n    \\n    pair(int v, int m)\\n    {\\n        val = v;\\n        max = m;\\n    }\\n    \\n}\\n\\n\\nclass Solution {\\n    \\n    //This problem is a variation of Matrix chain multiplication.\\n    //It is a very famous Dp problem.\\n\\t//Upvote if you like the solution. Thanks!\\n    \\n    int []ar;\\n    pair [][]dp;\\n    \\n    //Here a pair object has 2 attributes, val and max\\n    \\n    //val -> It is the value of the internal node formed by multiplying the \\n    //       maximum values of leaf in the right and left sub trees.\\n    \\n    //max -> If this tree were to be a subtree to a node above it, we need to pass on the\\n    //       max value of the leaf present in this sub tree\\n    \\n    pair solve(int i, int j)\\n    {\\n        //If single node, No internal node is formed.\\n        //Therefore, val = 0, max = ar[i]\\n        if(j - i + 1 == 1)\\n            return new pair(0, ar[i]);\\n        \\n        //If 2 nodes, val of the internal node will be ar[i] * ar[j]\\n        //And the max of them will be passed as the maximum leaf value for a Node above it\\n        if(j - i + 1 == 2)\\n            return new pair(ar[i]*ar[j], Math.max(ar[i], ar[j]));\\n        \\n        //If value is already calculated, return it.\\n        if(dp[i][j] != null)\\n            return dp[i][j];\\n        \\n        //Initialize the current internal node value as Integer Max\\n        int min = Integer.MAX_VALUE;\\n        int max = -1;\\n        \\n        for(int k = i; k < j; k++)\\n        {\\n            int sum = 0;\\n            \\n            //Aftering solving the left part\\n            pair left = solve(i, k);\\n            \\n            //Aftering solving the right part\\n            pair right = solve(k + 1, j);\\n            \\n            //If left.val == 0, then it was a single node\\n            //right.val will be the only internal node that is formed\\n            if(left.val == 0)\\n                sum = right.val + left.max * right.max;\\n    \\n            //If right.val == 0, then it was a single node\\n            //left.val will be the only internal node that is formed\\n            else if(right.val == 0)\\n                sum = left.val + left.max * right.max;\\n\\n            //Otherwise, left.val and right.val are the values of the internal nodes \\n            //Formed by the left and right subtree\\n            else\\n                sum = left.val + right.val + left.max * right.max;\\n            \\n            \\n            //We add left.max * right.max to all the cases because\\n            //the parent node in all the cases will be the product of the \\n            //Max leaf value in the left and right subtree\\n            \\n            //Update sum and max if necessary\\n            if(min > sum)\\n            {\\n                min = sum;\\n                max = Math.max(left.max, right.max);\\n            }\\n            \\n        }\\n        \\n        //Store in dp and return\\n        return dp[i][j] = new pair(min, max);\\n    }\\n    \\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        \\n        if(arr == null || arr.length == 0)\\n            return 0;\\n        \\n        dp = new pair[arr.length][arr.length];\\n        \\n        ar = arr;\\n        \\n        return solve(0, arr.length - 1).val;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    //This problem is a variation of Matrix chain multiplication.\\n    //It is a very famous Dp problem.\\n\\t//Upvote if you like the solution. Thanks!\\n    \\n    int []ar;\\n    pair [][]dp;\\n    \\n    //Here a pair object has 2 attributes, val and max\\n    \\n    //val -> It is the value of the internal node formed by multiplying the \\n    //       maximum values of leaf in the right and left sub trees.\\n    \\n    //max -> If this tree were to be a subtree to a node above it, we need to pass on the\\n    //       max value of the leaf present in this sub tree\\n    \\n    pair solve(int i, int j)\\n    {\\n        //If single node, No internal node is formed.\\n        //Therefore, val = 0, max = ar[i]\\n        if(j - i + 1 == 1)\\n            return new pair(0, ar[i]);\\n        \\n        //If 2 nodes, val of the internal node will be ar[i] * ar[j]\\n        //And the max of them will be passed as the maximum leaf value for a Node above it\\n        if(j - i + 1 == 2)\\n            return new pair(ar[i]*ar[j], Math.max(ar[i], ar[j]));\\n        \\n        //If value is already calculated, return it.\\n        if(dp[i][j] != null)\\n            return dp[i][j];\\n        \\n        //Initialize the current internal node value as Integer Max\\n        int min = Integer.MAX_VALUE;\\n        int max = -1;\\n        \\n        for(int k = i; k < j; k++)\\n        {\\n            int sum = 0;\\n            \\n            //Aftering solving the left part\\n            pair left = solve(i, k);\\n            \\n            //Aftering solving the right part\\n            pair right = solve(k + 1, j);\\n            \\n            //If left.val == 0, then it was a single node\\n            //right.val will be the only internal node that is formed\\n            if(left.val == 0)\\n                sum = right.val + left.max * right.max;\\n    \\n            //If right.val == 0, then it was a single node\\n            //left.val will be the only internal node that is formed\\n            else if(right.val == 0)\\n                sum = left.val + left.max * right.max;\\n\\n            //Otherwise, left.val and right.val are the values of the internal nodes \\n            //Formed by the left and right subtree\\n            else\\n                sum = left.val + right.val + left.max * right.max;\\n            \\n            \\n            //We add left.max * right.max to all the cases because\\n            //the parent node in all the cases will be the product of the \\n            //Max leaf value in the left and right subtree\\n            \\n            //Update sum and max if necessary\\n            if(min > sum)\\n            {\\n                min = sum;\\n                max = Math.max(left.max, right.max);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 723896,
                "title": "cpp-solution-with-comments",
                "content": "Runtime: 48 ms, faster than 15.89% of C++ online submissions for Minimum Cost Tree From Leaf Values.\\nMemory Usage: 9 MB, less than 35.80% of C++ online submissions for Minimum Cost Tree From Leaf Values.\\n```\\nclass Solution {\\n    int getMax(vector<int> &arr, int start, int end){\\n        int max_ = arr[start];\\n        for(int i = start+1; i <= end; i++){\\n            max_ = max(max_,arr[i]);\\n        }\\n        return max_;\\n    }\\n    int helper(vector<int>& arr, int start, int end, vector<vector<int>>& dp){\\n        if(start == end) return 0;\\n        if(end - start  == 1) return arr[start] * arr[end];\\n        if(dp[start][end] != -1) return dp[start][end];\\n        int x ,y = INT_MAX;\\n        for(int i = 0; start + i + 1 <= end; i++){\\n            //start to start+i in left sub tree start+i+1 to end in right\\n            //new node formed will be multiplication or largest leaf node from both sub tree\\n            //plus rest of nodes formed in the left and right subtree\\n            x =  getMax(arr,start,start+i) * getMax(arr,start+i+1,end) +   helper(arr,start,start+i,dp) + helper(arr,start+i+1,end,dp) ;\\n            //minimum of all possible combination\\n            y = min(y,x);\\n        }\\n        dp[start][end] = y;\\n        return dp[start][end];\\n    }\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<vector<int>> dp(n, vector<int> (n,-1));\\n        return helper(arr,0,n-1,dp);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int getMax(vector<int> &arr, int start, int end){\\n        int max_ = arr[start];\\n        for(int i = start+1; i <= end; i++){\\n            max_ = max(max_,arr[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 475182,
                "title": "c-recursive-memoization-tabulation-optimized-tabulation",
                "content": "For DP approach, the most imporant thing is to find the recursive equation. We can observe the overlapping subproblems, but not the optimal substructure. This makes the recursive relation for this problem is a bit special and does not have a nice form like a math formula. In fact, we can only try all possibilities of the tree and find the optimal one. \\n\\nHow to generate all possibilities? (This is the hardest part of this problem, in my opinion.)\\nActually, brute force. Split the array at different positions and get the cost for all the ways of splitting, then choose the way that gives the minimum cost. Now you know how to get the recursive equation.\\n\\n```C++\\nclass Solution {\\nprivate:\\n    int maxInRange(vector<int>& v, int l, int r) {\\n        int res = 0;\\n        for(int i = l; i <= r; ++i) res = max(res, v[i]);\\n        return res;\\n    }\\n    \\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        return opTab(arr);\\n    }\\n    \\n    // TLE\\n    int recursive(vector<int>& arr, int l, int r) {\\n        if (l == r) return 0;\\n        if (l + 1 == r) return arr[l] * arr[r];\\n        \\n        int res = INT_MAX;\\n        for(int leftLast = l; leftLast < r; ++leftLast) {\\n            int sum = recursive(arr, l, leftLast) + recursive(arr, leftLast+1, r);\\n            sum += maxInRange(arr, l, leftLast) * maxInRange(arr, leftLast+1, r);\\n            res = min(res, sum);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    // memoization\\n    // Time: more than O(n ^ 3)\\n    // Space: O(n ^ 2)\\n    int memoization(vector<int>& arr) {\\n        vector<vector<int>> mem(arr.size(), vector<int>(arr.size(), -1));\\n        return solve(arr, mem, 0, arr.size() - 1);\\n    }\\n    \\n    /*\\n    Let m = r - l.\\n    No. of iterations = m - 1.\\n    Two maxInRange calls has similar complexity as maxInRange(arr, i, j): O(m).\\n    Thus, complexity of solve: O(m ^ 2).\\n    */\\n    int solve(vector<int>& arr, vector<vector<int>>& mem, int l, int r) {\\n        if (l == r) return 0;\\n        if (l + 1 == r) return arr[l] * arr[r];\\n        if (mem[l][r] >= 0) return mem[l][r];\\n        \\n        mem[l][r] = INT_MAX;\\n        for(int leftLast = l; leftLast < r; ++leftLast) {\\n            int sum = solve(arr, mem, l, leftLast) + solve(arr, mem, leftLast+1, r);\\n            sum += maxInRange(arr, l, leftLast) * maxInRange(arr, leftLast+1, r);\\n            mem[l][r] = min(mem[l][r], sum);\\n        }\\n        return mem[l][r];\\n    }\\n    \\n    \\n    // tabulation\\n    // Time: more than O(n ^ 3)\\n    // Space: O(n ^ 2)\\n    int tabulation(vector<int>& arr) {\\n        vector<vector<int>> tab(arr.size(), vector<int>(arr.size()));\\n        \\n        for(int l = arr.size() - 1; l >= 0; --l) {\\n            for(int r = l; r <= arr.size() - 1; ++r) {\\n                if (l == r) {\\n                    tab[l][r] = 0;\\n                } else if (l + 1 == r) {\\n                    tab[l][r] = arr[l] * arr[r];\\n                } else {\\n                    tab[l][r] = INT_MAX;\\n                    // O(m ^ 2), where m = r - l.\\n                    for(int leftLast = l; leftLast < r; ++leftLast) {\\n                        int sum = tab[l][leftLast] + tab[leftLast+1][r];\\n                        sum += maxInRange(arr, l, leftLast) * maxInRange(arr, leftLast+1, r);\\n                        tab[l][r] = min(tab[l][r], sum);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return tab[0][arr.size() - 1];\\n    }\\n    \\n    \\n    // The process for finding the max value in range can be cached.\\n    // better tabulation\\n    // Time: O(n ^ 3)\\n    // Space: O(n ^ 2)\\n    int opTab(vector<int>& arr) {\\n        vector<vector<int>> tab(arr.size(), vector<int>(arr.size()));\\n        \\n\\t\\t// compute max value for all ranges\\n        vector<vector<int>> maxTab(arr.size(), vector<int>(arr.size()));\\n        for(int i = 0; i < maxTab.size(); ++i) {\\n            maxTab[i][i] = arr[i];\\n            for(int j = i + 1; j < maxTab[0].size(); ++j) {\\n                maxTab[i][j] = max(maxTab[i][j-1], arr[j]);\\n            }\\n        }\\n        \\n        for(int l = arr.size() - 1; l >= 0; --l) {\\n            for(int r = l; r <= arr.size() - 1; ++r) {\\n                if (l == r) {\\n                    tab[l][r] = 0;\\n                } else if (l + 1 == r) {\\n                    tab[l][r] = arr[l] * arr[r];\\n                } else {\\n                    tab[l][r] = INT_MAX;\\n                    for(int leftLast = l; leftLast < r; ++leftLast) {\\n                        int sum = tab[l][leftLast] + tab[leftLast+1][r];\\n                        sum += maxTab[l][leftLast] * maxTab[leftLast+1][r];\\n                        tab[l][r] = min(tab[l][r], sum);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return tab[0][arr.size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```C++\\nclass Solution {\\nprivate:\\n    int maxInRange(vector<int>& v, int l, int r) {\\n        int res = 0;\\n        for(int i = l; i <= r; ++i) res = max(res, v[i]);\\n        return res;\\n    }\\n    \\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        return opTab(arr);\\n    }\\n    \\n    // TLE\\n    int recursive(vector<int>& arr, int l, int r) {\\n        if (l == r) return 0;\\n        if (l + 1 == r) return arr[l] * arr[r];\\n        \\n        int res = INT_MAX;\\n        for(int leftLast = l; leftLast < r; ++leftLast) {\\n            int sum = recursive(arr, l, leftLast) + recursive(arr, leftLast+1, r);\\n            sum += maxInRange(arr, l, leftLast) * maxInRange(arr, leftLast+1, r);\\n            res = min(res, sum);\\n        }\\n        return res;\\n    }\\n    \\n    \\n    // memoization\\n    // Time: more than O(n ^ 3)\\n    // Space: O(n ^ 2)\\n    int memoization(vector<int>& arr) {\\n        vector<vector<int>> mem(arr.size(), vector<int>(arr.size(), -1));\\n        return solve(arr, mem, 0, arr.size() - 1);\\n    }\\n    \\n    /*\\n    Let m = r - l.\\n    No. of iterations = m - 1.\\n    Two maxInRange calls has similar complexity as maxInRange(arr, i, j): O(m).\\n    Thus, complexity of solve: O(m ^ 2).\\n    */\\n    int solve(vector<int>& arr, vector<vector<int>>& mem, int l, int r) {\\n        if (l == r) return 0;\\n        if (l + 1 == r) return arr[l] * arr[r];\\n        if (mem[l][r] >= 0) return mem[l][r];\\n        \\n        mem[l][r] = INT_MAX;\\n        for(int leftLast = l; leftLast < r; ++leftLast) {\\n            int sum = solve(arr, mem, l, leftLast) + solve(arr, mem, leftLast+1, r);\\n            sum += maxInRange(arr, l, leftLast) * maxInRange(arr, leftLast+1, r);\\n            mem[l][r] = min(mem[l][r], sum);\\n        }\\n        return mem[l][r];\\n    }\\n    \\n    \\n    // tabulation\\n    // Time: more than O(n ^ 3)\\n    // Space: O(n ^ 2)\\n    int tabulation(vector<int>& arr) {\\n        vector<vector<int>> tab(arr.size(), vector<int>(arr.size()));\\n        \\n        for(int l = arr.size() - 1; l >= 0; --l) {\\n            for(int r = l; r <= arr.size() - 1; ++r) {\\n                if (l == r) {\\n                    tab[l][r] = 0;\\n                } else if (l + 1 == r) {\\n                    tab[l][r] = arr[l] * arr[r];\\n                } else {\\n                    tab[l][r] = INT_MAX;\\n                    // O(m ^ 2), where m = r - l.\\n                    for(int leftLast = l; leftLast < r; ++leftLast) {\\n                        int sum = tab[l][leftLast] + tab[leftLast+1][r];\\n                        sum += maxInRange(arr, l, leftLast) * maxInRange(arr, leftLast+1, r);\\n                        tab[l][r] = min(tab[l][r], sum);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return tab[0][arr.size() - 1];\\n    }\\n    \\n    \\n    // The process for finding the max value in range can be cached.\\n    // better tabulation\\n    // Time: O(n ^ 3)\\n    // Space: O(n ^ 2)\\n    int opTab(vector<int>& arr) {\\n        vector<vector<int>> tab(arr.size(), vector<int>(arr.size()));\\n        \\n\\t\\t// compute max value for all ranges\\n        vector<vector<int>> maxTab(arr.size(), vector<int>(arr.size()));\\n        for(int i = 0; i < maxTab.size(); ++i) {\\n            maxTab[i][i] = arr[i];\\n            for(int j = i + 1; j < maxTab[0].size(); ++j) {\\n                maxTab[i][j] = max(maxTab[i][j-1], arr[j]);\\n            }\\n        }\\n        \\n        for(int l = arr.size() - 1; l >= 0; --l) {\\n            for(int r = l; r <= arr.size() - 1; ++r) {\\n                if (l == r) {\\n                    tab[l][r] = 0;\\n                } else if (l + 1 == r) {\\n                    tab[l][r] = arr[l] * arr[r];\\n                } else {\\n                    tab[l][r] = INT_MAX;\\n                    for(int leftLast = l; leftLast < r; ++leftLast) {\\n                        int sum = tab[l][leftLast] + tab[leftLast+1][r];\\n                        sum += maxTab[l][leftLast] * maxTab[leftLast+1][r];\\n                        tab[l][r] = min(tab[l][r], sum);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return tab[0][arr.size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 458577,
                "title": "java-readable-top-down-memoization-with-triplets-node-sum-largest-leaf",
                "content": "# Idea\\nBreak the problem into smaller subproblems; what if we can get the product and minimal sums for sub-trees of this product tree?\\n\\nThe intuition here is that since the leaf nodes are ordered, we can consider range-based sub-trees.\\n# Structures\\nThe `Triplet` keeps track of the:\\n- `int node`: this is the product at this point, used to compute the successive cumulative sum\\n- `int sum`: combined with node, this is useful for cacheing the sum to compute the cumulative sum up the subtrees\\n- `int largestLeaf`: for computing the parent node\\'s product, propagated up from the leaf nodes and re-computed at intersections\\n\\nWe want to minimize the `sum`, but require the other two fields to do so.\\n# Memoization\\nWe cache the optimal subtree in range `[left, right]`, where `0 <= left <= right < N`.\\n# Complexity\\nTime: O(N^2) to fill out the memo.\\nSpace: O(N^2) as there are a quadratic number of pairs of `(left, right)`.\\n# Code\\n```\\nclass Solution {\\n    \\n    class Triplet {\\n        public int node;\\n        public int sum;\\n        public int largestLeaf;\\n        public Triplet(int n, int s, int ll) { node = n; sum = s; largestLeaf = ll; }\\n    }\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        Triplet[][] memo = new Triplet[arr.length][arr.length];\\n        return dp(arr, 0, arr.length-1, memo).sum;\\n    }\\n    \\n    private Triplet dp(int[] arr, int left, int right, Triplet[][] memo) {\\n        if (memo[left][right] != null) return memo[left][right];\\n        \\n        Triplet minSum = new Triplet(-1, Integer.MAX_VALUE, -1);\\n        \\n        if (left == right) {\\n\\t\\t    // The solution for the singleton tree is just that node\\n            minSum = new Triplet(arr[left], 0, arr[left]);\\n        }\\n        else {\\n            for (int i = left; i < right; ++i) {\\n                Triplet splitLeft = dp(arr, left, i, memo);\\n                Triplet splitRight = dp(arr, i+1, right, memo);\\n\\t\\t\\t\\t\\n                int product = splitLeft.largestLeaf * splitRight.largestLeaf;\\n                int sum = splitLeft.sum + splitRight.sum + product;\\n\\n                if (sum < minSum.sum) {\\n\\t\\t\\t\\t\\tint largestLeaf = Math.max(splitLeft.largestLeaf, splitRight.largestLeaf);\\n                    minSum = new Triplet(product, sum, largestLeaf);\\n                }\\n            }\\n        }\\n        memo[left][right] = minSum;\\n        \\n        return minSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class Triplet {\\n        public int node;\\n        public int sum;\\n        public int largestLeaf;\\n        public Triplet(int n, int s, int ll) { node = n; sum = s; largestLeaf = ll; }\\n    }\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        Triplet[][] memo = new Triplet[arr.length][arr.length];\\n        return dp(arr, 0, arr.length-1, memo).sum;\\n    }\\n    \\n    private Triplet dp(int[] arr, int left, int right, Triplet[][] memo) {\\n        if (memo[left][right] != null) return memo[left][right];\\n        \\n        Triplet minSum = new Triplet(-1, Integer.MAX_VALUE, -1);\\n        \\n        if (left == right) {\\n\\t\\t    // The solution for the singleton tree is just that node\\n            minSum = new Triplet(arr[left], 0, arr[left]);\\n        }\\n        else {\\n            for (int i = left; i < right; ++i) {\\n                Triplet splitLeft = dp(arr, left, i, memo);\\n                Triplet splitRight = dp(arr, i+1, right, memo);\\n\\t\\t\\t\\t\\n                int product = splitLeft.largestLeaf * splitRight.largestLeaf;\\n                int sum = splitLeft.sum + splitRight.sum + product;\\n\\n                if (sum < minSum.sum) {\\n\\t\\t\\t\\t\\tint largestLeaf = Math.max(splitLeft.largestLeaf, splitRight.largestLeaf);\\n                    minSum = new Triplet(product, sum, largestLeaf);\\n                }\\n            }\\n        }\\n        memo[left][right] = minSum;\\n        \\n        return minSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 416550,
                "title": "brute-force-solution-and-optimised-soltuion-without-dp",
                "content": "We just need to find the smallest product element in each iteration and replace those two with the max value of the two element\\n```\\npublic int mctFromLeafValues(int[] arr) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<arr.length;i++){\\n            list.add(arr[i]);\\n        }\\n        int res = 0;\\n        while(list.size()>1){\\n            int product = Integer.MAX_VALUE;\\n            int index = 0;\\n            for(int i=0;i<list.size()-1;i++){\\n                if(list.get(i)*list.get(i+1)<product){\\n                    product = list.get(i)*list.get(i+1);\\n                    index = i;\\n                }\\n            }\\n            list.set(index, Integer.max(list.get(index), list.get(index+1)));\\n            list.remove(index+1);\\n            res += product;\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\nThere is an optimisation we can do by using stack intead of ArrayList and remove element when we find the next greater because the element either combines with its left element or right element whichever is minimum.\\n```\\npublic int mctFromLeafValues(int[] A) {\\n        int res = 0, n = A.length;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        for (int a : A) {\\n            while (stack.peek() <= a) {\\n                int mid = stack.pop();\\n                res += mid * Math.min(stack.peek(), a);\\n            }\\n            stack.push(a);\\n        }\\n        while (stack.size() > 2) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int mctFromLeafValues(int[] arr) {\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for(int i=0;i<arr.length;i++){\\n            list.add(arr[i]);\\n        }\\n        int res = 0;\\n        while(list.size()>1){\\n            int product = Integer.MAX_VALUE;\\n            int index = 0;\\n            for(int i=0;i<list.size()-1;i++){\\n                if(list.get(i)*list.get(i+1)<product){\\n                    product = list.get(i)*list.get(i+1);\\n                    index = i;\\n                }\\n            }\\n            list.set(index, Integer.max(list.get(index), list.get(index+1)));\\n            list.remove(index+1);\\n            res += product;\\n        }\\n        \\n        return res;\\n    }\\n```\n```\\npublic int mctFromLeafValues(int[] A) {\\n        int res = 0, n = A.length;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);\\n        for (int a : A) {\\n            while (stack.peek() <= a) {\\n                int mid = stack.pop();\\n                res += mid * Math.min(stack.peek(), a);\\n            }\\n            stack.push(a);\\n        }\\n        while (stack.size() > 2) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 340045,
                "title": "python-recursion-with-cache",
                "content": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        cache = {}\\n        def recur(start, end):\\n            if start == end:\\n                return arr[start], 0\\n            \\n            key = f\"{start} {end}\"\\n            if key in cache:\\n                return cache[key]\\n            \\n            local_max, local_sum = 0, math.inf\\n            for i in range(start, end):\\n                left_max, left_sum = recur(start, i)\\n                right_max, right_sum = recur(i + 1, end)\\n                local_max = max(local_max, max(left_max, right_max))\\n                local_sum = min(local_sum, left_sum + right_sum + left_max * right_max)\\n            \\n            cache[key] = local_max, local_sum\\n            \\n            return cache[key]\\n        \\n        return recur(0, len(arr) - 1)[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        cache = {}\\n        def recur(start, end):\\n            if start == end:\\n                return arr[start], 0\\n            \\n            key = f\"{start} {end}\"\\n            if key in cache:\\n                return cache[key]\\n            \\n            local_max, local_sum = 0, math.inf\\n            for i in range(start, end):\\n                left_max, left_sum = recur(start, i)\\n                right_max, right_sum = recur(i + 1, end)\\n                local_max = max(local_max, max(left_max, right_max))\\n                local_sum = min(local_sum, left_sum + right_sum + left_max * right_max)\\n            \\n            cache[key] = local_max, local_sum\\n            \\n            return cache[key]\\n        \\n        return recur(0, len(arr) - 1)[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777595,
                "title": "explained-with-example-c-dp-recursion",
                "content": "**Please Upvote if you find useful.....**\\n\\n**Important Points:**\\n1. The `non-leaf node` is created using **maximum value of left sub-tree and maximum value of right sub-tree.**\\n2. We have to make **partion of the array at all possible point** and Using those partion we have to find non-leaf nodes.\\nLet us take an example  **: [2,8,4,1,3]**\\n![image](https://assets.leetcode.com/users/images/500c80e0-2433-4e98-bd77-4d26343dc163_1645079150.6221445.png)![image](https://assets.leetcode.com/users/images/fd6a230f-5d86-4284-b0b8-6e8edbd79dce_1645079183.5354905.png)\\n\\n\\n\\n\\n**How can you approch this problem:**\\n1. Choose  `two possible point i and j which i is left most and j is right most such that all valid binary tree are created.`ie=>**i=0 and j=n-1.**\\n2. **Using k loops:**: It means you have to **iterate the every possible point b/w  i to j a**nd `find all possible combination.`\\n3. Base case=> As you move further in recursion =>`i and j came closer` . `if i==j ie: one element left so you have to return 0 because no binary tree is created using it.`\\n4. Now you  you have two partions:\\n`left partion---->(i,k)`\\n`right partion--->(k+1,j)`\\nfrom `left partion you have to find maximum value `\\nfrom` right partion you have to find maximum value`\\nans product it,\\n5.These are all `temporary answer so you will have to find minimum of all possible values.`\\n\\nCode:\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<int>&arr,int i,int j)\\n    {\\n\\t//Base case as mention in step 3.\\n        if(i==j)\\n        {\\n            return dp[i][j]= 0;\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n\\t\\t//Final answer (5)\\n        int ans=INT_MAX;\\n        for(int k=i;k<j;k++)\\n        {\\n\\t\\t//Left partion \\n            int left=solve(arr,i,k);\\n\\t\\t\\t//Right Partion\\n            int right=solve(arr,k+1,j);\\n\\t\\t\\t//maximum value in left partion\\n            int max_left=*max_element(arr.begin()+i,arr.begin()+k+1);\\n\\t\\t\\t//maximum value in right partion.\\n            int max_right=*max_element(arr.begin()+k+1,arr.begin()+j+1);\\n\\t\\t\\t// As we to find temprorary answer.\\n            int temp=left+right+max_left*max_right;\\n\\t\\t\\t//Minum of all answer\\n            ans=min(ans,temp);\\n        }\\n        return dp[i][j]= ans;\\n    }\\n    \\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        \\n        int n=arr.size();\\n        for(int i=0;i<=100;i++)\\n        {\\n            for(int j=0;j<=100;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(arr,0,n-1);\\n        \\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[101][101];\\n    int solve(vector<int>&arr,int i,int j)\\n    {\\n\\t//Base case as mention in step 3.\\n        if(i==j)\\n        {\\n            return dp[i][j]= 0;\\n        }\\n        if(dp[i][j]!=-1)\\n        {\\n            return dp[i][j];\\n        }\\n\\t\\t//Final answer (5)\\n        int ans=INT_MAX;\\n        for(int k=i;k<j;k++)\\n        {\\n\\t\\t//Left partion \\n            int left=solve(arr,i,k);\\n\\t\\t\\t//Right Partion\\n            int right=solve(arr,k+1,j);\\n\\t\\t\\t//maximum value in left partion\\n            int max_left=*max_element(arr.begin()+i,arr.begin()+k+1);\\n\\t\\t\\t//maximum value in right partion.\\n            int max_right=*max_element(arr.begin()+k+1,arr.begin()+j+1);\\n\\t\\t\\t// As we to find temprorary answer.\\n            int temp=left+right+max_left*max_right;\\n\\t\\t\\t//Minum of all answer\\n            ans=min(ans,temp);\\n        }\\n        return dp[i][j]= ans;\\n    }\\n    \\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        \\n        int n=arr.size();\\n        for(int i=0;i<=100;i++)\\n        {\\n            for(int j=0;j<=100;j++)\\n            {\\n                dp[i][j]=-1;\\n            }\\n        }\\n        return solve(arr,0,n-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653541,
                "title": "python-monotonic-stack-o-n-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        # O(n) monotonic stack solution\\n        # The general goal is that we wish to minimize products in the tree.\\n        # To do so, we want the lowest value nodes as low of level as possible in the tree \\n\\t\\t# and conversely the higher value nodes as high as possible.\\n        # This is due to the property of non-leaf nodes in the problem where\\n        # the value of each non-leaf node is equal to the product of the largest leaf value \\n\\t\\t# in its left and right subtree.\\n        # The overall intuition is similar to the O(n^2) greedy solution.\\n        # By doing so, we make sure that the greatest elements in the array\\n        # are only in the product calculations for as \"high\" in the tree as possible.\\n        # The local minima (by node value) will end up being at the lowest levels of the tree.\\n        # From a different point of view, you could see it as delaying using the higher value nodes for \\n\\t\\t# as long as possible in the higher levels.\\n        # A monotonic stack allows us to do this by always providing us information\\n        # on the previous smallest \"unused\" node that we have seen so far\\n        # which allows us to solve the problem in 1 pass.\\n        \\n        res = 0\\n        stack = []\\n        \\n        for num in arr:\\n            while len(stack) != 0 and num >= stack[-1]:\\n                # maintain the monotonic stack property by popping elements\\n                \\n                # the middle element is the local minima\\n                # left is the next item on stack\\n                # right is the current num\\n                mid = stack.pop()\\n                if len(stack) == 0:\\n\\t\\t\\t\\t\\t# no left, so use right in product calculation\\n                    res = res + mid * num\\n                else:\\n\\t\\t\\t\\t\\t# select between left and right to minimize cost\\n                    res = res + mid * min(stack[-1], num)\\n         \\n\\t\\t\\t# current element can be added in its place in stack\\n            stack.append(num)\\n        \\n        # by the end, there can be multiple leftover items in the stack\\n        # include them in the cost by just multiplying adjacent nodes\\n        # it is guaranteed optimal because of the monotonic property\\n        while len(stack) > 1: # > 1 because we need a pair to form a product\\n            res = res + stack.pop() * stack[-1]\\n        \\n        return res\\n```\\n\\nI suggest running through the code and drawing the stack as well as the in progress tree to really understand the algorithm. You will be able to visualize how the tree is created bottom-up with minimal cost.\\n\\nTime complexity: O(n) since we iterate through the array once and we push and pop each element to the stack only once.\\nSpace complexity: O(n) from the monotonic stack.\\n",
                "solutionTags": [
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        # O(n) monotonic stack solution\\n        # The general goal is that we wish to minimize products in the tree.\\n        # To do so, we want the lowest value nodes as low of level as possible in the tree \\n\\t\\t# and conversely the higher value nodes as high as possible.\\n        # This is due to the property of non-leaf nodes in the problem where\\n        # the value of each non-leaf node is equal to the product of the largest leaf value \\n\\t\\t# in its left and right subtree.\\n        # The overall intuition is similar to the O(n^2) greedy solution.\\n        # By doing so, we make sure that the greatest elements in the array\\n        # are only in the product calculations for as \"high\" in the tree as possible.\\n        # The local minima (by node value) will end up being at the lowest levels of the tree.\\n        # From a different point of view, you could see it as delaying using the higher value nodes for \\n\\t\\t# as long as possible in the higher levels.\\n        # A monotonic stack allows us to do this by always providing us information\\n        # on the previous smallest \"unused\" node that we have seen so far\\n        # which allows us to solve the problem in 1 pass.\\n        \\n        res = 0\\n        stack = []\\n        \\n        for num in arr:\\n            while len(stack) != 0 and num >= stack[-1]:\\n                # maintain the monotonic stack property by popping elements\\n                \\n                # the middle element is the local minima\\n                # left is the next item on stack\\n                # right is the current num\\n                mid = stack.pop()\\n                if len(stack) == 0:\\n\\t\\t\\t\\t\\t# no left, so use right in product calculation\\n                    res = res + mid * num\\n                else:\\n\\t\\t\\t\\t\\t# select between left and right to minimize cost\\n                    res = res + mid * min(stack[-1], num)\\n         \\n\\t\\t\\t# current element can be added in its place in stack\\n            stack.append(num)\\n        \\n        # by the end, there can be multiple leftover items in the stack\\n        # include them in the cost by just multiplying adjacent nodes\\n        # it is guaranteed optimal because of the monotonic property\\n        while len(stack) > 1: # > 1 because we need a pair to form a product\\n            res = res + stack.pop() * stack[-1]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1027170,
                "title": "dp-filling-order-graph-visualization",
                "content": "Code:\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [[float(\\'inf\\') for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = 0\\n        \\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                j = i + l - 1\\n                for k in range(i, j):\\n                    rootVal = max(arr[i:k+1]) * max(arr[k+1:j+1])\\n                    dp[i][j] = min(dp[i][j], rootVal + dp[i][k] + dp[k + 1][j])\\n        return dp[0][n - 1]\\n```\\n\\nGraph:\\n![image](https://assets.leetcode.com/users/images/d9508a4c-a24d-436a-85b2-8f5104e0b9b7_1611202141.8838825.png)\\n\\nThe code come from this amazing post: https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/478708/RZ-Summary-of-all-the-solutions-I-have-learned-from-Discuss-in-Python\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [[float(\\'inf\\') for _ in range(n)] for _ in range(n)]\\n        for i in range(n):\\n            dp[i][i] = 0\\n        \\n        for l in range(2, n + 1):\\n            for i in range(n - l + 1):\\n                j = i + l - 1\\n                for k in range(i, j):\\n                    rootVal = max(arr[i:k+1]) * max(arr[k+1:j+1])\\n                    dp[i][j] = min(dp[i][j], rootVal + dp[i][k] + dp[k + 1][j])\\n        return dp[0][n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992974,
                "title": "divide-and-conquer-with-explanation-short-fast-o-nlogn",
                "content": "Let say we have an inteval [s, e], and we already knew the max value and its position in this interval. The interval then can be divided into 3 parts:  left subtree, the max value, and the right subtree. To minimize the sum, we hope to reduce the level of the max value (i.e., put the max value close to root as much as possible.), because the higher position the max value is at, the less it will have chance to multiply with other values. And there wil be only two possible case shown in the following figure.\\n![image](https://assets.leetcode.com/users/images/6d37a675-8aa0-42e5-9f32-03c2fe009366_1609282911.2095585.png)\\nHowever, both of the cases have the same results, which is:\\n![image](https://assets.leetcode.com/users/images/94a0e4c7-fde3-4665-b1aa-6711558f3935_1609283107.0855892.png)\\nTherefore, all the steps are:\\n1. Find the max value and its position of the given interval.\\n2. Put left and right parts into recusive function to retrieve their max value and sum.\\n3. Calculate and return the sum using the formula above.\\nThe code:\\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n     return divide(arr, 0, arr.length)[1];\\n    }\\n\\n    int[] divide(int[] arr, int s, int e) {\\n        if (s == e)\\n            return new int[]{0, 0};                \\n        if (e - s == 1)\\n            return new int[]{arr[s], 0};\\n        int mx = s;\\n        for (int i = s; i < e; i++)                \\n            mx = (arr[i] > arr[mx])? i: mx;\\n        int [] left = divide(arr, s, mx), right = divide(arr, mx+1, e);             \\n        return new int[]{arr[mx], left[1] + right[1] + arr[mx] * (left[0] + right[0])};\\n    }\\n}\\n```\\nComplexity: time = O(N*logN), space = O(1)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n     return divide(arr, 0, arr.length)[1];\\n    }\\n\\n    int[] divide(int[] arr, int s, int e) {\\n        if (s == e)\\n            return new int[]{0, 0};                \\n        if (e - s == 1)\\n            return new int[]{arr[s], 0};\\n        int mx = s;\\n        for (int i = s; i < e; i++)                \\n            mx = (arr[i] > arr[mx])? i: mx;\\n        int [] left = divide(arr, s, mx), right = divide(arr, mx+1, e);             \\n        return new int[]{arr[mx], left[1] + right[1] + arr[mx] * (left[0] + right[0])};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971171,
                "title": "this-is-not-dp-c-with-time-o-n-and-space-o-n",
                "content": "```\\nint mctFromLeafValues(vector<int>& arr) {\\n\\tif (arr.size() == 2)\\n\\t\\treturn arr[0] * arr[1];\\n\\tint res = 0;\\n\\tvector<int> stack = { INT_MAX };\\n\\tfor (auto a : arr) {\\n\\t\\twhile (a >= stack.back()){\\n\\t\\t\\tint mid = stack.back();\\n\\t\\t\\tstack.pop_back();\\n\\t\\t\\tres += mid * min(a, stack.back());\\n\\t\\t}\\n\\t\\tstack.push_back(a);\\n\\t}\\n\\tfor (int i = 1; i < stack.size() - 1; i++) {\\n\\t\\tres += stack[i] * stack[i + 1];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint mctFromLeafValues(vector<int>& arr) {\\n\\tif (arr.size() == 2)\\n\\t\\treturn arr[0] * arr[1];\\n\\tint res = 0;\\n\\tvector<int> stack = { INT_MAX };\\n\\tfor (auto a : arr) {\\n\\t\\twhile (a >= stack.back()){\\n\\t\\t\\tint mid = stack.back();\\n\\t\\t\\tstack.pop_back();\\n\\t\\t\\tres += mid * min(a, stack.back());\\n\\t\\t}\\n\\t\\tstack.push_back(a);\\n\\t}\\n\\tfor (int i = 1; i < stack.size() - 1; i++) {\\n\\t\\tres += stack[i] * stack[i + 1];\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 917569,
                "title": "c-all-approaches-stack-greedy-and-dp",
                "content": "### Monotonic Stack solution (beats 100%):\\n```\\nint mono_stack(vector<int>& v) {\\n\\tint c=0;\\n\\tstack<int> st;\\n\\tfor(int i:v) {\\n\\t\\twhile(!st.empty() && st.top() <= i) {\\n\\t\\t\\tint x = st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\tc += x * min(st.empty() ? INT_MAX : st.top(),i);\\n\\t\\t}\\n\\t\\tst.push(i);\\n\\t}\\n\\tint a = st.top();\\n\\tst.pop();\\n\\twhile(!st.empty()) {\\n\\t\\tint x = st.top();\\n\\t\\tst.pop();\\n\\t\\tc += x * min(st.empty() ? INT_MAX : st.top(), a);\\n\\t\\ta = x;\\n\\t}\\n\\treturn c;\\n}\\n```\\n### Greedy solution (beats ~50%):\\n```\\nint greedy(vector<int>& v) {\\n\\tint t = 0;\\n\\twhile(v.size() > 1) {\\n\\t\\tint in = min_element(v.begin(),v.end()) - v.begin();\\n\\t\\tt += min(in>=1 ? v[in-1] : INT_MAX, in<v.size()-1 ? v[in+1] : INT_MAX) * v[in];\\n\\t\\tv.erase(v.begin()+in);\\n\\t}\\n\\treturn t;\\n}\\n```\\n### Recursive approach (TLE):\\n```\\nint rec(vector<int>& v, int l, int r) {\\n\\tif(l==r) return 0;\\n\\tint mn = INT_MAX;\\n\\tfor(int i=l; i<r; i++) {\\n\\t\\tint x = rec(v,l,i);\\n\\t\\tint y = rec(v,i+1,r);\\n\\t\\tint t = x + y + *max_element(v.begin()+l,v.begin()+i+1) * *max_element(v.begin()+i+1, v.begin()+r+1);\\n\\t\\tmn = min(mn, t);\\n\\t}\\n\\treturn mn;\\n}\\n```\\n### DP solution (based on above approach; beats ~10%):\\n```\\nint dp(vector<int>& v) {\\n\\tint n = v.size();\\n\\tvector<vector<int>> dp(n,vector<int>(n,0));\\n\\tfor(int j=0; j<n; j++) {\\n\\t\\tfor(int i=j; i>-1; i--) {\\n\\t\\t\\tfor(int k=i; k<j; k++) {\\n\\t\\t\\t\\tint x = dp[i][k];\\n\\t\\t\\t\\tint y = dp[k+1][j];\\n\\t\\t\\t\\tint t = x + y + *max_element(v.begin()+i,v.begin()+k+1) * *max_element(v.begin()+k+1,v.begin()+j+1);\\n\\t\\t\\t\\tdp[i][j] = !dp[i][j] ? t : min(dp[i][j],t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][n-1];\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Stack",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nint mono_stack(vector<int>& v) {\\n\\tint c=0;\\n\\tstack<int> st;\\n\\tfor(int i:v) {\\n\\t\\twhile(!st.empty() && st.top() <= i) {\\n\\t\\t\\tint x = st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\tc += x * min(st.empty() ? INT_MAX : st.top(),i);\\n\\t\\t}\\n\\t\\tst.push(i);\\n\\t}\\n\\tint a = st.top();\\n\\tst.pop();\\n\\twhile(!st.empty()) {\\n\\t\\tint x = st.top();\\n\\t\\tst.pop();\\n\\t\\tc += x * min(st.empty() ? INT_MAX : st.top(), a);\\n\\t\\ta = x;\\n\\t}\\n\\treturn c;\\n}\\n```\n```\\nint greedy(vector<int>& v) {\\n\\tint t = 0;\\n\\twhile(v.size() > 1) {\\n\\t\\tint in = min_element(v.begin(),v.end()) - v.begin();\\n\\t\\tt += min(in>=1 ? v[in-1] : INT_MAX, in<v.size()-1 ? v[in+1] : INT_MAX) * v[in];\\n\\t\\tv.erase(v.begin()+in);\\n\\t}\\n\\treturn t;\\n}\\n```\n```\\nint rec(vector<int>& v, int l, int r) {\\n\\tif(l==r) return 0;\\n\\tint mn = INT_MAX;\\n\\tfor(int i=l; i<r; i++) {\\n\\t\\tint x = rec(v,l,i);\\n\\t\\tint y = rec(v,i+1,r);\\n\\t\\tint t = x + y + *max_element(v.begin()+l,v.begin()+i+1) * *max_element(v.begin()+i+1, v.begin()+r+1);\\n\\t\\tmn = min(mn, t);\\n\\t}\\n\\treturn mn;\\n}\\n```\n```\\nint dp(vector<int>& v) {\\n\\tint n = v.size();\\n\\tvector<vector<int>> dp(n,vector<int>(n,0));\\n\\tfor(int j=0; j<n; j++) {\\n\\t\\tfor(int i=j; i>-1; i--) {\\n\\t\\t\\tfor(int k=i; k<j; k++) {\\n\\t\\t\\t\\tint x = dp[i][k];\\n\\t\\t\\t\\tint y = dp[k+1][j];\\n\\t\\t\\t\\tint t = x + y + *max_element(v.begin()+i,v.begin()+k+1) * *max_element(v.begin()+k+1,v.begin()+j+1);\\n\\t\\t\\t\\tdp[i][j] = !dp[i][j] ? t : min(dp[i][j],t);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][n-1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 667294,
                "title": "python-concise-dp-bottom-up-top-down",
                "content": "Find best non-dp approch from @lee215  at [link](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\nTime: `O(N^3)`\\nSpace: `O(N^2)`\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [[(0, 0)] * n for _ in range(n)] # (max_val, min_cost)\\n        \\'\\'\\'\\n        # memorization\\n        def helper(l, r):\\n            if dp[l][r][0] != 0: return dp[l][r]\\n            if l == r: return (arr[l], 0)\\n            max_val, min_cost = 0, float(\\'inf\\')\\n            for i in range(l, r):\\n                val_l, val_r = helper(l, i), helper(i+1, r)\\n                max_val = max(val_l[0], val_r[0])\\n                min_cost = min(min_cost, val_l[1] + val_r[1] + val_l[0]*val_r[0])\\n            dp[l][r] = (max_val, min_cost)\\n            return dp[l][r]\\n        return helper(0, n-1)[1]\\n        \\'\\'\\'\\n        # bottom up\\n        for size in range(n):\\n            for i in range(n-size):\\n                # [i, i+size]\\n                if size == 0:\\n                    dp[i][i+size] = (arr[i], 0)\\n                    continue\\n                max_val, min_cost = 0, float(\\'inf\\')\\n                for j in range(i, i+size):\\n                    max_val = max(dp[i][j][0], dp[j+1][i+size][0])\\n                    min_cost = min(min_cost, dp[i][j][1] + dp[j+1][i+size][1] + dp[i][j][0]*dp[j+1][i+size][0])\\n                dp[i][i+size] = (max_val, min_cost)\\n        return dp[0][n-1][1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dp = [[(0, 0)] * n for _ in range(n)] # (max_val, min_cost)\\n        \\'\\'\\'\\n        # memorization\\n        def helper(l, r):\\n            if dp[l][r][0] != 0: return dp[l][r]\\n            if l == r: return (arr[l], 0)\\n            max_val, min_cost = 0, float(\\'inf\\')\\n            for i in range(l, r):\\n                val_l, val_r = helper(l, i), helper(i+1, r)\\n                max_val = max(val_l[0], val_r[0])\\n                min_cost = min(min_cost, val_l[1] + val_r[1] + val_l[0]*val_r[0])\\n            dp[l][r] = (max_val, min_cost)\\n            return dp[l][r]\\n        return helper(0, n-1)[1]\\n        \\'\\'\\'\\n        # bottom up\\n        for size in range(n):\\n            for i in range(n-size):\\n                # [i, i+size]\\n                if size == 0:\\n                    dp[i][i+size] = (arr[i], 0)\\n                    continue\\n                max_val, min_cost = 0, float(\\'inf\\')\\n                for j in range(i, i+size):\\n                    max_val = max(dp[i][j][0], dp[j+1][i+size][0])\\n                    min_cost = min(min_cost, dp[i][j][1] + dp[j+1][i+size][1] + dp[i][j][0]*dp[j+1][i+size][0])\\n                dp[i][i+size] = (max_val, min_cost)\\n        return dp[0][n-1][1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520825,
                "title": "python3-a-greedy-algo",
                "content": "Algorithm (greedy): \\nPer @jadore801120 in this [thread](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution), recursively locste the minimum element and \"combine\" it with its smaller neighbor. \\n\\nImplementation (20ms, 99.43):\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        ans = 0\\n        while len(arr) > 1: \\n            i = arr.index(min(arr))\\n            ans += arr.pop(i)*min(arr[max(0,i-1):i+1])\\n        return ans\\n```\\n\\nAnalysis:\\nTime complexity `O(N^2)`\\nSpace complexity `O(1)`\\n\\nIn contrast, dp runs a lot slower than the above greedy algo\\n\\n(260ms, 26.11%): \\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def dp(i, j): \\n            \"\"\"Return \"\"\"\\n            if i+1 == j: return 0\\n            return min(max(arr[i:k])*max(arr[k:j]) + dp(i, k) + dp(k, j) for k in range(i+1, j))\\n        \\n        return dp(0, len(arr))\\n```\\n\\nEdited on 4/20/2021\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        ans = 0 \\n        stack = []\\n        for x in arr: \\n            while stack and stack[-1] <= x: \\n                val = stack.pop()\\n                ans += val * min(stack[-1] if stack else inf, x)\\n            stack.append(x)\\n        return ans + sum(stack[i-1]*stack[i] for i in range(1, len(stack)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        ans = 0\\n        while len(arr) > 1: \\n            i = arr.index(min(arr))\\n            ans += arr.pop(i)*min(arr[max(0,i-1):i+1])\\n        return ans\\n```\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        \\n        @lru_cache(None)\\n        def dp(i, j): \\n            \"\"\"Return \"\"\"\\n            if i+1 == j: return 0\\n            return min(max(arr[i:k])*max(arr[k:j]) + dp(i, k) + dp(k, j) for k in range(i+1, j))\\n        \\n        return dp(0, len(arr))\\n```\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        ans = 0 \\n        stack = []\\n        for x in arr: \\n            while stack and stack[-1] <= x: \\n                val = stack.pop()\\n                ans += val * min(stack[-1] if stack else inf, x)\\n            stack.append(x)\\n        return ans + sum(stack[i-1]*stack[i] for i in range(1, len(stack)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 385823,
                "title": "1130-minimum-cost-tree-from-leaf-values-javascript-48ms",
                "content": "```js\\nvar mctFromLeafValues = function(arr) {\\n    let sum = 0;\\n    while(arr.length !== 1){\\n        let min = Number.MAX_SAFE_INTEGER;\\n        let cur = 0;\\n        for(let i = 0; i < arr.length - 1; i++){\\n            let product = arr[i] * arr[i + 1];\\n            if(product < min){\\n                min = product;\\n                cur = i;\\n            }\\n        }\\n        sum += min;\\n        let maxInPair = Math.max(arr[cur], arr[cur + 1]);\\n        arr.splice(cur, 2, maxInPair)\\n    }\\n    return sum;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar mctFromLeafValues = function(arr) {\\n    let sum = 0;\\n    while(arr.length !== 1){\\n        let min = Number.MAX_SAFE_INTEGER;\\n        let cur = 0;\\n        for(let i = 0; i < arr.length - 1; i++){\\n            let product = arr[i] * arr[i + 1];\\n            if(product < min){\\n                min = product;\\n                cur = i;\\n            }\\n        }\\n        sum += min;\\n        let maxInPair = Math.max(arr[cur], arr[cur + 1]);\\n        arr.splice(cur, 2, maxInPair)\\n    }\\n    return sum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2599541,
                "title": "c-simple-dp-clever-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[40][40]={0};\\n    int solve(vector<int> arr,int start,int end)\\n    {\\n        if(start==end)\\n            return 0;\\n        if(dp[start][end]!=0)\\n            return dp[start][end];\\n        int mn=INT_MAX;\\n        for(int i=start;i<=end-1;i++)\\n        {\\n            int left=solve(arr,start,i);\\n            int right=solve(arr,i+1,end);\\n            int temp=left+right+*max_element(arr.begin()+start,arr.begin()+i+1) * *max_element(arr.begin()+i+1,arr.begin()+end+1);\\n            mn=min(mn,temp);\\n            \\n        }\\n        return dp[start][end]=mn;\\n    }\\n    int mctFromLeafValues(vector<int>& arr)\\n    {\\n        return solve(arr,0,arr.size()-1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int dp[40][40]={0}",
                "codeTag": "Java"
            },
            {
                "id": 2327793,
                "title": "c-memoization-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    int fun(int i, int j, vector<int>& arr){\\n        if(i == j)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        \\n        int ans = INT_MAX;\\n        for(int k = i; k < j; k++){\\n            \\n            int lm = 0 , rm = 0;\\n            \\n            for(int x = i; x <= k; x++)\\n                lm = max(lm,arr[x]);\\n            \\n            for(int x = k+1; x <= j; x++)\\n                rm = max(rm,arr[x]);\\n            \\n            ans = min(ans, fun(i,k,arr) + fun(k+1,j,arr) + (lm*rm));\\n        }\\n        \\n        return dp[i][j] = ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        \\n        dp = vector<vector<int>> (n, vector<int>(n , -1));\\n        return fun(0,n-1,arr);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<vector<int>> dp;\\n    \\n    int fun(int i, int j, vector<int>& arr){\\n        if(i == j)\\n            return 0;\\n        if(dp[i][j] != -1)\\n            return dp[i][j];\\n        \\n        \\n        int ans = INT_MAX;\\n        for(int k = i; k < j; k++){\\n            \\n            int lm = 0 , rm = 0;\\n            \\n            for(int x = i; x <= k; x++)\\n                lm = max(lm,arr[x]);\\n            \\n            for(int x = k+1; x <= j; x++)\\n                rm = max(rm,arr[x]);\\n            \\n            ans = min(ans, fun(i,k,arr) + fun(k+1,j,arr) + (lm*rm));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2246028,
                "title": "mcm-c-aditya-verma-template-mcm-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[50][50];\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        int  n = arr.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return mcm(arr, 0, n-1);\\n        \\n    }\\n    \\n    long long mcm(vector<int>& arr, int i, int j){\\n        \\n        if(i>=j)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        long ans = 1e12;\\n        \\n        for(int k = i; k<j ; k++){\\n            \\n            long c = mcm(arr,i,k) + mcm(arr,k+1,j);\\n            \\n            int a = arr[i];\\n            int b = arr[j];\\n            \\n            for(int p = i; p<=k ; p++)a = max(a,arr[p]);\\n            for(int p = k+1; p<=j; p++)b= max(b, arr[p]);\\n                        \\n            ans = min(ans, c + a*b);\\n        }\\n        \\n        return dp[i][j] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[50][50];\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        int  n = arr.size();\\n        memset(dp,-1,sizeof(dp));\\n        \\n        return mcm(arr, 0, n-1);\\n        \\n    }\\n    \\n    long long mcm(vector<int>& arr, int i, int j){\\n        \\n        if(i>=j)return 0;\\n        if(dp[i][j] != -1)return dp[i][j];\\n        long ans = 1e12;\\n        \\n        for(int k = i; k<j ; k++){\\n            \\n            long c = mcm(arr,i,k) + mcm(arr,k+1,j);\\n            \\n            int a = arr[i];\\n            int b = arr[j];\\n            \\n            for(int p = i; p<=k ; p++)a = max(a,arr[p]);\\n            for(int p = k+1; p<=j; p++)b= max(b, arr[p]);\\n                        \\n            ans = min(ans, c + a*b);\\n        }\\n        \\n        return dp[i][j] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113819,
                "title": "c-easy-dp-solution",
                "content": "```\\nclass Solution {\\nprivate:\\n\\tint dp[41][41];\\n\\tint maxi[41][41];\\n\\n\\tint solve(int left, int right) {\\n\\t\\t//leaf node\\n\\t\\tif (left == right) return 0;\\n\\t\\tif (dp[left][right] != -1) return dp[left][right];\\n\\n\\t\\tint ans = INT_MAX;\\n\\n\\t\\t// divide into 2 parts\\n\\t\\tfor (int i = left; i < right; ++i) {\\n\\t\\t\\tans = min(ans, maxi[left][i] * maxi[i + 1][right] + solve(left, i) + solve(i + 1, right));\\n\\t\\t}\\n\\t\\treturn dp[left][right] = ans;\\n\\t}\\npublic:\\n\\tint mctFromLeafValues(vector<int>& a) {\\n\\t\\tint n = a.size();\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\n\\t\\t//calculate max till j maxi[i][j] = max from i to j\\n\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tmaxi[i][i] = a[i];\\n\\t\\t\\tfor (int j = i + 1; j < n; ++j) {\\n\\t\\t\\t\\tmaxi[i][j] = max(maxi[i][j - 1], a[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn solve(0, n - 1);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\tint dp[41][41];\\n\\tint maxi[41][41];\\n\\n\\tint solve(int left, int right) {\\n\\t\\t//leaf node\\n\\t\\tif (left == right) return 0;\\n\\t\\tif (dp[left][right] != -1) return dp[left][right];\\n\\n\\t\\tint ans = INT_MAX;\\n\\n\\t\\t// divide into 2 parts\\n\\t\\tfor (int i = left; i < right; ++i) {\\n\\t\\t\\tans = min(ans, maxi[left][i] * maxi[i + 1][right] + solve(left, i) + solve(i + 1, right));\\n\\t\\t}\\n\\t\\treturn dp[left][right] = ans;\\n\\t}\\npublic:\\n\\tint mctFromLeafValues(vector<int>& a) {\\n\\t\\tint n = a.size();\\n\\t\\tmemset(dp, -1, sizeof(dp));\\n\\n\\t\\t//calculate max till j maxi[i][j] = max from i to j\\n\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tmaxi[i][i] = a[i];\\n\\t\\t\\tfor (int j = i + 1; j < n; ++j) {\\n\\t\\t\\t\\tmaxi[i][j] = max(maxi[i][j - 1], a[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn solve(0, n - 1);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036590,
                "title": "optimized-c-code-single-while-loop-78-time-72-memory",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int ans = 0, i = 0;\\n        int min_val = INT_MAX, idx;\\n        while(i < arr.size()-1 && arr.size() != 2)\\n        {\\n            if(arr[i]*arr[i+1] < min_val)\\n            {\\n                idx = i;\\n                min_val = arr[i]*arr[i+1];\\n            }\\n            if(i == arr.size()-2)\\n            {\\n                ans += min_val;\\n                min_val = INT_MAX;\\n                if(arr[idx] > arr[idx+1])\\n                    arr.erase(arr.begin()+(idx+1));\\n                else\\n                    arr.erase(arr.begin()+idx);\\n                i = -1;\\n            }\\n            i++;\\n        }\\n        ans += arr[0]*arr[1];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int ans = 0, i = 0;\\n        int min_val = INT_MAX, idx;\\n        while(i < arr.size()-1 && arr.size() != 2)\\n        {\\n            if(arr[i]*arr[i+1] < min_val)\\n            {\\n                idx = i;\\n                min_val = arr[i]*arr[i+1];\\n            }\\n            if(i == arr.size()-2)\\n            {\\n                ans += min_val;\\n                min_val = INT_MAX;\\n                if(arr[idx] > arr[idx+1])\\n                    arr.erase(arr.begin()+(idx+1));\\n                else\\n                    arr.erase(arr.begin()+idx);\\n                i = -1;\\n            }\\n            i++;\\n        }\\n        ans += arr[0]*arr[1];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603827,
                "title": "80-fast",
                "content": "class Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n=arr.size(),ans=0;\\n        \\n        pair<int,int> dp[n][n];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<n-i;j++){\\n                \\n                int r=j,c=j+i;\\n                // cout<<r<<\" \"<<c<<endl;\\n                \\n                if(r==c){\\n                    dp[r][c]={0,arr[r]};\\n                }else{\\n                    dp[r][c]={INT_MAX,0};\\n                    for(int k=r;k<c;k++){\\n                        \\n                        int lm=dp[r][k].second,rm=dp[k+1][c].second;\\n                        int sum=dp[r][k].first+dp[k+1][c].first+lm*rm;\\n                        \\n                        if(sum<dp[r][c].first){\\n                            dp[r][c]={sum,max(lm,rm)};\\n                        }\\n                        \\n                    }\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        \\n//         for(int i=0;i<n;i++){\\n            \\n//             for(int j=0;j<n-i;j++){\\n                \\n//                 int r=j,c=j+i;\\n                \\n//                 cout<<dp[r][c].first<<\" \"<<dp[r][c].second<<endl;\\n                \\n//             }\\n//         }\\n        \\n        return dp[0][n-1].first;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n=arr.size(),ans=0;\\n        \\n        pair<int,int> dp[n][n];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            for(int j=0;j<n-i;j++){\\n                \\n                int r=j,c=j+i;\\n                // cout<<r<<\" \"<<c<<endl;\\n                \\n                if(r==c){\\n                    dp[r][c]={0,arr[r]}",
                "codeTag": "C++"
            },
            {
                "id": 1430060,
                "title": "c-0-ms-faster-than-100-monostack",
                "content": "Since the non-leaf node value is the product of previous largest leaf and new leaf, the problem can be considered as a monostack problem.\\nIn order to find PGE (Previous Greater Element), the stack should be monotonous decreasing stack.\\n\\nFor the example: [6,2,7,8]\\n\\n|stack | push | pop | ans|\\n|--|--|--|--|\\nnull    | 6       | null | 0\\n6       | 2        | null | 0\\n6, 2     | 7        | 2, 6 | ans += 2 * 6 + 6 * 7\\n7       | 8        | 7     | ans += 7 * 8\\n8       | null     | 8 \\n\\nans = 110\\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size(), ans = 0;;\\n        vector<int> st;\\n        for (int i = 0; i < n; ++i) {\\n            int leaf = 0;\\n            while(!st.empty() && st.back() < arr[i]) {\\n                ans += leaf * st.back();\\n                leaf = st.back(); st.pop_back();\\n            }\\n            ans += leaf * arr[i];\\n            st.push_back(arr[i]);\\n        }\\n        for(int i = 0; i < st.size() - 1; ++i) {\\n            ans += st[i] * st[i + 1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size(), ans = 0;;\\n        vector<int> st;\\n        for (int i = 0; i < n; ++i) {\\n            int leaf = 0;\\n            while(!st.empty() && st.back() < arr[i]) {\\n                ans += leaf * st.back();\\n                leaf = st.back(); st.pop_back();\\n            }\\n            ans += leaf * arr[i];\\n            st.push_back(arr[i]);\\n        }\\n        for(int i = 0; i < st.size() - 1; ++i) {\\n            ans += st[i] * st[i + 1];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356573,
                "title": "python-dp-solution-using-matrix-chain-multiplication-template",
                "content": "Our formula is that of matrix chain multiplication:\\n\\n```python\\ndp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + (maxA[i][k] * maxA[k + 1][j]))\\n```\\n\\nNow, in this we go diagonal wise. We move towards top right corner from the center diagonal.\\n\\nWe use `l` to denote the level, `l=0` being the center diagonal. Then `i` would lie in `[0, n-l)` and `j` would be `i+l`.\\n\\n```python\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n    n = len(arr)\\n    \\n    dp = [[0 for j in range(n)] for i in range(n)]\\n    \\n    maxA = [[0 for j in range(n)] for i in range(n)]\\n    \\n    for i in range(n):\\n        maxA[i][i] = arr[i]\\n        \\n    for i in range(n):\\n        for j in range(i+1, n):\\n            maxA[i][j] = max(maxA[i][j-1], arr[j])\\n            \\n\\n    for l in range(1, n):\\n        for i in range(n - l):\\n            j = i + l\\n            for k in range(i, j):\\n                if dp[i][j] == 0:\\n                    dp[i][j] = dp[i][k] + dp[k+1][j] + (maxA[i][k] * maxA[k + 1][j])\\n                else:\\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + (maxA[i][k] * maxA[k + 1][j]))\\n                                   \\n    return dp[0][n-1]\\n```\\n\\nO(n ^ 3) time and O(n ^ 2) space",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\ndp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + (maxA[i][k] * maxA[k + 1][j]))\\n```\n```python\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n    n = len(arr)\\n    \\n    dp = [[0 for j in range(n)] for i in range(n)]\\n    \\n    maxA = [[0 for j in range(n)] for i in range(n)]\\n    \\n    for i in range(n):\\n        maxA[i][i] = arr[i]\\n        \\n    for i in range(n):\\n        for j in range(i+1, n):\\n            maxA[i][j] = max(maxA[i][j-1], arr[j])\\n            \\n\\n    for l in range(1, n):\\n        for i in range(n - l):\\n            j = i + l\\n            for k in range(i, j):\\n                if dp[i][j] == 0:\\n                    dp[i][j] = dp[i][k] + dp[k+1][j] + (maxA[i][k] * maxA[k + 1][j])\\n                else:\\n                    dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + (maxA[i][k] * maxA[k + 1][j]))\\n                                   \\n    return dp[0][n-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1051912,
                "title": "simple-and-easy-understanding-in-java",
                "content": "```\\nclass Solution {\\n       public int mctFromLeafValues(int[] A) {\\n        int res = 0;\\n       \\n        List<Integer> l=new ArrayList<>();\\n        for(int x:A)l.add(x);\\n           \\n        boolean isCleaned=false;\\n        while(!isCleaned){\\n            \\n            int min=Integer.MAX_VALUE;\\n            int minLeg1index=0;\\n            int minLeg2index=0;\\n            \\n            for(int i=1; i<l.size(); i++){\\n               if(min>l.get(i-1)*l.get(i)){\\n                   min=l.get(i-1)*l.get(i);\\n                   minLeg1index=i-1;\\n                   minLeg2index=i;\\n               }\\n             }\\n            \\n            if(l.get(minLeg1index)>l.get(minLeg2index))\\n                l.remove(minLeg2index);\\n            else \\n                l.remove(minLeg1index);\\n            \\n            if(l.size()<2)\\n                isCleaned=true;\\n            \\n         res+=min;\\n        }   \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n       public int mctFromLeafValues(int[] A) {\\n        int res = 0;\\n       \\n        List<Integer> l=new ArrayList<>();\\n        for(int x:A)l.add(x);\\n           \\n        boolean isCleaned=false;\\n        while(!isCleaned){\\n            \\n            int min=Integer.MAX_VALUE;\\n            int minLeg1index=0;\\n            int minLeg2index=0;\\n            \\n            for(int i=1; i<l.size(); i++){\\n               if(min>l.get(i-1)*l.get(i)){\\n                   min=l.get(i-1)*l.get(i);\\n                   minLeg1index=i-1;\\n                   minLeg2index=i;\\n               }\\n             }\\n            \\n            if(l.get(minLeg1index)>l.get(minLeg2index))\\n                l.remove(minLeg2index);\\n            else \\n                l.remove(minLeg1index);\\n            \\n            if(l.size()<2)\\n                isCleaned=true;\\n            \\n         res+=min;\\n        }   \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050470,
                "title": "one-pass-stack-without-pushing-extra-max-value",
                "content": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] A) {\\n        int res = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        for (int a : A) {\\n            while (!stack.isEmpty() && stack.peek() <= a) {\\n                int mid = stack.pop();\\n                if (stack.isEmpty()) res += mid * a;\\n                else res += mid * Math.min(stack.peek(), a);\\n            }\\n            stack.push(a);\\n        }\\n        while (stack.size() > 1) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nModify from lee215\\'s solution, I understand the solution most part except the Maximum value part, in the comment section he noted that the reason why we push max value at the beging of the stack is bacause we want make sure the stack is not empty, which I couldn\\'t make sense at the time.\\n\\nAfter did some scruitiny, I realize that since under condition like [6,2,5] (in the code: a = 5, stack [6, 2]), we need chose the smaller one between 6 and 5, this only happens if the stack has at least 2 value, if it\\'s only contains one element, then we need count that as one non-leaf node as well",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] A) {\\n        int res = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        for (int a : A) {\\n            while (!stack.isEmpty() && stack.peek() <= a) {\\n                int mid = stack.pop();\\n                if (stack.isEmpty()) res += mid * a;\\n                else res += mid * Math.min(stack.peek(), a);\\n            }\\n            stack.push(a);\\n        }\\n        while (stack.size() > 1) {\\n            res += stack.pop() * stack.peek();\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945607,
                "title": "c-with-comments",
                "content": "we need to understand what are trying to solve here.\\n\\nthe goal is to understand if we want to take the left sub tree or the right sub tree.\\nit sounds like dp problem. but dp on what... it was hard for me to understand so I started with recurssion.\\n\\nso we take left or right subtree.. so i create a helper function as always for i to j...\\nand compute ... left and right. now we can see that we need to understand do we want to take the maximal leaf or we don\\'t\\nif we take it we will have a big sub tree, so we are not going to take the maximal value and we take the next one.\\n\\n```\\npublic class Solution {\\n    private int _sum = 0;\\n    public int MctFromLeafValues(int[] arr) {\\n       Helper(arr, 0, arr.Length-1);\\n       return _sum;       \\n    }\\n```\\n    \\n    private int Helper(int[] arr, int s, int e)\\n    {\\n       if(s > e)\\n       {\\n          return 0; \\n       }\\n       if(s==e)\\n       {\\n           return arr[s];\\n       }\\n       int max = s;\\n       for(int i = s + 1; i <= e; i++)\\n       {\\n           if(arr[i] > arr[max])\\n           {\\n               max = i;\\n           }\\n       }\\n        int left = Helper(arr, s, max-1);\\n        int right = Helper(arr,max+1, e);\\n        \\n        _sum += arr[max] * (left+right);\\n        return arr[max];\\n     }\\n    }\\n\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    private int _sum = 0;\\n    public int MctFromLeafValues(int[] arr) {\\n       Helper(arr, 0, arr.Length-1);\\n       return _sum;       \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820160,
                "title": "recursive-top-down-memoized-dp-explained",
                "content": "\\n\\n> Approach\\n \\n1. You might have noted that there are possiblly many ways to merge. \\n2. So we try all of them, and memoize them.\\n3. We go `top down` since it is more intuitive .\\n4. While going top down we try to merge all possible.\\n5. We merge `a[st......i]` and `a[i+1.......en-1]`, for all `st <=  i  <= en-1`  and select the maximum of them.\\n\\n\\n> Algorithm\\n\\n\\n```\\n\\n// memoization table\\nvector<vector<pair<int, int>>> dp;\\n    \\n\\t// function returns a pair \\n    // {cost, max-leaf}\\n    pair<int, int> go(int st, int en, vector<int> &a) {\\n        if(st == en) {\\n            // on a leaf node, so cost = 0, max leaf = this node\\'s value\\n\\t\\t\\treturn {0, a[st]};\\n        }\\n        \\n\\t\\t// memoized solution\\n        if(dp[st][en].first != -1) {\\n\\t\\t\\treturn dp[st][en];\\n        }\\n        \\n        int ans = INT_MAX, maxLeaf;\\n        \\n        for(int i=st; i<en; i++) {\\n\\t\\t\\t// left subtree [st....i] \\n            auto p = go(st, i, a);\\n\\t\\t\\t// right subtrees [i+1....en]\\n\\t\\t\\tauto q = go(i+1, en, a);\\n\\t\\t\\t\\n            // we merge to left and right subtrees \\n\\t\\t\\t// left ans + right ans + (max-leaft left * max-leaf right)\\n            int temp = p.first + q.first + p.second * q.second;\\n            \\n            if(temp < ans) {\\n\\t\\t\\t\\t// update the answer \\n                ans = temp;\\n                maxLeaf = max(p.second, q.second);\\n            } else if(temp == ans) {\\n               // if max-leaf can be reduced \\n\\t\\t\\t   maxLeaf = min(maxLeaf, max(p.second, q.second));\\n            }\\n        }\\n        \\n\\t\\t// return, store ans \\n        return dp[st][en] = {ans, maxLeaf};\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& a) {\\n        int n = a.size();\\n        dp.assign(n, vector<pair<int, int>>(n, {-1,-1}));\\n        return go(0, n-1, a).first;\\n    }\\n\\t\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\n// memoization table\\nvector<vector<pair<int, int>>> dp;\\n    \\n\\t// function returns a pair \\n    // {cost, max-leaf}\\n    pair<int, int> go(int st, int en, vector<int> &a) {\\n        if(st == en) {\\n            // on a leaf node, so cost = 0, max leaf = this node\\'s value\\n\\t\\t\\treturn {0, a[st]};\\n        }\\n        \\n\\t\\t// memoized solution\\n        if(dp[st][en].first != -1) {\\n\\t\\t\\treturn dp[st][en];\\n        }\\n        \\n        int ans = INT_MAX, maxLeaf;\\n        \\n        for(int i=st; i<en; i++) {\\n\\t\\t\\t// left subtree [st....i] \\n            auto p = go(st, i, a);\\n\\t\\t\\t// right subtrees [i+1....en]\\n\\t\\t\\tauto q = go(i+1, en, a);\\n\\t\\t\\t\\n            // we merge to left and right subtrees \\n\\t\\t\\t// left ans + right ans + (max-leaft left * max-leaf right)\\n            int temp = p.first + q.first + p.second * q.second;\\n            \\n            if(temp < ans) {\\n\\t\\t\\t\\t// update the answer \\n                ans = temp;\\n                maxLeaf = max(p.second, q.second);\\n            } else if(temp == ans) {\\n               // if max-leaf can be reduced \\n\\t\\t\\t   maxLeaf = min(maxLeaf, max(p.second, q.second));\\n            }\\n        }\\n        \\n\\t\\t// return, store ans \\n        return dp[st][en] = {ans, maxLeaf};\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& a) {\\n        int n = a.size();\\n        dp.assign(n, vector<pair<int, int>>(n, {-1,-1}));\\n        return go(0, n-1, a).first;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 595269,
                "title": "c-0ms-solution-using-stack",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint mctFromLeafValues(vector<int>& arr) {\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tst.push(INT_MAX);\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<arr.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile(arr[i]>st.top())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint temp=st.top();\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tans+=temp*min(arr[i],st.top());\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tst.push(arr[i]);\\n\\t\\t\\t}\\n\\t\\t\\twhile(st.size()>=3)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint cur=st.top();\\n\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\tans+=cur*st.top();\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint mctFromLeafValues(vector<int>& arr) {\\n\\t\\t\\tstack<int> st;\\n\\t\\t\\tst.push(INT_MAX);\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0;i<arr.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\twhile(arr[i]>st.top())\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint temp=st.top();\\n\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\tans+=temp*min(arr[i],st.top());\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 510117,
                "title": "python3-sol-stack",
                "content": "```\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        stack = [float(\\'inf\\')]\\n        for currNum in arr:\\n            while stack[-1] <= currNum:\\n                drop = stack.pop()\\n                res += min(drop * currNum, drop * stack[-1])\\n            stack.append(currNum)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        return res\\n\\t\\t\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        while len(arr) > 1:\\n            minVal = min(arr)\\n            min_index = arr.index(minVal)\\n            if 0 < min_index < len(arr) - 1:\\n                res += min(minVal * arr[min_index - 1], minVal * arr[min_index + 1])\\n            else:\\n                if min_index == 0:\\n                    res += minVal * arr[min_index + 1]\\n                else:\\n                    res += minVal * arr[min_index - 1]\\n            arr.pop(min_index)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        stack = [float(\\'inf\\')]\\n        for currNum in arr:\\n            while stack[-1] <= currNum:\\n                drop = stack.pop()\\n                res += min(drop * currNum, drop * stack[-1])\\n            stack.append(currNum)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        return res\\n\\t\\t\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        while len(arr) > 1:\\n            minVal = min(arr)\\n            min_index = arr.index(minVal)\\n            if 0 < min_index < len(arr) - 1:\\n                res += min(minVal * arr[min_index - 1], minVal * arr[min_index + 1])\\n            else:\\n                if min_index == 0:\\n                    res += minVal * arr[min_index + 1]\\n                else:\\n                    res += minVal * arr[min_index - 1]\\n            arr.pop(min_index)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 471276,
                "title": "simple-c-2d-dp-solution",
                "content": "```\\n/*\\n    https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/\\n    \\n    The idea is to keep track of min inner sum of nodes that can be formed by each subarray range.\\n    TC: O(N^3)\\n    SC: O(N^2)\\n    \\n*/\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        const int N = arr.size();\\n        // max_leaf(i, j): max value leaf node in [i:j]\\n        vector<vector<int> > max_leaf(N, vector<int>(N, 0));\\n        // inner_node(i, j): min sum of inner node possible in [i:j]\\n        vector<vector<int> > inner_node(N, vector<int>(N, INT_MAX));\\n        \\n        for(int i = 0; i < N; i++)\\n            max_leaf[i][i] = arr[i];\\n        \\n        for(int l = 0; l < N; l++) {\\n            for(int start_idx = 0; start_idx < N - l; start_idx++) {\\n                int end_idx = start_idx + l;\\n                \\n                for(int k = start_idx; k < end_idx; k++) {\\n                    // update the max leaf node\\n                    max_leaf[start_idx][end_idx] = max(max_leaf[start_idx][k], max_leaf[k+1][end_idx]);\\n                    // find the inner sum for the current k\\n                    int left_subtree = inner_node[start_idx][k] == INT_MAX ? 0 : inner_node[start_idx][k];\\n                    int right_subtree = inner_node[k+1][end_idx] == INT_MAX ? 0 : inner_node[k+1][end_idx];\\n                    int curr_inner_sum =  left_subtree +  right_subtree + \\n                                           max_leaf[start_idx][k] * max_leaf[k+1][end_idx];\\n                    inner_node[start_idx][end_idx] = min(inner_node[start_idx][end_idx], \\n                                        curr_inner_sum);\\n                }\\n            }\\n        }\\n        \\n        //for(auto v:inner_node){for(auto a: v)cout<<a<<\" \";cout<<endl;}\\n        return inner_node[0][N-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/\\n    \\n    The idea is to keep track of min inner sum of nodes that can be formed by each subarray range.\\n    TC: O(N^3)\\n    SC: O(N^2)\\n    \\n*/\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        const int N = arr.size();\\n        // max_leaf(i, j): max value leaf node in [i:j]\\n        vector<vector<int> > max_leaf(N, vector<int>(N, 0));\\n        // inner_node(i, j): min sum of inner node possible in [i:j]\\n        vector<vector<int> > inner_node(N, vector<int>(N, INT_MAX));\\n        \\n        for(int i = 0; i < N; i++)\\n            max_leaf[i][i] = arr[i];\\n        \\n        for(int l = 0; l < N; l++) {\\n            for(int start_idx = 0; start_idx < N - l; start_idx++) {\\n                int end_idx = start_idx + l;\\n                \\n                for(int k = start_idx; k < end_idx; k++) {\\n                    // update the max leaf node\\n                    max_leaf[start_idx][end_idx] = max(max_leaf[start_idx][k], max_leaf[k+1][end_idx]);\\n                    // find the inner sum for the current k\\n                    int left_subtree = inner_node[start_idx][k] == INT_MAX ? 0 : inner_node[start_idx][k];\\n                    int right_subtree = inner_node[k+1][end_idx] == INT_MAX ? 0 : inner_node[k+1][end_idx];\\n                    int curr_inner_sum =  left_subtree +  right_subtree + \\n                                           max_leaf[start_idx][k] * max_leaf[k+1][end_idx];\\n                    inner_node[start_idx][end_idx] = min(inner_node[start_idx][end_idx], \\n                                        curr_inner_sum);\\n                }\\n            }\\n        }\\n        \\n        //for(auto v:inner_node){for(auto a: v)cout<<a<<\" \";cout<<endl;}\\n        return inner_node[0][N-1];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 452273,
                "title": "c-easy-to-read",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res=0;\\n        stack<int>stack;\\n        stack.push(INT_MAX);       //push a INT_MAX to ensure having a value int the stack\\'s bottom ;\\n\\t\\t\\n\\t\\t/*for example, we have a vector{1,2,3,4,5};\\n\\t\\tint the code below , we have result=1*2+2*3+3*4+4*5, minmum!\\n\\t\\tyou can try to draw that tree like:\\n\\t\\t                              20\\n\\t\\t                 12                      5 \\n\\t\\t          6              4\\n\\t\\t    2          3\\n\\t\\t1     2\\n\\t\\t*/\\n        for(int i: arr){\\n            while(i>=stack.top()){\\n                int temp=stack.top();\\n                stack.pop();\\n                res+=temp*min(stack.top(),i);\\n            }\\n            stack.push(i);\\n            \\n        }\\n        \\n\\t\\t\\n\\t\\t/* but for the case{5,4,3,2,1}?\\n\\t\\twe have every value pushed into the stack :\\n\\t\\t1\\n\\t\\t2\\n\\t\\t3\\n\\t\\t4\\n\\t\\t5\\n\\t\\t*/\\n\\t\\t/* by the code below,\\n\\t\\twe can directly draw the tree;\\n\\t\\t*/\\n        while(stack.size()!=2){\\n            int temp=stack.top();\\n            stack.pop();\\n            res+=temp*stack.top();\\n        }\\n\\t\\t\\n\\t\\t\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res=0;\\n        stack<int>stack;\\n        stack.push(INT_MAX);       //push a INT_MAX to ensure having a value int the stack\\'s bottom ;\\n\\t\\t\\n\\t\\t/*for example, we have a vector{1,2,3,4,5};\\n\\t\\tint the code below , we have result=1*2+2*3+3*4+4*5, minmum!\\n\\t\\tyou can try to draw that tree like:\\n\\t\\t                              20\\n\\t\\t                 12                      5 \\n\\t\\t          6              4\\n\\t\\t    2          3\\n\\t\\t1     2\\n\\t\\t*/\\n        for(int i: arr){\\n            while(i>=stack.top()){\\n                int temp=stack.top();\\n                stack.pop();\\n                res+=temp*min(stack.top(),i);\\n            }\\n            stack.push(i);\\n            \\n        }\\n        \\n\\t\\t\\n\\t\\t/* but for the case{5,4,3,2,1}?\\n\\t\\twe have every value pushed into the stack :\\n\\t\\t1\\n\\t\\t2\\n\\t\\t3\\n\\t\\t4\\n\\t\\t5\\n\\t\\t*/\\n\\t\\t/* by the code below,\\n\\t\\twe can directly draw the tree;\\n\\t\\t*/\\n        while(stack.size()!=2){\\n            int temp=stack.top();\\n            stack.pop();\\n            res+=temp*stack.top();\\n        }\\n\\t\\t\\n\\t\\t\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418518,
                "title": "java-top-down-dp",
                "content": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length;\\n        int[][] maxx =  new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            maxx[i][i] = arr[i];\\n            for (int j = i + 1; j < n; j++) {\\n                maxx[i][j] = Math.max(arr[j], maxx[i][j - 1]);\\n            }\\n        }\\n        Integer[][] memo = new Integer[n][n];\\n        return helper(0, n - 1, arr, memo, maxx);\\n    }\\n    int helper(int start, int end, int[] arr, Integer[][] memo, int[][] maxx) {\\n        if (start >= end) {\\n            return 0;\\n        }\\n        if (memo[start][end] != null) {\\n            return memo[start][end];\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for (int i = start; i < end; i++) {\\n            res = Math.min(res, maxx[start][i] * maxx[i + 1][end] + helper(start, i, arr, memo, maxx) + helper(i + 1, end, arr, memo, maxx));\\n        } \\n        memo[start][end] = res;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length;\\n        int[][] maxx =  new int[n][n];\\n        for (int i = 0; i < n; i++) {\\n            maxx[i][i] = arr[i];\\n            for (int j = i + 1; j < n; j++) {\\n                maxx[i][j] = Math.max(arr[j], maxx[i][j - 1]);\\n            }\\n        }\\n        Integer[][] memo = new Integer[n][n];\\n        return helper(0, n - 1, arr, memo, maxx);\\n    }\\n    int helper(int start, int end, int[] arr, Integer[][] memo, int[][] maxx) {\\n        if (start >= end) {\\n            return 0;\\n        }\\n        if (memo[start][end] != null) {\\n            return memo[start][end];\\n        }\\n        int res = Integer.MAX_VALUE;\\n        for (int i = start; i < end; i++) {\\n            res = Math.min(res, maxx[start][i] * maxx[i + 1][end] + helper(start, i, arr, memo, maxx) + helper(i + 1, end, arr, memo, maxx));\\n        } \\n        memo[start][end] = res;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384899,
                "title": "greedy-java",
                "content": "peek the smallest product everytime, and delete the smaller number\\n\\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int res = 0;\\n        List<Integer> nums = new ArrayList<>();\\n        for (int a : arr) nums.add(a);\\n        while (nums.size() > 1) { \\n            int min = Integer.MAX_VALUE, l = 0, r = 0;\\n            for (int i = 1; i < nums.size(); i++) {\\n                if (nums.get(i) * nums.get(i - 1) < min) {\\n                    min = nums.get(i) * nums.get(i - 1);\\n                    l = i - 1;\\n                    r = i;\\n                }\\n            }\\n            res += min;\\n            if (nums.get(l) > nums.get(r)) nums.remove(r);\\n            else nums.remove(l);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int res = 0;\\n        List<Integer> nums = new ArrayList<>();\\n        for (int a : arr) nums.add(a);\\n        while (nums.size() > 1) { \\n            int min = Integer.MAX_VALUE, l = 0, r = 0;\\n            for (int i = 1; i < nums.size(); i++) {\\n                if (nums.get(i) * nums.get(i - 1) < min) {\\n                    min = nums.get(i) * nums.get(i - 1);\\n                    l = i - 1;\\n                    r = i;\\n                }\\n            }\\n            res += min;\\n            if (nums.get(l) > nums.get(r)) nums.remove(r);\\n            else nums.remove(l);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799978,
                "title": "c-top-down-dp-solution",
                "content": "\\n# PLS UPVOTE MY SOLUTION IF YOU UNDERSTAND IT\\n# Approach\\nThe main function mctFromLeafValues(arr) takes a vector arr representing the leaf values of a binary search tree as input and returns the minimum cost to construct the binary search tree.\\n\\nThe helper function solve(arr, maxi, dp, left, right) takes several parameters:\\n\\narr: The input vector containing leaf values.\\nmaxi: A map (map<pair<int,int>,int>) that stores the maximum leaf value within each subarray. The key of the map is a pair of indices (left and right) representing the range, and the value is the maximum leaf value within that range.\\ndp: A 2D vector used for memoization. It stores the minimum cost for each range left to right.\\nleft and right: Represent the current range of leaf values to consider.\\nIn the helper function solve, it first checks for the base case:\\n\\nIf left == right, it means the range has only one leaf value, so no cost is needed, and the function returns 0.\\nIf the result for the current range left to right is already calculated and stored in the dp vector (i.e., dp[left][right] != -1), the function directly returns the result from the memoization table to avoid redundant computations.\\n\\nInitialize ans to INT_MAX, which will be used to store the minimum cost for the current range left to right.\\n\\nIterate from i = left to i < right, considering each position i as a candidate root. Calculate the cost for the candidate root and find the maximum cost between the left and right subtrees.\\n\\nCalculate the cost for the candidate root as maxi[{left,i}]*maxi[{i+1,right}] + solve(arr, maxi, dp, left, i) + solve(arr, maxi, dp, i + 1, right):\\n\\nmaxi[{left, i}]: Represents the maximum leaf value within the left subtree (from left to i).\\nmaxi[{i + 1, right}]: Represents the maximum leaf value within the right subtree (from i + 1 to right).\\nsolve(arr, maxi, dp, left, i): Represents the minimum cost of constructing the left subtree.\\nsolve(arr, maxi, dp, i + 1, right): Represents the minimum cost of constructing the right subtree.\\nKeep track of the minimum cost by updating ans with the minimum value between its current value and the cost calculated in step 7.\\n\\nAfter calculating the minimum cost for the current range left to right, store the result ans in the dp vector at index [left][right] for memoization.\\n\\nAfter calculating the minimum cost for all ranges, return the result stored in dp[0][n-1], which represents the minimum cost to construct the binary search tree.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N*N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(N*N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint solve( vector<int>& arr,map<pair<int,int>,int>&maxi,vector<vector<int>>&dp,int left,int right)\\n{\\n    if(left==right)\\n    {\\n        return 0;\\n    }\\n    if(dp[left][right]!=-1)\\n    {\\n        return dp[left][right];\\n    }\\n    int ans= INT_MAX;\\n    for(int i =left;i<right;i++)\\n    {\\n        ans=min(ans,maxi[{left,i}]*maxi[{i+1,right}]+solve(arr,maxi,dp,left,i)+solve(arr,maxi,dp,i+1,right));\\n    }\\n   return dp[left][right]=ans;\\n}\\n\\n    int mctFromLeafValues(vector<int>& arr) \\n    {\\n        int n= arr.size();\\n        map<pair<int,int>, int>maxi;\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        for(int i=0; i<n;i++)\\n        {\\n            maxi[{i,i}]=arr[i];\\n            for(int j =i+1;j<n;j++)\\n            {\\n                maxi[{i,j}]=max(arr[j],maxi[{i,j-1}]);\\n            }\\n        }\\n        return solve(arr,maxi,dp,0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint solve( vector<int>& arr,map<pair<int,int>,int>&maxi,vector<vector<int>>&dp,int left,int right)\\n{\\n    if(left==right)\\n    {\\n        return 0;\\n    }\\n    if(dp[left][right]!=-1)\\n    {\\n        return dp[left][right];\\n    }\\n    int ans= INT_MAX;\\n    for(int i =left;i<right;i++)\\n    {\\n        ans=min(ans,maxi[{left,i}]*maxi[{i+1,right}]+solve(arr,maxi,dp,left,i)+solve(arr,maxi,dp,i+1,right));\\n    }\\n   return dp[left][right]=ans;\\n}\\n\\n    int mctFromLeafValues(vector<int>& arr) \\n    {\\n        int n= arr.size();\\n        map<pair<int,int>, int>maxi;\\n        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));\\n        for(int i=0; i<n;i++)\\n        {\\n            maxi[{i,i}]=arr[i];\\n            for(int j =i+1;j<n;j++)\\n            {\\n                maxi[{i,j}]=max(arr[j],maxi[{i,j-1}]);\\n            }\\n        }\\n        return solve(arr,maxi,dp,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3620860,
                "title": "easy-to-understand-c-solution-memoized-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[42][42];\\n    int solve(int i, int j, vector<int>& arr){\\n        if(i==j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int mn = INT_MAX;\\n        for(int k=i; k<j; k++){\\n            int leftMax = 0;\\n            int rightMax= 0;\\n            for(int id=i; id<=k; id++) leftMax = max(leftMax,arr[id]);\\n            for(int id=k+1; id<=j; id++) rightMax = max(rightMax,arr[id]);\\n            mn = min(mn, leftMax*rightMax + solve(i,k,arr) + solve(k+1,j,arr));\\n        }\\n        return dp[i][j] = mn;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,arr.size()-1,arr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[42][42];\\n    int solve(int i, int j, vector<int>& arr){\\n        if(i==j) return 0;\\n        if(dp[i][j] != -1) return dp[i][j];\\n        int mn = INT_MAX;\\n        for(int k=i; k<j; k++){\\n            int leftMax = 0;\\n            int rightMax= 0;\\n            for(int id=i; id<=k; id++) leftMax = max(leftMax,arr[id]);\\n            for(int id=k+1; id<=j; id++) rightMax = max(rightMax,arr[id]);\\n            mn = min(mn, leftMax*rightMax + solve(i,k,arr) + solve(k+1,j,arr));\\n        }\\n        return dp[i][j] = mn;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        memset(dp,-1,sizeof(dp));\\n        return solve(0,arr.size()-1,arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3615262,
                "title": "c-new-way-explained-mcm-segment-tree",
                "content": "The approach that I am going to explain here is 100% New and Unique (probably not available in Discuss)\\n\\n**APPROACH:**\\n* This problem can be considered as an MCM problem. If we break array in **2 half** say **[start, k]** and **[k+1, end]**\\n* we can see that these 2 half (or these 2 sub-problem are **independent**), so **we can safely apply MCM**.\\n* ```Sum of non-leaf in [start, end] = Sum of non-leaf in [start, k] + Sum of non-leaf in [k+1, end] + ( MaxLeaf in [start, k] * MaxLeaf in [k+1, end] )```\\n* we will calculate this sum for different values of k from [start, end] as we did in MCM pattern and **choose the minimum sum** (as we are asked to minimse it)\\n* Now, **How can we find maxLeaf in [queryStart, queryEnd] optimally ?** That is where typical **max segement tree** comes into picture.\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    \\n    void build(int si, int ss, int se, vector<int>& arr, vector<int>& seg){\\n        if(ss==se){\\n            seg[si]=arr[ss]; return;\\n        }\\n        int mid= ss + (se-ss)/2;\\n        build(2*si+1, ss, mid, arr, seg);\\n        build(2*si+2, mid+1, se, arr, seg);\\n        seg[si]= max(seg[2*si+1], seg[2*si+2]);\\n        return;\\n    }\\n    \\n    int query(int si, int ss, int se, int qs, int qe, vector<int>& arr, vector<int>& seg){ // find max in [qs,qe]\\n        if(ss>qe || se<qs){ return INT_MIN; }  // complete outside\\n        if(ss>=qs && se<=qe){ return seg[si]; } // complete inside\\n        int mid= ss + (se-ss)/2;\\n        int lft= query(2*si+1, ss, mid, qs, qe, arr, seg);\\n        int rht= query(2*si+2, mid+1, se, qs, qe, arr, seg);\\n        return max(lft, rht);\\n    }\\n    \\n    int helper(int start, int end, vector<int>& arr, vector<int>& seg, vector<vector<int>>& dp){\\n        if(start>=end){ return 0; }\\n        if(dp[start][end]!=-1){ return dp[start][end]; }\\n        \\n        int sum=INT_MAX;\\n        for(int k=start; k<end; k++){\\n            int lft= helper(start, k, arr, seg, dp); // sum of non-leaf node of subtree [start, k]\\n            int rht= helper(k+1, end, arr, seg, dp); // sum of non-leaf node of subtree [k+1, end]\\n            int lftMax= query(0, 0, arr.size()-1, start, k, arr, seg); // max leaf node of subtree [start, k]\\n            int rhtMax= query(0, 0, arr.size()-1, k+1, end, arr, seg); // min leaf node of subtree [k+1, end]\\n            sum= min(sum, lft+rht+(lftMax*rhtMax)); // lftSum + rhtSum + (maxLeafLft*maxLeafRht)\\n        }\\n        return dp[start][end]=sum;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n= arr.size(); vector<int> seg(4*n);\\n        build(0, 0, n-1, arr, seg);\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return helper(0, n-1, arr, seg, dp);\\n    }\\n};\\n```\\nTime Complexity: O(N^2 * logN)\\nThanks !",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```Sum of non-leaf in [start, end] = Sum of non-leaf in [start, k] + Sum of non-leaf in [k+1, end] + ( MaxLeaf in [start, k] * MaxLeaf in [k+1, end] )```\n```\\nclass Solution {\\npublic:\\n    \\n    void build(int si, int ss, int se, vector<int>& arr, vector<int>& seg){\\n        if(ss==se){\\n            seg[si]=arr[ss]; return;\\n        }\\n        int mid= ss + (se-ss)/2;\\n        build(2*si+1, ss, mid, arr, seg);\\n        build(2*si+2, mid+1, se, arr, seg);\\n        seg[si]= max(seg[2*si+1], seg[2*si+2]);\\n        return;\\n    }\\n    \\n    int query(int si, int ss, int se, int qs, int qe, vector<int>& arr, vector<int>& seg){ // find max in [qs,qe]\\n        if(ss>qe || se<qs){ return INT_MIN; }  // complete outside\\n        if(ss>=qs && se<=qe){ return seg[si]; } // complete inside\\n        int mid= ss + (se-ss)/2;\\n        int lft= query(2*si+1, ss, mid, qs, qe, arr, seg);\\n        int rht= query(2*si+2, mid+1, se, qs, qe, arr, seg);\\n        return max(lft, rht);\\n    }\\n    \\n    int helper(int start, int end, vector<int>& arr, vector<int>& seg, vector<vector<int>>& dp){\\n        if(start>=end){ return 0; }\\n        if(dp[start][end]!=-1){ return dp[start][end]; }\\n        \\n        int sum=INT_MAX;\\n        for(int k=start; k<end; k++){\\n            int lft= helper(start, k, arr, seg, dp); // sum of non-leaf node of subtree [start, k]\\n            int rht= helper(k+1, end, arr, seg, dp); // sum of non-leaf node of subtree [k+1, end]\\n            int lftMax= query(0, 0, arr.size()-1, start, k, arr, seg); // max leaf node of subtree [start, k]\\n            int rhtMax= query(0, 0, arr.size()-1, k+1, end, arr, seg); // min leaf node of subtree [k+1, end]\\n            sum= min(sum, lft+rht+(lftMax*rhtMax)); // lftSum + rhtSum + (maxLeafLft*maxLeafRht)\\n        }\\n        return dp[start][end]=sum;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n= arr.size(); vector<int> seg(4*n);\\n        build(0, 0, n-1, arr, seg);\\n        vector<vector<int>> dp(n, vector<int>(n, -1));\\n        return helper(0, n-1, arr, seg, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427916,
                "title": "easy-greedy-approach-in-c",
                "content": "# Approach\\n- First it go through minimum to maximum.\\n- Then it will find which leftmost and rightmost is free and take minimum from both.\\n- Finally it will multiply with current value and add to ans. Also marking that current index is done and will not be used again.\\n- For eg- arr = $$[15,13,5,3,15]$$, first it will iterate from 3 then it will select minimum from both leftmost and rightmost and multiply it, in this $$min(5,15)*3$$ will add to ans and mark it as done. Now for 5 it will min(13,15) as 3 is already marked so it will add $$min(13,15)*5$$ and 5 is marked done, then for 13 it will add $$min(15,15)*13$$ as 5 and 3 is mark as done and we will mark 13 as done. Now for 15 there is only one value remaining so adding $$15*15$$ and mark the first pos of 15 done and for last 15 there is no one left. So ans will be = $$3*min(5,15)+5*min(13,15)+13*min(15,15)+15*15$$ = $$500$$.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& a) {\\n        vector<int>adj[16];\\n        int n = a.size();\\n        // Store the positions of every value\\n        for(int i=0; i<n; i++){\\n            adj[a[i]].push_back(i); \\n        }\\n        vector<int>done(n,0);\\n        int ans = 0;\\n        for(int j=1; j<=15; j++){\\n            if(adj[j].size()==0) continue;\\n            vector<int>v=adj[j];\\n            for(int i=0; i<v.size(); i++){\\n                int idx = v[i];\\n                int left = idx-1;\\n                int right = idx+1;\\n                //finding which leftmost and rightmost is free;\\n                while(left>=0 && done[left]) left--; \\n                while(right<n && done[right]) right++; \\n                int mx = 100;\\n                // checking that it exists or not\\n                if(left>=0) mx = min(mx,a[left]); \\n                if(right<n) mx = min(mx,a[right]); \\n                if(mx!=100)ans+=mx*j;\\n                done[v[i]]=1; // marking that this index is done.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& a) {\\n        vector<int>adj[16];\\n        int n = a.size();\\n        // Store the positions of every value\\n        for(int i=0; i<n; i++){\\n            adj[a[i]].push_back(i); \\n        }\\n        vector<int>done(n,0);\\n        int ans = 0;\\n        for(int j=1; j<=15; j++){\\n            if(adj[j].size()==0) continue;\\n            vector<int>v=adj[j];\\n            for(int i=0; i<v.size(); i++){\\n                int idx = v[i];\\n                int left = idx-1;\\n                int right = idx+1;\\n                //finding which leftmost and rightmost is free;\\n                while(left>=0 && done[left]) left--; \\n                while(right<n && done[right]) right++; \\n                int mx = 100;\\n                // checking that it exists or not\\n                if(left>=0) mx = min(mx,a[left]); \\n                if(right<n) mx = min(mx,a[right]); \\n                if(mx!=100)ans+=mx*j;\\n                done[v[i]]=1; // marking that this index is done.\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078405,
                "title": "fast-python-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is to use a greedy approach to solve this problem. We can start by keeping track of the minimum value of the current subarray and multiply it with the next minimum value. We can also use a stack to keep track of the values in the current subarray and pop the values that are greater than the next value.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize a variable \"ans\" to keep track of the minimum cost of the tree.\\n2. Create a stack and initialize it with a value of infinity.\\n3.Iterate through the array \"arr\" and for each value \"a\":\\na. While the last value in the stack is less than or equal to \"a\", pop the value from the stack and add the product of the popped value and the minimum of the last value in the stack and \"a\" to the \"ans\" variable.\\nb. Append \"a\" to the stack.\\n4. While the stack has more than 2 values, pop the last value and add the product of the popped value and the last value in the stack to the \"ans\" variable.\\n5. Return the \"ans\" variable.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        ans = 0\\n        stack = [float(\\'inf\\')]\\n        for a in arr:\\n            while stack[-1] <= a:\\n                mid = stack.pop()\\n                ans += mid * min(stack[-1], a)\\n            stack.append(a)\\n        while len(stack) > 2:\\n            ans += stack.pop() * stack[-1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        ans = 0\\n        stack = [float(\\'inf\\')]\\n        for a in arr:\\n            while stack[-1] <= a:\\n                mid = stack.pop()\\n                ans += mid * min(stack[-1], a)\\n            stack.append(a)\\n        while len(stack) > 2:\\n            ans += stack.pop() * stack[-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2897536,
                "title": "2-solutions-o-n-time-best-time-complexity",
                "content": "# GREEDY APPROACH\\n# Intuition\\nAll u need to do is that:\\nWe need to keep the max node at the top most level\\nSo for that we need to pick min node val and keep it at the depth\\nWe did that.\\nAs it is in inorder sequence. we need to take idx -1 or idx+1 node\\nTake the min one again\\nDelete the min node, do this till only 1 node.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(N*N)\\n- See finding min takes O(N) and we do it for every ith call.\\n- So N *N\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        while(arr.size() > 1){\\n            int N = arr.size();\\n            auto it = min_element(arr.begin(), arr.end());\\n            int idx =  it - arr.begin();\\n            if(idx > 0 && idx < N-1 ){\\n                res+= arr[idx] * min(arr[idx-1], arr[idx+1]);\\n            }\\n            else{\\n                // now we dont have options on both sides\\n                // either its on left or right thats it\\n                if(idx==0)\\n                    res+= arr[idx] * arr[idx+1];\\n                else\\n                    res+= arr[idx] * arr[idx-1];\\n            }\\n\\n            arr.erase(it);\\n\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n# TIME OPTIMIZED using MONOTONIC Stacks\\n \\n# Intuition\\nThe bottle neck is finding min guy. So we can try to make it in O(1)\\nSo that overall O(N) time and extra we may take O(N) Space\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n\\n        stack<int> stk;\\n        stk.push(INT_MAX); // to make sure we push 1st element\\n\\n        for(int a : arr){\\n            //monotonically decreasing stack.\\n            // big .... small at topmost\\n\\n            // big small big - pop the smaller guys\\n            while(stk.top() <= a){\\n                int tmp = stk.top();\\n                stk.pop(); // tmp is the min most guy. idx\\n                res+= tmp * min(stk.top(), a); // this is idx * min( idx-1, idx+1).\\n                //stk top is new one\\n            }\\n            stk.push(a);\\n        }\\n        // as in monotonic stack, once we pop that\\'s it \\n        while(stk.size() > 2){\\n            int tmp = stk.top();\\n            stk.pop(); // popped min most guy as it is mono dec stk\\n            res += tmp * stk.top(); // 2 min most guys mul\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        while(arr.size() > 1){\\n            int N = arr.size();\\n            auto it = min_element(arr.begin(), arr.end());\\n            int idx =  it - arr.begin();\\n            if(idx > 0 && idx < N-1 ){\\n                res+= arr[idx] * min(arr[idx-1], arr[idx+1]);\\n            }\\n            else{\\n                // now we dont have options on both sides\\n                // either its on left or right thats it\\n                if(idx==0)\\n                    res+= arr[idx] * arr[idx+1];\\n                else\\n                    res+= arr[idx] * arr[idx-1];\\n            }\\n\\n            arr.erase(it);\\n\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n\\n        stack<int> stk;\\n        stk.push(INT_MAX); // to make sure we push 1st element\\n\\n        for(int a : arr){\\n            //monotonically decreasing stack.\\n            // big .... small at topmost\\n\\n            // big small big - pop the smaller guys\\n            while(stk.top() <= a){\\n                int tmp = stk.top();\\n                stk.pop(); // tmp is the min most guy. idx\\n                res+= tmp * min(stk.top(), a); // this is idx * min( idx-1, idx+1).\\n                //stk top is new one\\n            }\\n            stk.push(a);\\n        }\\n        // as in monotonic stack, once we pop that\\'s it \\n        while(stk.size() > 2){\\n            int tmp = stk.top();\\n            stk.pop(); // popped min most guy as it is mono dec stk\\n            res += tmp * stk.top(); // 2 min most guys mul\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496135,
                "title": "easy-java-solution-with-memorization",
                "content": "```\\nclass Solution {\\n    \\n    int[][] tempResult;\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length-1;\\n        tempResult= new int[n+1][n+1];\\n        return getMin(arr, 0, n);\\n    }\\n    \\n    public int getMin(int[] arr, int start, int end){\\n        \\n        if(start== end){\\n            return 0;\\n        }\\n        \\n        if( tempResult[start][end] != 0 ){\\n            return tempResult[start][end];\\n        }\\n        \\n        int smallestAns= Integer.MAX_VALUE;\\n        \\n        for(int i= start; i<end; i++){\\n            \\n            //  Getting the max & min from the left & right sub-arrays respectively\\n            int maxLeft= 0, maxRight= 0;\\n            \\n            for(int j=start; j<=i; j++){\\n                maxLeft= Math.max( maxLeft, arr[j] );\\n            }\\n            \\n            for(int j = i+1; j<= end; j++){\\n                maxRight= Math.max(maxRight, arr[j]);\\n            }\\n            smallestAns= Math.min( smallestAns, maxLeft*maxRight + getMin(arr, start, i) + getMin(arr, i+1, end) );\\n            tempResult[start][end]= smallestAns;\\n        }\\n        \\n        return smallestAns;\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int[][] tempResult;\\n    \\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length-1;\\n        tempResult= new int[n+1][n+1];\\n        return getMin(arr, 0, n);\\n    }\\n    \\n    public int getMin(int[] arr, int start, int end){\\n        \\n        if(start== end){\\n            return 0;\\n        }\\n        \\n        if( tempResult[start][end] != 0 ){\\n            return tempResult[start][end];\\n        }\\n        \\n        int smallestAns= Integer.MAX_VALUE;\\n        \\n        for(int i= start; i<end; i++){\\n            \\n            //  Getting the max & min from the left & right sub-arrays respectively\\n            int maxLeft= 0, maxRight= 0;\\n            \\n            for(int j=start; j<=i; j++){\\n                maxLeft= Math.max( maxLeft, arr[j] );\\n            }\\n            \\n            for(int j = i+1; j<= end; j++){\\n                maxRight= Math.max(maxRight, arr[j]);\\n            }\\n            smallestAns= Math.min( smallestAns, maxLeft*maxRight + getMin(arr, start, i) + getMin(arr, i+1, end) );\\n            tempResult[start][end]= smallestAns;\\n        }\\n        \\n        return smallestAns;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441040,
                "title": "c-mcm-variation-tabulation-dp",
                "content": "TC:O(N  * N * N * N) ---> ~=O(N^4)\\nSC:O(N^2)\\n```\\nclass Solution {\\npublic:\\n    int maxi(int i, int j,vector<int>&arr){\\n        int maxx=0;\\n        for(int k=i;k<=j;k++)\\n            maxx=max(maxx,arr[k]);\\n        return maxx;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        int total_sum=0;\\n        for(int i=0;i<n;i++)\\n            total_sum+=arr[i];\\n        vector<vector<int>>dp(n,vector<int>(n,1e9));\\n        for(int i=0;i<n;i++)\\n            dp[i][i]=arr[i]; \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=i+1;j<n;j++){\\n               int mini_sum=INT_MAX;\\n                for(int k=i;k<j;k++){\\n                    int left  =  dp[i][k];\\n                    int right =  dp[k+1][j];\\n                    int curr_sum= maxi(i,k,arr)*maxi(k+1,j,arr) + left+right;\\n                    mini_sum=min(mini_sum,curr_sum);\\n                }\\n                dp[i][j]=mini_sum;  \\n            }\\n        }\\n        return dp[0][n-1]-total_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxi(int i, int j,vector<int>&arr){\\n        int maxx=0;\\n        for(int k=i;k<=j;k++)\\n            maxx=max(maxx,arr[k]);\\n        return maxx;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        int total_sum=0;\\n        for(int i=0;i<n;i++)\\n            total_sum+=arr[i];\\n        vector<vector<int>>dp(n,vector<int>(n,1e9));\\n        for(int i=0;i<n;i++)\\n            dp[i][i]=arr[i]; \\n        for(int i=n-1;i>=0;i--){\\n            for(int j=i+1;j<n;j++){\\n               int mini_sum=INT_MAX;\\n                for(int k=i;k<j;k++){\\n                    int left  =  dp[i][k];\\n                    int right =  dp[k+1][j];\\n                    int curr_sum= maxi(i,k,arr)*maxi(k+1,j,arr) + left+right;\\n                    mini_sum=min(mini_sum,curr_sum);\\n                }\\n                dp[i][j]=mini_sum;  \\n            }\\n        }\\n        return dp[0][n-1]-total_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2416400,
                "title": "c-dp-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    //memoization\\n    int dp[41][41];\\n    //finding  maximum value from index i to index j in an array\\n    int maxi(vector<int> &arr,int i,int j)\\n    {\\n        int m=INT_MIN;\\n        for(int k=i;k<=j;k++) m=max(m,arr[k]);\\n        return m;\\n    }\\n    \\n    int func(vector<int> &arr,int i,int j)\\n    {\\n        //if already computed return the value in dp array\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        //base case\\n        if(i==j) return 0;\\n        if(i+1==j) return arr[i]*arr[j];\\n        \\n        //dividing the array into two sub arrays at every index \\n        //then finding solution by treating them as left and right subtrees and take minimum value among them\\n        \\n        int m=INT_MAX;\\n        for(int k=i;k<j;k++)\\n        {\\n            m=min(m,maxi(arr,i,k)*maxi(arr,k+1,j)+func(arr,i,k)+func(arr,k+1,j));\\n        }\\n        \\n        dp[i][j]=m;\\n        return m;\\n        \\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        //initialising memoization array\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=0;j<arr.size();j++)\\n            {\\n                dp[i][j]=-1;\\n                if(i+1==j) dp[i][j]=arr[i]*arr[j];\\n                if(i==j) dp[i][j]=0;\\n            }\\n        }\\n        \\n        return func(arr,0,arr.size()-1);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //memoization\\n    int dp[41][41];\\n    //finding  maximum value from index i to index j in an array\\n    int maxi(vector<int> &arr,int i,int j)\\n    {\\n        int m=INT_MIN;\\n        for(int k=i;k<=j;k++) m=max(m,arr[k]);\\n        return m;\\n    }\\n    \\n    int func(vector<int> &arr,int i,int j)\\n    {\\n        //if already computed return the value in dp array\\n        \\n        if(dp[i][j]!=-1) return dp[i][j];\\n        \\n        //base case\\n        if(i==j) return 0;\\n        if(i+1==j) return arr[i]*arr[j];\\n        \\n        //dividing the array into two sub arrays at every index \\n        //then finding solution by treating them as left and right subtrees and take minimum value among them\\n        \\n        int m=INT_MAX;\\n        for(int k=i;k<j;k++)\\n        {\\n            m=min(m,maxi(arr,i,k)*maxi(arr,k+1,j)+func(arr,i,k)+func(arr,k+1,j));\\n        }\\n        \\n        dp[i][j]=m;\\n        return m;\\n        \\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        //initialising memoization array\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            for(int j=0;j<arr.size();j++)\\n            {\\n                dp[i][j]=-1;\\n                if(i+1==j) dp[i][j]=arr[i]*arr[j];\\n                if(i==j) dp[i][j]=0;\\n            }\\n        }\\n        \\n        return func(arr,0,arr.size()-1);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386853,
                "title": "c-dp-memoization-recursion-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[40][40]={0};\\n    int solve(vector<int> arr,int start,int end)\\n    {\\n        if(start==end)\\n            return 0;\\n        if(dp[start][end]!=0)\\n            return dp[start][end];\\n        int mn=INT_MAX;\\n        for(int i=start;i<=end-1;i++)\\n        {\\n            int left=solve(arr,start,i);\\n            int right=solve(arr,i+1,end);\\n            int temp=left+right+*max_element(arr.begin()+start,arr.begin()+i+1) * *max_element(arr.begin()+i+1,arr.begin()+end+1);\\n            mn=min(mn,temp);\\n            \\n        }\\n        return dp[start][end]=mn;\\n    }\\n    int mctFromLeafValues(vector<int>& arr)\\n    {\\n        return solve(arr,0,arr.size()-1);\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    int dp[40][40]={0}",
                "codeTag": "Java"
            },
            {
                "id": 2331503,
                "title": "c-memoization-commented-solution-dp-clean-code",
                "content": "```\\n // Intuition -> there are various combinations of trees possible \\n    \\n    // We have to take every possible  combination of trees \\n    \\n    // Now creating binary tree is very hectic\\n    \\n    // What we will do is , we will recursively do the calculations \\n    \\n    // start from  l=0 , e=n-1\\n    \\n    // for each i=l;i<e;i++ -> l , i to i+1 ,e \\n    \\n    // store the max_ele of the that leaf part & also sum till that node \\n    \\n    // I will comment on each part of code\\n    \\n    // We need 2 things max_leaf_value , sum_till_node\\n    \\n    vector<vector<pp>> dp;\\n    \\n      pp func(vector<int> &arr , int l , int r)\\n      {\\n          if(l==r)\\n          {\\n              // that means it is a leaf node \\n              \\n              // return max_leaf_value , max_product_sum_till_this_node\\n              \\n              return {arr[l] , 0};\\n          }\\n          \\n          pp temp={-1 , -1};\\n          \\n          if(dp[l][r]!=temp)\\n          {\\n              return dp[l][r];\\n          }\\n          \\n          int max_leaf=INT_MIN;\\n          int min_product_sum=INT_MAX;\\n          \\n          for(int i=l;i<r;i++)\\n          {\\n              auto left_subtree=func(arr , l , i);\\n              auto right_subtree=func(arr , i+1 , r);\\n              \\n              int max_leaf_subtree=max(left_subtree.first , right_subtree.first);\\n              \\n              max_leaf=max(max_leaf , max_leaf_subtree);\\n                  \\n               min_product_sum=min(min_product_sum , left_subtree.second +\\n                right_subtree.second + left_subtree.first*right_subtree.first);\\n          }\\n          \\n          return dp[l][r]= {max_leaf , min_product_sum};\\n      }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        \\n        int l=0 , r=n-1;\\n        \\n        pp temp={-1 , -1};\\n        \\n       dp.resize(45 , vector<pp>(45 , {-1 , -1}));\\n          \\n       pp ans = func(arr , l , r);\\n        \\n        return ans.second;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n // Intuition -> there are various combinations of trees possible \\n    \\n    // We have to take every possible  combination of trees \\n    \\n    // Now creating binary tree is very hectic\\n    \\n    // What we will do is , we will recursively do the calculations \\n    \\n    // start from  l=0 , e=n-1\\n    \\n    // for each i=l;i<e;i++ -> l , i to i+1 ,e \\n    \\n    // store the max_ele of the that leaf part & also sum till that node \\n    \\n    // I will comment on each part of code\\n    \\n    // We need 2 things max_leaf_value , sum_till_node\\n    \\n    vector<vector<pp>> dp;\\n    \\n      pp func(vector<int> &arr , int l , int r)\\n      {\\n          if(l==r)\\n          {\\n              // that means it is a leaf node \\n              \\n              // return max_leaf_value , max_product_sum_till_this_node\\n              \\n              return {arr[l] , 0};\\n          }\\n          \\n          pp temp={-1 , -1};\\n          \\n          if(dp[l][r]!=temp)\\n          {\\n              return dp[l][r];\\n          }\\n          \\n          int max_leaf=INT_MIN;\\n          int min_product_sum=INT_MAX;\\n          \\n          for(int i=l;i<r;i++)\\n          {\\n              auto left_subtree=func(arr , l , i);\\n              auto right_subtree=func(arr , i+1 , r);\\n              \\n              int max_leaf_subtree=max(left_subtree.first , right_subtree.first);\\n              \\n              max_leaf=max(max_leaf , max_leaf_subtree);\\n                  \\n               min_product_sum=min(min_product_sum , left_subtree.second +\\n                right_subtree.second + left_subtree.first*right_subtree.first);\\n          }\\n          \\n          return dp[l][r]= {max_leaf , min_product_sum};\\n      }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        \\n        int l=0 , r=n-1;\\n        \\n        pp temp={-1 , -1};\\n        \\n       dp.resize(45 , vector<pp>(45 , {-1 , -1}));\\n          \\n       pp ans = func(arr , l , r);\\n        \\n        return ans.second;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2249287,
                "title": "c-o-n-time-and-o-n-space",
                "content": "```\\nint mctFromLeafValues(vector<int>& arr) {\\n        stack<int> stack;\\n        int n = arr.size();\\n        int res = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int num = arr[i];\\n            while(!stack.empty() and stack.top()<=num)\\n            {\\n                int curr = stack.top();\\n                stack.pop();\\n                if(!stack.empty())\\n                    res = res + curr*min(stack.top(), num);\\n                else\\n                    res = res + curr*num;\\n            }\\n            stack.push(num);\\n        }\\n        while(stack.size()>=2)\\n        {\\n            int val = stack.top();\\n            stack.pop();\\n            res = res + stack.top()*val;\\n        }\\n        return res;\\n            \\n    }\\n```\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nint mctFromLeafValues(vector<int>& arr) {\\n        stack<int> stack;\\n        int n = arr.size();\\n        int res = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int num = arr[i];\\n            while(!stack.empty() and stack.top()<=num)\\n            {\\n                int curr = stack.top();\\n                stack.pop();\\n                if(!stack.empty())\\n                    res = res + curr*min(stack.top(), num);\\n                else\\n                    res = res + curr*num;\\n            }\\n            stack.push(num);\\n        }\\n        while(stack.size()>=2)\\n        {\\n            int val = stack.top();\\n            stack.pop();\\n            res = res + stack.top()*val;\\n        }\\n        return res;\\n            \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2248610,
                "title": "c-simplest-solutions-w-explanation",
                "content": "We need to return the minimum sum of the non-leaf nodes which are formed by the product of maximum leaf nodes of the leaft and right subtrees.\\n\\n* This is a Merging Intervals Problem. How?\\n\\n* The given array is the inorder traversal of the leaf nodes. But we do not know which all leaves can be placed in the left subtree and which all can be placed in the right subtree and which arrangement like this gives the minimum most sum.\\n\\n* So we try out every possibility. \\n\\n* Take for eg: ```[2, 6, 4, 1, 3]```. We try out every possible tree. \\n\\n* That is, we can place ```[2]``` in the left subtree and ```[6, 4, 1, 3]``` in the right subtree or ```[2, 6]``` in the left subtree and ```[4, 1, 3]``` in the right subtree.\\n\\n* So we use a value ```k``` a place it at every index from ```[0, n-1]``` (```n = arr.size()```) such that it divides the array into leafs belonging to left and right subtrees.\\n\\n* The subtrees can be solved recursively with the same formula,.\\n\\n**ALGORITHM:**\\n\\n* We need to return the minimum possible sum of the non-leaf nodes using leaves fro  ```[0, n-1]``` ~ ```[i, j]```. We traverse from leaf to root while solving using recursion.\\n\\n* We return a pair in each recursive call. The pair is ```{maxLeafNodeValue, minSum}```.\\n\\n* So when there\\'s only ```1``` node in the tree, that must be the leaf node. So we return ```{leafNodeValue, 0}``` as we do not need the sum of leaf node values.\\n\\n* We run a loop from ```i``` to ```j```. Array values from ```[i, k]``` belong to left subtree and ```[k+1, j]``` belong to right subtree.\\n\\n* Finally we take the maxLeafs product and add the minimumSum until there to get the minimum sum upto the current node.\\n\\n**RECURSION:**\\n\\n**Code:**\\n```\\nclass Solution {\\n    int n;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        n = arr.size();\\n        return solve(arr, 0, n-1).second;\\n    }\\n    \\n    pair<int, int> solve(vector<int> &arr, int i, int j) {\\n        if(i == j) return {arr[i], 0};\\n        \\n        int maxLeaf = INT_MIN, minSum = INT_MAX;\\n        \\n        for(int k=i; k<j; k++) {\\n            pair<int, int> left = solve(arr, i, k);\\n            pair<int, int> right = solve(arr, k+1, j);\\n            maxLeaf = max({maxLeaf, left.first, right.first});\\n            minSum = min(minSum, left.first * right.first + left.second + right.second);\\n        }\\n        return {maxLeaf, minSum};\\n    }\\n};\\n```\\n\\n**(OR)**\\n\\n```\\nclass Solution {\\n    int n;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        n = arr.size();\\n        return solve(arr, 0, n-1);\\n    }\\n    \\n    int solve(vector<int> &arr, int i, int j) {\\n        if(i == j) return 0;\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k=i; k<j; k++) {\\n            int left = solve(arr, i, k);\\n            int right = solve(arr, k+1, j);\\n            ans = min(ans,  (*max_element(arr.begin()+i, arr.begin()+k+1)) * (*max_element(arr.begin()+k+1, arr.begin()+j+1)) + left + right);  //instead of returning a pair, we can directly get the max leaf node value from the array itself.\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**DP (MEMORIZATION):**\\n\\n* We can memorize the solution  of subtrees to avoid repeated computations. So, ```dp[i][j]``` stores the minimum sum of the non-leaf nodes considering nodes from ```i``` to ```j``` in the array ```arr``` as leaves.\\n\\n**Code:**\\n```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> dp;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        n = arr.size();\\n        dp.resize(n+1, vector<int>(n+1, -1));\\n        return solve(arr, 0, n-1);\\n    }\\n    \\n    int solve(vector<int> &arr, int i, int j) {\\n        if(i == j) return 0;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k=i; k<j; k++) {\\n            int left = solve(arr, i, k);\\n            int right = solve(arr, k+1, j);\\n            ans = min(ans, (*max_element(arr.begin()+i, arr.begin()+k+1)) * (*max_element(arr.begin()+k+1, arr.begin()+j+1)) + left + right);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```[2, 6, 4, 1, 3]```\n```[2]```\n```[6, 4, 1, 3]```\n```[2, 6]```\n```[4, 1, 3]```\n```k```\n```[0, n-1]```\n```n = arr.size()```\n```[0, n-1]```\n```[i, j]```\n```{maxLeafNodeValue, minSum}```\n```1```\n```{leafNodeValue, 0}```\n```i```\n```j```\n```[i, k]```\n```[k+1, j]```\n```\\nclass Solution {\\n    int n;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        n = arr.size();\\n        return solve(arr, 0, n-1).second;\\n    }\\n    \\n    pair<int, int> solve(vector<int> &arr, int i, int j) {\\n        if(i == j) return {arr[i], 0};\\n        \\n        int maxLeaf = INT_MIN, minSum = INT_MAX;\\n        \\n        for(int k=i; k<j; k++) {\\n            pair<int, int> left = solve(arr, i, k);\\n            pair<int, int> right = solve(arr, k+1, j);\\n            maxLeaf = max({maxLeaf, left.first, right.first});\\n            minSum = min(minSum, left.first * right.first + left.second + right.second);\\n        }\\n        return {maxLeaf, minSum};\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int n;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        n = arr.size();\\n        return solve(arr, 0, n-1);\\n    }\\n    \\n    int solve(vector<int> &arr, int i, int j) {\\n        if(i == j) return 0;\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k=i; k<j; k++) {\\n            int left = solve(arr, i, k);\\n            int right = solve(arr, k+1, j);\\n            ans = min(ans,  (*max_element(arr.begin()+i, arr.begin()+k+1)) * (*max_element(arr.begin()+k+1, arr.begin()+j+1)) + left + right);  //instead of returning a pair, we can directly get the max leaf node value from the array itself.\\n        }\\n        return ans;\\n    }\\n};\\n```\n```dp[i][j]```\n```i```\n```j```\n```arr```\n```\\nclass Solution {\\n    int n;\\n    vector<vector<int>> dp;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        n = arr.size();\\n        dp.resize(n+1, vector<int>(n+1, -1));\\n        return solve(arr, 0, n-1);\\n    }\\n    \\n    int solve(vector<int> &arr, int i, int j) {\\n        if(i == j) return 0;\\n        \\n        if(dp[i][j] != -1) return dp[i][j];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k=i; k<j; k++) {\\n            int left = solve(arr, i, k);\\n            int right = solve(arr, k+1, j);\\n            ans = min(ans, (*max_element(arr.begin()+i, arr.begin()+k+1)) * (*max_element(arr.begin()+k+1, arr.begin()+j+1)) + left + right);\\n        }\\n        return dp[i][j] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214041,
                "title": "python-explained-with-pictures-dp-tabulation-intuitive",
                "content": "# EXPLANATION\\n![image](https://assets.leetcode.com/users/images/537bdd3a-16c1-4bee-8a42-b79e5945709c_1656511289.7734911.png)\\n\\nThe idea is very simple:\\n\\nGiven an array : We can break the array into two subarrays :\\nexample arr is (2,3,4,5) \\nwhich can be broken as:\\n1. (2) (3,4,5)\\n2. (2,3) (4,5)\\n3. (2,3,4) (5)\\n\\nNow we recursively find the answer for the subarray until we reach the base case\\n\\nwhen arr.size = 1: we return 0\\n\\n\\n\\n# CODE\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        d = {}\\n        def findMax(start,end):\\n            if (start,end) in d: return d[(start,end)]\\n            maxx = start\\n            for i in range(start+1,end+1):\\n                if arr[maxx] < arr[i] : maxx = i\\n            d[(start,end)] = arr[maxx]\\n            return arr[maxx]\\n        \\n        dp = [[float(\\'inf\\') for i in range(n)] for j in range(n)]\\n        for gap in range(n):\\n            for row in range(n - gap):\\n                col = row + gap\\n                if gap == 0:\\n                    dp[row][col] = 0\\n                elif gap == 1:\\n                    dp[row][col] = arr[row] * arr[col]\\n                else:\\n                    for k in range(row,col):\\n                        val = dp[row][k] + findMax(row,k) * findMax(k+1,col) + dp[k+1][col]\\n                        if val < dp[row][col]: dp[row][col] = val\\n                \\n\\n        return dp[0][-1]\\n                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        d = {}\\n        def findMax(start,end):\\n            if (start,end) in d: return d[(start,end)]\\n            maxx = start\\n            for i in range(start+1,end+1):\\n                if arr[maxx] < arr[i] : maxx = i\\n            d[(start,end)] = arr[maxx]\\n            return arr[maxx]\\n        \\n        dp = [[float(\\'inf\\') for i in range(n)] for j in range(n)]\\n        for gap in range(n):\\n            for row in range(n - gap):\\n                col = row + gap\\n                if gap == 0:\\n                    dp[row][col] = 0\\n                elif gap == 1:\\n                    dp[row][col] = arr[row] * arr[col]\\n                else:\\n                    for k in range(row,col):\\n                        val = dp[row][k] + findMax(row,k) * findMax(k+1,col) + dp[k+1][col]\\n                        if val < dp[row][col]: dp[row][col] = val\\n                \\n\\n        return dp[0][-1]\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863540,
                "title": "c-dp-recursion-all-possible-bt-easy-to-understand",
                "content": "**Solution:**\\n```\\npublic class Solution {\\n    Dictionary<KeyValuePair<int, int>, KeyValuePair<int, int>> dict = new Dictionary<KeyValuePair<int, int>, KeyValuePair<int, int>>();\\n    private KeyValuePair<int, int> DFS(int start, int end, int[] arr) {\\n        if(start == end) return new KeyValuePair<int, int>(arr[start], 0);\\n        if(dict.ContainsKey(new KeyValuePair<int, int>(start, end))) return dict[new KeyValuePair<int, int>(start, end)];\\n        int currSum = Int32.MaxValue;\\n        int currMax = 50;\\n        for(int i = start; i < end; ++i) {\\n            KeyValuePair<int, int> l = DFS(start, i, arr);\\n            KeyValuePair<int, int> r = DFS(i + 1, end, arr);\\n            currSum = Math.Min(currSum, l.Value + r.Value + l.Key * r.Key);\\n            currMax = Math.Max(l.Key, r.Key);\\n        }\\n        KeyValuePair<int, int> currRes = new KeyValuePair<int, int>(currMax, currSum);\\n        dict.Add(new KeyValuePair<int, int>(start, end), currRes);\\n        return currRes;\\n    }\\n    public int MctFromLeafValues(int[] arr) {\\n        return DFS(0, arr.Length - 1, arr).Value;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    Dictionary<KeyValuePair<int, int>, KeyValuePair<int, int>> dict = new Dictionary<KeyValuePair<int, int>, KeyValuePair<int, int>>();\\n    private KeyValuePair<int, int> DFS(int start, int end, int[] arr) {\\n        if(start == end) return new KeyValuePair<int, int>(arr[start], 0);\\n        if(dict.ContainsKey(new KeyValuePair<int, int>(start, end))) return dict[new KeyValuePair<int, int>(start, end)];\\n        int currSum = Int32.MaxValue;\\n        int currMax = 50;\\n        for(int i = start; i < end; ++i) {\\n            KeyValuePair<int, int> l = DFS(start, i, arr);\\n            KeyValuePair<int, int> r = DFS(i + 1, end, arr);\\n            currSum = Math.Min(currSum, l.Value + r.Value + l.Key * r.Key);\\n            currMax = Math.Max(l.Key, r.Key);\\n        }\\n        KeyValuePair<int, int> currRes = new KeyValuePair<int, int>(currMax, currSum);\\n        dict.Add(new KeyValuePair<int, int>(start, end), currRes);\\n        return currRes;\\n    }\\n    public int MctFromLeafValues(int[] arr) {\\n        return DFS(0, arr.Length - 1, arr).Value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739194,
                "title": "simple-python-dp-3-solutions-time-o-n-3-o-nlogn-o-n",
                "content": "```\\ndef mctFromLeafValues(self, nums: List[int]) -> int:\\n        n= len(nums)\\n        \\n        mem = {}\\n        def dp(i,j):\\n            \\n            if i==j: return 0, nums[i]# leafs result into 0\\n            \\n            if i>j: return 0, float(\"-inf\") #dont consider this\\n            \\n            if (i,j) in mem: return mem[(i,j)]\\n            ans = float(\"inf\")\\n            max_val = 0\\n            \\n            #does consider i,j to be leafs\\n            for k in range(i,j):\\n                \\n                left,max_l = dp(i,k)\\n                right,max_r  = dp(k+1,j)\\n                \\n                prod = max_l* max_r\\n                max_val = max(max_val, max_l, max_r)\\n                \\n                temp_ans = left+right+prod\\n                \\n                ans = min(ans, temp_ans)\\n        \\n            mem[(i,j)] = ans, max_val\\n            return mem[(i,j)]\\n        \\n        return dp(0,n-1)[0]\\n```\\n\\n```\\ndef mctFromLeafValues(self, nums: List[int]) -> int:\\n        n= len(nums)\\n\\t\\t\\n\\t\\tq= []\\n        heapq.heapify(q)\\n        result = 0\\n        \\n        for num in nums:\\n            \\n            while q and q[0]<=num:\\n                prev_small_num = heapq.heappop(q)\\n                if q:\\n                    result += prev_small_num *(min(num, q[0]))\\n                \\n                else:\\n                    result += prev_small_num * num\\n                    \\n            heapq.heappush(q, num)\\n                    \\n        while len(q)>1:\\n            prev_small_num = heapq.heappop(q)\\n            result += q[0] *prev_small_num\\n            \\n        return result\\n```\\n```\\ndef mctFromLeafValues(self, nums: List[int]) -> int:\\n        n= len(nums)\\n\\t\\tstack =[] #we need access to larger number so decrease q\\n        \\n        n = len(nums)\\n        \\n        ans = 0\\n        for j in range(n):\\n            num = nums[j]\\n            \\n            #update the stack such that we need to pop as as many small numbers as possible\\n            while stack and stack[-1]<num:\\n                small_num = stack.pop()\\n                \\n                ans += small_num* (min(stack[-1] if stack else float(\"inf\"),num)) #we dont know, wehter we should assign it to the left side or right side\\n                #we are forming non leaf nodes here and at the same time, we are forgetting small nodes\\n                \\n            stack.append(num)\\n                \\n       \\n        #left overs\\n        while stack and len(stack)>=2:\\n            prev_num = stack.pop()\\n            ans+= stack[-1]*prev_num\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\ndef mctFromLeafValues(self, nums: List[int]) -> int:\\n        n= len(nums)\\n        \\n        mem = {}\\n        def dp(i,j):\\n            \\n            if i==j: return 0, nums[i]# leafs result into 0\\n            \\n            if i>j: return 0, float(\"-inf\") #dont consider this\\n            \\n            if (i,j) in mem: return mem[(i,j)]\\n            ans = float(\"inf\")\\n            max_val = 0\\n            \\n            #does consider i,j to be leafs\\n            for k in range(i,j):\\n                \\n                left,max_l = dp(i,k)\\n                right,max_r  = dp(k+1,j)\\n                \\n                prod = max_l* max_r\\n                max_val = max(max_val, max_l, max_r)\\n                \\n                temp_ans = left+right+prod\\n                \\n                ans = min(ans, temp_ans)\\n        \\n            mem[(i,j)] = ans, max_val\\n            return mem[(i,j)]\\n        \\n        return dp(0,n-1)[0]\\n```\n```\\ndef mctFromLeafValues(self, nums: List[int]) -> int:\\n        n= len(nums)\\n\\t\\t\\n\\t\\tq= []\\n        heapq.heapify(q)\\n        result = 0\\n        \\n        for num in nums:\\n            \\n            while q and q[0]<=num:\\n                prev_small_num = heapq.heappop(q)\\n                if q:\\n                    result += prev_small_num *(min(num, q[0]))\\n                \\n                else:\\n                    result += prev_small_num * num\\n                    \\n            heapq.heappush(q, num)\\n                    \\n        while len(q)>1:\\n            prev_small_num = heapq.heappop(q)\\n            result += q[0] *prev_small_num\\n            \\n        return result\\n```\n```\\ndef mctFromLeafValues(self, nums: List[int]) -> int:\\n        n= len(nums)\\n\\t\\tstack =[] #we need access to larger number so decrease q\\n        \\n        n = len(nums)\\n        \\n        ans = 0\\n        for j in range(n):\\n            num = nums[j]\\n            \\n            #update the stack such that we need to pop as as many small numbers as possible\\n            while stack and stack[-1]<num:\\n                small_num = stack.pop()\\n                \\n                ans += small_num* (min(stack[-1] if stack else float(\"inf\"),num)) #we dont know, wehter we should assign it to the left side or right side\\n                #we are forming non leaf nodes here and at the same time, we are forgetting small nodes\\n                \\n            stack.append(num)\\n                \\n       \\n        #left overs\\n        while stack and len(stack)>=2:\\n            prev_num = stack.pop()\\n            ans+= stack[-1]*prev_num\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1716174,
                "title": "98-faster-with-hints-java",
                "content": "Monotonic stacks are a good option when a problem involves comparing the size of numeric elements, with their order being relevant.\\n```\\n\\t\\t/*\\n        T: O(n)\\n        S: O(n)\\n        */\\n        if(arr == null && arr.length <2)    return 0;\\n        int ans = 0;\\n        Stack<Integer> s = new Stack<>();\\n        \\n        s.push(arr[0]);\\n        \\n        for(int i=1; i< arr.length; i++){\\n            while(s.size()!= 0 && s.peek() <= arr[i]){\\n                int sv = s.pop();\\n                int prev = (s.size()==0) ? Integer.MAX_VALUE : s.peek();\\n                \\n                ans+= sv*Math.min(arr[i], prev);\\n            }\\n            s.push(arr[i]);\\n        }\\n        \\n        while(s.size()>1){\\n            ans+= s.pop()*s.peek();\\n        }\\n        return ans;",
                "solutionTags": [
                    "Java",
                    "Monotonic Stack"
                ],
                "code": "Monotonic stacks are a good option when a problem involves comparing the size of numeric elements, with their order being relevant.\\n```\\n\\t\\t/*\\n        T: O(n)\\n        S: O(n)\\n        */\\n        if(arr == null && arr.length <2)    return 0;\\n        int ans = 0;\\n        Stack<Integer> s = new Stack<>();\\n        \\n        s.push(arr[0]);\\n        \\n        for(int i=1; i< arr.length; i++){\\n            while(s.size()!= 0 && s.peek() <= arr[i]){\\n                int sv = s.pop();\\n                int prev = (s.size()==0) ? Integer.MAX_VALUE : s.peek();\\n                \\n                ans+= sv*Math.min(arr[i], prev);\\n            }\\n            s.push(arr[i]);\\n        }\\n        \\n        while(s.size()>1){\\n            ans+= s.pop()*s.peek();\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1583668,
                "title": "java-dfs-with-memo-explained",
                "content": "We\\'re given an array of the leaf-nodes obtained from in-order traversal of a complete binary tree. The problem is:\\n\\n1) partition this array in such a way, that elements to the left of the partition make up nodes in the left subtree of the whole tree.\\n2) elements to the right of the partition make up nodes in the right subtree of the whole tree.\\n\\nThere are *many such possible* partitionings. We want the partitioning such that, the perfect tree yielded by that partitioning, has the minimum possible sum of non-leaf nodes.\\n\\nWe can try all possible partitionings of the tree; note that, a non-leaf node is the product of the LARGEST leaf node in its left and right subtree; that\\'s where this line comes from:\\n\\n**maximumInRange(arr,start,partition)\\\\*maximumInRange(arr,partition+1,end)**\\n\\nWe want to add that value, to the BEST value (smallest sum) we gain, from further partitioning the left and right subtrees, at the selected partition. That\\'s where this line comes in:\\n\\n**dfs(arr,start,partition)+dfs(arr,partition+1,end)**\\n\\nAfter each calculation, we update our current \\'best\\' (minimum) result.\\n\\nAfter considering all such partitionings, we have found the best result. Use a memo array to cache intermediate results.\\n\\n```\\nclass Solution {\\n    int[][] memo;\\n    public int mctFromLeafValues(int[] arr) {\\n        memo= new int[arr.length+1][arr.length+1];\\n        return dfs(arr,0,arr.length-1);\\n    }\\n    \\n    private int dfs(int[] arr, int start, int end){\\n        if(end-start==0) return 0;\\n        if(end-start==1) return arr[start]*arr[end];\\n        if(memo[start][end]!=0) return memo[start][end];\\n        \\n        int res=Integer.MAX_VALUE;\\n        for (int partition=start; partition<end; partition++){\\n            res= Math.min(res, \\n                          dfs(arr,start,partition)+dfs(arr,partition+1,end)\\n                          + (maximumInRange(arr,start,partition)*maximumInRange(arr,partition+1,end)));\\n        }\\n        memo[start][end]=res;\\n        return res;\\n    }\\n    \\n    private int maximumInRange(int[] arr, int start, int end){\\n        int res=0;\\n        for (int i=start; i<=end; i++) res=Math.max(res,arr[i]);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] memo;\\n    public int mctFromLeafValues(int[] arr) {\\n        memo= new int[arr.length+1][arr.length+1];\\n        return dfs(arr,0,arr.length-1);\\n    }\\n    \\n    private int dfs(int[] arr, int start, int end){\\n        if(end-start==0) return 0;\\n        if(end-start==1) return arr[start]*arr[end];\\n        if(memo[start][end]!=0) return memo[start][end];\\n        \\n        int res=Integer.MAX_VALUE;\\n        for (int partition=start; partition<end; partition++){\\n            res= Math.min(res, \\n                          dfs(arr,start,partition)+dfs(arr,partition+1,end)\\n                          + (maximumInRange(arr,start,partition)*maximumInRange(arr,partition+1,end)));\\n        }\\n        memo[start][end]=res;\\n        return res;\\n    }\\n    \\n    private int maximumInRange(int[] arr, int start, int end){\\n        int res=0;\\n        for (int i=start; i<=end; i++) res=Math.max(res,arr[i]);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487776,
                "title": "java-simple-stack-solution-100",
                "content": "```java\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        Stack<Integer> stack = new Stack();\\n        int result = 0;\\n        \\n        for(int i = 0; i < arr.length; ++i) {\\n            while(!stack.empty() && stack.peek() <= arr[i])\\n                result += stack.pop() * (stack.empty() ? arr[i] : Math.min(stack.peek(), arr[i]));\\n            \\n            stack.push(arr[i]);\\n        }\\n        \\n        while(stack.size() > 1)\\n            result += stack.pop() * stack.peek();\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        Stack<Integer> stack = new Stack();\\n        int result = 0;\\n        \\n        for(int i = 0; i < arr.length; ++i) {\\n            while(!stack.empty() && stack.peek() <= arr[i])\\n                result += stack.pop() * (stack.empty() ? arr[i] : Math.min(stack.peek(), arr[i]));\\n            \\n            stack.push(arr[i]);\\n        }\\n        \\n        while(stack.size() > 1)\\n            result += stack.pop() * stack.peek();\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414705,
                "title": "c-dp-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    int sz=0;\\n    vector<int> arr;\\n    int mxdp[41][41]={};\\n    int fundp[41][41]={};\\n    int mx(int l,int r)\\n    {\\n        if(l==r) return arr[l];\\n        if(l>r) return 0;\\n        if(mxdp[l][r]) return mxdp[l][r];\\n        return mxdp[l][r]=max(mx(l+1,r),arr[l]);\\n    }\\n    int fun(int l,int r)\\n    {\\n        if(r-l<1) return 0;\\n        if(fundp[l][r]) return fundp[l][r];\\n        int ans=INT_MAX;\\n        for(int i=l;i<r;i++)\\n            ans=min(ans,fun(l,i)+fun(i+1,r)+mx(l,i)*mx(i+1,r));\\n        return fundp[l][r]=ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n       sz=arr.size();\\n        this->arr=arr;\\n        return fun(0,sz-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int sz=0;\\n    vector<int> arr;\\n    int mxdp[41][41]={};\\n    int fundp[41][41]={};\\n    int mx(int l,int r)\\n    {\\n        if(l==r) return arr[l];\\n        if(l>r) return 0;\\n        if(mxdp[l][r]) return mxdp[l][r];\\n        return mxdp[l][r]=max(mx(l+1,r),arr[l]);\\n    }\\n    int fun(int l,int r)\\n    {\\n        if(r-l<1) return 0;\\n        if(fundp[l][r]) return fundp[l][r];\\n        int ans=INT_MAX;\\n        for(int i=l;i<r;i++)\\n            ans=min(ans,fun(l,i)+fun(i+1,r)+mx(l,i)*mx(i+1,r));\\n        return fundp[l][r]=ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n       sz=arr.size();\\n        this->arr=arr;\\n        return fun(0,sz-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403495,
                "title": "c-iterative-dp-mcm",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& v) {\\n    int n = v.size();\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n    for (int j = 0; j < n; j++)\\n    {\\n        for (int i = j; i > -1; i--)\\n        {\\n            for (int k = i; k < j; k++)\\n            {\\n                int x = dp[i][k];\\n                int y = dp[k + 1][j];\\n                int temp = x + y + *max_element(v.begin() + i, v.begin() + k + 1) * *max_element(v.begin() + k + 1, v.begin() + j + 1);\\n                dp[i][j] = !dp[i][j] ? temp : min(dp[i][j], temp);\\n            }\\n        }\\n    }\\n    return dp[0][n - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& v) {\\n    int n = v.size();\\n    vector<vector<int>> dp(n, vector<int>(n, 0));\\n    for (int j = 0; j < n; j++)\\n    {\\n        for (int i = j; i > -1; i--)\\n        {\\n            for (int k = i; k < j; k++)\\n            {\\n                int x = dp[i][k];\\n                int y = dp[k + 1][j];\\n                int temp = x + y + *max_element(v.begin() + i, v.begin() + k + 1) * *max_element(v.begin() + k + 1, v.begin() + j + 1);\\n                dp[i][j] = !dp[i][j] ? temp : min(dp[i][j], temp);\\n            }\\n        }\\n    }\\n    return dp[0][n - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333938,
                "title": "monotone-stack-n-in-depth-explanation-python",
                "content": "```\\n#Basically for the minimum cost tree from Leaf Values, you want the smallest values farthest down \\n#the root, as you go up the tree, the leaf values should stay the same or increase. \\n#The tree should  look like a flatten binarty tree except each node needs 0 or two leafs.  IE given [8,4,2,3] \\n#\\n#        32\\n#       /  \\\\\\n#      12   8\\n#     / \\\\\\n#    6   4\\n#   / \\\\\\n#  2  3\\n# \\n# Result = 50\\n#have a monotone stack that keeps a decreasing order of values\\n#if we get a bigger number or equal then what is on top of the stack\\n#then we pop it off. And add whatever the value we popped off is  times the  min\\n#of ether whhats  on top of the stack or the number itself. \\n#Keep doing this process til we can add num to the stack and it will still be in decreasing order\\n#After iterating through arr, if the stack still has more than 2 values in it \\n#then pop off what is on top of the stack and\\n#times it by the next thing on the stack until there or two or less values.\\n\\n#IE if given [6,4,2] res would be 0 after iterating through arr, but stack would be [\\'INF\\',6,4,2] so it would be\\n# (6*4) + (2*4) = 32\\n\\nclass Solution:\\n    def mctFromLeafValues(self, arr):\\n        stack =  [float(\\'inf\\')]\\n        res = 0\\n        \\n        for num in arr:\\n            while stack and stack[-1] <= num:\\n                cur = stack.pop()\\n                #stack will always have atleast one thing in it after pop because inf is in there\\n                res += cur * min(num, stack[-1])\\n                \\n            stack.append(num)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        \\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Monotonic Stack"
                ],
                "code": "```\\n#Basically for the minimum cost tree from Leaf Values, you want the smallest values farthest down \\n#the root, as you go up the tree, the leaf values should stay the same or increase. \\n#The tree should  look like a flatten binarty tree except each node needs 0 or two leafs.  IE given [8,4,2,3] \\n#\\n#        32\\n#       /  \\\\\\n#      12   8\\n#     / \\\\\\n#    6   4\\n#   / \\\\\\n#  2  3\\n# \\n# Result = 50\\n#have a monotone stack that keeps a decreasing order of values\\n#if we get a bigger number or equal then what is on top of the stack\\n#then we pop it off. And add whatever the value we popped off is  times the  min\\n#of ether whhats  on top of the stack or the number itself. \\n#Keep doing this process til we can add num to the stack and it will still be in decreasing order\\n#After iterating through arr, if the stack still has more than 2 values in it \\n#then pop off what is on top of the stack and\\n#times it by the next thing on the stack until there or two or less values.\\n\\n#IE if given [6,4,2] res would be 0 after iterating through arr, but stack would be [\\'INF\\',6,4,2] so it would be\\n# (6*4) + (2*4) = 32\\n\\nclass Solution:\\n    def mctFromLeafValues(self, arr):\\n        stack =  [float(\\'inf\\')]\\n        res = 0\\n        \\n        for num in arr:\\n            while stack and stack[-1] <= num:\\n                cur = stack.pop()\\n                #stack will always have atleast one thing in it after pop because inf is in there\\n                res += cur * min(num, stack[-1])\\n                \\n            stack.append(num)\\n        while len(stack) > 2:\\n            res += stack.pop() * stack[-1]\\n        \\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1262849,
                "title": "python-solution-dp-based-o-n-3",
                "content": "```\\nclass Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        N = len(arr)\\n        dp = [[0 for _ in range(N)] for _ in range(N)]\\n        max_dp = [[0 for _ in range(N)] for _ in range(N)]\\n        \\n        for i in range(N):\\n            max_val = arr[i]\\n            for j in range(i, N):\\n                max_val = max(max_val, arr[j])\\n                max_dp[i][j] = max_val\\n                \\n        for gap in range(1, N):\\n            for i in range(N-gap):\\n                j = i + gap\\n                dp[i][j] = float(\"inf\")\\n                for k in range(i, j):\\n                    dp[i][j] = min(dp[i][j], \\\\\\n                                (dp[i][k]+dp[k+1][j])+max_dp[i][k]*max_dp[k+1][j])\\n                    \\n        \\n        return dp[0][N-1]\\n                    \\n                    \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \"\"\"\\n        \\n        N = len(arr)\\n        dp = [[0 for _ in range(N)] for _ in range(N)]\\n        max_dp = [[0 for _ in range(N)] for _ in range(N)]\\n        \\n        for i in range(N):\\n            max_val = arr[i]\\n            for j in range(i, N):\\n                max_val = max(max_val, arr[j])\\n                max_dp[i][j] = max_val\\n                \\n        for gap in range(1, N):\\n            for i in range(N-gap):\\n                j = i + gap\\n                dp[i][j] = float(\"inf\")\\n                for k in range(i, j):\\n                    dp[i][j] = min(dp[i][j], \\\\\\n                                (dp[i][k]+dp[k+1][j])+max_dp[i][k]*max_dp[k+1][j])\\n                    \\n        \\n        return dp[0][N-1]\\n                    \\n                    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1243620,
                "title": "java-o-n-time-and-space-detailed-explanation",
                "content": "```\\n   /*\\n    \"2 <= arr.length <= 40\"\\n    \"1 <= arr[i] <= 15 \"\\n  means each leaf value is positive.\\n    \"It is guaranteed that the answer fits into a 32-bit signed integer (ie. it is less than 2^31).\"\\n\\n  Idea:\\n  - Question name is \"Minimum Cost Tree From Leaf Values\"\\n  - Related Topics: stack\\n  - Similar question: Next Great Element I, Next Great Element  III\\n  - Hints are about DP which is O(N^3) time and O(N^2) space\\n\\n  Observation: for a smaller element A[i] once it is\\n   used to calculated the value of no-leaf node, the product, with another\\n   element whose value >=A[i], A[i] then will never be used anymore to\\n   calculated the value of any no-leaf node. Here the value of no-leaf node,\\n   the product, can be took as the `cost` of `removing` A[i].\\n\\n  For achieving the Minimum Cost Tree From Leaf Values\\n  - compared with the smaller element, the bigger element should be used\\n   later to avoid being used more times to calculate the cost of `removing`\\n   smaller ones. The biggest one will be used at most twice to calculate the\\n   cost of removing the second(the value of root) and the third biggest one\\n   if both of them are not on the same side of the biggest one.\\n  - when it is time to remove A[i], use the smaller one of 2 nearest bigger neighbor\\n    on both sides to make the cost of removing A[i] as small as possible,\\n    If there are smaller ones between A[i] and its 2 nearest bigger neighbor, then\\n    they should be removed firstly before removing A[i]. Monotonic descending stack\\n    is used in this kind of scenario. if there are A[x], A[i], A[y] with the same\\n    value, left one always be remove by the right one.\\n\\n  - The order of removing of each element does not affect the result\\n  - with Integer.MAX_VAL as the first element in Monotonic descending stack\\n    -- need not checking empty\\n    -- make code of calculating the cost of A[i] concise when remove A[i]\\n       in scenario where the stack status is (MAX_VAL,A[i]) and\\n       current element `cur` is bigger one. cost = A[i]*cur\\n  O(N) time and space, N is length of A[]\\n   */\\n  public int mctFromLeafValues(int[] A) {\\n    int r = 0;\\n    Stack<Integer> s = new Stack<>();\\n    s.push(Integer.MAX_VALUE); // dummy one\\n    for (int cur : A) {\\n      while (s.peek() <= cur) r += s.pop() * Math.min(s.peek(), cur); // pre > it <= cur\\n      s.push(cur);\\n    }\\n    while (s.size() > 2) r += s.pop() * s.peek();\\n    return r;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n   /*\\n    \"2 <= arr.length <= 40\"\\n    \"1 <= arr[i] <= 15 \"\\n  means each leaf value is positive.\\n    \"It is guaranteed that the answer fits into a 32-bit signed integer (ie. it is less than 2^31).\"\\n\\n  Idea:\\n  - Question name is \"Minimum Cost Tree From Leaf Values\"\\n  - Related Topics: stack\\n  - Similar question: Next Great Element I, Next Great Element  III\\n  - Hints are about DP which is O(N^3) time and O(N^2) space\\n\\n  Observation: for a smaller element A[i] once it is\\n   used to calculated the value of no-leaf node, the product, with another\\n   element whose value >=A[i], A[i] then will never be used anymore to\\n   calculated the value of any no-leaf node. Here the value of no-leaf node,\\n   the product, can be took as the `cost` of `removing` A[i].\\n\\n  For achieving the Minimum Cost Tree From Leaf Values\\n  - compared with the smaller element, the bigger element should be used\\n   later to avoid being used more times to calculate the cost of `removing`\\n   smaller ones. The biggest one will be used at most twice to calculate the\\n   cost of removing the second(the value of root) and the third biggest one\\n   if both of them are not on the same side of the biggest one.\\n  - when it is time to remove A[i], use the smaller one of 2 nearest bigger neighbor\\n    on both sides to make the cost of removing A[i] as small as possible,\\n    If there are smaller ones between A[i] and its 2 nearest bigger neighbor, then\\n    they should be removed firstly before removing A[i]. Monotonic descending stack\\n    is used in this kind of scenario. if there are A[x], A[i], A[y] with the same\\n    value, left one always be remove by the right one.\\n\\n  - The order of removing of each element does not affect the result\\n  - with Integer.MAX_VAL as the first element in Monotonic descending stack\\n    -- need not checking empty\\n    -- make code of calculating the cost of A[i] concise when remove A[i]\\n       in scenario where the stack status is (MAX_VAL,A[i]) and\\n       current element `cur` is bigger one. cost = A[i]*cur\\n  O(N) time and space, N is length of A[]\\n   */\\n  public int mctFromLeafValues(int[] A) {\\n    int r = 0;\\n    Stack<Integer> s = new Stack<>();\\n    s.push(Integer.MAX_VALUE); // dummy one\\n    for (int cur : A) {\\n      while (s.peek() <= cur) r += s.pop() * Math.min(s.peek(), cur); // pre > it <= cur\\n      s.push(cur);\\n    }\\n    while (s.size() > 2) r += s.pop() * s.peek();\\n    return r;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1231263,
                "title": "java-recursive-solution-with-memoization-top-down-dp-approach",
                "content": "```\\nclass Solution {\\n    int[][] memory;\\n    public int mctFromLeafValues(int[] arr) {\\n        memory = new int[arr.length][arr.length];\\n        //initializing memory array with invalid value -1\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=0; j<arr.length; j++){\\n                memory[i][j]=-1;\\n            }\\n        }\\n        \\n        //Top level call to recursive function\\n        return MCTSubree(arr, 0, arr.length-1);\\n    }\\n    \\n    public int MCTSubree(int[]arr, int l, int r){\\n        //if memory has already the valid value \\n        if(memory[l][r] != -1)\\n            return memory[l][r];\\n        \\n        //if subtree is just a leaf node\\n        if(l==r){\\n            memory[l][r] = 0;\\n            return 0;\\n        }\\n        \\n        int leftMaxLeaf = -1;\\n        int rightMaxLeaf = -1;\\n        int smallestSum = Integer.MAX_VALUE;\\n        \\n        //we will partition the arr between l and r index\\n        for(int p=l; p<r; p++){\\n            //determine the max leaf node in left partion\\n            leftMaxLeaf = Integer.max(leftMaxLeaf, arr[p]);\\n            \\n            //determine the max leaf node in right partion\\n            for(int i=p+1; i<=r; i++)\\n                rightMaxLeaf = Integer.max(rightMaxLeaf, arr[i]);\\n            \\n            //recursive call on left partition to get sum of non leaf nodes\\n            int leftSubtreeSum = MCTSubree(arr, l, p);\\n            //recursive call on right partition to get sum of non leaf nodes\\n            int rightSubtreeSum = MCTSubree(arr, p+1, r);\\n            \\n            //check if the current partion produces the smallest sum of non leaf nodes\\n            smallestSum = Math.min(smallestSum, leftMaxLeaf*rightMaxLeaf + leftSubtreeSum + rightSubtreeSum);\\n        }\\n        \\n        //save the result to memory\\n        memory[l][r] = smallestSum;\\n        return smallestSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] memory;\\n    public int mctFromLeafValues(int[] arr) {\\n        memory = new int[arr.length][arr.length];\\n        //initializing memory array with invalid value -1\\n        for(int i=0; i<arr.length; i++){\\n            for(int j=0; j<arr.length; j++){\\n                memory[i][j]=-1;\\n            }\\n        }\\n        \\n        //Top level call to recursive function\\n        return MCTSubree(arr, 0, arr.length-1);\\n    }\\n    \\n    public int MCTSubree(int[]arr, int l, int r){\\n        //if memory has already the valid value \\n        if(memory[l][r] != -1)\\n            return memory[l][r];\\n        \\n        //if subtree is just a leaf node\\n        if(l==r){\\n            memory[l][r] = 0;\\n            return 0;\\n        }\\n        \\n        int leftMaxLeaf = -1;\\n        int rightMaxLeaf = -1;\\n        int smallestSum = Integer.MAX_VALUE;\\n        \\n        //we will partition the arr between l and r index\\n        for(int p=l; p<r; p++){\\n            //determine the max leaf node in left partion\\n            leftMaxLeaf = Integer.max(leftMaxLeaf, arr[p]);\\n            \\n            //determine the max leaf node in right partion\\n            for(int i=p+1; i<=r; i++)\\n                rightMaxLeaf = Integer.max(rightMaxLeaf, arr[i]);\\n            \\n            //recursive call on left partition to get sum of non leaf nodes\\n            int leftSubtreeSum = MCTSubree(arr, l, p);\\n            //recursive call on right partition to get sum of non leaf nodes\\n            int rightSubtreeSum = MCTSubree(arr, p+1, r);\\n            \\n            //check if the current partion produces the smallest sum of non leaf nodes\\n            smallestSum = Math.min(smallestSum, leftMaxLeaf*rightMaxLeaf + leftSubtreeSum + rightSubtreeSum);\\n        }\\n        \\n        //save the result to memory\\n        memory[l][r] = smallestSum;\\n        return smallestSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206375,
                "title": "c-dp-mcm-recursive-memoized-faster-than-100",
                "content": "\\n       \\n     class Solution{\\n\\t public:\\n        int dp[50][50];                    \\n        int leftmax[50][50];            //i,j storing maximum sum from i to j\\n        int rightmax[50][50];          // i,j storing maximum from j to i\\n        int solve(vector<int>&arr,int i,int j){\\n\\t\\t      if(i>=j){                    // base condition\\n                 return 0;\\n              }\\n\\t           if(dp[i][j]!=-1){\\n                 return dp[i][j];\\n              }\\n       \\n\\t          int ans=INT_MAX;\\n              for(int k=i;k<j;k++){\\n                  int left,right;\\n                  if(dp[i][k]!=-1){  // checking if we already have answer from i to k\\n                     left=dp[i][k];\\n                   }\\n                 else{\\n                    dp[i][k]=solve(arr,i,k);       // if not then call and find that answer\\n                    left=dp[i][k];\\n                 }\\n            \\n                if(dp[k+1][j]!=-1){\\n                  right=dp[k+1][j];     //checking if we already have answer from k+1 to j\\n                }\\n                else{\\n                   dp[k+1][j]=solve(arr,k+1,j);   // if not then call and find \\n                   right=dp[k+1][j];\\n                 }\\n                 int temp=left+right+(leftmax[i][k]*rightmax[k+1][j]);   //add  product of maximum value from i to j and maximum value from k+1 to j \\n                 ans=min(ans,temp);    \\n           }\\n            return dp[i][j]=ans;      //find minimum and store it into dp matrix\\n       }\\n        int mctFromLeafValues(vector<int>& arr) {\\n            int n=arr.size();\\n            memset(dp,-1,sizeof(dp));\\n        \\n             for(int i=0;i<n;i++){\\n                int val=arr[i];\\n                for(int j=i;j<n;j++){\\n                val=max(val,arr[j]);\\n                leftmax[i][j]=val;\\n            }\\n        }\\n            for(int i=n-1;i>=0;i--){\\n                int val=arr[i];\\n                for(int j=i;j>=0;j--){\\n                val=max(val,arr[j]);\\n                rightmax[j][i]=val;\\n               }\\n           }\\n            return solve(arr,0,n-1);\\n         }\\n    };",
                "solutionTags": [],
                "code": "class Solution{\\n\\t public:\\n        int dp[50][50];                    \\n        int leftmax[50][50];            //i,j storing maximum sum from i to j\\n        int rightmax[50][50];          // i,j storing maximum from j to i\\n        int solve(vector<int>&arr,int i,int j){\\n\\t\\t      if(i>=j){                    // base condition\\n                 return 0;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 1204319,
                "title": "java-simple-solution-3-ms-faster-than-50-56-dp",
                "content": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr)\\n    {\\n        int n=arr.length-1;\\n        return fun(arr, 0, n, new Pair[n+1][n+1]).sum;\\n    }\\n    \\n    public Pair fun(int[] arr, int l, int r, Pair[][] dp)\\n    {\\n        if(l>r) return new Pair(0,1000000);\\n        if(l==r)return new Pair(arr[l], 0);\\n        if(dp[l][r]!=null) return dp[l][r];\\n        Pair ans=new Pair(0, 1000000);\\n        for(int i=l;i<r;i++)\\n        {\\n           Pair Pair_left= fun(arr, l, i, dp);\\n           Pair  Pair_right=fun(arr, i+1, r, dp);\\n            \\n            int total= Pair_left.sum + Pair_right.sum +(Pair_left.max * Pair_right.max);\\n            \\n            if(total< ans.sum)\\n            {\\n                ans.max= Math.max(Pair_left.max, Pair_right.max);\\n                ans.sum= total;\\n            }\\n        }\\n        dp[l][r]= new Pair(ans.max, ans.sum);\\n        return ans;\\n    }\\n}\\n\\nclass Pair\\n{\\n    int max, sum;\\n    Pair(int max, int sum)\\n    {\\n        this.max=max;\\n        this.sum=sum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n    public int mctFromLeafValues(int[] arr)\\n    {\\n        int n=arr.length-1;\\n        return fun(arr, 0, n, new Pair[n+1][n+1]).sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1102713,
                "title": "c-top-down-dp-simple-sol",
                "content": "class Solution {\\npublic:\\n    \\n    int dp[42][42];\\n    \\n    int fin(vector<int>&v , int l , int r){\\n        int ans = 0 ;\\n        for(int i=l; i<=r ; i++){\\n            ans = max(ans , v[i]);\\n        }\\n        return ans ;\\n    }\\n    \\n    int fun(vector<int>& v , int l , int r){\\n        if(l>=r){\\n            return 0;\\n        }\\n        if(dp[l][r]!= -1){\\n            return dp[l][r];\\n        }\\n        int ans = INT_MAX ;\\n        for(int i=l ; i<r ; i++){\\n            ans = min(ans , fin(v,l,i)*fin(v,i+1,r) + fun(v , l, i) + fun(v , i+1 , r));\\n        }\\n        \\n        return dp[l][r] = ans;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        memset(dp , -1 , sizeof(dp));\\n        int ans = fun(arr , 0 , arr.size()-1);\\n        return ans ;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int dp[42][42];\\n    \\n    int fin(vector<int>&v , int l , int r){\\n        int ans = 0 ;\\n        for(int i=l; i<=r ; i++){\\n            ans = max(ans , v[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1054145,
                "title": "java-short-iterative-dp-solution",
                "content": "```\\npublic int mctFromLeafValues(int[] arr) {\\n\\tint res = Integer.MAX_VALUE, n = arr.length;\\n\\tint[][] dp = new int[n][n], max = new int[n][n];\\n\\tfor(int len = 0; len < n; len++) {\\n\\t\\tfor(int i = 0; i + len < n; i++) {\\n\\t\\t\\tint j = i + len;\\n\\t\\t\\tif(i == j) {\\n\\t\\t\\t\\tmax[i][j] = arr[i];\\n\\t\\t\\t} else if(i + 1 == j){\\n\\t\\t\\t\\tdp[i][j] = arr[i] * arr[j];\\n\\t\\t\\t\\tmax[i][j] = Math.max(arr[i], arr[j]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[i][j] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor(int k = i; k < j; k++) {\\n\\t\\t\\t\\t\\tdp[i][j] = Math.min(dp[i][k] + dp[k + 1][j] + max[i][k] * max[k + 1][j], dp[i][j]);\\n\\t\\t\\t\\t\\tmax[i][j] = Math.max(max[i][k], max[k + 1][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][n - 1];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int mctFromLeafValues(int[] arr) {\\n\\tint res = Integer.MAX_VALUE, n = arr.length;\\n\\tint[][] dp = new int[n][n], max = new int[n][n];\\n\\tfor(int len = 0; len < n; len++) {\\n\\t\\tfor(int i = 0; i + len < n; i++) {\\n\\t\\t\\tint j = i + len;\\n\\t\\t\\tif(i == j) {\\n\\t\\t\\t\\tmax[i][j] = arr[i];\\n\\t\\t\\t} else if(i + 1 == j){\\n\\t\\t\\t\\tdp[i][j] = arr[i] * arr[j];\\n\\t\\t\\t\\tmax[i][j] = Math.max(arr[i], arr[j]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdp[i][j] = Integer.MAX_VALUE;\\n\\t\\t\\t\\tfor(int k = i; k < j; k++) {\\n\\t\\t\\t\\t\\tdp[i][j] = Math.min(dp[i][k] + dp[k + 1][j] + max[i][k] * max[k + 1][j], dp[i][j]);\\n\\t\\t\\t\\t\\tmax[i][j] = Math.max(max[i][k], max[k + 1][j]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn dp[0][n - 1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1007611,
                "title": "simple-python3-code",
                "content": "Pretty simple to understand:\\n\\n![image](https://assets.leetcode.com/users/images/71c435b6-5e4d-4b7a-b2c2-6e55a7c44c4e_1610117879.4392443.png)\\n\\n\\n```\\n# By Varsha Verma\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        if not arr:\\n            return 0\\n        if len(arr)<2:\\n            return 0\\n        if len(arr)==2:\\n            return arr[0]*arr[-1]\\n        res = 0\\n        while(len(arr)>1):\\n            max = arr[0]*arr[1]\\n            l = 0\\n            r = 1\\n            for i in range(len(arr)-1):\\n                if arr[i]*arr[i+1]<max:\\n                    max = arr[i]*arr[i+1]\\n                    l = i\\n                    r = i+1\\n            res+=max\\n            #print(l,r,max)\\n            if arr[l]>arr[r]:\\n                del arr[r]\\n            else:\\n                del arr[l]\\n        return res\\n\\t\\t\\n\\t```\\n\\t\\n\\t```\\n\\tclass Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        ans = 0\\n        while len(arr) > 1:\\n            minIndex = arr.index(min(arr))\\n            if 0 < minIndex < len(arr) - 1:\\n                ans += min(arr[minIndex - 1], arr[minIndex + 1]) * arr[minIndex]\\n            else:  \\n           #handle corner cases:when minimum value is either first value or last value of the list ex:[2,6,4]/[6,4,2]     \\n                ans += arr[1 if minIndex == 0 else minIndex - 1] * arr[minIndex]\\n            arr.pop(minIndex)\\n        return ans \\n        \\n\\t\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# By Varsha Verma\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        if not arr:\\n            return 0\\n        if len(arr)<2:\\n            return 0\\n        if len(arr)==2:\\n            return arr[0]*arr[-1]\\n        res = 0\\n        while(len(arr)>1):\\n            max = arr[0]*arr[1]\\n            l = 0\\n            r = 1\\n            for i in range(len(arr)-1):\\n                if arr[i]*arr[i+1]<max:\\n                    max = arr[i]*arr[i+1]\\n                    l = i\\n                    r = i+1\\n            res+=max\\n            #print(l,r,max)\\n            if arr[l]>arr[r]:\\n                del arr[r]\\n            else:\\n                del arr[l]\\n        return res\\n\\t\\t\\n\\t```\n```\\n\\tclass Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        ans = 0\\n        while len(arr) > 1:\\n            minIndex = arr.index(min(arr))\\n            if 0 < minIndex < len(arr) - 1:\\n                ans += min(arr[minIndex - 1], arr[minIndex + 1]) * arr[minIndex]\\n            else:  \\n           #handle corner cases:when minimum value is either first value or last value of the list ex:[2,6,4]/[6,4,2]     \\n                ans += arr[1 if minIndex == 0 else minIndex - 1] * arr[minIndex]\\n            arr.pop(minIndex)\\n        return ans \\n        \\n\\t\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1006966,
                "title": "java-bottom-up-dp",
                "content": "All thanks to this type of DP pattern which i learnt from this post : https://leetcode.com/discuss/general-discussion/458695/Dynamic-Programming-Patterns#Merging-Intervals\\n\\nTo optmisie further , could have use segement tree to Range max queries \\n```\\nclass Solution {\\n  private int infi = Integer.MAX_VALUE/2;\\n    public int mctFromLeafValues(int[] arr) {\\n       if(arr == null || arr.length <= 1)\\n           return 0;\\n       int n = arr.length;\\n       int[][] dp = new int[n][n];\\n\\n       //len = 1\\n       for (int i = 0; i < n ; i++)\\n           dp[i][i] = 0;\\n\\n       //len = 2\\n       for (int i = 0; i < n-1; i++)\\n           dp[i][i+1] = arr[i]*arr[i+1];\\n\\n       //len 3 and above\\n       for (int len = 3; len  <= n; len++){\\n           for (int i = 0; i+len-1 <= n-1; i++){\\n               int j = i+len-1;\\n               dp[i][j] = infi;\\n               for (int k = i; k <j ; k++){\\n                   dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k+1][j]+ maxVal(arr, i,k) * maxVal(arr, k+1, j));\\n               }\\n           }\\n       }\\n       return dp[0][n-1];\\n    }\\n\\n    private int maxVal(int[] arr, int low, int high){\\n        int max = Integer.MIN_VALUE;\\n        for (int i = low; i <= high; i++)\\n            max = Math.max(max, arr[i]);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  private int infi = Integer.MAX_VALUE/2;\\n    public int mctFromLeafValues(int[] arr) {\\n       if(arr == null || arr.length <= 1)\\n           return 0;\\n       int n = arr.length;\\n       int[][] dp = new int[n][n];\\n\\n       //len = 1\\n       for (int i = 0; i < n ; i++)\\n           dp[i][i] = 0;\\n\\n       //len = 2\\n       for (int i = 0; i < n-1; i++)\\n           dp[i][i+1] = arr[i]*arr[i+1];\\n\\n       //len 3 and above\\n       for (int len = 3; len  <= n; len++){\\n           for (int i = 0; i+len-1 <= n-1; i++){\\n               int j = i+len-1;\\n               dp[i][j] = infi;\\n               for (int k = i; k <j ; k++){\\n                   dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k+1][j]+ maxVal(arr, i,k) * maxVal(arr, k+1, j));\\n               }\\n           }\\n       }\\n       return dp[0][n-1];\\n    }\\n\\n    private int maxVal(int[] arr, int low, int high){\\n        int max = Integer.MIN_VALUE;\\n        for (int i = low; i <= high; i++)\\n            max = Math.max(max, arr[i]);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1006641,
                "title": "java-o-n-square-easily-understandable-solution-with-explanation",
                "content": "Imagine you are the organizer of a tournament for n players. The price you pay for a match is depends on the 2 players. One reasonable price for a match is price[player1]*price[player2], another price model price[player1] + price[player2] could also be reasonable, how we model it doesn\\'t matter, both price model go to the same direction. Now you want to arrange the matches until we have a champion. The goal is to minimize your cost.\\n\\nAs the organizer, you can do this. You find the weakest player that is still in the game, and will be eliminated in the next match. In order to pay less for that match, you want to choose the weakest opponent possible. With the constraint that \"Given an array of n positive integers, the values in the array map to the leaves of a binary search tree from left to right.\", you can only choose the opponent next to the weakest player (left or right). So, in order to remove a[i] from the game array a, you need to pick min(a[i-1], a[i+1]), the cost for this match will be a[i] * min(a[i-1], a[i+1]). Keep doing this, we can find the matching arrangement with minimum cost. As a bonus you probably get the highest watching rates because this arrangement favors close matches!\\n\\n![image](https://assets.leetcode.com/users/images/5d4c243f-6012-41de-80c4-6b48a850e0c5_1610048318.016361.png)\\n\\n\\n```\\nclass Solution {\\n  public int mctFromLeafValues(int[] A) {\\n    int cost = 0;\\n    int N = A.length;\\n    while(N > 1) {\\n      int ko = findMin(A, N);\\n      cost += A[ko] * minNeighbor(A, ko, N);\\n      removeElement(A, ko, N);\\n      N--;\\n    }\\n    return cost;\\n  }\\n\\n  private static int minNeighbor(int[] a, int ko, int N) {\\n    if(ko - 1 >= 0 && ko + 1 < N) {\\n      return Math.min(a[ko-1], a[ko+1]);\\n    } else {\\n      if(ko - 1 < 0) return a[ko+1];\\n      else return a[ko-1];\\n    }\\n  }\\n\\n  private static void removeElement(int[] a, int ko, int N) {\\n    for(int i = ko; i < N-1; i++) {\\n      a[i] = a[i+1];\\n    }\\n  }\\n\\n  private static int findMin(int[] a, int N) {\\n    int min = Integer.MAX_VALUE;\\n    int index = 0;\\n    for(int i = 0; i < N; i++) {\\n      if(min > a[i]) {\\n        min = a[i];\\n        index = i;\\n      }\\n    }\\n    return index;\\n  }\\n\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int mctFromLeafValues(int[] A) {\\n    int cost = 0;\\n    int N = A.length;\\n    while(N > 1) {\\n      int ko = findMin(A, N);\\n      cost += A[ko] * minNeighbor(A, ko, N);\\n      removeElement(A, ko, N);\\n      N--;\\n    }\\n    return cost;\\n  }\\n\\n  private static int minNeighbor(int[] a, int ko, int N) {\\n    if(ko - 1 >= 0 && ko + 1 < N) {\\n      return Math.min(a[ko-1], a[ko+1]);\\n    } else {\\n      if(ko - 1 < 0) return a[ko+1];\\n      else return a[ko-1];\\n    }\\n  }\\n\\n  private static void removeElement(int[] a, int ko, int N) {\\n    for(int i = ko; i < N-1; i++) {\\n      a[i] = a[i+1];\\n    }\\n  }\\n\\n  private static int findMin(int[] a, int N) {\\n    int min = Integer.MAX_VALUE;\\n    int index = 0;\\n    for(int i = 0; i < N; i++) {\\n      if(min > a[i]) {\\n        min = a[i];\\n        index = i;\\n      }\\n    }\\n    return index;\\n  }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947301,
                "title": "java-greedy-based-on-huffman-coding-beats-100",
                "content": "Unlike optimal huffman coding, we cannot choose any 2 values as leaf nodes and start \"merging\" them. But still, after drawing out some examples, it becomes clear that choosing the minimum first makes more sense in a greedy method. Thus we repeat below steps till a single node remains (which is our root). I use a Doubly Linked List in order to represent an array for O(1) removal.\\n\\n1. Pick up the leaf node with minimum value.\\n2. Combine it with its inorder neighbor which has smaller value between neighbors.\\n3. Once we get the new generated non-leaf node, the node with minimum value is useless (For the new generated subtree will be represented with the largest leaf node value.)\\n4. Repeat it until there is only one node.\\n\\n```\\nclass ListNode{\\n    Integer val;\\n    ListNode next;\\n    ListNode prev;\\n    public ListNode(int value){\\n        this.val = value;\\n    }\\n    public ListNode(){}\\n    public String toString(){ return this.val+\"\"; }\\n}\\n\\nclass Solution {\\n    ListNode head;\\n    ListNode tail;\\n    public int mctFromLeafValues(int[] arr) {\\n        head = new ListNode();\\n        tail = new ListNode();\\n        convertToDoublyLinkedList(arr); //O(n) time and O(n) space\\n        \\n        int sum = 0;\\n        int left = arr.length;\\n        while(left-- != 1){ // O(n) time\\n            // find minimum of the LinkedList\\n            ListNode min = findMin(); // O(n) time\\n            \\n            // find min left and right neighbour\\n            int minRightVal = min.next == tail ? Integer.MAX_VALUE: min.next.val;\\n            int minLeftVal = min.prev == head ? Integer.MAX_VALUE: min.prev.val;\\n            sum += Math.min(minLeftVal, minRightVal) * min.val;\\n            \\n            remove(min); // O(1) time\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    private void remove(ListNode node){\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    private ListNode findMin(){\\n        ListNode curr = head.next;\\n        ListNode min = null;\\n        int minVal = Integer.MAX_VALUE;\\n        \\n        while(curr != tail){\\n            if(curr.val < minVal){\\n                minVal = curr.val;\\n                min = curr;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return min;\\n    }\\n    \\n    private void convertToDoublyLinkedList(int[] arr){\\n        ListNode prev = head;\\n        for(int num: arr){\\n            ListNode curr = new ListNode(num);\\n            prev.next = curr;\\n            curr.prev = prev;\\n            prev = curr;\\n        }\\n        \\n        prev.next = tail;\\n        tail.prev = prev;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass ListNode{\\n    Integer val;\\n    ListNode next;\\n    ListNode prev;\\n    public ListNode(int value){\\n        this.val = value;\\n    }\\n    public ListNode(){}\\n    public String toString(){ return this.val+\"\"; }\\n}\\n\\nclass Solution {\\n    ListNode head;\\n    ListNode tail;\\n    public int mctFromLeafValues(int[] arr) {\\n        head = new ListNode();\\n        tail = new ListNode();\\n        convertToDoublyLinkedList(arr); //O(n) time and O(n) space\\n        \\n        int sum = 0;\\n        int left = arr.length;\\n        while(left-- != 1){ // O(n) time\\n            // find minimum of the LinkedList\\n            ListNode min = findMin(); // O(n) time\\n            \\n            // find min left and right neighbour\\n            int minRightVal = min.next == tail ? Integer.MAX_VALUE: min.next.val;\\n            int minLeftVal = min.prev == head ? Integer.MAX_VALUE: min.prev.val;\\n            sum += Math.min(minLeftVal, minRightVal) * min.val;\\n            \\n            remove(min); // O(1) time\\n        }\\n        \\n        return sum;\\n    }\\n    \\n    private void remove(ListNode node){\\n        node.prev.next = node.next;\\n        node.next.prev = node.prev;\\n    }\\n    \\n    private ListNode findMin(){\\n        ListNode curr = head.next;\\n        ListNode min = null;\\n        int minVal = Integer.MAX_VALUE;\\n        \\n        while(curr != tail){\\n            if(curr.val < minVal){\\n                minVal = curr.val;\\n                min = curr;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return min;\\n    }\\n    \\n    private void convertToDoublyLinkedList(int[] arr){\\n        ListNode prev = head;\\n        for(int num: arr){\\n            ListNode curr = new ListNode(num);\\n            prev.next = curr;\\n            curr.prev = prev;\\n            prev = curr;\\n        }\\n        \\n        prev.next = tail;\\n        tail.prev = prev;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895046,
                "title": "java-greedy-using-array-beat-100",
                "content": "Amazing and interesting question. My first response is backtracking + stack, but actually using Greedy can easily solve this. Have no idea how DP would work for this.\\n\\nSay for arr [5, 2, 3, 4]\\nMy first response would be just like adding parenthesis for different combination, like\\n(((5, 2), 3), 4), so collapse 5 and 2, the result will collapse with 3\\nAnother possibility (5,(2,(3,4))).\\nPay attention the number should be in order.\\n\\nBecause the biggest number of subtree will be calculated multiple time for product, so we should always try to pair with the smallest bigger number.\\nSo it\\'ll be (5,2), (2, 3), (3, 4); and we\\'ll choose (2, 3), plus product 2 * 3 = 6 into sum, then collalpse (2, 3) into 3, then array becomes [5, 3, 4], actually [5, 0, 3, 4], where we\\'ll skip zero. Then we can do this until there\\'s only one number > 0 left in array.\\n\\nBecause it\\'s only manipulating one single array, so beat 100%\\n\\n```\\nclass Solution {\\n    int sum = 0;\\n    public int mctFromLeafValues(int[] arr) {\\n        while (!oneZero(arr)) {\\n            findMin(arr);\\n        }\\n        return sum;\\n    }\\n    \\n    // For each traverse, find the two-num pair with smallest bigger num.\\n    private void findMin(int[] arr) {\\n        int firIdx = 0, secIdx = 0;\\n        int r1 = 0, r2 = 0; // result\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] != 0) {\\n                firIdx = i;\\n                break;\\n            }\\n        }\\n        \\n        for (int i = firIdx + 1; i < arr.length; i++) {\\n            if (arr[i] == 0) continue;\\n            // The next neighbor.\\n            secIdx = i;\\n            int bigger = Math.max(arr[firIdx], arr[secIdx]);\\n            if (bigger < min) { // Find the two-num pair with smallest bigger num\\n                min = bigger;\\n                r1 = firIdx;\\n                r2 = secIdx;\\n            }\\n            firIdx = secIdx;\\n        }\\n        \\n        // non-leaf node val equals to product\\n        sum += arr[r1] * arr[r2];\\n        // Reset whichever smaller to zero so next step we\\'ll skip.\\n        if (arr[r1] < arr[r2]) arr[r1] = 0;\\n        else arr[r2] = 0;\\n    }\\n    \\n    // Find until there\\'s only one int left in array.\\n    private boolean oneZero(int[] arr) {\\n        int count = 0;\\n        for (int num : arr) {\\n            if (num > 0) count++;\\n        }\\n        return count == 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int sum = 0;\\n    public int mctFromLeafValues(int[] arr) {\\n        while (!oneZero(arr)) {\\n            findMin(arr);\\n        }\\n        return sum;\\n    }\\n    \\n    // For each traverse, find the two-num pair with smallest bigger num.\\n    private void findMin(int[] arr) {\\n        int firIdx = 0, secIdx = 0;\\n        int r1 = 0, r2 = 0; // result\\n        int min = Integer.MAX_VALUE;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] != 0) {\\n                firIdx = i;\\n                break;\\n            }\\n        }\\n        \\n        for (int i = firIdx + 1; i < arr.length; i++) {\\n            if (arr[i] == 0) continue;\\n            // The next neighbor.\\n            secIdx = i;\\n            int bigger = Math.max(arr[firIdx], arr[secIdx]);\\n            if (bigger < min) { // Find the two-num pair with smallest bigger num\\n                min = bigger;\\n                r1 = firIdx;\\n                r2 = secIdx;\\n            }\\n            firIdx = secIdx;\\n        }\\n        \\n        // non-leaf node val equals to product\\n        sum += arr[r1] * arr[r2];\\n        // Reset whichever smaller to zero so next step we\\'ll skip.\\n        if (arr[r1] < arr[r2]) arr[r1] = 0;\\n        else arr[r2] = 0;\\n    }\\n    \\n    // Find until there\\'s only one int left in array.\\n    private boolean oneZero(int[] arr) {\\n        int count = 0;\\n        for (int num : arr) {\\n            if (num > 0) count++;\\n        }\\n        return count == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888406,
                "title": "c-dp",
                "content": "```\\npublic class Solution {\\n    public int MctFromLeafValues(int[] arr) {\\n        int len = arr.Length;\\n        int[,] max = new int[len, len];\\n        for (int i = 0; i < len; i++) \\n            max[i, i] = arr[i];\\n        \\n        for (int i = 0; i < len; i++)\\n        {\\n            for (int j = i + 1; j < len; j++)\\n            {\\n                max[i,j] = Math.Max(max[i, j - 1], arr[j]);\\n            }\\n        }\\n        \\n        int[,] dp = new int[len, len];\\n        for (int i = 0; i + 1 < len; i++)\\n            dp[i, i + 1] = arr[i] * arr[i + 1];\\n        \\n         for (int l = 2; l <= len; l++)\\n            {\\n                for (int i = 0; i < len - l; i++)\\n                {\\n                    int minCost = int.MaxValue;\\n                    int j = i + l;\\n                    for (int k = i; k < j; k++)\\n                    {\\n                        int temp = dp[i,k] + dp[k + 1, j] + (max[i,k] * max[k + 1, j]);\\n                        minCost = Math.Min(minCost, temp);\\n                    }\\n                    dp[i, j] = minCost;\\n                }\\n            }\\n        return dp[0, len - 1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\npublic class Solution {\\n    public int MctFromLeafValues(int[] arr) {\\n        int len = arr.Length;\\n        int[,] max = new int[len, len];\\n        for (int i = 0; i < len; i++) \\n            max[i, i] = arr[i];\\n        \\n        for (int i = 0; i < len; i++)\\n        {\\n            for (int j = i + 1; j < len; j++)\\n            {\\n                max[i,j] = Math.Max(max[i, j - 1], arr[j]);\\n            }\\n        }\\n        \\n        int[,] dp = new int[len, len];\\n        for (int i = 0; i + 1 < len; i++)\\n            dp[i, i + 1] = arr[i] * arr[i + 1];\\n        \\n         for (int l = 2; l <= len; l++)\\n            {\\n                for (int i = 0; i < len - l; i++)\\n                {\\n                    int minCost = int.MaxValue;\\n                    int j = i + l;\\n                    for (int k = i; k < j; k++)\\n                    {\\n                        int temp = dp[i,k] + dp[k + 1, j] + (max[i,k] * max[k + 1, j]);\\n                        minCost = Math.Min(minCost, temp);\\n                    }\\n                    dp[i, j] = minCost;\\n                }\\n            }\\n        return dp[0, len - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864430,
                "title": "dynamic-programming-method-explanation-video",
                "content": "I found a nice video that explain with great details how to resolve an algorithms like this (Yeah, its long. But it\\'s woth if you want to understand DP).\\n\\nhttps://www.youtube.com/watch?v=_WncuhSJZyA\\n\\nI also put my code, if you understand the video the code will result actually not that hard. \\nHope it helps somebody. \\nPlease comment if see any error, improvement or if you dont understand something :)\\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr)\\n    {\\n        //Creating and filling DP table with the initial values (all value-pair multiplication)\\n        vector<vector<int>> dp(arr.size(), vector<int>(arr.size()));\\n        for(size_t i{ 0 }, j{ 1 }; j < arr.size(); ++i, ++j) dp[i][j] = arr[i] * arr[j];\\n        \\n        //Creation of auxiliar array with max elements (for example for array {2,3,4,5} max_elem[0][0] means max element from posiion 0\\n        // to position 0 and is the value 2. And max_elem[0][3] means max element from position 0 to position 3 and its the value 5)\\n        vector<vector<int>> max_el(arr.size(), vector<int>(arr.size()));\\n        for(size_t i{ 0 }; i < arr.size(); ++i) max_el[i][i] = arr[i];\\n        for(size_t i{ 0 }; i < arr.size(); ++i)\\n            for(size_t j{ i + 1}; j < arr.size(); ++j)\\n                max_el[i][j] = *max_element(arr.begin() + i, arr.begin() + j + 1);\\n        \\n        //The dynamic programming logic (which is explained in the video) You should understand it clearly if you watch the video\\n        for(size_t i{ 2 }; i < arr.size(); ++i)\\n            for(size_t j{ 0 }, k{ i }; k < arr.size(); ++j, ++k)\\n            {\\n                int min_val{ numeric_limits<int>::max() };\\n                for(size_t m{ j }; m < k; ++m)\\n                {\\n                    int val{ max_el[j][m] * max_el[m + 1][k] + ((j == m) ? 0 : dp[j][m]) + ((m + 1 == k) ? 0 : dp[m + 1][k]) };\\n                    if(min_val > val) min_val = val;\\n                }\\n                dp[j][k] = min_val;\\n            }\\n        return dp[0][arr.size() - 1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr)\\n    {\\n        //Creating and filling DP table with the initial values (all value-pair multiplication)\\n        vector<vector<int>> dp(arr.size(), vector<int>(arr.size()));\\n        for(size_t i{ 0 }, j{ 1 }; j < arr.size(); ++i, ++j) dp[i][j] = arr[i] * arr[j];\\n        \\n        //Creation of auxiliar array with max elements (for example for array {2,3,4,5} max_elem[0][0] means max element from posiion 0\\n        // to position 0 and is the value 2. And max_elem[0][3] means max element from position 0 to position 3 and its the value 5)\\n        vector<vector<int>> max_el(arr.size(), vector<int>(arr.size()));\\n        for(size_t i{ 0 }; i < arr.size(); ++i) max_el[i][i] = arr[i];\\n        for(size_t i{ 0 }; i < arr.size(); ++i)\\n            for(size_t j{ i + 1}; j < arr.size(); ++j)\\n                max_el[i][j] = *max_element(arr.begin() + i, arr.begin() + j + 1);\\n        \\n        //The dynamic programming logic (which is explained in the video) You should understand it clearly if you watch the video\\n        for(size_t i{ 2 }; i < arr.size(); ++i)\\n            for(size_t j{ 0 }, k{ i }; k < arr.size(); ++j, ++k)\\n            {\\n                int min_val{ numeric_limits<int>::max() };\\n                for(size_t m{ j }; m < k; ++m)\\n                {\\n                    int val{ max_el[j][m] * max_el[m + 1][k] + ((j == m) ? 0 : dp[j][m]) + ((m + 1 == k) ? 0 : dp[m + 1][k]) };\\n                    if(min_val > val) min_val = val;\\n                }\\n                dp[j][k] = min_val;\\n            }\\n        return dp[0][arr.size() - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 853691,
                "title": "c-two-methods-tabulation-dp-and-top-down-memoization-recursion",
                "content": "Tabulation\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        int maxi[n][n];\\n        memset(maxi,0,sizeof(maxi));\\n        for(int i=0;i<n;i++)maxi[i][i]=arr[i];\\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                maxi[i][j]=max(maxi[i][j-1],maxi[i+1][j]);\\n            }\\n        }\\n        \\n        int dp[n+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                dp[i][j]=INT_MAX;\\n                for(int k=i;k<j;k++)\\n                {\\n                    dp[i][j]=min(dp[i][j],maxi[i][k]*maxi[k+1][j]+dp[i][k]+dp[k+1][j]);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```\\nMemoization\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> maxi;\\n    vector<vector<int>> dp;\\n    int solve(int i,int j)\\n    {\\n        if(i==j)\\n            return dp[i][i]=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        dp[i][j]=INT_MAX;\\n        for(int k=i;k<j;k++)\\n        {\\n            dp[i][j]=min(dp[i][j] ,\\n                         solve(i,k) + solve(k+1,j) + maxi[i][k]*maxi[k+1][j] );\\n        }\\n        return dp[i][j];\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        maxi.resize(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++)maxi[i][i]=arr[i];\\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                maxi[i][j]=max(maxi[i][j-1],maxi[i+1][j]);\\n            }\\n        }\\n        \\n        dp.resize(n+1,vector<int>(n+1,-1));\\n        return solve(0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        int maxi[n][n];\\n        memset(maxi,0,sizeof(maxi));\\n        for(int i=0;i<n;i++)maxi[i][i]=arr[i];\\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                maxi[i][j]=max(maxi[i][j-1],maxi[i+1][j]);\\n            }\\n        }\\n        \\n        int dp[n+1][n+1];\\n        memset(dp,0,sizeof(dp));\\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                dp[i][j]=INT_MAX;\\n                for(int k=i;k<j;k++)\\n                {\\n                    dp[i][j]=min(dp[i][j],maxi[i][k]*maxi[k+1][j]+dp[i][k]+dp[k+1][j]);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> maxi;\\n    vector<vector<int>> dp;\\n    int solve(int i,int j)\\n    {\\n        if(i==j)\\n            return dp[i][i]=0;\\n        if(dp[i][j]!=-1)return dp[i][j];\\n        dp[i][j]=INT_MAX;\\n        for(int k=i;k<j;k++)\\n        {\\n            dp[i][j]=min(dp[i][j] ,\\n                         solve(i,k) + solve(k+1,j) + maxi[i][k]*maxi[k+1][j] );\\n        }\\n        return dp[i][j];\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n=arr.size();\\n        maxi.resize(n,vector<int>(n,0));\\n        for(int i=0;i<n;i++)maxi[i][i]=arr[i];\\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                maxi[i][j]=max(maxi[i][j-1],maxi[i+1][j]);\\n            }\\n        }\\n        \\n        dp.resize(n+1,vector<int>(n+1,-1));\\n        return solve(0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847807,
                "title": "bottom-up-dp-c-solution-n-3-time-and-n-2-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        vector<vector<int>> maxi(n,vector<int>(n,0));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            maxi[i][i]=arr[i];\\n        }\\n        \\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                \\n                maxi[i][j]=max(maxi[i][j-1],maxi[i+1][j]);\\n            }\\n        }\\n        \\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        \\n        for(int l=1;l<n;l++)\\n        {\\n            for(int i=0;i<n-l;i++)\\n            {\\n                int j=i+l;\\n                dp[i][j]=INT_MAX;\\n                for(int k=i;k<j;k++)\\n                {\\n                    dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+maxi[i][k]*maxi[k+1][j]);\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        vector<vector<int>> maxi(n,vector<int>(n,0));\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            maxi[i][i]=arr[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 760467,
                "title": "java-o-n-time-and-o-n-space",
                "content": "This is first time I am posting something\\nIt took O(n) space and O(n) time\\n\\nThe idea is:\\n1. mid guy has an option to choose if it\\'s right is smaller or it\\'s left is biggest among three\\n2. Check this first and if mid guy has no option just multiply this with it\\'s left\\n3. Now if this is not the case then store all three\\n4. now check the next element with the last two stored value and do the same operation\\n5. Don\\'t stop after the single operation, keep on doing it until you can.\\n\\nExample:\\n\\n15 13 3 5 15\\n\\nnow pick first 3 : 15, (13), 3  ===> mid guy can choose\\n\\nso move on to next i.e. 5\\n\\nnow you have: 13, (3), 5 ===> mid guy again can choose\\n\\nso move on to next i.e. 15\\n\\nnow you have: 3, (5), 15 ===> Finally! mid guy has no option\\n\\nmultiply 3 and 5 => 15\\ntotal  = 15\\n\\n\\npick max = 5\\n\\nrearrange the list (use stack)\\n\\n15 13 5 15\\n\\nnot check again the last three and dont move forward for now\\n\\nnow you have: 13 (5) 15 ===> mid guy has no option\\n\\nmultiply 13 and 5 => 65 + total\\ntotal 80\\n\\npick max = 13\\n\\nrearrange the list\\n\\n15 13  15\\n\\nnot check again the last three and dont move forward for now\\n\\nnow you have: 15 (13) 15 ===> mid guy has no option\\n\\nmultiply 15 and 13 => 195 + total\\ntotal 275\\n\\npick max = 15\\n\\n15 15\\nnow you can not do this as stack has less than 3 size\\n\\nmove forward and array is empty\\n\\n15 15\\npop out from stack and save it as max\\nmax = 15\\nwhile you stack is not empty\\nvalue  = stack pop (15)\\ntotal += value*max (300)\\nmax = max(value, max) (15)\\n\\nI hope its a bit clear this way\\n\\n\\n\\n```\\n// Code\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {        \\n        Stack<Integer> st = new Stack();\\n        int result = 0;\\n        \\n        for(int i=0; i<arr.length; i++) {\\n            st.push(arr[i]);\\n            while(!st.isEmpty() && st.size()>2) {\\n                int n3 = st.pop();\\n                int n2 = st.pop();\\n                int n1 = st.pop();\\n                if((n1<=n3 || n1<=n2) && n2<=n3) {\\n                    result += n1*n2;\\n                    n1 = Math.max(n1,n2);\\n                    st.push(n1);\\n                    st.push(n3);\\n                }else{\\n                    st.push(n1);\\n                    st.push(n2);\\n                    st.push(n3);\\n                    break;\\n                }\\n            }\\n        }\\n                \\n        int max = st.pop();\\n        while(!st.isEmpty()) {\\n            int current = st.pop();\\n            result += max*current;\\n            max = Math.max(max,current);\\n        }\\n        return result;\\n     }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// Code\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {        \\n        Stack<Integer> st = new Stack();\\n        int result = 0;\\n        \\n        for(int i=0; i<arr.length; i++) {\\n            st.push(arr[i]);\\n            while(!st.isEmpty() && st.size()>2) {\\n                int n3 = st.pop();\\n                int n2 = st.pop();\\n                int n1 = st.pop();\\n                if((n1<=n3 || n1<=n2) && n2<=n3) {\\n                    result += n1*n2;\\n                    n1 = Math.max(n1,n2);\\n                    st.push(n1);\\n                    st.push(n3);\\n                }else{\\n                    st.push(n1);\\n                    st.push(n2);\\n                    st.push(n3);\\n                    break;\\n                }\\n            }\\n        }\\n                \\n        int max = st.pop();\\n        while(!st.isEmpty()) {\\n            int current = st.pop();\\n            result += max*current;\\n            max = Math.max(max,current);\\n        }\\n        return result;\\n     }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758560,
                "title": "simple-c-solution-without-dp-dynamic-programming",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        //if(arr.size() == 2) return arr[0]*arr[1];\\n        int sum = 0;\\n        while(arr.size() != 1){\\n            int i = 1,j = 0;\\n            \\n            for(i;i < arr.size()-1;i++)      // find minimum product of two consecutive number\\n                if(arr[i]*arr[i + 1] < arr[j]*arr[j + 1]) \\n                    j = i;\\n            \\n            sum += arr[j]*arr[j+1];\\n            \\n            // remove minimum one from that two consecutive number\\n            if(arr[j] > arr[j+1]) arr.erase(arr.begin() + j + 1);\\n            else arr.erase(arr.begin() + j);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        //if(arr.size() == 2) return arr[0]*arr[1];\\n        int sum = 0;\\n        while(arr.size() != 1){\\n            int i = 1,j = 0;\\n            \\n            for(i;i < arr.size()-1;i++)      // find minimum product of two consecutive number\\n                if(arr[i]*arr[i + 1] < arr[j]*arr[j + 1]) \\n                    j = i;\\n            \\n            sum += arr[j]*arr[j+1];\\n            \\n            // remove minimum one from that two consecutive number\\n            if(arr[j] > arr[j+1]) arr.erase(arr.begin() + j + 1);\\n            else arr.erase(arr.begin() + j);\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 753817,
                "title": "simple-easy-to-understand",
                "content": "```\\nans = 0\\nwhile len(arr) > 1:\\n\\t# Find the consecutive pair of leaves j and j+1 with the smallest product\\n\\tj = 0\\n\\tfor i in range(1, len(arr)-1):\\n\\t\\tif arr[i]*arr[i+1] < arr[j]*arr[j+1]:\\n\\t\\t\\tj = i\\n\\tans += arr[j]*arr[j+1]\\n\\n\\t# Remove the largest of j and j+1 from arr\\n\\tarr = arr[:j] + [max(arr[j], arr[j+1])] + arr[j+2:]\\n\\nreturn ans\\n```",
                "solutionTags": [],
                "code": "```\\nans = 0\\nwhile len(arr) > 1:\\n\\t# Find the consecutive pair of leaves j and j+1 with the smallest product\\n\\tj = 0\\n\\tfor i in range(1, len(arr)-1):\\n\\t\\tif arr[i]*arr[i+1] < arr[j]*arr[j+1]:\\n\\t\\t\\tj = i\\n\\tans += arr[j]*arr[j+1]\\n\\n\\t# Remove the largest of j and j+1 from arr\\n\\tarr = arr[:j] + [max(arr[j], arr[j+1])] + arr[j+2:]\\n\\nreturn ans\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 679197,
                "title": "summary-of-the-3-main-solutions-concise-yet-clear-python",
                "content": "Code and commentary adapted from [Summary of all the solutions I have learned from Discuss in Python](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/478708/RZ-Summary-of-all-the-solutions-I-have-learned-from-Discuss-in-Python). Please refer to that or [Summary and reasoning of different solutions](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340489/Summary-and-reasoning-of-different-solutions) for full explanation.\\n\\nConcise overview written mainly for my future review\\n\\n```\\nclass Solution:\\n    def mctFromLeafValues_DP(self, arr: List[int]) -> int:\\n        \"\"\"\\n        We split subtrees by splitting the list, since it\\'s given as in-order traversal\\n        DP, O(N^3) time, O(N^2) space\\n        \"\"\"\\n        @lru_cache(None)\\n        def dp(l, r):\\n            if l + 1 >= r:  # base case: only one value = leaf\\n                return 0    # leaf only contribs value to rootVal\\n            ans = float(\\'inf\\')\\n            for j in range(l+1, r): # for each split (start of second array)\\n                rootVal = max(arr[l:j]) * max(arr[j:r])\\n                ans = min(ans, rootVal + dp(l,j) + dp(j, r))\\n            return ans\\t# solution for the arr[l:r] subtree\\n        return dp(0, len(arr))\\n\\n    def mctFromLeafValues_Greedy(self, arr: List[int]) -> int:\\n        \"\"\"\\n        We want the smallest values to be deepest in the tree (so they are used most, as they led to smaller parent values).\\n        Greedy, O(N^2)\\n        \"\"\"\\n        res = 0\\n        # While pairs are left, use the smallest-val index & smallest neighbor\\n        while len(arr) > 1:\\n            ind = arr.index(min(arr))\\n            if ind == 0:\\n\\t\\t\\t\\tres += arr[ind] * arr[ind+1]\\t# edge case\\n            elif ind == len(arr)-1:\\n\\t\\t\\t\\tres += arr[ind] * arr[ind-1]\\t# edge case\\n            else:\\n\\t\\t\\t\\tres += arr[ind] * min(arr[ind+1], arr[ind-1])\\n            arr.pop(ind) \\n        return res\\n      \\n    def mctFromLeafValues_MonotonicStack(self, arr: List[int]) -> int:\\n        \"\"\"\\n        Instead of repeatedly finding the smallest element index, we can use a stack -- time: O(N), space: O(N)\\n        \"\"\"\\n        res = 0\\n        st = [float(\\'inf\\')]\\n        # While pairs are left, use the smallest-val index & smallest neighbor\\n        for num in arr:\\n            while st and num >= st[-1]: # remove all local minimums\\n                res += st.pop() * min(st[-1], num)\\n            st.append(num)\\n        while len(st) > 2:\\n            res += st.pop() * st[-1]\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues_DP(self, arr: List[int]) -> int:\\n        \"\"\"\\n        We split subtrees by splitting the list, since it\\'s given as in-order traversal\\n        DP, O(N^3) time, O(N^2) space\\n        \"\"\"\\n        @lru_cache(None)\\n        def dp(l, r):\\n            if l + 1 >= r:  # base case: only one value = leaf\\n                return 0    # leaf only contribs value to rootVal\\n            ans = float(\\'inf\\')\\n            for j in range(l+1, r): # for each split (start of second array)\\n                rootVal = max(arr[l:j]) * max(arr[j:r])\\n                ans = min(ans, rootVal + dp(l,j) + dp(j, r))\\n            return ans\\t# solution for the arr[l:r] subtree\\n        return dp(0, len(arr))\\n\\n    def mctFromLeafValues_Greedy(self, arr: List[int]) -> int:\\n        \"\"\"\\n        We want the smallest values to be deepest in the tree (so they are used most, as they led to smaller parent values).\\n        Greedy, O(N^2)\\n        \"\"\"\\n        res = 0\\n        # While pairs are left, use the smallest-val index & smallest neighbor\\n        while len(arr) > 1:\\n            ind = arr.index(min(arr))\\n            if ind == 0:\\n\\t\\t\\t\\tres += arr[ind] * arr[ind+1]\\t# edge case\\n            elif ind == len(arr)-1:\\n\\t\\t\\t\\tres += arr[ind] * arr[ind-1]\\t# edge case\\n            else:\\n\\t\\t\\t\\tres += arr[ind] * min(arr[ind+1], arr[ind-1])\\n            arr.pop(ind) \\n        return res\\n      \\n    def mctFromLeafValues_MonotonicStack(self, arr: List[int]) -> int:\\n        \"\"\"\\n        Instead of repeatedly finding the smallest element index, we can use a stack -- time: O(N), space: O(N)\\n        \"\"\"\\n        res = 0\\n        st = [float(\\'inf\\')]\\n        # While pairs are left, use the smallest-val index & smallest neighbor\\n        for num in arr:\\n            while st and num >= st[-1]: # remove all local minimums\\n                res += st.pop() * min(st[-1], num)\\n            st.append(num)\\n        while len(st) > 2:\\n            res += st.pop() * st[-1]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 654858,
                "title": "c-concise-greedy-approach",
                "content": "Greedy approach- Always choose those 2 leaf nodes that forms the smallest parent node.\\nThe smaller node of the two chosen leaf nodes is erased  \\n\\nclass Solution {\\npublic:\\n\\n    int mctFromLeafValues(vector<int>& arr) {\\n      int sum=0;\\n      while(arr.size()>=2)\\n      {\\n          int minproduct=INT_MAX;int pos;\\n          for(int i=0;i<arr.size()-1;i++)\\n          {\\n              if(arr[i]*arr[i+1]<minproduct)\\n              {\\n                  pos=i;\\n                  minproduct=arr[i]*arr[i+1];\\n              }\\n          }\\n          sum+=minproduct;\\n          if(arr[pos]<arr[pos+1]) arr.erase(arr.begin()+pos);\\n          else arr.erase(arr.begin()+(pos+1));\\n      }\\n    return sum;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int mctFromLeafValues(vector<int>& arr) {\\n      int sum=0;\\n      while(arr.size()>=2)\\n      {\\n          int minproduct=INT_MAX;int pos;\\n          for(int i=0;i<arr.size()-1;i++)\\n          {\\n              if(arr[i]*arr[i+1]<minproduct)\\n              {\\n                  pos=i;\\n                  minproduct=arr[i]*arr[i+1];\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 640213,
                "title": "c-dp-solution-similar-to-matrix-chain-multiplication",
                "content": "```\\nclass Solution {\\n    vector<vector<int>>maxi;\\n    vector<vector<int>>dp;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) { \\n        int n = arr.size();\\n        maxi.resize(n, vector<int>(n));\\n        dp.resize(n, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < n; i++) {\\n            maxi[i][i] = arr[i];\\n            for (int j = i+1; j < n; j++) {\\n                maxi[i][j] = max(maxi[i][j-1], arr[j]);\\n            }\\n        }\\n        \\n        for (int L = 1; L < n; L++) {\\n            for (int i = 0; i+L < n; i++) {\\n                int j = i+L;\\n                if (L == 1) {\\n                    dp[i][j] = arr[i]*arr[j];\\n                } else {\\n                    dp[i][j] = INT_MAX;\\n                    for (int k = i; k < j; k++) {\\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxi[i][k]*maxi[k+1][j]);    \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n-1];\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<vector<int>>maxi;\\n    vector<vector<int>>dp;\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) { \\n        int n = arr.size();\\n        maxi.resize(n, vector<int>(n));\\n        dp.resize(n, vector<int>(n, 0));\\n        \\n        for (int i = 0; i < n; i++) {\\n            maxi[i][i] = arr[i];\\n            for (int j = i+1; j < n; j++) {\\n                maxi[i][j] = max(maxi[i][j-1], arr[j]);\\n            }\\n        }\\n        \\n        for (int L = 1; L < n; L++) {\\n            for (int i = 0; i+L < n; i++) {\\n                int j = i+L;\\n                if (L == 1) {\\n                    dp[i][j] = arr[i]*arr[j];\\n                } else {\\n                    dp[i][j] = INT_MAX;\\n                    for (int k = i; k < j; k++) {\\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j] + maxi[i][k]*maxi[k+1][j]);    \\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dp[0][n-1];\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631202,
                "title": "python-dynamic-programming-matrix-chain-multiplication-easy-to-understand",
                "content": "```py\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        # Using matrix-chain-multiplication technique\\n        \\'\\'\\'\\n        Looking at the problem, Matrix-Chain-Multiplication was the first thing that came to my mind\\n        Here, I\\'ve tried a bottom-up approach of matrix-chain-multiplication, so follow along\\n        (Not the best structured explanation though)\\n        \\n        So, the sub-problem can be stated as:\\n        \\n          D(i: j) = minimum of { D(i: k) + D(k+1: j) + maximum_value(i: k) * maximum_value(k+1: j) for k in [i, j-1] }\\n          \\n          where D(i: j) is the optimal (minimum) sum of products of maximum leaf values (:\\\\) between i and j.\\n          \\n          and maximum_valud(i: j) = maximum of { maximum_value(i:j-1), arr[j]}\\n          \\n        If it went over your head, I don\\'t know an easier way to explain.\\n        \\n        I\\'ve build a 2D matrix, such that each cell stores the value\\n          \\n             dp[i][j] = (D(i:j), maximum_value(i:j))\\n        \\n        Now, code follows\\n        \\'\\'\\'\\n        \\n        dp = [[0 for i in range(len(arr))] for j in range(len(arr))]\\n        \\n        for i in range(len(arr)):\\n            dp[i][i] = (0, arr[i])\\n        \\n        # Refer to matrix-chain-multiplication (common structure)\\n        for v in range(1,len(arr)):\\n            for j in range(v, len(arr)):\\n                i = j - v\\n                D_i_j = min(dp[i][k][0] + dp[k+1][j][0] + dp[i][k][1] * dp[k+1][j][1] for k in range(i, j))\\n                M_i_j = max(dp[i][j-1][1], arr[j])\\n                \\n                dp[i][j] = (D_i_j, M_i_j)\\n        \\n        return dp[0][len(arr)-1][0]\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```py\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        # Using matrix-chain-multiplication technique\\n        \\'\\'\\'\\n        Looking at the problem, Matrix-Chain-Multiplication was the first thing that came to my mind\\n        Here, I\\'ve tried a bottom-up approach of matrix-chain-multiplication, so follow along\\n        (Not the best structured explanation though)\\n        \\n        So, the sub-problem can be stated as:\\n        \\n          D(i: j) = minimum of { D(i: k) + D(k+1: j) + maximum_value(i: k) * maximum_value(k+1: j) for k in [i, j-1] }\\n          \\n          where D(i: j) is the optimal (minimum) sum of products of maximum leaf values (:\\\\) between i and j.\\n          \\n          and maximum_valud(i: j) = maximum of { maximum_value(i:j-1), arr[j]}\\n          \\n        If it went over your head, I don\\'t know an easier way to explain.\\n        \\n        I\\'ve build a 2D matrix, such that each cell stores the value\\n          \\n             dp[i][j] = (D(i:j), maximum_value(i:j))\\n        \\n        Now, code follows\\n        \\'\\'\\'\\n        \\n        dp = [[0 for i in range(len(arr))] for j in range(len(arr))]\\n        \\n        for i in range(len(arr)):\\n            dp[i][i] = (0, arr[i])\\n        \\n        # Refer to matrix-chain-multiplication (common structure)\\n        for v in range(1,len(arr)):\\n            for j in range(v, len(arr)):\\n                i = j - v\\n                D_i_j = min(dp[i][k][0] + dp[k+1][j][0] + dp[i][k][1] * dp[k+1][j][1] for k in range(i, j))\\n                M_i_j = max(dp[i][j-1][1], arr[j])\\n                \\n                dp[i][j] = (D_i_j, M_i_j)\\n        \\n        return dp[0][len(arr)-1][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631105,
                "title": "javascript-solution",
                "content": "```\\nvar mctFromLeafValues = function(arr) {\\n  const dp = [];\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    dp[i] = [];\\n  }\\n  \\n  return treeBuilder(0, arr.length - 1);\\n  \\n  function treeBuilder(start, end) {\\n    \\n    if (start == end) {\\n      return 0;\\n    }\\n  \\n    if (dp[start][end]) {\\n      return dp[start][end];\\n    }\\n    \\n    let min = Number.MAX_VALUE;\\n    \\n    for (let i = start; i < end; i++) {\\n      const left = treeBuilder(start, i);\\n      const right = treeBuilder(i + 1, end);\\n      \\n      const maxLeft = Math.max(...arr.slice(start, i + 1));\\n      const maxRight = Math.max(...arr.slice(i + 1, end + 1));\\n       \\n      const rootVal = maxLeft * maxRight;\\n      \\n      min = Math.min(min, rootVal + left + right);\\n\\n    }\\n    \\n    dp[start][end] = min;\\n    return min;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nvar mctFromLeafValues = function(arr) {\\n  const dp = [];\\n\\n  for (let i = 0; i < arr.length; i++) {\\n    dp[i] = [];\\n  }\\n  \\n  return treeBuilder(0, arr.length - 1);\\n  \\n  function treeBuilder(start, end) {\\n    \\n    if (start == end) {\\n      return 0;\\n    }\\n  \\n    if (dp[start][end]) {\\n      return dp[start][end];\\n    }\\n    \\n    let min = Number.MAX_VALUE;\\n    \\n    for (let i = start; i < end; i++) {\\n      const left = treeBuilder(start, i);\\n      const right = treeBuilder(i + 1, end);\\n      \\n      const maxLeft = Math.max(...arr.slice(start, i + 1));\\n      const maxRight = Math.max(...arr.slice(i + 1, end + 1));\\n       \\n      const rootVal = maxLeft * maxRight;\\n      \\n      min = Math.min(min, rootVal + left + right);\\n\\n    }\\n    \\n    dp[start][end] = min;\\n    return min;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 628771,
                "title": "interview-dynamic-programming-or-greedy-algorithm-o-n-3-o-n-2-o-n-explanation",
                "content": "Approach - 1\\nUsing Dynamic Programming and Considering all possiblites.\\nTime Complexity = O(Len ^ 3)         Space Complexity = O(Len ^ 2)\\n```\\npublic int mctFromLeafValues(int[] arr) {\\n                if(arr==null || arr.length==0)return Integer.MIN_VALUE; // This is not possible as mentioned in constraints\\n                int[][] Maximum_Matrix=new int[arr.length][arr.length];// This will store the maximum value in array range from i-->j (both included)\\n                int[][] DP=new int[arr.length][arr.length];// This will store the answer to sub-problem (Remember if we are trying to partition the arr with a single leaf node on one side then its contribution would be 0)\\n                //Populating the Maximum_Matrix from arr\\n                for(int i=0;i<arr.length;i++){\\n                    int max=arr[i];\\n                    for(int j=i;j<arr.length;j++){\\n                        if(max<arr[j])\\n                            max=arr[j];\\n                        Maximum_Matrix[i][j]=max;\\n                    }\\n                }\\n                if(DEBUG){\\n                    for(int i=0;i<arr.length;i++){\\n                        for(int j=0;j<arr.length;j++){\\n                            System.out.print(Maximum_Matrix[i][j]+ \" \");\\n                        }\\n                        System.out.println();\\n                    }\\n                }\\n                // Populating the DP matrix from smaller sub-problems already evaluated and stored in dp arr\\n                // I am populating the DP matrix from principal diagonal towards the right top edge of the matrix\\n                // The principal value of DP matrix is 0 because I can\\'t make internal node out of it\\n                int i,j,Row=0,Col=1;    // Minimum 2 elements are present in the arr is ensured\\n                int iterations=(arr.length-1);  // populating all the diagonals just after principal diagonal\\n\\n                while(iterations!=0){\\n                    i=Row;j=Col;    // Starting diagnol type traversal from Row , Col\\n                    while ( (i!=arr.length) && (j!=arr.length) ){\\n                        int min_sum=Integer.MAX_VALUE;  // This is minimum possible sum of internal nodes\\n                        for(int partition=i;partition<j;partition++){   // This loop considers all partitions possible without making one side as null\\n                            // This is computing the so formed root node using maximum from left and right sub-trees respective maximum\\n                            // I already know the internal nodes in left subtree is DP[i][partition] and right subtree is DP[partition+1][j]\\n                            // justing adding the root node to left sub tree internal sum and right sub tree internal sum would give me sum for this sub-problem\\n                            int curr_sum=Maximum_Matrix[i][partition]*Maximum_Matrix[partition+1][j] + DP[i][partition] + DP[partition+1][j];\\n                            if(min_sum>curr_sum)\\n                                min_sum=curr_sum;\\n                        }\\n                        DP[i][j]=min_sum;\\n\\n                        i++;\\n                        j++;\\n                    }\\n                    Col++;\\n                    iterations--;\\n                }\\n\\n\\n                return DP[0][arr.length-1];\\n    }\\n```\\n\\n Approach-2\\nUsing Greedy Technique of picking pair with smallest possible product and deleting the smaller element amoung that and using bigger one for further product.\\n\\n```\\n// TC is O(N^2)  SC is O(1)\\n    // The innermost while loops will run atmost 40 times in the worst case and could be ignored in this case **Better Alternative could be -->** You can use doubly linkedlist where you can delete smaller element in O(1) time and no need of skipping values\\n    public int mctFromLeafValues_Optimized(int[] arr) {\\n        if(arr==null || arr.length==0)return Integer.MAX_VALUE; // This is not possible as mentioned in constraints\\n        if(arr.length==1)return Integer.MAX_VALUE;\\n        int num_of_elements=arr.length;\\n        int cost=0;\\n        while(num_of_elements>1){\\n            int i=0,j=0;\\n            int min_index=0;\\n            int min_prod=Integer.MAX_VALUE;\\n            for(int k=0;k<num_of_elements-1;k++){\\n                if(i==j){\\n                    j++;\\n                }\\n                while(arr[i]==Integer.MAX_VALUE)            // This while loop is for skipping already deleted nodes    (These would not be there if you are using linkedlist implementation)\\n                    i++;\\n                while(arr[j]==Integer.MAX_VALUE || (i==j))  // This while loop is for skipping already deleted nodes.\\n                    j++;\\n                if(min_prod>(arr[i]*arr[j]) ){\\n                    min_prod=(arr[i]*arr[j]);\\n                    min_index=((arr[i]<arr[j])?i:j);\\n                }\\n                i=i+1;\\n                j=i+1;\\n            }\\n            cost+=min_prod;\\n            arr[min_index]=Integer.MAX_VALUE;\\n            num_of_elements--;\\n        }\\n        return cost;\\n    }\\n```\\nApproach-3\\nUsing stack\\n\\n This solution is very tricky\\n    *   References\\n    *   https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n    *   I am just trying to give an explanation for better understanding of the above code.\\n \\n```\\npublic int mctFromLeafValues_Most_Optimized(int[] A) {\\n        int res = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);  // This is just a sentinal value to avoid keep checking the stack emptiness condition (Using this he is ensuring himself that no matter what stack would never be empty)\\n        for (int a : A) {\\n            while (stack.peek() <= a) {\\n                int mid = stack.pop();// This is just like picking the smallest element\\n                res += mid * Math.min(stack.peek(), a);// since current element is >=top implies the second min element could either be the element present in the top of the stack or incoming array element.\\n            }\\n            stack.push(a);// Doing similer to next greater element problem in which stack with descending values is maintained.\\n        }\\n        while (stack.size() > 2) {\\n            res += stack.pop() * stack.peek();//Just doing last pass in case some elements are still no processed i:e we have delayed their processing by putting them into stack\\n        }\\n        return res;\\n    }\\n```\\nThank you and have a nice day :)",
                "solutionTags": [],
                "code": "```\\npublic int mctFromLeafValues(int[] arr) {\\n                if(arr==null || arr.length==0)return Integer.MIN_VALUE; // This is not possible as mentioned in constraints\\n                int[][] Maximum_Matrix=new int[arr.length][arr.length];// This will store the maximum value in array range from i-->j (both included)\\n                int[][] DP=new int[arr.length][arr.length];// This will store the answer to sub-problem (Remember if we are trying to partition the arr with a single leaf node on one side then its contribution would be 0)\\n                //Populating the Maximum_Matrix from arr\\n                for(int i=0;i<arr.length;i++){\\n                    int max=arr[i];\\n                    for(int j=i;j<arr.length;j++){\\n                        if(max<arr[j])\\n                            max=arr[j];\\n                        Maximum_Matrix[i][j]=max;\\n                    }\\n                }\\n                if(DEBUG){\\n                    for(int i=0;i<arr.length;i++){\\n                        for(int j=0;j<arr.length;j++){\\n                            System.out.print(Maximum_Matrix[i][j]+ \" \");\\n                        }\\n                        System.out.println();\\n                    }\\n                }\\n                // Populating the DP matrix from smaller sub-problems already evaluated and stored in dp arr\\n                // I am populating the DP matrix from principal diagonal towards the right top edge of the matrix\\n                // The principal value of DP matrix is 0 because I can\\'t make internal node out of it\\n                int i,j,Row=0,Col=1;    // Minimum 2 elements are present in the arr is ensured\\n                int iterations=(arr.length-1);  // populating all the diagonals just after principal diagonal\\n\\n                while(iterations!=0){\\n                    i=Row;j=Col;    // Starting diagnol type traversal from Row , Col\\n                    while ( (i!=arr.length) && (j!=arr.length) ){\\n                        int min_sum=Integer.MAX_VALUE;  // This is minimum possible sum of internal nodes\\n                        for(int partition=i;partition<j;partition++){   // This loop considers all partitions possible without making one side as null\\n                            // This is computing the so formed root node using maximum from left and right sub-trees respective maximum\\n                            // I already know the internal nodes in left subtree is DP[i][partition] and right subtree is DP[partition+1][j]\\n                            // justing adding the root node to left sub tree internal sum and right sub tree internal sum would give me sum for this sub-problem\\n                            int curr_sum=Maximum_Matrix[i][partition]*Maximum_Matrix[partition+1][j] + DP[i][partition] + DP[partition+1][j];\\n                            if(min_sum>curr_sum)\\n                                min_sum=curr_sum;\\n                        }\\n                        DP[i][j]=min_sum;\\n\\n                        i++;\\n                        j++;\\n                    }\\n                    Col++;\\n                    iterations--;\\n                }\\n\\n\\n                return DP[0][arr.length-1];\\n    }\\n```\n```\\n// TC is O(N^2)  SC is O(1)\\n    // The innermost while loops will run atmost 40 times in the worst case and could be ignored in this case **Better Alternative could be -->** You can use doubly linkedlist where you can delete smaller element in O(1) time and no need of skipping values\\n    public int mctFromLeafValues_Optimized(int[] arr) {\\n        if(arr==null || arr.length==0)return Integer.MAX_VALUE; // This is not possible as mentioned in constraints\\n        if(arr.length==1)return Integer.MAX_VALUE;\\n        int num_of_elements=arr.length;\\n        int cost=0;\\n        while(num_of_elements>1){\\n            int i=0,j=0;\\n            int min_index=0;\\n            int min_prod=Integer.MAX_VALUE;\\n            for(int k=0;k<num_of_elements-1;k++){\\n                if(i==j){\\n                    j++;\\n                }\\n                while(arr[i]==Integer.MAX_VALUE)            // This while loop is for skipping already deleted nodes    (These would not be there if you are using linkedlist implementation)\\n                    i++;\\n                while(arr[j]==Integer.MAX_VALUE || (i==j))  // This while loop is for skipping already deleted nodes.\\n                    j++;\\n                if(min_prod>(arr[i]*arr[j]) ){\\n                    min_prod=(arr[i]*arr[j]);\\n                    min_index=((arr[i]<arr[j])?i:j);\\n                }\\n                i=i+1;\\n                j=i+1;\\n            }\\n            cost+=min_prod;\\n            arr[min_index]=Integer.MAX_VALUE;\\n            num_of_elements--;\\n        }\\n        return cost;\\n    }\\n```\n```\\npublic int mctFromLeafValues_Most_Optimized(int[] A) {\\n        int res = 0;\\n        Stack<Integer> stack = new Stack<>();\\n        stack.push(Integer.MAX_VALUE);  // This is just a sentinal value to avoid keep checking the stack emptiness condition (Using this he is ensuring himself that no matter what stack would never be empty)\\n        for (int a : A) {\\n            while (stack.peek() <= a) {\\n                int mid = stack.pop();// This is just like picking the smallest element\\n                res += mid * Math.min(stack.peek(), a);// since current element is >=top implies the second min element could either be the element present in the top of the stack or incoming array element.\\n            }\\n            stack.push(a);// Doing similer to next greater element problem in which stack with descending values is maintained.\\n        }\\n        while (stack.size() > 2) {\\n            res += stack.pop() * stack.peek();//Just doing last pass in case some elements are still no processed i:e we have delayed their processing by putting them into stack\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 569818,
                "title": "c-simple-greedy-solution-with-100-run-time",
                "content": "\\n```\\nint mctFromLeafValues(vector<int>& A) {\\n  int ans = 0;\\n  while(A.size() > 1) {\\n\\tint best_leaves_to_connect = INT_MAX, to_be_removed = -1;\\n\\tfor(int i = 1; i < A.size(); i++) {\\n\\t\\tint cost_of_two_leaves = A[i] * A[i-1];\\n\\t\\tif(cost_of_two_leaves < best_leaves_to_connect) {\\n\\t\\t\\tbest_leaves_to_connect = cost_of_two_leaves;\\n\\t\\t\\tto_be_removed = A[i] < A[i-1] ? i : i-1;\\n\\t\\t}\\n\\t}\\n\\tA.erase(A.begin() + to_be_removed);\\n\\tans = ans + best_leaves_to_connect;\\n  }\\n return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint mctFromLeafValues(vector<int>& A) {\\n  int ans = 0;\\n  while(A.size() > 1) {\\n\\tint best_leaves_to_connect = INT_MAX, to_be_removed = -1;\\n\\tfor(int i = 1; i < A.size(); i++) {\\n\\t\\tint cost_of_two_leaves = A[i] * A[i-1];\\n\\t\\tif(cost_of_two_leaves < best_leaves_to_connect) {\\n\\t\\t\\tbest_leaves_to_connect = cost_of_two_leaves;\\n\\t\\t\\tto_be_removed = A[i] < A[i-1] ? i : i-1;\\n\\t\\t}\\n\\t}\\n\\tA.erase(A.begin() + to_be_removed);\\n\\tans = ans + best_leaves_to_connect;\\n  }\\n return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 565541,
                "title": "bottom-up-python-dp-solution",
                "content": "Since I couldn\\'t find it anywhere, here is my bottom up DP solution:\\nN^2 time, N^2 space \\n\\nI worked backwards from this solution: https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340033/C%2B%2B-with-comments. Starting from the end of the array and building the tree up by increasing the interval size by decrementing L. Then start R at L + 1 to build references of that side of the subtree, that will be used later as R approaches N - 1.\\n\\n\\n\\tdef mctFromLeafValues(self, A):\\n\\n\\t\\t# bottom up dp solution\\n\\n\\t\\tN = len(A)\\n\\t\\tmaxi = [[0 for _ in range(N)] for __ in range(N)]\\n\\t\\tdp = [[0 for _ in range(N)] for __ in range(N)]\\n\\n\\t\\t# get the max in each interval\\n\\t\\tfor i in range(N):\\n\\t\\t\\tmaxi[i][i] = A[i]\\n\\t\\t\\tfor j in range(i + 1, N):\\n\\t\\t\\t\\tmaxi[i][j] = max(maxi[i][j-1], A[j])\\n\\n\\t\\tfor left in range(N - 2, -1, -1):\\n\\t\\t\\tfor right in range(left + 1, N):\\n\\t\\t\\t\\tdp[left][right] = float(\\'inf\\')\\n\\t\\t\\t\\tfor i in range(left, right):   # i represents the current interval subproblem\\n\\t\\t\\t\\t\\tdp[left][right] = min(dp[left][right], maxi[left][i] * maxi[i + 1][right] + dp[left][i] + dp[i + 1][right])\\n\\n\\t\\treturn dp[0][N-1]\\n\\t\\t\\nI\\'ll throw in my top-down as well to show where I started from. \\n\\n\\tdef mctFromLeafValues(self, A):\\n\\t\\n\\t\\tN = len(A)\\n\\t\\tmaxi = [[0 for _ in range(N)] for __ in range(N)]\\n        memo = {}\\n        return self.dp(0, N - 1, maxi, memo)\\n        \\n    def dp(self, left, right, maxi, memo):\\n        if (left, right) in memo: return memo[(left, right)]\\n        if left == right: return 0\\n        \\n        ans = float(\\'inf\\')\\n        \\n        for i in range(left, right):\\n            ans = min(ans, maxi[left][i] * maxi[i + 1][right] + self.dp(left, i, maxi, memo) + self.dp(i + 1, right, maxi, memo))\\n        \\n        memo[(left, right)] = ans\\n        return ans\\n\\t\\t\\nI was actually first trying to follow the example dynamic programming pattern from this post:\\nhttps://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns/439810#Merging-Intervals\\nBut the solution didn\\'t make sense to me. If anyone can explain that one I would greatly appreciate it. Not sure how he gets the answer by starting left at 1, rather than at the end like I have.",
                "solutionTags": [],
                "code": "Since I couldn\\'t find it anywhere, here is my bottom up DP solution:\\nN^2 time, N^2 space \\n\\nI worked backwards from this solution: https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340033/C%2B%2B-with-comments. Starting from the end of the array and building the tree up by increasing the interval size by decrementing L. Then start R at L + 1 to build references of that side of the subtree, that will be used later as R approaches N - 1.\\n\\n\\n\\tdef mctFromLeafValues(self, A):\\n\\n\\t\\t# bottom up dp solution\\n\\n\\t\\tN = len(A)\\n\\t\\tmaxi = [[0 for _ in range(N)] for __ in range(N)]\\n\\t\\tdp = [[0 for _ in range(N)] for __ in range(N)]\\n\\n\\t\\t# get the max in each interval\\n\\t\\tfor i in range(N):\\n\\t\\t\\tmaxi[i][i] = A[i]\\n\\t\\t\\tfor j in range(i + 1, N):\\n\\t\\t\\t\\tmaxi[i][j] = max(maxi[i][j-1], A[j])\\n\\n\\t\\tfor left in range(N - 2, -1, -1):\\n\\t\\t\\tfor right in range(left + 1, N):\\n\\t\\t\\t\\tdp[left][right] = float(\\'inf\\')\\n\\t\\t\\t\\tfor i in range(left, right):   # i represents the current interval subproblem\\n\\t\\t\\t\\t\\tdp[left][right] = min(dp[left][right], maxi[left][i] * maxi[i + 1][right] + dp[left][i] + dp[i + 1][right])\\n\\n\\t\\treturn dp[0][N-1]\\n\\t\\t\\nI\\'ll throw in my top-down as well to show where I started from. \\n\\n\\tdef mctFromLeafValues(self, A):\\n\\t\\n\\t\\tN = len(A)\\n\\t\\tmaxi = [[0 for _ in range(N)] for __ in range(N)]\\n        memo = {}\\n        return self.dp(0, N - 1, maxi, memo)\\n        \\n    def dp(self, left, right, maxi, memo):\\n        if (left, right) in memo: return memo[(left, right)]\\n        if left == right: return 0\\n        \\n        ans = float(\\'inf\\')\\n        \\n        for i in range(left, right):\\n            ans = min(ans, maxi[left][i] * maxi[i + 1][right] + self.dp(left, i, maxi, memo) + self.dp(i + 1, right, maxi, memo))\\n        \\n        memo[(left, right)] = ans\\n        return ans\\n\\t\\t\\nI was actually first trying to follow the example dynamic programming pattern from this post:\\nhttps://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns/439810#Merging-Intervals\\nBut the solution didn\\'t make sense to me. If anyone can explain that one I would greatly appreciate it. Not sure how he gets the answer by starting left at 1, rather than at the end like I have.",
                "codeTag": "Python3"
            },
            {
                "id": 517398,
                "title": "c-100-100",
                "content": "Premise: Want the biggest leaves to be connected as close to the root as possible to mitigate propagation of their values through multiplication into subsequent sums above them in the tree. Use a vector to keep track of available connection points (at the beginning, just the leaves) and iteratively connect the points (leaf and leaf, leaf and node, reducing size of vector) until the root is reached. At each iteration, connect the two adjacent connecting points that produce the smallest value to minimize propagation--add the product of the two values and replace them with the value of the greatest leaf.\\n\\n```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        while (arr.size() > 1){\\n            int p1 = 0, p2 = 1;\\n            int minprod = arr[p1]*arr[p2];\\n            for (int i = 2; i < arr.size(); i++){\\n                if (arr[i]*arr[i-1] < minprod){\\n                    minprod = arr[i]*arr[i-1];\\n                    p1 = i-1;\\n                    p2 = i;\\n                }\\n            }\\n            sum += minprod;\\n            int bigleaf = max(arr[p1],arr[p2]);\\n            if (bigleaf == arr[p1]){\\n                arr.erase(arr.begin()+p2);\\n            } else {\\n                arr.erase(arr.begin()+p1);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        while (arr.size() > 1){\\n            int p1 = 0, p2 = 1;\\n            int minprod = arr[p1]*arr[p2];\\n            for (int i = 2; i < arr.size(); i++){\\n                if (arr[i]*arr[i-1] < minprod){\\n                    minprod = arr[i]*arr[i-1];\\n                    p1 = i-1;\\n                    p2 = i;\\n                }\\n            }\\n            sum += minprod;\\n            int bigleaf = max(arr[p1],arr[p2]);\\n            if (bigleaf == arr[p1]){\\n                arr.erase(arr.begin()+p2);\\n            } else {\\n                arr.erase(arr.begin()+p1);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 515512,
                "title": "java-easy-understand-dp-and-recursive-solution",
                "content": "Recursion approach (Time limit ):\\n```\\n\\t\\tpublic int mctFromLeafValues(int[] arr) {\\n\\t\\t\\treturn helper(arr, 0, arr.length - 1);\\n\\t\\t}\\n    \\n\\t    public int helper(int[] arr, int start, int end) {\\n\\t\\t\\tif (start == end) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint interval = end - start;\\n\\t\\t\\tint count = Integer.MAX_VALUE;\\n\\n\\t\\t\\tfor (int i = 0; i < interval; i++) {\\n\\t\\t\\t\\tint countLeft = helper(arr, start, start + i);\\n\\t\\t\\t\\tint countRight = helper(arr, start + i + 1, end);\\n\\t\\t\\t\\tint curMax = getMax(arr, start, start + i) * getMax(arr, start + i + 1, end);\\n\\n\\t\\t\\t\\tcount = Math.min(countLeft + countRight + curMax, count);\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n   \\n    public int getMax(int[] arr, int start, int end) {\\n        if (start == end) {\\n            return arr[start];\\n        }\\n        \\n        int maxV = Integer.MIN_VALUE;\\n        for (int i = start; i <= end; i++) {\\n            maxV = Math.max(maxV, arr[i]);\\n        }\\n        \\n        return maxV;\\n    }\\n```\\n\\nDP Solution:\\n\\n```\\npublic int mctFromLeafValues(int[] arr) {\\n        int[][] dp = new int[arr.length][arr.length];\\n        \\n        return dpHelper(arr, 0, arr.length - 1, dp);\\n    }\\n    \\n    public int dpHelper(int[] arr, int start, int end, int[][] dp) {\\n        if (start == end) {\\n            return 0;\\n        }\\n        if (dp[start][end] != 0) {\\n            return dp[start][end];\\n        }\\n        \\n        int interval = end - start;\\n        int count = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < interval; i++) {\\n            int countLeft = dpHelper(arr, start, start + i, dp);\\n            int countRight = dpHelper(arr, start + i + 1, end, dp);\\n            int curMax = getMax(arr, start, start + i) * getMax(arr, start + i + 1, end);\\n            \\n            count = Math.min(countLeft + countRight + curMax, count);\\n        }\\n        \\n        dp[start][end] = count;\\n        return count;\\n    }\\n    \\n    public int getMax(int[] arr, int start, int end) {\\n        if (start == end) {\\n            return arr[start];\\n        }\\n        \\n        int maxV = Integer.MIN_VALUE;\\n        for (int i = start; i <= end; i++) {\\n            maxV = Math.max(maxV, arr[i]);\\n        }\\n        \\n        return maxV;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tpublic int mctFromLeafValues(int[] arr) {\\n\\t\\t\\treturn helper(arr, 0, arr.length - 1);\\n\\t\\t}\\n    \\n\\t    public int helper(int[] arr, int start, int end) {\\n\\t\\t\\tif (start == end) {\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint interval = end - start;\\n\\t\\t\\tint count = Integer.MAX_VALUE;\\n\\n\\t\\t\\tfor (int i = 0; i < interval; i++) {\\n\\t\\t\\t\\tint countLeft = helper(arr, start, start + i);\\n\\t\\t\\t\\tint countRight = helper(arr, start + i + 1, end);\\n\\t\\t\\t\\tint curMax = getMax(arr, start, start + i) * getMax(arr, start + i + 1, end);\\n\\n\\t\\t\\t\\tcount = Math.min(countLeft + countRight + curMax, count);\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n   \\n    public int getMax(int[] arr, int start, int end) {\\n        if (start == end) {\\n            return arr[start];\\n        }\\n        \\n        int maxV = Integer.MIN_VALUE;\\n        for (int i = start; i <= end; i++) {\\n            maxV = Math.max(maxV, arr[i]);\\n        }\\n        \\n        return maxV;\\n    }\\n```\n```\\npublic int mctFromLeafValues(int[] arr) {\\n        int[][] dp = new int[arr.length][arr.length];\\n        \\n        return dpHelper(arr, 0, arr.length - 1, dp);\\n    }\\n    \\n    public int dpHelper(int[] arr, int start, int end, int[][] dp) {\\n        if (start == end) {\\n            return 0;\\n        }\\n        if (dp[start][end] != 0) {\\n            return dp[start][end];\\n        }\\n        \\n        int interval = end - start;\\n        int count = Integer.MAX_VALUE;\\n        \\n        for (int i = 0; i < interval; i++) {\\n            int countLeft = dpHelper(arr, start, start + i, dp);\\n            int countRight = dpHelper(arr, start + i + 1, end, dp);\\n            int curMax = getMax(arr, start, start + i) * getMax(arr, start + i + 1, end);\\n            \\n            count = Math.min(countLeft + countRight + curMax, count);\\n        }\\n        \\n        dp[start][end] = count;\\n        return count;\\n    }\\n    \\n    public int getMax(int[] arr, int start, int end) {\\n        if (start == end) {\\n            return arr[start];\\n        }\\n        \\n        int maxV = Integer.MIN_VALUE;\\n        for (int i = start; i <= end; i++) {\\n            maxV = Math.max(maxV, arr[i]);\\n        }\\n        \\n        return maxV;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466913,
                "title": "java-comments-to-make-who-still-struggle-with-this-problems-could-understand-the-idea",
                "content": "\\n```\\n1. call dp[i][j] is minimum cost tree from i..j\\n2. our result is dp[0][arr.length - 1]\\n3. i..j have multiple way to build the tree, k: i -> j to devide into left subtree and right subtree: [0,k1] and [k1 + 1][j] or [0,k2] and [k2 + 1][j]\\n4. to find dp[i][j] we need to find all of subtree have smaller range. Ex [6,2,4] we need to find minimum cost: dp[0][0], dp[1][1], dp[2][2],\\ndp[0,1], dp[1,2]\\n5. dp[0][0], dp[1][1], dp[2][2].. dp[i][i] is leaf node so minimum cost tree to build leaf node is zero.\\n\\n\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[][] dp = new int[arr.length][arr.length];\\n        int[] leftMaxLeaf = new int[arr.length], rightMaxLeaf = new int[arr.length];\\n        int max = 0;\\n        for(int range = 1; range < arr.length; range++) {\\n            // smaller range between i and j start from 1 to n - 1\\n            \\n            for(int i = 0; i < arr.length - range; i++) {\\n                int j = i + range;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                \\n                // find max leaf in left subtree\\n                max = 0;\\n                for(int k = i; k < j; k++) {\\n                    max = Math.max(max, arr[k]);\\n                    leftMaxLeaf[k] = max;\\n                }\\n                \\n                // find max leaf in right subtree\\n                max = 0;\\n                for(int k = j; k >= 0; k--) {\\n                    max = Math.max(max, arr[k]);\\n                    rightMaxLeaf[k] = max;\\n                }\\n                \\n                // minimum cost i->j which compared from multiple way to build minimum cost of left subtree and right subtree and multiply \\n                // of max leaf in left and max leaf in right\\n                for(int k = i; k < j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + leftMaxLeaf[k] * rightMaxLeaf[k + 1]);\\n                }\\n            }\\n        } \\n        \\n        return dp[0][arr.length - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n1. call dp[i][j] is minimum cost tree from i..j\\n2. our result is dp[0][arr.length - 1]\\n3. i..j have multiple way to build the tree, k: i -> j to devide into left subtree and right subtree: [0,k1] and [k1 + 1][j] or [0,k2] and [k2 + 1][j]\\n4. to find dp[i][j] we need to find all of subtree have smaller range. Ex [6,2,4] we need to find minimum cost: dp[0][0], dp[1][1], dp[2][2],\\ndp[0,1], dp[1,2]\\n5. dp[0][0], dp[1][1], dp[2][2].. dp[i][i] is leaf node so minimum cost tree to build leaf node is zero.\\n\\n\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int[][] dp = new int[arr.length][arr.length];\\n        int[] leftMaxLeaf = new int[arr.length], rightMaxLeaf = new int[arr.length];\\n        int max = 0;\\n        for(int range = 1; range < arr.length; range++) {\\n            // smaller range between i and j start from 1 to n - 1\\n            \\n            for(int i = 0; i < arr.length - range; i++) {\\n                int j = i + range;\\n                dp[i][j] = Integer.MAX_VALUE;\\n                \\n                // find max leaf in left subtree\\n                max = 0;\\n                for(int k = i; k < j; k++) {\\n                    max = Math.max(max, arr[k]);\\n                    leftMaxLeaf[k] = max;\\n                }\\n                \\n                // find max leaf in right subtree\\n                max = 0;\\n                for(int k = j; k >= 0; k--) {\\n                    max = Math.max(max, arr[k]);\\n                    rightMaxLeaf[k] = max;\\n                }\\n                \\n                // minimum cost i->j which compared from multiple way to build minimum cost of left subtree and right subtree and multiply \\n                // of max leaf in left and max leaf in right\\n                for(int k = i; k < j; k++) {\\n                    dp[i][j] = Math.min(dp[i][j], dp[i][k] + dp[k + 1][j] + leftMaxLeaf[k] * rightMaxLeaf[k + 1]);\\n                }\\n            }\\n        } \\n        \\n        return dp[0][arr.length - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 444707,
                "title": "time-n-2-space-o-1-100",
                "content": "My solution without extra space and N^2 time complexity. The result is 100%\\nSteps:\\n1. Find a pair with min value(as a goal is to find minimum sum) as this is the in-order format and so we are taking an adjacent element from an array and finding the value.\\n2. Once we get the new generated non-leaf node, the node with minimum value is useless (For the newly generated subtree will be represented with the largest leaf node value.)\\n3. Repeat it until there is only one node.\\n\\n```\\n int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        int index = 0;\\n        while(1)\\n        {\\n            int min = INT_MAX;\\n            for(int i = 1;i < arr.size(); ++i)\\n            {\\n                if(arr[i-1] * arr[i] < min)\\n                {\\n                    min = arr[i-1] * arr[i];\\n                    index = i;\\n                }\\n            }\\n            sum += min;\\n            if(arr[index-1] > arr[index])\\n                arr.erase(arr.begin()+index);\\n            else\\n                arr.erase(arr.begin()+index-1);\\n            if(arr.size() < 2) break;\\n        }\\n        return sum;\\n    }\\n```\\n\\nexample: [3, 4, 6, 8, 9]\\noutput tree:\\n![image](https://assets.leetcode.com/users/bharsaklemukesh975/image_1588633538.png)\\n",
                "solutionTags": [],
                "code": "```\\n int mctFromLeafValues(vector<int>& arr) {\\n        int sum = 0;\\n        int index = 0;\\n        while(1)\\n        {\\n            int min = INT_MAX;\\n            for(int i = 1;i < arr.size(); ++i)\\n            {\\n                if(arr[i-1] * arr[i] < min)\\n                {\\n                    min = arr[i-1] * arr[i];\\n                    index = i;\\n                }\\n            }\\n            sum += min;\\n            if(arr[index-1] > arr[index])\\n                arr.erase(arr.begin()+index);\\n            else\\n                arr.erase(arr.begin()+index-1);\\n            if(arr.size() < 2) break;\\n        }\\n        return sum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 436593,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        while(len(arr)>1):\\n            mx = arr[0]*arr[1]\\n            l = 0\\n            r = 1\\n            for i in range(len(arr)-1):\\n                if arr[i]*arr[i+1]<mx:\\n                    mx = arr[i]*arr[i+1]\\n                    l = i\\n                    r = i+1\\n            ans+=mx\\n            #print(l,r,mx)\\n            if arr[l]>arr[r]:\\n                del arr[r]\\n            else:\\n                del arr[l]\\n        return ans\\n\\t\\t```\\n\\t\\t\\n\\t\\tThe solution basicallly checks all pairs of adjacent values in arr to find the pair with the lowest product and adds it to the ans. Then, it removes the minimum of the 2 numbers in the selected pair from the list. Repeat till no pairs left.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def mctFromLeafValues(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        while(len(arr)>1):\\n            mx = arr[0]*arr[1]\\n            l = 0\\n            r = 1\\n            for i in range(len(arr)-1):\\n                if arr[i]*arr[i+1]<mx:\\n                    mx = arr[i]*arr[i+1]\\n                    l = i\\n                    r = i+1\\n            ans+=mx\\n            #print(l,r,mx)\\n            if arr[l]>arr[r]:\\n                del arr[r]\\n            else:\\n                del arr[l]\\n        return ans\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 430828,
                "title": "optimized-java-solution-based-on-arraylist-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n\\t\\n        List<Integer> l=new ArrayList<>();\\n        for(int x:arr)l.add(x);\\n        int sum=0;\\n\\t\\t\\n        while(l.size()!=1){\\n            int index=l.indexOf(Collections.min(l)); //index of minimum element \\n            if(index==0 ||(index-1>=0&&index+1<l.size()&&l.get(index-1)>l.get(index+1))){ //pick left value\\n                sum+=l.get(index+1)*l.get(index);\\n                l.set(index,l.get(index+1)>l.get(index)?l.get(index+1):l.get(index));\\n                l.remove(index+1);\\n            }\\n            else{ //pick right value\\n                sum+=l.get(index-1)*l.get(index);\\n                l.set(index-1,l.get(index-1)>l.get(index)?l.get(index-1):l.get(index));\\n                l.remove(index);\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n\\t\\n        List<Integer> l=new ArrayList<>();\\n        for(int x:arr)l.add(x);\\n        int sum=0;\\n\\t\\t\\n        while(l.size()!=1){\\n            int index=l.indexOf(Collections.min(l)); //index of minimum element \\n            if(index==0 ||(index-1>=0&&index+1<l.size()&&l.get(index-1)>l.get(index+1))){ //pick left value\\n                sum+=l.get(index+1)*l.get(index);\\n                l.set(index,l.get(index+1)>l.get(index)?l.get(index+1):l.get(index));\\n                l.remove(index+1);\\n            }\\n            else{ //pick right value\\n                sum+=l.get(index-1)*l.get(index);\\n                l.set(index-1,l.get(index-1)>l.get(index)?l.get(index-1):l.get(index));\\n                l.remove(index);\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400971,
                "title": "python-divide-and-conquer-iterative-easy-to-understand",
                "content": "```\\n######################################################################\\n# Explanation\\n######################################################################\\n# starting concepts:\\n# [6,2,4,3,7,6]\\n# [6,2] [4] [3,7] [6]\\n# can have multiple single-child nodes\\n\\n# [6,2,4,3,7,6]\\n# [6,2] [4] [3] [7,6]\\n# can have adjacent single-child nodes\\n######################################################################\\n# Non-leaf value is product of biggest leaf in left and right subtrees\\n# to minimize, split up nodes so we form smallest product\\n# for root this is predetermined by product of two biggest\\n# i.e.\\n# [6,2,4,3,7], the root val must be 6*7=42\\n\\n# Remaining items are now up for grabs\\n# big number  * small number = big number \\n# bigger number * small number = even bigger number \\n# following this logic, we want the up for grab elements\\n# in subtree with smaller value. If tie then either subtree works\\n# since it will be a mirror tree of the opposite chosen subtree\\n# [6,2,4,3,7] ===> [6] [2,4,3,7] record: 42\\n\\n# Recursively repeat on all sub trees with size > 1:\\n\\n# Iteration 2:\\n# [6] [2,4,3,7] ===> [6] [2,4,3] [7]  record:28\\n# biggest = 4 and 7, 3 up for grabs goes into smaller subtree\\n\\n# Iteration 3:\\n# [6] [2,4,3] [7] ===> [6] [2,4] [3] [7] record: 12\\n\\n# Iteration 4:\\n# [6] [2,4,3] [7] ===> [6] [2] [4] [3] [7] record: 8\\n# the sum of the recorded values == 90\\n######################################################################\\n# Algorithm:\\n#   set answer = 0\\n#   Make subtree stack\\n#   startingSubtree is entire list\\n#   push startingSubtree onto stack\\n#   Repeat on all subtrees with size > 1:\\n#       Scan through the subtree for max and second max and record idxes O(n)\\n#       leftmax = idx of leftmost max\\n#       rightmax = idx of rightmost max\\n#       Make two subtrees doing the following:\\n#           leftmax and all items left of it go in leftsubtree\\n#           rightmax and all items right of it go in rightsubtree\\n#           if any middle items, they go to the side of smaller subtree\\n#           This division is a non-leaf node, so answer += leftmax  rightmax\\n#   return answer\\n######################################################################\\n\\nclass Solution:\\n    def get_lm_rm(self, arr):\\n        # arr - list of integers size>1\\n        # return: leftmax, rightmax\\n        big1, idx1, big2, idx2 = -1, -1, -1, -1\\n        for i, num in enumerate(arr):\\n            if num >= big1:\\n                big2, idx2 = big1, idx1\\n                big1, idx1 = num, i\\n            elif num >= big2:\\n                big2, idx2 = num, i\\n        return min(idx1, idx2), max(idx1, idx2)\\n        \\n    def mctFromLeafValues(self, arr: List[int]) -> int:   \\n        if len(arr) == 1:\\n            return 0\\n        answer = 0\\n        stack = [arr]\\n        while stack:\\n            subtree = stack.pop()\\n            leftmax, rightmax = self.get_lm_rm(subtree)\\n            left_subtree = subtree[:leftmax+1]\\n            right_subtree = subtree[rightmax:]\\n            middle = subtree[leftmax+1:rightmax]\\n            if subtree[leftmax] < subtree[rightmax]:\\n                left_subtree += middle\\n            else:\\n                right_subtree = middle + right_subtree\\n            answer += subtree[leftmax] * subtree[rightmax]\\n            if len(left_subtree) > 1:\\n                stack.append(left_subtree)\\n            if len(right_subtree) > 1:\\n                stack.append(right_subtree)\\n            print(\\'left:\\', left_subtree)\\n            print(\\'right:\\', right_subtree)\\n            print(subtree[leftmax] * subtree[rightmax])\\n        return answer\\n            \\n        \\n        \\n        \\n```\\n",
                "solutionTags": [],
                "code": "```\\n######################################################################\\n# Explanation\\n######################################################################\\n# starting concepts:\\n# [6,2,4,3,7,6]\\n# [6,2] [4] [3,7] [6]\\n# can have multiple single-child nodes\\n\\n# [6,2,4,3,7,6]\\n# [6,2] [4] [3] [7,6]\\n# can have adjacent single-child nodes\\n######################################################################\\n# Non-leaf value is product of biggest leaf in left and right subtrees\\n# to minimize, split up nodes so we form smallest product\\n# for root this is predetermined by product of two biggest\\n# i.e.\\n# [6,2,4,3,7], the root val must be 6*7=42\\n\\n# Remaining items are now up for grabs\\n# big number  * small number = big number \\n# bigger number * small number = even bigger number \\n# following this logic, we want the up for grab elements\\n# in subtree with smaller value. If tie then either subtree works\\n# since it will be a mirror tree of the opposite chosen subtree\\n# [6,2,4,3,7] ===> [6] [2,4,3,7] record: 42\\n\\n# Recursively repeat on all sub trees with size > 1:\\n\\n# Iteration 2:\\n# [6] [2,4,3,7] ===> [6] [2,4,3] [7]  record:28\\n# biggest = 4 and 7, 3 up for grabs goes into smaller subtree\\n\\n# Iteration 3:\\n# [6] [2,4,3] [7] ===> [6] [2,4] [3] [7] record: 12\\n\\n# Iteration 4:\\n# [6] [2,4,3] [7] ===> [6] [2] [4] [3] [7] record: 8\\n# the sum of the recorded values == 90\\n######################################################################\\n# Algorithm:\\n#   set answer = 0\\n#   Make subtree stack\\n#   startingSubtree is entire list\\n#   push startingSubtree onto stack\\n#   Repeat on all subtrees with size > 1:\\n#       Scan through the subtree for max and second max and record idxes O(n)\\n#       leftmax = idx of leftmost max\\n#       rightmax = idx of rightmost max\\n#       Make two subtrees doing the following:\\n#           leftmax and all items left of it go in leftsubtree\\n#           rightmax and all items right of it go in rightsubtree\\n#           if any middle items, they go to the side of smaller subtree\\n#           This division is a non-leaf node, so answer += leftmax  rightmax\\n#   return answer\\n######################################################################\\n\\nclass Solution:\\n    def get_lm_rm(self, arr):\\n        # arr - list of integers size>1\\n        # return: leftmax, rightmax\\n        big1, idx1, big2, idx2 = -1, -1, -1, -1\\n        for i, num in enumerate(arr):\\n            if num >= big1:\\n                big2, idx2 = big1, idx1\\n                big1, idx1 = num, i\\n            elif num >= big2:\\n                big2, idx2 = num, i\\n        return min(idx1, idx2), max(idx1, idx2)\\n        \\n    def mctFromLeafValues(self, arr: List[int]) -> int:   \\n        if len(arr) == 1:\\n            return 0\\n        answer = 0\\n        stack = [arr]\\n        while stack:\\n            subtree = stack.pop()\\n            leftmax, rightmax = self.get_lm_rm(subtree)\\n            left_subtree = subtree[:leftmax+1]\\n            right_subtree = subtree[rightmax:]\\n            middle = subtree[leftmax+1:rightmax]\\n            if subtree[leftmax] < subtree[rightmax]:\\n                left_subtree += middle\\n            else:\\n                right_subtree = middle + right_subtree\\n            answer += subtree[leftmax] * subtree[rightmax]\\n            if len(left_subtree) > 1:\\n                stack.append(left_subtree)\\n            if len(right_subtree) > 1:\\n                stack.append(right_subtree)\\n            print(\\'left:\\', left_subtree)\\n            print(\\'right:\\', right_subtree)\\n            print(subtree[leftmax] * subtree[rightmax])\\n        return answer\\n            \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 371314,
                "title": "java-easy-dp-using-hashmap",
                "content": "```\\n    private Map<String,Integer> resultMap; // Stores result of minimum value for a given index range\\n    private Map<String,Integer> highestValMap;// Store highest leaf node for a given index range.\\n\\n    public int mctFromLeafValues(int[] arr) {\\n        if(arr == null || arr.length ==0) {\\n            return 0;\\n        }\\n\\n        int start = 0;\\n        int end = arr.length-1;\\n        resultMap = new HashMap<>();\\n        highestValMap = new HashMap<>();\\n\\n        return util(start,end,arr);\\n    }\\n\\n    private int util(int start,int end,int[] arr) {\\n\\n        String key = start+\"_\"+end; // Key of the map : Comprising of start & end index.\\n        if(resultMap.containsKey(key)) {\\n            return resultMap.get(key);\\n        } else if(start == end) {\\n            int value = 0;\\n            resultMap.put(key,value);\\n            highestValMap.put(key, arr[start]);\\n            return value;\\n        } else if(start+1 == end) {\\n            int value = arr[start]*arr[end];\\n            resultMap.put(key, value);\\n            highestValMap.put(key, Math.max(arr[start],arr[end]));\\n            return value;\\n        }\\n        int minValue = Integer.MAX_VALUE;\\n        int i=0;\\n        /**\\n         * Lets say the size of the array is 5[0,4]: To find minimum result , Group array as\\n         * (0,0) (1,4)\\n         * (0,1) (2,4)\\n         * (0,2) (3,4)\\n         * (0,3) (4,4)\\n         */\\n        while (i<end-start) {\\n            int left = util(start,start+i, arr);\\n            int leftHighest = highestValMap.get(start+\"_\"+(start+i));\\n            int right = util(start+i+1,end, arr);\\n            int rightHighest = highestValMap.get(((start+i+1)+\"_\"+end));\\n            int val =  (left+right) + (leftHighest*rightHighest);\\n            if(val<minValue) {\\n                minValue = val;\\n                resultMap.put(key, minValue);\\n                highestValMap.put(key, Math.max(rightHighest,leftHighest));\\n            }\\n            i++;\\n        }\\n\\n        return minValue;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private Map<String,Integer> resultMap; // Stores result of minimum value for a given index range\\n    private Map<String,Integer> highestValMap;// Store highest leaf node for a given index range.\\n\\n    public int mctFromLeafValues(int[] arr) {\\n        if(arr == null || arr.length ==0) {\\n            return 0;\\n        }\\n\\n        int start = 0;\\n        int end = arr.length-1;\\n        resultMap = new HashMap<>();\\n        highestValMap = new HashMap<>();\\n\\n        return util(start,end,arr);\\n    }\\n\\n    private int util(int start,int end,int[] arr) {\\n\\n        String key = start+\"_\"+end; // Key of the map : Comprising of start & end index.\\n        if(resultMap.containsKey(key)) {\\n            return resultMap.get(key);\\n        } else if(start == end) {\\n            int value = 0;\\n            resultMap.put(key,value);\\n            highestValMap.put(key, arr[start]);\\n            return value;\\n        } else if(start+1 == end) {\\n            int value = arr[start]*arr[end];\\n            resultMap.put(key, value);\\n            highestValMap.put(key, Math.max(arr[start],arr[end]));\\n            return value;\\n        }\\n        int minValue = Integer.MAX_VALUE;\\n        int i=0;\\n        /**\\n         * Lets say the size of the array is 5[0,4]: To find minimum result , Group array as\\n         * (0,0) (1,4)\\n         * (0,1) (2,4)\\n         * (0,2) (3,4)\\n         * (0,3) (4,4)\\n         */\\n        while (i<end-start) {\\n            int left = util(start,start+i, arr);\\n            int leftHighest = highestValMap.get(start+\"_\"+(start+i));\\n            int right = util(start+i+1,end, arr);\\n            int rightHighest = highestValMap.get(((start+i+1)+\"_\"+end));\\n            int val =  (left+right) + (leftHighest*rightHighest);\\n            if(val<minValue) {\\n                minValue = val;\\n                resultMap.put(key, minValue);\\n                highestValMap.put(key, Math.max(rightHighest,leftHighest));\\n            }\\n            i++;\\n        }\\n\\n        return minValue;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 358341,
                "title": "c-beat100-time-and-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        while(arr.size()>2){\\n            auto x = min_element(arr.begin(), arr.end());       \\n            int temp = x == arr.begin()? INT_MAX : *x * (*(x-1));        \\n            int temp2 = x > arr.end() - 2? INT_MAX : *x * (*(x+1));\\n            int ml = min(temp, temp2);\\n            res += ml;\\n            arr.erase(x);\\n        }\\n        res += arr[0] * arr[1];\\n        return res;\\n    }\\n};\\n```\\ntime O(n2)\\nspace O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int res = 0;\\n        while(arr.size()>2){\\n            auto x = min_element(arr.begin(), arr.end());       \\n            int temp = x == arr.begin()? INT_MAX : *x * (*(x-1));        \\n            int temp2 = x > arr.end() - 2? INT_MAX : *x * (*(x+1));\\n            int ml = min(temp, temp2);\\n            res += ml;\\n            arr.erase(x);\\n        }\\n        res += arr[0] * arr[1];\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340433,
                "title": "c-bottom-up-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<vector<pair<int,int> > > dp(n, vector<pair<int,int>>(n));\\n        for (int len = 0; len < n; ++len) {\\n            for (int i = 0; i < n-len; ++i) {\\n                int j = i + len;\\n                if (i == j) {\\n                    dp[i][j].first = 0;\\n                    dp[i][j].second = arr[i];\\n                    continue;\\n                }\\n                dp[i][j].first = INT_MAX;\\n                dp[i][j].second = 0;\\n                for (int k = i; k < j; ++k) {\\n                    dp[i][j].second = max(dp[i][k].second, dp[k+1][j].second);\\n                    int sum = dp[i][k].second * dp[k+1][j].second;\\n                    sum += dp[i][k].first + dp[k+1][j].first;\\n                    if (dp[i][j].first > sum) { dp[i][j].first = sum; }                    \\n                }\\n                \\n            }\\n        }\\n        return dp[0][n-1].first;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        vector<vector<pair<int,int> > > dp(n, vector<pair<int,int>>(n));\\n        for (int len = 0; len < n; ++len) {\\n            for (int i = 0; i < n-len; ++i) {\\n                int j = i + len;\\n                if (i == j) {\\n                    dp[i][j].first = 0;\\n                    dp[i][j].second = arr[i];\\n                    continue;\\n                }\\n                dp[i][j].first = INT_MAX;\\n                dp[i][j].second = 0;\\n                for (int k = i; k < j; ++k) {\\n                    dp[i][j].second = max(dp[i][k].second, dp[k+1][j].second);\\n                    int sum = dp[i][k].second * dp[k+1][j].second;\\n                    sum += dp[i][k].first + dp[k+1][j].first;\\n                    if (dp[i][j].first > sum) { dp[i][j].first = sum; }                    \\n                }\\n                \\n            }\\n        }\\n        return dp[0][n-1].first;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947050,
                "title": "minimum-cost-tree-from-leaf-values-leetcode",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is the question that describe:-\\nGiven an array arr of positive integers, consider all binary trees such that:\\n\\nEach node has either 0 or 2 children;\\nThe values of arr correspond to the values of each leaf in an in-order traversal of the tree.\\nThe value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree, respectively.\\nAmong all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node. It is guaranteed this sum fits into a 32-bit integer.\\n\\nA node is a leaf if and only if it has zero children.\\n\\n \\n\\n# Example 1:\\n\\n\\nInput: arr = [6,2,4]\\nOutput: 32\\nExplanation: There are two possible trees shown.\\nThe first has a non-leaf node sum 36, and the second has non-leaf node sum 32.\\n# Example 2:\\n\\n\\nInput: arr = [4,11]\\nOutput: 44\\n \\n\\n# Constraints:\\n\\n2 <= arr.length <= 40\\n1 <= arr[i] <= 15\\nIt is guaranteed that the answer fits into a 32-bit signed integer (i.e., it is less than 231).\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr, map<pair<int,int> ,int >& maxi, int left, int right, vector<vector<int>> &dp){\\n        // base case:-\\n        if(left == right){\\n            return 0;\\n        }\\n        if(dp[left][right] != -1){\\n            return dp[left][right];\\n        }\\n\\n        int ans = INT_MAX;\\n\\n        for(int i = left; i<right; i++){\\n            ans = min(ans,\\n            maxi[{left,i}] * maxi[{i+1, right}]\\n            + solve(arr, maxi, left, i,dp)\\n            + solve(arr, maxi, i+1, right,dp));\\n        }\\n        dp[left][right] = ans;\\n        return dp[left][right];\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        // solving this question using map:-\\n        map<pair<int, int> ,int> maxi;\\n\\n        // store the data into the map:-\\n        for(int i = 0;i<arr.size();i++){\\n            maxi[{i,i}] = arr[i];\\n            for(int j = i+1;j<arr.size();j++){\\n                maxi[{i,j}] = max(arr[j], maxi[{i,j-1}]);\\n            }\\n        }\\n        int n = arr.size();\\n        vector<vector<int>> dp(n+1, vector<int>(n+1,-1));\\n        int ans = solve(arr, maxi, 0, arr.size()-1,dp);\\n        return ans;\\n    }\\n// By ~ Shubham Verma\\n};\\n```\\n![fe5d77d5-39f2-4839-9fcf-41c50106b04f_1676347139.1033723.gif](https://assets.leetcode.com/users/images/5e4950cf-b060-43e6-bc6e-24e08c0df667_1692729285.3549821.gif)\\n![f9e51783-3660-4252-933c-ec2c42b2d57d_1677809905.0379472.jpeg](https://assets.leetcode.com/users/images/5f50214c-f58a-4c4f-9715-ba0eecb1e676_1692729287.343367.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& arr, map<pair<int,int> ,int >& maxi, int left, int right, vector<vector<int>> &dp){\\n        // base case:-\\n        if(left == right){\\n            return 0;\\n        }\\n        if(dp[left][right] != -1){\\n            return dp[left][right];\\n        }\\n\\n        int ans = INT_MAX;\\n\\n        for(int i = left; i<right; i++){\\n            ans = min(ans,\\n            maxi[{left,i}] * maxi[{i+1, right}]\\n            + solve(arr, maxi, left, i,dp)\\n            + solve(arr, maxi, i+1, right,dp));\\n        }\\n        dp[left][right] = ans;\\n        return dp[left][right];\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        // solving this question using map:-\\n        map<pair<int, int> ,int> maxi;\\n\\n        // store the data into the map:-\\n        for(int i = 0;i<arr.size();i++){\\n            maxi[{i,i}] = arr[i];\\n            for(int j = i+1;j<arr.size();j++){\\n                maxi[{i,j}] = max(arr[j], maxi[{i,j-1}]);\\n            }\\n        }\\n        int n = arr.size();\\n        vector<vector<int>> dp(n+1, vector<int>(n+1,-1));\\n        int ans = solve(arr, maxi, 0, arr.size()-1,dp);\\n        return ans;\\n    }\\n// By ~ Shubham Verma\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892311,
                "title": "max-l-to-i-max-i-1-to-r-solve-a-l-i-mp-dp-solve-a-i-1-r-mp-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& a , int l ,int r, map<pair<int, int>, int> &mp, vector<vector<int>> &dp)\\n    {\\n        if(l==r)\\n            return 0;\\n        \\n        if(dp[l][r]!=-1)\\n            return dp[l][r];\\n        \\n        int ans = INT_MAX;\\n        for(int i=l;i<r;i++)\\n        {\\n            ans = min({long(ans) , (long)mp[{l,i}]*mp[{i+1,r}]+solve(a,l,i,mp,dp) + solve(a,i+1,r,mp,dp)});\\n        }\\n        \\n        \\n        \\n        return dp[l][r] = ans;\\n    }\\n    \\n    \\n    int mctFromLeafValues(vector<int>& a) {\\n        map<pair<int, int>, int> mp;\\n        int n = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[{i,i}] = a[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                mp[{i,j}] = max(mp[{i,j-1}],a[j]);\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        \\n        return solve(a,0,n-1,mp,dp);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<int>& a , int l ,int r, map<pair<int, int>, int> &mp, vector<vector<int>> &dp)\\n    {\\n        if(l==r)\\n            return 0;\\n        \\n        if(dp[l][r]!=-1)\\n            return dp[l][r];\\n        \\n        int ans = INT_MAX;\\n        for(int i=l;i<r;i++)\\n        {\\n            ans = min({long(ans) , (long)mp[{l,i}]*mp[{i+1,r}]+solve(a,l,i,mp,dp) + solve(a,i+1,r,mp,dp)});\\n        }\\n        \\n        \\n        \\n        return dp[l][r] = ans;\\n    }\\n    \\n    \\n    int mctFromLeafValues(vector<int>& a) {\\n        map<pair<int, int>, int> mp;\\n        int n = a.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            mp[{i,i}] = a[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n                mp[{i,j}] = max(mp[{i,j-1}],a[j]);\\n            }\\n        }\\n        \\n        \\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        \\n        return solve(a,0,n-1,mp,dp);\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803152,
                "title": "easy-c-solution-bottom-up-tabulation-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bottomUp(vector<int>& arr,map<pair<int,int>, int> &maxi,int n){\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int left=n-1;left>=0;left--){\\n            for(int right=0;right<n;right++){\\n                if(left>=right)\\n                    continue;\\n                else{\\n                    int ans=INT_MAX;\\n                    for(int i=left;i<right;i++){\\n                        ans=min(ans,\\n                        (maxi[{left,i}]*maxi[{i+1,right}]+\\n                        dp[left][i]\\n                        +dp[i+1][right]));\\n                    }\\n                    dp[left][right]=ans;\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n\\n    int mctFromLeafValues(vector<int>& arr) {\\n        map<pair<int,int>, int> maxi;\\n        for(int i=0;i<arr.size();i++){\\n            maxi[{i,i}]=arr[i];\\n             //this is basically \\n                // pair<int,int> p;\\n                // p.first=i;\\n                // p.second=i;\\n                // maxi[p]=arr[i];\\n            for(int j=i+1;j<arr.size();j++){\\n                maxi[{i,j}]=max(arr[j],maxi[{i,j-1}]);\\n            }\\n        }\\n        int n=arr.size();\\n        return bottomUp(arr,maxi,n);\\n      }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bottomUp(vector<int>& arr,map<pair<int,int>, int> &maxi,int n){\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,0));\\n        for(int left=n-1;left>=0;left--){\\n            for(int right=0;right<n;right++){\\n                if(left>=right)\\n                    continue;\\n                else{\\n                    int ans=INT_MAX;\\n                    for(int i=left;i<right;i++){\\n                        ans=min(ans,\\n                        (maxi[{left,i}]*maxi[{i+1,right}]+\\n                        dp[left][i]\\n                        +dp[i+1][right]));\\n                    }\\n                    dp[left][right]=ans;\\n                }\\n            }\\n        }\\n        return dp[0][n-1];\\n    }\\n\\n    int mctFromLeafValues(vector<int>& arr) {\\n        map<pair<int,int>, int> maxi;\\n        for(int i=0;i<arr.size();i++){\\n            maxi[{i,i}]=arr[i];\\n             //this is basically \\n                // pair<int,int> p;\\n                // p.first=i;\\n                // p.second=i;\\n                // maxi[p]=arr[i];\\n            for(int j=i+1;j<arr.size();j++){\\n                maxi[{i,j}]=max(arr[j],maxi[{i,j-1}]);\\n            }\\n        }\\n        int n=arr.size();\\n        return bottomUp(arr,maxi,n);\\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3803146,
                "title": "easy-c-solution-top-down-memonization-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int topDown(vector<int>& arr,map<pair<int,int>,int>& maxi,int left,int right,vector<vector<int>> &dp){\\n        if(left==right)\\n            return 0;\\n        if(dp[left][right]!=-1)\\n            return dp[left][right];\\n\\n        int ans=INT_MAX;\\n        for(int i=left;i<right;i++){\\n            ans=min(ans,\\n            (maxi[{left,i}]*maxi[{i+1,right}]+\\n            topDown(arr,maxi,left,i,dp)\\n            +topDown(arr,maxi,i+1,right,dp)));\\n        }\\n        dp[left][right]=ans;\\n        return dp[left][right];\\n    }\\n\\n    int mctFromLeafValues(vector<int>& arr) {\\n        map<pair<int,int>, int> maxi;\\n        for(int i=0;i<arr.size();i++){\\n            maxi[{i,i}]=arr[i];\\n             //this is basically \\n                // pair<int,int> p;\\n                // p.first=i;\\n                // p.second=i;\\n                // maxi[p]=arr[i];\\n            for(int j=i+1;j<arr.size();j++){\\n                maxi[{i,j}]=max(arr[j],maxi[{i,j-1}]);\\n            }\\n        }\\n        int n=arr.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        int ans=topDown(arr,maxi,0,n-1,dp);\\n        return ans;\\n      }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int topDown(vector<int>& arr,map<pair<int,int>,int>& maxi,int left,int right,vector<vector<int>> &dp){\\n        if(left==right)\\n            return 0;\\n        if(dp[left][right]!=-1)\\n            return dp[left][right];\\n\\n        int ans=INT_MAX;\\n        for(int i=left;i<right;i++){\\n            ans=min(ans,\\n            (maxi[{left,i}]*maxi[{i+1,right}]+\\n            topDown(arr,maxi,left,i,dp)\\n            +topDown(arr,maxi,i+1,right,dp)));\\n        }\\n        dp[left][right]=ans;\\n        return dp[left][right];\\n    }\\n\\n    int mctFromLeafValues(vector<int>& arr) {\\n        map<pair<int,int>, int> maxi;\\n        for(int i=0;i<arr.size();i++){\\n            maxi[{i,i}]=arr[i];\\n             //this is basically \\n                // pair<int,int> p;\\n                // p.first=i;\\n                // p.second=i;\\n                // maxi[p]=arr[i];\\n            for(int j=i+1;j<arr.size();j++){\\n                maxi[{i,j}]=max(arr[j],maxi[{i,j-1}]);\\n            }\\n        }\\n        int n=arr.size();\\n        vector<vector<int>> dp(n+1,vector<int>(n+1,-1));\\n        int ans=topDown(arr,maxi,0,n-1,dp);\\n        return ans;\\n      }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3722507,
                "title": "java-recursive-memoization-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length;\\n        // To Store maximum value between the range\\n        Map<Pair<Integer, Integer>, Integer> max = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            max.put(new Pair(i,i), arr[i]);\\n            for(int j = i + 1; j < n; j++){\\n                max.put(new Pair(i, j), Math.max(arr[j], max.get(new Pair(i, j - 1))));\\n            }\\n        }\\n\\n        // return helper(arr, max, 0, n - 1);\\n        \\n        int[][] dp = new int[n + 1][n + 1];\\n        for(int[] row : dp) Arrays.fill(row, -1);\\n        return helperMem(arr, max, 0, n - 1, dp);\\n    }\\n\\n    public int helper(int[] arr, Map<Pair<Integer, Integer>, Integer> max, int left, int right){\\n        if(left == right) return 0;\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i = left; i < right; i++){\\n            ans = Math.min(ans, \\n                max.get(new Pair(left, i)) * max.get(new Pair(i + 1, right)) \\n                + helper(arr, max, left, i) + helper(arr, max, i + 1, right)\\n                );\\n        }\\n        return ans;\\n    }\\n\\n    public int helperMem(int[] arr, Map<Pair<Integer, Integer>, Integer> max, int left, int right, int[][] dp){\\n        if(left == right) return 0;\\n        if(dp[left][right] != -1) return dp[left][right];\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i = left; i < right; i++){\\n            ans = Math.min(ans, \\n                max.get(new Pair(left, i)) * max.get(new Pair(i + 1, right)) \\n                + helperMem(arr, max, left, i, dp) + helperMem(arr, max, i + 1, right, dp)\\n                );\\n        }\\n        return dp[left][right] = ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        int n = arr.length;\\n        // To Store maximum value between the range\\n        Map<Pair<Integer, Integer>, Integer> max = new HashMap<>();\\n        for(int i = 0; i < n; i++){\\n            max.put(new Pair(i,i), arr[i]);\\n            for(int j = i + 1; j < n; j++){\\n                max.put(new Pair(i, j), Math.max(arr[j], max.get(new Pair(i, j - 1))));\\n            }\\n        }\\n\\n        // return helper(arr, max, 0, n - 1);\\n        \\n        int[][] dp = new int[n + 1][n + 1];\\n        for(int[] row : dp) Arrays.fill(row, -1);\\n        return helperMem(arr, max, 0, n - 1, dp);\\n    }\\n\\n    public int helper(int[] arr, Map<Pair<Integer, Integer>, Integer> max, int left, int right){\\n        if(left == right) return 0;\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i = left; i < right; i++){\\n            ans = Math.min(ans, \\n                max.get(new Pair(left, i)) * max.get(new Pair(i + 1, right)) \\n                + helper(arr, max, left, i) + helper(arr, max, i + 1, right)\\n                );\\n        }\\n        return ans;\\n    }\\n\\n    public int helperMem(int[] arr, Map<Pair<Integer, Integer>, Integer> max, int left, int right, int[][] dp){\\n        if(left == right) return 0;\\n        if(dp[left][right] != -1) return dp[left][right];\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int i = left; i < right; i++){\\n            ans = Math.min(ans, \\n                max.get(new Pair(left, i)) * max.get(new Pair(i + 1, right)) \\n                + helperMem(arr, max, left, i, dp) + helperMem(arr, max, i + 1, right, dp)\\n                );\\n        }\\n        return dp[left][right] = ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689527,
                "title": "python-made-easy-2-approaches-brute-force-o-n-2-monotonic-stack-o-n-explained",
                "content": "**Upvote if you understood the solutions :)**\\n\\nApproach 1: We select 2 minimum value neighbours from the array and pop the least value everytime. Why? We greedily only multiply the minimum possible combo and keep the bigger element each time.\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        i = j = None\\n        res = 0\\n\\n        while len(arr) > 1:\\n            for x in range(1, len(arr)):\\n                if i is None or arr[x] * arr[x - 1] < arr[j] * arr[i]:\\n                    if arr[x] > arr[x - 1]:\\n                        j = x\\n                        i = x - 1\\n                    else:\\n                        i = x\\n                        j = x - 1\\n\\n            res += arr[i] * arr[j]\\n            arr.pop(i)\\n            i = j = None\\n\\n        return res\\n```\\n\\nApproach 2: If we are given 3 elements, we iterate from left to right and multiply the least item to the second least one and keep the second least item and the largest one in a monotonic descending stack. We can only multiply the neighbouring items at any given moment. Note: in these 3 elements, the smallest element can only be used once.\\n\\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        stack = []\\n        \\n        for x in arr:\\n            while len(stack) and stack[-1] <= x:\\n                mini = stack.pop() # minimum element of the 3 elements stack[-1], stack[-2] and x\\n                \\n                if stack: # if stack has any item left\\n                    res +=  mini * min(x, stack[-1])\\n                else:\\n                    res += mini * x\\n            \\n            stack.append(x)\\n        \\n        # process the remaining items\\n        y = stack.pop()\\n        \\n        while len(stack):\\n            z = stack.pop()\\n            res += y * z\\n            y = z\\n        \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Stack",
                    "Greedy",
                    "Monotonic Stack"
                ],
                "code": "```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        i = j = None\\n        res = 0\\n\\n        while len(arr) > 1:\\n            for x in range(1, len(arr)):\\n                if i is None or arr[x] * arr[x - 1] < arr[j] * arr[i]:\\n                    if arr[x] > arr[x - 1]:\\n                        j = x\\n                        i = x - 1\\n                    else:\\n                        i = x\\n                        j = x - 1\\n\\n            res += arr[i] * arr[j]\\n            arr.pop(i)\\n            i = j = None\\n\\n        return res\\n```\n```\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        res = 0\\n        stack = []\\n        \\n        for x in arr:\\n            while len(stack) and stack[-1] <= x:\\n                mini = stack.pop() # minimum element of the 3 elements stack[-1], stack[-2] and x\\n                \\n                if stack: # if stack has any item left\\n                    res +=  mini * min(x, stack[-1])\\n                else:\\n                    res += mini * x\\n            \\n            stack.append(x)\\n        \\n        # process the remaining items\\n        y = stack.pop()\\n        \\n        while len(stack):\\n            z = stack.pop()\\n            res += y * z\\n            y = z\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587298,
                "title": "c-simple-easy-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(map<pair<int,int>,int>& mp,int l,int r,vector<vector<int>> &v){\\n        if(l==r)return 0;\\n        int ans = INT_MAX;\\n        if(v[l][r] != -1)return v[l][r];\\n        for(int i = l; i < r; i++){\\n            ans = min(ans,mp[{l,i}]*mp[{i+1,r}]+solve(mp,l,i,v)+solve(mp,i+1,r,v));\\n        }\\n        return v[l][r] = ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        map<pair<int,int>,int> mp;\\n        int i,j,n = arr.size();\\n        for(i = 0; i < n; i++){\\n            mp[{i,i}] = arr[i];\\n            for(j = i+1; j < n; j++){\\n                mp[{i,j}] = max(mp[{i,j-1}],arr[j]);\\n            }\\n        }\\n        vector<vector<int>> v (n,vector<int>(n,-1));\\n        // for(auto &i: mp)cout<<i.first.first<<\" \"<<i.first.second<<\" \"<<i.second<<endl;\\n        return solve(mp,0,n-1,v);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(map<pair<int,int>,int>& mp,int l,int r,vector<vector<int>> &v){\\n        if(l==r)return 0;\\n        int ans = INT_MAX;\\n        if(v[l][r] != -1)return v[l][r];\\n        for(int i = l; i < r; i++){\\n            ans = min(ans,mp[{l,i}]*mp[{i+1,r}]+solve(mp,l,i,v)+solve(mp,i+1,r,v));\\n        }\\n        return v[l][r] = ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        map<pair<int,int>,int> mp;\\n        int i,j,n = arr.size();\\n        for(i = 0; i < n; i++){\\n            mp[{i,i}] = arr[i];\\n            for(j = i+1; j < n; j++){\\n                mp[{i,j}] = max(mp[{i,j-1}],arr[j]);\\n            }\\n        }\\n        vector<vector<int>> v (n,vector<int>(n,-1));\\n        // for(auto &i: mp)cout<<i.first.first<<\" \"<<i.first.second<<\" \"<<i.second<<endl;\\n        return solve(mp,0,n-1,v);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2558285,
                "title": "python3-o-n-2-dp-commented-code",
                "content": "```\\n\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        \"\"\"\\n        we need to find dp(left,right), left -> start index, right -> end index\\n        suppose p is the partition point for the arr \\n        dp(left,right) = max(arr[left:p+1]) * max(arr[p+1:right+1]) + dp(left,p) + dp(p+1,right)\\n        we need to find dp(left,right) for all p in the range of (left,right)\\n        \\n        \"\"\"\\n        dp = {}\\n        \\n        def helper(left,right):\\n            if left == right:\\n                return 0 \\n            if (left,right) in dp:\\n                return dp[(left,right)]\\n            if left + 1 == right:\\n                return arr[left] * arr[right]\\n            \\n            min_cost = float(\\'inf\\')\\n            for p in range(left,right):\\n                cost = (max(arr[left:p+1]) * max(arr[p+1:right+1])) + helper(left,p) + helper(p+1,right)\\n                min_cost = min(min_cost,cost)\\n            \\n            dp[(left,right)] = min_cost\\n            return min_cost\\n        \\n        \\n        return helper(0,len(arr)-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution:\\n    def mctFromLeafValues(self, arr: List[int]) -> int:\\n        \"\"\"\\n        we need to find dp(left,right), left -> start index, right -> end index\\n        suppose p is the partition point for the arr \\n        dp(left,right) = max(arr[left:p+1]) * max(arr[p+1:right+1]) + dp(left,p) + dp(p+1,right)\\n        we need to find dp(left,right) for all p in the range of (left,right)\\n        \\n        \"\"\"\\n        dp = {}\\n        \\n        def helper(left,right):\\n            if left == right:\\n                return 0 \\n            if (left,right) in dp:\\n                return dp[(left,right)]\\n            if left + 1 == right:\\n                return arr[left] * arr[right]\\n            \\n            min_cost = float(\\'inf\\')\\n            for p in range(left,right):\\n                cost = (max(arr[left:p+1]) * max(arr[p+1:right+1])) + helper(left,p) + helper(p+1,right)\\n                min_cost = min(min_cost,cost)\\n            \\n            dp[(left,right)] = min_cost\\n            return min_cost\\n        \\n        \\n        return helper(0,len(arr)-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464461,
                "title": "java-faster-less-memory-than-98-documented-and-explained",
                "content": "Idea is to minimize the multiplicative impact at each step, so choose the smallest pair of numbers possible at each step:\\n\\n[6,2,4] -> Choose 2,4 as they have lesser multiplicative sum than 6,2. We need not keep the \\'node\\' this makes, only it\\'s sum, so add 8 to a running total. The maximum leaf value in this subtree is now 4, so we remove the 2 from the array:\\n[6, 4], Sum: 8\\nNow, the 4 here represents the maximum leaf value of the value(s) that have been taken out on either side of it.\\nRepeat:\\n[ ], Sum 8+24 = 32\\nArray is empty, so return.\\n\\nAgain:\\n6,2,1,3,4:0\\n6,2,3,4:2\\n6,3,4:2+6\\n6,4:2+6+12\\n:2+6+12+24 = 44\\n\\nCode:\\n```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        \\n        int sum = 0;\\n        while(arr.length > 2)\\n        {\\n            //Get the starting index of the minimum pair:\\n            int next = findMinSumStartingIndex(arr);\\n            \\n            //Add the product of the two values:\\n            sum += arr[next]*arr[next+1];\\n            \\n            //Find the smaller number:\\n            int removalIndex;\\n            if(arr[next]<=arr[next+1])\\n            {\\n                removalIndex = next;\\n            } else {\\n                removalIndex = next + 1;\\n            }\\n            \\n            //Use a new array and replace the old.\\n            int[] newArr = new int[arr.length-1];\\n            \\n            //Copy up to the removal index.\\n            System.arraycopy(arr,0,newArr,0,removalIndex);\\n            //Copy after the removal index.\\n            System.arraycopy(arr,removalIndex+1,newArr,removalIndex,arr.length-removalIndex-1);\\n            //Replace.\\n            arr = newArr;\\n        }\\n        //Return the sum plus the product of the final two array values.\\n        return sum + arr[0]*arr[1];\\n    }    \\n\\n    /**\\n    Checks pairwise values for the least sum of two numbers possible and returns the starting index\\n    of that pair.\\n    */\\n    private int findMinSumStartingIndex(int[] arr)\\n    {\\n        int minSum = Integer.MAX_VALUE;\\n        int msi=0;\\n        for(int x=0; x<arr.length-1; x++)\\n        {\\n            int sum = arr[x]+arr[x+1];\\n            if(sum < minSum){\\n                minSum = sum;\\n                msi = x;\\n            }\\n        }\\n        return msi;\\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int mctFromLeafValues(int[] arr) {\\n        \\n        int sum = 0;\\n        while(arr.length > 2)\\n        {\\n            //Get the starting index of the minimum pair:\\n            int next = findMinSumStartingIndex(arr);\\n            \\n            //Add the product of the two values:\\n            sum += arr[next]*arr[next+1];\\n            \\n            //Find the smaller number:\\n            int removalIndex;\\n            if(arr[next]<=arr[next+1])\\n            {\\n                removalIndex = next;\\n            } else {\\n                removalIndex = next + 1;\\n            }\\n            \\n            //Use a new array and replace the old.\\n            int[] newArr = new int[arr.length-1];\\n            \\n            //Copy up to the removal index.\\n            System.arraycopy(arr,0,newArr,0,removalIndex);\\n            //Copy after the removal index.\\n            System.arraycopy(arr,removalIndex+1,newArr,removalIndex,arr.length-removalIndex-1);\\n            //Replace.\\n            arr = newArr;\\n        }\\n        //Return the sum plus the product of the final two array values.\\n        return sum + arr[0]*arr[1];\\n    }    \\n\\n    /**\\n    Checks pairwise values for the least sum of two numbers possible and returns the starting index\\n    of that pair.\\n    */\\n    private int findMinSumStartingIndex(int[] arr)\\n    {\\n        int minSum = Integer.MAX_VALUE;\\n        int msi=0;\\n        for(int x=0; x<arr.length-1; x++)\\n        {\\n            int sum = arr[x]+arr[x+1];\\n            if(sum < minSum){\\n                minSum = sum;\\n                msi = x;\\n            }\\n        }\\n        return msi;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2451926,
                "title": "c-solution-using-stack-beats-80-short-and-clean",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& v) {\\n\\tint c=0;\\n\\tstack<int> st;\\n\\tfor(int i:v) {\\n\\t\\twhile(!st.empty() && st.top() <= i) {\\n\\t\\t\\tint x = st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\tc += x * min(st.empty() ? INT_MAX : st.top(),i);\\n\\t\\t}\\n\\t\\tst.push(i);\\n\\t}\\n\\tint a = st.top();\\n\\tst.pop();\\n\\twhile(!st.empty()) {\\n\\t\\tint x = st.top();\\n\\t\\tst.pop();\\n\\t\\tc += x * min(st.empty() ? INT_MAX : st.top(), a);\\n\\t\\ta = x;\\n\\t}\\n\\treturn c;\\n}\\n};\\n\\n\\n\\'\\'\\'\\n\\n**Upvote if it helped!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& v) {\\n\\tint c=0;\\n\\tstack<int> st;\\n\\tfor(int i:v) {\\n\\t\\twhile(!st.empty() && st.top() <= i) {\\n\\t\\t\\tint x = st.top();\\n\\t\\t\\tst.pop();\\n\\t\\t\\tc += x * min(st.empty() ? INT_MAX : st.top(),i);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2451792,
                "title": "simplest-c-solution-dp",
                "content": "```\\nint solve(vector<int>& arr, map<pair<int, int>, int> &maxi, int left, int right, vector<vector<int>> &dp){\\n        if(left == right)\\n            return 0;\\n        if(dp[left][right] != -1)\\n            return dp[left][right];\\n        int ans = INT_MAX;\\n        for(int k = left; k < right; k++){\\n            ans = min(ans, maxi[{left, k}] * maxi[{k+1, right}] + solve(arr, maxi, left, k, dp) + solve(arr, maxi, k+1, right, dp));\\n        }\\n        return dp[left][right] = ans;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        map<pair<int, int>, int> maxi;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        for(int i = 0; i < n; i++){\\n            maxi[{i, i}] = arr[i];\\n            for(int j = i+1; j < n; j++){\\n                maxi[{i, j}] = max(arr[j], maxi[{i, j-1}]);\\n            }\\n        }\\n        return solve(arr, maxi, 0, n - 1, dp);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nint solve(vector<int>& arr, map<pair<int, int>, int> &maxi, int left, int right, vector<vector<int>> &dp){\\n        if(left == right)\\n            return 0;\\n        if(dp[left][right] != -1)\\n            return dp[left][right];\\n        int ans = INT_MAX;\\n        for(int k = left; k < right; k++){\\n            ans = min(ans, maxi[{left, k}] * maxi[{k+1, right}] + solve(arr, maxi, left, k, dp) + solve(arr, maxi, k+1, right, dp));\\n        }\\n        return dp[left][right] = ans;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        map<pair<int, int>, int> maxi;\\n        vector<vector<int>> dp(n+1, vector<int>(n+1, -1));\\n        for(int i = 0; i < n; i++){\\n            maxi[{i, i}] = arr[i];\\n            for(int j = i+1; j < n; j++){\\n                maxi[{i, j}] = max(arr[j], maxi[{i, j-1}]);\\n            }\\n        }\\n        return solve(arr, maxi, 0, n - 1, dp);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2307503,
                "title": "a-mcm-variation",
                "content": "The logic is about MCM variation but the only thing added here is the third condition given.\\nThat we want the product of maximum leaf value in left and right.\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[41][41];\\n    int give_max(int start ,int end,vector<int>& arr)\\n    {\\n        int ans = INT_MIN;\\n        \\n        for(int i = start ; i<= end; i++)\\n        {\\n            ans = max(ans,arr[i]);\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    int solve(int start , int end, vector<int>& arr)\\n    {\\n        if(start >= end) // we have only one element \\n            return 0;  // as we want sum of non-leaf (one element is always leaf)\\n        \\n        \\n        if(dp[start][end] != -1)\\n            return dp[start][end];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i = start ; i < end ; i++)\\n        {\\n            int left_part = solve(start,i,arr);\\n            \\n            int right_part = solve(i+1,end,arr);\\n            \\n            int sum = left_part + right_part +  give_max(start,i,arr) * give_max(i+1,end,arr);\\n                                                //the 3rd condition product of max_element \\n                                                //of left and right subtree.\\n            \\n            ans = min(ans,sum);\\n        }\\n        \\n        return dp[start][end] = ans;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(0,n-1,arr);\\n    }\\n};\\n```\\nFor time i can\\'t say much 21% faster \\uD83D\\uDE02\\n![image](https://assets.leetcode.com/users/images/e59c3c08-1370-4845-a2a5-57c418c28b96_1658301160.369154.png)\\n",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[41][41];\\n    int give_max(int start ,int end,vector<int>& arr)\\n    {\\n        int ans = INT_MIN;\\n        \\n        for(int i = start ; i<= end; i++)\\n        {\\n            ans = max(ans,arr[i]);\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    int solve(int start , int end, vector<int>& arr)\\n    {\\n        if(start >= end) // we have only one element \\n            return 0;  // as we want sum of non-leaf (one element is always leaf)\\n        \\n        \\n        if(dp[start][end] != -1)\\n            return dp[start][end];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int i = start ; i < end ; i++)\\n        {\\n            int left_part = solve(start,i,arr);\\n            \\n            int right_part = solve(i+1,end,arr);\\n            \\n            int sum = left_part + right_part +  give_max(start,i,arr) * give_max(i+1,end,arr);\\n                                                //the 3rd condition product of max_element \\n                                                //of left and right subtree.\\n            \\n            ans = min(ans,sum);\\n        }\\n        \\n        return dp[start][end] = ans;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) \\n    {\\n        int n = arr.size();\\n        \\n        memset(dp,-1,sizeof(dp));\\n        \\n        return solve(0,n-1,arr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2302116,
                "title": "mcm-dp-c-easy-solution",
                "content": "MCM approach\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int dp[41][41];\\n    int mx(vector<int> &arr,int s,int e){\\n        int res = INT_MIN;\\n        for(int i=s;i<=e;i++){\\n            res = max(arr[i],res);\\n        }\\n        return res;\\n    }\\n    int solve(vector<int> &arr,int s,int e){\\n        if(s>=e){\\n            return 0;\\n        }\\n        if(dp[s][e]!=-1){\\n            return dp[s][e];\\n        }\\n        int ans = INT_MAX;\\n        for(int i=s;i<e;i++){\\n            int cost = solve(arr,s,i) + solve(arr,i+1,e) + mx(arr,s,i)*mx(arr,i+1,e);\\n            ans = min(ans,cost);\\n        }\\n        return dp[s][e] =  ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(arr,0,n-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[41][41];\\n    int mx(vector<int> &arr,int s,int e){\\n        int res = INT_MIN;\\n        for(int i=s;i<=e;i++){\\n            res = max(arr[i],res);\\n        }\\n        return res;\\n    }\\n    int solve(vector<int> &arr,int s,int e){\\n        if(s>=e){\\n            return 0;\\n        }\\n        if(dp[s][e]!=-1){\\n            return dp[s][e];\\n        }\\n        int ans = INT_MAX;\\n        for(int i=s;i<e;i++){\\n            int cost = solve(arr,s,i) + solve(arr,i+1,e) + mx(arr,s,i)*mx(arr,i+1,e);\\n            ans = min(ans,cost);\\n        }\\n        return dp[s][e] =  ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        int n = arr.size();\\n        memset(dp,-1,sizeof(dp));\\n        return solve(arr,0,n-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284694,
                "title": "python-solution",
                "content": "```\\n**DP will take O(N3) time So avoid it**\\n\\nFind \\'minIdx\\' till length of array > 1\\nminSum += min(array[idx-1],array[idx+1])*array[idx]\\n\\nExample : array = [8,2,9,4,1]\\n\\narray = [8,2,9,4,1]\\nminIdx = 4  \\nminSum += min([4]+[])*array.pop(minIdx) --> 4*1\\n\\narray = [8,2,9,4]\\nminIdx = 1  \\nminSum += min([8]+[9])*array.pop(minIdx) -- >8*2\\n\\narray = [8,9,4]\\nminIdx = 2  \\nminSum += min([9]+[])*array.pop(minIdx) -- >9*4\\n\\narray = [8,9]\\nminIdx = 0\\nminSum += min([9]+[])*array.pop(minIdx) -- >9*8    \\n\\nminSum = 9*8+9*4+8*2+4*1\\n\\ndef mctFromLeafValues(self, array):\\n    def getMinIdx(array):\\n        minIdx = 0\\n        for idx in range(len(array)):\\n            if array[idx] < array[minIdx]:\\n                minIdx = idx\\n        return minIdx\\n    minSum = 0\\n    while len(array) >1:\\n        idx = getMinIdx(array)\\n        minSum += min(array[idx-1:idx]+array[idx+1:idx+2])*array.pop(idx)\\n    return minSum\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n**DP will take O(N3) time So avoid it**\\n\\nFind \\'minIdx\\' till length of array > 1\\nminSum += min(array[idx-1],array[idx+1])*array[idx]\\n\\nExample : array = [8,2,9,4,1]\\n\\narray = [8,2,9,4,1]\\nminIdx = 4  \\nminSum += min([4]+[])*array.pop(minIdx) --> 4*1\\n\\narray = [8,2,9,4]\\nminIdx = 1  \\nminSum += min([8]+[9])*array.pop(minIdx) -- >8*2\\n\\narray = [8,9,4]\\nminIdx = 2  \\nminSum += min([9]+[])*array.pop(minIdx) -- >9*4\\n\\narray = [8,9]\\nminIdx = 0\\nminSum += min([9]+[])*array.pop(minIdx) -- >9*8    \\n\\nminSum = 9*8+9*4+8*2+4*1\\n\\ndef mctFromLeafValues(self, array):\\n    def getMinIdx(array):\\n        minIdx = 0\\n        for idx in range(len(array)):\\n            if array[idx] < array[minIdx]:\\n                minIdx = idx\\n        return minIdx\\n    minSum = 0\\n    while len(array) >1:\\n        idx = getMinIdx(array)\\n        minSum += min(array[idx-1:idx]+array[idx+1:idx+2])*array.pop(idx)\\n    return minSum\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2279472,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Approach 1 :- Using Recursion && Memoization***\\n\\n* ***Time Complexity :- O(N ^ 3)***\\n\\n* ***Space Complexity :- O(N * N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[45][45];\\n    \\n    int helper(vector<int>& arr, int start, int end)\\n    {\\n        // base case, if there is only one leaf node then sum of non-leaf node will be zero\\n        \\n        if(start == end)\\n            return 0;\\n        \\n        // if already calculated\\n        \\n        if(dp[start][end] != -1)\\n            return dp[start][end];\\n        \\n        // find minimum sum, by trying all possible case\\n        \\n        int min_sum = INT_MAX;\\n        \\n        for(int idx = start; idx < end; idx++)\\n        {\\n            // sum of non-leaf nodes on left side\\n            \\n            int left_sum = helper(arr, start, idx);\\n            \\n            // sum of non-leaf nodes on right side\\n            \\n            int right_sum = helper(arr, idx + 1, end);\\n            \\n            // find maximum value of leaf node on left side\\n            \\n            int left_max = *max_element(arr.begin() + start, arr.begin() + idx + 1);\\n            \\n            // find maximum value of leaf node on right side\\n            \\n            int right_max = *max_element(arr.begin() + idx + 1, arr.begin() + end + 1);\\n            \\n            // find total sum\\n            \\n            int total_sum = left_sum + right_sum + left_max * right_max;\\n            \\n            // update min_sum\\n            \\n            min_sum = min(min_sum, total_sum);\\n        }\\n        \\n        // store the result in dp and return result\\n        \\n        return dp[start][end] = min_sum;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // call helper function\\n        \\n        return helper(arr, 0, n - 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // declare a dp\\n    \\n    int dp[45][45];\\n    \\n    int helper(vector<int>& arr, int start, int end)\\n    {\\n        // base case, if there is only one leaf node then sum of non-leaf node will be zero\\n        \\n        if(start == end)\\n            return 0;\\n        \\n        // if already calculated\\n        \\n        if(dp[start][end] != -1)\\n            return dp[start][end];\\n        \\n        // find minimum sum, by trying all possible case\\n        \\n        int min_sum = INT_MAX;\\n        \\n        for(int idx = start; idx < end; idx++)\\n        {\\n            // sum of non-leaf nodes on left side\\n            \\n            int left_sum = helper(arr, start, idx);\\n            \\n            // sum of non-leaf nodes on right side\\n            \\n            int right_sum = helper(arr, idx + 1, end);\\n            \\n            // find maximum value of leaf node on left side\\n            \\n            int left_max = *max_element(arr.begin() + start, arr.begin() + idx + 1);\\n            \\n            // find maximum value of leaf node on right side\\n            \\n            int right_max = *max_element(arr.begin() + idx + 1, arr.begin() + end + 1);\\n            \\n            // find total sum\\n            \\n            int total_sum = left_sum + right_sum + left_max * right_max;\\n            \\n            // update min_sum\\n            \\n            min_sum = min(min_sum, total_sum);\\n        }\\n        \\n        // store the result in dp and return result\\n        \\n        return dp[start][end] = min_sum;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        // initialize dp with -1\\n        \\n        memset(dp, -1, sizeof(dp));\\n        \\n        // call helper function\\n        \\n        return helper(arr, 0, n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2278082,
                "title": "50-tc-and-87-sc-easy-python-solution",
                "content": "```\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n\\tn = len(arr)\\n\\tdef dp(i, j):\\n\\t\\tif(i == j):\\n\\t\\t\\treturn 0\\n\\t\\tif(i+1 == j):\\n\\t\\t\\treturn arr[i] * arr[j]\\n\\t\\tif((i, j) in d):\\n\\t\\t\\treturn d[(i, j)]\\n\\t\\ttemp = float(\\'inf\\')\\n\\t\\tfor k in range(i, j):\\n\\t\\t\\ttemp =  min(temp, (max(arr[i:k+1]) * max(arr[k+1:j+1])) + dp(i, k) + dp(k+1, j))\\n\\t\\td[(i, j)] = temp\\n\\t\\treturn temp\\n\\td = dict()\\n\\treturn dp(0, n-1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef mctFromLeafValues(self, arr: List[int]) -> int:\\n\\tn = len(arr)\\n\\tdef dp(i, j):\\n\\t\\tif(i == j):\\n\\t\\t\\treturn 0\\n\\t\\tif(i+1 == j):\\n\\t\\t\\treturn arr[i] * arr[j]\\n\\t\\tif((i, j) in d):\\n\\t\\t\\treturn d[(i, j)]\\n\\t\\ttemp = float(\\'inf\\')\\n\\t\\tfor k in range(i, j):\\n\\t\\t\\ttemp =  min(temp, (max(arr[i:k+1]) * max(arr[k+1:j+1])) + dp(i, k) + dp(k+1, j))\\n\\t\\td[(i, j)] = temp\\n\\t\\treturn temp\\n\\td = dict()\\n\\treturn dp(0, n-1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2245481,
                "title": "c-faster-than-85-mcm-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[41][41];\\n    int maxelement[41][41];\\n    \\n    int helper(vector<int> &arr , int start, int end){\\n        if(end - start == 0){\\n            return 0;\\n        }\\n        if( end - start == 1){\\n            return arr[start]*arr[end];\\n        }\\n        if(dp[start][end] != -1){\\n            return dp[start][end];\\n        }\\n        \\n        int cost = INT_MAX;\\n\\n        for(int i = start ; i < end ; i++){\\n            cost = min(cost,helper(arr,start,i)+helper(arr,i+1,end)+(maxelement[start][i]*maxelement[i+1][end]));\\n        }\\n        return dp[start][end]=cost;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i = 0 ; i < arr.size() ; i++){\\n            int maxi = 0;\\n            for(int j = i ; j< arr.size() ; j++){\\n                maxi = max(arr[j],maxi);\\n                maxelement[i][j] = maxi;\\n            }\\n        }\\n        \\n        return helper(arr,0,arr.size()-1);\\n        \\n    }\\n    \\n};\\n```\\n\\nTime complexity = O(n^2)\\nSpace complexity = O(n^2)",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[41][41];\\n    int maxelement[41][41];\\n    \\n    int helper(vector<int> &arr , int start, int end){\\n        if(end - start == 0){\\n            return 0;\\n        }\\n        if( end - start == 1){\\n            return arr[start]*arr[end];\\n        }\\n        if(dp[start][end] != -1){\\n            return dp[start][end];\\n        }\\n        \\n        int cost = INT_MAX;\\n\\n        for(int i = start ; i < end ; i++){\\n            cost = min(cost,helper(arr,start,i)+helper(arr,i+1,end)+(maxelement[start][i]*maxelement[i+1][end]));\\n        }\\n        return dp[start][end]=cost;\\n    }\\n    \\n    int mctFromLeafValues(vector<int>& arr) {\\n        memset(dp,-1,sizeof(dp));\\n        \\n        for(int i = 0 ; i < arr.size() ; i++){\\n            int maxi = 0;\\n            for(int j = i ; j< arr.size() ; j++){\\n                maxi = max(arr[j],maxi);\\n                maxelement[i][j] = maxi;\\n            }\\n        }\\n        \\n        return helper(arr,0,arr.size()-1);\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154751,
                "title": "cpp-recursion-memoization-well-commented",
                "content": "# 1] Recursion \\n\\n\\t`\\n\\t/*\\n\\tReturn the pair of integers\\n\\tThe first one will be the max value of the leaf node in that subtree\\n\\tThe second one will be the minimum value of the sum of non-leaf nodes from left to right subtrees.\\n*/\\n\\n```\\npair<int, int> treeSum(vector<int>& arr, int st, int end) {\\n\\t// Base case when there is a leaf node.\\n\\tif (st == end) {\\n\\t\\treturn {arr[st], 0};\\n\\t}\\n\\n\\t/*\\n\\t   Create a two variables minSum to store the minimum sum of non-leaf nodes\\n\\t   and maxLeaf to store the maximum of leaf node\\n\\t*/\\n\\tint minSum = INT_MAX, maxLeaf = INT_MIN;\\n\\n\\t// Split the array at the every ith position.\\n\\tfor (int i = st; i < end; i++) {\\n\\t\\t// Calling on the left subarary.\\n\\t\\tpair<int, int> left = treeSum(arr, st, i);\\n\\n\\t\\t// Calling on the right subarray.\\n\\t\\tpair<int, int> right = treeSum(arr, i + 1, end);\\n\\n\\t\\tminSum = min(minSum, left.second + right.second + (left.first * right.first));\\n\\t\\tmaxLeaf = max(left.first, right.first);\\n\\t}\\n\\treturn {maxLeaf, minSum};\\n}`\\n```\\n```\\n int mctFromLeafValues(vector<int>& arr) {\\n        // Return the minimum sum as the answer.\\n\\t\\treturn treeSum(arr, 0, arr.size() - 1).second;\\n    }\\n```\\n\\n\\n# 2] Dynamic Programming (Top - Down)\\n\\n```\\npair<int, int> treeSum(vector<int>& arr, int st, int end , vector<vector<pair<int, int>>>& dp) {\\n\\t// Base case to check for leaf node.\\n\\tif (st == end) {\\n\\t\\treturn {arr[st], 0};\\n\\t}\\n\\n\\t// To check whether we have already calculated the solution of the subproblem.\\n\\tif (dp[st][end].second != -1) {\\n\\t\\treturn dp[st][end];\\n\\t}\\n\\n\\t/*\\n\\t   Create a two variables minSum to store the minimum sum of non-leaf nodes\\n\\t   and maxLeaf to store the maximum of leaf node\\n\\t*/\\n\\tint minSum = INT_MAX, maxLeaf = INT_MIN;\\n\\n\\t// Split the array at the every ith position.\\n\\tfor (int i = st; i < end; i++) {\\n\\t\\t// Calling on the left subarary.\\n\\t\\tpair<int, int> left = treeSum(arr, st, i , dp);\\n\\n\\t\\t// Calling on the right subarray.\\n\\t\\tpair<int, int> right = treeSum(arr, i + 1, end , dp);\\n\\t\\tminSum = min(minSum, left.second + right.second + (left.first * right.first));\\n\\t\\tmaxLeaf = max(left.first, right.first);\\n\\t}\\n\\n\\t// Storing the answer in the dp table before retuning the answer.\\n\\tdp[st][end] = {maxLeaf, minSum};\\n\\treturn dp[st][end];\\n}\\nint mctFromLeafValues(vector<int>& arr) {\\n\\t/*\\n\\t   Create a 2d Array of pairs \\'DP\\' intialise with zero. The first one will be the\\n\\t   max value of the leaf node in that subtree The second one will be the minimum\\n\\t   value of the sum of non-leaf nodes from left to right subtrees.\\n\\t*/\\n\\tvector<vector<pair<int, int>>> dp = vector<vector<pair<int, int>>>(arr.size(), vector<pair<int, int>>(arr.size(), {INT_MIN, -1}));\\n\\n\\treturn treeSum(arr, 0, arr.size() - 1 , dp).second;\\n}\\n```\\n*   Time complexity: O(N ^ 3)\\n    Space Complexity: O(N ^ 2)*\\n\\n\\n*hope this will help\\uD83D\\uDE01*\\n*Upvote ?*\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\npair<int, int> treeSum(vector<int>& arr, int st, int end) {\\n\\t// Base case when there is a leaf node.\\n\\tif (st == end) {\\n\\t\\treturn {arr[st], 0};\\n\\t}\\n\\n\\t/*\\n\\t   Create a two variables minSum to store the minimum sum of non-leaf nodes\\n\\t   and maxLeaf to store the maximum of leaf node\\n\\t*/\\n\\tint minSum = INT_MAX, maxLeaf = INT_MIN;\\n\\n\\t// Split the array at the every ith position.\\n\\tfor (int i = st; i < end; i++) {\\n\\t\\t// Calling on the left subarary.\\n\\t\\tpair<int, int> left = treeSum(arr, st, i);\\n\\n\\t\\t// Calling on the right subarray.\\n\\t\\tpair<int, int> right = treeSum(arr, i + 1, end);\\n\\n\\t\\tminSum = min(minSum, left.second + right.second + (left.first * right.first));\\n\\t\\tmaxLeaf = max(left.first, right.first);\\n\\t}\\n\\treturn {maxLeaf, minSum};\\n}`\\n```\n```\\n int mctFromLeafValues(vector<int>& arr) {\\n        // Return the minimum sum as the answer.\\n\\t\\treturn treeSum(arr, 0, arr.size() - 1).second;\\n    }\\n```\n```\\npair<int, int> treeSum(vector<int>& arr, int st, int end , vector<vector<pair<int, int>>>& dp) {\\n\\t// Base case to check for leaf node.\\n\\tif (st == end) {\\n\\t\\treturn {arr[st], 0};\\n\\t}\\n\\n\\t// To check whether we have already calculated the solution of the subproblem.\\n\\tif (dp[st][end].second != -1) {\\n\\t\\treturn dp[st][end];\\n\\t}\\n\\n\\t/*\\n\\t   Create a two variables minSum to store the minimum sum of non-leaf nodes\\n\\t   and maxLeaf to store the maximum of leaf node\\n\\t*/\\n\\tint minSum = INT_MAX, maxLeaf = INT_MIN;\\n\\n\\t// Split the array at the every ith position.\\n\\tfor (int i = st; i < end; i++) {\\n\\t\\t// Calling on the left subarary.\\n\\t\\tpair<int, int> left = treeSum(arr, st, i , dp);\\n\\n\\t\\t// Calling on the right subarray.\\n\\t\\tpair<int, int> right = treeSum(arr, i + 1, end , dp);\\n\\t\\tminSum = min(minSum, left.second + right.second + (left.first * right.first));\\n\\t\\tmaxLeaf = max(left.first, right.first);\\n\\t}\\n\\n\\t// Storing the answer in the dp table before retuning the answer.\\n\\tdp[st][end] = {maxLeaf, minSum};\\n\\treturn dp[st][end];\\n}\\nint mctFromLeafValues(vector<int>& arr) {\\n\\t/*\\n\\t   Create a 2d Array of pairs \\'DP\\' intialise with zero. The first one will be the\\n\\t   max value of the leaf node in that subtree The second one will be the minimum\\n\\t   value of the sum of non-leaf nodes from left to right subtrees.\\n\\t*/\\n\\tvector<vector<pair<int, int>>> dp = vector<vector<pair<int, int>>>(arr.size(), vector<pair<int, int>>(arr.size(), {INT_MIN, -1}));\\n\\n\\treturn treeSum(arr, 0, arr.size() - 1 , dp).second;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2150827,
                "title": "c-solution-using-optimal-merge",
                "content": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        //started merging from picking up minimum element\\n        int ans=0;\\n        while(arr.size()>1){\\n            int idx= min_element(arr.begin(),arr.end())- arr.begin();//minimum element\\'s idx\\n            if(idx== arr.size()-1){\\n                ans+= arr[idx]*arr[idx-1];\\n            }\\n            else if(idx==0){\\n                ans+= arr[idx]*arr[idx+1];\\n            }\\n            else{\\n                ans+= arr[idx]*min(arr[idx-1], arr[idx+1]);\\n            }\\n            arr.erase(arr.begin()+idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mctFromLeafValues(vector<int>& arr) {\\n        //started merging from picking up minimum element\\n        int ans=0;\\n        while(arr.size()>1){\\n            int idx= min_element(arr.begin(),arr.end())- arr.begin();//minimum element\\'s idx\\n            if(idx== arr.size()-1){\\n                ans+= arr[idx]*arr[idx-1];\\n            }\\n            else if(idx==0){\\n                ans+= arr[idx]*arr[idx+1];\\n            }\\n            else{\\n                ans+= arr[idx]*min(arr[idx-1], arr[idx+1]);\\n            }\\n            arr.erase(arr.begin()+idx);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148359,
                "title": "c-array-partition-with-recursion-memoization",
                "content": "```class Solution {\\npublic:\\n    map<pair<int,int>,int> mp;\\n    \\n    int maxx(int i,int j,vector<int>&vec){\\n        return *max_element(vec.begin()+i,vec.begin()+j+1);\\n    }\\n    \\n    int rec(vector<int>& vec,int i,int j){\\n        if(i == j){\\n            return 0;\\n        }\\n        if(mp[{i,j}] != 0) return mp[{i,j}];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k = i;k<j;k++){\\n            ans = min(ans,maxx(i,k,vec)*maxx(k+1,j,vec) + rec(vec,i,k) + rec(vec,k+1,j));\\n        }\\n        \\n        return mp[{i,j}] = ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        return rec(arr,0,arr.size()-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```class Solution {\\npublic:\\n    map<pair<int,int>,int> mp;\\n    \\n    int maxx(int i,int j,vector<int>&vec){\\n        return *max_element(vec.begin()+i,vec.begin()+j+1);\\n    }\\n    \\n    int rec(vector<int>& vec,int i,int j){\\n        if(i == j){\\n            return 0;\\n        }\\n        if(mp[{i,j}] != 0) return mp[{i,j}];\\n        \\n        int ans = INT_MAX;\\n        \\n        for(int k = i;k<j;k++){\\n            ans = min(ans,maxx(i,k,vec)*maxx(k+1,j,vec) + rec(vec,i,k) + rec(vec,k+1,j));\\n        }\\n        \\n        return mp[{i,j}] = ans;\\n    }\\n    int mctFromLeafValues(vector<int>& arr) {\\n        return rec(arr,0,arr.size()-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564613,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1564666,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1564918,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1676338,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1566176,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1574481,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1573293,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1569629,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1857578,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1576266,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1564613,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1564666,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1564918,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1676338,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1566176,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1574481,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1573293,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1569629,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1857578,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            },
            {
                "id": 1576266,
                "content": [
                    {
                        "username": "knightzf",
                        "content": "### DFS/DP solution\\n1. From the problem, we know the goal is to find an optimal way to convert the array into a tree.\\n2. However we don\\'t know what is the optimal way to divide the array into left and right subtrees.\\n3. Also notice that after division the array becomes 2 subarrays, now we have 2 subproblems.\\n4. As a result, let\\'s try all possible ways to divide the array. Same is recursively applied to subarrays. Use a 2d array for memorization.\\n### O(N^2) solution\\n1. From the first solution, we blindly try all possible ways to divide the array. But do we really have no idea of the optimal division?\\n2. We actually know a little better. In the final tree, value of non-leaf nodes are from maximum leaf values from left and right subtrees. \\n3. If in the final tree, the maximum value from the array is at deepest level of the tree, its value will be used multiple times for multiple parent nodes, which is obviously not ideal. \\n4. So the finding here is we should place the smallest value from array at deepest level. Smallest value here means the product of pair arr[i] and arr[i + 1] where the product is smallest.\\n5. What happens to the pair after that? The smaller of the pair will never be used again and we can simply discard it.\\n6. The O(N^2) solution is to go through the array, find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n### lee215\\'s O(N) solution\\n1. The second solution removes the less of pair arr[i] and arr[i + 1] which has minimum product during each iteration.\\n2. Now we think about it, each iteration actually removes a local minimum value. \\n\\t * For elements arr[i - 1], arr[i] and arr[i + 1] where arr[i] is the local minium.\\n\\t * The product added to final result is arr[i] * min(arr[i - 1], arr[i + 1])\\n3. The problem can be translated into removing all local minium values while finding the first greater element on the left and on the right.\\n4. A stack based solution from previous problems can be applied as lee215 mentioned in his post."
                    },
                    {
                        "username": "pthread",
                        "content": "DP in all possible BTs from leaf nodes array in order to produce the optimal solution?!?!?\\nYou have got to be kidding me, if this is a medium level problem."
                    },
                    {
                        "username": "ans121097",
                        "content": "Since given array is the inorder traversal of tree leaves. Their order won\\'t change. You can only decide which 2 consecutive nodes you wanna combine to make a new node by their product.\\n\\nSuppose array is [8,4,1,2,5] \\nYou can multiply two consecutive digits and their product will be added to resultant sum. And those 2 digits will be replaced my max of them.\\nEx-\\narr=8,4,1,2,5\\nsum-0;\\ni-) multiply 1,2 \\narr = 8,4,2,5 ( because 2>1)\\nand sum=2;\\nii-) multiply 4,2\\narr= 8,4,5 (because 4>2)\\nand sum=2+8=10;\\niii-) multiply 4,5\\narr= 8,5 (because 5>4)\\nand sum= 10+ 20 = 30;\\niv-) multiply 8,5\\nsum=30+40\\n\\nAnswer is 70.\\n\\nNow think how can you solve this :)\\n\\n*Feel free to ask question in comments, do upvote if you understood the intuition*"
                    },
                    {
                        "username": "ry129",
                        "content": "This question should be hard"
                    },
                    {
                        "username": "jimlinntu",
                        "content": "These illustrations explain the correctness of the most upvoted greedy approach here.\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space\\n\\n![image](https://assets.leetcode.com/users/images/92c68163-6bde-46fb-ab67-862c7f67b499_1619141168.3640873.png)\\n![image](https://assets.leetcode.com/users/images/458e751e-14cd-4dee-806d-cb36556ea0b8_1619141168.2951288.png)\\n![image](https://assets.leetcode.com/users/images/2b173ab6-054d-4ba4-96ec-988cf8bac681_1619141168.5808558.png)\\n![image](https://assets.leetcode.com/users/images/f1995944-3c2a-4a02-a1d3-f4f92c11d6b8_1619141168.2315059.png)\\n![image](https://assets.leetcode.com/users/images/08847a5e-d9fe-4283-a7a2-917afe069fd1_1619356585.7288036.png)\\n![image](https://assets.leetcode.com/users/images/675e13ab-f6e0-4905-a7a6-3c4999eef6c9_1619356585.4605606.png)\\n\\n"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "Now I don\\'t quite understand the illstration and explanation for the decreasing stack"
                    },
                    {
                        "username": "cloudoleon",
                        "content": "In claim 1, you mention \"You can see that green parts will contribute the same cost\" but I actually don't see it just from the illustration\n\nEdit: I actually get it now. It's cause if we merge a_i in the beginning, a_i will never be contributed, so it's as if we always only had a_i+1 from start"
                    },
                    {
                        "username": "james127",
                        "content": "weed weed weed"
                    },
                    {
                        "username": "kawabunga",
                        "content": "My algorithm tends to find solutions which are better than what the verification finds. Because of this, my submission is not accepted. Could someone tell me what it is I\\'m getting wrong here?\\n\\nExample input: [ 8,7,10,12]\\nMy output: 256\\nExpected output: 284\\n\\nThis is the tree that I\\'ve built:\\n\\n  \\t\\t  \\t\\t 120\\n\\t     \\t\\t/    \\\\\\n  \\t\\t\\t  80     12\\n\\t  \\t\\t/    \\\\\\n    \\t   56     10\\n   \\t  \\t  / \\\\\\n  \\t\\t 8   7      \\n\\nAs you can see, the non-leaf nodes are: 56+80+120 = 256\\n\\nSo why is the expected output 284? Is the tree above somehow wrong?\\n\\nI have another example with [2,4,7,6,8] ..."
                    },
                    {
                        "username": "cloudoleon",
                        "content": "maybe there was an error, but now the answer correctly gives 256"
                    },
                    {
                        "username": "mohamad99A",
                        "content": "i don\\'t know why 284 is the answer where there is a tree with value of 256 !!"
                    },
                    {
                        "username": "harsh700ca",
                        "content": "I don\\'t find the stack solution intuitive. I think a proof would be helpful. None of the explanations provide a proof."
                    },
                    {
                        "username": "Sansk_Ritu",
                        "content": "you can think of a proof this way: \" The values giiven here are leaf nodes of inorder traversal. Which means that there order within won\\'t change. So a basic solution could be by combining(multiplying) two consecutive leaf nodes to give a non leaf value and replacing them by max of both. Now the step I just mentioned here gives a clear image of a stack operation!\"\\n"
                    },
                    {
                        "username": "random142857",
                        "content": "A very simple explanation of why the greedy method works:\n\nEach time we merge two neighbouring numbers, the length of the original array reduces by $1$. Therefore, we need a total of $n - 1$ merge operations, whatever the order is.\n\nThere will always be some numbers that are reused to compute the products.\n\nHence, we just need to find a way to merge the numbers, so that we are never \"wasting\" the small numbers, and never introduce unnecessary reuses of large numbers.\n\nIn what cases can we argue that we are \"wasting\"?\n\nSuppose we are merging some number $a$ by its neighbour. However, if this number $a$ could have been used to merge some other number $b$, where $b < a$, then, merging $a$ in advance will be a waste, and we will be introducing the reuse of some other number that is larger than $a$.\n\nNote that it is possible that $b$ being merged by some number $c$, where $a > c > b$. However, in this case, we can argue that if we merge $a$ in advance, we are wasting because we could have been using $a$ to merge $c$, instead of merging $c$ with some other number that is larger than $a$. We can make assumptions on other possible numbers between $a$ and $c$ here, but by the end of the day, there will exist a number that is smaller than $a$, which could have been merged by $a$ but lost the opportunity because we merged $a$ in advance.\n\nOn the other hand, if such numbers do not exist, then either\n1. merging $a$ first or merging the smallest number first does not matter, as they are both not wasting.\n2. we cannot find the numbers that make merging $a$ be wasting because $a$ is already the smallest number.\n\nHence, there is one way to completely avoid any wasting. If we always greedily merge the smallest number $s$ in the current array, then we know that the smallest number $s$ can never be used to merge any other numbers. Merging $s$ is always a safe move that never causes wastes."
                    },
                    {
                        "username": "dhruvil1998",
                        "content": "i am using this approach : find the index i so that arr[i] * arr[i + 1] is the smallest (arr[i] * arr[i + 1] is added to the result) and discard the less of the pair. Keep doing so until arr size is 1.\\n\\nbut i also see some discussion on below approach :\\n\\nhttps://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/340014/Greedy-python-solution\\n\\nboth are diff ways , i found good intuition with my approach but i am not able to understand the 2nd approach given in above link can anyone explain why this method works"
                    }
                ]
            }
        ]
    }
]