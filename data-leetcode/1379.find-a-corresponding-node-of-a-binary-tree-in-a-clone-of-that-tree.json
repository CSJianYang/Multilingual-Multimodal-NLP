[
    {
        "title": "Longest ZigZag Path in a Binary Tree",
        "question_content": "You are given the root of a binary tree.\nA ZigZag path for a binary tree is defined as follow:\n\n\tChoose any node in the binary tree and a direction (right or left).\n\tIf the current direction is right, move to the right child of the current node; otherwise, move to the left child.\n\tChange the direction from right to left or from left to right.\n\tRepeat the second and third steps until you can't move in the tree.\n\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\nReturn the longest ZigZag path contained in that tree.\n&nbsp;\nExample 1:\n\nInput: root = [1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\nOutput: 3\nExplanation: Longest ZigZag path in blue nodes (right -> left -> right).\n\nExample 2:\n\nInput: root = [1,1,1,null,1,null,null,1,1,null,1]\nOutput: 4\nExplanation: Longest ZigZag path in blue nodes (left -> right -> left -> right).\n\nExample 3:\n\nInput: root = [1]\nOutput: 0\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 5 * 104].\n\t1 <= Node.val <= 100",
        "solutions": [
            {
                "id": 531867,
                "title": "java-python-dfs-solution",
                "content": "## **Explanation**\\nRecursive return `[left, right, result]`, where:\\n`left` is the maximum length in direction of `root.left`\\n`right` is the maximum length in direction of `root.right`\\n`result` is the maximum length in the whole sub tree.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(height)`\\n<br>\\n\\n**Java**\\n```java\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root)[2];\\n    }\\n\\n    private int[] dfs(TreeNode root) {\\n        if (root == null) return new int[]{-1, -1, -1};\\n        int[] left = dfs(root.left), right = dfs(root.right);\\n        int res = Math.max(Math.max(left[1], right[0]) + 1, Math.max(left[2], right[2]));\\n        return new int[]{left[1] + 1, right[0] + 1, res};\\n    }\\n```\\n**C++**\\nby @SuperWhw\\n```cpp\\n    int longestZigZag(TreeNode* root) {\\n        return dfs(root)[2];\\n    }\\n\\n    vector<int> dfs(TreeNode* root) {\\n        if (!root) return { -1, -1, -1};\\n        vector<int> left = dfs(root->left), right = dfs(root->right);\\n        int res = max(max(left[1], right[0]) + 1, max(left[2], right[2]));\\n        return {left[1] + 1, right[0] + 1, res};\\n    }\\n```\\n**Python:**\\n```py\\n    def longestZigZag(self, root):\\n        def dfs(root):\\n            if not root: return [-1, -1, -1]\\n            left, right = dfs(root.left), dfs(root.right)\\n            return [left[1] + 1, right[0] + 1, max(left[1] + 1, right[0] + 1, left[2], right[2])]\\n        return dfs(root)[-1]\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root)[2];\\n    }\\n\\n    private int[] dfs(TreeNode root) {\\n        if (root == null) return new int[]{-1, -1, -1};\\n        int[] left = dfs(root.left), right = dfs(root.right);\\n        int res = Math.max(Math.max(left[1], right[0]) + 1, Math.max(left[2], right[2]));\\n        return new int[]{left[1] + 1, right[0] + 1, res};\\n    }\\n```\n```cpp\\n    int longestZigZag(TreeNode* root) {\\n        return dfs(root)[2];\\n    }\\n\\n    vector<int> dfs(TreeNode* root) {\\n        if (!root) return { -1, -1, -1};\\n        vector<int> left = dfs(root->left), right = dfs(root->right);\\n        int res = max(max(left[1], right[0]) + 1, max(left[2], right[2]));\\n        return {left[1] + 1, right[0] + 1, res};\\n    }\\n```\n```py\\n    def longestZigZag(self, root):\\n        def dfs(root):\\n            if not root: return [-1, -1, -1]\\n            left, right = dfs(root.left), dfs(root.right)\\n            return [left[1] + 1, right[0] + 1, max(left[1] + 1, right[0] + 1, left[2], right[2])]\\n        return dfs(root)[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 534418,
                "title": "java-c-dfs-solution-with-comment-o-n-clean-code",
                "content": "**Java**\\n```java\\nclass Solution {\\n    int maxStep = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, true, 0);\\n        dfs(root, false, 0);\\n        return maxStep;\\n    }\\n    private void dfs(TreeNode root, boolean isLeft, int step) {\\n        if (root == null) return;\\n        maxStep = Math.max(maxStep, step); // update max step sofar\\n        if (isLeft) {\\n            dfs(root.left, false, step + 1); // keep going from root to left\\n            dfs(root.right, true, 1); // restart going from root to right\\n        } else {\\n            dfs(root.right, true, step + 1); // keep going from root to right\\n            dfs(root.left, false, 1); // restart going from root to left\\n        }\\n    }\\n}\\n```\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    int maxStep = 0;\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root, true, 0);\\n        dfs(root, false, 0);\\n        return maxStep;\\n    }\\n    void dfs(TreeNode* root, bool isLeft, int step) {\\n        if (!root) return;\\n        maxStep = max(maxStep, step); // update max step sofar\\n        if (isLeft) {\\n            dfs(root->left, false, step + 1); // keep going from root to left\\n            dfs(root->right, true, 1); // restart going from root to right\\n        } else {\\n            dfs(root->right, true, step + 1); // keep going from root to right\\n            dfs(root->left, false, 1); // restart going from root to left\\n        }\\n    }\\n};\\n```\\nComplexity:\\n- Time: `O(n)`, it will visit all the nodes and each node once.\\n- Space: `O(h)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int maxStep = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, true, 0);\\n        dfs(root, false, 0);\\n        return maxStep;\\n    }\\n    private void dfs(TreeNode root, boolean isLeft, int step) {\\n        if (root == null) return;\\n        maxStep = Math.max(maxStep, step); // update max step sofar\\n        if (isLeft) {\\n            dfs(root.left, false, step + 1); // keep going from root to left\\n            dfs(root.right, true, 1); // restart going from root to right\\n        } else {\\n            dfs(root.right, true, step + 1); // keep going from root to right\\n            dfs(root.left, false, 1); // restart going from root to left\\n        }\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int maxStep = 0;\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root, true, 0);\\n        dfs(root, false, 0);\\n        return maxStep;\\n    }\\n    void dfs(TreeNode* root, bool isLeft, int step) {\\n        if (!root) return;\\n        maxStep = max(maxStep, step); // update max step sofar\\n        if (isLeft) {\\n            dfs(root->left, false, step + 1); // keep going from root to left\\n            dfs(root->right, true, 1); // restart going from root to right\\n        } else {\\n            dfs(root->right, true, step + 1); // keep going from root to right\\n            dfs(root->left, false, 1); // restart going from root to left\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1159847,
                "title": "c-easy-simple-traversal",
                "content": "Parameters:\\nl = count of max zigzag which reaches current Node by moving LEFT  from par  Node.\\nr = count of max zigzag which reaches current Node by moving RIGHT from par Node.\\n- Now update ans upto current node\\n- then send l+1 to RIGHT\\n- and r+1 to LEFT\\nPlease \\uD83D\\uDE4F  do upvote \\uD83D\\uDC4D if you find my solution apt\\uD83E\\uDD18\\n```\\nvoid ziggy(TreeNode* root, int l , int r, int& ans){\\n        if(!root) return;\\n         ans = max(ans, l);\\n         ans = max(ans, r);\\n        ziggy(root->left, 0, l+1, ans);\\n        \\n        ziggy(root->right, r+1, 0, ans);\\n        \\n        return;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int l=0;\\n        int r=0;\\n        int ans=0;\\n        ziggy(root, l,r,ans);\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nvoid ziggy(TreeNode* root, int l , int r, int& ans){\\n        if(!root) return;\\n         ans = max(ans, l);\\n         ans = max(ans, r);\\n        ziggy(root->left, 0, l+1, ans);\\n        \\n        ziggy(root->right, r+1, 0, ans);\\n        \\n        return;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int l=0;\\n        int r=0;\\n        int ans=0;\\n        ziggy(root, l,r,ans);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433060,
                "title": "image-explanation-easy-complete-intuition-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Longest ZigZag Path in a Binary Tree` by `Aryan Mittal`\\n![Microsoft5.png](https://assets.leetcode.com/users/images/95f272ac-7e6c-4122-a4f2-eee277eae354_1681870513.1834931.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/dc700053-7e28-4c89-9ccb-9b8eea23527b_1681866335.4239633.png)\\n![image.png](https://assets.leetcode.com/users/images/8408a910-3d92-4f43-9ea9-93bad63ae219_1681866345.8971014.png)\\n![image.png](https://assets.leetcode.com/users/images/4d52de15-84e1-4195-b926-a32a5a9a9263_1681866360.3134615.png)\\n![image.png](https://assets.leetcode.com/users/images/cb3f3fb3-3880-4d9b-b53f-a17dcb8c4c69_1681866371.5972638.png)\\n![image.png](https://assets.leetcode.com/users/images/3ae64e23-b322-4456-84fe-2ee3afc519bc_1681866383.361797.png)\\n![image.png](https://assets.leetcode.com/users/images/ef889cfa-8a54-45d7-ab07-cce747455a6a_1681866390.8031855.png)\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\n    public:\\n    int maxLength=0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength=max(maxLength,currLength);\\n        solve(root->left,0,dir?currLength+1:1);\\n        solve(root->right,1,dir?1:currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxLength=0;\\n    public void solve(TreeNode root,int dir,int currLength){\\n        if(root==null) return;\\n        maxLength=Math.max(maxLength,currLength);\\n        if(dir==1){\\n            solve(root.left,0,currLength+1);\\n            solve(root.right,1,1);\\n        }\\n        else{\\n            solve(root.right,1,currLength+1);\\n            solve(root.left,0,1);\\n        }\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.maxLength = 0\\n        def solve(node, deep, dir):\\n            self.maxLength = max(self.maxLength, deep)\\n\\n            if node.left is not None:\\n                solve(node.left, deep+1,\\'left\\') if dir != \\'left\\' else solve(node.left, 1, \\'left\\')\\n            if node.right is not None:\\n                solve(node.right, deep+1, \\'right\\') if dir != \\'right\\' else solve(node.right, 1, \\'right\\')\\n        solve(root, 0, \\'\\')\\n        return self.maxLength\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```C++ []\\nclass Solution {\\n    public:\\n    int maxLength=0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength=max(maxLength,currLength);\\n        solve(root->left,0,dir?currLength+1:1);\\n        solve(root->right,1,dir?1:currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxLength=0;\\n    public void solve(TreeNode root,int dir,int currLength){\\n        if(root==null) return;\\n        maxLength=Math.max(maxLength,currLength);\\n        if(dir==1){\\n            solve(root.left,0,currLength+1);\\n            solve(root.right,1,1);\\n        }\\n        else{\\n            solve(root.right,1,currLength+1);\\n            solve(root.left,0,1);\\n        }\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.maxLength = 0\\n        def solve(node, deep, dir):\\n            self.maxLength = max(self.maxLength, deep)\\n\\n            if node.left is not None:\\n                solve(node.left, deep+1,\\'left\\') if dir != \\'left\\' else solve(node.left, 1, \\'left\\')\\n            if node.right is not None:\\n                solve(node.right, deep+1, \\'right\\') if dir != \\'right\\' else solve(node.right, 1, \\'right\\')\\n        solve(root, 0, \\'\\')\\n        return self.maxLength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531880,
                "title": "simple-java-code-with-comments",
                "content": "```\\nstatic int max = 0;\\npublic static int longestZigZag(TreeNode root) {\\n        if (root == null) return -1;// if null return -1\\n        max = 0;\\n        helper(root.right, 1, true);// go right\\n        helper(root.left, 1, false);// go left\\n        return max;\\n    }\\n\\n    private static void helper(TreeNode root, int step, boolean isRight) {\\n        if (root == null) return;\\n        max = Math.max(max, step);\\n        if (isRight) {// if coming from right go left\\n            helper(root.left, step + 1, false);\\n            helper(root.right, 1, true);//try again from start\\n        } else {// else coming from left then go right\\n            helper(root.right, step + 1, true);\\n            helper(root.left, 1, false);\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int max = 0;\\npublic static int longestZigZag(TreeNode root) {\\n        if (root == null) return -1;// if null return -1\\n        max = 0;\\n        helper(root.right, 1, true);// go right\\n        helper(root.left, 1, false);// go left\\n        return max;\\n    }\\n\\n    private static void helper(TreeNode root, int step, boolean isRight) {\\n        if (root == null) return;\\n        max = Math.max(max, step);\\n        if (isRight) {// if coming from right go left\\n            helper(root.left, step + 1, false);\\n            helper(root.right, 1, true);//try again from start\\n        } else {// else coming from left then go right\\n            helper(root.right, step + 1, true);\\n            helper(root.left, 1, false);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433417,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n>To find the longest zigzag path in a binary tree, we can traverse the tree using DFS (Depth-First-Search) and at each node, keep track of the maximum length of the zigzag path seen so far.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>1. Initialize a variable ans to 0 to keep track of the maximum length of the zigzag path seen so far.\\n>2. Initialize a stack with the root node and two additional values n (the length of the zigzag path seen so far) and left (a boolean value indicating if the last traversal was to the left or not, where None represents the root node).\\n>3. Pop a node, n, and left from the stack.\\n>4. If the node is not None, update ans to max(ans, n).\\n>5. Add the left child to the stack with n + 1 as the new length and set left to 1 (indicating the last traversal was to the left) if the previous node was to the left or None, else set left to 0 (indicating the last traversal was to the right).\\n>6. Add the right child to the stack with n + 1 as the new length and set left to 0 (indicating the last traversal was to the right) if the previous node was to the right or None, else set left to 1 (indicating the last traversal was to the left).\\n>7. Repeat steps 3-6 until the stack is empty.\\n>8. Return ans\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n >O(N) where N is the number of nodes in the tree, as we visit every node exactly once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>O(N) as we need to store all the nodes in the worst case (i.e., a skewed tree).\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n```java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        int ans = 0;\\n        Stack<Triplet> stack = new Stack<>();\\n        stack.push(new Triplet(root, 0, null));\\n        while (!stack.isEmpty()) {\\n            Triplet triplet = stack.pop();\\n            TreeNode node = triplet.node;\\n            int n = triplet.n;\\n            Integer left = triplet.left;\\n            if (node != null) {\\n                ans = Math.max(ans, n);\\n                stack.push(new Triplet(node.left, left != null && left == 0 ? n + 1 : 1, 1));\\n                stack.push(new Triplet(node.right, left != null && left == 1 ? n + 1 : 1, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass Triplet {\\n    TreeNode node;\\n    int n;\\n    Integer left;\\n    \\n    public Triplet(TreeNode node, int n, Integer left) {\\n        this.node = node;\\n        this.n = n;\\n        this.left = left;\\n    }\\n}\\n\\n```\\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def longestZigZag(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        stack = [(root, 0, None)]\\n        while stack:\\n            node, n, left = stack.pop()\\n            if node:\\n                ans = max(ans, n)\\n                stack.append((node.left, 1 if left else n + 1, 1))\\n                stack.append((node.right, n + 1 if left else 1, 0))\\n        return ans\\n\\n```\\n\\n\\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar longestZigZag = function(root) {\\n    let ans = 0;\\n    const stack = [[root, 0, null]];\\n    while (stack.length > 0) {\\n        const [node, n, left] = stack.pop();\\n        if (node) {\\n            ans = Math.max(ans, n);\\n            stack.push([node.left, left != null && left == 0 ? n + 1 : 1, 1]);\\n            stack.push([node.right, left != null && left == 1 ? n + 1 : 1, 0]);\\n        }\\n    }\\n    return ans;\\n};\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        int ans = 0;\\n        Stack<Triplet> stack = new Stack<>();\\n        stack.push(new Triplet(root, 0, null));\\n        while (!stack.isEmpty()) {\\n            Triplet triplet = stack.pop();\\n            TreeNode node = triplet.node;\\n            int n = triplet.n;\\n            Integer left = triplet.left;\\n            if (node != null) {\\n                ans = Math.max(ans, n);\\n                stack.push(new Triplet(node.left, left != null && left == 0 ? n + 1 : 1, 1));\\n                stack.push(new Triplet(node.right, left != null && left == 1 ? n + 1 : 1, 0));\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass Triplet {\\n    TreeNode node;\\n    int n;\\n    Integer left;\\n    \\n    public Triplet(TreeNode node, int n, Integer left) {\\n        this.node = node;\\n        this.n = n;\\n        this.left = left;\\n    }\\n}\\n\\n```\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution(object):\\n    def longestZigZag(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: int\\n        \"\"\"\\n        ans = 0\\n        stack = [(root, 0, None)]\\n        while stack:\\n            node, n, left = stack.pop()\\n            if node:\\n                ans = max(ans, n)\\n                stack.append((node.left, 1 if left else n + 1, 1))\\n                stack.append((node.right, n + 1 if left else 1, 0))\\n        return ans\\n\\n```\n```javascript []\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar longestZigZag = function(root) {\\n    let ans = 0;\\n    const stack = [[root, 0, null]];\\n    while (stack.length > 0) {\\n        const [node, n, left] = stack.pop();\\n        if (node) {\\n            ans = Math.max(ans, n);\\n            stack.push([node.left, left != null && left == 0 ? n + 1 : 1, 1]);\\n            stack.push([node.right, left != null && left == 1 ? n + 1 : 1, 0]);\\n        }\\n    }\\n    return ans;\\n};\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531990,
                "title": "python-bfs-solution",
                "content": "BFS with queue\\nMain structure is `[node, from_, zigzag_len]`, where\\n`node` - is a current node,\\n`from_` - string with info about previous move (may be \\'l\\' if I came to current node from left or \\'r\\' if I came from left)\\n`zigzag_len` - length of zigzag path\\n\\nUPDATE: Thank you, @bunnyd! I updated code.\\n\\n```Python\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0   \\n        \\n        deq = deque()\\n        max_zigzag_size = 0\\n        \\n        if root.left:\\n            deq.append((root.left, \\'l\\', 1))\\n        if root.right:\\n            deq.append((root.right, \\'r\\', 1))\\n\\n        while deq:\\n            node, from_, zigzag_size = deq.popleft()\\n            max_zigzag_size = max(zigzag_size, max_zigzag_size) # update max len of zigzag path\\n            if node.left:\\n                if from_ == \\'l\\':  # if came from left\\n                    deq.append((node.left, \"l\", 1)) # set length of zigzag path to 1\\n                if from_ == \\'r\\':  # if came from right\\n                    deq.append((node.left, \"l\", zigzag_size + 1)) # increase length of zigzag path \\n            if node.right:\\n                if from_ == \\'l\\':\\n                    deq.append((node.right, \"r\", zigzag_size + 1))\\n                if from_ == \\'r\\':\\n                    deq.append((node.right, \"r\", 1))\\n        return max_zigzag_size  \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```Python\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        if not root:\\n            return 0   \\n        \\n        deq = deque()\\n        max_zigzag_size = 0\\n        \\n        if root.left:\\n            deq.append((root.left, \\'l\\', 1))\\n        if root.right:\\n            deq.append((root.right, \\'r\\', 1))\\n\\n        while deq:\\n            node, from_, zigzag_size = deq.popleft()\\n            max_zigzag_size = max(zigzag_size, max_zigzag_size) # update max len of zigzag path\\n            if node.left:\\n                if from_ == \\'l\\':  # if came from left\\n                    deq.append((node.left, \"l\", 1)) # set length of zigzag path to 1\\n                if from_ == \\'r\\':  # if came from right\\n                    deq.append((node.left, \"l\", zigzag_size + 1)) # increase length of zigzag path \\n            if node.right:\\n                if from_ == \\'l\\':\\n                    deq.append((node.right, \"r\", zigzag_size + 1))\\n                if from_ == \\'r\\':\\n                    deq.append((node.right, \"r\", 1))\\n        return max_zigzag_size  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 531808,
                "title": "java-recursion-try-each-node-as-a-zigzag-root-then-return-valid-sum-to-parent",
                "content": "```java\\nclass Solution {\\n    int result = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, true);\\n        return result;\\n    }\\n    \\n    public int dfs(TreeNode node, boolean isLeft){\\n        if(node == null){\\n            return 0;\\n        }\\n        //try start here\\n        int l = dfs(node.left, false);\\n        int r = dfs(node.right, true);\\n        result = Math.max(result, l);\\n        result = Math.max(result, r);\\n        //return sum for parent\\n        return 1 + (isLeft ? l : r);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    int result = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, true);\\n        return result;\\n    }\\n    \\n    public int dfs(TreeNode node, boolean isLeft){\\n        if(node == null){\\n            return 0;\\n        }\\n        //try start here\\n        int l = dfs(node.left, false);\\n        int r = dfs(node.right, true);\\n        result = Math.max(result, l);\\n        result = Math.max(result, r);\\n        //return sum for parent\\n        return 1 + (isLeft ? l : r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534863,
                "title": "c-minimalizm",
                "content": "Traverse the tree tracking whether we come from `left` or not.\\n- Continue traversing in the oposite direction and increment `depth`.\\n- Or, start a new traversal in the same direction, resetting `depth` to zero. \\n\\n```cpp\\nint dfs(TreeNode* n, bool left, int depth) {\\n    return n == nullptr ? depth : \\n        max(dfs(left ? n->left : n->right, !left, depth + 1),\\n            dfs(left ? n->right : n->left, left, 0));\\n}\\nint longestZigZag(TreeNode* root) {\\n    return max(dfs(root, true, -1), dfs(root, false, -1));\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dfs(TreeNode* n, bool left, int depth) {\\n    return n == nullptr ? depth : \\n        max(dfs(left ? n->left : n->right, !left, depth + 1),\\n            dfs(left ? n->right : n->left, left, 0));\\n}\\nint longestZigZag(TreeNode* root) {\\n    return max(dfs(root, true, -1), dfs(root, false, -1));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433160,
                "title": "leetcode-the-hard-way-dfs-explained-line-by-line",
                "content": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\n // TC: O(n)\\n // SC: O(n)\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root, int isLeft, int cnt) {\\n        // root is nullptr, we can return `cnt`\\n        if (!root) return cnt;\\n        // if `isLeft` is true, we have two choices\\n        // 1. go to right making a zipzag path - increase the cnt by 1 \\n        // 2. still go to left - starting a new zigzag path - hence cnt is set to 0\\n        if (isLeft) return max(dfs(root->right, 0, cnt + 1), dfs(root->left, 1, 0));\\n        // similarly, we apply the same logic for the opposite direction\\n        return max(dfs(root->left, 1, cnt + 1), dfs(root->right, 0, 0));\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        // go through left-subtree and right-subtree\\n        // get the max result\\n        return max(dfs(root->left, 1, 0), dfs(root->right, 0, 0));\\n    }\\n};\\n```\\n\\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node, isLeft, cnt):\\n            # root is None, we can return `cnt`\\n            if node is None: return cnt\\n            # if `isLeft` is true, we have two choices\\n            # 1. go to right making a zipzag path - increase the cnt by 1\\n            # 2. still go to left - starting a new zigzag path - hence cnt is set to 0\\n            if isLeft:  return max(dfs(node.right, 0, cnt + 1), dfs(node.left, 1, 0))\\n            # similarly, we apply the same logic for the opposite direction\\n            return max(dfs(node.left, 1, cnt + 1), dfs(node.right, 0, 0))\\n        # go through left-subtree and right-subtree and get the max result\\n        return max(dfs(root.left, 1, 0), dfs(root.right, 0, 0))\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\n // TC: O(n)\\n // SC: O(n)\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* root, int isLeft, int cnt) {\\n        // root is nullptr, we can return `cnt`\\n        if (!root) return cnt;\\n        // if `isLeft` is true, we have two choices\\n        // 1. go to right making a zipzag path - increase the cnt by 1 \\n        // 2. still go to left - starting a new zigzag path - hence cnt is set to 0\\n        if (isLeft) return max(dfs(root->right, 0, cnt + 1), dfs(root->left, 1, 0));\\n        // similarly, we apply the same logic for the opposite direction\\n        return max(dfs(root->left, 1, cnt + 1), dfs(root->right, 0, 0));\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        // go through left-subtree and right-subtree\\n        // get the max result\\n        return max(dfs(root->left, 1, 0), dfs(root->right, 0, 0));\\n    }\\n};\\n```\n```py\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def dfs(node, isLeft, cnt):\\n            # root is None, we can return `cnt`\\n            if node is None: return cnt\\n            # if `isLeft` is true, we have two choices\\n            # 1. go to right making a zipzag path - increase the cnt by 1\\n            # 2. still go to left - starting a new zigzag path - hence cnt is set to 0\\n            if isLeft:  return max(dfs(node.right, 0, cnt + 1), dfs(node.left, 1, 0))\\n            # similarly, we apply the same logic for the opposite direction\\n            return max(dfs(node.left, 1, cnt + 1), dfs(node.right, 0, 0))\\n        # go through left-subtree and right-subtree and get the max result\\n        return max(dfs(root.left, 1, 0), dfs(root.right, 0, 0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433646,
                "title": "c-easy-recursion-approach-beats-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        if(!root->right && !root->left)\\n            return 0;\\n        return solve(root, 0, false);\\n    }\\n    int solve(TreeNode* root, int length, bool shouldGoLeft) {\\n        if(!root)\\n            return length;\\n\\n        int left = 0;\\n        int right = 0;\\n        int tmp = 0;\\n\\n        if(shouldGoLeft && !root->left) {\\n            tmp = length;\\n            length = 0;\\n        } else if(!shouldGoLeft && !root->right) {\\n            tmp = length;\\n            length = 0;\\n        }\\n\\n        right = solve(root->right, shouldGoLeft ? 1: length + 1, true);\\n        left = solve(root->left, shouldGoLeft ? length + 1 : 1, false);\\n\\n        return std::max({left, right, tmp});\\n    }\\n};\\n```\\n![_za_kompom_yapfiles.ru-min (online-video-cutter.com).gif](https://assets.leetcode.com/users/images/255a229e-59b8-4d7a-b910-87108c171e71_1681884320.5500047.gif)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        if(!root->right && !root->left)\\n            return 0;\\n        return solve(root, 0, false);\\n    }\\n    int solve(TreeNode* root, int length, bool shouldGoLeft) {\\n        if(!root)\\n            return length;\\n\\n        int left = 0;\\n        int right = 0;\\n        int tmp = 0;\\n\\n        if(shouldGoLeft && !root->left) {\\n            tmp = length;\\n            length = 0;\\n        } else if(!shouldGoLeft && !root->right) {\\n            tmp = length;\\n            length = 0;\\n        }\\n\\n        right = solve(root->right, shouldGoLeft ? 1: length + 1, true);\\n        left = solve(root->left, shouldGoLeft ? length + 1 : 1, false);\\n\\n        return std::max({left, right, tmp});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433024,
                "title": "c-recursion",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res = 0;\\n\\n    void solve(TreeNode* node, bool goLeft, int currPathLen) {\\n        if (!node) return;\\n        res = max(res, currPathLen);\\n        if (goLeft) {\\n            solve(node->left, false, currPathLen + 1);\\n            solve(node->right, true, 1);\\n        } else {\\n            solve(node->right, true, currPathLen + 1);\\n            solve(node->left, false, 1);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root, true, 0);\\n        solve(root, false, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int res = 0;\\n\\n    void solve(TreeNode* node, bool goLeft, int currPathLen) {\\n        if (!node) return;\\n        res = max(res, currPathLen);\\n        if (goLeft) {\\n            solve(node->left, false, currPathLen + 1);\\n            solve(node->right, true, 1);\\n        } else {\\n            solve(node->right, true, currPathLen + 1);\\n            solve(node->left, false, 1);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root, true, 0);\\n        solve(root, false, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432989,
                "title": "dfs-solution-with-explanation-c-go",
                "content": "My approach is DFS. My `DFS` function takes `TreeNode`(current node), `bool`(direction), `int`(ZigZag count).\\nWe have two options:\\n1. We continue with direction (if previous was right, we go to left, else we go to right) and increment count. \\n2. We coutinue with another direction (if previous was right, we go to right, else we go to left) and reset count.\\n\\nAnd we choose maximum from this two options.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(depth)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nC#\\n```\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root) {\\n        return Math.Max(DFS(root.left, true, 0), DFS(root.right, false, 0));\\n    }\\n\\n    int DFS(TreeNode node, bool isLeft, int count) {\\n        if (node == null) {\\n            return count;\\n        }\\n\\n        if (isLeft) {\\n            return Math.Max(DFS(node.left, true, 0), DFS(node.right, false, count+1));\\n        }\\n        return Math.Max(DFS(node.left, true, count+1), DFS(node.right, false, 0));\\n    }\\n}\\n```\\nGo\\n```\\nfunc longestZigZag(root *TreeNode) int {\\n\\treturn max(dfs(root.Left, true, 0), dfs(root.Right, false, 0))\\n}\\n\\nfunc dfs(node *TreeNode, isLeft bool, count int) int {\\n\\tif node == nil {\\n\\t\\treturn count\\n\\t}\\n\\n\\tif isLeft {\\n\\t\\treturn max(dfs(node.Left, true, 0), dfs(node.Right, false, count+1))\\n\\t}\\n\\n\\treturn max(dfs(node.Left, true, count+1), dfs(node.Right, false, 0))\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root) {\\n        return Math.Max(DFS(root.left, true, 0), DFS(root.right, false, 0));\\n    }\\n\\n    int DFS(TreeNode node, bool isLeft, int count) {\\n        if (node == null) {\\n            return count;\\n        }\\n\\n        if (isLeft) {\\n            return Math.Max(DFS(node.left, true, 0), DFS(node.right, false, count+1));\\n        }\\n        return Math.Max(DFS(node.left, true, count+1), DFS(node.right, false, 0));\\n    }\\n}\\n```\n```\\nfunc longestZigZag(root *TreeNode) int {\\n\\treturn max(dfs(root.Left, true, 0), dfs(root.Right, false, 0))\\n}\\n\\nfunc dfs(node *TreeNode, isLeft bool, count int) int {\\n\\tif node == nil {\\n\\t\\treturn count\\n\\t}\\n\\n\\tif isLeft {\\n\\t\\treturn max(dfs(node.Left, true, 0), dfs(node.Right, false, count+1))\\n\\t}\\n\\n\\treturn max(dfs(node.Left, true, count+1), dfs(node.Right, false, 0))\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532399,
                "title": "java-beats-100-percent-with-explanation",
                "content": "I never liked a code which is succint but hard to understand. Specially you need to remember there will be others too who will look at that code and may need to do refactoring. Always liked a code which is easy to understand.\\n\\n```\\npublic int longestZigZag(TreeNode root) {\\n        return longestZigZagHelper(root, 0, 0, true, true);\\n    }\\n\\n    /**\\n\\t * max - current max as we go down to traverse the tree, while coming up it becomes the max possible in that branch \\n\\t * curMax - current max as we go down to travere the tree\\n     * fromLeft - did we land on node as left child\\n     * fromRight - did we land on node as right child\\n     */\\n    private int longestZigZagHelper(TreeNode node, int curMax, int max, boolean fromLeft, boolean fromRight) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        if (node.left == null && node.right == null) {\\n            /**\\n             * when we hit a child node, return the max to upper node.\\n             */\\n            return max;\\n        }\\n        int leftMax = Integer.MIN_VALUE;\\n        if (node.left != null) {\\n            if (fromLeft) {\\n                /**\\n                 * To handle cases like\\n                 *         1\\n                 *        / \\\\      at least max should be 1.\\n                 *       1   1\\n                 */\\n                max = Math.max(max, 1);\\n                leftMax = longestZigZagHelper(node.left, 1, max, true, false);\\n            } else {\\n                /**\\n                 * we are moving on zigzag path as we landed on node being a right child and our next step\\n                 * will be on left child.\\n                 */\\n                max = Math.max(max, curMax + 1);\\n                leftMax = longestZigZagHelper(node.left, curMax + 1, max, true, false);\\n            }\\n        }\\n        int rightMax = Integer.MIN_VALUE;\\n        if (node.right != null) {\\n            if (fromRight) {\\n                /**\\n                 * as mention in above to handle cases\\n                 */\\n                max = Math.max(max, 1);\\n                rightMax = longestZigZagHelper(node.right, 1, max, false, true);\\n            } else {\\n                /**\\n                 * we are moving on zigzag path as we landed on node being a right child and our next step\\n                 * will be on left child.\\n                 */\\n                max = Math.max(max, curMax + 1);\\n                rightMax = longestZigZagHelper(node.right, curMax + 1, max, false, true);\\n            }\\n        }\\n        /**\\n         * return the max zigzag from right child or from left child whatever is max\\n         */\\n        return Math.max(leftMax, rightMax);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestZigZag(TreeNode root) {\\n        return longestZigZagHelper(root, 0, 0, true, true);\\n    }\\n\\n    /**\\n\\t * max - current max as we go down to traverse the tree, while coming up it becomes the max possible in that branch \\n\\t * curMax - current max as we go down to travere the tree\\n     * fromLeft - did we land on node as left child\\n     * fromRight - did we land on node as right child\\n     */\\n    private int longestZigZagHelper(TreeNode node, int curMax, int max, boolean fromLeft, boolean fromRight) {\\n        if (node == null) {\\n            return 0;\\n        }\\n        if (node.left == null && node.right == null) {\\n            /**\\n             * when we hit a child node, return the max to upper node.\\n             */\\n            return max;\\n        }\\n        int leftMax = Integer.MIN_VALUE;\\n        if (node.left != null) {\\n            if (fromLeft) {\\n                /**\\n                 * To handle cases like\\n                 *         1\\n                 *        / \\\\      at least max should be 1.\\n                 *       1   1\\n                 */\\n                max = Math.max(max, 1);\\n                leftMax = longestZigZagHelper(node.left, 1, max, true, false);\\n            } else {\\n                /**\\n                 * we are moving on zigzag path as we landed on node being a right child and our next step\\n                 * will be on left child.\\n                 */\\n                max = Math.max(max, curMax + 1);\\n                leftMax = longestZigZagHelper(node.left, curMax + 1, max, true, false);\\n            }\\n        }\\n        int rightMax = Integer.MIN_VALUE;\\n        if (node.right != null) {\\n            if (fromRight) {\\n                /**\\n                 * as mention in above to handle cases\\n                 */\\n                max = Math.max(max, 1);\\n                rightMax = longestZigZagHelper(node.right, 1, max, false, true);\\n            } else {\\n                /**\\n                 * we are moving on zigzag path as we landed on node being a right child and our next step\\n                 * will be on left child.\\n                 */\\n                max = Math.max(max, curMax + 1);\\n                rightMax = longestZigZagHelper(node.right, curMax + 1, max, false, true);\\n            }\\n        }\\n        /**\\n         * return the max zigzag from right child or from left child whatever is max\\n         */\\n        return Math.max(leftMax, rightMax);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433067,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def helper(root, right, total):\\n            if not root:\\n                return total\\n            \\n            l = helper(root.left, False, total+1 if right else 1)\\n            r = helper(root.right, True, total+1 if not right else 1)\\n\\n            return max(l,r)\\n        \\n        return helper(root, None, 0) - 1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def helper(root, right, total):\\n            if not root:\\n                return total\\n            \\n            l = helper(root.left, False, total+1 if right else 1)\\n            r = helper(root.right, True, total+1 if not right else 1)\\n\\n            return max(l,r)\\n        \\n        return helper(root, None, 0) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531869,
                "title": "python-simple-recursion",
                "content": "```\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        res=0\\n        def helper(root,direction):\\n            nonlocal res\\n            if not root:\\n                return 0\\n            left=helper(root.left,\\'left\\')\\n            right=helper(root.right,\\'right\\')\\n            res=max(res,left+1,right+1)\\n            return right+1 if direction==\\'left\\' else left+1\\n         \\n        if not root:\\n            return 0\\n        helper(root,\\'left\\')\\n        helper(root,\\'right\\')\\n        return res-1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        res=0\\n        def helper(root,direction):\\n            nonlocal res\\n            if not root:\\n                return 0\\n            left=helper(root.left,\\'left\\')\\n            right=helper(root.right,\\'right\\')\\n            res=max(res,left+1,right+1)\\n            return right+1 if direction==\\'left\\' else left+1\\n         \\n        if not root:\\n            return 0\\n        helper(root,\\'left\\')\\n        helper(root,\\'right\\')\\n        return res-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862418,
                "title": "python-clean-solution-without-pain-image-and-explanation-beats-98",
                "content": "# Intuition\\nMany solutions to this problem on LeetCode can lead to eye strain due to their convoluted logic or excessive code. Here, we\\'re aiming to provide a simple and clean solution, which doesn\\'t compromise on efficiency or readability.\\n\\nTo understand the approach, consider the test case: \\n\\n```[1,1,1,1,1,null,1,null,null,null,null,1,1,null,1]```\\n\\nOn the associated tree diagram, we have highlighted two significant ZigZag paths. An orange path, of length 2, proceeds leftwards from the root, and a green path, of length 3, originates from the right branch of the root.\\n![image.png](https://assets.leetcode.com/users/images/75227891-a05a-4f54-9e55-c8b979c54ec4_1691146564.682754.png)\\n\\n# Approach\\nOur algorithm is rooted in the idea of tracking the length of the ZigZag paths as we traverse the tree, using depth-first search (DFS). The current path length is maintained in two variables - `left` and `right`. At each node, if we go left, we update `left` by adding 1 to `right` and reset `right` to 0. Conversely, if we go right, we add 1 to `left` and reset `left` to 0. This way, we always start a new path with either (0,1) or (1,0).\\n\\nEach ZigZag path length is continuously compared to a global maximum (`self.maxi`), and `self.maxi` is updated whenever a larger ZigZag path is found. At the end, `self.maxi` holds the length of the longest ZigZag path in the tree.\\n\\n# Complexity\\n- Time complexity: : O(n), where n is the number of nodes in the tree. This is because we are doing a single DFS traversal of the tree.\\n\\n- Space complexity: O(h), where h is the height of the tree. This accounts for the maximum size of the implicit call stack for the DFS traversal.\\n\\n---\\n\\nThis solution manages to achieve excellent performance without resorting to eye-gouging code, providing an accessible and elegant approach to a potentially complex problem.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.maxi = 0\\n\\n        def dfs(node, left, right):\\n            self.maxi = max(self.maxi, left, right)\\n\\n            if node.left:\\n                dfs(node.left, right + 1, 0)\\n\\n            if node.right:\\n                dfs(node.right, 0, left + 1)\\n\\n        dfs(root, 0, 0)\\n        return self.maxi\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```[1,1,1,1,1,null,1,null,null,null,null,1,1,null,1]```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.maxi = 0\\n\\n        def dfs(node, left, right):\\n            self.maxi = max(self.maxi, left, right)\\n\\n            if node.left:\\n                dfs(node.left, right + 1, 0)\\n\\n            if node.right:\\n                dfs(node.right, 0, left + 1)\\n\\n        dfs(root, 0, 0)\\n        return self.maxi\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433364,
                "title": "java-solution-easy-steps",
                "content": "```\\nclass Solution {\\n    int max=0;\\n    public int longestZigZag(TreeNode root) {\\n       if (root == null) return -1;\\n        max = 0;\\n        helper(root.right, 1, true);\\n        helper(root.left, 1, false);\\n        return max;   \\n    }\\n     private  void helper(TreeNode root, int step, boolean isRight) {\\n        if (root == null) return;\\n        max = Math.max(max, step);\\n        if (isRight) {\\n            helper(root.left, step + 1, false);\\n            helper(root.right, 1, true);\\n        } else {\\n            helper(root.right, step + 1, true);\\n            helper(root.left, 1, false);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int max=0;\\n    public int longestZigZag(TreeNode root) {\\n       if (root == null) return -1;\\n        max = 0;\\n        helper(root.right, 1, true);\\n        helper(root.left, 1, false);\\n        return max;   \\n    }\\n     private  void helper(TreeNode root, int step, boolean isRight) {\\n        if (root == null) return;\\n        max = Math.max(max, step);\\n        if (isRight) {\\n            helper(root.left, step + 1, false);\\n            helper(root.right, 1, true);\\n        } else {\\n            helper(root.right, step + 1, true);\\n            helper(root.left, 1, false);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433028,
                "title": "easy-solution-of-java-c-with-explanation-beginner-friendly",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n\\nclass Solution {\\n    int MAX;\\n    Map<TreeNode, int []> dp;\\n    public int longestZigZag(TreeNode root) {\\n        \\n        //postorder traversal\\n        //Map stores left from node and right from node\\n        dp = new HashMap<>();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    //returns max length from here if you go in a particular direction\\n    private void dfs(TreeNode root){\\n        if(root == null) return;\\n\\n        if(root.left == null && root.right == null){\\n            dp.put(root, new int[]{0,0});\\n            return;\\n        }\\n        //In dp value int []\\n        //index 0 represents left direction\\n        //index 1 represents right direction\\n        dfs(root.left);\\n        dfs(root.right);\\n\\n        int left = 0, right = 0;\\n\\n        if(dp.get(root.left) != null)\\n            left = 1 + dp.get(root.left)[1]; //we go right after left\\n        \\n        if(dp.get(root.right) != null)\\n            right = 1 + dp.get(root.right)[0]; //we go left after right\\n        dp.put(root, new int[]{left, right});\\n        MAX = Math.max(MAX, Math.max(left,right));\\n    }\\n}\\n```\\nC++\\n```\\n#include <iostream>\\n#include <unordered_map>\\n#include <vector>\\n\\nusing namespace std;\\n\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left;\\n    TreeNode* right;\\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n};\\n\\nclass Solution {\\n    int MAX;\\n    unordered_map<TreeNode*, vector<int>> dp;\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        dp.clear();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n\\n        if (!root->left && !root->right) {\\n            dp[root] = {0, 0};\\n            return;\\n        }\\n\\n        dfs(root->left);\\n        dfs(root->right);\\n\\n        int left = 0, right = 0;\\n\\n        if (dp.find(root->left) != dp.end())\\n            left = 1 + dp[root->left][1];\\n\\n        if (dp.find(root->right) != dp.end())\\n            right = 1 + dp[root->right][0];\\n\\n        dp[root] = {left, right};\\n        MAX = max(MAX, max(left, right));\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    int MAX;\\n    Map<TreeNode, int []> dp;\\n    public int longestZigZag(TreeNode root) {\\n        \\n        //postorder traversal\\n        //Map stores left from node and right from node\\n        dp = new HashMap<>();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    //returns max length from here if you go in a particular direction\\n    private void dfs(TreeNode root){\\n        if(root == null) return;\\n\\n        if(root.left == null && root.right == null){\\n            dp.put(root, new int[]{0,0});\\n            return;\\n        }\\n        //In dp value int []\\n        //index 0 represents left direction\\n        //index 1 represents right direction\\n        dfs(root.left);\\n        dfs(root.right);\\n\\n        int left = 0, right = 0;\\n\\n        if(dp.get(root.left) != null)\\n            left = 1 + dp.get(root.left)[1]; //we go right after left\\n        \\n        if(dp.get(root.right) != null)\\n            right = 1 + dp.get(root.right)[0]; //we go left after right\\n        dp.put(root, new int[]{left, right});\\n        MAX = Math.max(MAX, Math.max(left,right));\\n    }\\n}\\n```\n```\\n#include <iostream>\\n#include <unordered_map>\\n#include <vector>\\n\\nusing namespace std;\\n\\nstruct TreeNode {\\n    int val;\\n    TreeNode* left;\\n    TreeNode* right;\\n    TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n};\\n\\nclass Solution {\\n    int MAX;\\n    unordered_map<TreeNode*, vector<int>> dp;\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        dp.clear();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n\\n        if (!root->left && !root->right) {\\n            dp[root] = {0, 0};\\n            return;\\n        }\\n\\n        dfs(root->left);\\n        dfs(root->right);\\n\\n        int left = 0, right = 0;\\n\\n        if (dp.find(root->left) != dp.end())\\n            left = 1 + dp[root->left][1];\\n\\n        if (dp.find(root->right) != dp.end())\\n            right = 1 + dp[root->right][0];\\n\\n        dp[root] = {left, right};\\n        MAX = max(MAX, max(left, right));\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2283892,
                "title": "c-easiest-solution-using-memoization",
                "content": "Explanation:- Traverse the binary tree in a postorder manner and at each node we will calculate the longest zigzag path considering that node as a root and storing the ans in a Map . At each node if the left child is not null we will pass a boolean variable to true to indicate that it should choose the next node as right and similarly if right node is not null we will pass false to indiacate that it should go to the left  and if it cannot move we will simply return 1;\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    map<pair<TreeNode*,bool>,int>mp;\\n    int longestZigZag(TreeNode* root) {\\n      preorder(root);\\n        return ans;\\n        \\n    }\\n    void preorder(TreeNode*root){\\n        if(root!=NULL){\\n            if(root->left!=NULL){\\n                ans=max(ans,findzig(root->left,true));   // passing the left child with true so that it will move right\\n               \\n            }\\n            if(root->right!=NULL){\\n                ans=max(ans,findzig(root->right,false)); //passing the right child with false so that it will move left\\n              \\n            }\\n            preorder(root->left);  \\n            preorder(root->right);\\n        }\\n    }\\n    int findzig(TreeNode*root,bool chk){\\n        if(mp.find({root,chk})!=mp.end()) return mp[{root,chk}];   // checking if the node is already been computed \\n        if(chk){\\n            // go right\\n            if(root->right!=NULL){\\n                return mp[{root,chk}]=1+findzig(root->right,!chk); // moving left in next iteration\\n            }\\n            }else{\\n                if(root->left!=NULL){\\n                    return mp[{root,chk}]=1+findzig(root->left,!chk); // moving right in next iteration\\n                }\\n            }\\n        return mp[{root,chk}]=1;\\n    }\\n};\\n```\\nPlease upvote if U like my explanation",
                "solutionTags": [
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    map<pair<TreeNode*,bool>,int>mp;\\n    int longestZigZag(TreeNode* root) {\\n      preorder(root);\\n        return ans;\\n        \\n    }\\n    void preorder(TreeNode*root){\\n        if(root!=NULL){\\n            if(root->left!=NULL){\\n                ans=max(ans,findzig(root->left,true));   // passing the left child with true so that it will move right\\n               \\n            }\\n            if(root->right!=NULL){\\n                ans=max(ans,findzig(root->right,false)); //passing the right child with false so that it will move left\\n              \\n            }\\n            preorder(root->left);  \\n            preorder(root->right);\\n        }\\n    }\\n    int findzig(TreeNode*root,bool chk){\\n        if(mp.find({root,chk})!=mp.end()) return mp[{root,chk}];   // checking if the node is already been computed \\n        if(chk){\\n            // go right\\n            if(root->right!=NULL){\\n                return mp[{root,chk}]=1+findzig(root->right,!chk); // moving left in next iteration\\n            }\\n            }else{\\n                if(root->left!=NULL){\\n                    return mp[{root,chk}]=1+findzig(root->left,!chk); // moving right in next iteration\\n                }\\n            }\\n        return mp[{root,chk}]=1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 682415,
                "title": "java-simple-dfs",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root.left, 1, true);\\n        dfs(root.right, 1, false);\\n        return res;\\n    }\\n    \\n    private void dfs(TreeNode node, int prev, boolean left) {\\n        if (node == null) return;\\n        res = Math.max(res, prev);\\n        dfs(node.left, 1 + (left ? 0 : prev), true);\\n        dfs(node.right,1 + (left ? prev : 0), false);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root.left, 1, true);\\n        dfs(root.right, 1, false);\\n        return res;\\n    }\\n    \\n    private void dfs(TreeNode node, int prev, boolean left) {\\n        if (node == null) return;\\n        res = Math.max(res, prev);\\n        dfs(node.left, 1 + (left ? 0 : prev), true);\\n        dfs(node.right,1 + (left ? prev : 0), false);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433664,
                "title": "java-recursion",
                "content": "```\\nclass Solution {\\n    int LongestPath = 0;\\n    public int longestZigZag(TreeNode root) {\\n        int[] a = helper(root);\\n        return LongestPath;\\n    }\\n    \\n    //  {Longest Path Ending At leftNode, Longest Path Ending At RightNode}\\n    public int[] helper(TreeNode root) {\\n        if (root == null) {\\n            return new int[]{-1, -1};\\n        }\\n        int[] left = helper(root.left);\\n        int[] right = helper(root.right);\\n        int[] answer = new int[]{left[1] + 1, right[0] + 1};\\n        LongestPath = Math.max(LongestPath, Math.max(answer[0], answer[1]));\\n        return answer;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int LongestPath = 0;\\n    public int longestZigZag(TreeNode root) {\\n        int[] a = helper(root);\\n        return LongestPath;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3434051,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\nlet ans = 0;\\n\\nvar dfs = (root,left,steps) => {\\n    if(root == undefined){\\n        return \\n    }\\n\\n    ans = Math.max(ans,steps)\\n\\n    if(left){\\n        dfs(root.left, !left, steps+1)\\n        dfs(root.right, left, 1)\\n    }\\n    else{\\n        dfs(root.left, left, 1)\\n        dfs(root.right, !left, steps+1)\\n    }\\n}\\n\\nvar longestZigZag = function(root) {\\n    ans = 0\\n\\n    dfs(root,true,0)\\n    dfs(root,false,0)\\n\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nlet ans = 0;\\n\\nvar dfs = (root,left,steps) => {\\n    if(root == undefined){\\n        return \\n    }\\n\\n    ans = Math.max(ans,steps)\\n\\n    if(left){\\n        dfs(root.left, !left, steps+1)\\n        dfs(root.right, left, 1)\\n    }\\n    else{\\n        dfs(root.left, left, 1)\\n        dfs(root.right, !left, steps+1)\\n    }\\n}\\n\\nvar longestZigZag = function(root) {\\n    ans = 0\\n\\n    dfs(root,true,0)\\n    dfs(root,false,0)\\n\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1878082,
                "title": "c-dfs-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void solve(TreeNode* root , int score, int dir){\\n        if(root == NULL) return ;\\n        ans = max(ans, score);\\n        if(dir == 0)  {solve(root->right, score + 1, 1); solve(root->left, 1, 0);}\\n        else {solve(root->left, score + 1, 0); solve(root->right, 1, 1);}\\n        \\n    }\\n    int longestZigZag(TreeNode* root) {\\n           solve(root->left, 1, 0);\\n           solve(root->right, 1, 1);\\n           return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int ans = 0;\\n    void solve(TreeNode* root , int score, int dir){\\n        if(root == NULL) return ;\\n        ans = max(ans, score);\\n        if(dir == 0)  {solve(root->right, score + 1, 1); solve(root->left, 1, 0);}",
                "codeTag": "Java"
            },
            {
                "id": 550153,
                "title": "10-lines-clean-easy-to-understand-well-explained-code",
                "content": "Recurse through the tree. Return for every node what is the max path len if we go left from current node and what is the max path len if we go right from current node. Keep track of maximum. \\n\\n```python\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\t\\n        self.ans = 0  # global variable to store answer\\n\\t\\t\\n        def recurse(root):\\n\\t\\t\\t# if null return -1 because length is defined \\n\\t\\t\\t# as the number of nodes visited - 1. \\n            if not root: return (-1,-1) \\n\\t\\t\\t\\n\\t\\t\\t# l1 is max path len if we go left from current node and r1 if we go right\\t\\t\\t\\t\\t\\t\\n            l1,r1 = recurse(root.left)\\n            l2,r2 = recurse(root.right)\\n\\t\\t\\t# Notice that if we go left from current node then we have no other choice but\\n\\t\\t\\t# to go right from node.left to make the path zigzag. \\n\\t\\t\\t# That is why  r1 + 1 is the max path len  if we go left from current node. \\n\\t\\t\\t# Same logic for l2 + 1\\n            self.ans = max(self.ans, max(r1 + 1, l2 + 1))\\n            return (r1 + 1, l2 + 1)\\n\\t\\t\\t\\n        recurse(root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\t\\n        self.ans = 0  # global variable to store answer\\n\\t\\t\\n        def recurse(root):\\n\\t\\t\\t# if null return -1 because length is defined \\n\\t\\t\\t# as the number of nodes visited - 1. \\n            if not root: return (-1,-1) \\n\\t\\t\\t\\n\\t\\t\\t# l1 is max path len if we go left from current node and r1 if we go right\\t\\t\\t\\t\\t\\t\\n            l1,r1 = recurse(root.left)\\n            l2,r2 = recurse(root.right)\\n\\t\\t\\t# Notice that if we go left from current node then we have no other choice but\\n\\t\\t\\t# to go right from node.left to make the path zigzag. \\n\\t\\t\\t# That is why  r1 + 1 is the max path len  if we go left from current node. \\n\\t\\t\\t# Same logic for l2 + 1\\n            self.ans = max(self.ans, max(r1 + 1, l2 + 1))\\n            return (r1 + 1, l2 + 1)\\n\\t\\t\\t\\n        recurse(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433173,
                "title": "python3-solution",
                "content": "\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        stack=[(root,0,None)]\\n        while stack:\\n            node,n,left=stack.pop()\\n            if node:\\n                ans=max(ans,n)\\n                stack.append((node.left,1 if left else n+1,1))\\n                stack.append((node.right,n+1 if left else 1,0))\\n\\n        return ans        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        ans=0\\n        stack=[(root,0,None)]\\n        while stack:\\n            node,n,left=stack.pop()\\n            if node:\\n                ans=max(ans,n)\\n                stack.append((node.left,1 if left else n+1,1))\\n                stack.append((node.right,n+1 if left else 1,0))\\n\\n        return ans        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 713290,
                "title": "clean-c-recursive-solution",
                "content": "```\\nint maxPath;\\nvoid dfs(TreeNode *root,bool goLeft, int pathCovered){\\n\\tif(!root) return;\\n\\tmaxPath = max(maxPath,pathCovered);\\n\\tif(goLeft){\\n\\t\\tdfs(root->left,false,pathCovered+1);\\n\\t\\tdfs(root->right,true,1);\\n\\t}else{\\n\\t\\tdfs(root->left,false,1);\\n\\t\\tdfs(root->right,true,pathCovered+1);\\n\\t}\\n}\\nint longestZigZag(TreeNode* root) {\\n\\tmaxPath = 0;\\n\\tdfs(root,false,0);\\n\\tdfs(root,true,0);\\n\\treturn maxPath;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxPath;\\nvoid dfs(TreeNode *root,bool goLeft, int pathCovered){\\n\\tif(!root) return;\\n\\tmaxPath = max(maxPath,pathCovered);\\n\\tif(goLeft){\\n\\t\\tdfs(root->left,false,pathCovered+1);\\n\\t\\tdfs(root->right,true,1);\\n\\t}else{\\n\\t\\tdfs(root->left,false,1);\\n\\t\\tdfs(root->right,true,pathCovered+1);\\n\\t}\\n}\\nint longestZigZag(TreeNode* root) {\\n\\tmaxPath = 0;\\n\\tdfs(root,false,0);\\n\\tdfs(root,true,0);\\n\\treturn maxPath;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433774,
                "title": "c-solution-using-recursion-in-0-n-and-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlways think of the zigzag path that can be formed using current node via left subtree and right subtree and find the maximum.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the current node is a null node return a pair of {0,0} denoting the zigzag path is of length 0. Now, for every node calculate maximum zigzag path using left subtree and then using right subtree and maximize the ans.\\n\\n# Complexity\\n- Time complexity: O(n) -> where n is the number of nodes in tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) -> space used + O(h) -> where h is the maximum height of tree i.e. recursion stack space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> helper(TreeNode* root, int &ans) {\\n        if(root == NULL) return {0,0};\\n        pair<int,int> l = helper(root->left,ans);\\n        ans = max(ans,1+l.second);\\n        pair<int,int> r = helper(root->right,ans);\\n        ans = max(ans,1+r.first);\\n        return {1+l.second,1+r.first};\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        helper(root,ans);\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    pair<int,int> helper(TreeNode* root, int &ans) {\\n        if(root == NULL) return {0,0};\\n        pair<int,int> l = helper(root->left,ans);\\n        ans = max(ans,1+l.second);\\n        pair<int,int> r = helper(root->right,ans);\\n        ans = max(ans,1+r.first);\\n        return {1+l.second,1+r.first};\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        helper(root,ans);\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1777694,
                "title": "c-easy-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        queue<pair<pair<TreeNode*,char>,int>>q;\\n        if(!root)\\n            return 0;\\n        if(root->left)\\n            q.push({{root->left,\\'L\\'},1});\\n        if(root->right)\\n            q.push({{root->right,\\'R\\'},1});\\n        int maxiLen = 0;\\n        while(!q.empty())\\n        {\\n            pair<pair<TreeNode*,char>,int> pr = q.front();q.pop();\\n            \\n            TreeNode* node = pr.first.first;\\n            char nodeDir = pr.first.second;\\n            int len = pr.second;\\n            \\n            maxiLen = max(maxiLen, len);\\n           //  cout<<node->val<< \" \"<<nodeDir<<\" \"<<len<<endl;\\n            if(node->left)\\n            {\\n                if(nodeDir == \\'L\\')\\n                    q.push({{node->left,\\'L\\'},1});\\n                else\\n                    q.push({{node->left,\\'L\\'},len+1});\\n            }\\n            if(node->right)\\n            {\\n                if(nodeDir == \\'R\\')\\n                    q.push({{node->right,\\'R\\'},1});\\n                else\\n                    q.push({{node->right,\\'R\\'},len+1});\\n            }\\n        }\\n        return maxiLen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        queue<pair<pair<TreeNode*,char>,int>>q;\\n        if(!root)\\n            return 0;\\n        if(root->left)\\n            q.push({{root->left,\\'L\\'},1});\\n        if(root->right)\\n            q.push({{root->right,\\'R\\'},1});\\n        int maxiLen = 0;\\n        while(!q.empty())\\n        {\\n            pair<pair<TreeNode*,char>,int> pr = q.front();q.pop();\\n            \\n            TreeNode* node = pr.first.first;\\n            char nodeDir = pr.first.second;\\n            int len = pr.second;\\n            \\n            maxiLen = max(maxiLen, len);\\n           //  cout<<node->val<< \" \"<<nodeDir<<\" \"<<len<<endl;\\n            if(node->left)\\n            {\\n                if(nodeDir == \\'L\\')\\n                    q.push({{node->left,\\'L\\'},1});\\n                else\\n                    q.push({{node->left,\\'L\\'},len+1});\\n            }\\n            if(node->right)\\n            {\\n                if(nodeDir == \\'R\\')\\n                    q.push({{node->right,\\'R\\'},1});\\n                else\\n                    q.push({{node->right,\\'R\\'},len+1});\\n            }\\n        }\\n        return maxiLen;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 538986,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8  The ART of Dynamic Programming:](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master) Use two counters for left `L` and right `R` to track each node\\'s maximum zig-zag length, ie. similar to Kadane\\'s algorithm we track the \"best ending here\" at each `node` as we traverse the tree.\\n\\n**\\uD83E\\uDD14 Recurrence relations:** let `node` be a child of the `last` node seen during a DFS traversal of the tree\\n* if `node` is the *right* child of `last`, then `L[node] = 1 + R[last]`\\n* if `node` if the *left* child of `last`, then `R[node] = 1 + L[last]`\\n\\n\\uD83C\\uDFAF Return the maximum value of `L` and `R` minus `1`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun longestZigZag(root: TreeNode?): Int {\\n        var (L, R) = Pair(mutableMapOf<TreeNode?, Int>(), mutableMapOf<TreeNode?, Int>())\\n        fun go(node: TreeNode? = root, last: TreeNode? = null) {\\n            if (node == null)\\n                return\\n            L[node] = 1 + if (last != null && last.left != node) R[last] ?: 0 else 0\\n            R[node] = 1 + if (last != null && last.right != node) L[last] ?: 0 else 0\\n            go(node?.left, node)\\n            go(node?.right, node)\\n        }\\n        go()\\n        return Math.max(L.values.max()!!, R.values.max()!!) - 1\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet longestZigZag = (root, L = new Map(), R = new Map()) => {\\n    let go = (node = root, last = null) => {\\n        if (!node)\\n            return;\\n        L.set(node, 1 + (last && last.left != node ? (R.get(last) || 0) : 0));\\n        R.set(node, 1 + (last && last.right != node ? (L.get(last) || 0) : 0));\\n        go(node.left, node);\\n        go(node.right, node);\\n    };\\n    go();\\n    return Math.max(...L.values(), ...R.values()) - 1;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        L = Counter()\\n        R = Counter()\\n        def go(node = root, last = None):\\n            if not node:\\n                return\\n            L[node] = 1 + (R[last] if last and last.left != node else 0)\\n            R[node] = 1 + (L[last] if last and last.right != node else 0)\\n            go(node.left, node)\\n            go(node.right, node)\\n        go()\\n        return max(*L.values(), *R.values()) - 1\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using fun = function<void(TreeNode*, TreeNode*)>;\\n    using Map = unordered_map<TreeNode*, int>;\\n    using VI = vector<int>;\\n    int longestZigZag(TreeNode* root, Map L = {}, Map R = {}, VI cands = {}) {\\n        fun go = [&](auto node, auto last) {\\n            if (!node)\\n                return;\\n            L[node] = 1 + (last && last->left != node ? R[last] : 0);\\n            R[node] = 1 + (last && last->right != node ? L[last] : 0);\\n            go(node->left, node);\\n            go(node->right, node);\\n        };\\n        go(root, nullptr);\\n        transform(L.begin(), L.end(), back_inserter(cands), [](auto& pair) { return pair.second; });\\n        transform(R.begin(), R.end(), back_inserter(cands), [](auto& pair) { return pair.second; });\\n        return *max_element(cands.begin(), cands.end()) - 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun longestZigZag(root: TreeNode?): Int {\\n        var (L, R) = Pair(mutableMapOf<TreeNode?, Int>(), mutableMapOf<TreeNode?, Int>())\\n        fun go(node: TreeNode? = root, last: TreeNode? = null) {\\n            if (node == null)\\n                return\\n            L[node] = 1 + if (last != null && last.left != node) R[last] ?: 0 else 0\\n            R[node] = 1 + if (last != null && last.right != node) L[last] ?: 0 else 0\\n            go(node?.left, node)\\n            go(node?.right, node)\\n        }\\n        go()\\n        return Math.max(L.values.max()!!, R.values.max()!!) - 1\\n    }\\n}\\n```\n```\\nlet longestZigZag = (root, L = new Map(), R = new Map()) => {\\n    let go = (node = root, last = null) => {\\n        if (!node)\\n            return;\\n        L.set(node, 1 + (last && last.left != node ? (R.get(last) || 0) : 0));\\n        R.set(node, 1 + (last && last.right != node ? (L.get(last) || 0) : 0));\\n        go(node.left, node);\\n        go(node.right, node);\\n    };\\n    go();\\n    return Math.max(...L.values(), ...R.values()) - 1;\\n};\\n```\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        L = Counter()\\n        R = Counter()\\n        def go(node = root, last = None):\\n            if not node:\\n                return\\n            L[node] = 1 + (R[last] if last and last.left != node else 0)\\n            R[node] = 1 + (L[last] if last and last.right != node else 0)\\n            go(node.left, node)\\n            go(node.right, node)\\n        go()\\n        return max(*L.values(), *R.values()) - 1\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<void(TreeNode*, TreeNode*)>;\\n    using Map = unordered_map<TreeNode*, int>;\\n    using VI = vector<int>;\\n    int longestZigZag(TreeNode* root, Map L = {}, Map R = {}, VI cands = {}) {\\n        fun go = [&](auto node, auto last) {\\n            if (!node)\\n                return;\\n            L[node] = 1 + (last && last->left != node ? R[last] : 0);\\n            R[node] = 1 + (last && last->right != node ? L[last] : 0);\\n            go(node->left, node);\\n            go(node->right, node);\\n        };\\n        go(root, nullptr);\\n        transform(L.begin(), L.end(), back_inserter(cands), [](auto& pair) { return pair.second; });\\n        transform(R.begin(), R.end(), back_inserter(cands), [](auto& pair) { return pair.second; });\\n        return *max_element(cands.begin(), cands.end()) - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531878,
                "title": "python-iterative-dfs",
                "content": "```\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        ans = 0\\n        nodes = [(root, False, 0), (root, True, 0)]\\n        while nodes:\\n            node, right, length = nodes.pop()\\n            if node:\\n\\t\\t\\t\\tans = max(ans, length)\\n\\t\\t\\t\\tnodes.append((node.right if right else node.left, not right, length + 1))\\n\\t\\t\\t\\tnodes.append((node.left if right else node.right, right, 1))\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        ans = 0\\n        nodes = [(root, False, 0), (root, True, 0)]\\n        while nodes:\\n            node, right, length = nodes.pop()\\n            if node:\\n\\t\\t\\t\\tans = max(ans, length)\\n\\t\\t\\t\\tnodes.append((node.right if right else node.left, not right, length + 1))\\n\\t\\t\\t\\tnodes.append((node.left if right else node.right, right, 1))\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3435925,
                "title": "dfs-solution-java-solution-o-n",
                "content": "# Approach\\n1. The code follows a depth-first search (DFS) approach to traverse the binary tree and find the longest zigzag path. It uses a recursive helper function called dfs to perform the DFS.\\n2. The **dfs function** takes a node, a length of the path so far, and a boolean flag indicating whether the previous node traversed was a left child or a right child.\\n3. For each node, the function updates the **ans** variable if the current length is greater than the current **ans**. It then recursively calls itself on the node\\'s left and right child nodes, passing the length of the path so far incremented by 1, and the opposite of the **isLeft** flag of the current node.\\n4. By doing this, the function explores all possible zigzag paths in the binary tree and returns the length of the longest one. \\n5. The main function calls the **dfs function** twice, once for the left subtree of the root node with **isLeft** set to true and once for the right subtree of the root node with **isLeft** set to false. \\n6. Finally, it returns the value of **ans**, which holds the length of the longest zigzag path found.\\n\\n---\\n\\n- **DO NOT USE** *static int ans=0* , it will give error in the next testcase.\\n\\n# Complexity\\n- Time complexity: The time complexity of the given code is **O(n)**, where n is the number of nodes in the binary tree. \\n\\n- Space complexity: The space complexity of the code is **O(h)**, where h is the height of the binary tree.\\n\\n# Code\\n```\\nclass Solution {\\n     int ans=0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root.left,1,true);\\n        dfs(root.right,1,false);\\n        return ans;\\n        \\n    }\\n    public void dfs(TreeNode node,int len,boolean isLeft)\\n    {\\n        if(node==null)\\n            return;\\n        ans=Math.max(len,ans);\\n        if(isLeft)\\n        {\\n            dfs(node.right,len+1,false);\\n            dfs(node.left,1,true);\\n        }\\n        else\\n        {\\n            dfs(node.right,1,false);\\n            dfs(node.left,len+1,true);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n     int ans=0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root.left,1,true);\\n        dfs(root.right,1,false);\\n        return ans;\\n        \\n    }\\n    public void dfs(TreeNode node,int len,boolean isLeft)\\n    {\\n        if(node==null)\\n            return;\\n        ans=Math.max(len,ans);\\n        if(isLeft)\\n        {\\n            dfs(node.right,len+1,false);\\n            dfs(node.left,1,true);\\n        }\\n        else\\n        {\\n            dfs(node.right,1,false);\\n            dfs(node.left,len+1,true);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435126,
                "title": "beginner-friendly-solution-c-solution-95-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The idea is to get the maximum length of zigzag sequence for each node.\\n- Checking Left-Right-Left or Right-Left-Right, sequence for each node.\\n\\n# Approach\\nChoose a convention to traverse in a zigzag manner, for example\\n> 0 or false  for going left\\n>1 or true for going right\\n\\nThe idea is to traverse the tree in a zigzag manner\\n1. If node is Null, return the control back\\n2. For every node check the maximum length of \\n[left zigzag sequence(L->R->L), Right Zigzag sequence (R->L->R)]\\n3. If the sequence continue, keep increasing the length \\n4. Else, make the current node as the starting point and repeat steps 1,2,3,4\\n5. For each recursive call, keep updating the maximum length \\n\\nOnce all the nodes have been traversed, return the maximum length - 1\\n\\n# Complexity\\n- Time complexity : $$O(n)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity : $$O(1)$$, Ignoring the Recursive stack that was used\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution // Direction = 0, means we went left\\n{              // Direction = 1, means we went right\\npublic:\\n    int max_len = 0; // Store the maximum length in the max_lenwer variable\\n    void Get_Maximum_Length(TreeNode *node, int direction, int curr_length)\\n    {\\n        if (node == NULL) // If Node is Null, then its an end point\\n            return;       // Just return back the control\\n\\n        max_len = max(max_len, curr_length); // Storing the maximum length so far\\n\\n        if (direction == 0) // If Direction is 0,\\n        {                   // i.e. The current Node is the left part of the sequence\\n\\n            // Now we go right and increase the current length by 1\\n            Get_Maximum_Length(node->right, 1, curr_length + 1);\\n\\n            // If we go left again, we will not be making a zigzag sequence\\n            // And so we have to neglect the current length.\\n            // And find a path with current node as the starting point\\n            // Therefore we hold the current node as centre and traverse to the left\\n            // We send curr_length as 2, because if the left exists then surely there will\\n            // At least Two nodes in this sequence, hence length = 2\\n            Get_Maximum_Length(node->left, 0, 2);\\n        }\\n        else // Direction is 1,\\n        {    // i.e. The current Node is the right part of the sequence\\n\\n            // Now we go left and increase the current length by 1\\n            Get_Maximum_Length(node->left, 0, curr_length + 1);\\n\\n            // If we go right again, we will not be making a zigzag sequence\\n            // And so we have to neglect the current length.\\n            // And find a path with current node as the starting point\\n            // Therefore we hold the current node as centre and traverse to the right\\n            // We send curr_length as 2, because if the right exists then surely there will\\n            // At least Two nodes in this sequence, and hence length = 2\\n            Get_Maximum_Length(node->right, 1, 2);\\n        }\\n    }\\n    int longestZigZag(TreeNode *root)\\n    {\\n        // Check the maximum length to the left\\n        Get_Maximum_Length(root, 0, 1);\\n        // Check the maximum length to the right\\n        Get_Maximum_Length(root, 1, 1);\\n        // Returning max_len - 1, as asked in the question\\n        return max_len - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution // Direction = 0, means we went left\\n{              // Direction = 1, means we went right\\npublic:\\n    int max_len = 0; // Store the maximum length in the max_lenwer variable\\n    void Get_Maximum_Length(TreeNode *node, int direction, int curr_length)\\n    {\\n        if (node == NULL) // If Node is Null, then its an end point\\n            return;       // Just return back the control\\n\\n        max_len = max(max_len, curr_length); // Storing the maximum length so far\\n\\n        if (direction == 0) // If Direction is 0,\\n        {                   // i.e. The current Node is the left part of the sequence\\n\\n            // Now we go right and increase the current length by 1\\n            Get_Maximum_Length(node->right, 1, curr_length + 1);\\n\\n            // If we go left again, we will not be making a zigzag sequence\\n            // And so we have to neglect the current length.\\n            // And find a path with current node as the starting point\\n            // Therefore we hold the current node as centre and traverse to the left\\n            // We send curr_length as 2, because if the left exists then surely there will\\n            // At least Two nodes in this sequence, hence length = 2\\n            Get_Maximum_Length(node->left, 0, 2);\\n        }\\n        else // Direction is 1,\\n        {    // i.e. The current Node is the right part of the sequence\\n\\n            // Now we go left and increase the current length by 1\\n            Get_Maximum_Length(node->left, 0, curr_length + 1);\\n\\n            // If we go right again, we will not be making a zigzag sequence\\n            // And so we have to neglect the current length.\\n            // And find a path with current node as the starting point\\n            // Therefore we hold the current node as centre and traverse to the right\\n            // We send curr_length as 2, because if the right exists then surely there will\\n            // At least Two nodes in this sequence, and hence length = 2\\n            Get_Maximum_Length(node->right, 1, 2);\\n        }\\n    }\\n    int longestZigZag(TreeNode *root)\\n    {\\n        // Check the maximum length to the left\\n        Get_Maximum_Length(root, 0, 1);\\n        // Check the maximum length to the right\\n        Get_Maximum_Length(root, 1, 1);\\n        // Returning max_len - 1, as asked in the question\\n        return max_len - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434714,
                "title": "c-solution-easy-and-explained-recursive-code-commented-and-explained",
                "content": "![20230419_121913000_iOS.jpg](https://assets.leetcode.com/users/images/e4729c9b-4349-4601-8796-45d714581655_1681907007.8512464.jpeg)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void zig(bool dir,int &max_len,TreeNode* node,int length){\\n        if(node == NULL){\\n            return;\\n        }\\n        max_len = max(length,max_len);\\n        zig(0,max_len,node->left,dir?length+1:1); // dir=0 i.e. 0 means left node, if dir=1 that means this node was at right side previously and if dir=0 that means that this node was at left side previously\\n        zig(1,max_len,node->right,dir?1:length+1); // dir=1 i.e. 1 means right node,  \\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int max_len=0;\\n        zig(0,max_len,root,0);  // At root node, left and right both nodes qualify as the zig-zag path\\n        zig(1,max_len,root,0);  // That\\'s why we called function 2 times with different dir\\n        return max_len;        \\n    }\\n};\\n```\\n![upvote cat.jpeg](https://assets.leetcode.com/users/images/6ac9f885-df47-414d-8e35-b20f6bc3b9ed_1681906739.2323492.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void zig(bool dir,int &max_len,TreeNode* node,int length){\\n        if(node == NULL){\\n            return;\\n        }\\n        max_len = max(length,max_len);\\n        zig(0,max_len,node->left,dir?length+1:1); // dir=0 i.e. 0 means left node, if dir=1 that means this node was at right side previously and if dir=0 that means that this node was at left side previously\\n        zig(1,max_len,node->right,dir?1:length+1); // dir=1 i.e. 1 means right node,  \\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int max_len=0;\\n        zig(0,max_len,root,0);  // At root node, left and right both nodes qualify as the zig-zag path\\n        zig(1,max_len,root,0);  // That\\'s why we called function 2 times with different dir\\n        return max_len;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433533,
                "title": "easy-c-solution-optimized",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int maxLen = 0;\\n        dfs(root, maxLen);\\n        return maxLen;\\n    }\\n    \\n    pair<int, int> dfs(TreeNode* node, int& maxLen) {\\n        if (!node) {\\n            return {0, 0};\\n        }\\n        \\n        auto left = dfs(node->left, maxLen);\\n        auto right = dfs(node->right, maxLen);\\n        \\n        int leftMax = left.second, rightMax = right.first;\\n        maxLen = max(maxLen, max(leftMax, rightMax));\\n        \\n        return {1 + left.second, 1 + right.first};\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int maxLen = 0;\\n        dfs(root, maxLen);\\n        return maxLen;\\n    }\\n    \\n    pair<int, int> dfs(TreeNode* node, int& maxLen) {\\n        if (!node) {\\n            return {0, 0};\\n        }\\n        \\n        auto left = dfs(node->left, maxLen);\\n        auto right = dfs(node->right, maxLen);\\n        \\n        int leftMax = left.second, rightMax = right.first;\\n        maxLen = max(maxLen, max(leftMax, rightMax));\\n        \\n        return {1 + left.second, 1 + right.first};\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433531,
                "title": "python3-solution-with-explanation-longest-zigzag-path-in-a-binary-tree",
                "content": "**Approach** :\\n\\nWe can use a recursive Depth First Search (DFS) approach to traverse the binary tree and keep track of the length of the longest ZigZag path seen so far.\\n\\nWe can define a helper function **dfs** that takes four arguments: the current node being visited, the length of the longest ZigZag path seen so far when the last move was to the left, the length of the longest ZigZag path seen so far when the last move was to the right, and the overall maximum length of any ZigZag path seen so far.\\n\\nIn each recursive call of the **dfs** function, we update the overall maximum length seen so far to the maximum of the current **max_len**, **left_len**, and **right_len**. We then make two recursive calls, one for the left child and one for the right child. We update the length of the ZigZag path seen so far in the left and right recursive calls based on the direction of the last move (left or right) and set the other length to zero.\\n\\nFinally, we return the updated **max_len** value after all nodes in the binary tree have been visited.\\n\\n**Time Complexity** :\\n\\nThe time complexity of this approach is **O(n)**, where **n** is the number of nodes in the binary tree. This is because we visit each node exactly once during the DFS traversal.\\n\\n**Space Complexity** :\\n\\nThe space complexity of this approach is **O(h)**, where **h** is the height of the binary tree. This is because the depth of the recursive call stack is equal to the height of the binary tree.\\n\\n**Solution** :\\n\\n```\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        def dfs(node: TreeNode, left_len: int, right_len: int, max_len: int) -> int:\\n            if not node:\\n                return max_len\\n            max_len = max(max_len, left_len, right_len)\\n            return max(\\n                dfs(node.left, 0, left_len + 1, max_len),\\n                dfs(node.right, right_len + 1, 0, max_len),\\n            )\\n        return dfs(root, 0, 0, 0)\\n````",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        def dfs(node: TreeNode, left_len: int, right_len: int, max_len: int) -> int:\\n            if not node:\\n                return max_len\\n            max_len = max(max_len, left_len, right_len)\\n            return max(\\n                dfs(node.left, 0, left_len + 1, max_len),\\n                dfs(node.right, right_len + 1, 0, max_len),\\n            )\\n        return dfs(root, 0, 0, 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974248,
                "title": "c-readable-code-using-pair-class-and-recursion-o-n-complexity",
                "content": "```\\nclass Pair {\\npublic:\\n    int forwardSlash = -1;\\n    int backwardSlash = -1;\\n    int maxZZ = 0;\\n};\\n\\nclass Solution {\\npublic:\\n    Pair findZigZag(TreeNode* root){\\n        if(!root) {\\n            Pair nodeAns;\\n            return nodeAns; //returning default values i.e., -1, -1, 0\\n        }\\n        \\n        Pair left = findZigZag(root->left);\\n        Pair right = findZigZag(root->right);\\n        \\n        Pair nodeAns;\\n        \\n\\t\\t//finding maximium ZigZag path -> [continious or past maximum path]\\n        nodeAns.maxZZ = max(max(left.maxZZ, right.maxZZ) ,max(left.backwardSlash, right.forwardSlash)+1); \\n\\t\\t\\n\\t\\t//finding current path\\n\\t\\t\\n\\t\\t//Remember we need to find Zig Zag path ->relate the following code accordingly!\\n        nodeAns.forwardSlash = left.backwardSlash +1;\\n        nodeAns.backwardSlash = right.forwardSlash +1;\\n        \\n        return nodeAns;\\n    }\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n        Pair maxi = findZigZag(root);\\n        \\n        return maxi.maxZZ;\\n    }\\n};\\n```\\n\\n-> The code is not completely explained because I want to make sure that you\\'ll try to think on your own and understand better. This will make sure that the next time you see a similar question you can realize and apply this approach on your own.\\n\\n-> If you still cannot understand my approach feel free to ask me in comments... I\\'ll definitely try to help as soon as possible!\\n\\nThank you\\nP.S.:-  Please upvote if you like my approach!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Pair {\\npublic:\\n    int forwardSlash = -1;\\n    int backwardSlash = -1;\\n    int maxZZ = 0;\\n};\\n\\nclass Solution {\\npublic:\\n    Pair findZigZag(TreeNode* root){\\n        if(!root) {\\n            Pair nodeAns;\\n            return nodeAns; //returning default values i.e., -1, -1, 0\\n        }\\n        \\n        Pair left = findZigZag(root->left);\\n        Pair right = findZigZag(root->right);\\n        \\n        Pair nodeAns;\\n        \\n\\t\\t//finding maximium ZigZag path -> [continious or past maximum path]\\n        nodeAns.maxZZ = max(max(left.maxZZ, right.maxZZ) ,max(left.backwardSlash, right.forwardSlash)+1); \\n\\t\\t\\n\\t\\t//finding current path\\n\\t\\t\\n\\t\\t//Remember we need to find Zig Zag path ->relate the following code accordingly!\\n        nodeAns.forwardSlash = left.backwardSlash +1;\\n        nodeAns.backwardSlash = right.forwardSlash +1;\\n        \\n        return nodeAns;\\n    }\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n        Pair maxi = findZigZag(root);\\n        \\n        return maxi.maxZZ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549701,
                "title": "easy-to-understand",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    int maxi = 0;\\n    pair<int, int> rec(TreeNode *root)\\n    {\\n        if (root == NULL)\\n        {\\n            return {0, 0};\\n        }\\n        pair<int, int> left = rec(root->left);\\n        pair<int, int> right = rec(root->right);\\n        maxi = max({maxi,1 + left.second,1 + right.first});\\n        return {1 + left.second, 1 + right.first};\\n    }\\n\\n    int longestZigZag(TreeNode *root)\\n    {\\n        rec(root);\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int maxi = 0;\\n    pair<int, int> rec(TreeNode *root)\\n    {\\n        if (root == NULL)\\n        {\\n            return {0, 0};\\n        }\\n        pair<int, int> left = rec(root->left);\\n        pair<int, int> right = rec(root->right);\\n        maxi = max({maxi,1 + left.second,1 + right.first});\\n        return {1 + left.second, 1 + right.first};\\n    }\\n\\n    int longestZigZag(TreeNode *root)\\n    {\\n        rec(root);\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794014,
                "title": "c-passing-data-from-bottom-to-up",
                "content": "**Keep in mind:-** There are always two methods to pass data from one node to another node in recursion(except global variable)\\n1. from top to bottom\\n2.  from bottom to up\\n3.  to solve any problem(specifically of tree) always think like this,it will help.\\n\\nI am returning ```{left,right}``` from every node,\\n1. left means-> length of path starting from that node and moving towards left,\\n2.  right means:- length of path starting from that node and moving towards right\\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    int longestZigZag(TreeNode* root) {\\n        ans=0;\\n        find(root);\\n        return ans-1;\\n    }\\n    pair<int,int> find(TreeNode*root){\\n        if(!root)\\n            return {0,0};\\n        auto left=find(root->left);\\n        auto right=find(root->right);\\n        int leftCnt=1+left.second,rightCnt=1+right.first;\\n        ans=max(ans,max(leftCnt,rightCnt));\\n        return {leftCnt,rightCnt};\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```{left,right}```\n```\\nclass Solution {\\npublic:\\n    int ans;\\n    int longestZigZag(TreeNode* root) {\\n        ans=0;\\n        find(root);\\n        return ans-1;\\n    }\\n    pair<int,int> find(TreeNode*root){\\n        if(!root)\\n            return {0,0};\\n        auto left=find(root->left);\\n        auto right=find(root->right);\\n        int leftCnt=1+left.second,rightCnt=1+right.first;\\n        ans=max(ans,max(leftCnt,rightCnt));\\n        return {leftCnt,rightCnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536952,
                "title": "python-recursion-sol-and-iteration-sol-easy-and-clean",
                "content": "# Iteration\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        if not root: return res\\n        q= deque() # node, isLeft, depth\\n        if root.left: \\n            q.append((root.left,True,1))\\n        if root.right:\\n            q.append((root.right, False,1))\\n        \\n        while q:\\n            node,isleft,depth = q.popleft()\\n            res = max(res,depth)\\n            if isleft:\\n                if node.right: \\n                    q.append((node.right,False,depth+1))\\n                if node.left:\\n                    q.append((node.left,True,1))\\n                \\n            else:\\n                if node.left:\\n                    q.append((node.left,True,depth+1))\\n                if node.right:\\n                    q.append((node.right,False,1))\\n        return res\\n```\\n# Recursion\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.res = 0\\n        self.dfs(root.left,True,1)\\n        self.dfs(root.right,False,1)\\n        return self.res\\n    \\n    def dfs(self,node,isLeft,depth):\\n        if not node: return\\n        self.res = max(self.res,depth)\\n        \\n        if isLeft:\\n            self.dfs(node.left,True,1)\\n            self.dfs(node.right,False,depth+1)\\n        else:\\n            self.dfs(node.left,True,depth+1)\\n            self.dfs(node.right,False,1)\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        res = 0\\n        if not root: return res\\n        q= deque() # node, isLeft, depth\\n        if root.left: \\n            q.append((root.left,True,1))\\n        if root.right:\\n            q.append((root.right, False,1))\\n        \\n        while q:\\n            node,isleft,depth = q.popleft()\\n            res = max(res,depth)\\n            if isleft:\\n                if node.right: \\n                    q.append((node.right,False,depth+1))\\n                if node.left:\\n                    q.append((node.left,True,1))\\n                \\n            else:\\n                if node.left:\\n                    q.append((node.left,True,depth+1))\\n                if node.right:\\n                    q.append((node.right,False,1))\\n        return res\\n```\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.res = 0\\n        self.dfs(root.left,True,1)\\n        self.dfs(root.right,False,1)\\n        return self.res\\n    \\n    def dfs(self,node,isLeft,depth):\\n        if not node: return\\n        self.res = max(self.res,depth)\\n        \\n        if isLeft:\\n            self.dfs(node.left,True,1)\\n            self.dfs(node.right,False,depth+1)\\n        else:\\n            self.dfs(node.left,True,depth+1)\\n            self.dfs(node.right,False,1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436432,
                "title": "java-c-javascript-step-by-step-to-1-liner",
                "content": "# Approach\\nDo a DFS keeping track of `left` zigzag path and `right` zigzag path terminating at current `node`. They are both `0` at `root`.\\n\\n`left` zigzag path means current `node` is a left child of its parent and similar definition for `right`.\\n\\nIf we move to `node.left` (a left turn), we are able to extend `right` zigzag path by 1. Also note from `node.left`\\'s point of view, this `right + 1` is actually a *left* zigzag path (because `node.left` is a left child of its parent). *right* zigzag path however becomes `0` since `node.left` is not a right child of its parent. So `node.left` receives `left = right + 1` and `right = 0` from its parent.\\n\\nSimilar reasoning applies for `node.right`.\\n\\nOur path terminates when we reach a `null` node but by that point, we have already counted `leaf node -> null` into the path, so we just take `max(left, right) - 1`. (We are only interested in either `left` or `right` but since other would anyway be `0`, `max()` would work).\\n\\n# Code\\n\\nJava\\n```\\nclass Solution {\\n    private int dfs(TreeNode node, int left, int right) {\\n        if (node == null) return Math.max(left, right) - 1;\\n        int bestPathLeft = dfs(node.left, right + 1, 0);\\n        int bestPathRight = dfs(node.right, 0, left + 1);\\n        return Math.max(bestPathLeft, bestPathRight);\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root, 0, 0);\\n    }\\n}\\n```\\n\\nOptimization 1: If we set initial path values as `-1`, we don\\'t need to do `max() - 1` at `null` node.\\nOptimization 2: Let\\'s use ternary operator.\\n\\n```\\nclass Solution {\\n    private int dfs(TreeNode node, int left, int right) {\\n        return node == null ? Math.max(left, right) : Math.max(dfs(node.left, right + 1, -1), dfs(node.right, -1, left + 1));\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root, -1, -1);\\n    }\\n}\\n```\\n\\nOptimization 3: Use a language that allows default parameters. \\uD83D\\uDE09\\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root, int left = -1, int right = -1) {\\n        return !root ? max(left, right) : max(longestZigZag(root->left, right + 1), longestZigZag(root->right, -1, left + 1));\\n    }\\n};\\n```\\n\\nJavaScript\\n```\\nvar longestZigZag = function(root, left = -1, right = -1) {\\n    return !root ? Math.max(left, right) : Math.max(longestZigZag(root.left, right + 1), longestZigZag(root.right, -1, left + 1))\\n};\\n```\\n\\nTime complexity: $$O(n)$$\\nSpace complexity: $$O(n)$$\\n\\nP.S. Don\\'t write such code at work \\uD83D\\uDE05",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    private int dfs(TreeNode node, int left, int right) {\\n        if (node == null) return Math.max(left, right) - 1;\\n        int bestPathLeft = dfs(node.left, right + 1, 0);\\n        int bestPathRight = dfs(node.right, 0, left + 1);\\n        return Math.max(bestPathLeft, bestPathRight);\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root, 0, 0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int dfs(TreeNode node, int left, int right) {\\n        return node == null ? Math.max(left, right) : Math.max(dfs(node.left, right + 1, -1), dfs(node.right, -1, left + 1));\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        return dfs(root, -1, -1);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root, int left = -1, int right = -1) {\\n        return !root ? max(left, right) : max(longestZigZag(root->left, right + 1), longestZigZag(root->right, -1, left + 1));\\n    }\\n};\\n```\n```\\nvar longestZigZag = function(root, left = -1, right = -1) {\\n    return !root ? Math.max(left, right) : Math.max(longestZigZag(root.left, right + 1), longestZigZag(root.right, -1, left + 1))\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436056,
                "title": "java-binary-tree-longest-zigzag-path",
                "content": "\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n     public void dfs(AtomicInteger count, boolean right, TreeNode start, AtomicInteger maxCount)\\n     {\\n         if (start != null)\\n         {\\n             count.set(count.get() + 1);\\n             right = !right;\\n             dfs(count, right, !right ? start.right : start.left, maxCount);\\n             right = !right;\\n             count.set(count.get() + 1);\\n             dfs(count, right, right ? start.left : start.right, maxCount);\\n         }\\n         else {\\n             maxCount.set(Math.max(maxCount.get(), count.get()));\\n             count.set(-1);\\n         }\\n     }\\n     \\n    public int longestZigZag(TreeNode root) {\\n        AtomicInteger count = new AtomicInteger(-1);\\n        AtomicInteger maxCount = new AtomicInteger(0);\\n        dfs(count, true, root, maxCount);\\n         return maxCount.get();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n     public void dfs(AtomicInteger count, boolean right, TreeNode start, AtomicInteger maxCount)\\n     {\\n         if (start != null)\\n         {\\n             count.set(count.get() + 1);\\n             right = !right;\\n             dfs(count, right, !right ? start.right : start.left, maxCount);\\n             right = !right;\\n             count.set(count.get() + 1);\\n             dfs(count, right, right ? start.left : start.right, maxCount);\\n         }\\n         else {\\n             maxCount.set(Math.max(maxCount.get(), count.get()));\\n             count.set(-1);\\n         }\\n     }\\n     \\n    public int longestZigZag(TreeNode root) {\\n        AtomicInteger count = new AtomicInteger(-1);\\n        AtomicInteger maxCount = new AtomicInteger(0);\\n        dfs(count, true, root, maxCount);\\n         return maxCount.get();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434940,
                "title": "day-109-easy-recursion-approach-c",
                "content": "# Intuition and Approach\\nWe have to simply traverse all possible *zig-zag routes* in the tree\\nand we have condition that we have to go in left and right direction alternatively everytime , we can also start taking the path from any internal node\\n\\nSo, we have to go in all possible routes and find the max answer\\n\\nFirstly we have to make a direction factor which tells us which direction(i.e. left or right) we have to go in\\nso if we have to go right the direction : `dir = 1` and for left direction : `dir =0`\\n\\nNow we also have to create an answer(`ans`) factor which calculate our current path length  \\n\\nNow go to code section to understand question better,\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int max_ans=0;\\n    void solve(TreeNode* root,int dir,int ans){\\n        // left = 0, right = 1  --> parameter for taking the direction\\n        //base condition\\n        if(!root){return;}\\n\\n        //updating the answer\\n        max_ans = max(max_ans,ans);\\n\\n        if(dir==0){\\n            //going in the left direction\\n            solve(root->left,1,ans+1);\\n            //going in the right direction again to see if path is possible in the right direction\\n            //ans=1 because we already started our path\\n            solve(root->right,0,1);\\n        }\\n        else{\\n            //going in the right direction\\n            solve(root->right,0,ans+1);\\n            //going in the left direction again to see if path is possible in the left direction\\n            //ans=1 because we already started our path \\n            solve(root->left,1,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        //condition to go in left part\\n        solve(root,0,0);\\n        //condition to go in right part\\n        solve(root,1,0);\\n        return max_ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int max_ans=0;\\n    void solve(TreeNode* root,int dir,int ans){\\n        // left = 0, right = 1  --> parameter for taking the direction\\n        //base condition\\n        if(!root){return;}\\n\\n        //updating the answer\\n        max_ans = max(max_ans,ans);\\n\\n        if(dir==0){\\n            //going in the left direction\\n            solve(root->left,1,ans+1);\\n            //going in the right direction again to see if path is possible in the right direction\\n            //ans=1 because we already started our path\\n            solve(root->right,0,1);\\n        }\\n        else{\\n            //going in the right direction\\n            solve(root->right,0,ans+1);\\n            //going in the left direction again to see if path is possible in the left direction\\n            //ans=1 because we already started our path \\n            solve(root->left,1,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        //condition to go in left part\\n        solve(root,0,0);\\n        //condition to go in right part\\n        solve(root,1,0);\\n        return max_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434260,
                "title": "java-full-explaination-comments-lbeginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just need to keep track of previous move we took \\ni.e we took left or we took right.\\nSimultaneously we need to check the following condition and move forward :-\\nIf we took left then next step we need to take is right and If we took right then next step we need to take is left\\n**Note :-** \\nIf we took left and we dont have next step right then from left will calculate new max zig zag steps we can go and vice versa we need to check for right too. \\n\\n# Complexity\\n- Time complexity: O(N), where N is the number of nodes in the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H), where H is the height of the tree.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int maxStep = 0;//to keep track of max no. of steps\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left != null){\\n            helper(root.left,1,false,true);\\n        }\\n        if(root.right != null){\\n            helper(root.right,1,true,false);\\n        }\\n        return maxStep;\\n    }\\n    public void helper(TreeNode node,int step,boolean canGoLeft,boolean canGoRight){\\n        maxStep = Math.max(step,maxStep);//calculate the max at that step\\n        //it means previous step we took was right\\n        if(canGoLeft){\\n            if(node.left != null){\\n                helper(node.left,step+1,false,true);\\n            }\\n            //calculating new zigzag from here onwards\\n            if(node.right != null){\\n                helper(node.right,1,true,false);\\n            }\\n        }\\n        //it means previous step we took was left\\n        if(canGoRight){\\n            if(node.right != null){\\n                helper(node.right,step+1,true,false);\\n            }\\n            //calculating new zigzag from here onwards\\n            if(node.left != null){\\n                helper(node.left,1,false,true);\\n            }\\n        }\\n    }\\n}\\n```\\n**Please UpVote If you like it Happy Coding :)\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int maxStep = 0;//to keep track of max no. of steps\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left != null){\\n            helper(root.left,1,false,true);\\n        }\\n        if(root.right != null){\\n            helper(root.right,1,true,false);\\n        }\\n        return maxStep;\\n    }\\n    public void helper(TreeNode node,int step,boolean canGoLeft,boolean canGoRight){\\n        maxStep = Math.max(step,maxStep);//calculate the max at that step\\n        //it means previous step we took was right\\n        if(canGoLeft){\\n            if(node.left != null){\\n                helper(node.left,step+1,false,true);\\n            }\\n            //calculating new zigzag from here onwards\\n            if(node.right != null){\\n                helper(node.right,1,true,false);\\n            }\\n        }\\n        //it means previous step we took was left\\n        if(canGoRight){\\n            if(node.right != null){\\n                helper(node.right,step+1,true,false);\\n            }\\n            //calculating new zigzag from here onwards\\n            if(node.left != null){\\n                helper(node.left,1,false,true);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433432,
                "title": "java-dfs-beats-99-8-lines-clean-simple",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ on the stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int max = 0;\\n\\n  private int longestZigZag(TreeNode node, boolean isRight) {\\n    if (node == null) return 0;\\n\\n    var l = longestZigZag(node.left, true);\\n    var r = longestZigZag(node.right, false);\\n\\n    max = Math.max(max, 1 + (isRight ? l : r));\\n\\n    return 1 + (isRight ? r : l);\\n  }\\n\\n  public int longestZigZag(TreeNode root) {\\n    return Math.max(longestZigZag(root, true), max) - 1;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  int max = 0;\\n\\n  private int longestZigZag(TreeNode node, boolean isRight) {\\n    if (node == null) return 0;\\n\\n    var l = longestZigZag(node.left, true);\\n    var r = longestZigZag(node.right, false);\\n\\n    max = Math.max(max, 1 + (isRight ? l : r));\\n\\n    return 1 + (isRight ? r : l);\\n  }\\n\\n  public int longestZigZag(TreeNode root) {\\n    return Math.max(longestZigZag(root, true), max) - 1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433045,
                "title": "a-simple-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar longestZigZag = function(root) {\\n    let max = 0;\\n    \\n    const helper = (node, prev, length) => {\\n    \\n        if(node === null)\\n            return null;\\n        \\n        max = Math.max(max, length);\\n        \\n        helper(node.left, \"l\" , prev === \"r\" ? length + 1 : 1);\\n        helper(node.right, \"r\" , prev === \"l\" ? length + 1 : 1);\\n    }\\n    \\n    \\n    helper(root, \"l\", 0); \\n    helper(root, \"r\", 0);\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nvar longestZigZag = function(root) {\\n    let max = 0;\\n    \\n    const helper = (node, prev, length) => {\\n    \\n        if(node === null)\\n            return null;\\n        \\n        max = Math.max(max, length);\\n        \\n        helper(node.left, \"l\" , prev === \"r\" ? length + 1 : 1);\\n        helper(node.right, \"r\" , prev === \"l\" ? length + 1 : 1);\\n    }\\n    \\n    \\n    helper(root, \"l\", 0); \\n    helper(root, \"r\", 0);\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1244271,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    vector<int>postorder(TreeNode* root){\\n        \\n        if(root == NULL)\\n            return {-1, -1};\\n        \\n        int left = postorder(root->left)[1] + 1;\\n        int right = postorder(root->right)[0] + 1;\\n        \\n        ans = max({ans, left, right});\\n        return {left, right};\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        \\n        postorder(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    vector<int>postorder(TreeNode* root){\\n        \\n        if(root == NULL)\\n            return {-1, -1};\\n        \\n        int left = postorder(root->left)[1] + 1;\\n        int right = postorder(root->right)[0] + 1;\\n        \\n        ans = max({ans, left, right});\\n        return {left, right};\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        \\n        postorder(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231674,
                "title": "c-solution-memoization-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    //0->left,1->right,2->initial node ,both ways possible\\n    \\n    map< pair<TreeNode*,int>,int>mp; \\n    int recurs(TreeNode* root,int direction)\\n    {\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n        \\n        if(mp[{root,direction}]!=0)\\n        {\\n                return mp[{root,direction}];\\n        }\\n        \\n        if(direction==0)\\n        {\\n            return mp[{root,direction}]= recurs(root->right,1)+1;\\n        }\\n        else if(direction==1)\\n        {\\n             return mp[{root,direction}]=recurs(root->left,0)+1;\\n        }\\n        else\\n        {\\n            return mp[{root,direction}]=max(recurs(root->right,1)+1,recurs(root->left,0)+1);\\n        }\\n    }\\n    \\n    \\n    int ans=0;\\n    void pre(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        \\n        ans=max(recurs(root,2),ans);\\n        pre(root->left);\\n        pre(root->right);\\n    }\\n\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n        pre(root);\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    //0->left,1->right,2->initial node ,both ways possible\\n    \\n    map< pair<TreeNode*,int>,int>mp; \\n    int recurs(TreeNode* root,int direction)\\n    {\\n        if(root==NULL)\\n        {\\n            return 0;\\n        }\\n        \\n        if(mp[{root,direction}]!=0)\\n        {\\n                return mp[{root,direction}];\\n        }\\n        \\n        if(direction==0)\\n        {\\n            return mp[{root,direction}]= recurs(root->right,1)+1;\\n        }\\n        else if(direction==1)\\n        {\\n             return mp[{root,direction}]=recurs(root->left,0)+1;\\n        }\\n        else\\n        {\\n            return mp[{root,direction}]=max(recurs(root->right,1)+1,recurs(root->left,0)+1);\\n        }\\n    }\\n    \\n    \\n    int ans=0;\\n    void pre(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        \\n        ans=max(recurs(root,2),ans);\\n        pre(root->left);\\n        pre(root->right);\\n    }\\n\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n        pre(root);\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532242,
                "title": "python-dfs-explanation",
                "content": "* Use \"check\" as a checker that come from which side (left or right)\\n* if come from root, check = 0\\n* elif come from left node, check = 1\\n* elif come from right node, check = 2 \\n* \"count\" is a number of continuous zigzag nodes\\n* \"self.res\" is keep the maximum of \"count\" \\n\\n\\'\\'\\'\\n\\n\\n\\tdef longestZigZag(self, root):\\n\\t\\t\\tcheck = 0 # left = 1, right = 2\\n\\t\\t\\tcount = 0\\n\\t\\t\\tself.res = 0\\n\\n\\t\\t\\tdef dfs(node, count, check):\\n\\t\\t\\t\\tif node:\\n\\t\\t\\t\\t\\tif check == 1: # from left                    \\n\\t\\t\\t\\t\\t\\tdfs(node.left, 0, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, count+1, 2)\\n\\t\\t\\t\\t\\telif check == 2: # from right\\n\\t\\t\\t\\t\\t\\tdfs(node.left, count+1, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, 0, 2)\\n\\t\\t\\t\\t\\telif check == 0: # from root\\n\\t\\t\\t\\t\\t\\tdfs(node.left, count, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, count, 2)\\n\\t\\t\\t\\tself.res = max(self.res, count)\\n\\t\\t\\tdfs(root, count, check)\\n\\t\\t\\treturn self.res\\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "* Use \"check\" as a checker that come from which side (left or right)\\n* if come from root, check = 0\\n* elif come from left node, check = 1\\n* elif come from right node, check = 2 \\n* \"count\" is a number of continuous zigzag nodes\\n* \"self.res\" is keep the maximum of \"count\" \\n\\n\\'\\'\\'\\n\\n\\n\\tdef longestZigZag(self, root):\\n\\t\\t\\tcheck = 0 # left = 1, right = 2\\n\\t\\t\\tcount = 0\\n\\t\\t\\tself.res = 0\\n\\n\\t\\t\\tdef dfs(node, count, check):\\n\\t\\t\\t\\tif node:\\n\\t\\t\\t\\t\\tif check == 1: # from left                    \\n\\t\\t\\t\\t\\t\\tdfs(node.left, 0, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, count+1, 2)\\n\\t\\t\\t\\t\\telif check == 2: # from right\\n\\t\\t\\t\\t\\t\\tdfs(node.left, count+1, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, 0, 2)\\n\\t\\t\\t\\t\\telif check == 0: # from root\\n\\t\\t\\t\\t\\t\\tdfs(node.left, count, 1)\\n\\t\\t\\t\\t\\t\\tdfs(node.right, count, 2)\\n\\t\\t\\t\\tself.res = max(self.res, count)\\n\\t\\t\\tdfs(root, count, check)\\n\\t\\t\\treturn self.res\\n\\'\\'\\'",
                "codeTag": "Python3"
            },
            {
                "id": 531819,
                "title": "c-top-down-recusrion",
                "content": "```\\n#define LEFT 0\\n#define RIGHT 1\\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    void maxZigZag(TreeNode* root, int dir, int curr)\\n    {\\n        if(!root) return;\\n        \\n        //cout<<root->val<<endl;\\n        max1=max(max1,curr);\\n        if(dir==LEFT)\\n        {\\n            if(root->left)\\n            {\\n                maxZigZag(root->left, RIGHT, curr+1);\\n            }\\n            if(root->right){\\n                maxZigZag(root->right, LEFT, 1);\\n            }\\n        }\\n        else\\n        {\\n            if(root->right)\\n            {\\n                maxZigZag(root->right, LEFT, curr+1);\\n            }\\n            if(root->left)\\n            {\\n                maxZigZag(root->left, RIGHT, 1);\\n            }\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        maxZigZag(root,LEFT,0);\\n        return max1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define LEFT 0\\n#define RIGHT 1\\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    void maxZigZag(TreeNode* root, int dir, int curr)\\n    {\\n        if(!root) return;\\n        \\n        //cout<<root->val<<endl;\\n        max1=max(max1,curr);\\n        if(dir==LEFT)\\n        {\\n            if(root->left)\\n            {\\n                maxZigZag(root->left, RIGHT, curr+1);\\n            }\\n            if(root->right){\\n                maxZigZag(root->right, LEFT, 1);\\n            }\\n        }\\n        else\\n        {\\n            if(root->right)\\n            {\\n                maxZigZag(root->right, LEFT, curr+1);\\n            }\\n            if(root->left)\\n            {\\n                maxZigZag(root->left, RIGHT, 1);\\n            }\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        maxZigZag(root,LEFT,0);\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3435726,
                "title": "c-solution-easy-approach-recursive-code",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count(TreeNode* root,int check,int ans){\\n        if(!root)\\n          return ans;\\n        if(check==0)   //for left child\\n        {\\n            int a=0;\\n            a=count(root->left,1,ans+1);    //zigzag start from any previous node\\n            a=max(a,count(root->right,0,0)); //new zigzag from current node\\n            return a;   //maxi. length of zigzag upto current node\\n        }\\n        if(check==1)   //for right child\\n        {\\n            int b=0;\\n            b=count(root->right,0,ans+1);    //zigzag start from any previous node\\n            b=max(b,count(root->left,1,0));  //new zigzag from current node\\n            return b;   //maxi. length of zigzag upto current node\\n        }\\n        return max(count(root->left,1,0),count(root->right,0,0)); //for root( left child and right child)\\n    }\\n    int longestZigZag(TreeNode* root) {\\n       if(!root)\\n         return 0;\\n        int ans=count(root,-1,0);\\n        return ans;\\n    }\\n};\\n```\\n#Please UPVOTE if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count(TreeNode* root,int check,int ans){\\n        if(!root)\\n          return ans;\\n        if(check==0)   //for left child\\n        {\\n            int a=0;\\n            a=count(root->left,1,ans+1);    //zigzag start from any previous node\\n            a=max(a,count(root->right,0,0)); //new zigzag from current node\\n            return a;   //maxi. length of zigzag upto current node\\n        }\\n        if(check==1)   //for right child\\n        {\\n            int b=0;\\n            b=count(root->right,0,ans+1);    //zigzag start from any previous node\\n            b=max(b,count(root->left,1,0));  //new zigzag from current node\\n            return b;   //maxi. length of zigzag upto current node\\n        }\\n        return max(count(root->left,1,0),count(root->right,0,0)); //for root( left child and right child)\\n    }\\n    int longestZigZag(TreeNode* root) {\\n       if(!root)\\n         return 0;\\n        int ans=count(root,-1,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435693,
                "title": "accepted-swift-solution-using-dfs",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var maxSteps = 0\\n    func longestZigZag(_ root: TreeNode?) -> Int {\\n        dfs(root?.right, true, 1)\\n        dfs(root?.left, false, 1)\\n        return maxSteps\\n    }\\n\\n    func dfs(_ node: TreeNode?, _ isLeft: Bool, _ steps: Int) {\\n        if node == nil {\\n            return\\n        }\\n        maxSteps = max(maxSteps, steps)\\n        if isLeft {\\n            dfs(node?.left, false, steps+1)\\n            dfs(node?.right, true, 1)\\n        } else {\\n            dfs(node?.right, true, steps+1)\\n            dfs(node?.left, false, 1)\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    var maxSteps = 0\\n    func longestZigZag(_ root: TreeNode?) -> Int {\\n        dfs(root?.right, true, 1)\\n        dfs(root?.left, false, 1)\\n        return maxSteps\\n    }\\n\\n    func dfs(_ node: TreeNode?, _ isLeft: Bool, _ steps: Int) {\\n        if node == nil {\\n            return\\n        }\\n        maxSteps = max(maxSteps, steps)\\n        if isLeft {\\n            dfs(node?.left, false, steps+1)\\n            dfs(node?.right, true, 1)\\n        } else {\\n            dfs(node?.right, true, steps+1)\\n            dfs(node?.left, false, 1)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435555,
                "title": "c-easy-code-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxC = 0;\\n    void count(TreeNode *node, int dir, int curr)\\n    {\\n        if(node == NULL)\\n            return;\\n        maxC = max(maxC, curr);\\n\\n        if(dir == 1){\\n           count(node -> left, 0, curr + 1);\\n            count(node -> right, 1, 1);\\n        }\\n        else\\n        {\\n            count(node -> right, 1, curr + 1);\\n            count(node -> left, 0, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n\\t    // 1 for left, 0 for right\\n        count(root, 1, 0);\\n        count(root, 0, 0);\\n        return maxC;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxC = 0;\\n    void count(TreeNode *node, int dir, int curr)\\n    {\\n        if(node == NULL)\\n            return;\\n        maxC = max(maxC, curr);\\n\\n        if(dir == 1){\\n           count(node -> left, 0, curr + 1);\\n            count(node -> right, 1, 1);\\n        }\\n        else\\n        {\\n            count(node -> right, 1, curr + 1);\\n            count(node -> left, 0, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n\\t    // 1 for left, 0 for right\\n        count(root, 1, 0);\\n        count(root, 0, 0);\\n        return maxC;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435338,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    void solve(TreeNode* node, bool goLeft, int currPathLen) \\n    {\\n        if (!node) return;\\n        res = max(res, currPathLen);\\n        if (goLeft) \\n        {\\n            solve(node->left, false, currPathLen + 1);\\n            solve(node->right, true, 1);\\n        }\\n         else \\n         {\\n            solve(node->right, true, currPathLen + 1);\\n            solve(node->left, false, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root)\\n     {\\n        solve(root, true, 0);\\n        solve(root, false, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int res = 0;\\n    void solve(TreeNode* node, bool goLeft, int currPathLen) \\n    {\\n        if (!node) return;\\n        res = max(res, currPathLen);\\n        if (goLeft) \\n        {\\n            solve(node->left, false, currPathLen + 1);\\n            solve(node->right, true, 1);\\n        }\\n         else \\n         {\\n            solve(node->right, true, currPathLen + 1);\\n            solve(node->left, false, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root)\\n     {\\n        solve(root, true, 0);\\n        solve(root, false, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434952,
                "title": "time-space-98-beats-c-easy-to-understand-dfs",
                "content": "````\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int &ans,int s,int d){\\n        if(root == NULL){\\n            return;\\n        }\\n        ans = max(ans,d);\\n        if(s==1){\\n            solve(root->left,ans,0,d+1);\\n            solve(root->right,ans,1,1);\\n        }else{\\n            solve(root->right,ans,1,d+1);\\n            solve(root->left,ans,0,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        solve(root->left,ans,0,1);\\n        solve(root->right,ans,1,1);\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,int &ans,int s,int d){\\n        if(root == NULL){\\n            return;\\n        }\\n        ans = max(ans,d);\\n        if(s==1){\\n            solve(root->left,ans,0,d+1);\\n            solve(root->right,ans,1,1);\\n        }else{\\n            solve(root->right,ans,1,d+1);\\n            solve(root->left,ans,0,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        solve(root->left,ans,0,1);\\n        solve(root->right,ans,1,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434378,
                "title": "java-python-kotlin-golang-intuitive-dfs-recursive-solution",
                "content": "# Intuition\\nAt first , it looks like a DFS to calculate the height of a BST.\\nThen the zigzag forces to alternate direction (right or left). If previous node explored was `left`, then the next node must be `right` ( vice-versa). We have to keep track if the current node should explore left or right.\\n\\n# Approach\\n\\nWe have to keep track if the current node should explore left or right.\\nIn addition not to have a global variable, the level is passed in parameter to the recursive function.\\n\\n```Java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(longestZigZag(root, true, 0), longestZigZag(root, false, 0));\\n    }\\n\\n    public int longestZigZag(TreeNode root, boolean isLeft, int level) {\\n        //System.out.println(\"isLeft = \" + isLeft + \" root = \" + root + \" level = \"+ level);\\n        if(root == null) return level;\\n        \\n        if(isLeft){\\n            if(root.left == null) return level;\\n            return longestZigZag(root.left, false, level + 1);\\n        }else{\\n            if(root.right == null) return level;\\n            return longestZigZag(root.right, true, level + 1);\\n        }\\n\\n    }\\n}\\n```\\n\\nAt first, my initial implementation worked on all except the first example. I assumed the longest always starts from the root node.\\n\\n\\n![leetcode_sample_1_1702.png](https://assets.leetcode.com/users/images/9ab48f18-91f7-4817-b872-cd4845763cf7_1681897926.6954088.png)\\n\\nBut example 1, the longest zig zag doesn\\'t start at the root node. But at the first right child of the root node.\\n`If direction stays the same twice, we have to reset the level to zero`. Otherwise increment the level by one.\\n\\n## Illustration from a left Node\\n```\\n    // TDLR\\n    return Math.max(longestZigZag(root.left, false, level + 1), longestZigZag(root.left, true, 0));\\n\\n    // more detail on this one line.\\n    /**\\n    *\\n    *      x\\n    *     /\\n    *    x\\n    *   /\\n    *  x\\n    *\\n    **/\\n    int leftOfLeft = longestZigZag(root.left, true, 0); // reset level to 0\\n\\n    /**\\n    *\\n    *      x\\n    *     /\\n    *    x\\n    *     \\\\\\n    *      x\\n    *\\n    **/\\n    int rightOfLeft = longestZigZag(root.left, false, level + 1); // keep the zig zag, so increment the level\\n\\n```\\n\\n# Complexity\\n\\n- Time complexity:\\nO(n) , we explore all tree nodes\\n\\n- Space complexity:\\nO(height)\\n\\n# Code\\n\\n```Java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(longestZigZag(root, true, 0), longestZigZag(root, false, 0));\\n    }\\n\\n    public int longestZigZag(TreeNode root, boolean isLeft, int level) {\\n        if(root == null) return level;\\n        \\n        if(isLeft){\\n            if(root.left == null) return level;\\n            // the BST doesn\\'t have to start from the root node. If the same direction is done twice, reset the level to 0\\n            return Math.max(longestZigZag(root.left, false, level + 1), longestZigZag(root.left, true, 0));\\n        }else{\\n            if(root.right == null) return level;\\n            return Math.max(longestZigZag(root.right, true, level + 1), longestZigZag(root.right, false, 0));\\n        }\\n\\n    }\\n}\\n```\\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def longestZigZag(root: Optional[TreeNode], isLeft: bool, level: int) -> int:\\n            if root is None:\\n                return level\\n            \\n            if isLeft:\\n                if root.left is None: return level\\n                return max(longestZigZag(root.left, False, level + 1), longestZigZag(root.left, True, 0))\\n            else:\\n                if root.right is None: return level\\n                return max(longestZigZag(root.right, True, level + 1), longestZigZag(root.right, False, 0))\\n        \\n        return max(longestZigZag(root, True, 0), longestZigZag(root, False, 0))\\n```\\n```kotlin []\\n/**\\n * Example:\\n * var ti = TreeNode(5)\\n * var v = ti.`val`\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n    fun longestZigZag(root: TreeNode?): Int {\\n        return maxOf(longestZigZag(root, true, 0),  longestZigZag(root, false, 0))\\n    }\\n\\n    fun longestZigZag(root: TreeNode?, isLeft: Boolean, level: Int): Int {\\n        if(root == null) return level\\n\\n        if(isLeft){\\n            return root?.left?.let{\\n                 maxOf(longestZigZag(it, false, level + 1), longestZigZag(it,  true, 0))\\n            } ?: level\\n        }else{\\n            return root?.right?.let{\\n                 maxOf(longestZigZag(it, true, level + 1), longestZigZag(it, false, 0))\\n            } ?: level\\n        }\\n    }\\n}\\n\\n```\\n```golang []\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc longestZigZag(root *TreeNode) int {\\n\\treturn max(longestZigZagRec(root, true, 0), longestZigZagRec(root, false, 0))\\n}\\n\\nfunc longestZigZagRec(root *TreeNode, isLeft bool, level int) int {\\n\\tif root == nil {\\n\\t\\treturn level\\n\\t}\\n\\n\\tif isLeft {\\n\\t\\tleft := root.Left\\n\\t\\tif left == nil { return  level}\\n\\t\\treturn max(longestZigZagRec(left, false, level +1 ), longestZigZagRec(left, true, 0))\\n\\t}else{\\n\\t\\tright := root.Right\\n\\t\\tif right == nil {return  level}\\n\\t\\treturn max(longestZigZagRec(right, true, level+1), longestZigZagRec(right, false, 0))\\n\\t}\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```\\n\\nThanks for reading until the end.\\nIf some code is not fluent in their native programming language, please suggest in the comment section.\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Go",
                    "Kotlin",
                    "Recursion"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(longestZigZag(root, true, 0), longestZigZag(root, false, 0));\\n    }\\n\\n    public int longestZigZag(TreeNode root, boolean isLeft, int level) {\\n        //System.out.println(\"isLeft = \" + isLeft + \" root = \" + root + \" level = \"+ level);\\n        if(root == null) return level;\\n        \\n        if(isLeft){\\n            if(root.left == null) return level;\\n            return longestZigZag(root.left, false, level + 1);\\n        }else{\\n            if(root.right == null) return level;\\n            return longestZigZag(root.right, true, level + 1);\\n        }\\n\\n    }\\n}\\n```\n```\\n    // TDLR\\n    return Math.max(longestZigZag(root.left, false, level + 1), longestZigZag(root.left, true, 0));\\n\\n    // more detail on this one line.\\n    /**\\n    *\\n    *      x\\n    *     /\\n    *    x\\n    *   /\\n    *  x\\n    *\\n    **/\\n    int leftOfLeft = longestZigZag(root.left, true, 0); // reset level to 0\\n\\n    /**\\n    *\\n    *      x\\n    *     /\\n    *    x\\n    *     \\\\\\n    *      x\\n    *\\n    **/\\n    int rightOfLeft = longestZigZag(root.left, false, level + 1); // keep the zig zag, so increment the level\\n\\n```\n```Java []\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(longestZigZag(root, true, 0), longestZigZag(root, false, 0));\\n    }\\n\\n    public int longestZigZag(TreeNode root, boolean isLeft, int level) {\\n        if(root == null) return level;\\n        \\n        if(isLeft){\\n            if(root.left == null) return level;\\n            // the BST doesn\\'t have to start from the root node. If the same direction is done twice, reset the level to 0\\n            return Math.max(longestZigZag(root.left, false, level + 1), longestZigZag(root.left, true, 0));\\n        }else{\\n            if(root.right == null) return level;\\n            return Math.max(longestZigZag(root.right, true, level + 1), longestZigZag(root.right, false, 0));\\n        }\\n\\n    }\\n}\\n```\n```python []\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        def longestZigZag(root: Optional[TreeNode], isLeft: bool, level: int) -> int:\\n            if root is None:\\n                return level\\n            \\n            if isLeft:\\n                if root.left is None: return level\\n                return max(longestZigZag(root.left, False, level + 1), longestZigZag(root.left, True, 0))\\n            else:\\n                if root.right is None: return level\\n                return max(longestZigZag(root.right, True, level + 1), longestZigZag(root.right, False, 0))\\n        \\n        return max(longestZigZag(root, True, 0), longestZigZag(root, False, 0))\\n```\n```kotlin []\\n/**\\n * Example:\\n * var ti = TreeNode(5)\\n * var v = ti.`val`\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n    fun longestZigZag(root: TreeNode?): Int {\\n        return maxOf(longestZigZag(root, true, 0),  longestZigZag(root, false, 0))\\n    }\\n\\n    fun longestZigZag(root: TreeNode?, isLeft: Boolean, level: Int): Int {\\n        if(root == null) return level\\n\\n        if(isLeft){\\n            return root?.left?.let{\\n                 maxOf(longestZigZag(it, false, level + 1), longestZigZag(it,  true, 0))\\n            } ?: level\\n        }else{\\n            return root?.right?.let{\\n                 maxOf(longestZigZag(it, true, level + 1), longestZigZag(it, false, 0))\\n            } ?: level\\n        }\\n    }\\n}\\n\\n```\n```golang []\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc longestZigZag(root *TreeNode) int {\\n\\treturn max(longestZigZagRec(root, true, 0), longestZigZagRec(root, false, 0))\\n}\\n\\nfunc longestZigZagRec(root *TreeNode, isLeft bool, level int) int {\\n\\tif root == nil {\\n\\t\\treturn level\\n\\t}\\n\\n\\tif isLeft {\\n\\t\\tleft := root.Left\\n\\t\\tif left == nil { return  level}\\n\\t\\treturn max(longestZigZagRec(left, false, level +1 ), longestZigZagRec(left, true, 0))\\n\\t}else{\\n\\t\\tright := root.Right\\n\\t\\tif right == nil {return  level}\\n\\t\\treturn max(longestZigZagRec(right, true, level+1), longestZigZagRec(right, false, 0))\\n\\t}\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433966,
                "title": "easy-solution-in-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use 0 for nodes coming from the left and 1 for nodes coming from the right.\\n\\nFirstly, we declare a function that counts the zigzag path. One thing to notice is that if a node comes from the left and then goes left again, the zigzag path will be 1. If a node comes from the left and goes to the right, the zigzag path count will increase by 1 from the previous count and vice versa.\\n\\nThe \"solve\" function takes three parameters: \"root\", which is the treenode, \"dir\" which determines the direction the nodes are coming from, and \"len\" which shows the length of the zigzag path until the current node.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N), where N represents the total number of nodes in the tree. This is because we traverse each node precisely once.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n\\n    void solve(TreeNode* root, int dir, int len){\\n        if(root==NULL)  \\n            return;\\n        ans = max(ans, len);\\n        if(dir==0){\\n            // node comes from the left and then goes left again, the zigzag path will be 1.\\n            solve(root->left, 0, 1);\\n            // node comes from the left and goes to the right, the zigzag path count will increase by 1 from the previous count.\\n            solve(root->right, 1, len+1);\\n        }else{\\n            // node comes from the right and then goes right again, the zigzag path will be 1.\\n            solve(root->left, 0, len+1);\\n            // node comes from the right and goes to the left, the zigzag path count will increase by 1 from the previous count.\\n            solve(root->right, 1, 1);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root->left, 0, 1);\\n        solve(root->right, 1, 1);\\n        return ans;\\n    }\\n};\\n```\\n\\n![images.jpg](https://assets.leetcode.com/users/images/ff765eb1-bf72-408a-a59f-828ffa968ac9_1681889626.1299875.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n\\n    void solve(TreeNode* root, int dir, int len){\\n        if(root==NULL)  \\n            return;\\n        ans = max(ans, len);\\n        if(dir==0){\\n            // node comes from the left and then goes left again, the zigzag path will be 1.\\n            solve(root->left, 0, 1);\\n            // node comes from the left and goes to the right, the zigzag path count will increase by 1 from the previous count.\\n            solve(root->right, 1, len+1);\\n        }else{\\n            // node comes from the right and then goes right again, the zigzag path will be 1.\\n            solve(root->left, 0, len+1);\\n            // node comes from the right and goes to the left, the zigzag path count will increase by 1 from the previous count.\\n            solve(root->right, 1, 1);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root->left, 0, 1);\\n        solve(root->right, 1, 1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433861,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public:\\n    int maxLength=0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength=max(maxLength,currLength);\\n        solve(root->left,0,dir?currLength+1:1);\\n        solve(root->right,1,dir?1:currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    public:\\n    int maxLength=0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength=max(maxLength,currLength);\\n        solve(root->left,0,dir?currLength+1:1);\\n        solve(root->right,1,dir?1:currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433693,
                "title": "post-order-dfs-c",
                "content": "```\\nclass Solution {\\n    pair<int, int> dfs(TreeNode* root, int &ans) {\\n        if(!root) return {0, 0};\\n\\n        auto l = dfs(root -> left, ans);\\n        auto r = dfs(root -> right, ans);\\n\\n        int maxLeft = 1 + l.second;\\n        int maxRight = 1 + r.first;\\n        ans = max(ans, max(maxLeft, maxRight) - 1);\\n\\n        return {maxLeft, maxRight};\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    pair<int, int> dfs(TreeNode* root, int &ans) {\\n        if(!root) return {0, 0};\\n\\n        auto l = dfs(root -> left, ans);\\n        auto r = dfs(root -> right, ans);\\n\\n        int maxLeft = 1 + l.second;\\n        int maxRight = 1 + r.first;\\n        ans = max(ans, max(maxLeft, maxRight) - 1);\\n\\n        return {maxLeft, maxRight};\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433476,
                "title": "simple-python-solution-breadth-first-search",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        q= deque()\\n        q.append([root,\\'\\',0])\\n        ans=0\\n        while(q):\\n            u,prev_dir,cnt=q.popleft()\\n            ans= max(ans,cnt)\\n            if(u.left):\\n                if(prev_dir==\\'r\\'):\\n                    q.append([u.left,\\'l\\',cnt+1])\\n                else:\\n                    q.append([u.left,\\'l\\',1])\\n            if(u.right):\\n                if(prev_dir==\\'l\\'):\\n                    q.append([u.right,\\'r\\',cnt+1])\\n                else:\\n                    q.append([u.right,\\'r\\',1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        q= deque()\\n        q.append([root,\\'\\',0])\\n        ans=0\\n        while(q):\\n            u,prev_dir,cnt=q.popleft()\\n            ans= max(ans,cnt)\\n            if(u.left):\\n                if(prev_dir==\\'r\\'):\\n                    q.append([u.left,\\'l\\',cnt+1])\\n                else:\\n                    q.append([u.left,\\'l\\',1])\\n            if(u.right):\\n                if(prev_dir==\\'l\\'):\\n                    q.append([u.right,\\'r\\',cnt+1])\\n                else:\\n                    q.append([u.right,\\'r\\',1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433419,
                "title": "beats-100-c-15-lines-using-dfs",
                "content": "# Intuition\\nTo understand the intuition behind the given code, we can think of a zigzag path in a binary tree as a path that alternates between going left and going right. The length of the path is the number of edges traversed in the path. For example, in the tree below, the zigzag path with length 4 is indicated by the bold edges:\\n\\n\\n# Approach\\nThe code uses a depth-first search (DFS) approach to traverse the given binary tree. For each node, it computes three values: the length of the longest zigzag path starting from the node and going left, the length of the longest zigzag path starting from the node and going right, and the maximum length of zigzag path found so far in the tree. The maximum length of zigzag path can be obtained by taking the maximum of the three values computed for the root node.\\n\\nThe DFS function dfs takes a node as input and returns a list of three integers. If the node is None, it returns [-1, -1, -1] to indicate that there is no path. Otherwise, it recursively calls dfs on the left and right subtrees of the node and computes the three values described above using the values returned by the recursive calls.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        vector<int> res = dfs(root);\\n        return res[2];\\n    }\\nprivate:\\n    vector<int> dfs(TreeNode* node) {\\n        if (node == nullptr) return {-1, -1, -1};\\n        vector<int> lsubt = dfs(node->left);\\n        vector<int> rsubt = dfs(node->right);\\n        int llen = lsubt[1] + 1;\\n        int rlen = rsubt[0] + 1;\\n        int maxlen = max({llen, rlen, lsubt[2], rsubt[2]});\\n        return {llen, rlen, maxlen};\\n    }\\n};\\n```\\n\\nPlease Upvote",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        vector<int> res = dfs(root);\\n        return res[2];\\n    }\\nprivate:\\n    vector<int> dfs(TreeNode* node) {\\n        if (node == nullptr) return {-1, -1, -1};\\n        vector<int> lsubt = dfs(node->left);\\n        vector<int> rsubt = dfs(node->right);\\n        int llen = lsubt[1] + 1;\\n        int rlen = rsubt[0] + 1;\\n        int maxlen = max({llen, rlen, lsubt[2], rsubt[2]});\\n        return {llen, rlen, maxlen};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433178,
                "title": "ruby-dfs-solution",
                "content": "# Code\\n```\\ndef dfs(root, left, count)\\n  return unless root\\n  @max = [@max, count].max\\n  dfs(root.left, false, left ? count+1 : 1)\\n  dfs(root.right, true, !left ? count+1 : 1)\\nend\\n\\ndef longest_zig_zag(root)\\n  @max = 0\\n  dfs(root, true, 0)\\n  dfs(root, false, 0)\\n  @max\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef dfs(root, left, count)\\n  return unless root\\n  @max = [@max, count].max\\n  dfs(root.left, false, left ? count+1 : 1)\\n  dfs(root.right, true, !left ? count+1 : 1)\\nend\\n\\ndef longest_zig_zag(root)\\n  @max = 0\\n  dfs(root, true, 0)\\n  dfs(root, false, 0)\\n  @max\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3433050,
                "title": "javascript-4-lines-dfs-time-o-n-100-space-o-n",
                "content": "# Complexity\\n- Time complexity: O(n), beats 100%\\n- Space complexity: O(n), beats 80.4%\\n\\n# Code\\n```\\nconst f = ( r, p, v ) => {\\n    if ( !r ) return v - 1\\n    if ( p ) return Math.max( f( r.left, 0, v+1 ), f( r.right, 1, 1 ) )\\n    else return Math.max( f( r.right, 1, v+1 ), f( r.left, 0, 1 ) )\\n}, longestZigZag = r => Math.max( f( r.left, 0, 1 ), f( r.right, 1, 1 ) )\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nconst f = ( r, p, v ) => {\\n    if ( !r ) return v - 1\\n    if ( p ) return Math.max( f( r.left, 0, v+1 ), f( r.right, 1, 1 ) )\\n    else return Math.max( f( r.right, 1, v+1 ), f( r.left, 0, 1 ) )\\n}, longestZigZag = r => Math.max( f( r.left, 0, 1 ), f( r.right, 1, 1 ) )\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2839142,
                "title": "java-simple-solution-using-dfs",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public void helper(TreeNode root, int temp, String dir) {\\n        ans = Math.max(ans, temp);\\n        if(root == null)\\n            return;\\n        \\n        if(dir.equals(\"left\")) {\\n            helper(root.right, temp + 1, \"right\");\\n            helper(root.left, 1, \"left\");\\n        }\\n        if(dir.equals(\"right\")) {\\n            helper(root.right, 1, \"right\");\\n            helper(root.left, temp + 1, \"left\");\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        if(root == null | (root.left == null && root.right == null))\\n            return 0;\\n        helper(root.left, 1, \"left\");\\n        helper(root.right, 1, \"right\");\\n        return ans-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public void helper(TreeNode root, int temp, String dir) {\\n        ans = Math.max(ans, temp);\\n        if(root == null)\\n            return;\\n        \\n        if(dir.equals(\"left\")) {\\n            helper(root.right, temp + 1, \"right\");\\n            helper(root.left, 1, \"left\");\\n        }\\n        if(dir.equals(\"right\")) {\\n            helper(root.right, 1, \"right\");\\n            helper(root.left, temp + 1, \"left\");\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        if(root == null | (root.left == null && root.right == null))\\n            return 0;\\n        helper(root.left, 1, \"left\");\\n        helper(root.right, 1, \"right\");\\n        return ans-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870342,
                "title": "o-n-java-solution-with-comment-explanation-easy-to-understand",
                "content": "**Logic :** \\nEvery node have two choices : \\n- Follow the parent direction what his parent want\\n- Don\\'t follow the parent given direction and go reverse direction (may be find longest path)\\n\\nThen update the `max ` accordingly `parent_direction_longest_length` and `child_own_direction_longest_length`.\\n\\n```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root, false);\\n        solve(root, true);\\n        return max;\\n    }\\n\\n    // Right direction -> dir = true\\n    // Left direction -> dir = false\\n    public int solve(TreeNode node, boolean dir) {\\n        if (node == null) return -1;\\n\\n        // if we go right dir from node\\n        int right = ((node.right == null) ? -1 : solve(node.right, false)) + 1;\\n        \\n        // if we go left dir from node\\n        int left = ((node.left == null) ? -1 : solve(node.left, true)) + 1;\\n\\n        // if child is not serious about parent direction\\n        // He want to go own direction for check longest path (reverse of given parent direction)\\n        int childDirProfit = (dir) ? left : right;\\n        // if coming from right go left and vice versa for parent\\n        int parentDirProfit = (dir) ? right : left; \\n\\n        // update the max\\n        max = Math.max(max, Math.max(childDirProfit, parentDirProfit));\\n        \\n        // return what parent wanted\\n        return parentDirProfit;\\n    }\\n}\\n```\\nIt\\'s a simple DFS Solution so it will take `O(n)` times.\\nn = number of node in Tree.\\n\\n\\n**Don\\'t Forget to upvote if you found it helpful :)**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root, false);\\n        solve(root, true);\\n        return max;\\n    }\\n\\n    // Right direction -> dir = true\\n    // Left direction -> dir = false\\n    public int solve(TreeNode node, boolean dir) {\\n        if (node == null) return -1;\\n\\n        // if we go right dir from node\\n        int right = ((node.right == null) ? -1 : solve(node.right, false)) + 1;\\n        \\n        // if we go left dir from node\\n        int left = ((node.left == null) ? -1 : solve(node.left, true)) + 1;\\n\\n        // if child is not serious about parent direction\\n        // He want to go own direction for check longest path (reverse of given parent direction)\\n        int childDirProfit = (dir) ? left : right;\\n        // if coming from right go left and vice versa for parent\\n        int parentDirProfit = (dir) ? right : left; \\n\\n        // update the max\\n        max = Math.max(max, Math.max(childDirProfit, parentDirProfit));\\n        \\n        // return what parent wanted\\n        return parentDirProfit;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457821,
                "title": "c-commented-o-n-postorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // keeps track of no. of nodes in longest zig zag path\\n    int res = 0;\\n    \\n    // post order manner\\n    vector<int> traverse(TreeNode *root){\\n        if(!root) return {0, 0}; // by default NULL node returns path with 0 nodes,\\n        \\n        vector<int> leftDir = traverse(root->left);\\n        vector<int> rightDir = traverse(root->right);\\n        \\n        // currDir[0] - left side and currDir[1] - right side\\n        vector<int> currDir = {0, 0};\\n        \\n        // current\\'s node longest zig zag path in \\'left\\' will be 1 + its left child\\'s \\'right\\' path \\n        currDir[0] = leftDir[1] + 1;\\n        \\n        // current\\'s node longest zig zag path in \\'right\\' will be 1 + its right child\\'s \\'left\\' path\\n        currDir[1] = rightDir[0] + 1;\\n        \\n        // updating the answer\\n        res = max(res, max(currDir[0], currDir[1]));\\n        \\n        return currDir;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        // traverse the whole tree\\n        traverse(root);\\n        \\n        return res - 1; // -1 because we have maximum of number of nodes not path\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // keeps track of no. of nodes in longest zig zag path\\n    int res = 0;\\n    \\n    // post order manner\\n    vector<int> traverse(TreeNode *root){\\n        if(!root) return {0, 0}; // by default NULL node returns path with 0 nodes,\\n        \\n        vector<int> leftDir = traverse(root->left);\\n        vector<int> rightDir = traverse(root->right);\\n        \\n        // currDir[0] - left side and currDir[1] - right side\\n        vector<int> currDir = {0, 0};\\n        \\n        // current\\'s node longest zig zag path in \\'left\\' will be 1 + its left child\\'s \\'right\\' path \\n        currDir[0] = leftDir[1] + 1;\\n        \\n        // current\\'s node longest zig zag path in \\'right\\' will be 1 + its right child\\'s \\'left\\' path\\n        currDir[1] = rightDir[0] + 1;\\n        \\n        // updating the answer\\n        res = max(res, max(currDir[0], currDir[1]));\\n        \\n        return currDir;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        // traverse the whole tree\\n        traverse(root);\\n        \\n        return res - 1; // -1 because we have maximum of number of nodes not path\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1414516,
                "title": "recursive-solution-beats-96-72-beginner-friendly-c",
                "content": "We have two options at a particular node.\\nOption 1. we go to same ZigZag path coming from above and add one more edge to previous value.\\nOption 2. we go to different direction than the path coming from above but from here length of path will start from one.\\nThere are two variables one is ans which store overall answer and second is currLength which stores length of path till this node.\\n\\n```\\nclass Solution {\\n    void traverse(TreeNode *root, bool leftToRight, int &ans, int currLength)\\n    {\\n        if (root == NULL)\\n        {\\n            return;\\n        }\\n\\n        ans = max(ans, currLength);\\n\\n        if (leftToRight)\\n        {\\n            traverse(root->right, !leftToRight, ans, currLength + 1);  // option 1\\n            traverse(root->left, leftToRight, ans, 1);                 // option 2\\n        }\\n        else\\n        {\\n            traverse(root->left, !leftToRight, ans, currLength + 1); // option 1\\n            traverse(root->right, leftToRight, ans, 1);              // option 2\\n        }\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        traverse(root, true, ans, 0);\\n        return ans;\\n    }\\n};\\n```\\n\\nTime complexity :-\\n\\tLet us assume that there are N nodes in tree and we are visiting each node ones so time complexity for average case and worst case both is O(N).\\n\\t\\nSpace complexity :-\\n\\tAs you might think that we are calling each node ones so N number of function calls(in funciton stack) will be stored but at any point of time function calls stored will be equal to H (Height of Tree).\\nBecause we are traversing one path at a time so average case space complexity will be O(Log(n)). Worst case will be for skewed tree O(N).\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void traverse(TreeNode *root, bool leftToRight, int &ans, int currLength)\\n    {\\n        if (root == NULL)\\n        {\\n            return;\\n        }\\n\\n        ans = max(ans, currLength);\\n\\n        if (leftToRight)\\n        {\\n            traverse(root->right, !leftToRight, ans, currLength + 1);  // option 1\\n            traverse(root->left, leftToRight, ans, 1);                 // option 2\\n        }\\n        else\\n        {\\n            traverse(root->left, !leftToRight, ans, currLength + 1); // option 1\\n            traverse(root->right, leftToRight, ans, 1);              // option 2\\n        }\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        traverse(root, true, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400458,
                "title": "smallest-and-cleanest-code-ever-dfs-98-95-c",
                "content": "We are defining direction as if its true than go to right else left \\n```\\nclass Solution {\\n    void dfs(TreeNode* root, bool direction, int &ans, int travel){\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        ans = max(ans, travel);\\n        dfs(direction ? root->right : root->left, !direction, ans, travel + 1);\\n        dfs(direction ? root->left : root->right, direction, ans, 1); //This call is to make their own path\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, true, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(TreeNode* root, bool direction, int &ans, int travel){\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        ans = max(ans, travel);\\n        dfs(direction ? root->right : root->left, !direction, ans, travel + 1);\\n        dfs(direction ? root->left : root->right, direction, ans, 1); //This call is to make their own path\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int ans = 0;\\n        dfs(root, true, ans, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357661,
                "title": "c-solution-using-pair-left-right-and-maintaining-a-max-variable",
                "content": "```\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode *root, int &max_zig){\\n        if(root==NULL){\\n            return {0,0};\\n        }\\n        \\n        // pair contain left and right info\\n        // pair<left,right>\\n        // lsub pair contain <left,right> info means if root want right info it can take right and respectively \\n        \\n        pair<int,int> lsub = solve(root->left, max_zig);\\n        pair<int,int> rsub = solve(root->right, max_zig);\\n        \\n        // if given root is right part of parent root \\n        // so left part of our given root will contain 1 + right_subtree.right part\\n        int left = 1 + rsub.second;\\n        \\n        //if root is left part of parent root\\n        int right = 1+ lsub.first;\\n        \\n        // max_zig for maintaining maximum zigzag pattern found in entire traversal\\n        max_zig = max(max_zig,max(left,right));\\n        \\n        return {left,right};\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        if(root==NULL || (root->left==NULL && root->right==NULL)) return 0;\\n        int max_zig = 0;\\n        pair<int,int> res = solve(root,max_zig);\\n        return max_zig-1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    pair<int,int> solve(TreeNode *root, int &max_zig){\\n        if(root==NULL){\\n            return {0,0};\\n        }\\n        \\n        // pair contain left and right info\\n        // pair<left,right>\\n        // lsub pair contain <left,right> info means if root want right info it can take right and respectively \\n        \\n        pair<int,int> lsub = solve(root->left, max_zig);\\n        pair<int,int> rsub = solve(root->right, max_zig);\\n        \\n        // if given root is right part of parent root \\n        // so left part of our given root will contain 1 + right_subtree.right part\\n        int left = 1 + rsub.second;\\n        \\n        //if root is left part of parent root\\n        int right = 1+ lsub.first;\\n        \\n        // max_zig for maintaining maximum zigzag pattern found in entire traversal\\n        max_zig = max(max_zig,max(left,right));\\n        \\n        return {left,right};\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        if(root==NULL || (root->left==NULL && root->right==NULL)) return 0;\\n        int max_zig = 0;\\n        pair<int,int> res = solve(root,max_zig);\\n        return max_zig-1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1246342,
                "title": "c-short-and-concise-solution-with-explanation-memoization",
                "content": "##### Hi!\\n##### I have kept my code as short as possible.\\n##### Please upvote if you like it and feel free to share your opinion.*\\n```\\nclass Solution {\\npublic:\\n\\t// pair to store the length of pattern at current node depending on the direction\\n    map<pair<TreeNode*,bool>,int>mp;\\n\\t\\n    int helper(TreeNode* root,bool isRight,int length){\\n        if(!root)\\n            return length-1; // -1 to remove the extra step taken to reach NULL node\\n\\t\\t\\t\\n        if(mp.find({root,isRight})!=mp.end()) //check memo\\n            return mp[{root,isRight}];\\n\\t\\t\\t\\n\\t\\t\\t/*   now we have two choices\\n\\t\\t\\t*    either continue the pattern or start pattern from the begining  \\n\\t\\t\\t*    or start a new pattern with length 1\\n\\t\\t\\t*    memoize and return max of both*/\\n\\t\\t\\t\\n        if(isRight)\\n            mp[{root,isRight}]= max(helper(root->left,false,length+1),helper(root->right,true,1)); \\n        else\\n            mp[{root,isRight}]= max(helper(root->right,true,length+1),helper(root->left,false,1));\\n        return mp[{root,isRight}];\\n    }\\n\\t\\n    int longestZigZag(TreeNode* root) {\\n        return max(helper(root->right,true,1),helper(root->left,false,1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// pair to store the length of pattern at current node depending on the direction\\n    map<pair<TreeNode*,bool>,int>mp;\\n\\t\\n    int helper(TreeNode* root,bool isRight,int length){\\n        if(!root)\\n            return length-1; // -1 to remove the extra step taken to reach NULL node\\n\\t\\t\\t\\n        if(mp.find({root,isRight})!=mp.end()) //check memo\\n            return mp[{root,isRight}];\\n\\t\\t\\t\\n\\t\\t\\t/*   now we have two choices\\n\\t\\t\\t*    either continue the pattern or start pattern from the begining  \\n\\t\\t\\t*    or start a new pattern with length 1\\n\\t\\t\\t*    memoize and return max of both*/\\n\\t\\t\\t\\n        if(isRight)\\n            mp[{root,isRight}]= max(helper(root->left,false,length+1),helper(root->right,true,1)); \\n        else\\n            mp[{root,isRight}]= max(helper(root->right,true,length+1),helper(root->left,false,1));\\n        return mp[{root,isRight}];\\n    }\\n\\t\\n    int longestZigZag(TreeNode* root) {\\n        return max(helper(root->right,true,1),helper(root->left,false,1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888591,
                "title": "simple-java-code-with-recursion-no-arrays-used",
                "content": "There are 5 cases, \\n\\n1. The highest zig zag traversak has been reached at the current node. No more zig zag traversals can be performed, either because it is a leaf node or further traversals are all in the same direction\\n2. The highest traversal is found by continuing the current zig zag traversal in the left subtree\\n3. The highest traversal is found by continuing the current zig zag traversal in the right subtree\\n4. The highest traversal exists in left subtree, but is unconnected to the current zig zag traversal\\n5. The highest traversal exists in right subtree, but is unconnected to the current zig zag traversal\\n\\nWhen the the previous traversal is a left move and the next traversal is right move or vice versa, we increment the traversal count. This is because it is part of the same zig zag traversal. \\n\\nIf the previous traversal and next traversal are the same (i.e. left followed by left or right followed by right), then it is the start of a new zig zag traversal and the count is reset to 1. \\n\\nThe unconnected zig zag traversals in the left and right subtrees can be smaller than zig zag traversal of reaching the current node. We must get the max value of the current traversal value with the traversal values of left and right subtree.\\n\\nIf a leaf node is reached, the zig zag count are returned as is, since no more traversal can happen\\n\\n```\\n    public int longestZigZag(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        return Math.max(root.left != null ? performZigZag(root.left, 1, true) : 0, \\n                        root.right != null ? performZigZag(root.right, 1, false) : 0);\\n        \\n    }\\n    \\n    public int performZigZag(TreeNode node, int count, boolean prevLeft) {           \\n        if (node.left == null && node.right == null) {\\n            return count;\\n        }\\n        \\n        return Math.max(count, Math.max(\\n            node.left != null ? performZigZag(node.left, prevLeft ? 1 : count + 1, true) : 0, \\n            node.right != null ? performZigZag(node.right, prevLeft ? count + 1 : 1, false) : 0));\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestZigZag(TreeNode root) {\\n        if (root == null) return 0;\\n        \\n        return Math.max(root.left != null ? performZigZag(root.left, 1, true) : 0, \\n                        root.right != null ? performZigZag(root.right, 1, false) : 0);\\n        \\n    }\\n    \\n    public int performZigZag(TreeNode node, int count, boolean prevLeft) {           \\n        if (node.left == null && node.right == null) {\\n            return count;\\n        }\\n        \\n        return Math.max(count, Math.max(\\n            node.left != null ? performZigZag(node.left, prevLeft ? 1 : count + 1, true) : 0, \\n            node.right != null ? performZigZag(node.right, prevLeft ? count + 1 : 1, false) : 0));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 837271,
                "title": "java-dfs-solution-similar-to-lc-124",
                "content": "This problem can be solved simialr to https://leetcode.com/problems/binary-tree-maximum-path-sum/\\n\\nYou can consider the individial subtree by itself or consider the parent. So, check both possibilities.\\n\\nFurther optimization include, memoization to reduce the recHelper calls.\\n```\\n    int ans = Integer.MIN_VALUE;\\n    private int dfs(TreeNode root, boolean isLeft) {\\n        if (root == null)\\n            return -1;\\n        \\n        int left = dfs(root.left, true) + 1;\\n        int right = dfs(root.right, false) + 1;\\n        \\n        ans = Math.max(ans, Math.max(left, right));\\n        \\n        if (isLeft) {\\n            return right;\\n        } else {\\n            return left;\\n        }\\n    }\\n    \\n    public int longestZigZag(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        \\n        int left = dfs(root.left, true);\\n        int right = dfs(root.right, false);\\n        ans = Math.max(ans, Math.max(left, right) + 1);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int ans = Integer.MIN_VALUE;\\n    private int dfs(TreeNode root, boolean isLeft) {\\n        if (root == null)\\n            return -1;\\n        \\n        int left = dfs(root.left, true) + 1;\\n        int right = dfs(root.right, false) + 1;\\n        \\n        ans = Math.max(ans, Math.max(left, right));\\n        \\n        if (isLeft) {\\n            return right;\\n        } else {\\n            return left;\\n        }\\n    }\\n    \\n    public int longestZigZag(TreeNode root) {\\n        if (root == null)\\n            return 0;\\n        \\n        int left = dfs(root.left, true);\\n        int right = dfs(root.right, false);\\n        ans = Math.max(ans, Math.max(left, right) + 1);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739536,
                "title": "python-clean-dfs",
                "content": "```\\nclass Solution:\\n    def longestZigZag(self, root):\\n\\n        self.max_length = 0\\n        self.find_path(root, root)\\n        return self.max_length-1\\n    def find_path(self, root, parent):\\n        if root is None:\\n            return 0\\n        left = self.find_path(root.left, root)\\n        right = self.find_path(root.right, root)\\n\\n        self.max_length = max(self.max_length, max(left, right)+1)\\n\\n        if root == parent.left:\\n            return right+1\\n        else:\\n            return left+1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root):\\n\\n        self.max_length = 0\\n        self.find_path(root, root)\\n        return self.max_length-1\\n    def find_path(self, root, parent):\\n        if root is None:\\n            return 0\\n        left = self.find_path(root.left, root)\\n        right = self.find_path(root.right, root)\\n\\n        self.max_length = max(self.max_length, max(left, right)+1)\\n\\n        if root == parent.left:\\n            return right+1\\n        else:\\n            return left+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 722647,
                "title": "c-postorder-traversal-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int result=0;\\n    pair<int,int> postorder(TreeNode* root)\\n    {\\n        if(root==NULL) return {0,0};\\n        \\n        pair<int,int>curr;\\n        \\n        pair<int,int>left=postorder(root->left);\\n        pair<int,int>right=postorder(root->right);\\n        \\n        int lefttoright=1+left.second;//ZigZag path length If we take right from left child\\n        int righttoleft=1+right.first;//ZigZag path length If we take left from right child\\n        result=max(result,max(left.second,right.first));//Stores Maximum length zig zag path\\n        curr={lefttoright,righttoleft};\\n        return curr;\\n    }\\n    \\n    \\n    int longestZigZag(TreeNode* root) {\\n      postorder(root);\\n      return result;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int result=0;\\n    pair<int,int> postorder(TreeNode* root)\\n    {\\n        if(root==NULL) return {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 531859,
                "title": "python-dfs-with-direction-of-parent",
                "content": "The idea is to use DFS with direction where the node came from. If the child node has a same direction, reset the count to 1. Otherwise, keep incremeting the count.\\n\\n``` py\\n\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        def dfs(node, parent, cnt):\\n            if not node:\\n                return\\n\\t\\t\\tself.res = max(self.res, cnt)\\n            dfs(node.left, \\'left\\', (cnt + 1) if parent == \\'right\\' else 1)\\n            dfs(node.right, \\'right\\', (cnt + 1) if parent == \\'left\\' else 1)    \\n\\n        self.res = 0\\n        dfs(root, None, 0)\\n        return self.res\\n\\t\\t\\n```\\t\\t",
                "solutionTags": [],
                "code": "``` py\\n\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        def dfs(node, parent, cnt):\\n            if not node:\\n                return\\n\\t\\t\\tself.res = max(self.res, cnt)\\n            dfs(node.left, \\'left\\', (cnt + 1) if parent == \\'right\\' else 1)\\n            dfs(node.right, \\'right\\', (cnt + 1) if parent == \\'left\\' else 1)    \\n\\n        self.res = 0\\n        dfs(root, None, 0)\\n        return self.res\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3962256,
                "title": "easy-java-dfs-with-and-without-global-variable-and-with-global-variable",
                "content": "Method 1: Using global variable\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root==null)\\n            return -1;\\n        helper(root.right,1,true);\\n        helper(root.left,1,false);\\n        return max;\\n    }\\n    public void helper(TreeNode root,int step, boolean isright){\\n        if(root==null)\\n            return ;\\n        max = Math.max(max,step);\\n        if(isright){\\n            helper(root.left,step+1,false);\\n            helper(root.right,1,true);\\n        }\\n        else{\\n            helper(root.right,step+1,true);\\n            helper(root.left,1,false);\\n        }\\n    }\\n}\\n```\\n\\nMethod 2: Without Global variable\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        if(root==null)\\n            return -1;\\n        return Math.max(helper(root.right,1,true),\\n        helper(root.left,1,false));\\n    }\\n    public int helper(TreeNode root,int step, boolean isright){\\n        if(root==null)\\n            return 0;\\n        int left = 0;\\n        int right = 0;\\n        if(isright){\\n            left = helper(root.left,step+1,false);\\n            right = helper(root.right,1,true);\\n        }\\n        else{\\n            right = helper(root.right,step+1,true);\\n            left = helper(root.left,1,false);\\n        }\\n        return Math.max(step,Math.max(left,right));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root==null)\\n            return -1;\\n        helper(root.right,1,true);\\n        helper(root.left,1,false);\\n        return max;\\n    }\\n    public void helper(TreeNode root,int step, boolean isright){\\n        if(root==null)\\n            return ;\\n        max = Math.max(max,step);\\n        if(isright){\\n            helper(root.left,step+1,false);\\n            helper(root.right,1,true);\\n        }\\n        else{\\n            helper(root.right,step+1,true);\\n            helper(root.left,1,false);\\n        }\\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        if(root==null)\\n            return -1;\\n        return Math.max(helper(root.right,1,true),\\n        helper(root.left,1,false));\\n    }\\n    public int helper(TreeNode root,int step, boolean isright){\\n        if(root==null)\\n            return 0;\\n        int left = 0;\\n        int right = 0;\\n        if(isright){\\n            left = helper(root.left,step+1,false);\\n            right = helper(root.right,1,true);\\n        }\\n        else{\\n            right = helper(root.right,step+1,true);\\n            left = helper(root.left,1,false);\\n        }\\n        return Math.max(step,Math.max(left,right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3598938,
                "title": "python-solution-using-recursion-and-further-memoization",
                "content": "\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        dp = {}\\n\\n        def chk(node , dir):\\n            if node == None: return 0\\n\\n            if (node , dir) in dp: return dp[(node , dir)]\\n\\n            if dir == \"left\":\\n                if node.right:\\n                    dp[(node , dir)] = 1 + chk(node.right , \"right\")\\n                    return dp[(node , dir)]\\n\\n            elif dir == \"right\":\\n                if node.left:\\n                    dp[(node , dir)] = 1 + chk(node.left , \"left\")\\n                    return dp[(node , dir)]\\n            return 0\\n\\n        ans = -1\\n        def inorder(node):\\n            nonlocal ans\\n            if node == None: return \\n            inorder(node.left)\\n            ans = max( ans , chk(node , \"left\") )\\n            ans = max( ans , chk(node , \"right\"))\\n            inorder(node.right)\\n        \\n        inorder(root)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        dp = {}\\n\\n        def chk(node , dir):\\n            if node == None: return 0\\n\\n            if (node , dir) in dp: return dp[(node , dir)]\\n\\n            if dir == \"left\":\\n                if node.right:\\n                    dp[(node , dir)] = 1 + chk(node.right , \"right\")\\n                    return dp[(node , dir)]\\n\\n            elif dir == \"right\":\\n                if node.left:\\n                    dp[(node , dir)] = 1 + chk(node.left , \"left\")\\n                    return dp[(node , dir)]\\n            return 0\\n\\n        ans = -1\\n        def inorder(node):\\n            nonlocal ans\\n            if node == None: return \\n            inorder(node.left)\\n            ans = max( ans , chk(node , \"left\") )\\n            ans = max( ans , chk(node , \"right\"))\\n            inorder(node.right)\\n        \\n        inorder(root)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457726,
                "title": "java-dfs-no-global-variables",
                "content": "# Approach\\nDFS with in-place calculation of result. Addition of global result field can make execution faster since we will not need to make extra max comparison, but I prefer to keep the class clean, if possible.\\n\\n# Complexity\\n- Time complexity:\\n$$O(nodes)$$\\n\\n- Space complexity:\\n$$O(height)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(helper(root, 0, true), helper(root, 0, false));\\n    }\\n\\n    private int helper(TreeNode node, int path, boolean isLeft) {\\n        if (node == null) return 0;\\n        int left = helper(node.left, isLeft ? 0 : path + 1, !isLeft);\\n        int right = helper(node.right, isLeft ? path + 1 : 0, !isLeft);\\n        return Math.max(path, Math.max(left, right));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(helper(root, 0, true), helper(root, 0, false));\\n    }\\n\\n    private int helper(TreeNode node, int path, boolean isLeft) {\\n        if (node == null) return 0;\\n        int left = helper(node.left, isLeft ? 0 : path + 1, !isLeft);\\n        int right = helper(node.right, isLeft ? path + 1 : 0, !isLeft);\\n        return Math.max(path, Math.max(left, right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450296,
                "title": "c-find-longest-zigzag-in-binary-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n#define LEFT    -1\\n#define RIGHT   1\\n#define START   0\\n\\nint max = 0;\\n\\n// Recursion to check all the ZigZag variations\\nvoid longestZigZagRecur(struct TreeNode* root, int way, int length_curr)\\n{\\n    if(length_curr > max)\\n    {\\n        max = length_curr;\\n    }\\n\\n    if((root->right == NULL) && (root->left == NULL))\\n    {\\n        return;\\n    }\\n\\n    if(root->right != NULL)\\n    {\\n        longestZigZagRecur(root->right, RIGHT, ((way == LEFT))? length_curr + 1 : 1);\\n    }\\n\\n    if(root->left != NULL)\\n    {\\n        longestZigZagRecur(root->left, LEFT, ((way == RIGHT))? length_curr + 1 : 1);\\n    }\\n}\\n\\nint longestZigZag(struct TreeNode* root)\\n{\\n    max = 0;\\n\\n    if(root->left == NULL && root->right == NULL)\\n    {\\n        return 0;\\n    }\\n\\n    longestZigZagRecur(root, START, 1);\\n\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\n\\n#define LEFT    -1\\n#define RIGHT   1\\n#define START   0\\n\\nint max = 0;\\n\\n// Recursion to check all the ZigZag variations\\nvoid longestZigZagRecur(struct TreeNode* root, int way, int length_curr)\\n{\\n    if(length_curr > max)\\n    {\\n        max = length_curr;\\n    }\\n\\n    if((root->right == NULL) && (root->left == NULL))\\n    {\\n        return;\\n    }\\n\\n    if(root->right != NULL)\\n    {\\n        longestZigZagRecur(root->right, RIGHT, ((way == LEFT))? length_curr + 1 : 1);\\n    }\\n\\n    if(root->left != NULL)\\n    {\\n        longestZigZagRecur(root->left, LEFT, ((way == RIGHT))? length_curr + 1 : 1);\\n    }\\n}\\n\\nint longestZigZag(struct TreeNode* root)\\n{\\n    max = 0;\\n\\n    if(root->left == NULL && root->right == NULL)\\n    {\\n        return 0;\\n    }\\n\\n    longestZigZagRecur(root, START, 1);\\n\\n    return max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440174,
                "title": "java-o-n-recursion",
                "content": "# Intuition\\nThe one way that comes to mind is to find all possible paths but with given nodes can as much as $$10 ^ 4$$ this solution goes in n$$O(n ^2)$$\\nSo intuition was to optimize this approach. \\nTo optimize we can do:\\n1. keep track of know length and calculate the max length in one traversal\\n2. reduce the unnecessary paths (as valid paths are only zigzags so we can eliminate non-zigzag paths)\\n3. eliminate the calculation of subpaths as parent paths already are bigger than subpath (implies function strictly follows zigzag path)\\n\\n# Approach\\n1. create a function that can traverse the tree in the zigZag pattern (recursive functions work in case of trees) \\n2. maintain a global variable max and update it at every end of each path (i.e. where root == null)\\n3. for every node start a new calculation for the opposite direction with length 0 (this will calculate strictly the opposite direction as a path in the same direction, starting a calculation from current node will be a subpath of the already calculated path)\\n\\n# Complexity\\n- Time complexity:\\nIn this approach each node is visited only once so time complexity $$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n       zigZag(root, 0, 0);\\n       return max;\\n    }\\n\\n    //score is current number of nodes in path\\n    //direction 0 is for left and 1 for right\\n    public void zigZag(TreeNode root, int score, int direction){\\n        if(root == null){\\n            //zigZag fuction caculates the number of nodes for max path so length will be score - 1, i.e. for 4 nodes path will be 3.\\n            max = Math.max(max, score - 1);\\n            return;\\n        }\\n\\n        if(direction == 0){\\n            zigZag(root.left, score+1, 1);\\n            //spliting into opposite possiblity with score 1 i.e. reseting score to 0 and +1 of root node\\n            zigZag(root.right, 1, 0);\\n        }else{\\n            zigZag(root.right, score+1, 0);\\n            zigZag(root.left, 1, 1);\\n        }\\n    }\\n}\\n```\\n# **Its my first solution, Please tell me if I\\'ve messed up**\\n![images.jfif](https://assets.leetcode.com/users/images/76597852-b4f1-4146-9ba1-ae0e37c73e2d_1682059638.439474.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n       zigZag(root, 0, 0);\\n       return max;\\n    }\\n\\n    //score is current number of nodes in path\\n    //direction 0 is for left and 1 for right\\n    public void zigZag(TreeNode root, int score, int direction){\\n        if(root == null){\\n            //zigZag fuction caculates the number of nodes for max path so length will be score - 1, i.e. for 4 nodes path will be 3.\\n            max = Math.max(max, score - 1);\\n            return;\\n        }\\n\\n        if(direction == 0){\\n            zigZag(root.left, score+1, 1);\\n            //spliting into opposite possiblity with score 1 i.e. reseting score to 0 and +1 of root node\\n            zigZag(root.right, 1, 0);\\n        }else{\\n            zigZag(root.right, score+1, 0);\\n            zigZag(root.left, 1, 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436431,
                "title": "intuitive-python-solution-solution-blog",
                "content": "# Welcome to my Solution Blog!\\n![Copy of Copy of 617 ALG (2).png](https://assets.leetcode.com/users/images/9f9bbc79-74b6-4bb1-9383-7e44175139f7_1681946631.0889835.png)\\n\\n**Base Case:**\\nWhen you hit a leaf node -> return the depth and it\\'ll propagate up the tree and be returned!\\n\\n**Two Paths from here!**\\n\\nIf you went left previously, take the maximum of:\\n1. the current depth\\n2. now going down the right path, and incrementing the depth by 1\\n3. go down the left path AGAIN, and reset depth to 0\\n\\nThen repeat this logic (but reversed) for if you went right previously.\\n\\n\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        return max(self.helper(root.left, True, 0), self.helper(root.right, False, 0))\\n    \\n    def helper(self, root, isLeft, depth):\\n        if not root: return depth\\n\\n        if isLeft:\\n            depth = max(\\n                depth,\\n                self.helper(root.right, False, depth + 1),\\n                self.helper(root.left, True, 0)\\n            )\\n        \\n        else: # otherwise we previously went\\n            depth = max(\\n                depth,\\n                self.helper(root.left, True, depth + 1),\\n                self.helper(root.right, False, 0)\\n            )\\n        return depth\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        return max(self.helper(root.left, True, 0), self.helper(root.right, False, 0))\\n    \\n    def helper(self, root, isLeft, depth):\\n        if not root: return depth\\n\\n        if isLeft:\\n            depth = max(\\n                depth,\\n                self.helper(root.right, False, depth + 1),\\n                self.helper(root.left, True, 0)\\n            )\\n        \\n        else: # otherwise we previously went\\n            depth = max(\\n                depth,\\n                self.helper(root.left, True, depth + 1),\\n                self.helper(root.right, False, 0)\\n            )\\n        return depth\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436145,
                "title": "easy-c-top-down-solution",
                "content": "# Intuition\\nJust consider as waterfalling with bouncing.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\nTop Down \\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code \\n\\nclass Solution {\\npublic:\\n\\n    int max=0;\\n    void lng(TreeNode* root,bool dir,int ln){\\n        if(max<ln)max=ln;\\n        if(dir){//dir == 1 as root direction is right\\n            if(root->left !=nullptr) lng(root->left,0,ln+1);//right to left increase length\\n            if(root->right !=nullptr)lng(root->right,1,1);//new starting point\\n        }\\n        else{//dir == 0 as root direction is left\\n            if(root->left !=nullptr) lng(root->left,0,1);//new starting point\\n            if(root->right !=nullptr)lng(root->right,1,ln+1);//left to right increase length\\n        }\\n        return ;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(root)lng(root, 0, 0);\\n        return max;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int max=0;\\n    void lng(TreeNode* root,bool dir,int ln){\\n        if(max<ln)max=ln;\\n        if(dir){//dir == 1 as root direction is right\\n            if(root->left !=nullptr) lng(root->left,0,ln+1);//right to left increase length\\n            if(root->right !=nullptr)lng(root->right,1,1);//new starting point\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3435540,
                "title": "java-recursive-solution-pre-order-traversal",
                "content": "# Intuition\\nTraverse the tree and keep a boolean to identify reft and left and keep count accordingly.\\n# Approach\\nTraverse the tree\\n    keep boolean to identify previous move\\n    increment/set count accordingly\\n    check for max and update\\nreturn max;\\n\\n# Complexity\\n- Time complexity:O(n)\\n\\n- Space complexity:O(1)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left != null){\\n            traverse(root.left,true,1);\\n        }\\n        if(root.right != null){\\n            traverse(root.right,false,1);\\n        }\\n        return max;\\n    }\\n    public void traverse(TreeNode root,boolean left,int count){\\n        if(max < count){\\n            max = count;\\n        }\\n        if(root.left != null){\\n            traverse(root.left,true,!left?count+1:1);\\n        }\\n        if(root.right != null){\\n            traverse(root.right,false,left?count+1:1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left != null){\\n            traverse(root.left,true,1);\\n        }\\n        if(root.right != null){\\n            traverse(root.right,false,1);\\n        }\\n        return max;\\n    }\\n    public void traverse(TreeNode root,boolean left,int count){\\n        if(max < count){\\n            max = count;\\n        }\\n        if(root.left != null){\\n            traverse(root.left,true,!left?count+1:1);\\n        }\\n        if(root.right != null){\\n            traverse(root.right,false,left?count+1:1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435468,
                "title": "c-easy-solution-easy-recursion-solution",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint ans=0;\\n    void dfs(TreeNode* root,bool last,int len)\\n    {\\n        if(!root) return;\\n        ans=max(ans,len);\\n        if(!last)\\n        {\\n            dfs(root->left,false,1);\\n            dfs(root->right,true,len+1);\\n        }\\n        else\\n        {\\n            dfs(root->left,false,len+1);\\n            dfs(root->right,true,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root->left,false,1);\\n        dfs(root->right,true,1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint ans=0;\\n    void dfs(TreeNode* root,bool last,int len)\\n    {\\n        if(!root) return;\\n        ans=max(ans,len);\\n        if(!last)\\n        {\\n            dfs(root->left,false,1);\\n            dfs(root->right,true,len+1);\\n        }\\n        else\\n        {\\n            dfs(root->left,false,len+1);\\n            dfs(root->right,true,1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root->left,false,1);\\n        dfs(root->right,true,1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435314,
                "title": "python3-dfs-solution",
                "content": "\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n\\n        def dfs(root,direction,depth):\\n            \\n            nonlocal res\\n            if not root:\\n                return \\n            res=max(res,depth)\\n\\n            if direction==-1:\\n                dfs(root.right,1,depth+1)\\n                dfs(root.left,-1,1)\\n\\n            else:\\n                dfs(root.left,-1,depth+1)\\n                dfs(root.right,1,1)\\n            \\n        res=0\\n        dfs(root,1,0)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n\\n        def dfs(root,direction,depth):\\n            \\n            nonlocal res\\n            if not root:\\n                return \\n            res=max(res,depth)\\n\\n            if direction==-1:\\n                dfs(root.right,1,depth+1)\\n                dfs(root.left,-1,1)\\n\\n            else:\\n                dfs(root.left,-1,depth+1)\\n                dfs(root.right,1,1)\\n            \\n        res=0\\n        dfs(root,1,0)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434968,
                "title": "easy-solution-in-java-recursion",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxLen = 0;\\n    public int longestZigZag(TreeNode root) {\\n        helper(root, 0, 0);  \\n        helper(root, 1, 0);  \\n        return maxLen;  \\n    }\\n\\n    public void helper(TreeNode root, int path, int currentLen){\\n        if(root == null)\\n            return;\\n        maxLen = Math.max(maxLen, currentLen);\\n        if(path == 1)\\n        {\\n            helper(root.left, 0, currentLen + 1);\\n            helper(root.right, 1, 1);\\n        }\\n        else\\n        {\\n            helper(root.right, 1, currentLen + 1);\\n            helper(root.left, 0, 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxLen = 0;\\n    public int longestZigZag(TreeNode root) {\\n        helper(root, 0, 0);  \\n        helper(root, 1, 0);  \\n        return maxLen;  \\n    }\\n\\n    public void helper(TreeNode root, int path, int currentLen){\\n        if(root == null)\\n            return;\\n        maxLen = Math.max(maxLen, currentLen);\\n        if(path == 1)\\n        {\\n            helper(root.left, 0, currentLen + 1);\\n            helper(root.right, 1, 1);\\n        }\\n        else\\n        {\\n            helper(root.right, 1, currentLen + 1);\\n            helper(root.left, 0, 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434642,
                "title": "java-beats-100-optimal-solution-easy-explanation-beginner-friendly-dfs",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n**CODE WITHOUT COMMENTS BELOW**\\n\\n**UPVOTE PLEASE !!!**\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max=0; // to store max\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left!=null){\\n           helper(root.left,true,1);    // going left adding 1 node\\n        }\\n        if(root.right!=null){\\n            helper(root.right,false,1); // going right adding 1 node\\n        }\\n        return max;\\n        \\n    }\\n    //BOOLEAN LEFT to know if arrived at this node by traversing left or right\\n    public void helper(TreeNode root,boolean left,int val){\\n        if(root.left==null && root.right==null){\\n            //LEAF NODE return val\\n            max=Math.max(val,max);\\n            return;\\n        }\\n      \\n        if(left){  \\n            //if arrived from left then right node should be included \\n            if(root.right!=null){\\n             helper(root.right,false,val+1);  //+1 node as right node is present\\n            }else{\\n                max=Math.max(val,max);    //if right node not present compare the val to max\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,1);   // starting as 1st node as it has already arrived from left so going left would be starting a new chain\\n\\n            }\\n        }else{\\n           \\n             if(root.right!=null){\\n                 helper(root.right,false,1);\\n            }\\n             //if arrived from right then left node should be included \\n            if(root.left!=null){\\n                helper(root.left,true,val+1); //+1 node as right node is present\\n\\n            }\\n            else{\\n                max=Math.max(val,max);    //if left node not present compare the val to max\\n            }\\n\\n        }\\n        \\n    }\\n}\\n```\\n**CODE WITHOUT COMMENTS**\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max=0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left!=null){\\n           helper(root.left,true,1);\\n        }\\n        if(root.right!=null){\\n            helper(root.right,false,1);\\n        }\\n        return max;\\n        \\n    }\\n    public void helper(TreeNode root,boolean left,int val){\\n        if(root.left==null && root.right==null){\\n            max=Math.max(val,max);\\n            return;\\n        }\\n        if(left){\\n            if(root.right!=null){\\n             helper(root.right,false,val+1);\\n            }else{\\n                max=Math.max(val,max);\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,1);\\n            }\\n        }else{\\n             if(root.right!=null){\\n                 helper(root.right,false,1);\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,val+1);\\n            }\\n            else{\\n                max=Math.max(val,max);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max=0; // to store max\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left!=null){\\n           helper(root.left,true,1);    // going left adding 1 node\\n        }\\n        if(root.right!=null){\\n            helper(root.right,false,1); // going right adding 1 node\\n        }\\n        return max;\\n        \\n    }\\n    //BOOLEAN LEFT to know if arrived at this node by traversing left or right\\n    public void helper(TreeNode root,boolean left,int val){\\n        if(root.left==null && root.right==null){\\n            //LEAF NODE return val\\n            max=Math.max(val,max);\\n            return;\\n        }\\n      \\n        if(left){  \\n            //if arrived from left then right node should be included \\n            if(root.right!=null){\\n             helper(root.right,false,val+1);  //+1 node as right node is present\\n            }else{\\n                max=Math.max(val,max);    //if right node not present compare the val to max\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,1);   // starting as 1st node as it has already arrived from left so going left would be starting a new chain\\n\\n            }\\n        }else{\\n           \\n             if(root.right!=null){\\n                 helper(root.right,false,1);\\n            }\\n             //if arrived from right then left node should be included \\n            if(root.left!=null){\\n                helper(root.left,true,val+1); //+1 node as right node is present\\n\\n            }\\n            else{\\n                max=Math.max(val,max);    //if left node not present compare the val to max\\n            }\\n\\n        }\\n        \\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max=0;\\n    public int longestZigZag(TreeNode root) {\\n        if(root.left!=null){\\n           helper(root.left,true,1);\\n        }\\n        if(root.right!=null){\\n            helper(root.right,false,1);\\n        }\\n        return max;\\n        \\n    }\\n    public void helper(TreeNode root,boolean left,int val){\\n        if(root.left==null && root.right==null){\\n            max=Math.max(val,max);\\n            return;\\n        }\\n        if(left){\\n            if(root.right!=null){\\n             helper(root.right,false,val+1);\\n            }else{\\n                max=Math.max(val,max);\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,1);\\n            }\\n        }else{\\n             if(root.right!=null){\\n                 helper(root.right,false,1);\\n            }\\n            if(root.left!=null){\\n                helper(root.left,true,val+1);\\n            }\\n            else{\\n                max=Math.max(val,max);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434458,
                "title": "optimised-solution-with-easy-and-complete-explanation",
                "content": "# Intuition\\nTo solve this problem, we can perform a depth-first search (DFS) on the binary tree, keeping track of the length of the longest ZigZag path seen so far. For each node, we need to check both the left and right subtrees to see if there are any ZigZag paths that pass through the node.\\n\\n# Approach\\nTo do this, we can define a helper function dfs that takes in a node and a boolean flag indicating whether we are currently traversing the left or right subtree. If we are traversing the left subtree, we update the length of the longest ZigZag path seen so far by adding the length of the longest ZigZag path in the right subtree of the current node plus 1 (for the current node). Similarly, if we are traversing the right subtree, we update the length of the longest ZigZag path seen so far by adding the length of the longest ZigZag path in the left subtree of the current node plus 1.\\n\\nWe can then call this helper function on the root node, passing in a flag indicating that we are not currently traversing any subtree (i.e., the root node is not part of any ZigZag path). Finally, we return the length of the longest ZigZag path seen so far.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int max_length = 0;\\n        dfs(root, false, 0, max_length); // Start with root node, not traversing any subtree\\n        dfs(root, true, 0, max_length); // Start with root node, traversing right subtree\\n        return max_length;\\n    }\\n    \\n    void dfs(TreeNode* node, bool is_right, int length, int& max_length) {\\n        if (!node) return;\\n        max_length = max(max_length, length); // Update max_length with current ZigZag path length\\n        \\n        if (is_right) { // Traversing right subtree\\n            dfs(node->right, false, length + 1, max_length); // Check left subtree\\n            dfs(node->left, true, 1, max_length); // Check right subtree\\n        } else { // Traversing left subtree\\n            dfs(node->left, true, length + 1, max_length); // Check right subtree\\n            dfs(node->right, false, 1, max_length); // Check left subtree\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        int max_length = 0;\\n        dfs(root, false, 0, max_length); // Start with root node, not traversing any subtree\\n        dfs(root, true, 0, max_length); // Start with root node, traversing right subtree\\n        return max_length;\\n    }\\n    \\n    void dfs(TreeNode* node, bool is_right, int length, int& max_length) {\\n        if (!node) return;\\n        max_length = max(max_length, length); // Update max_length with current ZigZag path length\\n        \\n        if (is_right) { // Traversing right subtree\\n            dfs(node->right, false, length + 1, max_length); // Check left subtree\\n            dfs(node->left, true, 1, max_length); // Check right subtree\\n        } else { // Traversing left subtree\\n            dfs(node->left, true, length + 1, max_length); // Check right subtree\\n            dfs(node->right, false, 1, max_length); // Check left subtree\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434428,
                "title": "go-clean-recursive-solution",
                "content": "```\\nfunc longestZigZag(root *TreeNode) int {\\n    res := 0\\n    \\n    var walk func(*TreeNode, int, int)\\n    walk = func(root* TreeNode, l, r int) {\\n        if root != nil {\\n            res = max(res, l, r)\\n            walk(root.Left, r + 1, 0)\\n            walk(root.Right, 0, l + 1)\\n        }\\n    }\\n    \\n    walk(root, 0, 0)\\n    return res\\n}\\n\\nfunc max(a ...int) int {\\n    res := a[0]\\n    for _, v := range a {\\n        if v > res {\\n            res = v\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestZigZag(root *TreeNode) int {\\n    res := 0\\n    \\n    var walk func(*TreeNode, int, int)\\n    walk = func(root* TreeNode, l, r int) {\\n        if root != nil {\\n            res = max(res, l, r)\\n            walk(root.Left, r + 1, 0)\\n            walk(root.Right, 0, l + 1)\\n        }\\n    }\\n    \\n    walk(root, 0, 0)\\n    return res\\n}\\n\\nfunc max(a ...int) int {\\n    res := a[0]\\n    for _, v := range a {\\n        if v > res {\\n            res = v\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3434362,
                "title": "javascript-simple-recursive-solution",
                "content": "# Approach\\nRecursively: \\n- if root is null, return -1 to compensate the +1 from previous call to result to 0\\n- if root is left child, recursively check its right subtree and add root edge to it. Then recursively check its left subtree and assign max of these values to ans. We always want to return the right subtree max here, so we can continue to add up to that path.\\n- if root is right child, do the same, but mirrored (instead of right subtree we\\'ll return right one)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nconst LEFT = 0\\nconst RIGHT = 1\\nlet ans = 0\\n\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nconst longestZigZag = root => {\\n    ans = 0\\n    const left = 1 + recLongestZigZag(root.left, LEFT)\\n    const right = 1 + recLongestZigZag(root.right, RIGHT)\\n    ans = Math.max(\\n        left,\\n        right,\\n        ans,\\n    )\\n    return ans\\n}\\n\\nconst recLongestZigZag = (root, dir) => {\\n    if (root === null) return -1\\n    const left = 1 + recLongestZigZag(root.left, LEFT)\\n    const right = 1 + recLongestZigZag(root.right, RIGHT)\\n    ans = Math.max(ans, left, right)\\n    return dir === LEFT ? right : left\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nconst LEFT = 0\\nconst RIGHT = 1\\nlet ans = 0\\n\\n/**\\n * @param {TreeNode} root\\n * @return {number}\\n */\\nconst longestZigZag = root => {\\n    ans = 0\\n    const left = 1 + recLongestZigZag(root.left, LEFT)\\n    const right = 1 + recLongestZigZag(root.right, RIGHT)\\n    ans = Math.max(\\n        left,\\n        right,\\n        ans,\\n    )\\n    return ans\\n}\\n\\nconst recLongestZigZag = (root, dir) => {\\n    if (root === null) return -1\\n    const left = 1 + recLongestZigZag(root.left, LEFT)\\n    const right = 1 + recLongestZigZag(root.right, RIGHT)\\n    ans = Math.max(ans, left, right)\\n    return dir === LEFT ? right : left\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3434187,
                "title": "tree-depth-first-search",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(h)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar longestZigZag = function(root) {\\n    var maxZigZag = 0;\\n    function dfs(root, zig, zigzag) {\\n        if(root == null)\\n            return;\\n        maxZigZag = Math.max(maxZigZag, zigzag);\\n        dfs(root.left, -1, 1 + ((zig == 1) ? zigzag : 0));\\n        dfs(root.right, 1, 1 + ((zig == -1) ? zigzag : 0));\\n    };\\n    dfs(root, 0, 0);\\n    return maxZigZag;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nvar longestZigZag = function(root) {\\n    var maxZigZag = 0;\\n    function dfs(root, zig, zigzag) {\\n        if(root == null)\\n            return;\\n        maxZigZag = Math.max(maxZigZag, zigzag);\\n        dfs(root.left, -1, 1 + ((zig == 1) ? zigzag : 0));\\n        dfs(root.right, 1, 1 + ((zig == -1) ? zigzag : 0));\\n    };\\n    dfs(root, 0, 0);\\n    return maxZigZag;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3434039,
                "title": "java-dfs-explained",
                "content": "# Solution:\\n```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        // we are currently standing on the root node\\n        dfs(root.left, 1, false);   // call for left\\n        dfs(root.right, 1, true);   // call for right\\n        // Why 1? Because from root to root\\'s left or right \\n        // is a distance of 1 unit\\n        return max;\\n    }\\n\\n    // the parameter boolean goRight will let us know \\n    // if we took the right direction or the left direction\\n    private void dfs(TreeNode root, int depth, boolean goRight) {\\n        if (root == null) {\\n            return;\\n        }\\n        // update max distance\\n        max = Math.max(max, depth); \\n        // if we had took right direction\\n        if (goRight) {\\n            // we have 2 options:\\n            // Go left: That\\'d be a zigzag order so distance + 1\\n            dfs(root.left, depth + 1, false);\\n            // Go right: Zigzag order is broken so distance resets to 1\\n            dfs(root.right, 1, true);\\n        } \\n        // Else if we had took a left direction\\n        else {\\n            // we have 2 options:\\n            // Go left: Zigzag order is broken so distance resets to 1\\n            dfs(root.left, 1, false);\\n            // Go right: That\\'d be a zigzag order so distance + 1\\n            dfs(root.right, depth + 1, true);\\n        }\\n        // In each call we set goRight true or false accordingly \\n        // if we are moving to left or right\\n\\n        // Also, why are we resetting the distance to 1 and not 0?\\n        // Because, from current node to next node where we are \\n        // stepping on, the distance is 1, so we set it to 1.\\n    }\\n}\\n```\\n---\\n\\nIn the above solution, we stood at the root and called our recursive method on left and right in the `longestZigZag()` method.\\n\\nWe can also call the recursive method only once in `longestZigZag()` by calling it on the root node itself, setting `goRight` parameter to anything, because we are just stepping our foot on it, it doesn\\'t matter if we came from left or right. The distance would be `0` at root because we can\\'t count our steps if we came from emptiness. We start counting after we start stepping afterwards from root node.  Everything will just be the same from there.\\n```\\ndfs(root, 0, false);\\n```\\n---\\n## Clean solution:\\n```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, 0, false); \\n        return max;\\n    }\\n\\n    private void dfs(TreeNode root, int depth, boolean goRight) {\\n        if (root == null) \\n            return;\\n        }\\n        max = Math.max(max, depth); \\n        if (goRight) {\\n            dfs(root.left, depth + 1, false);\\n            dfs(root.right, 1, true);\\n        } else {dfs(root.left, 1, false);\\n            dfs(root.right, depth + 1, true);\\n        }\\n    }\\n}\\n```\\n---\\n### Time complexity: $$O(n)$$\\n### Space complexity: $$O(n)$$",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        // we are currently standing on the root node\\n        dfs(root.left, 1, false);   // call for left\\n        dfs(root.right, 1, true);   // call for right\\n        // Why 1? Because from root to root\\'s left or right \\n        // is a distance of 1 unit\\n        return max;\\n    }\\n\\n    // the parameter boolean goRight will let us know \\n    // if we took the right direction or the left direction\\n    private void dfs(TreeNode root, int depth, boolean goRight) {\\n        if (root == null) {\\n            return;\\n        }\\n        // update max distance\\n        max = Math.max(max, depth); \\n        // if we had took right direction\\n        if (goRight) {\\n            // we have 2 options:\\n            // Go left: That\\'d be a zigzag order so distance + 1\\n            dfs(root.left, depth + 1, false);\\n            // Go right: Zigzag order is broken so distance resets to 1\\n            dfs(root.right, 1, true);\\n        } \\n        // Else if we had took a left direction\\n        else {\\n            // we have 2 options:\\n            // Go left: Zigzag order is broken so distance resets to 1\\n            dfs(root.left, 1, false);\\n            // Go right: That\\'d be a zigzag order so distance + 1\\n            dfs(root.right, depth + 1, true);\\n        }\\n        // In each call we set goRight true or false accordingly \\n        // if we are moving to left or right\\n\\n        // Also, why are we resetting the distance to 1 and not 0?\\n        // Because, from current node to next node where we are \\n        // stepping on, the distance is 1, so we set it to 1.\\n    }\\n}\\n```\n```\\ndfs(root, 0, false);\\n```\n```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        dfs(root, 0, false); \\n        return max;\\n    }\\n\\n    private void dfs(TreeNode root, int depth, boolean goRight) {\\n        if (root == null) \\n            return;\\n        }\\n        max = Math.max(max, depth); \\n        if (goRight) {\\n            dfs(root.left, depth + 1, false);\\n            dfs(root.right, 1, true);\\n        } else {dfs(root.left, 1, false);\\n            dfs(root.right, depth + 1, true);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433906,
                "title": "java-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        harsh(root,1,1,0);\\n        return ans;\\n    }\\n    int ans=0;\\n    public void harsh(TreeNode root,int l,int r,int s){\\n        ans=Math.max(ans,s);\\n        if(root.left!=null) harsh(root.left,0,1,s*l+1);\\n        if(root.right!=null) harsh(root.right,1,0,s*r+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        harsh(root,1,1,0);\\n        return ans;\\n    }\\n    int ans=0;\\n    public void harsh(TreeNode root,int l,int r,int s){\\n        ans=Math.max(ans,s);\\n        if(root.left!=null) harsh(root.left,0,1,s*l+1);\\n        if(root.right!=null) harsh(root.right,1,0,s*r+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433704,
                "title": "c-recursive-code-to-optimised-code",
                "content": "**Recursive Code**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    //int cnt=0;\\n    int maxi=1;\\n    void f(TreeNode* root,string dir,int cnt)\\n    {\\n        if(root==NULL)\\n        {\\n            maxi=max(maxi,cnt);\\n            return;\\n        }\\n        if(dir==\"right\")\\n            f(root->right,\"left\",cnt+1);\\n        else\\n            f(root->left,\"right\",cnt+1);\\n    }\\n    void f1(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n            f(root,\"left\",0);\\n            f(root,\"right\",0);\\n        f1(root->left);\\n        f1(root->right);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        f1(root);\\n        return maxi-1;\\n    }\\n};\\n```\\n**Optimised Code**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    void f(TreeNode* root,string dir,int cnt)\\n    {\\n        if(root==NULL)\\n            return;\\n        maxi=max(maxi,cnt);\\n        if(dir==\"left\")\\n        {\\n           f(root->right,\"right\",cnt+1);\\n           f(root->left,\"left\",1);\\n        }\\n        else\\n        {\\n            f(root->left,\"left\",cnt+1);\\n            f(root->right,\"right\",1);\\n        }\\n        \\n    }\\n    int longestZigZag(TreeNode* root) {\\n        f(root,\"left\",0);\\n        f(root,\"right\",0);\\n        return (maxi==INT_MIN)?0:maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    //int cnt=0;\\n    int maxi=1;\\n    void f(TreeNode* root,string dir,int cnt)\\n    {\\n        if(root==NULL)\\n        {\\n            maxi=max(maxi,cnt);\\n            return;\\n        }\\n        if(dir==\"right\")\\n            f(root->right,\"left\",cnt+1);\\n        else\\n            f(root->left,\"right\",cnt+1);\\n    }\\n    void f1(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return;\\n            f(root,\"left\",0);\\n            f(root,\"right\",0);\\n        f1(root->left);\\n        f1(root->right);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        f1(root);\\n        return maxi-1;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxi=INT_MIN;\\n    void f(TreeNode* root,string dir,int cnt)\\n    {\\n        if(root==NULL)\\n            return;\\n        maxi=max(maxi,cnt);\\n        if(dir==\"left\")\\n        {\\n           f(root->right,\"right\",cnt+1);\\n           f(root->left,\"left\",1);\\n        }\\n        else\\n        {\\n            f(root->left,\"left\",cnt+1);\\n            f(root->right,\"right\",1);\\n        }\\n        \\n    }\\n    int longestZigZag(TreeNode* root) {\\n        f(root,\"left\",0);\\n        f(root,\"right\",0);\\n        return (maxi==INT_MIN)?0:maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433462,
                "title": "python-short-and-clean-dfs-functional-programming",
                "content": "# Approach\\n1. Define `longest_zig_zag` which takes a `node` and returns:\\n    - longest zigzig beginning from `node` and taking `left` edge.\\n    - longest zigzag beginning from `node` and taking `right` edge.\\n    - longest zigzag beginning anywhere in the subtree of `node`. (This is the desired answer)\\n\\n2. Recursively, call `longest_zig_zag` on `left` and `right` subtrees.\\n\\n3. Now, compute the result values for `node` based on the results of subtrees as shown in the code below.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is the number of nodes in the tree`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode | None) -> int:\\n        def longest_zig_zag(node: TreeNode | None) -> tuple[int, int, int]:\\n            if node is None: return -1, -1, -1\\n\\n            _, lt_node_max, lt_tree_max = longest_zig_zag(node.left)\\n            rt_node_max, _, rt_tree_max = longest_zig_zag(node.right)\\n\\n            lt, rt = lt_node_max + 1, rt_node_max + 1\\n            return lt, rt, max(lt_tree_max, rt_tree_max, lt, rt)\\n        \\n        return longest_zig_zag(root)[-1]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def longestZigZag(self, root: TreeNode | None) -> int:\\n        def longest_zig_zag(node: TreeNode | None) -> tuple[int, int, int]:\\n            if node is None: return -1, -1, -1\\n\\n            _, lt_node_max, lt_tree_max = longest_zig_zag(node.left)\\n            rt_node_max, _, rt_tree_max = longest_zig_zag(node.right)\\n\\n            lt, rt = lt_node_max + 1, rt_node_max + 1\\n            return lt, rt, max(lt_tree_max, rt_tree_max, lt, rt)\\n        \\n        return longest_zig_zag(root)[-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433449,
                "title": "python-simple-python-solution-using-dfs-recursion",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 377 ms, faster than 83.88% of Python3 online submissions for Longest ZigZag Path in a Binary Tree.\\n# Memory Usage: 60.9 MB, less than 69.60% of Python3 online submissions for Longest ZigZag Path in a Binary Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n\\t\\t\\tself.result = 0\\n\\n\\t\\t\\tdef DFS(node, current_max_path, direction):\\n\\n\\t\\t\\t\\tif node != None:\\n\\n\\t\\t\\t\\t\\tself.result = max(self.result, current_max_path)\\n\\n\\t\\t\\t\\t\\tif direction:\\n\\t\\t\\t\\t\\t\\tDFS(node.right , current_max_path + 1 , False)\\n\\t\\t\\t\\t\\t\\tDFS(node.left , 1 , True)\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tDFS(node.left , current_max_path + 1 , True)\\n\\t\\t\\t\\t\\t\\tDFS(node.right , 1 , False)\\n\\n\\t\\t\\tif root.left:\\n\\t\\t\\t\\tDFS(root.left , 1 , True)\\n\\n\\t\\t\\tif root.right:\\n\\t\\t\\t\\tDFS(root.right , 1 , False)\\n\\n\\t\\t\\treturn self.result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 377 ms, faster than 83.88% of Python3 online submissions for Longest ZigZag Path in a Binary Tree.\\n# Memory Usage: 60.9 MB, less than 69.60% of Python3 online submissions for Longest ZigZag Path in a Binary Tree.\\n\\n\\tclass Solution:\\n\\t\\tdef longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n\\t\\t\\tself.result = 0\\n\\n\\t\\t\\tdef DFS(node, current_max_path, direction):\\n\\n\\t\\t\\t\\tif node != None:\\n\\n\\t\\t\\t\\t\\tself.result = max(self.result, current_max_path)\\n\\n\\t\\t\\t\\t\\tif direction:\\n\\t\\t\\t\\t\\t\\tDFS(node.right , current_max_path + 1 , False)\\n\\t\\t\\t\\t\\t\\tDFS(node.left , 1 , True)\\n\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tDFS(node.left , current_max_path + 1 , True)\\n\\t\\t\\t\\t\\t\\tDFS(node.right , 1 , False)\\n\\n\\t\\t\\tif root.left:\\n\\t\\t\\t\\tDFS(root.left , 1 , True)\\n\\n\\t\\t\\tif root.right:\\n\\t\\t\\t\\tDFS(root.right , 1 , False)\\n\\n\\t\\t\\treturn self.result\\n\\t\\t\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3433343,
                "title": "iterative-dfs-solution-in-rust",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn longest_zig_zag(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut max_len = 0;\\n        let mut stack = vec![(root, true, 0)];\\n        while let Some((node, is_left, len)) = stack.pop() {\\n            if let Some(node) = node {\\n                max_len = max_len.max(len);\\n                let &TreeNode { ref left, ref right, .. } = &*node.borrow();\\n                stack.push((left.as_ref().map(Rc::clone), true, if is_left { 1 } else { len + 1 }));\\n                stack.push((right.as_ref().map(Rc::clone), false, if is_left { len + 1 } else { 1 }));\\n            }\\n        }\\n        max_len\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn longest_zig_zag(root: Option<Rc<RefCell<TreeNode>>>) -> i32 {\\n        let mut max_len = 0;\\n        let mut stack = vec![(root, true, 0)];\\n        while let Some((node, is_left, len)) = stack.pop() {\\n            if let Some(node) = node {\\n                max_len = max_len.max(len);\\n                let &TreeNode { ref left, ref right, .. } = &*node.borrow();\\n                stack.push((left.as_ref().map(Rc::clone), true, if is_left { 1 } else { len + 1 }));\\n                stack.push((right.as_ref().map(Rc::clone), false, if is_left { len + 1 } else { 1 }));\\n            }\\n        }\\n        max_len\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3433226,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* node, int dir, int len) {\\n        if (node == NULL) return len;\\n        int left = dfs(node->left, 1, (dir == 0 ? len + 1 : 0));\\n        int right = dfs(node->right, 0, (dir == 1 ? len + 1 : 0));\\n        return max(left, right);\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        int left = dfs(root->left, 1, 0);\\n        int right = dfs(root->right, 0, 0);\\n        return max(left, right);\\n    }\\n};\\n\\n```\\nOther solution modified from the javascript code of comments\\n```\\nclass Solution {\\npublic:\\n    int getLength(TreeNode* root, bool flag, int& res) {\\n    if (root == nullptr) {\\n        return 0;\\n    }\\n    \\n    int left_path = getLength(root->left, true, res);\\n    int right_path = getLength(root->right, false, res);\\n    res = max(res, max(left_path, right_path));\\n    \\n    if (flag) {\\n        return 1 + right_path;\\n    } else {\\n        return 1 + left_path;\\n    }\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n    int res = 0;\\n    getLength(root, true, res);\\n    getLength(root, false, res);\\n    return res;\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int dfs(TreeNode* node, int dir, int len) {\\n        if (node == NULL) return len;\\n        int left = dfs(node->left, 1, (dir == 0 ? len + 1 : 0));\\n        int right = dfs(node->right, 0, (dir == 1 ? len + 1 : 0));\\n        return max(left, right);\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        if (root == NULL) return 0;\\n        int left = dfs(root->left, 1, 0);\\n        int right = dfs(root->right, 0, 0);\\n        return max(left, right);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int getLength(TreeNode* root, bool flag, int& res) {\\n    if (root == nullptr) {\\n        return 0;\\n    }\\n    \\n    int left_path = getLength(root->left, true, res);\\n    int right_path = getLength(root->right, false, res);\\n    res = max(res, max(left_path, right_path));\\n    \\n    if (flag) {\\n        return 1 + right_path;\\n    } else {\\n        return 1 + left_path;\\n    }\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n    int res = 0;\\n    getLength(root, true, res);\\n    getLength(root, false, res);\\n    return res;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433044,
                "title": "python-readable-dfs-recursion",
                "content": "\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def longestZigZag(self, root):\\n        def dfsLeft(node, count):\\n            if not node:\\n                return count\\n            left, right = dfsLeft(node.left, 0), dfsRight(node.right, count + 1)\\n            return max(left, right)\\n            \\n        def dfsRight(node, count):\\n            if not node:\\n                return count\\n            left, right = dfsLeft(node.left, count + 1), dfsRight(node.right, 0)\\n            return max(left, right)\\n\\n        return max(dfsLeft(root.left, 0), dfsRight(root.right, 0))\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution(object):\\n    def longestZigZag(self, root):\\n        def dfsLeft(node, count):\\n            if not node:\\n                return count\\n            left, right = dfsLeft(node.left, 0), dfsRight(node.right, count + 1)\\n            return max(left, right)\\n            \\n        def dfsRight(node, count):\\n            if not node:\\n                return count\\n            left, right = dfsLeft(node.left, count + 1), dfsRight(node.right, 0)\\n            return max(left, right)\\n\\n        return max(dfsLeft(root.left, 0), dfsRight(root.right, 0))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432953,
                "title": "daily-leetcoding-challenge-april-day-19",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 19.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3310421,
                "title": "c-java-simple-dfs-solution",
                "content": "1. If the current node is a left child, \\n    - `dfs(node->right,currLen+1)` to continue the ZigZag path\\n    - `dfs(node->left,1)`- Start a new ZigZag path from current node (left direction)\\n2. If the current node is a right child,\\n    - `dfs(node->left,currLen+1)` to continue the ZigZag path\\n    - `dfs(node->right,1)` - Start a new ZigZag path from current node (right direction)\\n\\nSo we can do a DFS traversal from root in both directions and at each node update the maximum length of the path (edges in the path).\\n\\n```C++ []\\nclass Solution {\\n    public:\\n    int maxLength = 0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength = max(maxLength, currLength);\\n        // At each node, two choices\\n        // Continue the previous path in the alternate direction\\n        // Start a new path in the same direction\\n        solve(root->left, 0, (dir)? currLength+1 : 1);\\n        solve(root->right, 1, (dir)? 1 : currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root, 0, 0);\\n        solve(root, 1, 0);\\n        return maxLength;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int maxLength=0;\\n    public void solve(TreeNode root,int dir,int currLength){\\n        if(root==null) return;\\n        maxLength=Math.max(maxLength,currLength);\\n        // At each node, two choices\\n        // Continue the previous path in the alternate direction\\n        // Start a new path in the same direction\\n        if(dir==1){\\n            solve(root.left,0,currLength+1);\\n            solve(root.right,1,1);\\n        }\\n        else{\\n            solve(root.right,1,currLength+1);\\n            solve(root.left,0,1);\\n        }\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```C++ []\\nclass Solution {\\n    public:\\n    int maxLength = 0;\\n\\n    void solve(TreeNode* root,int dir,int currLength){\\n        if(!root) return;\\n        maxLength = max(maxLength, currLength);\\n        // At each node, two choices\\n        // Continue the previous path in the alternate direction\\n        // Start a new path in the same direction\\n        solve(root->left, 0, (dir)? currLength+1 : 1);\\n        solve(root->right, 1, (dir)? 1 : currLength+1);\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        solve(root, 0, 0);\\n        solve(root, 1, 0);\\n        return maxLength;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int maxLength=0;\\n    public void solve(TreeNode root,int dir,int currLength){\\n        if(root==null) return;\\n        maxLength=Math.max(maxLength,currLength);\\n        // At each node, two choices\\n        // Continue the previous path in the alternate direction\\n        // Start a new path in the same direction\\n        if(dir==1){\\n            solve(root.left,0,currLength+1);\\n            solve(root.right,1,1);\\n        }\\n        else{\\n            solve(root.right,1,currLength+1);\\n            solve(root.left,0,1);\\n        }\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        solve(root,0,0);\\n        solve(root,1,0);\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070087,
                "title": "pyhon-easy-soultion-to-understand-with-explanation-beast-90",
                "content": "# Approach\\nWe want to cut zigzag. lets say we are the left son, when we want to get the lenght of left path of our right child(The opposite if we are the right son ).\\nSo for each node we call the same function to our childs. the base case is a None node and we return 0. After that we check which son are we and increase result based on the path lenght from the child.\\n\\nright[0] means go to the right child and give me the length of the left path.\\nleft[1] means go to the left child and give me the length of the right path.\\n\\n# Complexity\\n- Time complexity:\\nO(n): we are doing kind of a dfs scan , which is known for being O(n)\\n\\n- Space complexity:\\nO(1): we are not using any extra memory.\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n        result = 0\\n        def dfs(node,parent):\\n            nonlocal result \\n            if node is None:\\n                return (0,0)\\n            left = dfs(node.left,node)\\n            right = dfs(node.right,node)\\n            if parent.left==node\\n                result = max(result,right[0]+1)\\n            else:\\n                result = max(result,left[1]+1)\\n            return (left[1]+1,right[0]+1)\\n        dfs(root.left,root)\\n        dfs(root.right,root)\\n        return result\\n                \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n\\n        result = 0\\n        def dfs(node,parent):\\n            nonlocal result \\n            if node is None:\\n                return (0,0)\\n            left = dfs(node.left,node)\\n            right = dfs(node.right,node)\\n            if parent.left==node\\n                result = max(result,right[0]+1)\\n            else:\\n                result = max(result,left[1]+1)\\n            return (left[1]+1,right[0]+1)\\n        dfs(root.left,root)\\n        dfs(root.right,root)\\n        return result\\n                \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2688910,
                "title": "java-o-n-dp-solution-with-explanation-and-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition 1 - We will do post order traversal as we want to use the results of the children stored in a DP natured map data structure.\\n\\nIntuition 2 - We will use 2 persistent variables namely a dp map and a MAX variable. that signify the following:\\n1. ***DP map*** -> Will store an int array of size 2 consisting of the max zigzag length if you start from this root in both left and right direction. Index 0 holds the left scenario and 1 holds the right scenario.\\n2. ***MAX*** -> used to calculate max length seen so far.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter every postorder computation DP will hold <Key, Value> as <Current Node reference, Array[max distance from here if you go left, max distance from here if you go right]>\\n\\n# Complexity\\n- Time complexity: O(n) where n is the number of nodes as we go over every node just once\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) as dp is the size of nodes as keys and values are constant of size 2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int MAX;\\n    Map<TreeNode, int []> dp;\\n    public int longestZigZag(TreeNode root) {\\n        \\n        //postorder traversal\\n        //Map stores left from node and right from node\\n        dp = new HashMap<>();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    //returns max length from here if you go in a particular direction\\n    private void dfs(TreeNode root){\\n        if(root == null) return;\\n\\n        if(root.left == null && root.right == null){\\n            dp.put(root, new int[]{0,0});\\n            return;\\n        }\\n        //In dp value int []\\n        //index 0 represents left direction\\n        //index 1 represents right direction\\n        dfs(root.left);\\n        dfs(root.right);\\n\\n        int left = 0, right = 0;\\n\\n        if(dp.get(root.left) != null)\\n            left = 1 + dp.get(root.left)[1]; //we go right after left\\n        \\n        if(dp.get(root.right) != null)\\n            right = 1 + dp.get(root.right)[0]; //we go left after right\\n        dp.put(root, new int[]{left, right});\\n        MAX = Math.max(MAX, Math.max(left,right));\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\n    int MAX;\\n    Map<TreeNode, int []> dp;\\n    public int longestZigZag(TreeNode root) {\\n        \\n        //postorder traversal\\n        //Map stores left from node and right from node\\n        dp = new HashMap<>();\\n        dfs(root);\\n        return MAX;\\n    }\\n\\n    //returns max length from here if you go in a particular direction\\n    private void dfs(TreeNode root){\\n        if(root == null) return;\\n\\n        if(root.left == null && root.right == null){\\n            dp.put(root, new int[]{0,0});\\n            return;\\n        }\\n        //In dp value int []\\n        //index 0 represents left direction\\n        //index 1 represents right direction\\n        dfs(root.left);\\n        dfs(root.right);\\n\\n        int left = 0, right = 0;\\n\\n        if(dp.get(root.left) != null)\\n            left = 1 + dp.get(root.left)[1]; //we go right after left\\n        \\n        if(dp.get(root.right) != null)\\n            right = 1 + dp.get(root.right)[0]; //we go left after right\\n        dp.put(root, new int[]{left, right});\\n        MAX = Math.max(MAX, Math.max(left,right));\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2679946,
                "title": "c",
                "content": "Runtime: 125 ms, faster than 100.00% of C online submissions for Longest ZigZag Path in a Binary Tree.\\nMemory Usage: 53.5 MB, less than 28.57% of C online submissions for Longest ZigZag Path in a Binary Tree.\\n```\\ntypedef struct{\\n    int l;\\n    int r;\\n}Data;\\n\\nData process(struct TreeNode* root,int* max){\\n    Data ret;\\n    if(root == NULL){\\n        ret.l = -1;\\n        ret.r = -1;\\n        return ret;\\n    }\\n    Data dLTree = process(root->left, max);\\n    Data dRTree = process(root->right, max);\\n    \\n    ret.l = 1 + dRTree.r;\\n    ret.r = 1 + dLTree.l;\\n    *max  = fmax( fmax(ret.l, *max), ret.r);\\n    return ret;\\n}\\n\\nint longestZigZag(struct TreeNode* root){\\n    int max = 0;\\n    process(root, &max);\\n    return max;\\n}\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\ntypedef struct{\\n    int l;\\n    int r;\\n}Data;\\n\\nData process(struct TreeNode* root,int* max){\\n    Data ret;\\n    if(root == NULL){\\n        ret.l = -1;\\n        ret.r = -1;\\n        return ret;\\n    }\\n    Data dLTree = process(root->left, max);\\n    Data dRTree = process(root->right, max);\\n    \\n    ret.l = 1 + dRTree.r;\\n    ret.r = 1 + dLTree.l;\\n    *max  = fmax( fmax(ret.l, *max), ret.r);\\n    return ret;\\n}\\n\\nint longestZigZag(struct TreeNode* root){\\n    int max = 0;\\n    process(root, &max);\\n    return max;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2609933,
                "title": "easy-js-beginner-solution",
                "content": "Theory:\\n\\n1. Longest zigzag path can either begin from \"left\" or \"right\" edge. Hence need to find max from these two.\\n2. When we are at root, we will start by saying that, we have taken hypothetical path \"l\" or \"r\" with length 0.\\n3. when we are at left node, we check whether the prev edge we took is \"r\". If yes increase the path length. else we need to start new journey from here because Left - > Left is not zigzag.\\n4. Similarly when we are at right node we check if the prev edge we took is \"l\". If yes, our zigzag path will increase by one. If not, then new journey will start from here because Right -> Right path is not zigzag. \\n\\n```\\nvar longestZigZag = function(root) {\\n    let max = 0;\\n    \\n    const helper = (node, prev, length) => {\\n    \\n        if(node === null)\\n            return null;\\n        \\n        max = Math.max(max, length);\\n        \\n        helper(node.left, \"l\" , prev === \"r\" ? length + 1 : 1);\\n        helper(node.right, \"r\" , prev === \"l\" ? length + 1 : 1);\\n    }\\n    \\n    \\n    helper(root, \"l\", 0); \\n    helper(root, \"r\", 0);\\n    \\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar longestZigZag = function(root) {\\n    let max = 0;\\n    \\n    const helper = (node, prev, length) => {\\n    \\n        if(node === null)\\n            return null;\\n        \\n        max = Math.max(max, length);\\n        \\n        helper(node.left, \"l\" , prev === \"r\" ? length + 1 : 1);\\n        helper(node.right, \"r\" , prev === \"l\" ? length + 1 : 1);\\n    }\\n    \\n    \\n    helper(root, \"l\", 0); \\n    helper(root, \"r\", 0);\\n    \\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2559539,
                "title": "python3-iterative-dfs-using-stack-99-time-91-space-o-n-time-o-n-space",
                "content": "Initialize stack with root.left and root.right because the direction when entering the root node is undefined. If you do double left or double right, restart the count.\\n```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        \\n        LEFT = 0\\n        RIGHT = 1\\n            \\n        stack = []\\n        if root.left:\\n            stack.append((root.left, LEFT, 1))\\n        if root.right:\\n            stack.append((root.right, RIGHT, 1))\\n            \\n        longest = 0\\n        while stack:\\n            node, direction, count = stack.pop()\\n            \\n            longest = max(longest, count)\\n            if direction == LEFT:\\n                if node.left:\\n                    stack.append((node.left, LEFT, 1))\\n                if node.right:\\n                    stack.append((node.right, RIGHT, count+1))\\n            else:\\n                if node.right:\\n                    stack.append((node.right, RIGHT, 1))\\n                if node.left:\\n                    stack.append((node.left, LEFT, count+1))\\n        return longest\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        \\n        LEFT = 0\\n        RIGHT = 1\\n            \\n        stack = []\\n        if root.left:\\n            stack.append((root.left, LEFT, 1))\\n        if root.right:\\n            stack.append((root.right, RIGHT, 1))\\n            \\n        longest = 0\\n        while stack:\\n            node, direction, count = stack.pop()\\n            \\n            longest = max(longest, count)\\n            if direction == LEFT:\\n                if node.left:\\n                    stack.append((node.left, LEFT, 1))\\n                if node.right:\\n                    stack.append((node.right, RIGHT, count+1))\\n            else:\\n                if node.right:\\n                    stack.append((node.right, RIGHT, 1))\\n                if node.left:\\n                    stack.append((node.left, LEFT, count+1))\\n        return longest\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2436026,
                "title": "o-n-recursion-5-line-c-code",
                "content": "```\\nint zigzag(TreeNode* root, int dir, int val){\\n        if(root==NULL) return val;\\n        return dir==-1? max(zigzag(root->right,1,val+1),zigzag(root->left,-1,0)) : max(zigzag(root->left,-1,val+1),zigzag(root->right,1,0));\\n    }   \\n    int longestZigZag(TreeNode* root) {\\n        return max(zigzag(root->left,-1,0),zigzag(root->right,1,0));\\n    }\\n```",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nint zigzag(TreeNode* root, int dir, int val){\\n        if(root==NULL) return val;\\n        return dir==-1? max(zigzag(root->right,1,val+1),zigzag(root->left,-1,0)) : max(zigzag(root->left,-1,val+1),zigzag(root->right,1,0));\\n    }   \\n    int longestZigZag(TreeNode* root) {\\n        return max(zigzag(root->left,-1,0),zigzag(root->right,1,0));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2126462,
                "title": "java-solution-with-comments-and-clean-code",
                "content": "```\\nclass Solution {\\n\\n    int ans = 0;    //global variable ans to store and compare longest path\\n    \\n    public int longestZigZag(TreeNode root) {\\n\\t\\n\\t\\t//to keep a record of previous traversal boolean flag is used \\n        pathFinder(root.left,true,0);       //from root to left and then to right so flag is true\\n        pathFinder(root.right,false,0);     //from root to right and then  to left so flag is false\\n        return ans;\\n    }\\n    \\n    public void pathFinder(TreeNode root, boolean flag, int sum){\\n\\t\\n\\t\\t//base condition\\n        if(root==null){\\n            ans = Math.max(ans,sum);\\n            return;\\n        }\\n        \\n\\t\\t//true means we have to go right.\\n        if(flag){\\n            pathFinder(root.right,false,sum+1);  //recursive call for root.right\\n            pathFinder(root.left,true,0);        //but there can be new ZigZag path from root.left\\n        }\\n        else{\\n\\t\\t\\t//we have to go left\\n            pathFinder(root.left,true,sum+1);  //recursive call for root.left\\n            pathFinder(root.right,false,0);    //but there can be new ZigZag path from root.left\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\n    int ans = 0;    //global variable ans to store and compare longest path\\n    \\n    public int longestZigZag(TreeNode root) {\\n\\t\\n\\t\\t//to keep a record of previous traversal boolean flag is used \\n        pathFinder(root.left,true,0);       //from root to left and then to right so flag is true\\n        pathFinder(root.right,false,0);     //from root to right and then  to left so flag is false\\n        return ans;\\n    }\\n    \\n    public void pathFinder(TreeNode root, boolean flag, int sum){\\n\\t\\n\\t\\t//base condition\\n        if(root==null){\\n            ans = Math.max(ans,sum);\\n            return;\\n        }\\n        \\n\\t\\t//true means we have to go right.\\n        if(flag){\\n            pathFinder(root.right,false,sum+1);  //recursive call for root.right\\n            pathFinder(root.left,true,0);        //but there can be new ZigZag path from root.left\\n        }\\n        else{\\n\\t\\t\\t//we have to go left\\n            pathFinder(root.left,true,sum+1);  //recursive call for root.left\\n            pathFinder(root.right,false,0);    //but there can be new ZigZag path from root.left\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1806903,
                "title": "c-dfs-super-simple-o-n-and-o-1",
                "content": "We use 2 variables pleft and pright which contain the length of longest zigzag path ending at the current node given the current node is a left child or a right child of its parent respectively.\\nIf the current node has a right child, the length of zigzag path ending with this right child will be pleft+1. Similarly for the case when the current node has a left child.\\n```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* root, int pleft, int pright){\\n        if(root==NULL) return ;\\n        if(root->right){\\n            ans = max(ans, pleft+1);\\n            fun(root->right, 0, pleft+1); //pright of the right child is the new lenght of zigzag path = pleft+1\\n        }\\n        if(root->left){\\n            ans = max(ans, pright+1);\\n            fun(root->left, pright+1, 0);\\n            \\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* root, int pleft, int pright){\\n        if(root==NULL) return ;\\n        if(root->right){\\n            ans = max(ans, pleft+1);\\n            fun(root->right, 0, pleft+1); //pright of the right child is the new lenght of zigzag path = pleft+1\\n        }\\n        if(root->left){\\n            ans = max(ans, pright+1);\\n            fun(root->left, pright+1, 0);\\n            \\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1791746,
                "title": "java-dfs-clean-easy-to-understand-with-explanation-solution-o-n",
                "content": "```\\nprivate enum Direction {\\n\\tRIGHT, LEFT;\\n}\\n\\npublic int longestZigZag(TreeNode root) {\\n\\treturn dfs(root, 0, null); // Start from the root no directions yet\\n}\\n\\nprivate int dfs(TreeNode node, int sum, Direction dir) {\\n\\tif (node == null) return sum - 1; // If the cur node is null just remove the plus 1 from sum\\n\\t// When going to a node if we are coming from the same direction than we would need to reset the sum to 1\\n\\tint left = dfs(node.left, dir == Direction.LEFT ? 1 : sum + 1, Direction.LEFT);\\n\\tint right = dfs(node.right, dir == Direction.RIGHT ? 1 : sum + 1, Direction.RIGHT);\\n\\n\\treturn Math.max(left, right); // Return the maximum of the left and the right\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nprivate enum Direction {\\n\\tRIGHT, LEFT;\\n}\\n\\npublic int longestZigZag(TreeNode root) {\\n\\treturn dfs(root, 0, null); // Start from the root no directions yet\\n}\\n\\nprivate int dfs(TreeNode node, int sum, Direction dir) {\\n\\tif (node == null) return sum - 1; // If the cur node is null just remove the plus 1 from sum\\n\\t// When going to a node if we are coming from the same direction than we would need to reset the sum to 1\\n\\tint left = dfs(node.left, dir == Direction.LEFT ? 1 : sum + 1, Direction.LEFT);\\n\\tint right = dfs(node.right, dir == Direction.RIGHT ? 1 : sum + 1, Direction.RIGHT);\\n\\n\\treturn Math.max(left, right); // Return the maximum of the left and the right\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1766450,
                "title": "java-simple-approach-explained-with-comments",
                "content": "```\\nclass Solution {\\n   int max = 0;\\n\\n\\tpublic int longestZigZag(TreeNode root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n        // start with depth (indicates count of nodes in zigzag path sofar) zero in both directions\\n\\t\\tpath(root.left, 0, false);\\n\\t\\tpath(root.right, 0, true);\\n        // return max zigzag path found\\n\\t\\treturn max;\\n\\t}\\n\\n\\t//using boolean value direction: false-left true-right\\n\\tpublic void path(TreeNode node, int depth, boolean direction) {\\n        // capture max depth of zigzag path captured sofar in global variable max\\n\\t\\tmax = Math.max(max, depth);\\n\\t\\tif (node == null)\\n\\t\\t\\treturn;\\n        // if previous direction is right(i.e direction is true) and we r heading towards left increment depth+1 as it counts towards valid zigzag path\\n\\t\\totherwise its important that we need to reset because current zigzag path breaks here and we need to start again to see if there is any other zigzag path from this node.\\n\\t\\tpath(node.left, direction ? depth + 1 : 0, false);\\n        // likewise if previous zigzag path is left(i.e direction is false) and we r heading towards right increment depth+1 is it counts towards valid zigzag path \\n\\t\\totherwise reset current count sofar and start again from here\\n\\t\\tpath(node.right, !direction ? depth + 1 : 0, true);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   int max = 0;\\n\\n\\tpublic int longestZigZag(TreeNode root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn 0;\\n        // start with depth (indicates count of nodes in zigzag path sofar) zero in both directions\\n\\t\\tpath(root.left, 0, false);\\n\\t\\tpath(root.right, 0, true);\\n        // return max zigzag path found\\n\\t\\treturn max;\\n\\t}\\n\\n\\t//using boolean value direction: false-left true-right\\n\\tpublic void path(TreeNode node, int depth, boolean direction) {\\n        // capture max depth of zigzag path captured sofar in global variable max\\n\\t\\tmax = Math.max(max, depth);\\n\\t\\tif (node == null)\\n\\t\\t\\treturn;\\n        // if previous direction is right(i.e direction is true) and we r heading towards left increment depth+1 as it counts towards valid zigzag path\\n\\t\\totherwise its important that we need to reset because current zigzag path breaks here and we need to start again to see if there is any other zigzag path from this node.\\n\\t\\tpath(node.left, direction ? depth + 1 : 0, false);\\n        // likewise if previous zigzag path is left(i.e direction is false) and we r heading towards right increment depth+1 is it counts towards valid zigzag path \\n\\t\\totherwise reset current count sofar and start again from here\\n\\t\\tpath(node.right, !direction ? depth + 1 : 0, true);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713560,
                "title": "c-simple-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    int dfs(TreeNode* node, bool isLeftChild = true){\\n        if (node == nullptr) return -1;\\n        \\n        int left = dfs(node -> left, true) + 1;\\n        int right = dfs(node -> right, false) + 1;\\n        \\n        ans = max(ans, max(left, right));\\n        return (isLeftChild) ? right : left;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        dfs(root); //root has no father, therefore it could be either true or false\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    int dfs(TreeNode* node, bool isLeftChild = true){\\n        if (node == nullptr) return -1;\\n        \\n        int left = dfs(node -> left, true) + 1;\\n        int right = dfs(node -> right, false) + 1;\\n        \\n        ans = max(ans, max(left, right));\\n        return (isLeftChild) ? right : left;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        dfs(root); //root has no father, therefore it could be either true or false\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637424,
                "title": "c",
                "content": "```\\n    //0->left\\n    //1->right\\n    int a = 0;\\n    int b = 0;\\n    map<pair<TreeNode*,bool>,int> mp;\\n    int solve(TreeNode* root, bool flag){\\n        if (root==NULL){\\n            return -1;\\n        }\\n        \\n        if (mp.find({root,flag})!=mp.end()){\\n            return mp[{root,flag}];\\n        }\\n        if (flag==0){\\n            return mp[{root,flag}]=1+solve(root->right,1);\\n        }\\n        else{\\n            return mp[{root,flag}]=1+solve(root->left,0);\\n        }\\n    }\\n    void dfs(TreeNode* root){\\n        if (root==NULL){\\n            return;\\n        }\\n        a  = max(a,solve(root,0));\\n        b = max(b,solve(root,1));\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root);\\n       \\n        return max(a,b);\\n    }\\n};",
                "solutionTags": [
                    "Memoization"
                ],
                "code": "```\\n    //0->left\\n    //1->right\\n    int a = 0;\\n    int b = 0;\\n    map<pair<TreeNode*,bool>,int> mp;\\n    int solve(TreeNode* root, bool flag){\\n        if (root==NULL){\\n            return -1;\\n        }\\n        \\n        if (mp.find({root,flag})!=mp.end()){\\n            return mp[{root,flag}];\\n        }\\n        if (flag==0){\\n            return mp[{root,flag}]=1+solve(root->right,1);\\n        }\\n        else{\\n            return mp[{root,flag}]=1+solve(root->left,0);\\n        }\\n    }\\n    void dfs(TreeNode* root){\\n        if (root==NULL){\\n            return;\\n        }\\n        a  = max(a,solve(root,0));\\n        b = max(b,solve(root,1));\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        dfs(root);\\n       \\n        return max(a,b);\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1495111,
                "title": "c-inorder-traversal",
                "content": "```\\n \\nclass Solution {\\npublic:\\n    int ans;\\n    \\n    void inorder(TreeNode* root,bool dir,int len){\\n        \\n        if(root==NULL) return ;\\n         \\n        ans=max(ans,len);\\n        if(dir==0){\\n            inorder(root->left,1,len+1);\\n            inorder(root->right,0,1);\\n        }\\n        else{\\n             inorder(root->right,0,len+1);\\n             inorder(root->left,1,1);\\n        }\\n         \\n        return ;\\n       } \\n    \\n    int longestZigZag(TreeNode* root) {\\n        ans=0;\\n         inorder(root->left,1, 1);\\n         inorder(root->right,0, 1);\\n        \\n        return ans ;\\n    }\\n};\\n```\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int ans=0; \\n    \\n    pair<int,int>  dfs(TreeNode* root){\\n        \\n        if(!root)  return {-1,-1};\\n        \\n        auto [l1,l2]= dfs(root->left);\\n        auto [r1,r2]= dfs(root->right);\\n         \\n        ans=max({ans,l2+1,r1+1});\\n        \\n        return {l2+1,r1+1};  \\n        \\n    }\\n      \\n    int longestZigZag(TreeNode* root) {\\n        \\n        dfs(root); \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n \\nclass Solution {\\npublic:\\n    int ans;\\n    \\n    void inorder(TreeNode* root,bool dir,int len){\\n        \\n        if(root==NULL) return ;\\n         \\n        ans=max(ans,len);\\n        if(dir==0){\\n            inorder(root->left,1,len+1);\\n            inorder(root->right,0,1);\\n        }\\n        else{\\n             inorder(root->right,0,len+1);\\n             inorder(root->left,1,1);\\n        }\\n         \\n        return ;\\n       } \\n    \\n    int longestZigZag(TreeNode* root) {\\n        ans=0;\\n         inorder(root->left,1, 1);\\n         inorder(root->right,0, 1);\\n        \\n        return ans ;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int ans=0; \\n    \\n    pair<int,int>  dfs(TreeNode* root){\\n        \\n        if(!root)  return {-1,-1};\\n        \\n        auto [l1,l2]= dfs(root->left);\\n        auto [r1,r2]= dfs(root->right);\\n         \\n        ans=max({ans,l2+1,r1+1});\\n        \\n        return {l2+1,r1+1};  \\n        \\n    }\\n      \\n    int longestZigZag(TreeNode* root) {\\n        \\n        dfs(root); \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447927,
                "title": "simple-recursion-in-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int max_val=0;\\n    int fun(TreeNode* temp,bool isLeft)\\n    {\\n        if(!temp) return 0;\\n        int l = fun(temp->left,0);\\n        int r = fun(temp->right,1);\\n        max_val = max({max_val,l,r});\\n        return 1+(isLeft?l:r);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        fun(root,0);\\n        return max_val;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int max_val=0;\\n    int fun(TreeNode* temp,bool isLeft)\\n    {\\n        if(!temp) return 0;\\n        int l = fun(temp->left,0);\\n        int r = fun(temp->right,1);\\n        max_val = max({max_val,l,r});\\n        return 1+(isLeft?l:r);\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        fun(root,0);\\n        return max_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344683,
                "title": "dp-dfs-java-thinking-in-terms-of-subproblems",
                "content": "This solution is not a clever solution, but it shows how to think in terms of subproblems and thinking about what choices do you have at each subproblem. Always start with the base case and your initial caller because they give clues as to what your choices are. \\n\\nThe way I thought about it was: `If I\\'m at the root, then what is the longest chain I can make? I don\\'t know, so I will check my left and right`. Then I saw in the example that the longest zigzag does not necessarily need to originate from the root. That means `the longest zigzag can originate from any node`. At every node, I can choose to extend my current chain, OR I can try to act as the root of the chain. I don\\'t know which is better, so I try both of them in the recursion. If I am extending, I add 1 to the length to the next call. If I am acting as the root of the chain, the chain length is now only 1 for the next caller.\\n```\\nclass Solution {\\n  private static final int LEFT = 0;\\n  private static final int RIGHT = 1;\\n  int max = 0;\\n  public int longestZigZag(TreeNode root) {\\n    Set<TreeNode> dp = new HashSet<>();\\n    traverse(root.left, LEFT, 1, dp);\\n    traverse(root.right, RIGHT, 1, dp);\\n    return max;\\n  }\\n  \\n  public void traverse(TreeNode root, int prevDir, int length, Set<TreeNode> dp) {\\n    if(root == null) return;\\n    if(dp.contains(root)) return;\\n    \\n    // extend\\n    if(prevDir == LEFT) {\\n      traverse(root.right, RIGHT, length+1, dp);\\n    } else {\\n      traverse(root.left, LEFT, length+1, dp); \\n    }\\n    \\n    // act as source\\n    traverse(root.left, LEFT, 1, dp);\\n    traverse(root.right, RIGHT, 1, dp);\\n    max = Math.max(max, length);\\n    dp.add(root);\\n  }\\n}\\n```\\n\\nUpvote if this helped you \\uD83D\\uDC4D",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  private static final int LEFT = 0;\\n  private static final int RIGHT = 1;\\n  int max = 0;\\n  public int longestZigZag(TreeNode root) {\\n    Set<TreeNode> dp = new HashSet<>();\\n    traverse(root.left, LEFT, 1, dp);\\n    traverse(root.right, RIGHT, 1, dp);\\n    return max;\\n  }\\n  \\n  public void traverse(TreeNode root, int prevDir, int length, Set<TreeNode> dp) {\\n    if(root == null) return;\\n    if(dp.contains(root)) return;\\n    \\n    // extend\\n    if(prevDir == LEFT) {\\n      traverse(root.right, RIGHT, length+1, dp);\\n    } else {\\n      traverse(root.left, LEFT, length+1, dp); \\n    }\\n    \\n    // act as source\\n    traverse(root.left, LEFT, 1, dp);\\n    traverse(root.right, RIGHT, 1, dp);\\n    max = Math.max(max, length);\\n    dp.add(root);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1278621,
                "title": "c-short-and-simple-dfs-solution",
                "content": "```\\nint solve(TreeNode* root, bool isRightChild, int &ans) {\\n\\tif(!root) return 0;\\n\\tint l = solve(root->left, false, ans);\\n\\tint r = solve(root->right, true, ans);\\n\\tans = max(ans, max(l, r) + 1);\\n\\treturn isRightChild ? l+1 : r+1;\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n\\tint ans = 0;\\n\\tsolve(root, false, ans);\\n\\treturn ans - 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint solve(TreeNode* root, bool isRightChild, int &ans) {\\n\\tif(!root) return 0;\\n\\tint l = solve(root->left, false, ans);\\n\\tint r = solve(root->right, true, ans);\\n\\tans = max(ans, max(l, r) + 1);\\n\\treturn isRightChild ? l+1 : r+1;\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n\\tint ans = 0;\\n\\tsolve(root, false, ans);\\n\\treturn ans - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 764324,
                "title": "easy-java-dfs",
                "content": "```\\nclass Solution {    \\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(dfs(root, true, -1), dfs(root, false, -1));\\n    }\\n    \\n    int dfs(TreeNode node, boolean toLeft, int path) {\\n        if (node == null) {\\n            return path;\\n        }\\n        int ans = -1;\\n        if (toLeft) {\\n            ans = dfs(node.left, false, path + 1);\\n            ans = Math.max(ans, dfs(node.right, true, 0));\\n        } else {\\n            ans = dfs(node.right, true, path + 1);\\n            ans = Math.max(ans, dfs(node.left, false, 0));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {    \\n    public int longestZigZag(TreeNode root) {\\n        return Math.max(dfs(root, true, -1), dfs(root, false, -1));\\n    }\\n    \\n    int dfs(TreeNode node, boolean toLeft, int path) {\\n        if (node == null) {\\n            return path;\\n        }\\n        int ans = -1;\\n        if (toLeft) {\\n            ans = dfs(node.left, false, path + 1);\\n            ans = Math.max(ans, dfs(node.right, true, 0));\\n        } else {\\n            ans = dfs(node.right, true, path + 1);\\n            ans = Math.max(ans, dfs(node.left, false, 0));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 726933,
                "title": "python3-clean-bfs-solution-using-deque",
                "content": "I am using a deque for BFS in python.\\nThe node of the BFS will be **{curr_node, state(can be \\'L\\' or \\'R\\'), longestdistance}** where longest distance = longest zigzag distance so far.\\n\\nNow if your current state is \\'L\\' and a right child exist for the current node, we will extend the current longest distance by 1 (same case for state \\'R\\' and existence of a left child)\\n\\n```\\nfrom collections import deque\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        # dequeu node : [curr_node, state, longestdistance]\\n        ans = 0\\n        q = deque([[root, \\'A\\', 0]])\\n        while (len(q) != 0):\\n            top, state, dist = q[0]\\n            ans = max(ans, dist)\\n            q.popleft()\\n            if state == \\'A\\':\\n                if top.left:\\n                    q.append([top.left, \\'L\\', 1])\\n                if top.right:\\n                    q.append([top.right, \\'R\\', 1])\\n            else:\\n                if state == \\'L\\':\\n                    if top.left:\\n                        q.append([top.left, \\'L\\', 1])\\n                    if top.right:\\n                        q.append([top.right, \\'R\\', dist+1])\\n                if state == \\'R\\':\\n                    if top.left:\\n                        q.append([top.left, \\'L\\', dist+1])\\n                    if top.right:\\n                        q.append([top.right, \\'R\\', 1])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\n    def longestZigZag(self, root: TreeNode) -> int:\\n        # dequeu node : [curr_node, state, longestdistance]\\n        ans = 0\\n        q = deque([[root, \\'A\\', 0]])\\n        while (len(q) != 0):\\n            top, state, dist = q[0]\\n            ans = max(ans, dist)\\n            q.popleft()\\n            if state == \\'A\\':\\n                if top.left:\\n                    q.append([top.left, \\'L\\', 1])\\n                if top.right:\\n                    q.append([top.right, \\'R\\', 1])\\n            else:\\n                if state == \\'L\\':\\n                    if top.left:\\n                        q.append([top.left, \\'L\\', 1])\\n                    if top.right:\\n                        q.append([top.right, \\'R\\', dist+1])\\n                if state == \\'R\\':\\n                    if top.left:\\n                        q.append([top.left, \\'L\\', dist+1])\\n                    if top.right:\\n                        q.append([top.right, \\'R\\', 1])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 713022,
                "title": "java-top-down-easy-clean-solution-o-n",
                "content": "We follow a top down approach. \\nWe keep track of : \\n1. The direction we came from .\\n2. The distance of zig zag path till now.  If its a LL, RR combo, we start as new and take as the distance to be zero.\\n\\n```\\n  int gl;\\n    public int longestZigZag(TreeNode root) {\\n        if(root == null || root.left == null && root.right == null)return 0;\\n        helper(root.left,0,0);\\n        helper(root.right,1,0);\\n        return gl+1;\\n    }\\n    void helper(TreeNode root,int d,int distTillNow){\\n        if(root == null)return;\\n        gl = Math.max(distTillNow,gl);\\n     \\n        helper(root.left,0,d == 0 ? 0 : distTillNow+1);\\n        helper(root.right,1,d == 1 ? 0 : distTillNow+1);\\n    }\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "We follow a top down approach. \\nWe keep track of : \\n1. The direction we came from .\\n2. The distance of zig zag path till now.  If its a LL, RR combo, we start as new and take as the distance to be zero.\\n\\n```\\n  int gl;\\n    public int longestZigZag(TreeNode root) {\\n        if(root == null || root.left == null && root.right == null)return 0;\\n        helper(root.left,0,0);\\n        helper(root.right,1,0);\\n        return gl+1;\\n    }\\n    void helper(TreeNode root,int d,int distTillNow){\\n        if(root == null)return;\\n        gl = Math.max(distTillNow,gl);\\n     \\n        helper(root.left,0,d == 0 ? 0 : distTillNow+1);\\n        helper(root.right,1,d == 1 ? 0 : distTillNow+1);\\n    }\\n\\t\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 614941,
                "title": "simple-recursion-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,int l,int r,int &ans,int cur){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            ans=max(ans,cur);\\n            return;\\n        }\\n        if(l){\\n            ans=max(ans,cur);\\n            fun(root->left,1,0,ans,1);\\n            fun(root->right,0,1,ans,cur+1);\\n        }\\n        else if(r){\\n            ans=max(ans,cur);\\n            fun(root->right,0,1,ans,1);\\n            fun(root->left,1,0,ans,cur+1);\\n        }\\n        return;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int re=0,an=0;\\n        fun(root->left,1,0,an,re+1);\\n        fun(root->right,0,1,an,re+1);\\n        return an;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,int l,int r,int &ans,int cur){\\n        if(root==NULL) return;\\n        if(root->left==NULL && root->right==NULL){\\n            ans=max(ans,cur);\\n            return;\\n        }\\n        if(l){\\n            ans=max(ans,cur);\\n            fun(root->left,1,0,ans,1);\\n            fun(root->right,0,1,ans,cur+1);\\n        }\\n        else if(r){\\n            ans=max(ans,cur);\\n            fun(root->right,0,1,ans,1);\\n            fun(root->left,1,0,ans,cur+1);\\n        }\\n        return;\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int re=0,an=0;\\n        fun(root->left,1,0,an,re+1);\\n        fun(root->right,0,1,an,re+1);\\n        return an;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531828,
                "title": "java-dfs-keep-a-parameter-for-direction",
                "content": "```\\nclass Solution {\\n    static int max = 0;\\n    public static void dfs(TreeNode root, int prev, int curr) {\\n        max = Math.max(max, curr);\\n        if(root == null) return;\\n        if(prev == 1) {\\n            dfs(root.left, -1, curr + 1);\\n            dfs(root.right, 1, 0);\\n            return;\\n        } else if(prev == 0) {\\n            dfs(root.left, -1, 0);\\n            dfs(root.right, 1, 0);\\n            return;\\n        } else {\\n            dfs(root.left, -1, 0);\\n            dfs(root.right, 1, curr + 1);\\n            return;\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        max = 0;\\n        dfs(root, 0, 0);\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    static int max = 0;\\n    public static void dfs(TreeNode root, int prev, int curr) {\\n        max = Math.max(max, curr);\\n        if(root == null) return;\\n        if(prev == 1) {\\n            dfs(root.left, -1, curr + 1);\\n            dfs(root.right, 1, 0);\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 531806,
                "title": "c-recursion",
                "content": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int zz(TreeNode* root, bool dir) {\\n        if (!root) return -1;\\n        return 1 + (dir ? zz(root->left, !dir) : zz(root->right, !dir));\\n    }\\n    \\n    int longestZigZag(TreeNode* root, int mark=0) {\\n        if (!root) return 0;\\n\\t\\t// we only need to go both left and right in the first step\\n\\t\\t// if we go to left, we ignore the right branch of the left node since it is already checked in the previous zig-zag\\n\\t\\t// if we go to right, we ignore the left branch of the right node since it is already checked in the previous zig-zag\\n        return  max(max(mark >= 0 ? zz(root, true) : 0, mark <= 0 ? zz(root, false) : 0),\\n                    max(longestZigZag(root->left, 1), longestZigZag(root->right, -1)));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int zz(TreeNode* root, bool dir) {\\n        if (!root) return -1;\\n        return 1 + (dir ? zz(root->left, !dir) : zz(root->right, !dir));\\n    }\\n    \\n    int longestZigZag(TreeNode* root, int mark=0) {\\n        if (!root) return 0;\\n\\t\\t// we only need to go both left and right in the first step\\n\\t\\t// if we go to left, we ignore the right branch of the left node since it is already checked in the previous zig-zag\\n\\t\\t// if we go to right, we ignore the left branch of the right node since it is already checked in the previous zig-zag\\n        return  max(max(mark >= 0 ? zz(root, true) : 0, mark <= 0 ? zz(root, false) : 0),\\n                    max(longestZigZag(root->left, 1), longestZigZag(root->right, -1)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058328,
                "title": "c-beats-99-simple-recursion",
                "content": "# Intuition\\nAt each Node in the tree, you have the option to continue the pattern and go right/left accordingly or start a new path with length 1 to the opposing direction.\\n\\n# Approach\\n- The `length` argument is passed by value, and at any point in the recursion stack will contain the current maximum length of zigzag pattern.\\n- We don\\'t need to compare the recursive call answers, so just the maximum `length` at any point contains the answer.\\n- We need to start the recursion call from both left and right at the root.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n): All nodes are visited once as the recursive call structure is unique.\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    int ans = -1;\\n    // 0 is left, 1 is right\\n    void _getLongestPath(TreeNode* curr, int direction, int length) {\\n        if(!curr) return;\\n        if(direction == 0) {\\n            _getLongestPath(curr->right, 1, length+1);\\n            _getLongestPath(curr->left, 0, 1);\\n        }\\n        else {\\n            _getLongestPath(curr->left, 0, length+1);\\n            _getLongestPath(curr->right, 1, 1);\\n        }\\n        ans = max(ans, length);\\n    }\\n\\n\\n    int longestZigZag(TreeNode* root) {\\n        unordered_map<TreeNode*, int> dp;\\n        _getLongestPath(root, 0, 0);\\n        _getLongestPath(root, 1, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int ans = -1;\\n    // 0 is left, 1 is right\\n    void _getLongestPath(TreeNode* curr, int direction, int length) {\\n        if(!curr) return;\\n        if(direction == 0) {\\n            _getLongestPath(curr->right, 1, length+1);\\n            _getLongestPath(curr->left, 0, 1);\\n        }\\n        else {\\n            _getLongestPath(curr->left, 0, length+1);\\n            _getLongestPath(curr->right, 1, 1);\\n        }\\n        ans = max(ans, length);\\n    }\\n\\n\\n    int longestZigZag(TreeNode* root) {\\n        unordered_map<TreeNode*, int> dp;\\n        _getLongestPath(root, 0, 0);\\n        _getLongestPath(root, 1, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976088,
                "title": "optimized-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Definition of TreeNode: This part defines the structure of a binary tree node, including its value, left child, and right child.\\n\\n2. helper Function: This function is a recursive helper that traverses the binary tree, tracking the current zigzag length (steps) and the maximum zigzag length encountered so far (maxSum). The goLeft parameter determines whether the next move should be towards the left child (if true) or right child (if false). The base case of the recursion is when the root is nullptr, in which case the function returns.\\n\\n3. Update maxSum: Before exploring child nodes, the helper function updates maxSum with the current steps value. This is done at each node to ensure that the function keeps track of the maximum zigzag length encountered so far.\\n\\n4. Recursive Calls: Depending on the goLeft value, the function calls itself recursively for the left and right children. If moving left, it increments steps and moves to the right child, and vice versa if moving right. This alternation helps keep track of zigzag paths.\\n\\n5. longestZigZag Function: This function initializes the maxSum variable to -1 (to handle the case where there\\'s no zigzag path), and then it calls the helper function with the root of the binary tree, starting with a steps value of 0, and sets goLeft to true. It returns the final maxSum value.\\n\\n5. Null Checks: Your code includes proper null checks to handle cases where the input root is null, as well as within the recursive helper function to avoid accessing the properties of a null node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,int steps,int& maxSum,bool goLeft) {\\n        if (root == nullptr) {\\n            return; // Null check to handle base case\\n        }\\n        \\n        maxSum = max(maxSum,steps);\\n\\n        if(goLeft == true) {\\n            helper(root->left,steps+1,maxSum,false);\\n\\n            helper(root->right,1,maxSum,true);\\n        }\\n\\n        else {\\n            helper(root->left,1,maxSum,false);\\n\\n            helper(root->right,steps+1,maxSum,true);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        int maxSum = -1;\\n        if(root == NULL)\\n            return 0;\\n\\n        bool goLeft = true;\\n\\n        helper(root,0,maxSum,goLeft);\\n\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void helper(TreeNode* root,int steps,int& maxSum,bool goLeft) {\\n        if (root == nullptr) {\\n            return; // Null check to handle base case\\n        }\\n        \\n        maxSum = max(maxSum,steps);\\n\\n        if(goLeft == true) {\\n            helper(root->left,steps+1,maxSum,false);\\n\\n            helper(root->right,1,maxSum,true);\\n        }\\n\\n        else {\\n            helper(root->left,1,maxSum,false);\\n\\n            helper(root->right,steps+1,maxSum,true);\\n        }\\n    }\\n\\n    int longestZigZag(TreeNode* root) {\\n        int maxSum = -1;\\n        if(root == NULL)\\n            return 0;\\n\\n        bool goLeft = true;\\n\\n        helper(root,0,maxSum,goLeft);\\n\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954439,
                "title": "simple-traversal-o-n-with-java",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        foo(root.left,false,1);\\n        foo(root.right,true,1);\\n        return max;\\n    }\\n    private void foo(TreeNode node, boolean isRight, int counter){\\n        if(node==null){\\n            return;\\n        }\\n        max = Math.max(max,counter);\\n        foo(node.left, false, isRight ? counter + 1 : 1);\\n        foo(node.right, true, !isRight ? counter + 1 : 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        foo(root.left,false,1);\\n        foo(root.right,true,1);\\n        return max;\\n    }\\n    private void foo(TreeNode node, boolean isRight, int counter){\\n        if(node==null){\\n            return;\\n        }\\n        max = Math.max(max,counter);\\n        foo(node.left, false, isRight ? counter + 1 : 1);\\n        foo(node.right, true, !isRight ? counter + 1 : 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710322,
                "title": "java-short-and-sweet-beats-99",
                "content": "```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        int l = root.left == null ? 0 : lzz(root.left, 1, false);\\n        int r = root.right == null ? 0 : lzz(root.right, 1, true);\\n        return Math.max(l, r);\\n    }\\n\\n    public int lzz(TreeNode n, int len, boolean parentLeft) {\\n        int l = n.left == null ? len : lzz(n.left, parentLeft ? len + 1 : 1, false);\\n        int r = n.right == null ? len : lzz(n.right, parentLeft ? 1 : len + 1, true);\\n        return Math.max(l, r);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n        int l = root.left == null ? 0 : lzz(root.left, 1, false);\\n        int r = root.right == null ? 0 : lzz(root.right, 1, true);\\n        return Math.max(l, r);\\n    }\\n\\n    public int lzz(TreeNode n, int len, boolean parentLeft) {\\n        int l = n.left == null ? len : lzz(n.left, parentLeft ? len + 1 : 1, false);\\n        int r = n.right == null ? len : lzz(n.right, parentLeft ? 1 : len + 1, true);\\n        return Math.max(l, r);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3641666,
                "title": "write-your-own-its-simple-try-harder",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ndfs\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ndfs\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(2^nodes)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nodes)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* node,char state,int ct){\\n        cout<<endl<<state<<endl;\\n        int t;\\n        if(node->left){\\n            if(state==\\'r\\' || state==\\'o\\'){\\n                t=ct+1;\\n                // cout<<node->left->val<<state;\\n                ans=max(t,ans);\\n            }\\n            else{\\n                // cout<<endl;\\n                t=1;\\n            }\\n            dfs(node->left,\\'l\\',t);\\n        }\\n        if(node->right){\\n            if(state==\\'l\\' || state==\\'o\\'){\\n                t=ct+1;\\n                // cout<<node->right->val<<state;\\n                ans=max(t,ans);\\n            }\\n            else{\\n                // cout<<endl;\\n                t=1;\\n            }\\n            dfs(node->right,\\'r\\',t);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        dfs(root,\\'o\\',0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void dfs(TreeNode* node,char state,int ct){\\n        cout<<endl<<state<<endl;\\n        int t;\\n        if(node->left){\\n            if(state==\\'r\\' || state==\\'o\\'){\\n                t=ct+1;\\n                // cout<<node->left->val<<state;\\n                ans=max(t,ans);\\n            }\\n            else{\\n                // cout<<endl;\\n                t=1;\\n            }\\n            dfs(node->left,\\'l\\',t);\\n        }\\n        if(node->right){\\n            if(state==\\'l\\' || state==\\'o\\'){\\n                t=ct+1;\\n                // cout<<node->right->val<<state;\\n                ans=max(t,ans);\\n            }\\n            else{\\n                // cout<<endl;\\n                t=1;\\n            }\\n            dfs(node->right,\\'r\\',t);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        dfs(root,\\'o\\',0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3615829,
                "title": "c-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root)\\n    {\\n        Queue<(TreeNode, string, int)> q = new Queue<(TreeNode, string, int)>();\\n        q.Enqueue((root, \"\", 0));\\n        int ans = 0;\\n\\n        while (q.Count > 0)\\n        {\\n            (TreeNode u, string prevDir, int cnt) = q.Dequeue();\\n            ans = Math.Max(ans, cnt);\\n\\n            if (u.left != null)\\n            {\\n                if (prevDir == \"r\")\\n                    q.Enqueue((u.left, \"l\", cnt + 1));\\n                else\\n                    q.Enqueue((u.left, \"l\", 1));\\n            }\\n\\n            if (u.right != null)\\n            {\\n                if (prevDir == \"l\")\\n                    q.Enqueue((u.right, \"r\", cnt + 1));\\n                else\\n                    q.Enqueue((u.right, \"r\", 1));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root)\\n    {\\n        Queue<(TreeNode, string, int)> q = new Queue<(TreeNode, string, int)>();\\n        q.Enqueue((root, \"\", 0));\\n        int ans = 0;\\n\\n        while (q.Count > 0)\\n        {\\n            (TreeNode u, string prevDir, int cnt) = q.Dequeue();\\n            ans = Math.Max(ans, cnt);\\n\\n            if (u.left != null)\\n            {\\n                if (prevDir == \"r\")\\n                    q.Enqueue((u.left, \"l\", cnt + 1));\\n                else\\n                    q.Enqueue((u.left, \"l\", 1));\\n            }\\n\\n            if (u.right != null)\\n            {\\n                if (prevDir == \"l\")\\n                    q.Enqueue((u.right, \"r\", cnt + 1));\\n                else\\n                    q.Enqueue((u.right, \"r\", 1));\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581544,
                "title": "python-efficient-and-easy-depth-first-search-dfs-solution",
                "content": "# Approach\\nTo solve this problem, we can use the DFS (Depth-First Search) approach while keeping track of the previous traversal. When the previous traversal goes to the left, the next traversal to the right can make use of the previous height. However, if the next traversal goes to the left again, its height will start from 0 because it no longer follows the zigzag pattern. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def dfs(self, tree, h=0, state=None):\\n        if tree is None:\\n            self.max_h = max(h, self.max_h)\\n            return\\n        \\n        self.dfs(tree.left, h+1 if state==\"right\" else 0, \"left\")\\n        self.dfs(tree.right, h+1 if state==\"left\" else 0, \"right\")\\n        \\n\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.max_h = 0\\n        self.dfs(root)\\n        return self.max_h\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n    def dfs(self, tree, h=0, state=None):\\n        if tree is None:\\n            self.max_h = max(h, self.max_h)\\n            return\\n        \\n        self.dfs(tree.left, h+1 if state==\"right\" else 0, \"left\")\\n        self.dfs(tree.right, h+1 if state==\"left\" else 0, \"right\")\\n        \\n\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.max_h = 0\\n        self.dfs(root)\\n        return self.max_h\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545526,
                "title": "c-hard-qn-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxStep=0;\\n    \\n    void helper(TreeNode* root, bool goLeft, int step){\\n        if(root==NULL){ return; }\\n        maxStep= max(maxStep, step);\\n        \\n        if(goLeft==true){ // I want to go left\\n            helper(root->left, false, step+1); // I went left, so step+1, now in the next step, I want to go right, so goLeft= false \\n            helper(root->right, true, 1); // I went right, step reseted\\n        }\\n        else if(goLeft==false){ // I want to go right\\n            helper(root->right, true, step+1); // I went right, so step+1, now In next step, I want to go left, so goLeft= true\\n            helper(root->left, false, 1); // I went left, step reseted\\n        }\\n        return;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        maxStep=0;\\n        helper(root, true, 0); // from root, we will move to left, and we have taken 0 steps till now\\n        helper(root, false, 0); // from root, we will move to right, and we have taken 0 steps till now\\n        return maxStep;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxStep=0;\\n    \\n    void helper(TreeNode* root, bool goLeft, int step){\\n        if(root==NULL){ return; }\\n        maxStep= max(maxStep, step);\\n        \\n        if(goLeft==true){ // I want to go left\\n            helper(root->left, false, step+1); // I went left, so step+1, now in the next step, I want to go right, so goLeft= false \\n            helper(root->right, true, 1); // I went right, step reseted\\n        }\\n        else if(goLeft==false){ // I want to go right\\n            helper(root->right, true, step+1); // I went right, so step+1, now In next step, I want to go left, so goLeft= true\\n            helper(root->left, false, 1); // I went left, step reseted\\n        }\\n        return;\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        maxStep=0;\\n        helper(root, true, 0); // from root, we will move to left, and we have taken 0 steps till now\\n        helper(root, false, 0); // from root, we will move to right, and we have taken 0 steps till now\\n        return maxStep;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442431,
                "title": "binbin-is-very-close-to-cry-when-solving-this-problem-wuwuwuwu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        if root.left is None and root.right is None:\\n            return 0\\n        \\n        self.maxV = 1\\n        def choosepath(node,d,n):\\n            \\n            self.maxV = max(n, self.maxV) \\n            if d == 1:\\n                if node.left is not None:\\n                    choosepath(node.left,-1,n+1)\\n                if node.right is not None:\\n                    choosepath(node.right,1,1)\\n            if d == -1:\\n                if node.right is not None:\\n                    choosepath(node.right,1,n+1)\\n                if node.left is not None:\\n                    choosepath(node.left,-1,1)\\n            \\n        \\n        choosepath(root,1,0)\\n        return self.maxV\\n      \\n       \\n\\n\\n            \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        if root.left is None and root.right is None:\\n            return 0\\n        \\n        self.maxV = 1\\n        def choosepath(node,d,n):\\n            \\n            self.maxV = max(n, self.maxV) \\n            if d == 1:\\n                if node.left is not None:\\n                    choosepath(node.left,-1,n+1)\\n                if node.right is not None:\\n                    choosepath(node.right,1,1)\\n            if d == -1:\\n                if node.right is not None:\\n                    choosepath(node.right,1,n+1)\\n                if node.left is not None:\\n                    choosepath(node.left,-1,1)\\n            \\n        \\n        choosepath(root,1,0)\\n        return self.maxV\\n      \\n       \\n\\n\\n            \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442310,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\\n *   var value: Int = _value\\n *   var left: TreeNode = _left\\n *   var right: TreeNode = _right\\n * }\\n */\\nobject Solution {\\n    def longestZigZag(root: TreeNode): Int = {\\n      def dfs(root: TreeNode, direction: Int, curDepth: Int, maxDepth: Int):Int = {\\n        if (root == null) {\\n          (maxDepth max curDepth) - 1\\n        } else  if (direction == 0) {\\n          dfs(root.left, 1, curDepth + 1, maxDepth max (curDepth + 1)) max dfs(root.right, 0, 1, maxDepth max (curDepth + 1))\\n        } else  {\\n          dfs(root.right, 0, curDepth + 1, maxDepth max (curDepth + 1)) max dfs(root.left, 1, 1, maxDepth max (curDepth + 1))\\n        }\\n      }\\n      dfs(root, 0, 0, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode(_value: Int = 0, _left: TreeNode = null, _right: TreeNode = null) {\\n *   var value: Int = _value\\n *   var left: TreeNode = _left\\n *   var right: TreeNode = _right\\n * }\\n */\\nobject Solution {\\n    def longestZigZag(root: TreeNode): Int = {\\n      def dfs(root: TreeNode, direction: Int, curDepth: Int, maxDepth: Int):Int = {\\n        if (root == null) {\\n          (maxDepth max curDepth) - 1\\n        } else  if (direction == 0) {\\n          dfs(root.left, 1, curDepth + 1, maxDepth max (curDepth + 1)) max dfs(root.right, 0, 1, maxDepth max (curDepth + 1))\\n        } else  {\\n          dfs(root.right, 0, curDepth + 1, maxDepth max (curDepth + 1)) max dfs(root.left, 1, 1, maxDepth max (curDepth + 1))\\n        }\\n      }\\n      dfs(root, 0, 0, 0)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439359,
                "title": "map-level-order-traversal-o-n-time-and-space",
                "content": "> # ***Mastering the art of problem-solving - give my LeetCode solution an upvote if you agree!***\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHi there! In this solution, I will explain the code that you have given me. The code is a solution to the problem of finding the longest zigzag path in a binary tree. A zigzag path is a sequence of nodes such that each node is either the left child or the right child of its parent, and the direction alternates between left and right. For example, in the following tree, the longest zigzag path is [1, 3, 2, 6, 7], which has length 4.\\n\\n   ```\\n    1\\n   / \\\\\\n  2   3\\n / \\\\ / \\\\\\n4  6 5  7\\n```\\n\\nThe code uses a map to store the length of the longest zigzag path ending at each node and each direction (left or right). The key of the map is a pair of a node pointer and a boolean value, where the boolean value indicates whether the last move was to the left (true) or to the right (false). The value of the map is an integer representing the length of the zigzag path.\\n\\nThe code also uses a recursive function called traverse to update the map for each node and each direction. The function takes two parameters: a node pointer and a boolean value indicating whether the current move is to the left or to the right. The function does the following:\\n\\n- If the node is null, return.\\n- If the current move is to the left, call traverse on the left child with false as the next move, and update the map for the current node and direction by adding one to the map value for the left child and false.\\n- If the current move is to the right, call traverse on the right child with true as the next move, and update the map for the current node and direction by adding one to the map value for the right child and true.\\n\\nThe code also uses a queue to perform a level order traversal of the tree. For each node in the queue, it checks if it has been visited by looking up in the map. If not, it calls traverse on that node with both directions (true and false). Then it adds its left and right children to the queue if they are not null.\\n\\nFinally, the code iterates over all the entries in the map and finds the maximum value among them. This is the length of the longest zigzag path in the tree. It subtracts one from this value because it counts from zero.\\n\\nI hope this solution helped you understand how this code works. If you have any questions or feedback, please leave a comment below. Thank you for reading!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    map<pair<TreeNode*,bool>,int> map;\\n    void traverse(TreeNode* root,bool isLeft){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(isLeft){\\n            traverse(root->left,false);\\n            map[{root,true}]=map[{root->left,false}]+1;\\n        }\\n        else{\\n            traverse(root->right,true);\\n            map[{root,false}]=map[{root->right,true}]+1;\\n        }\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        ios_base::sync_with_stdio(false);\\n        int ans = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* temp = q.front();\\n            q.pop();\\n            if(map.find({temp,false})==map.end()){\\n                traverse(temp,false);\\n            }\\n            if(map.find({temp,true})==map.end()){\\n                traverse(temp,true);\\n            }\\n            if(temp->left){\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                q.push(temp->right);\\n            }\\n        }\\n        for(auto it:map){\\n            ans=max(ans,it.second);\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    1\\n   / \\\\\\n  2   3\\n / \\\\ / \\\\\\n4  6 5  7\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    map<pair<TreeNode*,bool>,int> map;\\n    void traverse(TreeNode* root,bool isLeft){\\n        if(root==NULL){\\n            return;\\n        }\\n        if(isLeft){\\n            traverse(root->left,false);\\n            map[{root,true}]=map[{root->left,false}]+1;\\n        }\\n        else{\\n            traverse(root->right,true);\\n            map[{root,false}]=map[{root->right,true}]+1;\\n        }\\n    }\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        ios_base::sync_with_stdio(false);\\n        int ans = 0;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty()){\\n            TreeNode* temp = q.front();\\n            q.pop();\\n            if(map.find({temp,false})==map.end()){\\n                traverse(temp,false);\\n            }\\n            if(map.find({temp,true})==map.end()){\\n                traverse(temp,true);\\n            }\\n            if(temp->left){\\n                q.push(temp->left);\\n            }\\n            if(temp->right){\\n                q.push(temp->right);\\n            }\\n        }\\n        for(auto it:map){\\n            ans=max(ans,it.second);\\n        }\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437219,
                "title": "easy-approach-beats-95-of-python-users",
                "content": "\\n**HELLO GUYS **\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.a=0\\n        def fun(root,i,pre):\\n            if root==None:\\n                return\\n            if pre==1:\\n                fun(root.left,1,1)\\n                fun(root.right,i+1,2)\\n            elif pre==2:\\n                fun(root.left,i+1,1)\\n                fun(root.right,1,2)\\n            else:\\n                fun(root.left,i+1,1)\\n                fun(root.right,i+1,2)\\n            if self.a<i:\\n                self.a=i\\n        fun(root,0,0)\\n        return self.a\\n```\\n# **Please vote up if you like the solution**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def longestZigZag(self, root: Optional[TreeNode]) -> int:\\n        self.a=0\\n        def fun(root,i,pre):\\n            if root==None:\\n                return\\n            if pre==1:\\n                fun(root.left,1,1)\\n                fun(root.right,i+1,2)\\n            elif pre==2:\\n                fun(root.left,i+1,1)\\n                fun(root.right,1,2)\\n            else:\\n                fun(root.left,i+1,1)\\n                fun(root.right,i+1,2)\\n            if self.a<i:\\n                self.a=i\\n        fun(root,0,0)\\n        return self.a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436871,
                "title": "easiest-java-solution-using-common-sense-and-memoization",
                "content": "# Intuition\\nCommon sense and Tricky memoization\\n\\n# Approach\\nEasy Recursion and Memoization!\\n\\n# Complexity\\n- Time complexity:\\nlinear time\\n\\n- Space complexity:\\nO(n) where n is the size of HashMap\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max_m=Integer.MIN_VALUE;\\n    public int helper(boolean left, boolean right, TreeNode root,int max,HashMap<TreeNode,Integer> dp)\\n    {\\n        if(root==null)\\n\\t        return 0;\\n\\t        if(dp.containsKey(root))\\n\\t        \\treturn dp.get(root);\\n\\t        if(left==true && root.left!=null)\\n\\t        helper(false,true,root.left,max+1,dp);\\n\\t        if(right==true && root.right!=null)\\n\\t        helper(true,false,root.right,max+1,dp);\\n\\t        max_m=Math.max(max_m,max);\\n\\t        dp.put(root, max_m);\\n\\t        max=0;\\n\\t        helper(false,true,root.left,1,dp);\\n\\t        helper(true,false,root.right,1,dp);\\n\\t        return max_m;\\n    }\\n    public int longestZigZag(TreeNode root) {\\n      if(root.left==null && root.right==null)\\n\\t        return 0;\\n\\t        HashMap<TreeNode, Integer> dp=new HashMap<>();\\n\\t        return Math.max(helper(false,true,root.left,1,dp),helper(true,false,root.right,1,dp));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max_m=Integer.MIN_VALUE;\\n    public int helper(boolean left, boolean right, TreeNode root,int max,HashMap<TreeNode,Integer> dp)\\n    {\\n        if(root==null)\\n\\t        return 0;\\n\\t        if(dp.containsKey(root))\\n\\t        \\treturn dp.get(root);\\n\\t        if(left==true && root.left!=null)\\n\\t        helper(false,true,root.left,max+1,dp);\\n\\t        if(right==true && root.right!=null)\\n\\t        helper(true,false,root.right,max+1,dp);\\n\\t        max_m=Math.max(max_m,max);\\n\\t        dp.put(root, max_m);\\n\\t        max=0;\\n\\t        helper(false,true,root.left,1,dp);\\n\\t        helper(true,false,root.right,1,dp);\\n\\t        return max_m;\\n    }\\n    public int longestZigZag(TreeNode root) {\\n      if(root.left==null && root.right==null)\\n\\t        return 0;\\n\\t        HashMap<TreeNode, Integer> dp=new HashMap<>();\\n\\t        return Math.max(helper(false,true,root.left,1,dp),helper(true,false,root.right,1,dp));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436785,
                "title": "have-track-of-prev-direction-c-easy-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    void dfs(TreeNode*root, char prev, int cnt)\\n    {\\n        if(!root) return;\\n        ans=max(ans,cnt);\\n        \\n\\t\\t//root node condition as there is no prev direction\\n        if(prev==\\'?\\')   \\n        {\\n            dfs(root->left,\\'l\\',1);\\n            dfs(root->right,\\'r\\',1);\\n        }                           \\n        else if(prev==\\'l\\')  //if we came to current node from left edge\\n        {\\n            dfs(root->left,\\'l\\',1);\\n            dfs(root->right,\\'r\\',cnt+1);\\n        }\\n        else if(prev==\\'r\\')  //if we came to current node by right edge\\n        {\\n            dfs(root->left,\\'l\\',cnt+1);\\n            dfs(root->right,\\'r\\',1);\\n        }\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        dfs(root,\\'?\\',0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n\\n    void dfs(TreeNode*root, char prev, int cnt)\\n    {\\n        if(!root) return;\\n        ans=max(ans,cnt);\\n        \\n\\t\\t//root node condition as there is no prev direction\\n        if(prev==\\'?\\')   \\n        {\\n            dfs(root->left,\\'l\\',1);\\n            dfs(root->right,\\'r\\',1);\\n        }                           \\n        else if(prev==\\'l\\')  //if we came to current node from left edge\\n        {\\n            dfs(root->left,\\'l\\',1);\\n            dfs(root->right,\\'r\\',cnt+1);\\n        }\\n        else if(prev==\\'r\\')  //if we came to current node by right edge\\n        {\\n            dfs(root->left,\\'l\\',cnt+1);\\n            dfs(root->right,\\'r\\',1);\\n        }\\n    }\\n    \\n    int longestZigZag(TreeNode* root) {\\n        dfs(root,\\'?\\',0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436290,
                "title": "simple-c-solution-with-explanation",
                "content": "# Intuition\\n\\n# Approach\\nWe keep the state of child that it\\'s created from left or Right edge. Also, keep the total of number edges upto current node that follows the zigzag rules.\\n\\nSolved using dfs.\\nif comes from left but going to right add +1 with existing value \\nor call with 0 as zigzag len\\n\\nif comes from right but going to left add +1 with existing value\\nor call with 0 as zigzat len\\n\\n# Complexity\\n- Time complexity:\\nO(n).\\n**Explanation**\\nHere n is the total number of node in the tree. We will visit each node exactly one time.\\n\\n- Space complexity:\\n- O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\nprivate:\\n    int dfs(TreeNode* cur, int state = 0, int tot = 0) {\\n        if(cur==nullptr) return (tot - 1);\\n\\n        int left = dfs(cur->left, -1, 1 + ((state!=-1)?tot:0));\\n        int right = dfs(cur->right, +1, 1 + ((state!=1)?tot:0));    \\n\\n        return max(left, right);\\n    }\\n\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        return dfs(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n\\nprivate:\\n    int dfs(TreeNode* cur, int state = 0, int tot = 0) {\\n        if(cur==nullptr) return (tot - 1);\\n\\n        int left = dfs(cur->left, -1, 1 + ((state!=-1)?tot:0));\\n        int right = dfs(cur->right, +1, 1 + ((state!=1)?tot:0));    \\n\\n        return max(left, right);\\n    }\\n\\npublic:\\n    int longestZigZag(TreeNode* root) {\\n        return dfs(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436266,
                "title": "90-faster-java-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    // create maxi to compare with every len\\n    public int maxi = 0;\\n    public void helper(TreeNode root,int LorR, int len){\\n        if(root == null) return; // if we reach end of leaf node then simply return\\n        maxi = Math.max(len,maxi); // compare with maxi and len, which evere greater just store it in maxi\\n        if(LorR == 0){ // if previous node was left node, ie LorR == 0\\n            // here we have two choices \\n            helper(root.right,1,len+1); // 1. if previous was left then next will be right node, \\n            // then increase len & LorR == right == 1\\n            helper(root.left,0,1); // 2. for next node will left node, then it will node follow zig zag, then change len = 1\\n        } else{ // ifprevious node was right node ie LorR == 1\\n            helper(root.left,0,len+1);\\n            helper(root.right,1,1);\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        // LorR == 0, for left & at starting len = 1\\n        helper(root.left,0,1); // call for left part\\n        // LorR == 1, for right\\n        helper(root.right,1,1); // call fpr right part\\n        return maxi;\\n    }\\n}\\n```\\n![478xve.jpg](https://assets.leetcode.com/users/images/12f5b4ad-1d51-42a6-a0b9-0048d2afd02a_1681938100.5555906.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // create maxi to compare with every len\\n    public int maxi = 0;\\n    public void helper(TreeNode root,int LorR, int len){\\n        if(root == null) return; // if we reach end of leaf node then simply return\\n        maxi = Math.max(len,maxi); // compare with maxi and len, which evere greater just store it in maxi\\n        if(LorR == 0){ // if previous node was left node, ie LorR == 0\\n            // here we have two choices \\n            helper(root.right,1,len+1); // 1. if previous was left then next will be right node, \\n            // then increase len & LorR == right == 1\\n            helper(root.left,0,1); // 2. for next node will left node, then it will node follow zig zag, then change len = 1\\n        } else{ // ifprevious node was right node ie LorR == 1\\n            helper(root.left,0,len+1);\\n            helper(root.right,1,1);\\n        }\\n    }\\n    public int longestZigZag(TreeNode root) {\\n        // LorR == 0, for left & at starting len = 1\\n        helper(root.left,0,1); // call for left part\\n        // LorR == 1, for right\\n        helper(root.right,1,1); // call fpr right part\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436142,
                "title": "c-easy-and-readable-solution-faster-than-75-less-than-50",
                "content": "![image.png](https://assets.leetcode.com/users/images/b391f1ae-9338-4294-bf54-93e5541b46b0_1681934251.1040218.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root) {\\n        int left = Helper (root, true, 0);\\n        int right = Helper (root, false, 0);\\n        int ans = Math.Max(left, right);\\n        return ans - 1;\\n    }\\n\\n    int Helper (TreeNode node, bool isLeft, int length)\\n    {\\n        if(node == null)\\n            return length;\\n        int current = isLeft ?  Helper(node.right, !isLeft, length + 1) : Helper(node.left, !isLeft, length + 1);\\n        int alternate = isLeft ? Helper(node.left, isLeft, 1) : Helper(node.right, isLeft, 1);\\n        int maxLength = Math.Max(current, alternate);\\n        return maxLength;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int LongestZigZag(TreeNode root) {\\n        int left = Helper (root, true, 0);\\n        int right = Helper (root, false, 0);\\n        int ans = Math.Max(left, right);\\n        return ans - 1;\\n    }\\n\\n    int Helper (TreeNode node, bool isLeft, int length)\\n    {\\n        if(node == null)\\n            return length;\\n        int current = isLeft ?  Helper(node.right, !isLeft, length + 1) : Helper(node.left, !isLeft, length + 1);\\n        int alternate = isLeft ? Helper(node.left, isLeft, 1) : Helper(node.right, isLeft, 1);\\n        int maxLength = Math.Max(current, alternate);\\n        return maxLength;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435870,
                "title": "java-solution-with-o-n-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne way is to find all the zig-zag path and find the longest one. But in this approach the time complexity will O(n^2) which is not so good.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo optimize the algorithm for traversing a binary tree, we aim to reduce the time complexity from O(n^2) to O(n) or O(nlogn). This means that we need to traverse the tree only once. To achieve this, we should keep track of the longest path seen so far at every step of the traversal. This will allow us to determine the longest path in the tree without having to revisit any nodes, resulting in a more efficient solution with a lower time complexity. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) : Because we go on every note exactly once from top to bottom.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(h) : As we do dfs , so the recursive stack depth can be max O(depth) of nodes of tree.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n //dir 0 = L , 1 == R\\nclass Solution {\\npublic int maxLength=0;\\npublic void zigZagPath(TreeNode root,String dir,int currLength){\\nif(root==null) return;\\nmaxLength=Math.max(maxLength,currLength);\\nif(dir==\"R\"){\\n    zigZagPath(root.left,\"L\",currLength+1);\\n    zigZagPath(root.right,\"R\",1);\\n}\\nelse{\\n    zigZagPath(root.right,\"R\",currLength+1);\\n    zigZagPath(root.left,\"L\",1);\\n}\\n}\\npublic int longestZigZag(TreeNode root) {\\n    zigZagPath(root,\"L\",0);\\n    zigZagPath(root,\"R\",0); \\n    return maxLength;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n //dir 0 = L , 1 == R\\nclass Solution {\\npublic int maxLength=0;\\npublic void zigZagPath(TreeNode root,String dir,int currLength){\\nif(root==null) return;\\nmaxLength=Math.max(maxLength,currLength);\\nif(dir==\"R\"){\\n    zigZagPath(root.left,\"L\",currLength+1);\\n    zigZagPath(root.right,\"R\",1);\\n}\\nelse{\\n    zigZagPath(root.right,\"R\",currLength+1);\\n    zigZagPath(root.left,\"L\",1);\\n}\\n}\\npublic int longestZigZag(TreeNode root) {\\n    zigZagPath(root,\"L\",0);\\n    zigZagPath(root,\"R\",0); \\n    return maxLength;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435744,
                "title": "c-accepted-no-dp-a-easy-approach-using-dfs",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// Direction = true   means we move to left node\\n//Direction = false   means we move to right node\\n//depth  = when we go one side down we call the function again and increase the depth by one\\n//maxdepth = we track the max depth\\nint maxdepth=0;\\n   void solve(TreeNode* root,bool Direction,int depth){\\n     if(root==NULL){\\n         return;\\n         //no icrease in depth\\n     }\\n     if(Direction){ //Direction = true   means we move to left node\\n       solve(root->left,false,depth+1);//and increase the depth by 1 and for zig zig we set the direction as false\\n          solve(root->right,true,1);//if suppose we we are not going left(as zig zig)so we put depath as 1 and start a new chain \\n     }\\n     else{\\n        solve(root->right,true,depth+1);//Direction = true   means we move to left node//and increase the depth by 1 and for zig zig we set the direction as false\\n        solve(root->left,false,1);//if suppose we we are not going right(as zig zig)so we put depath as 1 and start a new chain \\n     }\\n     maxdepth =max(maxdepth,depth);\\n   }\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,true,0);\\n         solve(root,true,0);\\n         return maxdepth;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n// Direction = true   means we move to left node\\n//Direction = false   means we move to right node\\n//depth  = when we go one side down we call the function again and increase the depth by one\\n//maxdepth = we track the max depth\\nint maxdepth=0;\\n   void solve(TreeNode* root,bool Direction,int depth){\\n     if(root==NULL){\\n         return;\\n         //no icrease in depth\\n     }\\n     if(Direction){ //Direction = true   means we move to left node\\n       solve(root->left,false,depth+1);//and increase the depth by 1 and for zig zig we set the direction as false\\n          solve(root->right,true,1);//if suppose we we are not going left(as zig zig)so we put depath as 1 and start a new chain \\n     }\\n     else{\\n        solve(root->right,true,depth+1);//Direction = true   means we move to left node//and increase the depth by 1 and for zig zig we set the direction as false\\n        solve(root->left,false,1);//if suppose we we are not going right(as zig zig)so we put depath as 1 and start a new chain \\n     }\\n     maxdepth =max(maxdepth,depth);\\n   }\\n    int longestZigZag(TreeNode* root) {\\n        solve(root,true,0);\\n         solve(root,true,0);\\n         return maxdepth;\\n    }\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435575,
                "title": "easy-java-dfs-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition is to solve the question using dfs keeping track of the path being zigzag or straight.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n) where n is the number of TreeNodes\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void dfs(TreeNode curr, String path, int count){\\n        if(curr == null){\\n            return;\\n        }\\n\\n\\n        if(count > max){\\n            max = count;\\n        }\\n\\n\\n        if(path == \"right\" || path == \"\"){\\n            dfs(curr.left, \"left\", count+1);\\n        }else{\\n            dfs(curr.left, \"left\", 1);\\n        }\\n\\n\\n        if(path == \"left\" || path == \"\"){\\n            dfs(curr.right, \"right\", count + 1);\\n        }else{\\n            dfs(curr.right, \"right\", 1);\\n        }\\n        \\n    }\\n\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        String path = \"\";\\n        dfs(root, path, 0);\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void dfs(TreeNode curr, String path, int count){\\n        if(curr == null){\\n            return;\\n        }\\n\\n\\n        if(count > max){\\n            max = count;\\n        }\\n\\n\\n        if(path == \"right\" || path == \"\"){\\n            dfs(curr.left, \"left\", count+1);\\n        }else{\\n            dfs(curr.left, \"left\", 1);\\n        }\\n\\n\\n        if(path == \"left\" || path == \"\"){\\n            dfs(curr.right, \"right\", count + 1);\\n        }else{\\n            dfs(curr.right, \"right\", 1);\\n        }\\n        \\n    }\\n\\n    int max = 0;\\n    public int longestZigZag(TreeNode root) {\\n        String path = \"\";\\n        dfs(root, path, 0);\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435548,
                "title": "c-recursion-easy-approach",
                "content": "Here is my c++ code for thi problem.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void chk(TreeNode* root, int dir, int cnt){\\n        if(!root){return;}\\n        ans=max(ans, cnt);\\n        if(dir){\\n            chk(root->left, 0, cnt+1);\\n            chk(root->right, 1, 1);\\n        }\\n        else{\\n            chk(root->right, 1, cnt+1);\\n            chk(root->left, 0, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root){return 0;}\\n        chk(root, 1, 0);\\n        chk(root, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    void chk(TreeNode* root, int dir, int cnt){\\n        if(!root){return;}\\n        ans=max(ans, cnt);\\n        if(dir){\\n            chk(root->left, 0, cnt+1);\\n            chk(root->right, 1, 1);\\n        }\\n        else{\\n            chk(root->right, 1, cnt+1);\\n            chk(root->left, 0, 1);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root){return 0;}\\n        chk(root, 1, 0);\\n        chk(root, 0, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435375,
                "title": "simple-recursion-approach-very-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void helper(TreeNode* root, int dis, int dir){\\n        if(!root) return ;\\n        ans = max(ans, dis);\\n        if(dir == 1){\\n            helper(root->left, dis+1, 0);\\n            helper(root->right,1,1);\\n        }\\n        else {\\n            helper(root->right, dis+1, 1);\\n            helper(root->left,1,0);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        helper(root,0,1);\\n        helper(root,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void helper(TreeNode* root, int dis, int dir){\\n        if(!root) return ;\\n        ans = max(ans, dis);\\n        if(dir == 1){\\n            helper(root->left, dis+1, 0);\\n            helper(root->right,1,1);\\n        }\\n        else {\\n            helper(root->right, dis+1, 1);\\n            helper(root->left,1,0);\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        helper(root,0,1);\\n        helper(root,0,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435346,
                "title": "best-c-solution-one-time-traverse-the-tree",
                "content": "\\n\\n# Code\\n```\\n\\n #define pi  pair<int, int>\\n #define ppi pair<int, pi>\\nclass Solution {\\npublic:\\n    ppi solve(TreeNode* root)    {\\n        if(root == NULL)    return {0, {-1, -1}};\\n        ppi l = solve(root -> left);\\n        ppi r = solve(root -> right);\\n        ppi temp;\\n        temp.second.first = l.second.second + 1;\\n        temp.second.second = r.second.first + 1;\\n        temp.first=max(max(l.first, r.first), max(temp.second.first, temp.second.second));\\n        return temp;\\n    }\\n\\n\\n    int longestZigZag(TreeNode* root) {\\n        return solve(root).first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\n #define pi  pair<int, int>\\n #define ppi pair<int, pi>\\nclass Solution {\\npublic:\\n    ppi solve(TreeNode* root)    {\\n        if(root == NULL)    return {0, {-1, -1}};\\n        ppi l = solve(root -> left);\\n        ppi r = solve(root -> right);\\n        ppi temp;\\n        temp.second.first = l.second.second + 1;\\n        temp.second.second = r.second.first + 1;\\n        temp.first=max(max(l.first, r.first), max(temp.second.first, temp.second.second));\\n        return temp;\\n    }\\n\\n\\n    int longestZigZag(TreeNode* root) {\\n        return solve(root).first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435317,
                "title": "scan-node-itself-and-left-and-right-for-thenode",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* r) {\\n        int res = 0;\\n        bool l =true;\\n        solve(r,res,l,0);\\n        solve(r,res,!l,0);\\n        return res;\\n        \\n    }\\n    \\n    void solve(TreeNode* r,int &res, bool l, int t)\\n    {\\n        if(!r)\\n            return;\\n        res = max(res, t);\\n        if(l)\\n        {\\n            solve(r->left,res,!l,t+1);\\n            solve(r->right,res,l,1);\\n        }\\n        else\\n        {\\n            solve(r->right,res,!l,t+1);\\n            solve(r->left,res,l,1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int longestZigZag(TreeNode* r) {\\n        int res = 0;\\n        bool l =true;\\n        solve(r,res,l,0);\\n        solve(r,res,!l,0);\\n        return res;\\n        \\n    }\\n    \\n    void solve(TreeNode* r,int &res, bool l, int t)\\n    {\\n        if(!r)\\n            return;\\n        res = max(res, t);\\n        if(l)\\n        {\\n            solve(r->left,res,!l,t+1);\\n            solve(r->right,res,l,1);\\n        }\\n        else\\n        {\\n            solve(r->right,res,!l,t+1);\\n            solve(r->left,res,l,1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435304,
                "title": "simple-recursive-easy-to-understand-cpp",
                "content": "# Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou are given the root of a binary tree.\\n\\nA ZigZag path for a binary tree is defined as follow:\\n\\nChoose any node in the binary tree and a direction (right or left).\\nIf the current direction is right, move to the right child of the current node; otherwise, move to the left child.\\nChange the direction from right to left or from left to right.\\nRepeat the second and third steps until you can\\'t move in the tree.\\nZigzag length is defined as the number of nodes visited - 1. (A single node has a length of 0).\\n\\nReturn the longest ZigZag path contained in that tree.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n`The solve function is a recursive helper function that calculates the zigzag length of a given subtree rooted at root. The function takes three parameters: root which is a pointer to the root node of the current subtree, isleft which is a boolean variable that indicates whether the current node is a left child or a right child of its parent, and len which is the length of the zigzag path up to the current node. If root is NULL, the function returns 0 as there is no zigzag path in that subtree.\\n\\nIn the solve function, the left and right children of the current node are recursively explored, and their respective zigzag lengths are calculated by calling solve recursively with updated parameters. The isleft parameter is used to determine the direction of the zigzag path at each node: if isleft is true, the path is going left to right, and if isleft is false, the path is going right to left. The len parameter is updated based on the direction of the zigzag path at the current node.\\n\\nOnce the zigzag lengths of the left and right children have been calculated, the solve function returns the maximum zigzag length between the left child, right child, and the current node. This is done by taking the maximum of len, lh, and rh.\\n\\nThe longestZigZag function is the main function that calculates the longest zigzag path in the binary tree. It first checks if the root is NULL and returns 0 if it is. It then calculates the zigzag lengths of the left and right children by calling solve with updated parameters. Finally, it returns the maximum zigzag length between the left child and the right child by taking the maximum of lh and rh.`\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(H) height of tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, bool isleft, int len)\\n{\\n    if(root==NULL) return 0; // If the root is NULL, return 0 as there is no zigzag path\\n\\n    int lh = solve(root->left,true, isleft?1:len+1); // Recursively calculate the zigzag length for the left child\\n    int rh = solve(root->right,false,isleft?len+1:1); // Recursively calculate the zigzag length for the right child\\n\\n    return max(len,max(lh,rh)); // Return the maximum zigzag length between the left child, right child, and the current node\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n    \\n    if(root==NULL) return 0; // If the root is NULL, return 0 as there is no zigzag path\\n\\n    int lh = solve(root->left,true,1); // Calculate the zigzag length for the left child\\n    int rh = solve(root->right,false,1); // Calculate the zigzag length for the right child\\n\\n    return max(lh,rh); // Return the maximum zigzag length between the left child and the right child\\n}\\n};\\n```\\n![PLEASE UPVOTE.jpg](https://assets.leetcode.com/users/images/2edcfb93-5a2f-4695-88af-3f8a85708fc0_1681919198.8154056.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int solve(TreeNode* root, bool isleft, int len)\\n{\\n    if(root==NULL) return 0; // If the root is NULL, return 0 as there is no zigzag path\\n\\n    int lh = solve(root->left,true, isleft?1:len+1); // Recursively calculate the zigzag length for the left child\\n    int rh = solve(root->right,false,isleft?len+1:1); // Recursively calculate the zigzag length for the right child\\n\\n    return max(len,max(lh,rh)); // Return the maximum zigzag length between the left child, right child, and the current node\\n}\\n\\nint longestZigZag(TreeNode* root) {\\n    \\n    if(root==NULL) return 0; // If the root is NULL, return 0 as there is no zigzag path\\n\\n    int lh = solve(root->left,true,1); // Calculate the zigzag length for the left child\\n    int rh = solve(root->right,false,1); // Calculate the zigzag length for the right child\\n\\n    return max(lh,rh); // Return the maximum zigzag length between the left child and the right child\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435283,
                "title": "runtime-100-00-faster-memory-usage-less-than-97-92",
                "content": "```\\nclass Solution {\\n    static int ct;\\n    public int longestZigZag(TreeNode root) {\\n        ct = 0;\\n        if(root.left!=null)recur(root.left,\\'l\\',1);\\n        if(root.right!=null)recur(root.right,\\'r\\',1);\\n        return ct;\\n    }\\n    private static void recur(TreeNode root, char c, int x){\\n        if(x>ct)ct = x;\\n        if(c==\\'l\\'){\\n            if(root.left!=null)recur(root.left,\\'l\\',1);\\n            if(root.right!=null)recur(root.right,\\'r\\',x+1);\\n        }else{\\n            if(root.left!=null)recur(root.left,\\'l\\',x+1);\\n            if(root.right!=null)recur(root.right,\\'r\\',1);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    static int ct;\\n    public int longestZigZag(TreeNode root) {\\n        ct = 0;\\n        if(root.left!=null)recur(root.left,\\'l\\',1);\\n        if(root.right!=null)recur(root.right,\\'r\\',1);\\n        return ct;\\n    }\\n    private static void recur(TreeNode root, char c, int x){\\n        if(x>ct)ct = x;\\n        if(c==\\'l\\'){\\n            if(root.left!=null)recur(root.left,\\'l\\',1);\\n            if(root.right!=null)recur(root.right,\\'r\\',x+1);\\n        }else{\\n            if(root.left!=null)recur(root.left,\\'l\\',x+1);\\n            if(root.right!=null)recur(root.right,\\'r\\',1);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435164,
                "title": "simple-c-solution-recursion",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int sol(TreeNode *root, bool d, int l){\\n        if(root == NULL) return l;\\n\\n        if(d == 0){\\n            return max(sol(root->left, 0, 0), sol(root->right, 1, l+1));\\n        }\\n        else{\\n            return max(sol(root->left, 0, 1+l), sol(root->right, 1, 0));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n         if(root == NULL) return 0;\\n\\n         return max(sol(root->left, 0, 0), sol(root->right, 1, 0));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int sol(TreeNode *root, bool d, int l){\\n        if(root == NULL) return l;\\n\\n        if(d == 0){\\n            return max(sol(root->left, 0, 0), sol(root->right, 1, l+1));\\n        }\\n        else{\\n            return max(sol(root->left, 0, 1+l), sol(root->right, 1, 0));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n         if(root == NULL) return 0;\\n\\n         return max(sol(root->left, 0, 0), sol(root->right, 1, 0));\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1868047,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868130,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868023,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868680,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868336,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868150,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868053,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868857,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868595,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868285,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868047,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868130,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868023,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868680,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868336,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868150,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868053,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868857,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868595,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868285,
                "content": [
                    {
                        "username": "Eslam-Soliman",
                        "content": "Looks like the image representation for test case 1 in the description isn't accurate. It doesn't match the one generated under the Testcase tab"
                    },
                    {
                        "username": "prithvi91827",
                        "content": "Although, I solved this question in O(n^2) and giving me TLE but I am glad I solved this."
                    },
                    {
                        "username": "prithvi91827",
                        "content": "[@user3510p](/user3510p) \\nclass Solution {\\npublic:\\n    int maxi = 0;\\n    int f(TreeNode* root, int prevmove){\\n        if(!root) return 0;\\n        if(prevmove == -1){\\n            return max(f(root->left,0),f(root->right,1));\\n        }\\n        else{\\n            if(prevmove == 0){\\n                return 1 + f(root->right,1);\\n            }\\n            else{\\n                return 1 + f(root->left,0);\\n            }\\n        }\\n\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        if(!root) return 0;\\n        int len = f(root,-1);\\n        maxi = max(len,maxi);\\n        longestZigZag(root->left);\\n        longestZigZag(root->right);\\n\\n        return maxi;\\n    }\\n};"
                    },
                    {
                        "username": "user3510p",
                        "content": "can u share the approach"
                    },
                    {
                        "username": "rajat_171",
                        "content": "In this Platform, wherever there is Coding\\u2013 there will always be DP to be found as well - Leetcode Uchiha."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "[@Mek_san](/Mek_san) lol"
                    },
                    {
                        "username": "Nisarg_Pipaliya",
                        "content": "Those who forget the past, they tend to repeat it - DP Nara"
                    },
                    {
                        "username": "Mek_san",
                        "content": "As long as there is a concept of greedy, dp would also exist. Dp is born in ordered to decrease time in recursion."
                    },
                    {
                        "username": "riyaJha_3624",
                        "content": "This was a tricky one!"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "That\\'s how my daily life look like : zig-zag"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style=\\'color:green\\'>Hint</span>\\nUse DFS with a variable that determines direction and flip that variable each iteration"
                    },
                    {
                        "username": "jacksonchen1998",
                        "content": "The first graph\\'s image is wrong. There has another right child."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@vetor](/vetor) It is, it just doesn\\'t start in the rootNode"
                    },
                    {
                        "username": "BeniAc",
                        "content": "The image is correct. Take into consideration that you have to find out the longest path, given that you have to move right->left/left->right, you cannot move in the same direction twice, one after the other."
                    },
                    {
                        "username": "vetor",
                        "content": "but its not zigzag\\n"
                    },
                    {
                        "username": "himgupta2197",
                        "content": "The below test case should give 6 as the correct output, but the expected output is 5. how?\\n\\n[6,9,7,3,null,2,8,5,8,9,7,3,9,9,4,2,10,null,5,4,3,10,10,9,4,1,2,null,null,6,5,null,null,null,null,9,null,9,6,5,null,5,null,null,7,7,4,null,1,null,null,3,7,null,9,null,null,null,null,null,null,null,null,9,9,null,null,null,7,null,null,null,null,null,null,null,null,null,6,8,7,null,null,null,3,10,null,null,null,null,null,1,null,1,2]"
                    },
                    {
                        "username": "no947",
                        "content": "I had the same issue. I feel like my code is identical to the answer code. If you every figured out the question can you let me know?"
                    },
                    {
                        "username": "princepatrick",
                        "content": "I was facing the same issue for my previous submissions but rectified the test case later. The issue was let us assume we move to the current node through the left branch with a zig zag score of 3 and if we take a right branch then the score increases to 4 but if we move to the left branch again, then the score needs to reset to 1 again, but my previous code was retaining the score to 3, which was the issue.\\n\\nOn traversing the same direction in a future branch, I reset the score to 1 again. This resolved my issue. Let me know if my explanation was not clear. I will try explain again and better. "
                    },
                    {
                        "username": "mikemaximenko",
                        "content": "I having the same problem. Don\\'t understand it either"
                    },
                    {
                        "username": "malikharshit03",
                        "content": "HINT:\\nThis question can be solved using simple DFS traversal.\\n\\nTraverse in dfs fashion (with parameters current treenode, path and count) and keep track of previous path which took us here. While calling the current path (left or right) increment the count if the paths are different. \\nExample: \\nIf the curr node is brought by path equal to left and we are going to move right, we increment count by 1\\nIf the curr node is brought by path equal to left and we are going to move left, we assign count as 1 because zigzag is interrupted by 2 lefts.\\n\\nWe use the same thought process for 2 cases of path coming from right as well.\\nThroughout the dfs traversal keep updating the max value of count which is the required answer.\\n\\nFor Complete solution refer : https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3435575/easy-java-dfs-solution-with-explanation/\\n"
                    },
                    {
                        "username": "hosua",
                        "content": "Very helpful, thank you."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "done so many dp problems lately that I put memoization :) When it was not really needed. \\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1868005,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 2069060,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1868638,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1868250,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1868030,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1868190,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 2065036,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 2031715,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1924319,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1911286,
                "content": [
                    {
                        "username": "UchihaKim",
                        "content": "And the storm begin... I hope not"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "Yeah..it is..!!"
                    },
                    {
                        "username": "iamprashantmmishra",
                        "content": "This one was really interesting. Just try with a recursive solution and maintain left and right lengths and pass it accordingly if you are going to the left side or right side and return max of the 2 calls. "
                    },
                    {
                        "username": "najwer23",
                        "content": "i hate graphs "
                    },
                    {
                        "username": "hosua",
                        "content": "This isn\\'t even a graph problem"
                    },
                    {
                        "username": "foodsnow",
                        "content": "It\\'s easier to solve it after you write simple dfs traversal "
                    },
                    {
                        "username": "anwendeng",
                        "content": "I wrote a code to find the maximal length of the tree. \nAnd I want to modify it to solve the problem. ` int pathLen=0;\n    void dfs(TreeNode* Node, int level){\n        if (Node==NULL) return ;\n        cout<<Node->val<<\",level=\"<<level<<endl;\n        pathLen=max(pathLen, level);\n        dfs(Node->left, level+1);\n        dfs(Node->right, level+1);.`  "
                    },
                    {
                        "username": "anwendeng",
                        "content": "So, the modification goes well. https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/solutions/3433226/easy-c-solution/\\n\\nLater, I will try to optimize "
                    },
                    {
                        "username": "Kiy0taka_Ayanak0ji",
                        "content": "Maintain a boolean:\n```cpp\nint maxZig(TreeNode* root , bool isRight = true,int height)\n```"
                    },
                    {
                        "username": "breathermachine",
                        "content": "You\\'ll need to pass in the direction to your recursive call as well. \\n```\\nint longestZigZag(TreeNode *node, int direction) {\\n```"
                    },
                    {
                        "username": "Firebelias12",
                        "content": "This should be an easy."
                    },
                    {
                        "username": "Athanasios-Kataras",
                        "content": "Are you sure it wasn't one of those cases that the solution just came to you easily? It is a bit tricky to get the alternating paths when they don't just start from root. Easy are generally items with no tricky parts."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "Hey there to PROs ! I was able to come up with a solution for this question which was ~ 90% correct in my first try ,under almost 10 minutes . IS THIS A WIN?  "
                    },
                    {
                        "username": "amanrushed",
                        "content": "This is tricky"
                    },
                    {
                        "username": "codetogrow",
                        "content": "This problem needs some clarification!\\nWe are not being asked the length of the longest path. We have to find the longest \"zigzag\" path!\\n\\nA zigzag path is a path where the direction between every two consecutive nodes alternates, i.e., if we went right from the current node to get to the next node, then from the next node, we should go left to get to the next node after that, and vice versa.\\n\\nThat is why the testcase\\n[1,null,1,1,1,null,null,1,1,null,1,null,null,null,1]\\n\\nmust yield the output 3 instead of 5."
                    },
                    {
                        "username": "prats02",
                        "content": "why is this wrong?\\n\\nclass Solution {\\npublic:\\n    int fn(TreeNode* root,int n){\\n        if(root==NULL) return 0;\\n        if(n==1){\\n            return max((1+fn(root->right,2)),fn(root->left,1));\\n        }\\n        else{\\n            return max((1+fn(root->left,1)),fn(root->right,2));\\n        }\\n    }\\n    int longestZigZag(TreeNode* root) {\\n        return max(fn(root->left,1),fn(root->right,2));\\n    }\\n};"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "the question says \"Choose any node in the binary tree and a direction (right or left)\" \\ninside the longest-zigzag func( fo dfs). \\n\\n\\ni mean - \\nint longestZigZag(TreeNode* root) {\\nreturn max(fn(root->left,1),fn(root->right,2)); // modify this lil bit\\nlongestZigZag(root->left);\\nlongestZigZag(root->right);\\n}\\n};"
                    }
                ]
            },
            {
                "id": 1895120,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1891095,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868753,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868598,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868563,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868541,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868522,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868504,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868492,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            },
            {
                "id": 1868491,
                "content": [
                    {
                        "username": "ndrwknsh",
                        "content": "If you\\'re struggling with this problem, you may want to consider the differences between top-down recursion and bottom-up recursion."
                    },
                    {
                        "username": "tsagikyan",
                        "content": "Faster than editorial | CPP | 1-liner recursion:\n```\n    int dfs(TreeNode* root, int lsum, int rsum) {\n        return root==0 ? max(lsum,rsum) : max(dfs(root->left, rsum+1, -1), dfs(root->right, -1, lsum+1));\n    }\n\n    int longestZigZag(TreeNode* root) {\n        return dfs(root, -1, -1);\n    }\n```"
                    },
                    {
                        "username": "user5742L",
                        "content": "Why it is Giving WA??\nclass Solution {\n    public int f(TreeNode root, boolean isLeft, int count) {\n        if (root == null) {\n            return count;\n        }\n        if (isLeft) {\n            return Math.max(f(root.right, false, count + 1), Math.max(f(root.left, true, 0),f(root.left, false, 0)));\n        } else {\n            return Math.max(f(root.left, true, count + 1), Math.max(f(root.right, true, 0),f(root.right, false, 0)));\n        }\n    }\n    \n    public int longestZigZag(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        return Math.max(f(root.left, true, 0), f(root.right, false, 0));\n    }\n}\n\n\n\n  "
                    },
                    {
                        "username": "ankeshaman333",
                        "content": "Is anyone facing version of your browser is too low to load the code-editor"
                    },
                    {
                        "username": "klaca",
                        "content": "It happened to me two days ago but now it works. I didn't do anything to fix it."
                    },
                    {
                        "username": "klaca",
                        "content": "Do you have any tips for debugging a test case with a huge tree? I fail at test case 52, my solution returns 2050 instead of 6962 and I don't have the slightest idea what the problem could be.\nmy approach is to follow a zigzag, putting unvisited nodes (with direction) on a stack, and starting a new count from the top of the stack when the current path is exhausted. It has no problem with the first 51 test cases."
                    },
                    {
                        "username": "klaca",
                        "content": "[@Mister_CK](/Mister_CK) It's not a recursion. I thought to do an incremental traversal using a stack, there is really not much difference to it. I will try recursion now that I can't see the problem with incremental. \nEdit: it was quite simple with recursion. I'm still bothered about not knowing what went wrong with my incremental solution... I guess I just have to leave it like that now..."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "you could log the root in you recursive function. Not sure if that test case isn\\'t to big for even that though. \\nBut creating a stack of nodes to visit later is not a great approach. Try to do those nodes immediately. (or, well, DFS so still after the current iteration, but there is no need to store them, just call them, if you get what I mean)"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "struggled a lot to solve this one"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "me too, was trying to use dynamic programming, but couldn\\'t get it to work, wasted a lot of time on it. Doing DFS while keeping track of current path length was so much simpeler! Ended up spending more time on this medium than on Sundays hard."
                    },
                    {
                        "username": "jainams6160",
                        "content": " Can some explain me the time complexity of this solution?\\n\\n    static int ans;\\n    static void util(TreeNode root, boolean l, boolean r, int value){\\n        if(root == null){\\n            ans = Math.max(ans, value);\\n            return;\\n        }\\n        if(l)\\n            util(root.left, false, true, value + 1);\\n        if(r)\\n            util(root.right, true, false, value + 1);\\n        util(root.left, true, true, -1);\\n        util(root.right, true, true, -1);\\n    }\\n\\n    public int longestZigZag(TreeNode root) {\\n        ans = 0;\\n        util(root, true, true, -1)\\n        return ans;\\n    }`"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "Example 1 doesn\\'t make any sense to me? Doesn\\'t it go right *twice* at the beginning? \\n\\nI feel like it should be right -> left -> right for a path length of 2, since we count edges not nodes"
                    },
                    {
                        "username": "elrestbrain",
                        "content": "[@pinakibanerjee2001](/pinakibanerjee2001) oh duh, thank you"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "You are supposed to find maximum zigzag path starting at any node, not necessarily starting at root\n"
                    },
                    {
                        "username": "van146",
                        "content": "yeah - I was stumbled upon the same understanding spike - e.g. read the whole description - as we need to find max possible zigzag path within the tree, and this one not necessarily would start from the root of the tree, that\\'s why example one is correct and it explains the task better then description"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `yclass Solution {\\n    public int longestZigZag(TreeNode root) {\\n    return dfs(root).subtreeMax;\\n  }\\n\\n  private T dfs(TreeNode root) {\\n    if (root == null)\\n      return new T(-1, -1, -1);\\n    T left = dfs(root.left);\\n    T right = dfs(root.right);\\n    final int leftZigZag = left.rightMax + 1;\\n    final int rightZigZag = right.leftMax + 1;\\n    final int subtreeMax =\\n        Math.max(Math.max(leftZigZag, rightZigZag), Math.max(left.subtreeMax, right.subtreeMax));\\n    return new T(leftZigZag, rightZigZag, subtreeMax);\\n  }\\n}`"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `class T {\\n  public int leftMax;\\n  public int rightMax;\\n  public int subtreeMax;\\n\\n  public T(int leftMax, int rightMax, int subtreeMax) {\\n    this.leftMax = leftMax;\\n    this.rightMax = rightMax;\\n    this.subtreeMax = subtreeMax;\\n  }\\n}`"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Sum BST in Binary Tree",
        "question_content": "<p>Given a <strong>binary tree</strong> <code>root</code>, return <em>the maximum sum of all keys of <strong>any</strong> sub-tree which is also a Binary Search Tree (BST)</em>.</p>\n\n<p>Assume a BST is defined as follows:</p>\n\n<ul>\n\t<li>The left subtree of a node contains only nodes with keys <strong>less than</strong> the node&#39;s key.</li>\n\t<li>The right subtree of a node contains only nodes with keys <strong>greater than</strong> the node&#39;s key.</li>\n\t<li>Both the left and right subtrees must also be binary search trees.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/30/sample_1_1709.png\" style=\"width: 320px; height: 250px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]\n<strong>Output:</strong> 20\n<strong>Explanation:</strong> Maximum sum in a valid Binary search tree is obtained in root node with key equal to 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/01/30/sample_2_1709.png\" style=\"width: 134px; height: 180px;\" /></p>\n\n<pre>\n<strong>Input:</strong> root = [4,3,null,1,2]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Maximum sum in a valid Binary search tree is obtained in a single root node with key equal to 2.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [-4,-2,-5]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> All values are negatives. Return an empty BST.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 4 * 10<sup>4</sup>]</code>.</li>\n\t<li><code>-4 * 10<sup>4</sup> &lt;= Node.val &lt;= 4 * 10<sup>4</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 531822,
                "title": "java-post-order-traverse-with-comment-clean-code",
                "content": "```java\\nclass Solution {\\n    private int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        postOrderTraverse(root);\\n        return maxSum;\\n    }\\n    private int[] postOrderTraverse(TreeNode root) {\\n        if (root == null) return new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, 0}; // {min, max, sum}, initialize min=MAX_VALUE, max=MIN_VALUE\\n        int[] left = postOrderTraverse(root.left);\\n        int[] right = postOrderTraverse(root.right);\\n        // The BST is the tree:\\n        if (!(     left != null             // the left subtree must be BST\\n                && right != null            // the right subtree must be BST\\n                && root.val > left[1]       // the root\\'s key must greater than maximum keys of the left subtree\\n                && root.val < right[0]))    // the root\\'s key must lower than minimum keys of the right subtree\\n            return null;\\n        int sum = root.val + left[2] + right[2]; // now it\\'s a BST make `root` as root\\n        maxSum = Math.max(maxSum, sum);\\n        int min = Math.min(root.val, left[0]);\\n        int max = Math.max(root.val, right[1]);\\n        return new int[]{min, max, sum};\\n    }\\n}\\n```\\n**Complexity:**\\n- Time: `O(n)`\\n- Space: `O(h)`, where `h` is the height of the binary tree\\n\\n\\n**Similar problem**\\n[98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    private int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        postOrderTraverse(root);\\n        return maxSum;\\n    }\\n    private int[] postOrderTraverse(TreeNode root) {\\n        if (root == null) return new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, 0}; // {min, max, sum}, initialize min=MAX_VALUE, max=MIN_VALUE\\n        int[] left = postOrderTraverse(root.left);\\n        int[] right = postOrderTraverse(root.right);\\n        // The BST is the tree:\\n        if (!(     left != null             // the left subtree must be BST\\n                && right != null            // the right subtree must be BST\\n                && root.val > left[1]       // the root\\'s key must greater than maximum keys of the left subtree\\n                && root.val < right[0]))    // the root\\'s key must lower than minimum keys of the right subtree\\n            return null;\\n        int sum = root.val + left[2] + right[2]; // now it\\'s a BST make `root` as root\\n        maxSum = Math.max(maxSum, sum);\\n        int min = Math.min(root.val, left[0]);\\n        int max = Math.max(root.val, right[1]);\\n        return new int[]{min, max, sum};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1126183,
                "title": "c-recursion-easy-to-understand",
                "content": "**Code:**\\n```\\nint ans;\\nclass prop{\\npublic:\\n    bool bst;       //to check if tree is bst\\n    int ma;         //max value in a tree\\n    int mi;         //min value in an tree\\n    int ms;         //current maximum sum\\n    prop(){\\n        bst=true;\\n        ma=INT_MIN;\\n        mi=INT_MAX;\\n        ms=0;\\n    }\\n};\\nclass Solution {\\npublic:\\n    prop calcSum(TreeNode* root){\\n        if (root == NULL){\\n            return prop();\\n        }\\n        prop p;\\n        prop pl = calcSum(root->left);                        //recursive call for left sub-tree\\n        prop pr = calcSum(root->right);                       //recursive call for right sub-tree\\n\\t\\t\\n\\t\\t//if sub-tree including this node is bst\\n        if ( pl.bst==true && pr.bst==true && root->val>pl.ma && root->val<pr.mi ){\\n            p.bst = true;                                                      //current tree is a bst\\n            p.ms = pl.ms + pr.ms + root->val;          \\n            p.mi  = min(root->val, pl.mi);\\n            p.ma = max(root->val, pr.ma);\\n        }\\n\\t\\t//if current tree is not a bst\\n        else {\\n            p.bst=false;\\n            p.ms=max(pl.ms, pr.ms);\\n        }\\n\\t\\t\\n        ans=max(ans, p.ms);\\n        return p;\\n    }\\n    int maxSumBST(TreeNode* root){\\n        ans = 0;\\n        calcSum(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nint ans;\\nclass prop{\\npublic:\\n    bool bst;       //to check if tree is bst\\n    int ma;         //max value in a tree\\n    int mi;         //min value in an tree\\n    int ms;         //current maximum sum\\n    prop(){\\n        bst=true;\\n        ma=INT_MIN;\\n        mi=INT_MAX;\\n        ms=0;\\n    }\\n};\\nclass Solution {\\npublic:\\n    prop calcSum(TreeNode* root){\\n        if (root == NULL){\\n            return prop();\\n        }\\n        prop p;\\n        prop pl = calcSum(root->left);                        //recursive call for left sub-tree\\n        prop pr = calcSum(root->right);                       //recursive call for right sub-tree\\n\\t\\t\\n\\t\\t//if sub-tree including this node is bst\\n        if ( pl.bst==true && pr.bst==true && root->val>pl.ma && root->val<pr.mi ){\\n            p.bst = true;                                                      //current tree is a bst\\n            p.ms = pl.ms + pr.ms + root->val;          \\n            p.mi  = min(root->val, pl.mi);\\n            p.ma = max(root->val, pr.ma);\\n        }\\n\\t\\t//if current tree is not a bst\\n        else {\\n            p.bst=false;\\n            p.ms=max(pl.ms, pr.ms);\\n        }\\n\\t\\t\\n        ans=max(ans, p.ms);\\n        return p;\\n    }\\n    int maxSumBST(TreeNode* root){\\n        ans = 0;\\n        calcSum(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534877,
                "title": "java-one-pass-post-order-dfs-o-n",
                "content": "```\\nclass Solution {\\n    int max;\\n    public int maxSumBST(TreeNode root) {\\n        max = 0;\\n        findMaxSum(root);\\n        return max;\\n    }\\n    \\n    //int[]{isBST(0/1), largest, smallest, sum}\\n    public int[] findMaxSum(TreeNode node){\\n        if(node==null){\\n            return new int[]{1, Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\\n        }\\n        int[] left = findMaxSum(node.left);\\n        int[] right = findMaxSum(node.right);\\n        boolean isBST = left[0]==1 && right[0]==1 && node.val>left[1] && node.val<right[2];\\n        int sum = node.val + left[3] + right[3];\\n        if(isBST){\\n            max = Math.max(max, sum);\\n        }\\n        return new int[]{isBST?1:0, Math.max(node.val,right[1]), Math.min(node.val,left[2]), sum};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max;\\n    public int maxSumBST(TreeNode root) {\\n        max = 0;\\n        findMaxSum(root);\\n        return max;\\n    }\\n    \\n    //int[]{isBST(0/1), largest, smallest, sum}\\n    public int[] findMaxSum(TreeNode node){\\n        if(node==null){\\n            return new int[]{1, Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\\n        }\\n        int[] left = findMaxSum(node.left);\\n        int[] right = findMaxSum(node.right);\\n        boolean isBST = left[0]==1 && right[0]==1 && node.val>left[1] && node.val<right[2];\\n        int sum = node.val + left[3] + right[3];\\n        if(isBST){\\n            max = Math.max(max, sum);\\n        }\\n        return new int[]{isBST?1:0, Math.max(node.val,right[1]), Math.min(node.val,left[2]), sum};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531826,
                "title": "c-o-n-record-min-max-and-sum",
                "content": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // {smallest_num, largest_num, curr_sum} of a tree\\n    vector<int> traverse(TreeNode* root, int& ans) {\\n        if (!root) return {INT_MAX, INT_MIN, 0};\\n        vector<int> left(traverse(root->left, ans)), right(traverse(root->right, ans));\\n\\t\\t// check if a tree is BST\\n        if (left.empty() || right.empty() || root->val <= left[1] || root->val >= right[0]) return {};\\n\\t\\t// if BST, update ans\\n        int curr_sum = left[2] + right[2] + root->val;\\n        ans = max(ans, curr_sum);\\n        return {min(left[0], root->val), max(right[1], root->val), curr_sum};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans(0);\\n        traverse(root, ans);\\n        return max(0, ans);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // {smallest_num, largest_num, curr_sum} of a tree\\n    vector<int> traverse(TreeNode* root, int& ans) {\\n        if (!root) return {INT_MAX, INT_MIN, 0};\\n        vector<int> left(traverse(root->left, ans)), right(traverse(root->right, ans));\\n\\t\\t// check if a tree is BST\\n        if (left.empty() || right.empty() || root->val <= left[1] || root->val >= right[0]) return {};\\n\\t\\t// if BST, update ans\\n        int curr_sum = left[2] + right[2] + root->val;\\n        ans = max(ans, curr_sum);\\n        return {min(left[0], root->val), max(right[1], root->val), curr_sum};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans(0);\\n        traverse(root, ans);\\n        return max(0, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531800,
                "title": "python-easy-traversal-with-explanation",
                "content": "**Idea**\\nFor each subtree, we return 4 elements.\\n1. the status of this subtree, `1` means it\\'s empty, `2` means it\\'s a BST, `0` means it\\'s not a BST\\n2. size of this subtree (we only care about size of BST though)\\n3. the minimal value in this subtree\\n4. the maximal value in this subtree\\n\\nThen we only need to make sure for every BST\\n- both of its children are BST\\n- the right bound of its left child is smaller than `root.val`\\n- the left bound of its right child is larger than `root.val`\\n\\n**Complexity**\\nTime: `O(N)`\\nSpace: `O(logN)` for function calls, worst case `O(N)` if the given tree is not balanced\\n\\n**Python 3**\\n```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        res = 0\\n        def traverse(root):\\n            \\'\\'\\'return status_of_bst, size_of_bst, left_bound, right_bound\\'\\'\\'\\n            nonlocal res\\n            if not root: return 1, 0, None, None # this subtree is empty\\n            \\n            ls, l, ll, lr = traverse(root.left)\\n            rs, r, rl, rr = traverse(root.right)\\n            \\n            if ((ls == 2 and lr < root.val) or ls == 1) and ((rs == 2 and rl > root.val) or rs == 1):\\n\\t\\t        # this subtree is a BST\\n                size = root.val + l + r\\n                res = max(res, size)\\n                return 2, size, (ll if ll is not None else root.val), (rr if rr is not None else root.val)\\n            return 0, None, None, None # this subtree is not a BST\\n        \\n        traverse(root)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Interactive"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        res = 0\\n        def traverse(root):\\n            \\'\\'\\'return status_of_bst, size_of_bst, left_bound, right_bound\\'\\'\\'\\n            nonlocal res\\n            if not root: return 1, 0, None, None # this subtree is empty\\n            \\n            ls, l, ll, lr = traverse(root.left)\\n            rs, r, rl, rr = traverse(root.right)\\n            \\n            if ((ls == 2 and lr < root.val) or ls == 1) and ((rs == 2 and rl > root.val) or rs == 1):\\n\\t\\t        # this subtree is a BST\\n                size = root.val + l + r\\n                res = max(res, size)\\n                return 2, size, (ll if ll is not None else root.val), (rr if rr is not None else root.val)\\n            return 0, None, None, None # this subtree is not a BST\\n        \\n        traverse(root)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162388,
                "title": "c-use-dfs-class-object-simple-efficient-solution",
                "content": "**TC: O(N) - DFS Traversal\\nSC: O(N) - Auxiliary recursion stack space**\\n\\n**Code:**\\n```\\nclass NodeValue {\\npublic: \\n    int minNode, maxNode, maxSum;\\n    \\n    NodeValue(int minNode, int maxNode, int maxSum)\\n    {\\n        this->minNode = minNode;\\n        this->maxNode = maxNode;\\n        this->maxSum = maxSum;\\n    }\\n};\\n\\nclass Solution {\\n    \\nprivate:\\n    NodeValue maxSumBSTHelper(TreeNode* root)\\n    {\\n        if(!root) return NodeValue(INT_MAX, INT_MIN, 0);\\n        \\n        auto left = maxSumBSTHelper(root->left);\\n        auto right = maxSumBSTHelper(root->right);\\n        \\n        if(left.maxNode < root->val && root->val < right.minNode)\\n        {\\n            //if BT is BST\\n            sum = max(sum, root->val + left.maxSum + right.maxSum);\\n            \\n            return NodeValue(min(root->val, left.minNode), max(root->val, right.maxNode), root->val + left.maxSum + right.maxSum);\\n            \\n        }\\n        \\n        return NodeValue(INT_MIN, INT_MAX, max(left.maxSum, right.maxSum));   \\n    }\\n    \\npublic:\\n    int sum=0;\\n    int maxSumBST(TreeNode* root) \\n    {\\n        maxSumBSTHelper(root);\\n        return sum>0 ? sum : 0;\\n        \\n    }\\n};\\n```\\n\\n**Please upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass NodeValue {\\npublic: \\n    int minNode, maxNode, maxSum;\\n    \\n    NodeValue(int minNode, int maxNode, int maxSum)\\n    {\\n        this->minNode = minNode;\\n        this->maxNode = maxNode;\\n        this->maxSum = maxSum;\\n    }\\n};\\n\\nclass Solution {\\n    \\nprivate:\\n    NodeValue maxSumBSTHelper(TreeNode* root)\\n    {\\n        if(!root) return NodeValue(INT_MAX, INT_MIN, 0);\\n        \\n        auto left = maxSumBSTHelper(root->left);\\n        auto right = maxSumBSTHelper(root->right);\\n        \\n        if(left.maxNode < root->val && root->val < right.minNode)\\n        {\\n            //if BT is BST\\n            sum = max(sum, root->val + left.maxSum + right.maxSum);\\n            \\n            return NodeValue(min(root->val, left.minNode), max(root->val, right.maxNode), root->val + left.maxSum + right.maxSum);\\n            \\n        }\\n        \\n        return NodeValue(INT_MIN, INT_MAX, max(left.maxSum, right.maxSum));   \\n    }\\n    \\npublic:\\n    int sum=0;\\n    int maxSumBST(TreeNode* root) \\n    {\\n        maxSumBSTHelper(root);\\n        return sum>0 ? sum : 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839174,
                "title": "java-dfs-with-explanation-faster-than-99",
                "content": "At each node we want to know 2 things:\\n - Is this node the root of a valid BST?\\n - What is the sum of the subtree?\\n\\nIf we know these 2 pieces of information about each node, then finding the final solution is trivial.\\n\\nThe main idea of this problem is to start at the bottom (leaf) nodes and work our way up the tree, remembering the \"2 things\" about each node on the way up. To encapsulate the data nicely, we can define a custom data structure that adds relevant data we need to the given `TreeNode` class:\\n\\n```\\n    static class NodeWrapper {\\n        final TreeNode node;\\n        int sum;\\n        int max;\\n        int min;\\n        boolean validBST = true;\\n        public NodeWrapper(TreeNode node) {\\n            this.node = node;\\n            this.sum = node.val;\\n            this.max = node.val;\\n            this.min = node.val;\\n        }\\n    }\\n```\\n\\nTo obtain the final solution, we perform a post-order DFS and use the `NodeWrapper` for the left and right subtrees of each node to determine the original 2 pieces of information we need: is the current node a BST, and what is the sum of the subtree.\\n\\nThe final solution looks like this:\\n\\n```\\nclass Solution {\\n    \\n    int maxSum = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        findMaxSum(root);\\n        return maxSum;\\n    }\\n    \\n    private NodeWrapper findMaxSum(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        \\n        NodeWrapper leftTree = findMaxSum(root.left);\\n        NodeWrapper rightTree = findMaxSum(root.right);\\n        \\n        NodeWrapper curNode = new NodeWrapper(root);\\n        if (leftTree != null) {\\n            curNode.sum += leftTree.sum;\\n            curNode.max = Math.max(root.val, leftTree.max);\\n            curNode.min = Math.min(root.val, leftTree.min);\\n            curNode.validBST = leftTree.validBST && leftTree.max < root.val;\\n        }\\n        if (rightTree != null) {\\n            curNode.sum += rightTree.sum;\\n            curNode.max = Math.max(curNode.max, rightTree.max);\\n            curNode.min = Math.min(curNode.min, rightTree.min);\\n            curNode.validBST &= rightTree.validBST && rightTree.min > root.val;\\n        }\\n\\n        if (curNode.validBST) {\\n            maxSum = Math.max(maxSum, curNode.sum);   \\n        }\\n        return curNode;\\n    }\\n        \\n    static class NodeWrapper {\\n        final TreeNode node;\\n        int sum;\\n        int max;\\n        int min;\\n        boolean validBST = true;\\n        public NodeWrapper(TreeNode node) {\\n            this.node = node;\\n            this.sum = node.val;\\n            this.max = node.val;\\n            this.min = node.val;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    static class NodeWrapper {\\n        final TreeNode node;\\n        int sum;\\n        int max;\\n        int min;\\n        boolean validBST = true;\\n        public NodeWrapper(TreeNode node) {\\n            this.node = node;\\n            this.sum = node.val;\\n            this.max = node.val;\\n            this.min = node.val;\\n        }\\n    }\\n```\n```\\nclass Solution {\\n    \\n    int maxSum = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        findMaxSum(root);\\n        return maxSum;\\n    }\\n    \\n    private NodeWrapper findMaxSum(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        \\n        NodeWrapper leftTree = findMaxSum(root.left);\\n        NodeWrapper rightTree = findMaxSum(root.right);\\n        \\n        NodeWrapper curNode = new NodeWrapper(root);\\n        if (leftTree != null) {\\n            curNode.sum += leftTree.sum;\\n            curNode.max = Math.max(root.val, leftTree.max);\\n            curNode.min = Math.min(root.val, leftTree.min);\\n            curNode.validBST = leftTree.validBST && leftTree.max < root.val;\\n        }\\n        if (rightTree != null) {\\n            curNode.sum += rightTree.sum;\\n            curNode.max = Math.max(curNode.max, rightTree.max);\\n            curNode.min = Math.min(curNode.min, rightTree.min);\\n            curNode.validBST &= rightTree.validBST && rightTree.min > root.val;\\n        }\\n\\n        if (curNode.validBST) {\\n            maxSum = Math.max(maxSum, curNode.sum);   \\n        }\\n        return curNode;\\n    }\\n        \\n    static class NodeWrapper {\\n        final TreeNode node;\\n        int sum;\\n        int max;\\n        int min;\\n        boolean validBST = true;\\n        public NodeWrapper(TreeNode node) {\\n            this.node = node;\\n            this.sum = node.val;\\n            this.max = node.val;\\n            this.min = node.val;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534900,
                "title": "c-naive-correct",
                "content": "**Update** the first solution is accepted, but it\\'s not accurate. See the second solution below.\\n\\nWhy this problem is marked hard?\\n\\nWe traverse the tree and return INT_MIN if it is not BST. Otherwise, we return the sum of its node values.\\n\\nIf sums for the both left and right subtrees is not INT_MIN (both subtrees are BST), we then check if the value of the current node is greater then left node value, and lower than right node value. If it is, we return the sum of the entire subtree.\\n\\nOtherwise, return INT_MIN.\\n\\n```cpp\\nint maxSum = 0;\\nint dfs(TreeNode* n) {\\n    if (n == nullptr) return 0;\\n    auto ls = dfs(n->left), rs = dfs(n->right);\\n    if (ls != INT_MIN && rs != INT_MIN) {\\n        if ((n->left == nullptr || n->left->val < n->val) \\n            && (n->right == nullptr || n->right->val > n->val)) {\\n            maxSum = max(maxSum, n->val + ls + rs);\\n            return n->val + ls + rs;\\n        }\\n    }\\n    return INT_MIN;\\n}\\nint maxSumBST(TreeNode* root) {\\n    dfs(root);\\n    return maxSum;\\n}\\n```\\n\\n**Updated Solution**\\nThe solution above is accepted, however, as [hiepit](https://leetcode.com/hiepit/) and [MohammedShoaib](https://leetcode.com/mohammedshoaib/) pointed out, it produces wrong result for use case like this: `[4,2,6,1,5,3,9]`. To address it, we need to also track the minimum and maximum value of the subtree, and check that the node value is greater than the maximum, and less than the minimum of left and right subtrees, respectfully.\\n\\nSo, instead of just sum, below we return tree values: {sum, min value, max value}.\\n```cpp\\n#define ANIMAL_STYLE 1\\n```\\n```cpp\\nint max_sum = 0;\\narray<int, 3> dfs(TreeNode* n) {\\n    auto l = n->left ? dfs(n->left) : array<int, 3>{0, n->val, n->val - 1};\\n    auto r = n->right ? dfs(n->right) : array<int, 3>{0, n->val + 1, n->val};\\n    if (l[2] < n->val && n->val < r[1]) {\\n        max_sum = max(max_sum, n->val + l[0] + r[0]);\\n        return {n->val + l[0] + r[0], l[1], r[2]};        \\n    }\\n    return {0, INT_MIN, INT_MAX};\\n}\\nint maxSumBST(TreeNode* root) {\\n    dfs(root);\\n    return max_sum;\\n}\\n```\\n```cpp\\n#undef ANIMAL_STYLE\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxSum = 0;\\nint dfs(TreeNode* n) {\\n    if (n == nullptr) return 0;\\n    auto ls = dfs(n->left), rs = dfs(n->right);\\n    if (ls != INT_MIN && rs != INT_MIN) {\\n        if ((n->left == nullptr || n->left->val < n->val) \\n            && (n->right == nullptr || n->right->val > n->val)) {\\n            maxSum = max(maxSum, n->val + ls + rs);\\n            return n->val + ls + rs;\\n        }\\n    }\\n    return INT_MIN;\\n}\\nint maxSumBST(TreeNode* root) {\\n    dfs(root);\\n    return maxSum;\\n}\\n```\n```cpp\\n#define ANIMAL_STYLE 1\\n```\n```cpp\\nint max_sum = 0;\\narray<int, 3> dfs(TreeNode* n) {\\n    auto l = n->left ? dfs(n->left) : array<int, 3>{0, n->val, n->val - 1};\\n    auto r = n->right ? dfs(n->right) : array<int, 3>{0, n->val + 1, n->val};\\n    if (l[2] < n->val && n->val < r[1]) {\\n        max_sum = max(max_sum, n->val + l[0] + r[0]);\\n        return {n->val + l[0] + r[0], l[1], r[2]};        \\n    }\\n    return {0, INT_MIN, INT_MAX};\\n}\\nint maxSumBST(TreeNode* root) {\\n    dfs(root);\\n    return max_sum;\\n}\\n```\n```cpp\\n#undef ANIMAL_STYLE\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1555163,
                "title": "c-postorder-traversal-easy-to-understand-dfs",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    class bst {\\n    public:\\n      bool isbst;\\n      int max;\\n      int min;\\n      int sum;\\n    };\\n\\n    bst Bst(TreeNode* root) {\\n\\n      if (root == nullptr)\\n      {  \\n        bst bres;            // Base Case\\n        bres.isbst = true;\\n        bres.max = INT_MIN;\\n        bres.min = INT_MAX;\\n        bres.sum = 0;\\n        return bres;\\n      }\\n      bst l = Bst(root->left); // left sub-tree\\n      bst r = Bst(root->right); // right sub-tree\\n\\n      bst ans;\\n\\n      ans.max = max(root->val, max(l.max, r.max));\\n      ans.min = min(root->val, min(l.min, r.min));\\n\\n      // Check if current tree is Bst or not ?\\n      ans.isbst = l.isbst && r.isbst && (l.max < root->val && r.min > root->val);\\n\\n      if(ans.isbst){\\n          ans.sum = l.sum + r.sum + root->val;\\n          ans.min = min(root->val, min(l.min, r.min));\\n          ans.max = max(root->val, max(l.max, r.max));\\n      }\\n      else\\n          ans.sum = max(l.sum, r.sum);\\n      \\n      res = max(res, ans.sum);\\n      return ans;\\n    }\\n    \\n    int res = INT_MIN;\\n    int maxSumBST(TreeNode* root) {\\n        Bst(root);\\n        return res > 0 ? res : 0;\\n    }\\n};\\n```\\nHope you liked it , kindly upvote !!\\nComment down your queries \\nHappy Coding \\uD83E\\uDD17",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class bst {\\n    public:\\n      bool isbst;\\n      int max;\\n      int min;\\n      int sum;\\n    };\\n\\n    bst Bst(TreeNode* root) {\\n\\n      if (root == nullptr)\\n      {  \\n        bst bres;            // Base Case\\n        bres.isbst = true;\\n        bres.max = INT_MIN;\\n        bres.min = INT_MAX;\\n        bres.sum = 0;\\n        return bres;\\n      }\\n      bst l = Bst(root->left); // left sub-tree\\n      bst r = Bst(root->right); // right sub-tree\\n\\n      bst ans;\\n\\n      ans.max = max(root->val, max(l.max, r.max));\\n      ans.min = min(root->val, min(l.min, r.min));\\n\\n      // Check if current tree is Bst or not ?\\n      ans.isbst = l.isbst && r.isbst && (l.max < root->val && r.min > root->val);\\n\\n      if(ans.isbst){\\n          ans.sum = l.sum + r.sum + root->val;\\n          ans.min = min(root->val, min(l.min, r.min));\\n          ans.max = max(root->val, max(l.max, r.max));\\n      }\\n      else\\n          ans.sum = max(l.sum, r.sum);\\n      \\n      res = max(res, ans.sum);\\n      return ans;\\n    }\\n    \\n    int res = INT_MIN;\\n    int maxSumBST(TreeNode* root) {\\n        Bst(root);\\n        return res > 0 ? res : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 990802,
                "title": "c-recursive-faster-than-99-with-explanation",
                "content": "From the definition of a BST, we can figure out that we need a recursive solution - in order to find out whether a subtree at a given node is a BST, we first need to find out whether its children are BSTs. Once we know that left and right subtrees of the node are BSTs, we need to check whether left subtree contains only values that are less than the node\\'s value, and right subtree contains values that are greater than the node\\'s value. Because we need multiple different values for each child, we can make our helper function return a structure with all those values. One more piece of inormation that is needed for calculating the max sum of any BST subtree would be the sum of all values in the subtree, and we can return it as part of our helper structure. Note that we can also solve this without ```isBst``` field in the structure if we use other fields to make up for it, but I think this way is more intuitive and more readable.\\n\\n```\\nclass Solution {\\n    struct S {\\n        bool isBST;\\n        int minVal, maxVal, sum;\\n    };\\n    \\n    S helper(TreeNode *node, int &res) {\\n        if (!node) {\\n            return { true, INT_MAX, INT_MIN, 0 };\\n        }\\n        S l = helper(node->left, res);\\n        S r = helper(node->right, res);\\n        if (l.isBST && r.isBST && l.maxVal < node->val && r.minVal > node->val) {\\n            int sum = l.sum + r.sum + node->val;\\n            res = max(res, sum);\\n            return { true, min(l.minVal, node->val), max(r.maxVal, node->val), sum };\\n        } else {\\n            return { false, 0, 0, 0 };\\n        }\\n    }\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int res = 0;\\n        helper(root, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```isBst```\n```\\nclass Solution {\\n    struct S {\\n        bool isBST;\\n        int minVal, maxVal, sum;\\n    };\\n    \\n    S helper(TreeNode *node, int &res) {\\n        if (!node) {\\n            return { true, INT_MAX, INT_MIN, 0 };\\n        }\\n        S l = helper(node->left, res);\\n        S r = helper(node->right, res);\\n        if (l.isBST && r.isBST && l.maxVal < node->val && r.minVal > node->val) {\\n            int sum = l.sum + r.sum + node->val;\\n            res = max(res, sum);\\n            return { true, min(l.minVal, node->val), max(r.maxVal, node->val), sum };\\n        } else {\\n            return { false, 0, 0, 0 };\\n        }\\n    }\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int res = 0;\\n        helper(root, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598444,
                "title": "java-easy-and-intuitive-solution-all-approaches-brute-to-optimal-99-78-faster",
                "content": "# Brute\\n**Code**\\n```java\\npublic class MaxSumBSTinBT {\\n    int maxsum = 0;\\n    public int maxSumBSTBrute(TreeNode root) {\\n        if(root == null) return 0;\\n\\n        if(isValidBST(root))\\n            maxsum = Math.max(maxsum, sumTree(root));\\n\\n        maxSumBSTBrute(root.left);\\n        maxSumBSTBrute(root.right);\\n\\n        return maxsum;\\n    }\\n\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBSTUtil(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    private boolean isValidBSTUtil(TreeNode root, long minRange, long maxRange) {\\n        if(root == null) return true;\\n\\n        if(root.val <= minRange || root.val >= maxRange) return false;\\n\\n        return isValidBSTUtil(root.left, minRange, root.val) && isValidBSTUtil(root.right, root.val, maxRange);\\n    }\\n\\n    public int sumTree(TreeNode root) {\\n        if(root == null) return 0;\\n\\n        return root.val + sumTree(root.left) + sumTree(root.right);\\n    }\\n}\\n```\\n\\n**Explanation**\\nThis code will give time limit exceeded when ran but this is very intuitive solution.\\nIn this we are doing following steps:\\n- we check at a particular node starting from root node that if the tree starting from this node is valid bst or not. \\n\\t- if it is then we update our maxsum value.\\n- then we call recursively on left and right subtree\\n- finally return maxsum value which is by default 0 as sum cannot be smaller than 0.\\n- \\n---\\n<br>\\n\\n# Brute - slightly better\\n```java\\npublic class MaxSumBSTinBTBetter {\\n    int maxsum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n\\n        boolean isBST = isValidBST(root);\\n        int[] sumAndNeg = new int[2];\\n        sumAndNeg = sumTree(root, sumAndNeg);\\n\\n        if(isBST)\\n            maxsum = Math.max(maxsum, sumAndNeg[0]);\\n\\n        if(!isBST || sumAndNeg[1] == 1) {\\n            maxSumBST(root.left);\\n            maxSumBST(root.right);\\n        }\\n\\n        return maxsum;\\n    }\\n\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBSTUtil(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    private boolean isValidBSTUtil(TreeNode root, long minRange, long maxRange) {\\n        if(root == null) return true;\\n\\n        if(root.val <= minRange || root.val >= maxRange) return false;\\n\\n        return isValidBSTUtil(root.left, minRange, root.val) && isValidBSTUtil(root.right, root.val, maxRange);\\n    }\\n\\n    public int[] sumTree(TreeNode root, int[] arr) {\\n        if(root == null) return new int[]{0, arr[1]};\\n\\n        if(root.val < 0) {\\n            arr[1] = 1;\\n        }\\n        arr[0] = root.val + sumTree(root.left, arr)[0] + sumTree(root.right, arr)[0];\\n        return arr;\\n    }\\n}\\n```\\n\\n**Explanation**\\nThis too will give time limit exceeded but I\\'ve included these to provide brute force solutions as well which are foundation for builing a solution, our next solution though will be optimal.\\nNow see in given figure\\n![image](https://assets.leetcode.com/users/images/7ab01813-9787-4c40-9eb6-e8d882452e0f_1638005873.081496.png)\\n\\nwhen we got to know that tree with root 3 is a bst why do we need to check for left and right subtree, when we could just return the sum of entire tree isn\\'t it?\\nNo. In the constraints we are given that tree also contains negative nodes for which sum could be reduced, so in this solution of ours we check if the tree doesn\\'t have any negative node then just don\\'t call on left and right otherwise do.\\n\\n---\\n<br>\\n\\n# Final Optimal Solution\\n\\n![image](https://assets.leetcode.com/users/images/f2dc9222-2289-4c11-9587-375b2369f9a5_1638006460.8124442.png)\\n\\n```java\\npublic class MaxSumBSTinBTOptimal {\\n    int maxsum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        postorder(root);\\n        return maxsum;\\n    }\\n\\n    private int[] postorder(TreeNode root) {\\n        if(root == null)\\n            return new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, 0}; // {min, max, sum}\\n\\n        // postorder -> Left Right Root\\n        int[] leftTree = postorder(root.left);\\n        int[] rightTree = postorder(root.right);\\n\\n        if(leftTree == null ||\\n                rightTree == null ||\\n                root.val <= leftTree[1] ||\\n                root.val >= rightTree[0]\\n        ) {\\n            return null;\\n        }\\n\\n        int sum = root.val + leftTree[2] + rightTree[2];\\n        maxsum = Math.max(maxsum, sum);\\n\\n        int max = Math.max(root.val, rightTree[1]);\\n        int min = Math.min(root.val, leftTree[0]);\\n\\n        return new int[]{min, max, sum};\\n    }\\n}\\n```\\n\\n**Explanation**\\nIn this solution we do a postorder traversal which is (Left -> Right -> Root) \\n\\nStep by step definition of algorithm goes as follow:-\\n- the array which is returned from postorder function contains 3 values, minimum from right subtree, maximum from left subtree, and sum of nodes in tree.\\n\\n```java\\nif(leftTree == null ||\\n\\t\\trightTree == null ||\\n\\t\\troot.val <= leftTree[1] ||\\n\\t\\troot.val >= rightTree[0]\\n) {\\n\\treturn null;\\n}\\n```\\n- This says that if either left subtree is not bst or right subtree is not a bst or root.val is less than maximum of left tree or greater than min from right then return null.\\n\\n- Then we calculate sum, min and max along with updating maxsum.\\n- then we return an array containing all 3.\\n\\nHope it helps\\nDo upvote and smile\\nThanks",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic class MaxSumBSTinBT {\\n    int maxsum = 0;\\n    public int maxSumBSTBrute(TreeNode root) {\\n        if(root == null) return 0;\\n\\n        if(isValidBST(root))\\n            maxsum = Math.max(maxsum, sumTree(root));\\n\\n        maxSumBSTBrute(root.left);\\n        maxSumBSTBrute(root.right);\\n\\n        return maxsum;\\n    }\\n\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBSTUtil(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    private boolean isValidBSTUtil(TreeNode root, long minRange, long maxRange) {\\n        if(root == null) return true;\\n\\n        if(root.val <= minRange || root.val >= maxRange) return false;\\n\\n        return isValidBSTUtil(root.left, minRange, root.val) && isValidBSTUtil(root.right, root.val, maxRange);\\n    }\\n\\n    public int sumTree(TreeNode root) {\\n        if(root == null) return 0;\\n\\n        return root.val + sumTree(root.left) + sumTree(root.right);\\n    }\\n}\\n```\n```java\\npublic class MaxSumBSTinBTBetter {\\n    int maxsum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n\\n        boolean isBST = isValidBST(root);\\n        int[] sumAndNeg = new int[2];\\n        sumAndNeg = sumTree(root, sumAndNeg);\\n\\n        if(isBST)\\n            maxsum = Math.max(maxsum, sumAndNeg[0]);\\n\\n        if(!isBST || sumAndNeg[1] == 1) {\\n            maxSumBST(root.left);\\n            maxSumBST(root.right);\\n        }\\n\\n        return maxsum;\\n    }\\n\\n    public boolean isValidBST(TreeNode root) {\\n        return isValidBSTUtil(root, Long.MIN_VALUE, Long.MAX_VALUE);\\n    }\\n\\n    private boolean isValidBSTUtil(TreeNode root, long minRange, long maxRange) {\\n        if(root == null) return true;\\n\\n        if(root.val <= minRange || root.val >= maxRange) return false;\\n\\n        return isValidBSTUtil(root.left, minRange, root.val) && isValidBSTUtil(root.right, root.val, maxRange);\\n    }\\n\\n    public int[] sumTree(TreeNode root, int[] arr) {\\n        if(root == null) return new int[]{0, arr[1]};\\n\\n        if(root.val < 0) {\\n            arr[1] = 1;\\n        }\\n        arr[0] = root.val + sumTree(root.left, arr)[0] + sumTree(root.right, arr)[0];\\n        return arr;\\n    }\\n}\\n```\n```java\\npublic class MaxSumBSTinBTOptimal {\\n    int maxsum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        postorder(root);\\n        return maxsum;\\n    }\\n\\n    private int[] postorder(TreeNode root) {\\n        if(root == null)\\n            return new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, 0}; // {min, max, sum}\\n\\n        // postorder -> Left Right Root\\n        int[] leftTree = postorder(root.left);\\n        int[] rightTree = postorder(root.right);\\n\\n        if(leftTree == null ||\\n                rightTree == null ||\\n                root.val <= leftTree[1] ||\\n                root.val >= rightTree[0]\\n        ) {\\n            return null;\\n        }\\n\\n        int sum = root.val + leftTree[2] + rightTree[2];\\n        maxsum = Math.max(maxsum, sum);\\n\\n        int max = Math.max(root.val, rightTree[1]);\\n        int min = Math.min(root.val, leftTree[0]);\\n\\n        return new int[]{min, max, sum};\\n    }\\n}\\n```\n```java\\nif(leftTree == null ||\\n\\t\\trightTree == null ||\\n\\t\\troot.val <= leftTree[1] ||\\n\\t\\troot.val >= rightTree[0]\\n) {\\n\\treturn null;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1897682,
                "title": "java-easy-to-understand-code",
                "content": "Hi, This code is self explanatory! Do Upvote if u like it.\\nAlso this can be used to find the maximum size of BST present in a binary tree with a slight modification.\\n\\n```\\nclass Solution {\\n    int maxSum = 0;  //maxSum initialized to maintain it at every step and made global so no need to pass in function\\n    class NodePair{ /// this class will be viewed as a single node of tree\\n        int min, max, sum;\\n    }\\n    public NodePair getSum(TreeNode root){\\n        if(root == null){  // if null then return sum 0 and minimum value as Int max and max value as Int min\\n            NodePair a = new NodePair();\\n            a.min = Integer.MAX_VALUE;\\n            a.max = Integer.MIN_VALUE;\\n            a.sum = 0;\\n            return a;\\n        }\\n        NodePair main = new NodePair();\\n        NodePair left = getSum(root.left);  //recursion till leftmost node\\n        NodePair right = getSum(root.right);  //recursion till rightmost node\\n        \\n        if(left.max < root.val && root.val < right.min){  //validating the bst\\n            main.min = Math.min(root.val, Math.min(left.min, right.min));\\n            main.max = Math.max(root.val, Math.max(left.max, right.max));\\n            main.sum = root.val + left.sum + right.sum;\\n            maxSum = Math.max(maxSum,main.sum);\\n        }\\n        else{\\n            main.min = Integer.MIN_VALUE;  // if not bst then just pass the sum calculated as of now\\n            main.max = Integer.MAX_VALUE;\\n            main.sum = Math.max(left.sum,right.sum);\\n        }\\n        return main;\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        NodePair temp = new NodePair();\\n        temp = getSum(root);\\n        return maxSum > 0 ? maxSum : 0;\\n    }\\n}\\n```\\n\\nThis is the code to find the size of maximum BST :\\n\\n```\\nclass Solution {\\n    class NodePair{ /// this class will be viewed as a single node of tree\\n        int min, max, size;\\n    }\\n    public NodePair getSize(TreeNode root){\\n        if(root == null){  // if null then return size 0 and minimum value as Int max and max value as Int min\\n            NodePair a = new NodePair();\\n            a.min = Integer.MAX_VALUE;\\n            a.max = Integer.MIN_VALUE;\\n            a.size = 0;\\n            return a;\\n        }\\n        NodePair main = new NodePair();\\n        NodePair left = getSize(root.left);  //recursion till leftmost node\\n        NodePair right = getSize(root.right);  //recursion till rightmost node\\n        \\n        if(left.max < root.val && root.val < right.min){  //validating the bst\\n            main.min = Math.min(root.val, Math.min(left.min, right.min));\\n            main.max = Math.max(root.val, Math.max(left.max, right.max));\\n            main.size = 1 + left.size + right.size;\\n        }\\n        else{\\n            main.min = Integer.MIN_VALUE;  // if not bst then just pass the size calculated as of now\\n            main.max = Integer.MAX_VALUE;\\n            main.size = Math.max(left.size,right.size);\\n        }\\n        return main;\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        return getSize(root).size;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int maxSum = 0;  //maxSum initialized to maintain it at every step and made global so no need to pass in function\\n    class NodePair{ /// this class will be viewed as a single node of tree\\n        int min, max, sum;\\n    }\\n    public NodePair getSum(TreeNode root){\\n        if(root == null){  // if null then return sum 0 and minimum value as Int max and max value as Int min\\n            NodePair a = new NodePair();\\n            a.min = Integer.MAX_VALUE;\\n            a.max = Integer.MIN_VALUE;\\n            a.sum = 0;\\n            return a;\\n        }\\n        NodePair main = new NodePair();\\n        NodePair left = getSum(root.left);  //recursion till leftmost node\\n        NodePair right = getSum(root.right);  //recursion till rightmost node\\n        \\n        if(left.max < root.val && root.val < right.min){  //validating the bst\\n            main.min = Math.min(root.val, Math.min(left.min, right.min));\\n            main.max = Math.max(root.val, Math.max(left.max, right.max));\\n            main.sum = root.val + left.sum + right.sum;\\n            maxSum = Math.max(maxSum,main.sum);\\n        }\\n        else{\\n            main.min = Integer.MIN_VALUE;  // if not bst then just pass the sum calculated as of now\\n            main.max = Integer.MAX_VALUE;\\n            main.sum = Math.max(left.sum,right.sum);\\n        }\\n        return main;\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        NodePair temp = new NodePair();\\n        temp = getSum(root);\\n        return maxSum > 0 ? maxSum : 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    class NodePair{ /// this class will be viewed as a single node of tree\\n        int min, max, size;\\n    }\\n    public NodePair getSize(TreeNode root){\\n        if(root == null){  // if null then return size 0 and minimum value as Int max and max value as Int min\\n            NodePair a = new NodePair();\\n            a.min = Integer.MAX_VALUE;\\n            a.max = Integer.MIN_VALUE;\\n            a.size = 0;\\n            return a;\\n        }\\n        NodePair main = new NodePair();\\n        NodePair left = getSize(root.left);  //recursion till leftmost node\\n        NodePair right = getSize(root.right);  //recursion till rightmost node\\n        \\n        if(left.max < root.val && root.val < right.min){  //validating the bst\\n            main.min = Math.min(root.val, Math.min(left.min, right.min));\\n            main.max = Math.max(root.val, Math.max(left.max, right.max));\\n            main.size = 1 + left.size + right.size;\\n        }\\n        else{\\n            main.min = Integer.MIN_VALUE;  // if not bst then just pass the size calculated as of now\\n            main.max = Integer.MAX_VALUE;\\n            main.size = Math.max(left.size,right.size);\\n        }\\n        return main;\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        return getSize(root).size;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549773,
                "title": "well-commented-c-solution-intuitive-but-efficient-solution",
                "content": "Intuitive solution which handles all cases well.\\n\\n```\\nclass Solution {\\npublic:\\n \\n//ans will store our final ans     \\nint ans =0;\\n\\nstruct str{\\n    int stn; // Sum till now of the present node value and it\\'s left and right subtree \\n    int max; // Min value in subtree \\n    int min; // Max value in subtree \\n    int ans; // Sum of largest BST which which is a subtree of the present node \\n    bool isBST; // If subtree is BST \\n}; \\n \\n  \\nstr util(TreeNode* root){\\n    \\n    //if root is NULL\\n    if (root == NULL) \\n        return {0, INT_MIN, INT_MAX, 0, true}; \\n    \\n    //if root is a leaf node\\n    if (root->left == NULL && root->right == NULL) \\n        return {root->val, root->val, root->val, root->val, true}; \\n \\n    //recurring for the left and right subtrees\\n    str lt = util(root->left); \\n    str rt = util(root->right); \\n    \\n    //create a structure to return the values for the current node\\n    str ret_cur; \\n    ret_cur.stn = (root->val + lt.stn + rt.stn);\\n    \\n    // If whole tree rooted under current root is BST\\n    if (lt.isBST && rt.isBST && lt.max < root->val && rt.min > root->val) {\\n        \\n        //update the max and the min for the present node\\n        ret_cur.min = min(lt.min, root->val); \\n        ret_cur.max = max(rt.max, root->val); \\n        \\n        //update answer for tree rooted under current \\'root\\' \\n        ret_cur.ans = ret_cur.stn; \\n        ret_cur.isBST = true; \\n        \\n        //update the overall final ans\\n        ans = max(ans, ret_cur.ans);\\n        \\n        //return the ret_cur to the calling function\\n        return ret_cur;\\n        \\n    }\\n   \\n    //if whole tree is not BST, return maximum of left and right subtrees \\n    ret_cur.ans = max(lt.ans, rt.ans);\\n    \\n    //update the overall final ans\\n    ans = max(ret_cur.ans,ans);\\n    \\n    //since the tree rooted with the current node is not a  BST\\n    ret_cur.isBST = false; \\n  \\n    //return the ret_cur\\n    return ret_cur; \\n} \\n\\n    \\n    \\nint maxSumBST(TreeNode* root) {\\n    //return 0 for the base case when the given tree is NULL\\n    if(root==NULL)\\n\\t    return 0;\\n    return max(ans,util(root).ans);\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n \\n//ans will store our final ans     \\nint ans =0;\\n\\nstruct str{\\n    int stn; // Sum till now of the present node value and it\\'s left and right subtree \\n    int max; // Min value in subtree \\n    int min; // Max value in subtree \\n    int ans; // Sum of largest BST which which is a subtree of the present node \\n    bool isBST; // If subtree is BST \\n}; \\n \\n  \\nstr util(TreeNode* root){\\n    \\n    //if root is NULL\\n    if (root == NULL) \\n        return {0, INT_MIN, INT_MAX, 0, true}; \\n    \\n    //if root is a leaf node\\n    if (root->left == NULL && root->right == NULL) \\n        return {root->val, root->val, root->val, root->val, true}; \\n \\n    //recurring for the left and right subtrees\\n    str lt = util(root->left); \\n    str rt = util(root->right); \\n    \\n    //create a structure to return the values for the current node\\n    str ret_cur; \\n    ret_cur.stn = (root->val + lt.stn + rt.stn);\\n    \\n    // If whole tree rooted under current root is BST\\n    if (lt.isBST && rt.isBST && lt.max < root->val && rt.min > root->val) {\\n        \\n        //update the max and the min for the present node\\n        ret_cur.min = min(lt.min, root->val); \\n        ret_cur.max = max(rt.max, root->val); \\n        \\n        //update answer for tree rooted under current \\'root\\' \\n        ret_cur.ans = ret_cur.stn; \\n        ret_cur.isBST = true; \\n        \\n        //update the overall final ans\\n        ans = max(ans, ret_cur.ans);\\n        \\n        //return the ret_cur to the calling function\\n        return ret_cur;\\n        \\n    }\\n   \\n    //if whole tree is not BST, return maximum of left and right subtrees \\n    ret_cur.ans = max(lt.ans, rt.ans);\\n    \\n    //update the overall final ans\\n    ans = max(ret_cur.ans,ans);\\n    \\n    //since the tree rooted with the current node is not a  BST\\n    ret_cur.isBST = false; \\n  \\n    //return the ret_cur\\n    return ret_cur; \\n} \\n\\n    \\n    \\nint maxSumBST(TreeNode* root) {\\n    //return 0 for the base case when the given tree is NULL\\n    if(root==NULL)\\n\\t    return 0;\\n    return max(ans,util(root).ans);\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2406626,
                "title": "c-most-detailed-explaination-each-line-of-code-explained",
                "content": "## Approach\\n--> we will start from `leaf nodes` and for any node we will first find answer for it\\'s children means it\\'s `left and right nodes` so for that we need a traversal technique which will first find answer for left and right and then for root. so this traversal is `Post order(left -> right -> root)`.\\n\\nNow we know 2 things till now:\\n\\n```\\n1. we will start from leaf nodes\\n2. we will use postorder\\n```\\n\\n==> Now first we have to check if any subtree is valid BST or not and for that any node have to satisfy these 2 conditions:\\n\\n```\\n1. Current node\\'s value must be greater than maximum value in it\\'s left subtree\\n2. Current node\\'s value must be smaller than minimum value in it\\'s right subtree\\n```\\n\\n--> Now for each node we will store `4` things:\\n\\n```\\n1. If it\\'s subtree(Including that node itself) is BST or not\\n2. Max sum till now\\n3. minimum value in that tree\\n4. maximum value in that tree\\n```\\n\\n--> Now the question is how we can store these values?\\n\\nSo we can use `pair` or we can use `Class` or `struct` so store these 4 values for each node.\\n\\nThe class will look like this:\\n\\n```cpp\\nclass Info {\\n    public:\\n        int ms; // maximum sum till now\\n        int mini; // minimum value in tree\\n        int maxi; // maximum value in tree\\n        bool isbst; // true if current tree is bst or false.\\n        // default values\\n        Info(){\\n            ms = 0;\\n            mini = INT_MAX;\\n            maxi = INT_MIN;\\n            isbst = true;\\n        }\\n};\\n```\\n\\nNow for each node, we will first find answers for it\\'s left and right subtree (In postorder manner).\\n\\n```cpp\\nInfo node;\\nInfo nodeleft = solve(root->left);\\nInfo noderight = solve(root->right);\\n```\\n\\nNow we have answers for it\\'s left and right subtree now we just have to check if `The subtree is BST including the current node` and we already know the conditions:\\n\\n```\\n1. nodeleft.isbst must be true\\n2. noderight.isbst must be true\\n3. the max value of leftsubtree i.e. nodeleft.maxi must be lower than root->val\\n4. the min value of rightsubtree i.e. noderight.mini must be greater than root->val\\n```\\n\\nIf it satisfies all 4 conditions then we know that `it\\'s a BST`. so we will add `root->val` in `nodeleft.ms + noderight.ms` which will be total sum of this tree.\\n\\n- `node.mini` will be minimum value of `root->val` and `nodeleft.mini`\\n- `node.maxi` will be maximum value of `root->val` and `noderight.maxi`\\n\\nLet\\'s see this part in code:\\n\\n```cpp\\nif(nodeleft.isbst && noderight.isbst && root->val > nodeleft.maxi && root->val < noderight.mini){\\n\\tnode.isbst = true;\\n\\tnode.ms = root->val + nodeleft.ms + noderight.ms;\\n\\tnode.mini = min(root->val,nodeleft.mini);\\n\\tnode.maxi = max(root->val,noderight.maxi);\\n}\\n```\\n\\n--> Now if the above conditions is false then we will mark `node.isbst` as false but `node.ms` will be maximum of `nodeleft.ms and noderight.ms` because we might found any answer in any one of the subtree so we will **not** reset it.\\n\\n```cpp\\nelse{\\n\\tnode.isbst = false;\\n\\tnode.ms = max(nodeleft.ms,noderight.ms);\\n}\\n```\\n\\n>Remember that node.mini and node.maxi will not be changed in this case so it will have the default values which are `INT_MAX` and `INT_MIN`.\\n\\n--> At last maintain one global variable `ans` which will be our final answer and modify our ans and return `node`.\\n\\n```cpp\\nans = max(ans,node.ms);\\nreturn node;\\n```\\n\\n---\\n\\n--> So now let\\'s see the full code:\\n\\n## Final Code:\\n\\n```cpp\\nclass Info {\\n    public:\\n        int ms;\\n        int mini;\\n        int maxi;\\n        bool isbst;\\n        Info(){\\n            ms = 0;\\n            mini = INT_MAX;\\n            maxi = INT_MIN;\\n            isbst = true;\\n        }\\n};\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    Info solve(TreeNode* root){\\n        if(root == NULL){\\n            return Info();\\n        }      \\n        Info node;\\n        Info nodeleft = solve(root->left);\\n        Info noderight = solve(root->right);\\n        if(nodeleft.isbst && noderight.isbst && root->val > nodeleft.maxi && root->val < noderight.mini){\\n            node.isbst = true;\\n            node.ms = root->val + nodeleft.ms + noderight.ms;\\n            node.mini = min(root->val,nodeleft.mini);\\n            node.maxi = max(root->val,noderight.maxi);\\n        }\\n        else{\\n            node.isbst = false;\\n            node.ms = max(nodeleft.ms,noderight.ms);\\n        }\\n        ans = max(ans,node.ms);\\n        return node;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n```\\n---\\n\\nIf you liked this explaination then please upvote \\uD83D\\uDE00 and if you want more explainations like this then checkout it [here](https://github.com/shivam1317/DSA-Notes).\\n\\nThanks for reading.",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n1. we will start from leaf nodes\\n2. we will use postorder\\n```\n```\\n1. Current node\\'s value must be greater than maximum value in it\\'s left subtree\\n2. Current node\\'s value must be smaller than minimum value in it\\'s right subtree\\n```\n```\\n1. If it\\'s subtree(Including that node itself) is BST or not\\n2. Max sum till now\\n3. minimum value in that tree\\n4. maximum value in that tree\\n```\n```cpp\\nclass Info {\\n    public:\\n        int ms; // maximum sum till now\\n        int mini; // minimum value in tree\\n        int maxi; // maximum value in tree\\n        bool isbst; // true if current tree is bst or false.\\n        // default values\\n        Info(){\\n            ms = 0;\\n            mini = INT_MAX;\\n            maxi = INT_MIN;\\n            isbst = true;\\n        }\\n};\\n```\n```cpp\\nInfo node;\\nInfo nodeleft = solve(root->left);\\nInfo noderight = solve(root->right);\\n```\n```\\n1. nodeleft.isbst must be true\\n2. noderight.isbst must be true\\n3. the max value of leftsubtree i.e. nodeleft.maxi must be lower than root->val\\n4. the min value of rightsubtree i.e. noderight.mini must be greater than root->val\\n```\n```cpp\\nif(nodeleft.isbst && noderight.isbst && root->val > nodeleft.maxi && root->val < noderight.mini){\\n\\tnode.isbst = true;\\n\\tnode.ms = root->val + nodeleft.ms + noderight.ms;\\n\\tnode.mini = min(root->val,nodeleft.mini);\\n\\tnode.maxi = max(root->val,noderight.maxi);\\n}\\n```\n```cpp\\nelse{\\n\\tnode.isbst = false;\\n\\tnode.ms = max(nodeleft.ms,noderight.ms);\\n}\\n```\n```cpp\\nans = max(ans,node.ms);\\nreturn node;\\n```\n```cpp\\nclass Info {\\n    public:\\n        int ms;\\n        int mini;\\n        int maxi;\\n        bool isbst;\\n        Info(){\\n            ms = 0;\\n            mini = INT_MAX;\\n            maxi = INT_MIN;\\n            isbst = true;\\n        }\\n};\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    Info solve(TreeNode* root){\\n        if(root == NULL){\\n            return Info();\\n        }      \\n        Info node;\\n        Info nodeleft = solve(root->left);\\n        Info noderight = solve(root->right);\\n        if(nodeleft.isbst && noderight.isbst && root->val > nodeleft.maxi && root->val < noderight.mini){\\n            node.isbst = true;\\n            node.ms = root->val + nodeleft.ms + noderight.ms;\\n            node.mini = min(root->val,nodeleft.mini);\\n            node.maxi = max(root->val,noderight.maxi);\\n        }\\n        else{\\n            node.isbst = false;\\n            node.ms = max(nodeleft.ms,noderight.ms);\\n        }\\n        ans = max(ans,node.ms);\\n        return node;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        solve(root);\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245609,
                "title": "c-simple-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n\\t// here mx and mn are used to find minimum and maximum node in the current subtree\\n\\t// function return the sum of nodes of the subtree.\\n\\t\\n    int rec(TreeNode *root,int &mx,int &mn,int &a)\\n    {\\n        if(!root) return 0;\\n        \\n\\t// lmn,lmx will find the minimum and maximum node in the left subtree \\n\\t// similarly, rmn,rmx will find minimum and maximum node in the right subtree\\n\\t\\t\\n        int lmn,rmn,rmx,lmx;\\n        \\n        lmn=rmn=INT_MAX;\\n        lmx=rmx=INT_MIN;\\n\\t\\t\\n        int l=rec(root->left,lmx,lmn,a);\\n        int r=rec(root->right,rmx,rmn,a);\\n        \\n        int val=l+r+root->val;\\n    \\n\\t// if the left maximum is less than and right minimum is greater than current node\\n\\t// than the subtree rooted at current node is BST.\\n\\t\\t\\n        if((lmx<(root->val)) and (rmn>(root->val)))\\n        {\\n            a=max(a,val);\\n            mx=max(root->val,rmx);\\n            mn=min(root->val,lmn);\\n        }\\n        else\\n        {\\n            mx=INT_MAX;\\n            mn=INT_MIN;\\n        }\\n        return val;        \\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        int a=0;\\n        int mx=INT_MIN,mn=INT_MAX;\\n        rec(root,mx,mn,a);\\n        return a;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n*  Time - O(n)\\n*  Space - O(h) , h is height of tree\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// here mx and mn are used to find minimum and maximum node in the current subtree\\n\\t// function return the sum of nodes of the subtree.\\n\\t\\n    int rec(TreeNode *root,int &mx,int &mn,int &a)\\n    {\\n        if(!root) return 0;\\n        \\n\\t// lmn,lmx will find the minimum and maximum node in the left subtree \\n\\t// similarly, rmn,rmx will find minimum and maximum node in the right subtree\\n\\t\\t\\n        int lmn,rmn,rmx,lmx;\\n        \\n        lmn=rmn=INT_MAX;\\n        lmx=rmx=INT_MIN;\\n\\t\\t\\n        int l=rec(root->left,lmx,lmn,a);\\n        int r=rec(root->right,rmx,rmn,a);\\n        \\n        int val=l+r+root->val;\\n    \\n\\t// if the left maximum is less than and right minimum is greater than current node\\n\\t// than the subtree rooted at current node is BST.\\n\\t\\t\\n        if((lmx<(root->val)) and (rmn>(root->val)))\\n        {\\n            a=max(a,val);\\n            mx=max(root->val,rmx);\\n            mn=min(root->val,lmn);\\n        }\\n        else\\n        {\\n            mx=INT_MAX;\\n            mn=INT_MIN;\\n        }\\n        return val;        \\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        int a=0;\\n        int mx=INT_MIN,mn=INT_MAX;\\n        rec(root,mx,mn,a);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684444,
                "title": "java-simple-dfs-use-output-class",
                "content": "```\\nclass Solution {\\n    int res = 0;\\n    public class Output{\\n        boolean bst;\\n        int sum, min, max;\\n        public Output(boolean bst, int sum, int min, int max) {\\n            this.bst = bst;\\n            this.sum = sum;\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root);\\n        return res;\\n    }\\n    \\n    private Output dfs(TreeNode node) {\\n        boolean isBST = false;\\n        int sum = 0, min = 0, max = 0;\\n        if (node.left == null && node.right == null) {\\n            res = Math.max(res, node.val);\\n            return new Output(true, node.val, node.val, node.val);\\n        }\\n        if (node.left == null) {\\n            Output right = dfs(node.right);\\n            isBST = right.bst && node.val < right.min;\\n            if (isBST) res = Math.max(res, node.val + right.sum);\\n            return new Output(isBST, node.val + right.sum, node.val, right.max);\\n        }\\n        \\n        if (node.right == null) {\\n            Output left = dfs(node.left);\\n            isBST = left.bst && node.val > left.max;\\n            if (isBST) res = Math.max(res, node.val + left.sum);\\n            return new Output(isBST, node.val + left.sum, left.min, node.val);\\n        }\\n        \\n        Output left = dfs(node.left), right = dfs(node.right);\\n        isBST = left.bst && right.bst && node.val > left.max && node.val < right.min;\\n        if (isBST) res = Math.max(res, node.val + left.sum + right.sum);\\n        return new Output(isBST, node.val + left.sum + right.sum, left.min, right.max);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int res = 0;\\n    public class Output{\\n        boolean bst;\\n        int sum, min, max;\\n        public Output(boolean bst, int sum, int min, int max) {\\n            this.bst = bst;\\n            this.sum = sum;\\n            this.min = min;\\n            this.max = max;\\n        }\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        if (root == null) return 0;\\n        dfs(root);\\n        return res;\\n    }\\n    \\n    private Output dfs(TreeNode node) {\\n        boolean isBST = false;\\n        int sum = 0, min = 0, max = 0;\\n        if (node.left == null && node.right == null) {\\n            res = Math.max(res, node.val);\\n            return new Output(true, node.val, node.val, node.val);\\n        }\\n        if (node.left == null) {\\n            Output right = dfs(node.right);\\n            isBST = right.bst && node.val < right.min;\\n            if (isBST) res = Math.max(res, node.val + right.sum);\\n            return new Output(isBST, node.val + right.sum, node.val, right.max);\\n        }\\n        \\n        if (node.right == null) {\\n            Output left = dfs(node.left);\\n            isBST = left.bst && node.val > left.max;\\n            if (isBST) res = Math.max(res, node.val + left.sum);\\n            return new Output(isBST, node.val + left.sum, left.min, node.val);\\n        }\\n        \\n        Output left = dfs(node.left), right = dfs(node.right);\\n        isBST = left.bst && right.bst && node.val > left.max && node.val < right.min;\\n        if (isBST) res = Math.max(res, node.val + left.sum + right.sum);\\n        return new Output(isBST, node.val + left.sum + right.sum, left.min, right.max);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 571513,
                "title": "python-recursion-easy-to-understand",
                "content": "```python\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        self.ans = 0\\n        \\n        def maxSum(root):\\n            if not root:\\n                return True, [float(\\'inf\\'), float(\\'-inf\\')], 0\\n            \\n            l, l_range, l_sum = maxSum(root.left)\\n            r, r_range, r_sum = maxSum(root.right)\\n            \\n            if l and r and l_range[1] < root.val < r_range[0]:\\n                total = l_sum + r_sum + root.val\\n                self.ans = max(self.ans, total)\\n                return True, [min(l_range[0], root.val), max(r_range[1], root.val)], total\\n            \\n            return False, [float(\\'inf\\'), float(\\'-inf\\')], None\\n        \\n        _, __, ___ = maxSum(root)\\n        return self.ans\\n```\\n\\nuse bottom-up way to return a bool to indicate if subtree is valid bst and a range and sum of the subtree.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        self.ans = 0\\n        \\n        def maxSum(root):\\n            if not root:\\n                return True, [float(\\'inf\\'), float(\\'-inf\\')], 0\\n            \\n            l, l_range, l_sum = maxSum(root.left)\\n            r, r_range, r_sum = maxSum(root.right)\\n            \\n            if l and r and l_range[1] < root.val < r_range[0]:\\n                total = l_sum + r_sum + root.val\\n                self.ans = max(self.ans, total)\\n                return True, [min(l_range[0], root.val), max(r_range[1], root.val)], total\\n            \\n            return False, [float(\\'inf\\'), float(\\'-inf\\')], None\\n        \\n        _, __, ___ = maxSum(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505666,
                "title": "c-easy-with-t-c-o-n-love-babbar-s-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCheck Left Subtree valid or not,\\nthen check right subtree is valid or not,\\nthen check maxLeft < root->data < minRight to confirm if it\\'s a BST\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need 3 variables of type int: maxi, mini, sum.\\nAnd 1 bool type: isBST\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\nclass info\\n{\\n    public: \\n    int maxi;\\n    int mini;\\n    bool isBST;\\n    int sum;\\n};\\n\\ninfo solve(TreeNode* root, int &ans)\\n{\\n    // base case\\n    if(root==NULL)\\n    {\\n        return {INT_MIN, INT_MAX, true, 0};\\n    }\\n\\n    info left=solve(root->left, ans);\\n    info right=solve(root->right, ans);\\n\\n    info currNode;\\n\\n    currNode.sum=left.sum + right.sum + root->val;\\n    currNode.maxi=max(root->val, right.maxi);\\n    currNode.mini=min(root->val, left.mini);\\n\\n    if(left.isBST && right.isBST && (root->val > left.maxi && root->val < right.mini))\\n    {\\n        currNode.isBST=true;\\n    }\\n    else\\n    {\\n        currNode.isBST=false;\\n    }\\n\\n    // answer update\\n    if(currNode.isBST)\\n    {\\n        ans=max(ans, currNode.sum);\\n    }\\n\\n    return currNode;\\n}\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n        int maxSum=0;\\n        info temp=solve(root, maxSum);\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\nclass info\\n{\\n    public: \\n    int maxi;\\n    int mini;\\n    bool isBST;\\n    int sum;\\n};\\n\\ninfo solve(TreeNode* root, int &ans)\\n{\\n    // base case\\n    if(root==NULL)\\n    {\\n        return {INT_MIN, INT_MAX, true, 0};\\n    }\\n\\n    info left=solve(root->left, ans);\\n    info right=solve(root->right, ans);\\n\\n    info currNode;\\n\\n    currNode.sum=left.sum + right.sum + root->val;\\n    currNode.maxi=max(root->val, right.maxi);\\n    currNode.mini=min(root->val, left.mini);\\n\\n    if(left.isBST && right.isBST && (root->val > left.maxi && root->val < right.mini))\\n    {\\n        currNode.isBST=true;\\n    }\\n    else\\n    {\\n        currNode.isBST=false;\\n    }\\n\\n    // answer update\\n    if(currNode.isBST)\\n    {\\n        ans=max(ans, currNode.sum);\\n    }\\n\\n    return currNode;\\n}\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n        int maxSum=0;\\n        info temp=solve(root, maxSum);\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297160,
                "title": "c-dfs-validate-binary-search-tree-extra-step-o-n",
                "content": "This is basically [98. Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/) with extra step of calculating the sum of each valid subtree.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        \\n        helper(root, ans);\\n        \\n        return ans;\\n    }\\n    \\n    tuple<int, int, int> helper(TreeNode* root, int& ans) { // min, max, sum\\n        if (not root) {\\n            // base case\\n            return {INT_MAX, INT_MIN, 0};\\n        }\\n        \\n        auto [leftMin, leftMax, leftSum] = helper(root->left, ans);\\n        auto [rightMin, rightMax, rightSum] = helper(root->right, ans);\\n        \\n        if (root->val > leftMax and root->val < rightMin) {\\n            // valid bst\\n            int sum = leftSum + root->val + rightSum;\\n            ans = max(ans, sum);\\n\\n            return {min(root->val, leftMin), max(root->val, rightMax), sum};\\n        }\\n        \\n        // invalid bst\\n        return {INT_MIN, INT_MAX, 0};\\n    }\\n};\\n```\\n\\nTime complexity - O(N).\\nSpace complexity - O(H).",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        \\n        helper(root, ans);\\n        \\n        return ans;\\n    }\\n    \\n    tuple<int, int, int> helper(TreeNode* root, int& ans) { // min, max, sum\\n        if (not root) {\\n            // base case\\n            return {INT_MAX, INT_MIN, 0};\\n        }\\n        \\n        auto [leftMin, leftMax, leftSum] = helper(root->left, ans);\\n        auto [rightMin, rightMax, rightSum] = helper(root->right, ans);\\n        \\n        if (root->val > leftMax and root->val < rightMin) {\\n            // valid bst\\n            int sum = leftSum + root->val + rightSum;\\n            ans = max(ans, sum);\\n\\n            return {min(root->val, leftMin), max(root->val, rightMax), sum};\\n        }\\n        \\n        // invalid bst\\n        return {INT_MIN, INT_MAX, 0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531967,
                "title": "python-easy-to-understand-recursive-solution",
                "content": "The code is straightforward. Key is to accumulate the sum bottom-up and nullify the sum once the BST property is violated.\\n```python\\ndef maxSumBST(self, root: TreeNode) -> int:\\n    if not root:\\n        return 0\\n    self.s = 0\\n    def helper(cur):\\n        a, amin, amax = helper(cur.left) if cur.left else (0, float(\\'inf\\'), float(\\'-inf\\'))\\n        b, bmin, bmax = helper(cur.right) if cur.right else (0, float(\\'inf\\'), float(\\'-inf\\'))\\n        if a is not None and b is not None:\\n            if cur.val > amax and cur.val < bmin:\\n                s = cur.val + a + b\\n                self.s = max(self.s, s)\\n                return s, min(cur.val, amin), max(cur.val, bmax)\\n        return (None, None, None)\\n    helper(root)\\n    return self.s\\n```\\nVote up if you find this helpful, thanks!\\n\\n**Edit**: an issue suggested by [jesus805](https://leetcode.com/jesus805) in the original solution has been fixed.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef maxSumBST(self, root: TreeNode) -> int:\\n    if not root:\\n        return 0\\n    self.s = 0\\n    def helper(cur):\\n        a, amin, amax = helper(cur.left) if cur.left else (0, float(\\'inf\\'), float(\\'-inf\\'))\\n        b, bmin, bmax = helper(cur.right) if cur.right else (0, float(\\'inf\\'), float(\\'-inf\\'))\\n        if a is not None and b is not None:\\n            if cur.val > amax and cur.val < bmin:\\n                s = cur.val + a + b\\n                self.s = max(self.s, s)\\n                return s, min(cur.val, amin), max(cur.val, bmax)\\n        return (None, None, None)\\n    helper(root)\\n    return self.s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1467928,
                "title": "recursion-c-post-order-traversal",
                "content": "```\\nclass DataNode{          // To keep track of min max value, sum of subtree below it and if subtree rooted at current node is BST or not.\\npublic:\\n    int minVal = INT_MAX;\\n    int maxVal = INT_MIN;\\n    int sum = 0;\\n    bool isBST = false;\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    int maxSum = 0;\\n    \\n    DataNode solve(TreeNode* root)\\n    {\\n        if(!root) return {INT_MAX, INT_MIN, 0, true};\\n        \\n        if(!root->left && !root->right)                  // If leaf node then return it as a BST\\n        {\\n            maxSum = max(maxSum, root->val);\\n            return {root->val, root->val, root->val, true};\\n        }\\n        \\n        DataNode left = solve(root->left);                 // Left node Data\\n        DataNode right = solve(root->right);           // Right node Data\\n      \\n        int sum = left.sum + right.sum + root->val;    // Sum of subtree rooted at current node\\n        bool isBST = false;\\n        \\n        if(left.maxVal < root->val && right.minVal > root->val && left.isBST && right.isBST)   // Check if current node is BST or not\\n        {   \\n            isBST = true;                // Mark it as true, i.e BST\\n            maxSum = max(maxSum, sum);       // Also find the maximum sum of subtree\\n        }\\n        \\n        return {min(root->val, left.minVal), max(root->val, right.maxVal), sum, isBST};\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        \\n        solve(root);\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass DataNode{          // To keep track of min max value, sum of subtree below it and if subtree rooted at current node is BST or not.\\npublic:\\n    int minVal = INT_MAX;\\n    int maxVal = INT_MIN;\\n    int sum = 0;\\n    bool isBST = false;\\n};\\n\\nclass Solution {\\npublic:\\n    \\n    int maxSum = 0;\\n    \\n    DataNode solve(TreeNode* root)\\n    {\\n        if(!root) return {INT_MAX, INT_MIN, 0, true};\\n        \\n        if(!root->left && !root->right)                  // If leaf node then return it as a BST\\n        {\\n            maxSum = max(maxSum, root->val);\\n            return {root->val, root->val, root->val, true};\\n        }\\n        \\n        DataNode left = solve(root->left);                 // Left node Data\\n        DataNode right = solve(root->right);           // Right node Data\\n      \\n        int sum = left.sum + right.sum + root->val;    // Sum of subtree rooted at current node\\n        bool isBST = false;\\n        \\n        if(left.maxVal < root->val && right.minVal > root->val && left.isBST && right.isBST)   // Check if current node is BST or not\\n        {   \\n            isBST = true;                // Mark it as true, i.e BST\\n            maxSum = max(maxSum, sum);       // Also find the maximum sum of subtree\\n        }\\n        \\n        return {min(root->val, left.minVal), max(root->val, right.maxVal), sum, isBST};\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        \\n        solve(root);\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532019,
                "title": "python-post-order-checking-bst-and-sum-up-in-single-round-356-ms",
                "content": "Write an auxiliary function to recursively check if a tree rooted with node `r` is a BST, if it is, return True and the sum of the tree at the same time. Every time you get a valid tree sum, append it to the `res`.\\n\\nPlease note that in this problem, null nodes connected to the leaf nodes can also be considered as a valid node/subtree with sum 0. So example 3 returns 0 instead of any negative node.\\n\\n```py\\nclass Solution:\\n    def isBST(self, r):\\n        if not r:\\n            return True, 0\\n        is_left, left_sum = self.isBST(r.left)\\n        is_right, right_sum = self.isBST(r.right)\\n        if (r.left and r.left.val >= r.val) or (r.right and r.right.val <= r.val):\\n            return False, 0\\n        if is_left and is_right:\\n            s = left_sum + right_sum + r.val\\n            self.res.append(s)\\n            return True, s\\n        return False, 0\\n\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        self.res = []\\n        self.isBST(root)\\n        if self.res:\\n            return max(max(self.res), 0)\\n        else:\\n            return 0\\n```\\n\\n",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def isBST(self, r):\\n        if not r:\\n            return True, 0\\n        is_left, left_sum = self.isBST(r.left)\\n        is_right, right_sum = self.isBST(r.right)\\n        if (r.left and r.left.val >= r.val) or (r.right and r.right.val <= r.val):\\n            return False, 0\\n        if is_left and is_right:\\n            s = left_sum + right_sum + r.val\\n            self.res.append(s)\\n            return True, s\\n        return False, 0\\n\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        self.res = []\\n        self.isBST(root)\\n        if self.res:\\n            return max(max(self.res), 0)\\n        else:\\n            return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906030,
                "title": "c-recursive-post-order-traversal-using-object-oriented-programming-o-n",
                "content": "Hi all, \\nI solved this question using post order traversal which took TC- O(n). For mainitaining BST data, I have made a NodeData class which stores cumulative sum and cumulative maxSum for the valid BSTs. I tried applying OOP principles here. \\n\\nHave a look and do let me know in comments your thoughts.\\n```\\nclass NodeData{\\nprivate:\\n    int mini;\\n    int maxi;\\n    int sum;\\n    int maxSum;\\npublic:\\n    NodeData(int mini, int maxi, int sum, int maxSum){\\n        this->mini=mini;\\n        this->maxi=maxi;\\n        this->sum=sum;\\n        this->maxSum=maxSum;\\n    }\\n    int getsum(){\\n        return sum;\\n    }\\n    int getmaxi(){\\n        return maxi;\\n    }\\n    int getmini(){\\n        return mini;\\n    }\\n    int getmaxSum(){\\n        return maxSum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    NodeData maxBST(TreeNode* root){\\n        if(!root) return NodeData(INT_MAX,INT_MIN,0,INT_MIN);\\n        \\n        NodeData left = maxBST(root->left);\\n        NodeData right = maxBST(root->right);\\n        \\n        if(left.getmaxi() < root->val && right.getmini() > root->val){\\n            \\n            return NodeData(min(left.getmini(), root->val), max(right.getmaxi(), root->val), root->val + left.getsum() + right.getsum(), max(max(left.getmaxSum(), right.getmaxSum()), root->val + left.getsum() + right.getsum()));\\n            \\n        }\\n        return NodeData(INT_MIN, INT_MAX, max(left.getsum(), right.getsum()), max(left.getmaxSum(),right.getmaxSum()));\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans = maxBST(root).getmaxSum();\\n        return ans>=0?ans:0;\\n    }\\n};\\n```\\nCheers!",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass NodeData{\\nprivate:\\n    int mini;\\n    int maxi;\\n    int sum;\\n    int maxSum;\\npublic:\\n    NodeData(int mini, int maxi, int sum, int maxSum){\\n        this->mini=mini;\\n        this->maxi=maxi;\\n        this->sum=sum;\\n        this->maxSum=maxSum;\\n    }\\n    int getsum(){\\n        return sum;\\n    }\\n    int getmaxi(){\\n        return maxi;\\n    }\\n    int getmini(){\\n        return mini;\\n    }\\n    int getmaxSum(){\\n        return maxSum;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    NodeData maxBST(TreeNode* root){\\n        if(!root) return NodeData(INT_MAX,INT_MIN,0,INT_MIN);\\n        \\n        NodeData left = maxBST(root->left);\\n        NodeData right = maxBST(root->right);\\n        \\n        if(left.getmaxi() < root->val && right.getmini() > root->val){\\n            \\n            return NodeData(min(left.getmini(), root->val), max(right.getmaxi(), root->val), root->val + left.getsum() + right.getsum(), max(max(left.getmaxSum(), right.getmaxSum()), root->val + left.getsum() + right.getsum()));\\n            \\n        }\\n        return NodeData(INT_MIN, INT_MAX, max(left.getsum(), right.getsum()), max(left.getmaxSum(),right.getmaxSum()));\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans = maxBST(root).getmaxSum();\\n        return ans>=0?ans:0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2205564,
                "title": "python-intuitive-easy-to-understand-explanation",
                "content": "![image](https://assets.leetcode.com/users/images/a830b6a4-b525-4ad0-b0a7-6c614f40f822_1656340808.9508603.jpeg)\\nread more : https://www.theconfusedtechie.com/post/maximum-sum-bst-in-binary-tree\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        # declaire a variable maxSum to hold the max path sum\\n        self.maxSum=0\\n        def getMax(root):\\n            # return max,min,val - if root is null, valid BST\\n            if not root : return (float(\"-inf\"),float(\"inf\"),0)\\n            # traverse left and right part\\n            leftMax,leftMin,leftMaxSum=getMax(root.left)\\n            rightMax,rightMin,rightMaxSum=getMax(root.right)\\n            # if a valid BST\\n            if root.val>leftMax and root.val<rightMin:\\n                # update maxSum\\n                self.maxSum=max(self.maxSum,root.val+leftMaxSum+rightMaxSum)\\n                # return maximum and minimum node values starting from that node and pathSum\\n                return max(root.val,rightMax),min(root.val,leftMin),root.val+leftMaxSum+rightMaxSum\\n            # if not a BST - set an impossible condition such than the root is also returned as non-BST\\n            return  (float(\"inf\"),float(\"-inf\"),0)\\n        getMax(root)    \\n        return self.maxSum\\n        \\n            \\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        # declaire a variable maxSum to hold the max path sum\\n        self.maxSum=0\\n        def getMax(root):\\n            # return max,min,val - if root is null, valid BST\\n            if not root : return (float(\"-inf\"),float(\"inf\"),0)\\n            # traverse left and right part\\n            leftMax,leftMin,leftMaxSum=getMax(root.left)\\n            rightMax,rightMin,rightMaxSum=getMax(root.right)\\n            # if a valid BST\\n            if root.val>leftMax and root.val<rightMin:\\n                # update maxSum\\n                self.maxSum=max(self.maxSum,root.val+leftMaxSum+rightMaxSum)\\n                # return maximum and minimum node values starting from that node and pathSum\\n                return max(root.val,rightMax),min(root.val,leftMin),root.val+leftMaxSum+rightMaxSum\\n            # if not a BST - set an impossible condition such than the root is also returned as non-BST\\n            return  (float(\"inf\"),float(\"-inf\"),0)\\n        getMax(root)    \\n        return self.maxSum\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1520684,
                "title": "c-o-n",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\n\\n1.For tree rooted at particular node to be BST: \\n* Left Child is BST\\n* Right Child is BST\\n\\n2.Current node has to be BST itself:\\n* node value > max value in Left Child \\n* node value < min value in Right Child\\n\\t\\n```\\nclass Solution {\\npublic:\\n    \\n    struct pair{\\n        bool bst;\\n        int maxsum; // max sum possible till current root\\n        int sum,  minVal, maxVal; // current subtree info\\n        pair(bool check, int ms, int s, int min, int max){\\n            bst=check;\\n            maxsum=ms;\\n            sum=s;\\n            minVal=min;\\n            maxVal=max;\\n        }\\n    };\\n    \\n    struct pair solve(TreeNode* root){\\n        struct pair p={true,INT_MIN,0,INT_MAX,INT_MIN};\\n        if(root==NULL) return p;\\n        \\n        struct pair lp=solve(root->left);\\n        struct pair rp=solve(root->right);\\n        \\n        int val=root->val;\\n        \\n        bool isBST = (val > lp.maxVal && val < rp.minVal && lp.bst && rp.bst); // check if current node form BST\\n        \\n        int curMaxSum, curSum, curMin, curMax;\\n        if(isBST){\\n            curSum = lp.sum+rp.sum+val;\\n            curMaxSum = max(curSum,max(lp.maxsum,rp.maxsum));\\n            curMin = min(val,lp.minVal);\\n            curMax = max(val,rp.maxVal);\\n        }else{\\n            curSum=0;\\n            curMaxSum=max(lp.maxsum,rp.maxsum);\\n            curMin=INT_MIN;\\n            curMax=INT_MAX;\\n        }\\n        struct pair cur={isBST,curMaxSum,curSum,curMin,curMax};\\n        return cur;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        return max(0,solve(root).maxsum);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    struct pair{\\n        bool bst;\\n        int maxsum; // max sum possible till current root\\n        int sum,  minVal, maxVal; // current subtree info\\n        pair(bool check, int ms, int s, int min, int max){\\n            bst=check;\\n            maxsum=ms;\\n            sum=s;\\n            minVal=min;\\n            maxVal=max;\\n        }\\n    };\\n    \\n    struct pair solve(TreeNode* root){\\n        struct pair p={true,INT_MIN,0,INT_MAX,INT_MIN};\\n        if(root==NULL) return p;\\n        \\n        struct pair lp=solve(root->left);\\n        struct pair rp=solve(root->right);\\n        \\n        int val=root->val;\\n        \\n        bool isBST = (val > lp.maxVal && val < rp.minVal && lp.bst && rp.bst); // check if current node form BST\\n        \\n        int curMaxSum, curSum, curMin, curMax;\\n        if(isBST){\\n            curSum = lp.sum+rp.sum+val;\\n            curMaxSum = max(curSum,max(lp.maxsum,rp.maxsum));\\n            curMin = min(val,lp.minVal);\\n            curMax = max(val,rp.maxVal);\\n        }else{\\n            curSum=0;\\n            curMaxSum=max(lp.maxsum,rp.maxsum);\\n            curMin=INT_MIN;\\n            curMax=INT_MAX;\\n        }\\n        struct pair cur={isBST,curMaxSum,curSum,curMin,curMax};\\n        return cur;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        return max(0,solve(root).maxsum);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487927,
                "title": "python-dfs-the-most-standard-template-for-bottom-up",
                "content": "Please also use the same method (almost the same code with a little change) to solve Problem 333. Largest BST Subtree to test yourself whether you seize this methd.\\n\\n```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        \\n        def dfs(root):\\n\\t\\t\\n            if not root:\\n                return True, 0, float(\"inf\"), float(\"-inf\")\\n            \\n            lres, lsum, lmin, lmax = dfs(root.left)\\n            rres, rsum, rmin, rmax = dfs(root.right)\\n            \\n            if lres and rres and lmax < root.val < rmin:\\n                self.result = max(self.result, root.val+lsum+rsum)\\n                return True, root.val+lsum+rsum, min(root.val, lmin), max(root.val, rmax)\\n            else:\\n\\t\\t\\t\\t# it doesn\\'t matter which value here returns after False, \\n\\t\\t\\t\\t# since the code above \"if lres and rres...\" will assure that \\n\\t\\t\\t\\t# it will not run the FALSE subtree to affect the final result.\\n                return False, 0, 0, 0 \\n               \\n        self.result = 0\\n        dfs(root)\\n        return self.result\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        \\n        def dfs(root):\\n\\t\\t\\n            if not root:\\n                return True, 0, float(\"inf\"), float(\"-inf\")\\n            \\n            lres, lsum, lmin, lmax = dfs(root.left)\\n            rres, rsum, rmin, rmax = dfs(root.right)\\n            \\n            if lres and rres and lmax < root.val < rmin:\\n                self.result = max(self.result, root.val+lsum+rsum)\\n                return True, root.val+lsum+rsum, min(root.val, lmin), max(root.val, rmax)\\n            else:\\n\\t\\t\\t\\t# it doesn\\'t matter which value here returns after False, \\n\\t\\t\\t\\t# since the code above \"if lres and rres...\" will assure that \\n\\t\\t\\t\\t# it will not run the FALSE subtree to affect the final result.\\n                return False, 0, 0, 0 \\n               \\n        self.result = 0\\n        dfs(root)\\n        return self.result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1117229,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<int> dfs(TreeNode* root){\\n        if(root==NULL){\\n            return {true,0,0,0}; //isBST-true, sum-0, minimum-0, maximum-0\\n        }\\n        vector<int> l(dfs(root->left));\\n        vector<int> r(dfs(root->right));\\n        if((l[0]==true && (root->left==NULL || root->val>l[3])) && (r[0]==true && (root->right==NULL || root->val<r[2]))){\\n            int s=root->val+l[1]+r[1];\\n            ans=max(ans,s);\\n            int mini=0,maxi=0;\\n            if(root->left==NULL)\\n                mini=root->val;\\n            else\\n                mini=l[2];\\n            if(root->right==NULL)\\n                maxi=root->val;\\n            else\\n                maxi=r[3];\\n            return {true,s,mini,maxi};\\n        }\\n        return {false,0,0,0};  \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    vector<int> dfs(TreeNode* root){\\n        if(root==NULL){\\n            return {true,0,0,0}; //isBST-true, sum-0, minimum-0, maximum-0\\n        }\\n        vector<int> l(dfs(root->left));\\n        vector<int> r(dfs(root->right));\\n        if((l[0]==true && (root->left==NULL || root->val>l[3])) && (r[0]==true && (root->right==NULL || root->val<r[2]))){\\n            int s=root->val+l[1]+r[1];\\n            ans=max(ans,s);\\n            int mini=0,maxi=0;\\n            if(root->left==NULL)\\n                mini=root->val;\\n            else\\n                mini=l[2];\\n            if(root->right==NULL)\\n                maxi=root->val;\\n            else\\n                maxi=r[3];\\n            return {true,s,mini,maxi};\\n        }\\n        return {false,0,0,0};  \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 839262,
                "title": "python-3-dfs-helper-which-return-bst-flag-sum-min-max-of-all-nodes-under-this-node",
                "content": "```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        self.ans = 0 #empty BST allowed\\n        def help(r):\\n            if not r:\\n                return True,0,math.inf,-math.inf # Note -infinity as upper bound and +infinity as lower bound\\n            \\n            isLeftBST,leftSum,leftMin,leftMax = help(r.left)           \\n            isRightBST,rightSum,rightMin,rightMax = help(r.right)\\n            \\n            if (isLeftBST and r.val>leftMax) and (isRightBST and r.val<rightMin):\\n                self.ans = max(self.ans,r.val+leftSum+rightSum) #update the global max\\n                return True, r.val+leftSum+rightSum, min(leftMin,r.val),max(rightMax,r.val)\\n            else:\\n                return False,-math.inf,0,0 #does not matter\\n        _,_,_,_ = help(root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        self.ans = 0 #empty BST allowed\\n        def help(r):\\n            if not r:\\n                return True,0,math.inf,-math.inf # Note -infinity as upper bound and +infinity as lower bound\\n            \\n            isLeftBST,leftSum,leftMin,leftMax = help(r.left)           \\n            isRightBST,rightSum,rightMin,rightMax = help(r.right)\\n            \\n            if (isLeftBST and r.val>leftMax) and (isRightBST and r.val<rightMin):\\n                self.ans = max(self.ans,r.val+leftSum+rightSum) #update the global max\\n                return True, r.val+leftSum+rightSum, min(leftMin,r.val),max(rightMax,r.val)\\n            else:\\n                return False,-math.inf,0,0 #does not matter\\n        _,_,_,_ = help(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 727311,
                "title": "java-simple-solution-o-n-time-o-1-space-with-explanation-and-comments",
                "content": "For each subtree to be BST, there needs to be min and max limits. \\nMax node in left subtree must be < root value, and root value must be > min node in right subtree. \\nOn a subtree that can\\'t meet the BST property, we need to set min to MIN_VALUE and max to MAX_VALUE to make sure its sum cannot contribute to the sum of its parent node.\\n```\\nclass Solution {\\n    int max = 0;\\n    public int maxSumBST(TreeNode root) {\\n        post(root);\\n        return max;\\n    }\\n    public int[] post(TreeNode root) {\\n        //int[]res = {min, max, sum}\\n        if (root == null) return new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, 0};\\n        int[] left = post(root.left);\\n        int[] right = post(root.right);\\n        if (root.val > left[1] && root.val < right[0]) {//valid BST\\n            int[] res = new int[3];\\n            res[0] = Math.min(left[0], root.val);//update min\\n            res[1] = Math.max(right[1], root.val);//update max\\n            res[2] = root.val + left[2] + right[2];\\n            max = Math.max(max, res[2]);\\n            return res;\\n        }\\n        //not a valid BST, can\\'t let result be part of greater bst, so apply min/max\\n        return new int[]{Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    int max = 0;\\n    public int maxSumBST(TreeNode root) {\\n        post(root);\\n        return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3908722,
                "title": "why-postorder-basic-approach-beginners-s-friendly-0-n-at-leaf-node",
                "content": "# Intuition\\nBasic recursion.\\nWe cant go to every node and and check for binary tree. The constains are very high, hence we need to go in one traversal and check for binary seach tree and calculate sum.\\n\\nNow at a node, we say it is bst only if it is greater than left and less than the right.\\nNow to check for left and right first and then the root.\\nWe can do a postorder traversal.\\nLeft-->Right-->Root\\n\\n# Approach\\nNow for postorder, lets say at leaf node, they are always a bst in themselves \\nwhen we get null, we return min value as INT_MAX and max value as INT_MIN. So when it gets at leaf it satisfiy for bst.\\nnow at evety node we just check for bst \\n\\nif BST-->we take sum of both left , right and root.\\n```\\nint sum=root->val+lt.sum+rt.sum;\\nreturn BST(sum,min(root->val,lt.mini),max(root->val,rt.maxi));\\n```\\n\\nif not BST-->we just take max of left and right as the current root doesnt form the bst.\\nso we just pass on the earlier max value of sub-BST.\\n```\\nreturn BST(max(lt.sum,rt.sum),INT_MIN,INT_MAX);\\n```\\n\\n# Complexity\\n- Time complexity:\\nWe just traverse the tree once and hence TC-> O(N)\\n\\n- Space complexity:\\nWe use another data structure BST\\nwhich take O(1) space but stack space is used\\nHence O(H) where H is height of tree\\n\\n# Code\\n```\\nclass BST {\\npublic:\\n    int sum;\\n    int mini;\\n    int maxi;\\n    BST(int sum=0,int mini=INT_MAX,int maxi=INT_MIN) {\\n        this->sum=sum;\\n        this->mini=mini;\\n        this->maxi=maxi;\\n    }\\n};\\nint ans=0;\\nBST helper(TreeNode *root) {\\n    if(!root)return BST(0,INT_MAX,INT_MIN);\\n    auto lt=helper(root->left);\\n    auto rt=helper(root->right);\\n    if(root->val>lt.maxi && root->val<rt.mini){\\n        int sum=root->val+lt.sum+rt.sum;\\n        ans=max(ans,sum);\\n        return BST(sum,min(root->val,lt.mini),max(root->val,rt.maxi));\\n    }\\n    return BST(max(lt.sum,rt.sum),INT_MIN,INT_MAX);\\n}\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nint sum=root->val+lt.sum+rt.sum;\\nreturn BST(sum,min(root->val,lt.mini),max(root->val,rt.maxi));\\n```\n```\\nreturn BST(max(lt.sum,rt.sum),INT_MIN,INT_MAX);\\n```\n```\\nclass BST {\\npublic:\\n    int sum;\\n    int mini;\\n    int maxi;\\n    BST(int sum=0,int mini=INT_MAX,int maxi=INT_MIN) {\\n        this->sum=sum;\\n        this->mini=mini;\\n        this->maxi=maxi;\\n    }\\n};\\nint ans=0;\\nBST helper(TreeNode *root) {\\n    if(!root)return BST(0,INT_MAX,INT_MIN);\\n    auto lt=helper(root->left);\\n    auto rt=helper(root->right);\\n    if(root->val>lt.maxi && root->val<rt.mini){\\n        int sum=root->val+lt.sum+rt.sum;\\n        ans=max(ans,sum);\\n        return BST(sum,min(root->val,lt.mini),max(root->val,rt.maxi));\\n    }\\n    return BST(max(lt.sum,rt.sum),INT_MIN,INT_MAX);\\n}\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        helper(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267195,
                "title": "java-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\n    //Brute Force Approach:-\\n    //1. Validate the tree\\n        //1.a. if it is a BST, then calculate its sum\\n        //1.b. if it is not, then no need to calculate the sum\\n    //Time Complexity:- O(n^2) => O(n) for validity and O(n) for calculating sum\\n    //Therefore, it would give TLE\\n    \\n    //Optimised Approach:-\\n    //here we are trying to calculate the sum while checking the validity of the binary tree as BST\\n    //1. we have to check the left and right subtree before the root for BST check so we would do preorder traversal\\n    //2. for checking BST and to get the sum together, we need to get 4 things:\\n\\t\\t//is the tree BST, sum obtained till now, max value for the root to be BST, min value for the root to be BST\\n    //Time Complexity:- O(n) because we traverse the tree only once\\n    //now read the code carefully, it has been commented for better readibility\\n    \\n    //custom data structure which should be returned\\n    class Pair{\\n        boolean isBST;\\n        int sum;\\n        int max;\\n        int min;\\n        Pair(boolean _isBST,int _sum,int _max,int _min){\\n            isBST=_isBST;\\n            sum=_sum;\\n            max=_max;\\n            min=_min;\\n        }\\n        Pair(){\\n            isBST=false;\\n            sum=0;\\n            max=Integer.MIN_VALUE;\\n            min=Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    //keeps ultimate answer\\n    int res=0;\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        return res;\\n    }\\n    \\n    private Pair helper(TreeNode root){\\n        //an empty tree is a BST with sum 0 and max value=Integer.MIN_VALUE and min value=Integer.MAX_VALUE\\n        if(root==null){\\n            return new Pair(true,0,Integer.MIN_VALUE,Integer.MAX_VALUE);\\n        }\\n        \\n        //getting values from left subtree\\n        Pair l=helper(root.left);\\n        //getting values from right subtree\\n        Pair r=helper(root.right);\\n        \\n        //we would be returning this\\n        Pair ansret=new Pair();\\n        \\n        //checking if the tree is a BST\\n        //check if the root node is within the range \\n        //root.val should be greater than left subtree max value\\n        //root.val should be less than right subtree min value\\n        //and left and right subtrees should be BSTs\\n        if(root.val>l.max && root.val<r.min && l.isBST && r.isBST){\\n            ansret.isBST=true;\\n            ansret.sum=l.sum+r.sum+root.val;\\n            ansret.min=Math.min(root.val,l.min);\\n            ansret.max=Math.max(root.val,r.max);\\n            res=Math.max(res,ansret.sum);\\n        }\\n        //if the tree is not a BST\\n        //then we cannot develop any BST which is connected to this root\\n        //therefore put the value of max to Integer.MAX_VALUE and value of min to Integer.MIN_VALUE\\n        //so that no root value connecting this root satisfies the BST criteria\\n        else{\\n            ansret.isBST=false;\\n            ansret.sum=0;\\n            ansret.max=Integer.MAX_VALUE;\\n            ansret.min=Integer.MIN_VALUE;\\n        }\\n        return ansret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    //Brute Force Approach:-\\n    //1. Validate the tree\\n        //1.a. if it is a BST, then calculate its sum\\n        //1.b. if it is not, then no need to calculate the sum\\n    //Time Complexity:- O(n^2) => O(n) for validity and O(n) for calculating sum\\n    //Therefore, it would give TLE\\n    \\n    //Optimised Approach:-\\n    //here we are trying to calculate the sum while checking the validity of the binary tree as BST\\n    //1. we have to check the left and right subtree before the root for BST check so we would do preorder traversal\\n    //2. for checking BST and to get the sum together, we need to get 4 things:\\n\\t\\t//is the tree BST, sum obtained till now, max value for the root to be BST, min value for the root to be BST\\n    //Time Complexity:- O(n) because we traverse the tree only once\\n    //now read the code carefully, it has been commented for better readibility\\n    \\n    //custom data structure which should be returned\\n    class Pair{\\n        boolean isBST;\\n        int sum;\\n        int max;\\n        int min;\\n        Pair(boolean _isBST,int _sum,int _max,int _min){\\n            isBST=_isBST;\\n            sum=_sum;\\n            max=_max;\\n            min=_min;\\n        }\\n        Pair(){\\n            isBST=false;\\n            sum=0;\\n            max=Integer.MIN_VALUE;\\n            min=Integer.MAX_VALUE;\\n        }\\n    }\\n    \\n    //keeps ultimate answer\\n    int res=0;\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        return res;\\n    }\\n    \\n    private Pair helper(TreeNode root){\\n        //an empty tree is a BST with sum 0 and max value=Integer.MIN_VALUE and min value=Integer.MAX_VALUE\\n        if(root==null){\\n            return new Pair(true,0,Integer.MIN_VALUE,Integer.MAX_VALUE);\\n        }\\n        \\n        //getting values from left subtree\\n        Pair l=helper(root.left);\\n        //getting values from right subtree\\n        Pair r=helper(root.right);\\n        \\n        //we would be returning this\\n        Pair ansret=new Pair();\\n        \\n        //checking if the tree is a BST\\n        //check if the root node is within the range \\n        //root.val should be greater than left subtree max value\\n        //root.val should be less than right subtree min value\\n        //and left and right subtrees should be BSTs\\n        if(root.val>l.max && root.val<r.min && l.isBST && r.isBST){\\n            ansret.isBST=true;\\n            ansret.sum=l.sum+r.sum+root.val;\\n            ansret.min=Math.min(root.val,l.min);\\n            ansret.max=Math.max(root.val,r.max);\\n            res=Math.max(res,ansret.sum);\\n        }\\n        //if the tree is not a BST\\n        //then we cannot develop any BST which is connected to this root\\n        //therefore put the value of max to Integer.MAX_VALUE and value of min to Integer.MIN_VALUE\\n        //so that no root value connecting this root satisfies the BST criteria\\n        else{\\n            ansret.isBST=false;\\n            ansret.sum=0;\\n            ansret.max=Integer.MAX_VALUE;\\n            ansret.min=Integer.MIN_VALUE;\\n        }\\n        return ansret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1228153,
                "title": "c-simple-recursion-solution",
                "content": "Acutally solution was easy, tough task was to check isBST in same recursion.....\\nHope you all understand the following solution.\\n```\\nclass Solution {\\npublic:\\n\\n    bool get_output(TreeNode * root, int & sum,int & part_sum, int & min_val, int & max_val){\\n        \\n\\n        \\n        if(root->left==NULL and root->right==NULL){\\n            part_sum = root->val;\\n            sum = max(sum,root->val);\\n            min_val = root->val;\\n            max_val = root->val;\\n            return true;\\n        }\\n        \\n        // other condition\\n        bool left_part = true, right_part= true;\\n        \\n        int left_part_sum=0, right_part_sum=0 ;\\n        int min_val1=INT_MAX,max_val1=INT_MIN ,min_val2=INT_MAX,max_val2=INT_MIN ;\\n        \\n        if(root->left)\\n            left_part = get_output(root->left,sum,left_part_sum,min_val1,max_val1);\\n        if(root->right)\\n            right_part = get_output(root->right,sum, right_part_sum,min_val2 ,max_val2);\\n        \\n        if(!left_part or !right_part){\\n            return false;\\n        }\\n        \\n        if(root->val<=max_val1 or root->val>=min_val2){\\n            return false;\\n        }\\n        \\n        min_val = min({root->val,min_val1,min_val2});\\n        max_val = max({root->val,max_val1,max_val2});        \\n        \\n        // update the condition\\n        sum = max(sum,left_part_sum+right_part_sum + root->val);\\n        \\n        part_sum = left_part_sum+ right_part_sum + root->val;\\n        \\n        return true;\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        \\n        // Base Case\\n        if(root==NULL){\\n            return 0;\\n        }\\n                \\n        int sum =INT_MIN;\\n        \\n        bool isValid= false;\\n        \\n\\n        int part_sum =0;\\n        int min_val,max_val;\\n        isValid = get_output(root,sum,part_sum,min_val,max_val);\\n        \\n        if(sum<0){\\n            return 0;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool get_output(TreeNode * root, int & sum,int & part_sum, int & min_val, int & max_val){\\n        \\n\\n        \\n        if(root->left==NULL and root->right==NULL){\\n            part_sum = root->val;\\n            sum = max(sum,root->val);\\n            min_val = root->val;\\n            max_val = root->val;\\n            return true;\\n        }\\n        \\n        // other condition\\n        bool left_part = true, right_part= true;\\n        \\n        int left_part_sum=0, right_part_sum=0 ;\\n        int min_val1=INT_MAX,max_val1=INT_MIN ,min_val2=INT_MAX,max_val2=INT_MIN ;\\n        \\n        if(root->left)\\n            left_part = get_output(root->left,sum,left_part_sum,min_val1,max_val1);\\n        if(root->right)\\n            right_part = get_output(root->right,sum, right_part_sum,min_val2 ,max_val2);\\n        \\n        if(!left_part or !right_part){\\n            return false;\\n        }\\n        \\n        if(root->val<=max_val1 or root->val>=min_val2){\\n            return false;\\n        }\\n        \\n        min_val = min({root->val,min_val1,min_val2});\\n        max_val = max({root->val,max_val1,max_val2});        \\n        \\n        // update the condition\\n        sum = max(sum,left_part_sum+right_part_sum + root->val);\\n        \\n        part_sum = left_part_sum+ right_part_sum + root->val;\\n        \\n        return true;\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        \\n        // Base Case\\n        if(root==NULL){\\n            return 0;\\n        }\\n                \\n        int sum =INT_MIN;\\n        \\n        bool isValid= false;\\n        \\n\\n        int part_sum =0;\\n        int min_val,max_val;\\n        isValid = get_output(root,sum,part_sum,min_val,max_val);\\n        \\n        if(sum<0){\\n            return 0;\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619888,
                "title": "python-easy-bottom-up-approach",
                "content": "```\\nclass NodeValue:\\n    def __init__(self, minNode, maxNode, Sum):\\n        self.maxNode = maxNode\\n        self.minNode = minNode\\n        self.Sum = Sum\\n\\nclass Solution:\\n    def largestBstHelper(self, node):\\n        if not node:\\n            return NodeValue(float(\\'inf\\'), float(\\'-inf\\'), 0)\\n\\n        left = self.largestBstHelper(node.left)\\n        right = self.largestBstHelper(node.right)\\n\\n        if left.maxNode < node.val and node.val < right.minNode:\\n            currSum=left.Sum+ right.Sum + node.val\\n            self.maxSum=max(self.maxSum,currSum)\\n            return NodeValue(min(node.val, left.minNode), max(node.val, right.maxNode),currSum)\\n\\n        return NodeValue(float(\\'-inf\\'), float(\\'inf\\'), max(left.Sum, right.Sum))\\n    \\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        self.maxSum=0\\n        ans=self.largestBstHelper(root).Sum \\n        return self.maxSum\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass NodeValue:\\n    def __init__(self, minNode, maxNode, Sum):\\n        self.maxNode = maxNode\\n        self.minNode = minNode\\n        self.Sum = Sum\\n\\nclass Solution:\\n    def largestBstHelper(self, node):\\n        if not node:\\n            return NodeValue(float(\\'inf\\'), float(\\'-inf\\'), 0)\\n\\n        left = self.largestBstHelper(node.left)\\n        right = self.largestBstHelper(node.right)\\n\\n        if left.maxNode < node.val and node.val < right.minNode:\\n            currSum=left.Sum+ right.Sum + node.val\\n            self.maxSum=max(self.maxSum,currSum)\\n            return NodeValue(min(node.val, left.minNode), max(node.val, right.maxNode),currSum)\\n\\n        return NodeValue(float(\\'-inf\\'), float(\\'inf\\'), max(left.Sum, right.Sum))\\n    \\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        self.maxSum=0\\n        ans=self.largestBstHelper(root).Sum \\n        return self.maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351882,
                "title": "striver-s-method-super-easy-to-understand",
                "content": "# Intuition\\nThis question is just a copy of Finding Largest Bst in a Binary Tree.\\nBig Thanks! to Striver :).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n**Step -1**\\n\\nFind a Valid Bst \\n\\n->then get the maximum_Sum \\n\\n->we can get it by currSum = leftSum+ rightSum + root->val\\n\\n->update left and right child of the valid Bst\\n\\n**Step-2**\\n\\n*This Step occurs when the Binary Tree is not a bst.*\\n\\nIn this case:- \\n\\n->mark our isBst as false\\n\\n->update the maximum value of our current Bst\\n\\n**Step-3**\\n\\nonce done with 2 steps\\n\\n->store maximum answer and simply return it.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$  -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass NodeVal{\\n    public:\\n    bool isBst;\\n    int minNode,maxNode,maxSum;\\n    NodeVal(){\\n        isBst = true;\\n        minNode = INT_MAX;\\n        maxNode = INT_MIN;\\n        maxSum= 0;\\n    }\\n};\\nint ans;\\nclass Solution {\\npublic:\\n    NodeVal FindSum(TreeNode* root){\\n    if(root == NULL) return NodeVal();\\n    NodeVal curr;\\n    //Now take 2 pointer for left and right \\n    //-- we are going to perform POSTORDER TRAVERSAL\\n    NodeVal left = FindSum(root->left);\\n    NodeVal right = FindSum(root->right);\\n\\n    /*\\n    Checking main condition of BST:\\n    -----------Left < ROOT < RIGHT-----------\\n    \\n*/\\n    if((left.isBst==true && right.isBst == true) && (left.maxNode<root->val && root->val<right.minNode)){\\n        // make curr bst as bst \\n        curr.isBst = true;\\n        //Below is our answer\\n        curr.maxSum = left.maxSum + right.maxSum+root->val;\\n        // now store minimal node or the left node as it\\'s a BST  \\n        curr.minNode= min(left.minNode,root->val);\\n        // now store maximum node or the right node for bst\\n        curr.maxNode = max(right.maxNode,root->val);\\n    }\\n    /*if the given Binary Tree is Not a BST*/\\n    else{\\n        curr.isBst = false; // else mark it false saying \"No, its NOT BST\"\\n        curr.maxSum = max(left.maxSum,right.maxSum);// keep updating maxSum\\n    }\\n    ans = max(ans,curr.maxSum);// store current answer \\n    return curr;\\n}\\n    int maxSumBST(TreeNode* root) {\\n        ans =0;\\n        NodeVal obj = FindSum(root);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass NodeVal{\\n    public:\\n    bool isBst;\\n    int minNode,maxNode,maxSum;\\n    NodeVal(){\\n        isBst = true;\\n        minNode = INT_MAX;\\n        maxNode = INT_MIN;\\n        maxSum= 0;\\n    }\\n};\\nint ans;\\nclass Solution {\\npublic:\\n    NodeVal FindSum(TreeNode* root){\\n    if(root == NULL) return NodeVal();\\n    NodeVal curr;\\n    //Now take 2 pointer for left and right \\n    //-- we are going to perform POSTORDER TRAVERSAL\\n    NodeVal left = FindSum(root->left);\\n    NodeVal right = FindSum(root->right);\\n\\n    /*\\n    Checking main condition of BST:\\n    -----------Left < ROOT < RIGHT-----------\\n    \\n*/\\n    if((left.isBst==true && right.isBst == true) && (left.maxNode<root->val && root->val<right.minNode)){\\n        // make curr bst as bst \\n        curr.isBst = true;\\n        //Below is our answer\\n        curr.maxSum = left.maxSum + right.maxSum+root->val;\\n        // now store minimal node or the left node as it\\'s a BST  \\n        curr.minNode= min(left.minNode,root->val);\\n        // now store maximum node or the right node for bst\\n        curr.maxNode = max(right.maxNode,root->val);\\n    }\\n    /*if the given Binary Tree is Not a BST*/\\n    else{\\n        curr.isBst = false; // else mark it false saying \"No, its NOT BST\"\\n        curr.maxSum = max(left.maxSum,right.maxSum);// keep updating maxSum\\n    }\\n    ans = max(ans,curr.maxSum);// store current answer \\n    return curr;\\n}\\n    int maxSumBST(TreeNode* root) {\\n        ans =0;\\n        NodeVal obj = FindSum(root);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310253,
                "title": "optimized-solution-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n class NodeValue{\\n    public int maxValue,minValue,maxsum;\\n    NodeValue(int max, int min,int maxsum){\\n        this.maxValue = max;\\n        this.minValue = min;\\n        this.maxsum = maxsum;\\n    }\\n}\\n\\nclass Solution {\\n    int max = 0;\\n    public NodeValue maxSumBSTHelper(TreeNode root){\\n        //An empty tree or bst of size 0;\\n        if(root == null){\\n            return new NodeValue(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        }\\n        NodeValue left = maxSumBSTHelper(root.left);\\n        NodeValue right = maxSumBSTHelper(root.right);\\n        \\n        //Check if it\\'s a valid bst\\n        if(left.maxValue < root.val && root.val < right.minValue){\\n            //It is a BST , calculate maxsum tillnow.\\n             max = Math.max(max,root.val + left.maxsum + right.maxsum);\\n            return new NodeValue(Math.max(root.val,right.maxValue), Math.min(root.val,left.minValue),root.val+left.maxsum + right.maxsum);\\n           \\n        }\\n        return new NodeValue(Integer.MAX_VALUE,Integer.MIN_VALUE,Math.max(left.maxsum,right.maxsum));\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        maxSumBSTHelper(root);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n class NodeValue{\\n    public int maxValue,minValue,maxsum;\\n    NodeValue(int max, int min,int maxsum){\\n        this.maxValue = max;\\n        this.minValue = min;\\n        this.maxsum = maxsum;\\n    }\\n}\\n\\nclass Solution {\\n    int max = 0;\\n    public NodeValue maxSumBSTHelper(TreeNode root){\\n        //An empty tree or bst of size 0;\\n        if(root == null){\\n            return new NodeValue(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        }\\n        NodeValue left = maxSumBSTHelper(root.left);\\n        NodeValue right = maxSumBSTHelper(root.right);\\n        \\n        //Check if it\\'s a valid bst\\n        if(left.maxValue < root.val && root.val < right.minValue){\\n            //It is a BST , calculate maxsum tillnow.\\n             max = Math.max(max,root.val + left.maxsum + right.maxsum);\\n            return new NodeValue(Math.max(root.val,right.maxValue), Math.min(root.val,left.minValue),root.val+left.maxsum + right.maxsum);\\n           \\n        }\\n        return new NodeValue(Integer.MAX_VALUE,Integer.MIN_VALUE,Math.max(left.maxsum,right.maxsum));\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        maxSumBSTHelper(root);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124363,
                "title": "c-o-n-simple-and-easy-solution-validate-bst",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is an extension to the \\'Validate BST\\' Problem.Maintain Ranges for a node and check it for the largest left child and the smallest right child.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(height of tree)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n class nodeValue{\\n     public:\\n     int min;\\n     int max;\\n     int sum;\\n     nodeValue(int min,int max,int sum)\\n     {\\n         this->min=min;\\n         this->max=max;\\n         this->sum=sum;\\n     }\\n };\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int maxSumBST(TreeNode* root) {\\n        fun(root);\\n        return ans;\\n    }\\n    nodeValue fun(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return nodeValue(INT_MAX,INT_MIN,0);\\n        nodeValue l=fun(root->left);\\n        nodeValue r=fun(root->right);\\n        if(root->val>l.max && root->val<r.min)\\n        {\\n            ans=max(ans,root->val+l.sum+r.sum);\\n            return nodeValue(min(root->val,l.min),max(root->val,r.max),l.sum+root->val+r.sum);\\n        }\\n        return nodeValue(INT_MIN,INT_MAX,max(l.sum,r.sum));\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n class nodeValue{\\n     public:\\n     int min;\\n     int max;\\n     int sum;\\n     nodeValue(int min,int max,int sum)\\n     {\\n         this->min=min;\\n         this->max=max;\\n         this->sum=sum;\\n     }\\n };\\nclass Solution {\\npublic:\\n    int ans=0;\\n    int maxSumBST(TreeNode* root) {\\n        fun(root);\\n        return ans;\\n    }\\n    nodeValue fun(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        return nodeValue(INT_MAX,INT_MIN,0);\\n        nodeValue l=fun(root->left);\\n        nodeValue r=fun(root->right);\\n        if(root->val>l.max && root->val<r.min)\\n        {\\n            ans=max(ans,root->val+l.sum+r.sum);\\n            return nodeValue(min(root->val,l.min),max(root->val,r.max),l.sum+root->val+r.sum);\\n        }\\n        return nodeValue(INT_MIN,INT_MAX,max(l.sum,r.sum));\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2996686,
                "title": "detailed-explanation-easy-code-beats-90",
                "content": "# Intuition\\n- We have to find global maximum sum of any BST present as subtree, so we will have to vist every node\\n- Each node has to calculate if node + subtree forms a BST or not. If yes, then global max Sum needs to be updated.\\n - For processing at each node, we need to know if it forms a BST and if yes, then what is the sum.\\n\\n# Approach\\n- First data point we need is if the node forms a BST, this is only possible if left subtree is a BST, right subtree is a BST and also the max of left subtree is less than node\\'s data and min of right subtree is greater than node\\'s data. We can easily see that we need 3 values from each subtree : isBST, max value and min value. With these value parent nodes can see if they are BST or not.\\n- If current node is not a BST we simply need to return to upper (parent) node only this info since nothing else is needed. However, if current node is a BST we need to pass 3 values talked in the previous point and also the sum of this current subtree. When we calculate sum of current BST subtree, we can also check to see if is max sum seen so far.\\n- This problem is like two easy problems combined: Check BST (check whether a tree is BST or not) and Tree Sum (calculate Sum). We just need to combine these logics and not return any other info if the current node does not form a BST since no other info is desired by parent node in this case.\\n- Since null node is also a BST, we return from it with default values.\\n- Since negative values are not to be taken and even empty BST is better than these, we start from maxSum as zero (rather than min integer possible in language).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ : We just need to traverse once\\n\\n- Space complexity:\\n$$O(n)$$ : If the tree is highly skewed, then recursive calls on stack can take $$O(n)$$ space otherwise in a balnced tree, space complexity is $$O(log n)$$\\n\\n# Code\\n```\\nclass quad{     // 4 values have to be returned so made a quad class\\n    public :\\n    int maxEle;\\n    int minEle;\\n    bool isBST;\\n    int sum;\\n    quad(int maxEle, int minEle, bool isBST, int sum){\\n        this -> maxEle = maxEle;\\n        this -> minEle = minEle;\\n        this -> isBST = isBST;\\n        this -> sum = sum;\\n    }\\n    quad(){\\n        this-> isBST = false;       //when isBST is false, then other values can be garbage\\n    }\\n};\\nclass Solution {\\npublic:\\n    int maxSum = 0;\\n    quad traverse(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return quad(INT_MIN, INT_MAX, true, 0);\\n        \\n        quad leftAns = traverse(root ->left);\\n        quad rightAns = traverse(root -> right);\\n\\n        bool isBST = leftAns.isBST && rightAns.isBST && (leftAns.maxEle < root->val) && (rightAns.minEle > root->val);\\n        \\n        if(!isBST)\\n            return quad();          // default constructor sets isBST to false, rest are garbage values\\n        else\\n            {\\n                int sum = leftAns.sum + rightAns.sum + root->val;\\n                if(sum > maxSum)            // try updating globally maintained sum\\n                    maxSum = sum;\\n                return quad(max(root->val, rightAns.maxEle),\\n                            min(root->val, leftAns.minEle),\\n                            true,\\n                            sum );\\n            }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        traverse(root);\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass quad{     // 4 values have to be returned so made a quad class\\n    public :\\n    int maxEle;\\n    int minEle;\\n    bool isBST;\\n    int sum;\\n    quad(int maxEle, int minEle, bool isBST, int sum){\\n        this -> maxEle = maxEle;\\n        this -> minEle = minEle;\\n        this -> isBST = isBST;\\n        this -> sum = sum;\\n    }\\n    quad(){\\n        this-> isBST = false;       //when isBST is false, then other values can be garbage\\n    }\\n};\\nclass Solution {\\npublic:\\n    int maxSum = 0;\\n    quad traverse(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return quad(INT_MIN, INT_MAX, true, 0);\\n        \\n        quad leftAns = traverse(root ->left);\\n        quad rightAns = traverse(root -> right);\\n\\n        bool isBST = leftAns.isBST && rightAns.isBST && (leftAns.maxEle < root->val) && (rightAns.minEle > root->val);\\n        \\n        if(!isBST)\\n            return quad();          // default constructor sets isBST to false, rest are garbage values\\n        else\\n            {\\n                int sum = leftAns.sum + rightAns.sum + root->val;\\n                if(sum > maxSum)            // try updating globally maintained sum\\n                    maxSum = sum;\\n                return quad(max(root->val, rightAns.maxEle),\\n                            min(root->val, leftAns.minEle),\\n                            true,\\n                            sum );\\n            }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        traverse(root);\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836583,
                "title": "striver-cpp-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// created class container to store maximum,minimum,and maxsum values\\n class cont{\\n     public:\\n        int maxsum;\\n        int maxval;\\n        int minval;\\n    cont(int ms,int mx,int mi){\\n        maxsum=ms;\\n        maxval=mx;\\n        minval=mi;\\n    }\\n };\\nclass Solution {\\npublic:\\n    int res;    // created this variable to keep track on maxsum till now\\n    cont solve(TreeNode* root){\\n        if(root==NULL){\\n            return cont(0,INT_MIN,INT_MAX);\\n        }\\n\\n        auto left = solve(root->left);\\n        auto right=solve(root->right);\\n\\n        if((root->val > left.maxval) && (root->val < right.minval)){\\n            int s=root->val+left.maxsum+right.maxsum;\\n            res=max(res,s);\\n            return cont(s,max(root->val,right.maxval),min(root->val,left.minval));\\n        }\\n\\n        return cont(max(left.maxsum,right.maxsum),INT_MAX,INT_MIN);\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        res=0;\\n        solve(root).maxsum;\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// created class container to store maximum,minimum,and maxsum values\\n class cont{\\n     public:\\n        int maxsum;\\n        int maxval;\\n        int minval;\\n    cont(int ms,int mx,int mi){\\n        maxsum=ms;\\n        maxval=mx;\\n        minval=mi;\\n    }\\n };\\nclass Solution {\\npublic:\\n    int res;    // created this variable to keep track on maxsum till now\\n    cont solve(TreeNode* root){\\n        if(root==NULL){\\n            return cont(0,INT_MIN,INT_MAX);\\n        }\\n\\n        auto left = solve(root->left);\\n        auto right=solve(root->right);\\n\\n        if((root->val > left.maxval) && (root->val < right.minval)){\\n            int s=root->val+left.maxsum+right.maxsum;\\n            res=max(res,s);\\n            return cont(s,max(root->val,right.maxval),min(root->val,left.minval));\\n        }\\n\\n        return cont(max(left.maxsum,right.maxsum),INT_MAX,INT_MIN);\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        res=0;\\n        solve(root).maxsum;\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2575531,
                "title": "easy-c-solution-recursive-solution-same-like-maximum-height-of-bst",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    class info{\\n      public:\\n      int maxi;\\n      int mini;\\n      bool isBst;\\n      int sum;\\n      \\n    };\\n    \\n    info solve(TreeNode*root,int &ans){\\n        \\n        if(root==NULL){\\n            return {INT_MIN,INT_MAX,true,0};\\n        }\\n        \\n        \\n        info left = solve(root->left,ans);\\n        info right = solve(root->right,ans);\\n        \\n        info currNode;\\n        currNode.maxi = max(root->val,right.maxi);\\n        currNode.mini = min(root->val,left.mini);\\n        currNode.sum = left.sum + right.sum + root->val; \\n        \\n        if(left.isBst && right.isBst && (root->val> left.maxi && root->val < right.mini)){\\n        currNode.isBst = true;\\n            currNode.sum = left.sum + right.sum + root->val;\\n        }\\n        else {\\n        currNode.isBst  = false;\\n        }\\n        \\n        \\n        if(currNode.isBst)ans = max(ans,currNode.sum);\\n        return currNode;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int sum = 0;\\n        info t = solve(root,sum);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    class info{\\n      public:\\n      int maxi;\\n      int mini;\\n      bool isBst;\\n      int sum;\\n      \\n    };\\n    \\n    info solve(TreeNode*root,int &ans){\\n        \\n        if(root==NULL){\\n            return {INT_MIN,INT_MAX,true,0};\\n        }\\n        \\n        \\n        info left = solve(root->left,ans);\\n        info right = solve(root->right,ans);\\n        \\n        info currNode;\\n        currNode.maxi = max(root->val,right.maxi);\\n        currNode.mini = min(root->val,left.mini);\\n        currNode.sum = left.sum + right.sum + root->val; \\n        \\n        if(left.isBst && right.isBst && (root->val> left.maxi && root->val < right.mini)){\\n        currNode.isBst = true;\\n            currNode.sum = left.sum + right.sum + root->val;\\n        }\\n        else {\\n        currNode.isBst  = false;\\n        }\\n        \\n        \\n        if(currNode.isBst)ans = max(ans,currNode.sum);\\n        return currNode;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int sum = 0;\\n        info t = solve(root,sum);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396279,
                "title": "c-recursion-post-order-traversal",
                "content": "* At each node we return an `array<int,4>` where\\n1.  `arr[0]` -> if the subtree is BST or not\\n2.  `arr[1]` -> sum of the subtree.\\n3.  `arr[2]`-> Max Value in that subtree.\\n4.  `arr[3]` -> Min Value in that subtree.\\n\\n* A tree will be a BST when its `left and right subtree are both BST\\'s` and the value or root node should be such that it lies between the **max Value from left subtree and min Value from right subtree**\\n\\n* We Keep track of sum in  variable **ans**.\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = 0 ;\\n\\t\\n    array<int,4> solve(TreeNode * root){\\n        if(!root) return {1,0,INT_MIN,INT_MAX} ;\\n        \\n        array<int,4> l = solve(root->left) ;\\n        array<int,4> r = solve(root->right) ;\\n        \\n        if(l[0] and r[0]){\\n            if(root->val > l[2] and root->val < r[3]){\\n                ans = max({ans,l[1],r[1]}) ;\\n                return {1,l[1] + r[1] + root->val,max({root->val,l[2],r[2]}),min({root->val,l[3],r[3]})} ;\\n            }\\n        }\\n        \\n        return {0,max(l[1],r[1]),INT_MIN,INT_MAX} ;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        auto arr = solve(root) ;\\n        return max(ans,arr[1]) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0 ;\\n\\t\\n    array<int,4> solve(TreeNode * root){\\n        if(!root) return {1,0,INT_MIN,INT_MAX} ;\\n        \\n        array<int,4> l = solve(root->left) ;\\n        array<int,4> r = solve(root->right) ;\\n        \\n        if(l[0] and r[0]){\\n            if(root->val > l[2] and root->val < r[3]){\\n                ans = max({ans,l[1],r[1]}) ;\\n                return {1,l[1] + r[1] + root->val,max({root->val,l[2],r[2]}),min({root->val,l[3],r[3]})} ;\\n            }\\n        }\\n        \\n        return {0,max(l[1],r[1]),INT_MIN,INT_MAX} ;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        auto arr = solve(root) ;\\n        return max(ans,arr[1]) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2386278,
                "title": "java-o-n-min-max-sum",
                "content": "```\\nclass Solution {\\n    \\n    int ans = 0;\\n    public int maxSumBST(TreeNode root) {\\n        solve(root);\\n        return ans;\\n    }\\n    // int[] = { min, max, sum };\\n    private int[] solve(TreeNode root) {\\n        if(root == null) \\n            return new int[] { Integer.MAX_VALUE, Integer.MIN_VALUE, 0 };\\n        \\n        int[] left = solve(root.left);\\n        int[] right = solve(root.right);\\n        \\n        if(root.val > left[1] && root.val < right[0]) {\\n             int sum = left[2] + right[2] + root.val;\\n             ans = Math.max(ans, sum);\\n             return new int[] { Math.min(left[0], root.val), Math.max(root.val, right[1]), sum };  \\n        }\\n\\t\\t\\n        return new int[] { Integer.MIN_VALUE, Integer.MAX_VALUE, 0 }; \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int ans = 0;\\n    public int maxSumBST(TreeNode root) {\\n        solve(root);\\n        return ans;\\n    }\\n    // int[] = { min, max, sum };\\n    private int[] solve(TreeNode root) {\\n        if(root == null) \\n            return new int[] { Integer.MAX_VALUE, Integer.MIN_VALUE, 0 };\\n        \\n        int[] left = solve(root.left);\\n        int[] right = solve(root.right);\\n        \\n        if(root.val > left[1] && root.val < right[0]) {\\n             int sum = left[2] + right[2] + root.val;\\n             ans = Math.max(ans, sum);\\n             return new int[] { Math.min(left[0], root.val), Math.max(root.val, right[1]), sum };  \\n        }\\n\\t\\t\\n        return new int[] { Integer.MIN_VALUE, Integer.MAX_VALUE, 0 }; \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2380070,
                "title": "c-simple-recursive-solution-detailed-explanation",
                "content": "**Logic:**\\nWe know that for any BST:\\n1. Root is greater than the smallest element in its left subtree\\n2. Root is smaller than the largest element in its right subtree\\n\\n```\\nclass Solution {\\npublic:\\n\\t // Stores the ans\\n    int sum = 0;\\n    \\n\\t// Returns {sum of all nodes, {min node, max node}} of the subtree\\n    pair<int,pair<int,int>> helper(TreeNode *root){\\n\\t\\t// For NULL node, sum = 0 and consider min = INT_MAX and max = INT_MIN\\n        if(root == NULL){\\n            return {0, {INT_MAX, INT_MIN}};\\n        }\\n        \\n\\t\\t// Moving into left and right children\\n        pair<int,pair<int,int>> lst = helper(root->left);\\n        pair<int,pair<int,int>> rst = helper(root->right);\\n        \\n        // Valid BST (max in left < root and root < min in right)\\n        if(lst.second.second < root->val && root->val < rst.second.first){\\n            int s = root->val + lst.first + rst.first;\\n            sum = max(sum, s);\\n\\t\\t\\t// Updating the min and max of the subtree\\n            int mi = min({root->val, lst.second.first, rst.second.first});\\n            int ma = max({root->val, lst.second.second, rst.second.second});\\n            return {s, {mi, ma}};\\n        }\\n        \\n\\t\\t// Not a valid BST, then make min = INT_MIN and max = INT_MAX\\n\\t\\t// so that any subsequent parent nodes cannot consider the current subtree in BST\\n        return {0, {INT_MIN, INT_MAX}};\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```\\n\\n**References:** https://www.youtube.com/watch?v=X0oXMdtUDwo (Took insipiration from this video)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t // Stores the ans\\n    int sum = 0;\\n    \\n\\t// Returns {sum of all nodes, {min node, max node}} of the subtree\\n    pair<int,pair<int,int>> helper(TreeNode *root){\\n\\t\\t// For NULL node, sum = 0 and consider min = INT_MAX and max = INT_MIN\\n        if(root == NULL){\\n            return {0, {INT_MAX, INT_MIN}};\\n        }\\n        \\n\\t\\t// Moving into left and right children\\n        pair<int,pair<int,int>> lst = helper(root->left);\\n        pair<int,pair<int,int>> rst = helper(root->right);\\n        \\n        // Valid BST (max in left < root and root < min in right)\\n        if(lst.second.second < root->val && root->val < rst.second.first){\\n            int s = root->val + lst.first + rst.first;\\n            sum = max(sum, s);\\n\\t\\t\\t// Updating the min and max of the subtree\\n            int mi = min({root->val, lst.second.first, rst.second.first});\\n            int ma = max({root->val, lst.second.second, rst.second.second});\\n            return {s, {mi, ma}};\\n        }\\n        \\n\\t\\t// Not a valid BST, then make min = INT_MIN and max = INT_MAX\\n\\t\\t// so that any subsequent parent nodes cannot consider the current subtree in BST\\n        return {0, {INT_MIN, INT_MAX}};\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        helper(root);\\n        return sum;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2347445,
                "title": "optimal-c-solution-beats-100-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    pair<int, pair<int,int>> solve(TreeNode* root){\\n        if(!root->left && !root->right){\\n            ans = max(ans, root->val);\\n            return {root->val, {root->val, root->val}};\\n        }\\n        pair<int,pair<int,int>> left = {0,{INT_MAX,INT_MIN}}, right = {0,{INT_MAX,INT_MIN}};\\n        if(root->left) left = solve(root->left);\\n        if(root->right) right = solve(root->right);\\n        if(root->val>left.second.second && root->val<right.second.first){\\n            ans = max(ans, left.first+right.first+root->val);\\n            return {left.first+right.first+root->val, {min(left.second.first, root->val), max(right.second.second, root->val)}};\\n        }\\n        else return {0, {INT_MIN,INT_MAX}};\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL); \\n        auto x = solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    \\n    pair<int, pair<int,int>> solve(TreeNode* root){\\n        if(!root->left && !root->right){\\n            ans = max(ans, root->val);\\n            return {root->val, {root->val, root->val}};\\n        }\\n        pair<int,pair<int,int>> left = {0,{INT_MAX,INT_MIN}}, right = {0,{INT_MAX,INT_MIN}};\\n        if(root->left) left = solve(root->left);\\n        if(root->right) right = solve(root->right);\\n        if(root->val>left.second.second && root->val<right.second.first){\\n            ans = max(ans, left.first+right.first+root->val);\\n            return {left.first+right.first+root->val, {min(left.second.first, root->val), max(right.second.second, root->val)}};\\n        }\\n        else return {0, {INT_MIN,INT_MAX}};\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL); \\n        auto x = solve(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206165,
                "title": "cpp-code-o-n-tc-post-order-traversal-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n// the idea here is to find the largest bst subtree , then count sum of each element\\n// and return the sum\\n\\n// creating class to hold values \\nclass NodeValue{\\npublic:\\n    int maxVal , minVal , maxSum , sum , isBst;\\n    NodeValue( int mx , int mn , int ans , int s , int bst){\\n        this -> maxVal = mx ;\\n        this -> minVal = mn ; \\n        this -> maxSum = ans ;\\n        this -> sum = s ;\\n        this -> isBst = bst;\\n    }    \\n};\\n\\nclass Solution {\\nprivate:\\n    NodeValue largeSumBst( TreeNode* root){\\n        if ( !root) return NodeValue(INT_MIN , INT_MAX , 0 , 0 , 1 );\\n        \\n        // postorder traversal\\n        auto left = largeSumBst( root -> left );\\n        auto right = largeSumBst( root -> right );\\n        \\n        // if not bst\\n        if (!left.isBst or !right.isBst ){\\n            return NodeValue ( INT_MIN , INT_MAX , max ({ left.maxSum , right.maxSum , 0 }) , root -> val + right.sum + left.sum , 0 );\\n        }\\n        \\n        // if the tree is a valid bst \\n        if ( left.maxVal < root -> val and right.minVal > root -> val){\\n            return NodeValue ( max ( {root -> val , left.maxVal , right.maxVal }) , \\n                             min ({ root -> val , left.minVal , right.minVal }) ,\\n                             max ({ 0 , (root -> val + left.sum + right.sum ) , right.maxSum , left.maxSum}),\\n                                root -> val + left.sum + right.sum , 1);\\n        }\\n        \\n        // not a bst\\n        return NodeValue ( INT_MIN , INT_MAX , max ({ left.maxSum , right.maxSum , 0}) , root -> val + right.sum + left.sum , 0 );\\n    }\\n    \\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        if (!root) return 0 ;\\n        return largeSumBst( root ).maxSum ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n// the idea here is to find the largest bst subtree , then count sum of each element\\n// and return the sum\\n\\n// creating class to hold values \\nclass NodeValue{\\npublic:\\n    int maxVal , minVal , maxSum , sum , isBst;\\n    NodeValue( int mx , int mn , int ans , int s , int bst){\\n        this -> maxVal = mx ;\\n        this -> minVal = mn ; \\n        this -> maxSum = ans ;\\n        this -> sum = s ;\\n        this -> isBst = bst;\\n    }    \\n};\\n\\nclass Solution {\\nprivate:\\n    NodeValue largeSumBst( TreeNode* root){\\n        if ( !root) return NodeValue(INT_MIN , INT_MAX , 0 , 0 , 1 );\\n        \\n        // postorder traversal\\n        auto left = largeSumBst( root -> left );\\n        auto right = largeSumBst( root -> right );\\n        \\n        // if not bst\\n        if (!left.isBst or !right.isBst ){\\n            return NodeValue ( INT_MIN , INT_MAX , max ({ left.maxSum , right.maxSum , 0 }) , root -> val + right.sum + left.sum , 0 );\\n        }\\n        \\n        // if the tree is a valid bst \\n        if ( left.maxVal < root -> val and right.minVal > root -> val){\\n            return NodeValue ( max ( {root -> val , left.maxVal , right.maxVal }) , \\n                             min ({ root -> val , left.minVal , right.minVal }) ,\\n                             max ({ 0 , (root -> val + left.sum + right.sum ) , right.maxSum , left.maxSum}),\\n                                root -> val + left.sum + right.sum , 1);\\n        }\\n        \\n        // not a bst\\n        return NodeValue ( INT_MIN , INT_MAX , max ({ left.maxSum , right.maxSum , 0}) , root -> val + right.sum + left.sum , 0 );\\n    }\\n    \\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        if (!root) return 0 ;\\n        return largeSumBst( root ).maxSum ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003391,
                "title": "c-solution-easy-to-understand",
                "content": "```\\nstruct Node {\\n    int maximum;\\n    int minimum;\\n    int sum;\\n    bool isBst;\\n    Node() {\\n        maximum = INT_MIN;\\n        minimum = INT_MAX;\\n        sum = 0;\\n        isBst = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    Node getSum(TreeNode * root) {\\n\\t// base condition\\n        if (root == NULL) return Node();\\n\\t\\t\\n        Node node;\\n\\t\\t\\n\\t\\t// never question this step, just write it .This is important in every binary tree question\\n        Node node_left = getSum(root -> left);\\n        Node node_right = getSum(root -> right);\\n\\n// induction step, contains the main logic\\n        if (node_left.isBst == true && node_right.isBst == true && node_left.maximum < root -> val && node_right.minimum > root -> val) {\\n            node.sum = node_left.sum + node_right.sum + root -> val;\\n            node.isBst = true;\\n            node.minimum = min(root -> val, min(node_left.minimum, node_right.minimum));\\n            node.maximum = max(root -> val, max(node_left.maximum, node_right.maximum));\\n        } else {\\n            node.isBst = false;\\n            node.sum = 0;\\n        }\\n        ans = max(ans, node.sum);\\n        return node;\\n    }\\n\\t\\n    int maxSumBST(TreeNode * root) {\\n        ans = INT_MIN;\\n        getSum(root);\\n        if (ans > 0) return ans;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct Node {\\n    int maximum;\\n    int minimum;\\n    int sum;\\n    bool isBst;\\n    Node() {\\n        maximum = INT_MIN;\\n        minimum = INT_MAX;\\n        sum = 0;\\n        isBst = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    Node getSum(TreeNode * root) {\\n\\t// base condition\\n        if (root == NULL) return Node();\\n\\t\\t\\n        Node node;\\n\\t\\t\\n\\t\\t// never question this step, just write it .This is important in every binary tree question\\n        Node node_left = getSum(root -> left);\\n        Node node_right = getSum(root -> right);\\n\\n// induction step, contains the main logic\\n        if (node_left.isBst == true && node_right.isBst == true && node_left.maximum < root -> val && node_right.minimum > root -> val) {\\n            node.sum = node_left.sum + node_right.sum + root -> val;\\n            node.isBst = true;\\n            node.minimum = min(root -> val, min(node_left.minimum, node_right.minimum));\\n            node.maximum = max(root -> val, max(node_left.maximum, node_right.maximum));\\n        } else {\\n            node.isBst = false;\\n            node.sum = 0;\\n        }\\n        ans = max(ans, node.sum);\\n        return node;\\n    }\\n\\t\\n    int maxSumBST(TreeNode * root) {\\n        ans = INT_MIN;\\n        getSum(root);\\n        if (ans > 0) return ans;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638387,
                "title": "java-postorder-o-n-learned-from-labuladong",
                "content": "#### Before Everything\\nThe solution is I learned from **labuladong.** \\nhttps://labuladong.gitee.io/algo/2/18/27/\\n#### Idea\\nFor solving the problem, with the view of <u>the current root</u>, we need to know following things:\\n+  `sum` of left subtree and right subtree\\n+  `min` of right subtree\\n+  `max` of left subtree\\n+  `isBST` of leftSubtree\\n\\nBecause only following conditions, can we update the global variable`maxSum` which stores the possible answer:\\n+ left subtree is BST, right subtree is BST\\n+ current tree is BST\\n\\nSo we use an array to store the result of each tree\\n```java\\n// int[] res = new int[]{sum, min, max, isBST}\\nint[] res = new int[4]; \\n```\\nConvert two conditions into mathematical expression:\\n```java\\n// left subtree is BST, right subtree is BST\\nleft[3] == 1 && right[3] == 1;\\n// current tree is BST\\n// i.e., the value of root should less than min of right subtree and greater than max of left subtree\\nroot.val > left[2] && root.val < right[1];\\n```\\nWhen  the conditions are satisfied, we can update the global variable `maxSum`\\n```java\\n this.maxSum = Math.max(curr[0], this.maxSum);\\n```\\n#### Code\\n```\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        traverse(root);\\n        return this.maxSum;\\n    }\\n    \\n    // int[] sum = {sum, min, max, isBST}\\n    private int[] traverse(TreeNode root){\\n        // base case\\n        if(root == null){\\n            return new int[]{0, Integer.MAX_VALUE, Integer.MIN_VALUE, 1};\\n        }\\n        // left\\n        int[] left = traverse(root.left);\\n        // right\\n        int[] right = traverse(root.right);\\n        // root\\n        // check left and right is BST or not, if so, check if root and min and max okay, then update sum\\n        int[] curr = new int[4];\\n        if(left[3] == 1 && right[3] == 1 && root.val > left[2] && root.val < right[1]){\\n            curr[3] = 1;\\n            curr[0] = left[0] + right[0] + root.val;\\n            curr[1] = Math.min(root.val, left[1]);\\n            curr[2] = Math.max(root.val, right[2]);\\n            this.maxSum = Math.max(curr[0], this.maxSum);\\n        }else{\\n            curr[3] = 0;\\n        }\\n        return curr;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java\\n// int[] res = new int[]{sum, min, max, isBST}\\nint[] res = new int[4]; \\n```\n```java\\n// left subtree is BST, right subtree is BST\\nleft[3] == 1 && right[3] == 1;\\n// current tree is BST\\n// i.e., the value of root should less than min of right subtree and greater than max of left subtree\\nroot.val > left[2] && root.val < right[1];\\n```\n```java\\n this.maxSum = Math.max(curr[0], this.maxSum);\\n```\n```\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        traverse(root);\\n        return this.maxSum;\\n    }\\n    \\n    // int[] sum = {sum, min, max, isBST}\\n    private int[] traverse(TreeNode root){\\n        // base case\\n        if(root == null){\\n            return new int[]{0, Integer.MAX_VALUE, Integer.MIN_VALUE, 1};\\n        }\\n        // left\\n        int[] left = traverse(root.left);\\n        // right\\n        int[] right = traverse(root.right);\\n        // root\\n        // check left and right is BST or not, if so, check if root and min and max okay, then update sum\\n        int[] curr = new int[4];\\n        if(left[3] == 1 && right[3] == 1 && root.val > left[2] && root.val < right[1]){\\n            curr[3] = 1;\\n            curr[0] = left[0] + right[0] + root.val;\\n            curr[1] = Math.min(root.val, left[1]);\\n            curr[2] = Math.max(root.val, right[2]);\\n            this.maxSum = Math.max(curr[0], this.maxSum);\\n        }else{\\n            curr[3] = 0;\\n        }\\n        return curr;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281341,
                "title": "similar-to-largest-bst-in-binary-tree-problem",
                "content": "There are two cases: \\n1. If the Current Root be the root of the BST (when its value lies between maximum value in its left BST and minimum in its right BST). In that case, the sum it will store will be simply, left_sum + right_sum + root->val.\\n2.  Otherwise, the sum it will store will be max(left_sum,right_sum) because in this case we have max sum BST in either of its left and right subtree.\\n```\\nclass bst_node{\\n    public:\\n        bool isbst; //if true it means subtree rooted at current bst_node is BST\\n        int max_val; // It stores minimum value of BST nodes rooted at current bst_node.\\n        int min_val; // Smilar to max_val.\\n        int sum; //It stores sum of BST possible in subtree rooted at current bst_node.\\n};\\nclass Solution {\\npublic:\\n    bst_node solve(TreeNode* root, int &max_sum){\\n        if(!root){\\n            return {true,INT_MIN,INT_MAX,0};\\n        }\\n        auto left_info = solve(root->left,max_sum);\\n        auto right_info = solve(root->right,max_sum);\\n        bst_node root_info;\\n        if(left_info.isbst && right_info.isbst && left_info.max_val< root->val && root->val < right_info.min_val){\\n            root_info.isbst = true;\\n            root_info.min_val = min(root->val,left_info.min_val);\\n            root_info.max_val = max(root->val,right_info.max_val);\\n            root_info.sum = left_info.sum + right_info.sum + root->val;\\n        }\\n        else{\\n            root_info.isbst = false;\\n            root_info.min_val = min(root->val,left_info.min_val);\\n            root_info.max_val = max(root->val,right_info.max_val);\\n            root_info.sum = max(left_info.sum,right_info.sum);\\n        }\\n        max_sum  = max(max_sum,root_info.sum);\\n        return root_info;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int max_sum =0;\\n        solve(root,max_sum);\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass bst_node{\\n    public:\\n        bool isbst; //if true it means subtree rooted at current bst_node is BST\\n        int max_val; // It stores minimum value of BST nodes rooted at current bst_node.\\n        int min_val; // Smilar to max_val.\\n        int sum; //It stores sum of BST possible in subtree rooted at current bst_node.\\n};\\nclass Solution {\\npublic:\\n    bst_node solve(TreeNode* root, int &max_sum){\\n        if(!root){\\n            return {true,INT_MIN,INT_MAX,0};\\n        }\\n        auto left_info = solve(root->left,max_sum);\\n        auto right_info = solve(root->right,max_sum);\\n        bst_node root_info;\\n        if(left_info.isbst && right_info.isbst && left_info.max_val< root->val && root->val < right_info.min_val){\\n            root_info.isbst = true;\\n            root_info.min_val = min(root->val,left_info.min_val);\\n            root_info.max_val = max(root->val,right_info.max_val);\\n            root_info.sum = left_info.sum + right_info.sum + root->val;\\n        }\\n        else{\\n            root_info.isbst = false;\\n            root_info.min_val = min(root->val,left_info.min_val);\\n            root_info.max_val = max(root->val,right_info.max_val);\\n            root_info.sum = max(left_info.sum,right_info.sum);\\n        }\\n        max_sum  = max(max_sum,root_info.sum);\\n        return root_info;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int max_sum =0;\\n        solve(root,max_sum);\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043844,
                "title": "javascript-solution",
                "content": "https://leetcode.com/problems/validate-binary-search-tree/\\nhttps://leetcode.com/problems/binary-tree-maximum-path-sum/\\n\\nThere are two sub problems: how to check if subtree valid BST, and how to get the max sum of a subtree.\\n\\nThe base case is when we get to a leaf node, we return a \"blank\" object up the recursion stack --- we know the sum at a leaf is 0, it must be a valid BST because there are no nodes below it, and it has no upper and lower limit.\\n\\nThen, when we are at a node we need to check: are the left and right subtrees below it valid BSTs? and does this node have a value that is greater than the maximum value in the left subtree, and a value less then the minimum value in the right subtree? Remembering the rules of BSTs.\\n\\nIf so, we can calculate a new sum at that node and check if this is the best sum we have seen so far. In this case we return the current sum upwards and set our low and high values\\n\\n```\\nclass Result {\\n  constructor(sum, isBST, low, high) {\\n    this.sum = sum\\n    this.isBST = isBST\\n    this.low = low\\n    this.high = high\\n  }\\n}\\n\\nconst maxSumBST = function(root) {\\n  let maxSum = 0\\n\\n  const search = root => {\\n    if (!root) {\\n      return new Result(\\n        0,\\n        true,\\n        Number.MAX_SAFE_INTEGER,\\n        Number.MIN_SAFE_INTEGER\\n      )\\n    }\\n\\n    const left = search(root.left)\\n    const right = search(root.right)\\n\\n    if (left.isBST && right.isBST && root.val > left.high && root.val < right.low) {\\n      const sum = root.val + left.sum + right.sum\\n      maxSum = Math.max(maxSum, sum)\\n\\n      return new Result(\\n        sum,\\n        true,\\n        Math.min(root.val, left.low),\\n        Math.max(root.val, right.high)\\n      )\\n    }\\n\\n    return new Result(0, false, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER)\\n  }\\n\\n  search(root)\\n\\n  return maxSum\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Result {\\n  constructor(sum, isBST, low, high) {\\n    this.sum = sum\\n    this.isBST = isBST\\n    this.low = low\\n    this.high = high\\n  }\\n}\\n\\nconst maxSumBST = function(root) {\\n  let maxSum = 0\\n\\n  const search = root => {\\n    if (!root) {\\n      return new Result(\\n        0,\\n        true,\\n        Number.MAX_SAFE_INTEGER,\\n        Number.MIN_SAFE_INTEGER\\n      )\\n    }\\n\\n    const left = search(root.left)\\n    const right = search(root.right)\\n\\n    if (left.isBST && right.isBST && root.val > left.high && root.val < right.low) {\\n      const sum = root.val + left.sum + right.sum\\n      maxSum = Math.max(maxSum, sum)\\n\\n      return new Result(\\n        sum,\\n        true,\\n        Math.min(root.val, left.low),\\n        Math.max(root.val, right.high)\\n      )\\n    }\\n\\n    return new Result(0, false, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER)\\n  }\\n\\n  search(root)\\n\\n  return maxSum\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 891024,
                "title": "java-short-solution-do-not-need-post-order-traversal",
                "content": "```\\nclass Output{\\n    boolean bst;\\n    int sum;\\n    int max;\\n    int min;\\n    public Output(boolean bst, int sum, int min, int max) {\\n            this.bst = bst;\\n            this.sum = sum;\\n            this.min = min;\\n            this.max = max;\\n        }\\n}\\nclass Solution {\\n    int res = 0;\\n    public int maxSumBST(TreeNode root) {\\n        //sumBST(x): the sum of valid bst, with the root is x\\n        if(root==null) return 0;\\n        sumBST(root);\\n        return res;        \\n    }\\n    private Output sumBST(TreeNode root) {\\n        if(root==null) {\\n            return new Output(true, 0, Integer.MAX_VALUE, Integer.MIN_VALUE);\\n        }\\n        boolean bst = false;\\n        int max=root.val, min=root.val, sum=root.val;\\n        \\n        Output left = sumBST(root.left);\\n        Output right = sumBST(root.right);\\n            if(left.bst && right.bst && left.max<root.val && right.min>root.val) {\\n                bst = true;\\n                min = Math.min(left.min, root.val);\\n                max = Math.max(right.max, root.val);\\n                sum+=left.sum+right.sum;  \\n                res = Math.max(res, sum);\\n                return new Output(bst, sum, min, max);\\n            }\\n            return new Output(bst, sum, min, max);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Output{\\n    boolean bst;\\n    int sum;\\n    int max;\\n    int min;\\n    public Output(boolean bst, int sum, int min, int max) {\\n            this.bst = bst;\\n            this.sum = sum;\\n            this.min = min;\\n            this.max = max;\\n        }\\n}\\nclass Solution {\\n    int res = 0;\\n    public int maxSumBST(TreeNode root) {\\n        //sumBST(x): the sum of valid bst, with the root is x\\n        if(root==null) return 0;\\n        sumBST(root);\\n        return res;        \\n    }\\n    private Output sumBST(TreeNode root) {\\n        if(root==null) {\\n            return new Output(true, 0, Integer.MAX_VALUE, Integer.MIN_VALUE);\\n        }\\n        boolean bst = false;\\n        int max=root.val, min=root.val, sum=root.val;\\n        \\n        Output left = sumBST(root.left);\\n        Output right = sumBST(root.right);\\n            if(left.bst && right.bst && left.max<root.val && right.min>root.val) {\\n                bst = true;\\n                min = Math.min(left.min, root.val);\\n                max = Math.max(right.max, root.val);\\n                sum+=left.sum+right.sum;  \\n                res = Math.max(res, sum);\\n                return new Output(bst, sum, min, max);\\n            }\\n            return new Output(bst, sum, min, max);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 749916,
                "title": "c-easy-traversal-with-comments",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n//check if valid BST for given root.\\n    bool isValid(TreeNode* root, int* left, int* right)\\n    {\\n        if(root == NULL)\\n            return true;\\n        else\\n        {\\n            if(left != NULL && root->val <= *left)\\n                return false;\\n            if(right != NULL && root->val >= *right)\\n                return false;\\n            return isValid(root->left, left, &root->val) && isValid(root->right, &root->val, right);\\n        }\\n    }\\n    \\n    int maxSum(TreeNode* root, int& max)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        else\\n        {\\n            int l = maxSum(root->left, max);\\n            int r = maxSum(root->right, max);\\n            max = std::max(max, std::max(l, std::max(r, l + r + root->val)));\\n            return l + r + root->val;\\n        }\\n    }\\n    //check for valid BST in binary tree\\n    int getMax(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        if(isValid(root, NULL, NULL))\\n        {\\n\\t\\t\\t// true then even the subtree is BST, so just find the max subtree sum.\\n            int max = INT_MIN;\\n            maxSum(root, max);\\n            return max;\\n        }\\n        else\\n\\t\\t\\t// Recursive=ly find for left and right nodes, if the present node is not a valid BST.\\n            return max(getMax(root->left), getMax(root->right));\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n            return getMax(root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n//check if valid BST for given root.\\n    bool isValid(TreeNode* root, int* left, int* right)\\n    {\\n        if(root == NULL)\\n            return true;\\n        else\\n        {\\n            if(left != NULL && root->val <= *left)\\n                return false;\\n            if(right != NULL && root->val >= *right)\\n                return false;\\n            return isValid(root->left, left, &root->val) && isValid(root->right, &root->val, right);\\n        }\\n    }\\n    \\n    int maxSum(TreeNode* root, int& max)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        else\\n        {\\n            int l = maxSum(root->left, max);\\n            int r = maxSum(root->right, max);\\n            max = std::max(max, std::max(l, std::max(r, l + r + root->val)));\\n            return l + r + root->val;\\n        }\\n    }\\n    //check for valid BST in binary tree\\n    int getMax(TreeNode* root)\\n    {\\n        if(root == NULL)\\n            return 0;\\n        if(isValid(root, NULL, NULL))\\n        {\\n\\t\\t\\t// true then even the subtree is BST, so just find the max subtree sum.\\n            int max = INT_MIN;\\n            maxSum(root, max);\\n            return max;\\n        }\\n        else\\n\\t\\t\\t// Recursive=ly find for left and right nodes, if the present node is not a valid BST.\\n            return max(getMax(root->left), getMax(root->right));\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n            return getMax(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536508,
                "title": "why-post-order-traversal-is-ideal-to-solve-this-one-solution",
                "content": "Most solutions discussed here solve this using Post Order traversal. I tried to solve this using preorder traversal (using the floor and ceiling method to check validity of BST like in [here](https://leetcode.com/problems/validate-binary-search-tree/discuss/32178/Clean-Python-Solution/31031)), and got confused.\\n\\nFor this problem we need to build the solution from the bottom-up i.e., from the leaf nodes towards the root. Only then can we check if the current sub-tree is a valid BST, and then update the maximum sum. This means post order is the ideal way to traverse the tree.\\n\\nHere\\'s a solution using this idea: \\n```python\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = 0\\n        \\n    def maxSumBST(self, root):\\n        def postOrderTraverse(node):\\n            \"\"\" \\n            Perform post order traversal of tree\\n            to determine sub trees which are BSTs\\n            and calculate maximum sum of its elements.\\n            \\n            Returns:\\n            isValidBST: True if valid BST else False\\n            currentSum: sum of current sub tree. None \\n                        if not a valid BST.\\n            currentMin: minimum value of current sub tree\\n            currentMax: maximum value of current sub tree\\n            \"\"\"\\n            if not node:\\n                return True, 0, float(\\'inf\\'), float(\\'-inf\\') # Empty sub tree\\n\\n            lValidBST, lSum, lMin, lMax = postOrderTraverse(node.left)\\n            rValidBST, rSum, rMin, rMax = postOrderTraverse(node.right)\\n\\n            # Check if current subtree is a valid BST\\n            if lValidBST and rValidBST and lMax < node.val < rMin: \\n                currSum = lSum + rSum + node.val\\n                currMin = lMin if lMin != float(\\'inf\\') else node.val\\n                currMax = rMax if rMax != float(\\'-inf\\') else node.val\\n                self.maxSum = max(self.maxSum, currSum)  # update max sum\\n                return True, currSum, currMin, currMax\\n            \\n            return False, None, None, None \\n        \\n        postOrderTraverse(root)\\n        return self.maxSum\\n```\\n\\n(Code is modified from [this post](https://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531800/Python-Easy-traversal-with-explanation) for readability)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def __init__(self):\\n        self.maxSum = 0\\n        \\n    def maxSumBST(self, root):\\n        def postOrderTraverse(node):\\n            \"\"\" \\n            Perform post order traversal of tree\\n            to determine sub trees which are BSTs\\n            and calculate maximum sum of its elements.\\n            \\n            Returns:\\n            isValidBST: True if valid BST else False\\n            currentSum: sum of current sub tree. None \\n                        if not a valid BST.\\n            currentMin: minimum value of current sub tree\\n            currentMax: maximum value of current sub tree\\n            \"\"\"\\n            if not node:\\n                return True, 0, float(\\'inf\\'), float(\\'-inf\\') # Empty sub tree\\n\\n            lValidBST, lSum, lMin, lMax = postOrderTraverse(node.left)\\n            rValidBST, rSum, rMin, rMax = postOrderTraverse(node.right)\\n\\n            # Check if current subtree is a valid BST\\n            if lValidBST and rValidBST and lMax < node.val < rMin: \\n                currSum = lSum + rSum + node.val\\n                currMin = lMin if lMin != float(\\'inf\\') else node.val\\n                currMax = rMax if rMax != float(\\'-inf\\') else node.val\\n                self.maxSum = max(self.maxSum, currSum)  # update max sum\\n                return True, currSum, currMin, currMax\\n            \\n            return False, None, None, None \\n        \\n        postOrderTraverse(root)\\n        return self.maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533254,
                "title": "python-easy-to-understand-divide-and-conquer",
                "content": "The recursive helper function passes four variables: \\n1. max sum down stream from current root(including all sub tree)\\n2. sum starting from current node: \\n\\t -if current tree is a valid BST, return the sum\\n\\t -otherwise return INT_MIN value\\n3. return the min value of the tree starting from current node\\n4.  return the max value of the tree starting from current node\\n\\n1 and 2 are used for passing sum values, while 3 and 4 are used for BST validation,\\nThere is a trick for empty node case: the min is INT_MAX and max is INT_MIN.\\nBy using this trick, for the following tree:\\n        2\\n    /      \\\\\\\\\\nnull     null\\n\\nroot.val = 2, which is larger than the left sub\\'s max, which is INT_MIN\\nans 2 is smaller than the right sub\\'s min, which is INT_MAX\\n\\nsimilar question: \\nhttps://leetcode.com/problems/validate-binary-search-tree/\\nhttps://leetcode.com/problems/largest-bst-subtree/\\n```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        return self.helper(root)[0]\\n    \\n    def helper(self, root):\\n        if not root:\\n            return 0, 0, float(\"inf\"), float(\"-inf\") # max sum, current sum, min max of sub tree\\n        left_sum, left_cursum, left_min, left_max = self.helper(root.left)\\n        right_sum, right_cursum, right_min, right_max = self.helper(root.right)\\n        if root.val <= left_max or root.val >= right_min: # not a valid BST\\n            return max(left_sum, right_sum), float(\"-inf\"), float(\\'-inf\\'), float(\\'inf\\')\\n        cursum = left_cursum + right_cursum + root.val\\n        return max(left_sum, right_sum, cursum), cursum, min(left_min, root.val), max(right_max, root.val)\\n```",
                "solutionTags": [
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        return self.helper(root)[0]\\n    \\n    def helper(self, root):\\n        if not root:\\n            return 0, 0, float(\"inf\"), float(\"-inf\") # max sum, current sum, min max of sub tree\\n        left_sum, left_cursum, left_min, left_max = self.helper(root.left)\\n        right_sum, right_cursum, right_min, right_max = self.helper(root.right)\\n        if root.val <= left_max or root.val >= right_min: # not a valid BST\\n            return max(left_sum, right_sum), float(\"-inf\"), float(\\'-inf\\'), float(\\'inf\\')\\n        cursum = left_cursum + right_cursum + root.val\\n        return max(left_sum, right_sum, cursum), cursum, min(left_min, root.val), max(right_max, root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532881,
                "title": "python-o-n-by-dfs-85-w-hint",
                "content": "Python O(n) by DFS. 85%+\\n\\n---\\n\\n**Hint**:\\n\\nThink of **post-order DFS** to develop a algorithm to update maximum value by each summation of valid BST.\\n\\nTake care that **initial value of maximum** should be **0** to **reject negative summation value**.\\n\\n---\\n\\n\\n```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        \\n        maximum_sum = 0\\n        \\n        def sumBST( node: TreeNode):\\n            \\n            if not node:\\n                return True, 0, float(\\'inf\\'), float(\\'-inf\\')\\n            \\n            else:\\n                \\n                is_left_bst, l_sum, l_min, l_max = sumBST( node.left )\\n                is_right_bst, r_sum, r_min, r_max = sumBST( node.right )\\n \\n                nonlocal maximum_sum\\n                cur_sum = l_sum + node.val + r_sum\\n        \\n                # If current subtree is BST, then compare and update maximum_sum\\n                # Otherwise, return (False, 0, None, None) to parent level\\n            \\n                if is_left_bst and is_right_bst and l_max < node.val < r_min:\\n\\n                    cur_min = l_min if l_min != float(\\'inf\\') else node.val\\n                    cur_max = r_max if r_max != float(\\'-inf\\') else node.val\\n                    \\n                    maximum_sum = max(maximum_sum, cur_sum )\\n                    return True, cur_sum, cur_min, cur_max\\n                \\n                else:\\n                    return False, 0, None, None\\n\\n        # ----------------------------------------\\n        sumBST( root )\\n        return maximum_sum\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #98 Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)\\n\\n[Leetcode #938 Range Sum of BST](https://leetcode.com/problems/range-sum-of-bst/)\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Binary Search Tree](https://en.wikipedia.org/wiki/Binary_search_tree)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        \\n        maximum_sum = 0\\n        \\n        def sumBST( node: TreeNode):\\n            \\n            if not node:\\n                return True, 0, float(\\'inf\\'), float(\\'-inf\\')\\n            \\n            else:\\n                \\n                is_left_bst, l_sum, l_min, l_max = sumBST( node.left )\\n                is_right_bst, r_sum, r_min, r_max = sumBST( node.right )\\n \\n                nonlocal maximum_sum\\n                cur_sum = l_sum + node.val + r_sum\\n        \\n                # If current subtree is BST, then compare and update maximum_sum\\n                # Otherwise, return (False, 0, None, None) to parent level\\n            \\n                if is_left_bst and is_right_bst and l_max < node.val < r_min:\\n\\n                    cur_min = l_min if l_min != float(\\'inf\\') else node.val\\n                    cur_max = r_max if r_max != float(\\'-inf\\') else node.val\\n                    \\n                    maximum_sum = max(maximum_sum, cur_sum )\\n                    return True, cur_sum, cur_min, cur_max\\n                \\n                else:\\n                    return False, 0, None, None\\n\\n        # ----------------------------------------\\n        sumBST( root )\\n        return maximum_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531957,
                "title": "c-concise-recursion-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int maxSumBST(TreeNode* root) {\\n        h(root);\\n        return ans;\\n    }\\n    \\n    //return value {isBST, sum_of_tree, min_value_of_tree, max_value_of_tree }\\n    vector<int> h(TreeNode* root) {\\n        if(!root) return {true, 0};\\n        auto res1 = h(root->left);\\n        auto res2 = h(root->right);\\n        if(res1[0] && (!root->left || res1[3] < root->val)) {\\n            if(res2[0] && (!root->right ||  res2[2] > root->val)) {\\n                int sum = res1[1] + res2[1] + root->val;\\n                ans = max(ans, sum);\\n                return {true, sum, root->left ? res1[2] : root->val, root->right ? res2[3] : root->val};\\n            }\\n        }\\n        return {false, 0};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    int maxSumBST(TreeNode* root) {\\n        h(root);\\n        return ans;\\n    }\\n    \\n    //return value {isBST, sum_of_tree, min_value_of_tree, max_value_of_tree }\\n    vector<int> h(TreeNode* root) {\\n        if(!root) return {true, 0};\\n        auto res1 = h(root->left);\\n        auto res2 = h(root->right);\\n        if(res1[0] && (!root->left || res1[3] < root->val)) {\\n            if(res2[0] && (!root->right ||  res2[2] > root->val)) {\\n                int sum = res1[1] + res2[1] + root->val;\\n                ans = max(ans, sum);\\n                return {true, sum, root->left ? res1[2] : root->val, root->right ? res2[3] : root->val};\\n            }\\n        }\\n        return {false, 0};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531809,
                "title": "easy-java-solution-clean-code",
                "content": "```\\nprivate class BSTInfo {\\n        boolean isBST;\\n        int sum;\\n        int currentMax;\\n        int max;\\n        int min;\\n        BSTInfo(int max, int min, boolean isBST, int sum, int currentSum) {\\n            this.max = max;\\n            this.min = min;\\n            this.isBST = isBST;\\n            this.sum = sum;\\n            currentMax = currentSum;\\n        }\\n        BSTInfo() {\\n        }\\n    }\\n\\n    private int maxSum;\\n\\n    public int maxSumBST(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        int ans = util(root).currentMax;\\n        return ans<0?0:ans;\\n    }\\n\\n    private BSTInfo util(TreeNode root) {\\n        if (root == null) {\\n            return new BSTInfo( Integer.MIN_VALUE, Integer.MAX_VALUE, true, 0, 0 );\\n        }\\n\\n        if (root.left == null && root.right == null) {\\n            maxSum = Math.max(maxSum, root.val);\\n            return new BSTInfo( root.val, root.val, true, root.val, maxSum);\\n        }\\n\\n        // Store information about the left subtree\\n        BSTInfo leftTree = util(root.left);\\n\\n        // Store information about the right subtree\\n        BSTInfo rightTree = util(root.right);\\n\\n        BSTInfo bstInfo=new BSTInfo();\\n\\n        // Check If the subtree rooted under the current node is a Binary Search Tree\\n        if (leftTree.isBST && rightTree.isBST && leftTree.max < root.val && rightTree.min > root.val) {\\n            bstInfo.max = Math.max(root.val, Math.max(leftTree.max, rightTree.max));\\n            bstInfo.min = Math.min(root.val, Math.min(leftTree.min, rightTree.min));\\n            maxSum = Math.max(maxSum, rightTree.sum + root.val + leftTree.sum);\\n            bstInfo.sum = rightTree.sum + root.val + leftTree.sum;\\n            // Update the current maximum sum\\n            bstInfo.currentMax = maxSum;\\n            bstInfo.isBST = true;\\n            return bstInfo;\\n        }\\n\\n        // If the entire tree is not a Binary Search Tree then simply update the current maximum sum\\n        bstInfo.isBST = false;\\n        bstInfo.currentMax = maxSum;\\n        bstInfo.sum = rightTree.sum + root.val + leftTree.sum;\\n        return bstInfo;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nprivate class BSTInfo {\\n        boolean isBST;\\n        int sum;\\n        int currentMax;\\n        int max;\\n        int min;\\n        BSTInfo(int max, int min, boolean isBST, int sum, int currentSum) {\\n            this.max = max;\\n            this.min = min;\\n            this.isBST = isBST;\\n            this.sum = sum;\\n            currentMax = currentSum;\\n        }\\n        BSTInfo() {\\n        }\\n    }\\n\\n    private int maxSum;\\n\\n    public int maxSumBST(TreeNode root) {\\n        maxSum = Integer.MIN_VALUE;\\n        int ans = util(root).currentMax;\\n        return ans<0?0:ans;\\n    }\\n\\n    private BSTInfo util(TreeNode root) {\\n        if (root == null) {\\n            return new BSTInfo( Integer.MIN_VALUE, Integer.MAX_VALUE, true, 0, 0 );\\n        }\\n\\n        if (root.left == null && root.right == null) {\\n            maxSum = Math.max(maxSum, root.val);\\n            return new BSTInfo( root.val, root.val, true, root.val, maxSum);\\n        }\\n\\n        // Store information about the left subtree\\n        BSTInfo leftTree = util(root.left);\\n\\n        // Store information about the right subtree\\n        BSTInfo rightTree = util(root.right);\\n\\n        BSTInfo bstInfo=new BSTInfo();\\n\\n        // Check If the subtree rooted under the current node is a Binary Search Tree\\n        if (leftTree.isBST && rightTree.isBST && leftTree.max < root.val && rightTree.min > root.val) {\\n            bstInfo.max = Math.max(root.val, Math.max(leftTree.max, rightTree.max));\\n            bstInfo.min = Math.min(root.val, Math.min(leftTree.min, rightTree.min));\\n            maxSum = Math.max(maxSum, rightTree.sum + root.val + leftTree.sum);\\n            bstInfo.sum = rightTree.sum + root.val + leftTree.sum;\\n            // Update the current maximum sum\\n            bstInfo.currentMax = maxSum;\\n            bstInfo.isBST = true;\\n            return bstInfo;\\n        }\\n\\n        // If the entire tree is not a Binary Search Tree then simply update the current maximum sum\\n        bstInfo.isBST = false;\\n        bstInfo.currentMax = maxSum;\\n        bstInfo.sum = rightTree.sum + root.val + leftTree.sum;\\n        return bstInfo;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531803,
                "title": "c-tree-bottom-up",
                "content": "```\\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    \\n    int isBst(TreeNode* root)\\n    {\\n        if(!root) return 0;\\n        if(!root->left && !root->right)\\n        {\\n            max1=max(max1,root->val);\\n            return root->val;\\n        }\\n        int left = isBst(root->left);\\n        int right = isBst(root->right);\\n        if(left!=INT_MIN && right!=INT_MIN)\\n        {\\n            if(root->left!=NULL && root->left->val>=root->val) return INT_MIN;\\n            if(root->right!=NULL && root->right->val<=root->val) return INT_MIN;\\n            int m = left+right+root->val;     \\n            max1=max(m,max1);\\n            return m;\\n        }\\n        return INT_MIN;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        isBst(root);\\n        return max1;\\n    }\\n};\\n```\\nThe above solution will not work for cases like [6,3,7,1,4,5,10]\\n\\nBelow is the solution which handles these cases too.\\nBasically at each node we need to keep track of max  node in left subtree and min node in right subtree.\\n\\n```\\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    \\n    vector<int> isBst(TreeNode* root)\\n    {\\n        if(!root) return {0, INT_MIN, INT_MIN};\\n        if(!root->left && !root->right)\\n        {\\n            max1 = max(max1, root->val);\\n            return {root->val, root->val, root->val};\\n        }\\n        vector<int> left = isBst(root->left);\\n        vector<int> right = isBst(root->right);\\n        \\n        if(left[0] != INT_MIN && right[0] != INT_MIN)\\n        {\\n            if(root->left != NULL && left[1] >= root->val) return {INT_MIN, INT_MIN, INT_MIN};\\n            \\n            if(root->right != NULL && right[2] <= root->val) return {INT_MIN, INT_MIN, INT_MIN};\\n         \\n            int sum = left[0] + right[0] + root->val;     // current sum\\n            \\n            max1 = max(sum,max1);                           //result till now\\n            \\n            int maxTillNow = 0;\\n            if(left[1]==INT_MIN)     //Dont consider left subtree if it does  not exist eg:{16,null,17}          \\n                maxTillNow = max(root->val, right[2]);  \\n            else      //dont consider right subtree if does not exist eg: {16,15,null}\\n                maxTillNow = max(left[1], max(root->val, right[2]==INT_MIN? root->val:right[2]));\\n            \\n            int minTillNow = 0;\\t\\t\\t\\n            if(right[2]==INT_MIN)    //dont oconsider right subtree if it does not exist eg:{16,15,null}\\n                minTillNow = min(root->val, left[1]);  \\n\\t\\t\\telse    //dont consider left subtree if it does not exist eg:{16,null,17}\\n                minTillNow = min(right[2], min(root->val, left[1]==INT_MIN? root->val:left[1]));       \\n            \\n            return {sum, maxTillNow, minTillNow};\\n        }\\n        return {INT_MIN, INT_MIN, INT_MIN};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        isBst(root);\\n        return max1;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    \\n    int isBst(TreeNode* root)\\n    {\\n        if(!root) return 0;\\n        if(!root->left && !root->right)\\n        {\\n            max1=max(max1,root->val);\\n            return root->val;\\n        }\\n        int left = isBst(root->left);\\n        int right = isBst(root->right);\\n        if(left!=INT_MIN && right!=INT_MIN)\\n        {\\n            if(root->left!=NULL && root->left->val>=root->val) return INT_MIN;\\n            if(root->right!=NULL && root->right->val<=root->val) return INT_MIN;\\n            int m = left+right+root->val;     \\n            max1=max(m,max1);\\n            return m;\\n        }\\n        return INT_MIN;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        isBst(root);\\n        return max1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int max1 = 0;\\n    \\n    vector<int> isBst(TreeNode* root)\\n    {\\n        if(!root) return {0, INT_MIN, INT_MIN};\\n        if(!root->left && !root->right)\\n        {\\n            max1 = max(max1, root->val);\\n            return {root->val, root->val, root->val};\\n        }\\n        vector<int> left = isBst(root->left);\\n        vector<int> right = isBst(root->right);\\n        \\n        if(left[0] != INT_MIN && right[0] != INT_MIN)\\n        {\\n            if(root->left != NULL && left[1] >= root->val) return {INT_MIN, INT_MIN, INT_MIN};\\n            \\n            if(root->right != NULL && right[2] <= root->val) return {INT_MIN, INT_MIN, INT_MIN};\\n         \\n            int sum = left[0] + right[0] + root->val;     // current sum\\n            \\n            max1 = max(sum,max1);                           //result till now\\n            \\n            int maxTillNow = 0;\\n            if(left[1]==INT_MIN)     //Dont consider left subtree if it does  not exist eg:{16,null,17}          \\n                maxTillNow = max(root->val, right[2]);  \\n            else      //dont consider right subtree if does not exist eg: {16,15,null}\\n                maxTillNow = max(left[1], max(root->val, right[2]==INT_MIN? root->val:right[2]));\\n            \\n            int minTillNow = 0;\\t\\t\\t\\n            if(right[2]==INT_MIN)    //dont oconsider right subtree if it does not exist eg:{16,15,null}\\n                minTillNow = min(root->val, left[1]);  \\n\\t\\t\\telse    //dont consider left subtree if it does not exist eg:{16,null,17}\\n                minTillNow = min(right[2], min(root->val, left[1]==INT_MIN? root->val:left[1]));       \\n            \\n            return {sum, maxTillNow, minTillNow};\\n        }\\n        return {INT_MIN, INT_MIN, INT_MIN};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        isBst(root);\\n        return max1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995873,
                "title": "simple-cpp-solution-with-aproach-and-comments-92-beats-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n // properties we need to solve this\\n class info{\\n public:\\n   int maxi; \\n   int mini;\\n   bool isBst;\\n   int sum ;\\n };\\ninfo solve(TreeNode*root,int &ans){\\n    // if root== NULL then simply return the maximum and minimum and the currsum =0\\n    if(root==NULL){\\n        return {INT_MIN,INT_MAX,true,0};\\n    }\\n    // left call\\n    info left= solve(root->left,ans);\\n    // right\\n    info right = solve(root->right,ans);\\n    info currNode;\\n    //calculation for the sum of the current Node\\n    currNode.sum = left.sum +right.sum +root->val;\\n    //current node ke maximum value is define as\\n    // maximum of current Nodes val and maximum of right subtree\\n    currNode.maxi = max(root->val,right.maxi);\\n    // currNode ke minimum is defines as minimum of roots val and minimum of left subtree\\n    currNode.mini = min(root->val,left.mini);\\n    // now condition for being the current node is a bst\\n    // 1.left and right subtree are also bst \\n    //2.roots val lies btw maximum of left subtree ans minimum of right subtree\\n    if(left.isBst && right.isBst && \\n    (root->val>left.maxi && root->val<right.mini)){\\n        currNode.isBst= true;\\n    }\\n    else{\\n       currNode.isBst = false;\\n    }\\n    //if the current node is bst and add that node value also\\n    if(currNode.isBst){\\n        ans = max(ans,currNode.sum);\\n    }\\n    return currNode;\\n}\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int maxSum =0;\\n        info temp = solve(root,maxSum);\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n // properties we need to solve this\\n class info{\\n public:\\n   int maxi; \\n   int mini;\\n   bool isBst;\\n   int sum ;\\n };\\ninfo solve(TreeNode*root,int &ans){\\n    // if root== NULL then simply return the maximum and minimum and the currsum =0\\n    if(root==NULL){\\n        return {INT_MIN,INT_MAX,true,0};\\n    }\\n    // left call\\n    info left= solve(root->left,ans);\\n    // right\\n    info right = solve(root->right,ans);\\n    info currNode;\\n    //calculation for the sum of the current Node\\n    currNode.sum = left.sum +right.sum +root->val;\\n    //current node ke maximum value is define as\\n    // maximum of current Nodes val and maximum of right subtree\\n    currNode.maxi = max(root->val,right.maxi);\\n    // currNode ke minimum is defines as minimum of roots val and minimum of left subtree\\n    currNode.mini = min(root->val,left.mini);\\n    // now condition for being the current node is a bst\\n    // 1.left and right subtree are also bst \\n    //2.roots val lies btw maximum of left subtree ans minimum of right subtree\\n    if(left.isBst && right.isBst && \\n    (root->val>left.maxi && root->val<right.mini)){\\n        currNode.isBst= true;\\n    }\\n    else{\\n       currNode.isBst = false;\\n    }\\n    //if the current node is bst and add that node value also\\n    if(currNode.isBst){\\n        ans = max(ans,currNode.sum);\\n    }\\n    return currNode;\\n}\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int maxSum =0;\\n        info temp = solve(root,maxSum);\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994390,
                "title": "c-the-cleanest-solution-thus-far",
                "content": "The approach is simple, track the minimum, maximum, sum, and whether it is a valid BST, for each subtree, in a bottom to top fashion (Postorder).\\n\\nOn first glance, it appears lengthy but just focus on the dfs part - traverse in postorder and now update your 4 variables properly.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct TreeDetails {\\n        bool isBST;\\n        int minm;\\n        int maxm;\\n        int sum;\\n        TreeDetails (bool a, int b, int c, int d) {\\n            isBST = a;\\n            minm = b;\\n            maxm = c;\\n            sum = d;\\n        }\\n    };\\n\\n// core function\\n    TreeDetails* solve (TreeNode* root, int &ans) {\\n        if (!root) return new TreeDetails (true, INT_MAX, INT_MIN, 0);\\n\\n        // traverse in postorder\\n        TreeDetails *left = solve(root->left, ans);\\n        TreeDetails *right = solve(root->right, ans);\\n\\n        // CORE UPDATE logic for the 4 variables\\n        bool isBST = left->isBST && right->isBST && root->val > left->maxm && root->val < right->minm ;\\n\\n        int sum = left->sum + right->sum + root->val;\\n        if (isBST) ans = max(sum, ans);\\n\\n        int minm = min(root->val, min(left->minm, right->minm));\\n        int maxm = max(root->val, max(left->maxm, right->maxm));\\n\\n        //return\\n        return new TreeDetails (isBST, minm, maxm, sum);\\n    }\\n\\n\\n// driver function\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct TreeDetails {\\n        bool isBST;\\n        int minm;\\n        int maxm;\\n        int sum;\\n        TreeDetails (bool a, int b, int c, int d) {\\n            isBST = a;\\n            minm = b;\\n            maxm = c;\\n            sum = d;\\n        }\\n    };\\n\\n// core function\\n    TreeDetails* solve (TreeNode* root, int &ans) {\\n        if (!root) return new TreeDetails (true, INT_MAX, INT_MIN, 0);\\n\\n        // traverse in postorder\\n        TreeDetails *left = solve(root->left, ans);\\n        TreeDetails *right = solve(root->right, ans);\\n\\n        // CORE UPDATE logic for the 4 variables\\n        bool isBST = left->isBST && right->isBST && root->val > left->maxm && root->val < right->minm ;\\n\\n        int sum = left->sum + right->sum + root->val;\\n        if (isBST) ans = max(sum, ans);\\n\\n        int minm = min(root->val, min(left->minm, right->minm));\\n        int maxm = max(root->val, max(left->maxm, right->maxm));\\n\\n        //return\\n        return new TreeDetails (isBST, minm, maxm, sum);\\n    }\\n\\n\\n// driver function\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916346,
                "title": "basic-recursion-easy-approach-post-order-no-oops-concept",
                "content": "# Intuition\\nWe cant go to every node and and check for binary tree. If we check for every node, then it would surely give tle. Hence we need to go in one traversal and check for binary seach tree and calculate sum.\\n\\nWe say tree BST when root is greater than left and less than the right.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFor base case,  when we are at leaf node, they are always a bst in themselves\\nwhen we get null, we return min value as INT_MAX and max value as INT_MIN. So when it gets at leaf it satisfiy for bst.\\nnow at evety node we just check for bst\\n\\nif BST-->we take the sum of left subtree, right subtree and root.\\n\\nif value of left is less then root, and right is less then right, then we update our ans, mx, min variables,\\n\\notherwise we set the mx = INT_MAX, mn = INT_MIN\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n\\n- Time complexity:\\n TC-> O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1) but stack space is used\\nHence O(H) where H is height of tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nint rec(TreeNode *root,int &mx,int &mn,int &a)\\n    {\\n        if(!root) return 0;\\n        \\n\\t// lmn,lmx will find the minimum and maximum node in the left subtree \\n\\t// similarly, rmn,rmx will find minimum and maximum node in the right subtree\\n\\t\\t\\n        int lmn,rmn,rmx,lmx;\\n        \\n        lmn=rmn=INT_MAX;\\n        lmx=rmx=INT_MIN;\\n\\t\\t\\n        int l=rec(root->left,lmx,lmn,a);\\n        int r=rec(root->right,rmx,rmn,a);\\n        \\n        int val=l+r+root->val;\\n    \\n\\t// if the left maximum is less than and right minimum is greater than current node\\n\\t// than the subtree rooted at current node is BST.\\n\\t\\t\\n        if((lmx<(root->val)) and (rmn>(root->val)))\\n        {\\n            a=max(a,val);\\n            mx=max(root->val,rmx);\\n            mn=min(root->val,lmn);\\n        }\\n        else\\n        {\\n            mx=INT_MAX;\\n            mn=INT_MIN;\\n        }\\n        return val;        \\n    }\\n    public:\\n    \\n    int maxSumBST(TreeNode* root) {\\n        int a=0;\\n        int mx=INT_MIN,mn=INT_MAX;\\n        rec(root,mx,mn,a);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nint rec(TreeNode *root,int &mx,int &mn,int &a)\\n    {\\n        if(!root) return 0;\\n        \\n\\t// lmn,lmx will find the minimum and maximum node in the left subtree \\n\\t// similarly, rmn,rmx will find minimum and maximum node in the right subtree\\n\\t\\t\\n        int lmn,rmn,rmx,lmx;\\n        \\n        lmn=rmn=INT_MAX;\\n        lmx=rmx=INT_MIN;\\n\\t\\t\\n        int l=rec(root->left,lmx,lmn,a);\\n        int r=rec(root->right,rmx,rmn,a);\\n        \\n        int val=l+r+root->val;\\n    \\n\\t// if the left maximum is less than and right minimum is greater than current node\\n\\t// than the subtree rooted at current node is BST.\\n\\t\\t\\n        if((lmx<(root->val)) and (rmn>(root->val)))\\n        {\\n            a=max(a,val);\\n            mx=max(root->val,rmx);\\n            mn=min(root->val,lmn);\\n        }\\n        else\\n        {\\n            mx=INT_MAX;\\n            mn=INT_MIN;\\n        }\\n        return val;        \\n    }\\n    public:\\n    \\n    int maxSumBST(TreeNode* root) {\\n        int a=0;\\n        int mx=INT_MIN,mn=INT_MAX;\\n        rec(root,mx,mn,a);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3143402,
                "title": "c",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    class info\\n    {\\n        public:\\n        int maxi;\\n        int mini;\\n        bool isBST;\\n        int sum;\\n    };\\n\\n    info solve(TreeNode* root, int &maxsum)\\n    {\\n        if(!root)\\n            return {INT_MIN, INT_MAX, true, 0};\\n        \\n        info left = solve(root->left, maxsum);\\n        info right = solve(root->right, maxsum);\\n\\n        info currNode;\\n\\n        currNode.sum = left.sum+right.sum+root->val;\\n        currNode.maxi = max(root->val, right.maxi);\\n        currNode.mini = min(root->val, left.mini);\\n\\n        if(left.isBST && right.isBST && (root->val > left.maxi && root->val < right.mini))\\n            currNode.isBST = true;\\n        else currNode.isBST = false;\\n        \\n        if(currNode.isBST)\\n            maxsum = max(maxsum, currNode.sum);\\n            \\n        return currNode;\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int maxsum=0;\\n        info temp = solve(root, maxsum);\\n        return maxsum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    class info\\n    {\\n        public:\\n        int maxi;\\n        int mini;\\n        bool isBST;\\n        int sum;\\n    };\\n\\n    info solve(TreeNode* root, int &maxsum)\\n    {\\n        if(!root)\\n            return {INT_MIN, INT_MAX, true, 0};\\n        \\n        info left = solve(root->left, maxsum);\\n        info right = solve(root->right, maxsum);\\n\\n        info currNode;\\n\\n        currNode.sum = left.sum+right.sum+root->val;\\n        currNode.maxi = max(root->val, right.maxi);\\n        currNode.mini = min(root->val, left.mini);\\n\\n        if(left.isBST && right.isBST && (root->val > left.maxi && root->val < right.mini))\\n            currNode.isBST = true;\\n        else currNode.isBST = false;\\n        \\n        if(currNode.isBST)\\n            maxsum = max(maxsum, currNode.sum);\\n            \\n        return currNode;\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int maxsum=0;\\n        info temp = solve(root, maxsum);\\n        return maxsum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2957150,
                "title": "java-readable-recursion",
                "content": "```\\nclass Solution {\\n    class TreeInfo {\\n        boolean isBST;\\n        TreeNode min;\\n        TreeNode max;\\n        int sum;\\n        int globalMax;\\n        \\n        public TreeInfo(boolean isBST, TreeNode min, TreeNode max, int sum, int globalMax) {\\n            this.isBST = isBST;\\n            this.min = min;\\n            this.max = max;\\n            this.sum = sum;\\n            this.globalMax = globalMax;\\n        }\\n    }\\n    \\n    public int maxSumBST(TreeNode root) {\\n        return helper(root).globalMax;\\n    }\\n    \\n    private TreeInfo helper(TreeNode root) {\\n        if (root == null) return new TreeInfo(true, null, null, 0, 0);\\n        if (root.left == null && root.right == null) {\\n            return new TreeInfo(true, root, root, root.val, Math.max(0, root.val));\\n        }\\n        TreeInfo left = helper(root.left);\\n        TreeInfo right = helper(root.right);\\n\\n        if (!left.isBST\\n            || !right.isBST\\n            || root.left != null && root.val <= left.max.val \\n            || root.right != null && root.val >= right.min.val) {\\n            return new TreeInfo(false, null, null, 0, Math.max(left.globalMax, right.globalMax));\\n        } \\n        \\n        int curSum = left.sum + right.sum + root.val;\\n        TreeNode min = root.left == null ? root : left.min;\\n        TreeNode max = root.right == null ? root : right.max;\\n        return new TreeInfo(true, min, max, curSum, Math.max(curSum, Math.max(left.globalMax, right.globalMax)));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class TreeInfo {\\n        boolean isBST;\\n        TreeNode min;\\n        TreeNode max;\\n        int sum;\\n        int globalMax;\\n        \\n        public TreeInfo(boolean isBST, TreeNode min, TreeNode max, int sum, int globalMax) {\\n            this.isBST = isBST;\\n            this.min = min;\\n            this.max = max;\\n            this.sum = sum;\\n            this.globalMax = globalMax;\\n        }\\n    }\\n    \\n    public int maxSumBST(TreeNode root) {\\n        return helper(root).globalMax;\\n    }\\n    \\n    private TreeInfo helper(TreeNode root) {\\n        if (root == null) return new TreeInfo(true, null, null, 0, 0);\\n        if (root.left == null && root.right == null) {\\n            return new TreeInfo(true, root, root, root.val, Math.max(0, root.val));\\n        }\\n        TreeInfo left = helper(root.left);\\n        TreeInfo right = helper(root.right);\\n\\n        if (!left.isBST\\n            || !right.isBST\\n            || root.left != null && root.val <= left.max.val \\n            || root.right != null && root.val >= right.min.val) {\\n            return new TreeInfo(false, null, null, 0, Math.max(left.globalMax, right.globalMax));\\n        } \\n        \\n        int curSum = left.sum + right.sum + root.val;\\n        TreeNode min = root.left == null ? root : left.min;\\n        TreeNode max = root.right == null ? root : right.max;\\n        return new TreeInfo(true, min, max, curSum, Math.max(curSum, Math.max(left.globalMax, right.globalMax)));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820159,
                "title": "inorder-traversal-by-striver-method-85-faster",
                "content": "# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(1)\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n// created class container to store maximum,minimum,and maxsum values\\n class cont{\\n     public:\\n        int maxsum;\\n        int maxval;\\n        int minval;\\n    cont(int ms,int mx,int mi){\\n        maxsum=ms;\\n        maxval=mx;\\n        minval=mi;\\n    }\\n };\\nclass Solution {\\npublic:\\n    int res;    // created this variable to keep track on maxsum till now\\n    cont solve(TreeNode* root){\\n        if(root==NULL){\\n            return cont(0,INT_MIN,INT_MAX);\\n        }\\n\\n        auto left = solve(root->left);\\n        auto right=solve(root->right);\\n\\n        if((root->val > left.maxval) && (root->val < right.minval)){\\n            int s=root->val+left.maxsum+right.maxsum;\\n            res=max(res,s);\\n            return cont(s,max(root->val,right.maxval),min(root->val,left.minval));\\n        }\\n\\n        return cont(max(left.maxsum,right.maxsum),INT_MAX,INT_MIN);\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        res=0;\\n        solve(root).maxsum;\\n        return res; \\n    }\\n};\\n```rec\\n// ONE PIECE IS REAL //\\n\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n// created class container to store maximum,minimum,and maxsum values\\n class cont{\\n     public:\\n        int maxsum;\\n        int maxval;\\n        int minval;\\n    cont(int ms,int mx,int mi){\\n        maxsum=ms;\\n        maxval=mx;\\n        minval=mi;\\n    }\\n };\\nclass Solution {\\npublic:\\n    int res;    // created this variable to keep track on maxsum till now\\n    cont solve(TreeNode* root){\\n        if(root==NULL){\\n            return cont(0,INT_MIN,INT_MAX);\\n        }\\n\\n        auto left = solve(root->left);\\n        auto right=solve(root->right);\\n\\n        if((root->val > left.maxval) && (root->val < right.minval)){\\n            int s=root->val+left.maxsum+right.maxsum;\\n            res=max(res,s);\\n            return cont(s,max(root->val,right.maxval),min(root->val,left.minval));\\n        }\\n\\n        return cont(max(left.maxsum,right.maxsum),INT_MAX,INT_MIN);\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        res=0;\\n        solve(root).maxsum;\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2678525,
                "title": "java-tc-o-n-sc-o-1-post-order-traversal-easy-explaination",
                "content": "**APPROACH**\\nFirst we check if it\\'s a valid BST. IF it is a valid BST , we take the max sum till now ```max = Math.max(max,root.val + left.maxsum + right.maxsum);``` and move in upward direction to look for another valid BST with greater sum .\\n\\n**BST VALIDATION**\\n*Node value must be greater than the largest value of left tree and must be smaller than the smallest value of right tree*\\n\\n**COMPLEXITIES**\\n **  TC :  O(N)\\n   SC : O(1) (except recursive stack)**\\n   \\n   **EXPLAINATION**\\n   We just start doing post order traversal and if it\\'s a valid BST we calculate our maximum till now and compute maxValue on the left , minValue on the right and total sum root.val + leftmaxsum + rightmaxsum\\n   ```\\n   if(left.maxValue < root.val && root.val < right.minValue){\\n             max = Math.max(max,root.val + left.maxsum + right.maxsum);\\n            return new NodeValue(Math.max(root.val,right.maxValue), Math.min(root.val,left.minValue),root.val+left.maxsum + right.maxsum);\\n           \\n        }\\n   ```\\n   We create a class named as NodeValue which consists of 3 things :\\n   ```\\n   class NodeValue{\\n    // maxValue maxValue,minValue for checking Validation of BST and maxsum of that valid BST.\\n    public int maxValue,minValue,maxsum;\\n    NodeValue(int max, int min,int maxsum){\\n        this.maxValue = max;\\n        this.minValue = min;\\n        this.maxsum = maxsum;\\n    }\\n}\\n```\\n**CODE**\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass NodeValue{\\n    // maxValue maxValue,minValue for checking Validation of BST and maxsum of that valid BST.\\n    public int maxValue,minValue,maxsum;\\n    NodeValue(int max, int min,int maxsum){\\n        this.maxValue = max;\\n        this.minValue = min;\\n        this.maxsum = maxsum;\\n    }\\n}\\n\\nclass Solution {\\n    int max = 0;\\n    public NodeValue maxSumBSTHelper(TreeNode root){\\n        //An empty tree or bst of size 0;\\n        if(root == null){\\n            return new NodeValue(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        }\\n        //Get values from left and right subtree\\n        NodeValue left = maxSumBSTHelper(root.left);\\n        NodeValue right = maxSumBSTHelper(root.right);\\n        \\n        //Check if it\\'s a valid bst\\n        if(left.maxValue < root.val && root.val < right.minValue){\\n            //It is a BST , calculate maxsum tillnow.\\n             max = Math.max(max,root.val + left.maxsum + right.maxsum);\\n            return new NodeValue(Math.max(root.val,right.maxValue), Math.min(root.val,left.minValue),root.val+left.maxsum + right.maxsum);\\n           \\n        }\\n        //Otherwise return [INF,-INF] so that parent can\\'t be a bst.\\n        return new NodeValue(Integer.MAX_VALUE,Integer.MIN_VALUE,Math.max(left.maxsum,right.maxsum));\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        maxSumBSTHelper(root);\\n        return max;\\n    }\\n}\\n```\\n***IF YOU LIKE THE SOLUTION MAKE SURE TO UPVOTE IT\\nTHANK YOU.*\\n\\t\\n\\n\\t\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```max = Math.max(max,root.val + left.maxsum + right.maxsum);```\n```\\n   if(left.maxValue < root.val && root.val < right.minValue){\\n             max = Math.max(max,root.val + left.maxsum + right.maxsum);\\n            return new NodeValue(Math.max(root.val,right.maxValue), Math.min(root.val,left.minValue),root.val+left.maxsum + right.maxsum);\\n           \\n        }\\n   ```\n```\\n   class NodeValue{\\n    // maxValue maxValue,minValue for checking Validation of BST and maxsum of that valid BST.\\n    public int maxValue,minValue,maxsum;\\n    NodeValue(int max, int min,int maxsum){\\n        this.maxValue = max;\\n        this.minValue = min;\\n        this.maxsum = maxsum;\\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass NodeValue{\\n    // maxValue maxValue,minValue for checking Validation of BST and maxsum of that valid BST.\\n    public int maxValue,minValue,maxsum;\\n    NodeValue(int max, int min,int maxsum){\\n        this.maxValue = max;\\n        this.minValue = min;\\n        this.maxsum = maxsum;\\n    }\\n}\\n\\nclass Solution {\\n    int max = 0;\\n    public NodeValue maxSumBSTHelper(TreeNode root){\\n        //An empty tree or bst of size 0;\\n        if(root == null){\\n            return new NodeValue(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        }\\n        //Get values from left and right subtree\\n        NodeValue left = maxSumBSTHelper(root.left);\\n        NodeValue right = maxSumBSTHelper(root.right);\\n        \\n        //Check if it\\'s a valid bst\\n        if(left.maxValue < root.val && root.val < right.minValue){\\n            //It is a BST , calculate maxsum tillnow.\\n             max = Math.max(max,root.val + left.maxsum + right.maxsum);\\n            return new NodeValue(Math.max(root.val,right.maxValue), Math.min(root.val,left.minValue),root.val+left.maxsum + right.maxsum);\\n           \\n        }\\n        //Otherwise return [INF,-INF] so that parent can\\'t be a bst.\\n        return new NodeValue(Integer.MAX_VALUE,Integer.MIN_VALUE,Math.max(left.maxsum,right.maxsum));\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        maxSumBSTHelper(root);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658716,
                "title": "c-efficient-easy-understanding-recursion-solution",
                "content": "```\\n\\nstruct tri\\n{\\n    int min,max,sum;\\n    tri(int a,int b,int c)\\n    {\\n        min = a;\\n        max= b;\\n        sum = c;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    tri solve(TreeNode *root, int& res)\\n    {\\n        if(root == NULL)\\n        {\\n            tri t(INT_MAX,INT_MIN,0);\\n            return t;\\n        }\\n        \\n        \\n        tri a = solve(root->left,res);  //recursion for left sub tree\\n\\t\\ttri b = solve(root->right,res); //recursion for right sub tree\\n        \\n        \\n        if( (a.max < root->val) && (b.min >root->val))  // root is in valid range ang forms BST\\n        {\\n            res = max( { res, a.sum+b.sum+root->val});  // update the result\\n            tri t( min({a.min,b.min,root->val}), max({a.max,b.max,root->val}), a.sum+b.sum+root->val);  // return min ,max , sum of sub tree to parent\\n            return t;\\n        }\\n        else\\n        {\\n            tri t(INT_MIN ,INT_MAX , INT_MIN);     //return min ,max , sum of sub tree to parent\\n            return t;\\n        }\\n            \\n    }\\n    int maxSumBST(TreeNode* root) \\n    {\\n        int res=0;\\n        solve(root,res);\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nstruct tri\\n{\\n    int min,max,sum;\\n    tri(int a,int b,int c)\\n    {\\n        min = a;\\n        max= b;\\n        sum = c;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    tri solve(TreeNode *root, int& res)\\n    {\\n        if(root == NULL)\\n        {\\n            tri t(INT_MAX,INT_MIN,0);\\n            return t;\\n        }\\n        \\n        \\n        tri a = solve(root->left,res);  //recursion for left sub tree\\n\\t\\ttri b = solve(root->right,res); //recursion for right sub tree\\n        \\n        \\n        if( (a.max < root->val) && (b.min >root->val))  // root is in valid range ang forms BST\\n        {\\n            res = max( { res, a.sum+b.sum+root->val});  // update the result\\n            tri t( min({a.min,b.min,root->val}), max({a.max,b.max,root->val}), a.sum+b.sum+root->val);  // return min ,max , sum of sub tree to parent\\n            return t;\\n        }\\n        else\\n        {\\n            tri t(INT_MIN ,INT_MAX , INT_MIN);     //return min ,max , sum of sub tree to parent\\n            return t;\\n        }\\n            \\n    }\\n    int maxSumBST(TreeNode* root) \\n    {\\n        int res=0;\\n        solve(root,res);\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592309,
                "title": "c-most-intuitive-and-self-explanatory-solution",
                "content": "Most intuitive solution: Time: O(N), Space: O(1)\\n\\n```\\nclass Data {\\n    public:\\n    int minVal;\\n    int maxVal;\\n    int sum;\\n    bool isBST;\\n};\\n\\nclass Solution {\\npublic:\\n    Data solve(TreeNode *root, int &ans) {\\n        if (!root) {\\n            return {INT_MAX, INT_MIN, 0, true};\\n        }\\n        \\n        Data left = solve(root -> left, ans);\\n        Data right = solve(root -> right, ans);\\n        \\n        Data curr;\\n        curr.minVal = min(left.minVal, root -> val);\\n        curr.maxVal = max(right.maxVal, root -> val);\\n        curr.isBST = (left.isBST and right.isBST) and \\n            (root -> val > left.maxVal and root -> val < right.minVal);\\n        curr.sum = left.sum + right.sum + root -> val;\\n        \\n        if (curr.isBST) {\\n            ans = max(ans, curr.sum);\\n        }\\n        return curr;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        if (!root) return 0;\\n        int ans = 0;\\n        Data temp = solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Data {\\n    public:\\n    int minVal;\\n    int maxVal;\\n    int sum;\\n    bool isBST;\\n};\\n\\nclass Solution {\\npublic:\\n    Data solve(TreeNode *root, int &ans) {\\n        if (!root) {\\n            return {INT_MAX, INT_MIN, 0, true};\\n        }\\n        \\n        Data left = solve(root -> left, ans);\\n        Data right = solve(root -> right, ans);\\n        \\n        Data curr;\\n        curr.minVal = min(left.minVal, root -> val);\\n        curr.maxVal = max(right.maxVal, root -> val);\\n        curr.isBST = (left.isBST and right.isBST) and \\n            (root -> val > left.maxVal and root -> val < right.minVal);\\n        curr.sum = left.sum + right.sum + root -> val;\\n        \\n        if (curr.isBST) {\\n            ans = max(ans, curr.sum);\\n        }\\n        return curr;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        if (!root) return 0;\\n        int ans = 0;\\n        Data temp = solve(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296755,
                "title": "c-recursion-using-minimum-and-maximum-logic",
                "content": "logic is simple, recursive function returns 3 values ie.\\n1.total of BST (including left, right, node) (return 0 if it is not valid BST), \\n2. minimum value in that tree, \\n3. maximum value in that tree.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector<int> rec(TreeNode* root,int &ans){          \\n        if(root==NULL){\\n            return {0,INT_MAX,INT_MIN};             //will satisfy every node \\n        }\\n        vector<int> l=rec(root->left,ans);\\n        vector<int> r=rec(root->right,ans);\\n        \\n        if(l[2]<root->val && r[1]>root->val){        // r[1] has minimum value in right sub tree and l[2] has maximum value in left sub tree \\n            ans=max(ans,root->val+l[0]+r[0]);          //update ans when condition true \\n            return {root->val+l[0]+r[0],\\n                    min(root->val,l[1]),               //update new minimum\\n                    max(root->val,r[2])                //update new maximum \\n                   };\\n        }\\n        else{\\n            return {0,INT_MIN,INT_MAX};         //will not satisfy any node above this tree\\n        }\\n    }\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        rec(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate:\\n    vector<int> rec(TreeNode* root,int &ans){          \\n        if(root==NULL){\\n            return {0,INT_MAX,INT_MIN};             //will satisfy every node \\n        }\\n        vector<int> l=rec(root->left,ans);\\n        vector<int> r=rec(root->right,ans);\\n        \\n        if(l[2]<root->val && r[1]>root->val){        // r[1] has minimum value in right sub tree and l[2] has maximum value in left sub tree \\n            ans=max(ans,root->val+l[0]+r[0]);          //update ans when condition true \\n            return {root->val+l[0]+r[0],\\n                    min(root->val,l[1]),               //update new minimum\\n                    max(root->val,r[2])                //update new maximum \\n                   };\\n        }\\n        else{\\n            return {0,INT_MIN,INT_MAX};         //will not satisfy any node above this tree\\n        }\\n    }\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        rec(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2290433,
                "title": "c-solution-fully-explained-similar-like-largest-bst-in-binary-tree",
                "content": "```\\n\\n// Plz upvote if it help :)\\n\\nclass info{\\n    public:\\n    // Data member\\n    int maxi;\\n    int mini;\\n    bool isBst;\\n    int size;\\n    int key;\\n};\\n\\ninfo solve(TreeNode* root,int &ans){\\n    // base case\\n    if(root == NULL){\\n        // We need to return {maxi,mini,isBst,size,key} \\n        // We treat Null as Bst and size is consider as 0\\n        \\n        return {INT_MIN,INT_MAX,true,0,0};\\n    }\\n    \\n    // Doing postorder traversal\\n    info left = solve(root->left,ans);\\n    info right = solve(root->right,ans);\\n    \\n    info currentNode;\\n    // storing maximum and minimum from left and right and current root\\n    currentNode.maxi = max(right.maxi,root->val);\\n    currentNode.mini = min(left.mini,root->val);\\n    currentNode.size = left.size + right.size + 1;\\n    \\n    currentNode.key = left.key + right.key + root->val;\\n    \\n    // checking if current node is valid BST or not\\n    if(left.isBst && right.isBst && root->val > left.maxi && root->val < right.mini){\\n        currentNode.isBst = true;\\n    }\\n    else{\\n        currentNode.isBst = false;\\n    }\\n    \\n    // updating answer\\n    if(currentNode.isBst){\\n        ans = max(ans,currentNode.key);\\n    }\\n    \\n    return currentNode;\\n}\\n\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        \\n        solve(root,ans);\\n        \\n        return ans;\\n    }\\n};\\n\\n// plz upvote if it help :)\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\n// Plz upvote if it help :)\\n\\nclass info{\\n    public:\\n    // Data member\\n    int maxi;\\n    int mini;\\n    bool isBst;\\n    int size;\\n    int key;\\n};\\n\\ninfo solve(TreeNode* root,int &ans){\\n    // base case\\n    if(root == NULL){\\n        // We need to return {maxi,mini,isBst,size,key} \\n        // We treat Null as Bst and size is consider as 0\\n        \\n        return {INT_MIN,INT_MAX,true,0,0};\\n    }\\n    \\n    // Doing postorder traversal\\n    info left = solve(root->left,ans);\\n    info right = solve(root->right,ans);\\n    \\n    info currentNode;\\n    // storing maximum and minimum from left and right and current root\\n    currentNode.maxi = max(right.maxi,root->val);\\n    currentNode.mini = min(left.mini,root->val);\\n    currentNode.size = left.size + right.size + 1;\\n    \\n    currentNode.key = left.key + right.key + root->val;\\n    \\n    // checking if current node is valid BST or not\\n    if(left.isBst && right.isBst && root->val > left.maxi && root->val < right.mini){\\n        currentNode.isBst = true;\\n    }\\n    else{\\n        currentNode.isBst = false;\\n    }\\n    \\n    // updating answer\\n    if(currentNode.isBst){\\n        ans = max(ans,currentNode.key);\\n    }\\n    \\n    return currentNode;\\n}\\n\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        \\n        solve(root,ans);\\n        \\n        return ans;\\n    }\\n};\\n\\n// plz upvote if it help :)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199669,
                "title": "c-clean-code-with-explanations",
                "content": "**Approach**\\nThrough instance of helper class, we will expect to get the maximum and minimum values in right and left subtrees. Also the sum of nodes in left and rigth subtrees and a variable isBst which will tell that the subtree is BST or not.\\n\\nFor a particualar node, if either of the left or right subtree is not BST, then the subtree through the current node will also not be a BST. If both of the subtrees are BST, then we will check if the subtree through the current node is a BST or not i.e., \\n`root->val > left subtree\\'s max value && root->val < right subtree\\'s min value`\\n\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n    // Helper Class\\n    class Helper {\\n        public: \\n        int maxi, mini, sum, isBST;\\n        Helper() {\\n            maxi = -40000; mini = 40000; sum = 0; isBST = 1;\\n        }\\n    };\\n    // Default object for base case\\n    Helper hh;\\n    // This will store the max sum for a BST\\n    int maxSum = 0;\\n    Helper dfs(TreeNode *root) {\\n        if(!root) {\\n            return hh;\\n        }\\n        Helper l = dfs(root->left);\\n        Helper r = dfs(root->right);\\n        Helper h;\\n        // If either of the subtrees is not BST, subtree through current node cannot be BST\\n\\t    // Also if current node is less than the maximum node of left subtree or greater than\\n\\t    // the minimum node of right subtree, it can\\'t be a bst\\n        if(!l.isBST || !r.isBST || root->val <= l.maxi || root->val >= r.mini) {\\n            h.isBST = 0;\\n            return h;\\n        }\\n        // If a BST is formed through current node\\n        h.sum = l.sum + r.sum + root->val;\\n        maxSum = max(maxSum, h.sum);\\n        h.mini = min(l.mini, root->val);\\n        h.maxi = max(r.maxi, root->val);\\n        return h;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        Helper h = dfs(root);\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper Class\\n    class Helper {\\n        public: \\n        int maxi, mini, sum, isBST;\\n        Helper() {\\n            maxi = -40000; mini = 40000; sum = 0; isBST = 1;\\n        }\\n    };\\n    // Default object for base case\\n    Helper hh;\\n    // This will store the max sum for a BST\\n    int maxSum = 0;\\n    Helper dfs(TreeNode *root) {\\n        if(!root) {\\n            return hh;\\n        }\\n        Helper l = dfs(root->left);\\n        Helper r = dfs(root->right);\\n        Helper h;\\n        // If either of the subtrees is not BST, subtree through current node cannot be BST\\n\\t    // Also if current node is less than the maximum node of left subtree or greater than\\n\\t    // the minimum node of right subtree, it can\\'t be a bst\\n        if(!l.isBST || !r.isBST || root->val <= l.maxi || root->val >= r.mini) {\\n            h.isBST = 0;\\n            return h;\\n        }\\n        // If a BST is formed through current node\\n        h.sum = l.sum + r.sum + root->val;\\n        maxSum = max(maxSum, h.sum);\\n        h.mini = min(l.mini, root->val);\\n        h.maxi = max(r.maxi, root->val);\\n        return h;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        Helper h = dfs(root);\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195648,
                "title": "python-solution-with-explanation",
                "content": "* If upperbound == -inf, it means there is no upper bound. Any number can be bigger than -inf.\\n* Similarly if the lowerbound is inf, there is no lower bound. Any number can be smaller than infinity.\\n\\nThe tree is traversed in **post order,** that is, first verify if the left subtree and the right subtrees are BSTs, then try to include the root.\\n\\nIf the node is empty, there\\'s no upperbound or lowerbound to that empty bst, and the bst sum is 0.\\n\\nFor a node to be in BST form, its left and right subtrees must be BSTs, and **value of the node must be higher than the highest value(upper bound) of left subtree and lower than the lowest value(lower bound) of the right subtree**.\\n\\nUpperBound of the BST thus formed would be max(max in right subtree, node\\'s value) and lower bound would min(min value in left subtree, node\\'s value).\\n\\n\\n**If the node violates BST property, make it\\'s subtree sum have a rippling negating effect by making it -inf so that no branch containing it can be considered for BST subtree sum.**\\n\\nNegative sums are considered 0\\n\\n```\\n\\nclass Solution:\\n  \\n  def maxSumBST(self, root: TreeNode) -> int:\\n    sum_ = 0\\n    def recurse(root):\\n      nonlocal sum_\\n      \\n      if root:\\n        \\n        left,left_lb,left_ub = recurse(root.left)\\n        right,right_lb,right_ub = recurse(root.right) \\n        \\n        if root.val>left_ub and root.val<right_lb:\\n          s = left+right+root.val\\n          sum_ = max(s,sum_)\\n          return s,min(root.val,left_lb),max(root.val,right_ub)\\n        else:\\n          return (float(\\'-inf\\'),float(\\'inf\\'),float(\\'-inf\\'))\\n      \\n      \\n      else:\\n        return (0,float(\\'inf\\'),float(\\'-inf\\'))\\n      \\n    recurse(root)\\n    return sum_\\n        \\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "* If upperbound == -inf, it means there is no upper bound. Any number can be bigger than -inf.\\n* Similarly if the lowerbound is inf, there is no lower bound. Any number can be smaller than infinity.\\n\\nThe tree is traversed in **post order,** that is, first verify if the left subtree and the right subtrees are BSTs, then try to include the root.\\n\\nIf the node is empty, there\\'s no upperbound or lowerbound to that empty bst, and the bst sum is 0.\\n\\nFor a node to be in BST form, its left and right subtrees must be BSTs, and **value of the node must be higher than the highest value(upper bound) of left subtree and lower than the lowest value(lower bound) of the right subtree**.\\n\\nUpperBound of the BST thus formed would be max(max in right subtree, node\\'s value) and lower bound would min(min value in left subtree, node\\'s value).\\n\\n\\n**If the node violates BST property, make it\\'s subtree sum have a rippling negating effect by making it -inf so that no branch containing it can be considered for BST subtree sum.**\\n\\nNegative sums are considered 0\\n\\n```\\n\\nclass Solution:\\n  \\n  def maxSumBST(self, root: TreeNode) -> int:\\n    sum_ = 0\\n    def recurse(root):\\n      nonlocal sum_\\n      \\n      if root:\\n        \\n        left,left_lb,left_ub = recurse(root.left)\\n        right,right_lb,right_ub = recurse(root.right) \\n        \\n        if root.val>left_ub and root.val<right_lb:\\n          s = left+right+root.val\\n          sum_ = max(s,sum_)\\n          return s,min(root.val,left_lb),max(root.val,right_ub)\\n        else:\\n          return (float(\\'-inf\\'),float(\\'inf\\'),float(\\'-inf\\'))\\n      \\n      \\n      else:\\n        return (0,float(\\'inf\\'),float(\\'-inf\\'))\\n      \\n    recurse(root)\\n    return sum_\\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 2004782,
                "title": "c-solution-90-fast-with-o-n-time-complexity",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // return func\\n    struct s{\\n        bool isBST;\\n        int mini,maxi,sum;\\n    };\\n    \\n    // logic func/solution func\\n    s solve(TreeNode* root,int &res){\\n        if(!root){\\n            return {true,INT_MAX,INT_MIN,0};\\n        }\\n        \\n        s left=solve(root->left,res);\\n        s right=solve(root->right,res);\\n        \\n        if(left.isBST && right.isBST && left.maxi<root->val && right.mini>root->val){\\n            int cur=left.sum+right.sum+root->val;\\n            res=max(res,cur);\\n            return {true,min(left.mini,root->val),max(right.maxi,root->val),cur};\\n        }\\n        else return {false,0,0,0};\\n    }\\n    \\n    // main/starting func\\n    int maxSumBST(TreeNode* root) {\\n        int res=0;\\n        solve(root,res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    // return func\\n    struct s{\\n        bool isBST;\\n        int mini,maxi,sum;\\n    };\\n    \\n    // logic func/solution func\\n    s solve(TreeNode* root,int &res){\\n        if(!root){\\n            return {true,INT_MAX,INT_MIN,0};\\n        }\\n        \\n        s left=solve(root->left,res);\\n        s right=solve(root->right,res);\\n        \\n        if(left.isBST && right.isBST && left.maxi<root->val && right.mini>root->val){\\n            int cur=left.sum+right.sum+root->val;\\n            res=max(res,cur);\\n            return {true,min(left.mini,root->val),max(right.maxi,root->val),cur};\\n        }\\n        else return {false,0,0,0};\\n    }\\n    \\n    // main/starting func\\n    int maxSumBST(TreeNode* root) {\\n        int res=0;\\n        solve(root,res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908553,
                "title": "useful-template-to-approach-bst-problem",
                "content": "When the problem has the pattern to find the BST from a binary tree, it means we need to find every possible BST under the root node.\\nThe bigget hint is from the definition of BST\\n\\n1. The left subtree of a node contains only nodes with keys less than the node\\'s key.\\n2. The right subtree of a node contains only nodes with keys greater than the node\\'s key.\\n3. Both the left and right subtrees must also be binary search trees.\\n\\nSo for every node we will need the following information:\\n1. If its left subtree is a BST and its min/max boundry and the sum of nodes under this tree.\\n2. If its right subtree is a BST and its min/max boundry and the sum of nodes under this tree.\\n3. If left subtree max boundry <=  current node value <= right subtree min boundry\\n\\nFor 1 and 2, we can combine BST validality with its boundry. \\nIf a node has a valid min/max boundry, it makes sense to be a valid BST. \\n\\nBase case:\\nWhen the node is null, we want to make it a valid BST so for a leaf node it is natual to check if the boundry is valid. How can we achieve that?\\nThe **key point** is for null node to return **a minimum boundry that is very large and a maximum boundry that is very small**.\\n\\nSo when a leaf node gets the left subtree boundry and compare the node\\'s value with the max boundry, it will always be valid because a null node will return a very samll maximum bondray.\\n\\nSimilarily, when a leaf node compares its value with the min boundry from right subtree, it will be valid because a null node returns a very large minimum boundry.\\n\\n![image](https://assets.leetcode.com/users/images/eded1b5a-ca00-4490-9503-64480cdecdc3_1648953902.8246553.png)\\n\\n\\nSo now we have the BST information, we are ready to get the largest sum of a valid BST. \\nThe idea is simple: just return a extra integer for the sum. We only add up the sum to current node if `left subtree max boundry <=  current node value <= right subtree min boundry`, meaning current node is a valid BST as well.\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    // left, right, sum\\n    tuple<int,int,int> getSumBST(TreeNode* node) {\\n        if(!node)\\n            return {INT_MAX, INT_MIN, 0};\\n        \\n        auto [left_l, left_r, left_sum] = getSumBST(node->left);\\n        auto [right_l, right_r, right_sum] = getSumBST(node->right);\\n        \\n        // initialize with invalid bst node\\n        tuple<int,int,int> ret(INT_MIN, INT_MAX, 0);\\n        \\n        // valid bst under node\\n        if(node->val > left_r && node->val < right_l) {\\n            ret = { min(left_l, node->val), max(right_r, node->val), left_sum+right_sum+node->val };\\n            ans = max(ans, left_sum+right_sum+node->val);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    \\n    int maxSumBST(TreeNode* root) {\\n        getSumBST(root);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    // left, right, sum\\n    tuple<int,int,int> getSumBST(TreeNode* node) {\\n        if(!node)\\n            return {INT_MAX, INT_MIN, 0};\\n        \\n        auto [left_l, left_r, left_sum] = getSumBST(node->left);\\n        auto [right_l, right_r, right_sum] = getSumBST(node->right);\\n        \\n        // initialize with invalid bst node\\n        tuple<int,int,int> ret(INT_MIN, INT_MAX, 0);\\n        \\n        // valid bst under node\\n        if(node->val > left_r && node->val < right_l) {\\n            ret = { min(left_l, node->val), max(right_r, node->val), left_sum+right_sum+node->val };\\n            ans = max(ans, left_sum+right_sum+node->val);\\n        }\\n        \\n        return ret;\\n    }\\n    \\n    \\n    int maxSumBST(TreeNode* root) {\\n        getSumBST(root);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1858241,
                "title": "c-finding-all-the-bsts-along-with-its-sum",
                "content": "```\\n//Approach - Finding a bst and calculating its sum (In Bottom Up Manner or In PostOrder)\\n//At each node i will maintain a minimum value and a maximum value from that node to bottom of tree\\n//At each node i will check\\n//  1 - If its left subtree is a BST\\n//  2 - If its right sub tree is a BST\\n//  3 - If its value is greater than max of its left (b/c if it is greater than max of its left means it is greater than all the nodes of its left subtree)\\n//  4 - If its value is less than min of its right b/c if it is less than minimum of its right subtree means it is less than all the nodes of its right subtree\\n//  5 - if all the above condition satisfies means it is a BST then sum of this BST will be left.sum + right.sum + node.val\\n\\nclass NodeVal{      \\n    public:\\n    int minVal, maxVal,sum;\\n    bool isBST;\\n    \\n    NodeVal(int a, int b, int c, bool e)\\n    {\\n        minVal = a;\\n        maxVal = b;\\n        sum = c;\\n        isBST = e;\\n    }\\n    NodeVal(){}\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    NodeVal findSum(TreeNode* node)\\n    {\\n        if(node == NULL) return NodeVal(INT_MAX, INT_MIN, 0, true);\\n        \\n        auto left = findSum(node->left);\\n        auto right = findSum(node->right);\\n        \\n        NodeVal nv;\\n        \\n        nv.isBST = (left.isBST && right.isBST && node->val < right.minVal && node->val > left.maxVal);\\n        nv.minVal = min(node->val, left.minVal);\\n        nv.maxVal = max(node->val, right.maxVal);\\n        \\n        \\n        if(nv.isBST)\\n        {\\n            nv.sum = left.sum + right.sum + node->val;\\n            ans = max(ans, nv.sum);\\n        }\\n        \\n        return nv;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        auto a = findSum(root);\\n        return ans > 0 ? ans : 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n//Approach - Finding a bst and calculating its sum (In Bottom Up Manner or In PostOrder)\\n//At each node i will maintain a minimum value and a maximum value from that node to bottom of tree\\n//At each node i will check\\n//  1 - If its left subtree is a BST\\n//  2 - If its right sub tree is a BST\\n//  3 - If its value is greater than max of its left (b/c if it is greater than max of its left means it is greater than all the nodes of its left subtree)\\n//  4 - If its value is less than min of its right b/c if it is less than minimum of its right subtree means it is less than all the nodes of its right subtree\\n//  5 - if all the above condition satisfies means it is a BST then sum of this BST will be left.sum + right.sum + node.val\\n\\nclass NodeVal{      \\n    public:\\n    int minVal, maxVal,sum;\\n    bool isBST;\\n    \\n    NodeVal(int a, int b, int c, bool e)\\n    {\\n        minVal = a;\\n        maxVal = b;\\n        sum = c;\\n        isBST = e;\\n    }\\n    NodeVal(){}\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    NodeVal findSum(TreeNode* node)\\n    {\\n        if(node == NULL) return NodeVal(INT_MAX, INT_MIN, 0, true);\\n        \\n        auto left = findSum(node->left);\\n        auto right = findSum(node->right);\\n        \\n        NodeVal nv;\\n        \\n        nv.isBST = (left.isBST && right.isBST && node->val < right.minVal && node->val > left.maxVal);\\n        nv.minVal = min(node->val, left.minVal);\\n        nv.maxVal = max(node->val, right.maxVal);\\n        \\n        \\n        if(nv.isBST)\\n        {\\n            nv.sum = left.sum + right.sum + node->val;\\n            ans = max(ans, nv.sum);\\n        }\\n        \\n        return nv;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        auto a = findSum(root);\\n        return ans > 0 ? ans : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833032,
                "title": "simple-solution-in-java-elegant-and-concise-o-n-time",
                "content": "```\\nclass Solution {\\n    private int ans = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n        \\n        Info info = find(root);\\n        return ans;\\n    }\\n    \\n    private Info find(TreeNode root){\\n        if(root == null){\\n            return new Info();\\n        }\\n        \\n        Info lTree = find(root.left);\\n        Info rTree = find(root.right);\\n        \\n        Info info = new Info();\\n        if(lTree.isBST == true && rTree.isBST == true){\\n            if(lTree.max < root.val && rTree.min > root.val){\\n                info.maxBSTsum = root.val + lTree.maxBSTsum + rTree.maxBSTsum;\\n                info.max = rTree.max == Integer.MIN_VALUE ? root.val : rTree.max;\\n                info.min = lTree.min == Integer.MAX_VALUE ? root.val : lTree.min;\\n            }else{\\n                info.isBST = false;\\n            }\\n        }else{\\n            info.isBST = false;\\n        }\\n        \\n        if(info.isBST){\\n            ans = Math.max(ans, info.maxBSTsum);\\n        }\\n        return info;\\n    }\\n    \\n    private class Info{\\n        public int max;\\n        public int min;\\n        public int maxBSTsum;\\n        public boolean isBST;\\n        \\n        public Info(){\\n            this.max = Integer.MIN_VALUE;\\n            this.min = Integer.MAX_VALUE;\\n            this.isBST = true;\\n            this.maxBSTsum = 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int ans = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n        \\n        Info info = find(root);\\n        return ans;\\n    }\\n    \\n    private Info find(TreeNode root){\\n        if(root == null){\\n            return new Info();\\n        }\\n        \\n        Info lTree = find(root.left);\\n        Info rTree = find(root.right);\\n        \\n        Info info = new Info();\\n        if(lTree.isBST == true && rTree.isBST == true){\\n            if(lTree.max < root.val && rTree.min > root.val){\\n                info.maxBSTsum = root.val + lTree.maxBSTsum + rTree.maxBSTsum;\\n                info.max = rTree.max == Integer.MIN_VALUE ? root.val : rTree.max;\\n                info.min = lTree.min == Integer.MAX_VALUE ? root.val : lTree.min;\\n            }else{\\n                info.isBST = false;\\n            }\\n        }else{\\n            info.isBST = false;\\n        }\\n        \\n        if(info.isBST){\\n            ans = Math.max(ans, info.maxBSTsum);\\n        }\\n        return info;\\n    }\\n    \\n    private class Info{\\n        public int max;\\n        public int min;\\n        public int maxBSTsum;\\n        public boolean isBST;\\n        \\n        public Info(){\\n            this.max = Integer.MIN_VALUE;\\n            this.min = Integer.MAX_VALUE;\\n            this.isBST = true;\\n            this.maxBSTsum = 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718688,
                "title": "o-n-java-solution-for-maximun-sum-bst",
                "content": "```\\n// Stores the maximum ans minimum node in this subStree ans the max sum of the valid\\n// Bst in this subtree\\npublic class Data{\\n    int largest;``\\n    int smallest;\\n    int sum;\\n    public Data(int l, int s, int sz){\\n        this.largest = l;\\n        this.smallest = s;\\n        this.sum = sz;\\n    }\\n}\\n\\n\\n\\n// For a Bst this value of the current node must be greater than the largest value in the left part &&\\n// it should be smaller than the smallest value ofthe right part.\\n// left.largest < curr.value < right.smallest\\n\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n        Data ans = new Data(0, 0, 0);\\n        findSum(root, ans);\\n        return ans.sum < 0 ? 0 : ans.sum;\\n    }\\n    \\n    \\n    public Data findSum(TreeNode node, Data ans){\\n        // If left node then return largest as the smallest & smallest as the the max to satisfy the bst\\n        if(node == null) return new Data(Integer.MIN_VALUE, Integer.MAX_VALUE, 0);\\n        \\n        // Inorder traversal\\n        Data left = findSum(node.left, ans);\\n        Data right = findSum(node.right, ans);\\n        \\n        // Valid BST Check: left.largest < curr.value < right.smallest\\n        if(node.val > left.largest && node.val < right.smallest){\\n            // compare the max sum \\n            ans.sum = Math.max(ans.sum, node.val + left.sum + right.sum);\\n            \\n            // Get (the max,min,sum) for the curr node and return it\\n            int max = Math.max(node.val, right.largest);\\n            int min = Math.min(node.val,left.smallest);\\n            int sum = node.val + left.sum + right.sum;\\n            return new Data(max, min, sum);\\n        }\\n        \\n        // If the curr node is not a valid bst then return the value such that no node above this node\\n        // can be a bst\\n        return new Data(Integer.MAX_VALUE, Integer.MIN_VALUE, Math.max(left.sum, right.sum));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Stores the maximum ans minimum node in this subStree ans the max sum of the valid\\n// Bst in this subtree\\npublic class Data{\\n    int largest;``\\n    int smallest;\\n    int sum;\\n    public Data(int l, int s, int sz){\\n        this.largest = l;\\n        this.smallest = s;\\n        this.sum = sz;\\n    }\\n}\\n\\n\\n\\n// For a Bst this value of the current node must be greater than the largest value in the left part &&\\n// it should be smaller than the smallest value ofthe right part.\\n// left.largest < curr.value < right.smallest\\n\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n        Data ans = new Data(0, 0, 0);\\n        findSum(root, ans);\\n        return ans.sum < 0 ? 0 : ans.sum;\\n    }\\n    \\n    \\n    public Data findSum(TreeNode node, Data ans){\\n        // If left node then return largest as the smallest & smallest as the the max to satisfy the bst\\n        if(node == null) return new Data(Integer.MIN_VALUE, Integer.MAX_VALUE, 0);\\n        \\n        // Inorder traversal\\n        Data left = findSum(node.left, ans);\\n        Data right = findSum(node.right, ans);\\n        \\n        // Valid BST Check: left.largest < curr.value < right.smallest\\n        if(node.val > left.largest && node.val < right.smallest){\\n            // compare the max sum \\n            ans.sum = Math.max(ans.sum, node.val + left.sum + right.sum);\\n            \\n            // Get (the max,min,sum) for the curr node and return it\\n            int max = Math.max(node.val, right.largest);\\n            int min = Math.min(node.val,left.smallest);\\n            int sum = node.val + left.sum + right.sum;\\n            return new Data(max, min, sum);\\n        }\\n        \\n        // If the curr node is not a valid bst then return the value such that no node above this node\\n        // can be a bst\\n        return new Data(Integer.MAX_VALUE, Integer.MIN_VALUE, Math.max(left.sum, right.sum));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532937,
                "title": "java-easy-approach-with-explanation-100-faster-new-approach-no-dp",
                "content": "```\\nclass Solution \\n{\\n    int  maxSum= 0;//Global Sum \\n    class pair\\n    {\\n        boolean isBST;//Wheater the node is BST or not \\n        int max;//BST Upperlimit\\n        int min;//BST Lower Limit \\n        int sum;//Cumulative node sum in BST \\n        pair()\\n        {\\n            this.isBST= true;\\n            this.max= Integer.MIN_VALUE;\\n            this.min= Integer.MAX_VALUE;\\n            this.sum= 0;\\n        }\\n    }\\n   \\n    public  pair isBST( TreeNode root )\\n    {//Post Order Bottom Up Approach \\n        if ( root == null ){//base case when we hit the null node, we consider it as BST \\n            pair p= new pair();\\n            return p;\\n        }\\n        \\n        pair left= isBST( root.left );//Recursing down the left subtree \\n        pair right= isBST(  root.right );//Recursing down the right subtree \\n        \\n        pair p= new pair();//Current node, after having its child information \\n        \\n        if (  left.isBST == false || right.isBST == false ){//if the child is not BST the the node is also not a BST \\n            p.isBST= false;\\n            return p;\\n        }\\n        \\n        //calculating the maximum and minimum value of the node, to serve it to the current node\\'s parent //Sice child is BST Confirmed, we are calculating this way \\n        p.max= Math.max( root.val, right.max );\\n        p.min= Math.min( root.val, left.min  );\\n        \\n        \\n        if ( root.val > left.max && root.val < right.min ){//checking that the current node is a Tree BST ( node BST is a Subset of TreeBST, hence its covered using Tree BST) or not\\n            p.sum= left.sum+ right.sum+ root.val;//calculating the sum, on the basis of sum received from the children//Cumulative BST Sum\\n            maxSum= Math.max( maxSum, p.sum );//if maximum sum found updating \\n            return p;//returning the current node with information to the parent, to decide whether parent is BST or Not and including it will maximize the cumulating BST Sum or Not //current Node is BST  \\n        }\\n        \\n        //Not a Tree BST Case \\n        p.isBST= false;//If the current node is not a BST \\n        return p;//returning the current node ( not a BST ) with all the information to its parent\\n    }\\n    public int maxSumBST( TreeNode root ) {\\n        isBST( root );\\n        return maxSum;//Maximum BST Nodes Sum \\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution \\n{\\n    int  maxSum= 0;//Global Sum \\n    class pair\\n    {\\n        boolean isBST;//Wheater the node is BST or not \\n        int max;//BST Upperlimit\\n        int min;//BST Lower Limit \\n        int sum;//Cumulative node sum in BST \\n        pair()\\n        {\\n            this.isBST= true;\\n            this.max= Integer.MIN_VALUE;\\n            this.min= Integer.MAX_VALUE;\\n            this.sum= 0;\\n        }\\n    }\\n   \\n    public  pair isBST( TreeNode root )\\n    {//Post Order Bottom Up Approach \\n        if ( root == null ){//base case when we hit the null node, we consider it as BST \\n            pair p= new pair();\\n            return p;\\n        }\\n        \\n        pair left= isBST( root.left );//Recursing down the left subtree \\n        pair right= isBST(  root.right );//Recursing down the right subtree \\n        \\n        pair p= new pair();//Current node, after having its child information \\n        \\n        if (  left.isBST == false || right.isBST == false ){//if the child is not BST the the node is also not a BST \\n            p.isBST= false;\\n            return p;\\n        }\\n        \\n        //calculating the maximum and minimum value of the node, to serve it to the current node\\'s parent //Sice child is BST Confirmed, we are calculating this way \\n        p.max= Math.max( root.val, right.max );\\n        p.min= Math.min( root.val, left.min  );\\n        \\n        \\n        if ( root.val > left.max && root.val < right.min ){//checking that the current node is a Tree BST ( node BST is a Subset of TreeBST, hence its covered using Tree BST) or not\\n            p.sum= left.sum+ right.sum+ root.val;//calculating the sum, on the basis of sum received from the children//Cumulative BST Sum\\n            maxSum= Math.max( maxSum, p.sum );//if maximum sum found updating \\n            return p;//returning the current node with information to the parent, to decide whether parent is BST or Not and including it will maximize the cumulating BST Sum or Not //current Node is BST  \\n        }\\n        \\n        //Not a Tree BST Case \\n        p.isBST= false;//If the current node is not a BST \\n        return p;//returning the current node ( not a BST ) with all the information to its parent\\n    }\\n    public int maxSumBST( TreeNode root ) {\\n        isBST( root );\\n        return maxSum;//Maximum BST Nodes Sum \\n    }\\n}//Please do Upvote, it helps a lot \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1499664,
                "title": "c-o-n-basic-understanding-intuition-algorithm-clean-code",
                "content": "## **Basic** **Understanding**\\nThe question tells us that we have a binary tree given. In this binary tree, we can have a subtree as BST, but the whole subtree should follow BST rules. eg\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t7\\n\\t\\t\\t\\t\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\t\\t\\t\\t     6     9\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t11    10\\n```\\nIn the above binary tree, we cannot choose 7 as root node of BST tree, because the subtree of 9 is not a BST. Hence only 6, 11 and 10 can be called BST as they have no sub-tree which is not BST. Hence, any node whose all subtree are BST and the node itself follow BST rule can be called as BST. What we have to do next is to tell which BST has the maximum sum. In this case, its 11.\\n\\n## **Intuition**\\nSince now we have the prerequisite to solve it mentally, we can start thinking it programmatically. If at any node we can have the following information : \\n1. Is the left subtree BST?\\n2. Is the right subtree BST?\\n3. Max and Min value of left and right BST?\\n4. Sum of left and right subtree.\\n\\nWe can tell that if this node is a BST or not.\\nIf any of the left or right subtree is not BST, we can say that this node is not BST. If the \\n```\\nnode->val > max(left-subtree) && node->val < min(right-subtree)\\n```\\nthen, the node is a BST and we can have the total sum for the node and compare with a global maximum variable.\\n\\nNote:\\n1. Why do we need both max and min value for subtree?\\nBecause the node can be either right subtree or left subtree of the parent node, in which case its min or max value will be needed respectively.\\n2. What should be the approach of adding the the node value, \"top to bottom\" or \"bottom to top\"?\\nFrom the above discussion it can be said, it is optimal to take the sum from bottom to top.\\n\\n## **Algorithm**\\n1. We can do a post order traversal, because we need to traverse both left and right subtree for the information needed at a node.\\n2. Each node will return an array of size 4, with the following information : \\n\\t```\\n\\tarr[0]  = sum of the BST at the node\\n\\tarr[1] = bool value to indicate if the subtree formed by the node is BST.\\n\\tarr[2] = min value of the subtree\\n\\tarr[3] = max value of the subtree\\n\\t```\\n3. If the node is BST, take sum of left-subtree + right-subtree + node->val and campare against the global max.\\n4. Return the global max after the post order traversal is finished.\\n\\n## **Code**\\n```\\nclass Solution {\\npublic:\\n    int maxs = 0;\\n    vector<int> traverse(TreeNode* root){\\n        vector<int> t(4,0);\\n        if(!root){\\n            t[1] = 1;\\n            t[2] = INT_MAX;\\n            t[3] = INT_MIN;\\n            return t;\\n        }\\n\\n        vector<int> l = traverse(root->left);\\n\\n        vector<int> r = traverse(root->right);        \\n\\n        if(l[1] && r[1] && (root->val > l[3]) && (root->val < r[2])){\\n            int sum = l[0] + r[0] + root->val;\\n            maxs = max(maxs,sum);\\n            t[0] = sum;\\n            t[1] = 1;\\n            t[2] = !root->left ? root->val : l[2];\\n            t[3] = !root->right ? root->val : r[3];\\n            return t;\\n        }\\n        return t;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        traverse(root);\\n        return maxs;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t7\\n\\t\\t\\t\\t\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\t\\t\\t\\t     6     9\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t /   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t11    10\\n```\n```\\nnode->val > max(left-subtree) && node->val < min(right-subtree)\\n```\n```\\n\\tarr[0]  = sum of the BST at the node\\n\\tarr[1] = bool value to indicate if the subtree formed by the node is BST.\\n\\tarr[2] = min value of the subtree\\n\\tarr[3] = max value of the subtree\\n\\t```\n```\\nclass Solution {\\npublic:\\n    int maxs = 0;\\n    vector<int> traverse(TreeNode* root){\\n        vector<int> t(4,0);\\n        if(!root){\\n            t[1] = 1;\\n            t[2] = INT_MAX;\\n            t[3] = INT_MIN;\\n            return t;\\n        }\\n\\n        vector<int> l = traverse(root->left);\\n\\n        vector<int> r = traverse(root->right);        \\n\\n        if(l[1] && r[1] && (root->val > l[3]) && (root->val < r[2])){\\n            int sum = l[0] + r[0] + root->val;\\n            maxs = max(maxs,sum);\\n            t[0] = sum;\\n            t[1] = 1;\\n            t[2] = !root->left ? root->val : l[2];\\n            t[3] = !root->right ? root->val : r[3];\\n            return t;\\n        }\\n        return t;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        traverse(root);\\n        return maxs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304683,
                "title": "java-recursive-time-efficient",
                "content": "```\\nclass Solution {\\n    int max=Integer.MIN_VALUE;\\n    \\n    public int[] helper(TreeNode root){\\n        //return pattern is { max_sum , 0 if not bst and 1 if bst , maximum on left of subtree , minimum on right of subtree}\\n        if(root==null) return new int[]{0,1,-99999,99999};\\n        \\n        //solve for left and right\\n        int[] l=helper(root.left);\\n        int[] r=helper(root.right);\\n        \\n        //maxLeft\\n        int maxL=Math.max(root.val,Math.max(l[2],r[2]));\\n        \\n        //minRight\\n        int minR=Math.min(root.val,Math.min(l[3],r[3]));\\n        \\n        // if the subtree is a BST\\n        if(root.val>l[2]&&root.val<r[3]&&l[1]==1&&r[1]==1){\\n            max=Math.max(max,l[0]+r[0]+root.val);\\n            return new int[]{l[0]+r[0]+root.val,1,maxL,minR};\\n        }\\n        \\n        //if subtree is not BST\\n        else return new int[]{0,0,maxL,minR};\\n        \\n    }\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        if(max<0) return 0;\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int max=Integer.MIN_VALUE;\\n    \\n    public int[] helper(TreeNode root){\\n        //return pattern is { max_sum , 0 if not bst and 1 if bst , maximum on left of subtree , minimum on right of subtree}\\n        if(root==null) return new int[]{0,1,-99999,99999};\\n        \\n        //solve for left and right\\n        int[] l=helper(root.left);\\n        int[] r=helper(root.right);\\n        \\n        //maxLeft\\n        int maxL=Math.max(root.val,Math.max(l[2],r[2]));\\n        \\n        //minRight\\n        int minR=Math.min(root.val,Math.min(l[3],r[3]));\\n        \\n        // if the subtree is a BST\\n        if(root.val>l[2]&&root.val<r[3]&&l[1]==1&&r[1]==1){\\n            max=Math.max(max,l[0]+r[0]+root.val);\\n            return new int[]{l[0]+r[0]+root.val,1,maxL,minR};\\n        }\\n        \\n        //if subtree is not BST\\n        else return new int[]{0,0,maxL,minR};\\n        \\n    }\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        if(max<0) return 0;\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1234514,
                "title": "easy-to-grasp-c-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    // define a struct with parameters that keep check of whether BST exists\\n    // watch Tushar roy video on YT for explanation\\n    struct BSTNode {\\n        bool isBST;\\n        int min;\\n        int max;\\n        int sum; \\n    };\\n    BSTNode helper(TreeNode* curr, int &ans){\\n        if(curr){\\n            BSTNode left = helper(curr->left, ans);\\n            BSTNode right = helper(curr->right, ans);\\n            // for a node\\'s isBST to be true, its left and right subT should\\n            // also be BSTs, and node\\'s val > left\\'s max and <right\\'s min\\n            bool isBST = left.isBST && right.isBST && curr->val > left.max && curr->val < right.min;\\n            // sum param of this particular node\\n            int sum = left.sum + right.sum + curr->val;\\n            // only if a BST can be formed at this curr will we modify ans\\n            if(isBST) ans = max(ans, sum);\\n            // return status to higher levels\\n            return {isBST, min(curr->val, left.min), max(curr->val, right.max), sum };               \\n        } else return {true, INT_MAX, INT_MIN, 0};\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        helper(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // define a struct with parameters that keep check of whether BST exists\\n    // watch Tushar roy video on YT for explanation\\n    struct BSTNode {\\n        bool isBST;\\n        int min;\\n        int max;\\n        int sum; \\n    };\\n    BSTNode helper(TreeNode* curr, int &ans){\\n        if(curr){\\n            BSTNode left = helper(curr->left, ans);\\n            BSTNode right = helper(curr->right, ans);\\n            // for a node\\'s isBST to be true, its left and right subT should\\n            // also be BSTs, and node\\'s val > left\\'s max and <right\\'s min\\n            bool isBST = left.isBST && right.isBST && curr->val > left.max && curr->val < right.min;\\n            // sum param of this particular node\\n            int sum = left.sum + right.sum + curr->val;\\n            // only if a BST can be formed at this curr will we modify ans\\n            if(isBST) ans = max(ans, sum);\\n            // return status to higher levels\\n            return {isBST, min(curr->val, left.min), max(curr->val, right.max), sum };               \\n        } else return {true, INT_MAX, INT_MIN, 0};\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        helper(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153185,
                "title": "java-recursive-clean-code-with-explanation-6ms-faster-than-81-97",
                "content": "```\\nclass Solution {\\n    //6ms,81.97%; 52MB,69.60%\\n    int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    //int[]:\\n    // int[0]: 0: is not bst, 1: is bst;\\n    // int[1]: next leftMax, meaningly now max\\n    // int[2]: next rightMin, meaningly now min\\n    // int[4]: int[0] == 1 ? sum : 0;\\n    private int[] helper(TreeNode node) {\\n        if (node == null) {\\n            return new int[]{1, Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\\n        }\\n        int[] left = helper(node.left);\\n        int[] right = helper(node.right);\\n        if (left[0] == 1 && right[0] == 1 && left[1] < node.val && node.val < right[2]) {\\n            int sum = left[3]+right[3]+node.val;\\n            maxSum = Math.max(maxSum, sum);\\n\\t\\t\\t// compare to node.val dealing with NULL topwards\\n            return new int[]{1, Math.max(right[1], node.val), Math.min(left[2], node.val), sum}; \\n        }\\n        return new int[]{0, Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //6ms,81.97%; 52MB,69.60%\\n    int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        return maxSum;\\n    }\\n\\n    //int[]:\\n    // int[0]: 0: is not bst, 1: is bst;\\n    // int[1]: next leftMax, meaningly now max\\n    // int[2]: next rightMin, meaningly now min\\n    // int[4]: int[0] == 1 ? sum : 0;\\n    private int[] helper(TreeNode node) {\\n        if (node == null) {\\n            return new int[]{1, Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\\n        }\\n        int[] left = helper(node.left);\\n        int[] right = helper(node.right);\\n        if (left[0] == 1 && right[0] == 1 && left[1] < node.val && node.val < right[2]) {\\n            int sum = left[3]+right[3]+node.val;\\n            maxSum = Math.max(maxSum, sum);\\n\\t\\t\\t// compare to node.val dealing with NULL topwards\\n            return new int[]{1, Math.max(right[1], node.val), Math.min(left[2], node.val), sum}; \\n        }\\n        return new int[]{0, Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1101779,
                "title": "c-efficient-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    struct subtreeInfo\\n    {\\n        bool isBST;\\n        int mini;\\n        int maxi;\\n        int sum;\\n        subtreeInfo(bool b,int mini,int maxi,int sum)\\n        {\\n            this->isBST=b;\\n            this->mini=mini;\\n            this->maxi=maxi;\\n            this->sum=sum;\\n        }\\n    };\\n    \\n    subtreeInfo* maxSumBST(TreeNode* root,int &max_sum)\\n    {\\n        if (!root)\\n        {\\n            return new subtreeInfo(true,INT_MAX,INT_MIN,0);\\n        }\\n        subtreeInfo* lt = maxSumBST(root->left,max_sum);\\n        subtreeInfo* rt = maxSumBST(root->right,max_sum);\\n        if (lt->isBST && rt->isBST && root->val>lt->maxi && root->val<rt->mini)\\n        {\\n            max_sum=max(max_sum,lt->sum+rt->sum+root->val);\\n            return new subtreeInfo(true,min(root->val,min(lt->mini,rt->mini)),max(root->val,max(lt->maxi,rt->maxi)),lt->sum+rt->sum+root->val);\\n        }\\n        else\\n        {\\n            return new subtreeInfo(false,0,INT_MAX,INT_MIN);\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        if (!root) return 0;\\n        int max_sum=0;\\n        maxSumBST(root,max_sum);\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct subtreeInfo\\n    {\\n        bool isBST;\\n        int mini;\\n        int maxi;\\n        int sum;\\n        subtreeInfo(bool b,int mini,int maxi,int sum)\\n        {\\n            this->isBST=b;\\n            this->mini=mini;\\n            this->maxi=maxi;\\n            this->sum=sum;\\n        }\\n    };\\n    \\n    subtreeInfo* maxSumBST(TreeNode* root,int &max_sum)\\n    {\\n        if (!root)\\n        {\\n            return new subtreeInfo(true,INT_MAX,INT_MIN,0);\\n        }\\n        subtreeInfo* lt = maxSumBST(root->left,max_sum);\\n        subtreeInfo* rt = maxSumBST(root->right,max_sum);\\n        if (lt->isBST && rt->isBST && root->val>lt->maxi && root->val<rt->mini)\\n        {\\n            max_sum=max(max_sum,lt->sum+rt->sum+root->val);\\n            return new subtreeInfo(true,min(root->val,min(lt->mini,rt->mini)),max(root->val,max(lt->maxi,rt->maxi)),lt->sum+rt->sum+root->val);\\n        }\\n        else\\n        {\\n            return new subtreeInfo(false,0,INT_MAX,INT_MIN);\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        if (!root) return 0;\\n        int max_sum=0;\\n        maxSumBST(root,max_sum);\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055846,
                "title": "short-easy-to-understand-c-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    \\n    pair<int,pair<int,int>> func(TreeNode* node, int & ans){\\n        if(!node) return {0,{INT_MAX,INT_MIN}};\\n        auto l= func(node->left,ans);\\n        auto r= func(node->right,ans);\\n        if(r.second.first<=node->val || l.second.second>= node->val) return {0,{INT_MIN,INT_MAX}};\\n        int num= l.first+ r.first + node->val;\\n        ans=max(ans,num);\\n        return {num,{min(node->val,l.second.first),max(node->val,r.second.second)}};\\n}\\n    \\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        func(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    \\n    pair<int,pair<int,int>> func(TreeNode* node, int & ans){\\n        if(!node) return {0,{INT_MAX,INT_MIN}};\\n        auto l= func(node->left,ans);\\n        auto r= func(node->right,ans);\\n        if(r.second.first<=node->val || l.second.second>= node->val) return {0,{INT_MIN,INT_MAX}};\\n        int num= l.first+ r.first + node->val;\\n        ans=max(ans,num);\\n        return {num,{min(node->val,l.second.first),max(node->val,r.second.second)}};\\n}\\n    \\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        func(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053026,
                "title": "java-code-with-comments-6ms",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        find(root);\\n        return max;\\n    }\\n    \\n    private ValidateBST find(TreeNode node) {\\n        if (node == null) return new ValidateBST(true);\\n        \\n        ValidateBST left = find(node.left);\\n        ValidateBST right = find(node.right);\\n        ValidateBST cur = new ValidateBST();\\n        \\n        int curValue = node.val;\\n        \\n        //getting lower bound -> min(cur, left.lower, right.lower)\\n        cur.lower = Math.min(curValue, Math.min(left.lower, right.lower));\\n        \\n        //getting upper bound -> max(cur, left.upper, right.upper)\\n        cur.upper = Math.max(curValue, Math.max(left.upper, right.upper));\\n        \\n        //isBST -> left.upper < curValue < right.lower\\n        cur.isBST = left.isBST && right.isBST && curValue>left.upper && curValue<right.lower;\\n        \\n        if (cur.isBST) {\\n            cur.sum = curValue + left.sum + right.sum;\\n            max = Math.max(max, cur.sum);\\n        }\\n        \\n        return cur;\\n    }\\n    \\n    private class ValidateBST {\\n        int sum;\\n        boolean isBST;\\n        \\n        //we will be doing post order traversal, \\n        //so the leaf nodes left.upper should be min and right.lower should be max\\n        int lower = Integer.MAX_VALUE;\\n        int upper = Integer.MIN_VALUE;\\n        \\n        public ValidateBST(){\\n        }\\n        \\n        public ValidateBST(boolean isBST) {\\n           this.isBST = isBST;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int max = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        find(root);\\n        return max;\\n    }\\n    \\n    private ValidateBST find(TreeNode node) {\\n        if (node == null) return new ValidateBST(true);\\n        \\n        ValidateBST left = find(node.left);\\n        ValidateBST right = find(node.right);\\n        ValidateBST cur = new ValidateBST();\\n        \\n        int curValue = node.val;\\n        \\n        //getting lower bound -> min(cur, left.lower, right.lower)\\n        cur.lower = Math.min(curValue, Math.min(left.lower, right.lower));\\n        \\n        //getting upper bound -> max(cur, left.upper, right.upper)\\n        cur.upper = Math.max(curValue, Math.max(left.upper, right.upper));\\n        \\n        //isBST -> left.upper < curValue < right.lower\\n        cur.isBST = left.isBST && right.isBST && curValue>left.upper && curValue<right.lower;\\n        \\n        if (cur.isBST) {\\n            cur.sum = curValue + left.sum + right.sum;\\n            max = Math.max(max, cur.sum);\\n        }\\n        \\n        return cur;\\n    }\\n    \\n    private class ValidateBST {\\n        int sum;\\n        boolean isBST;\\n        \\n        //we will be doing post order traversal, \\n        //so the leaf nodes left.upper should be min and right.lower should be max\\n        int lower = Integer.MAX_VALUE;\\n        int upper = Integer.MIN_VALUE;\\n        \\n        public ValidateBST(){\\n        }\\n        \\n        public ValidateBST(boolean isBST) {\\n           this.isBST = isBST;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1029483,
                "title": "c-postorder-short-solution-faster-than-98",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Info {\\n        bool isBST;\\n        int mn;\\n        int mx;\\n        int sum;\\n    };\\n    Info findMaxBST(TreeNode* node, int& res) {\\n        if (node != nullptr) {\\n            Info left = findMaxBST(node -> left, res);\\n            Info right = findMaxBST(node -> right, res);\\n            bool isBST = (left.isBST and right.isBST and left.mx < node -> val and node -> val < right.mn);\\n            int sum = node -> val + left.sum + right.sum;\\n            if (isBST) res = max(res, sum);\\n            return { isBST, min(node -> val, left.mn), max(node -> val, right.mx) , sum};\\n        } else {\\n            return { true, INT_MAX, INT_MIN, 0};\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int res = 0;\\n        findMaxBST(root, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Info {\\n        bool isBST;\\n        int mn;\\n        int mx;\\n        int sum;\\n    };\\n    Info findMaxBST(TreeNode* node, int& res) {\\n        if (node != nullptr) {\\n            Info left = findMaxBST(node -> left, res);\\n            Info right = findMaxBST(node -> right, res);\\n            bool isBST = (left.isBST and right.isBST and left.mx < node -> val and node -> val < right.mn);\\n            int sum = node -> val + left.sum + right.sum;\\n            if (isBST) res = max(res, sum);\\n            return { isBST, min(node -> val, left.mn), max(node -> val, right.mx) , sum};\\n        } else {\\n            return { true, INT_MAX, INT_MIN, 0};\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int res = 0;\\n        findMaxBST(root, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1019178,
                "title": "java-easy-to-understand-code-postorder-traversal-o-n",
                "content": "At every node level, keep capturing detail whether BST or not and update the sum accordingly.\\n\\n**Postorder traversal.**\\n\\nTime complexity - **O(n)** , because at every node we are doing constant operation in setting min, max, isBst and sum fields.\\n```\\nclass Solution {\\n    int ans;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        Val v = helper(root);\\n        return ans;\\n    }\\n    \\n    public Val helper(TreeNode root){\\n        //base case\\n        if(root == null){\\n            Val v = new Val();\\n            v.min = Integer.MAX_VALUE;\\n            v.max = Integer.MIN_VALUE;\\n            v.isBst = true;\\n            return v;\\n        }\\n        \\n        Val left = helper(root.left);\\n        Val right = helper(root.right);\\n        \\n        Val curr = new Val();\\n        curr.isBst = left.isBst && right.isBst && root.val > left.max && root.val < right.min;\\n        \\n        curr.min = Math.min(Math.min(left.min, right.min), root.val);\\n        curr.max = Math.max(Math.max(right.max, left.max), root.val);\\n        \\n        if(curr.isBst){\\n            curr.sum = root.val + left.sum + right.sum;\\n            ans = Math.max(ans, curr.sum);\\n        }\\n        \\n        return curr;\\n    }\\n}\\n\\nclass Val{\\n    boolean isBst;\\n    int min;\\n    int max;\\n    int sum;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        Val v = helper(root);\\n        return ans;\\n    }\\n    \\n    public Val helper(TreeNode root){\\n        //base case\\n        if(root == null){\\n            Val v = new Val();\\n            v.min = Integer.MAX_VALUE;\\n            v.max = Integer.MIN_VALUE;\\n            v.isBst = true;\\n            return v;\\n        }\\n        \\n        Val left = helper(root.left);\\n        Val right = helper(root.right);\\n        \\n        Val curr = new Val();\\n        curr.isBst = left.isBst && right.isBst && root.val > left.max && root.val < right.min;\\n        \\n        curr.min = Math.min(Math.min(left.min, right.min), root.val);\\n        curr.max = Math.max(Math.max(right.max, left.max), root.val);\\n        \\n        if(curr.isBst){\\n            curr.sum = root.val + left.sum + right.sum;\\n            ans = Math.max(ans, curr.sum);\\n        }\\n        \\n        return curr;\\n    }\\n}\\n\\nclass Val{\\n    boolean isBst;\\n    int min;\\n    int max;\\n    int sum;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 982820,
                "title": "c-one-pass-simple-easy-to-understand-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    tuple<bool,int,int,int> _maxSumBST(TreeNode* root,int &ans){\\n        if(NULL == root)\\n            return make_tuple(true,INT_MAX,INT_MIN,0);\\n        \\n        auto left=_maxSumBST(root->left,ans);\\n        auto right=_maxSumBST(root->right,ans);\\n        \\n        //Handling cases when subtree or current tree is not BST, return false.\\n        if(get<0>(left)==false || get<0>(right)==false || get<2>(left)>=root->val \\n           || get<1>(right)<=root->val)\\n            return make_tuple(false,INT_MAX,INT_MIN,ans);\\n        \\n        int min_val=min(root->val,min(get<1>(left),get<1>(right)));\\n \\xA0 \\xA0 \\xA0 \\xA0int max_val=max(root->val,max(get<2>(left),get<2>(right)));\\n        int curr_sum=get<3>(left)+root->val+get<3>(right);\\n        \\n        ans=max(ans,curr_sum);\\n        return make_tuple(true,min_val,max_val,curr_sum);\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        tuple<bool,int,int,int> val; //bool,min,max,sum\\n        _maxSumBST(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    tuple<bool,int,int,int> _maxSumBST(TreeNode* root,int &ans){\\n        if(NULL == root)\\n            return make_tuple(true,INT_MAX,INT_MIN,0);\\n        \\n        auto left=_maxSumBST(root->left,ans);\\n        auto right=_maxSumBST(root->right,ans);\\n        \\n        //Handling cases when subtree or current tree is not BST, return false.\\n        if(get<0>(left)==false || get<0>(right)==false || get<2>(left)>=root->val \\n           || get<1>(right)<=root->val)\\n            return make_tuple(false,INT_MAX,INT_MIN,ans);\\n        \\n        int min_val=min(root->val,min(get<1>(left),get<1>(right)));\\n \\xA0 \\xA0 \\xA0 \\xA0int max_val=max(root->val,max(get<2>(left),get<2>(right)));\\n        int curr_sum=get<3>(left)+root->val+get<3>(right);\\n        \\n        ans=max(ans,curr_sum);\\n        return make_tuple(true,min_val,max_val,curr_sum);\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        tuple<bool,int,int,int> val; //bool,min,max,sum\\n        _maxSumBST(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933794,
                "title": "python-recursion-postorder-traversal-without-global-vars",
                "content": "```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        MIN, MAX = -40001, 40001\\n        def traversal(root: TreeNode):\\n            if root:                    \\n                # l, r - indicators of left and right subtrees are BST trees\\n                # lmin, lmax - minimun and maximum elements seen in the left subtree\\n                # rmin, rmax - minimun and maximum elements seen in the right subtree\\n                # ls, rs - sum of elements in the left/right subtree\\n                # lcs, rcs -  current  maximum sum in the left/right subtree\\n\\n                l, lmin, lmax, ls, lcs = traversal(root.left)\\n                r, rmin, rmax, rs, rcs = traversal(root.right)\\n\\n                # always compare against maximum element seen in the left subtree and minimum in the right subtree \\n                if l and r and lmax < root.val < rmin:\\n                    s = ls + rs + root.val\\n                    return True, min(lmin, root.val), max(rmax, root.val), s, max(s, lcs, rcs)\\n\\n                # does not matter what to return except of indicator of BST tree and current max sum in between subtrees\\n                return False, MAX, MIN, None, max(lcs, rcs)\\n            return True, MAX, MIN, 0, 0\\n        \\n        return traversal(root)[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        MIN, MAX = -40001, 40001\\n        def traversal(root: TreeNode):\\n            if root:                    \\n                # l, r - indicators of left and right subtrees are BST trees\\n                # lmin, lmax - minimun and maximum elements seen in the left subtree\\n                # rmin, rmax - minimun and maximum elements seen in the right subtree\\n                # ls, rs - sum of elements in the left/right subtree\\n                # lcs, rcs -  current  maximum sum in the left/right subtree\\n\\n                l, lmin, lmax, ls, lcs = traversal(root.left)\\n                r, rmin, rmax, rs, rcs = traversal(root.right)\\n\\n                # always compare against maximum element seen in the left subtree and minimum in the right subtree \\n                if l and r and lmax < root.val < rmin:\\n                    s = ls + rs + root.val\\n                    return True, min(lmin, root.val), max(rmax, root.val), s, max(s, lcs, rcs)\\n\\n                # does not matter what to return except of indicator of BST tree and current max sum in between subtrees\\n                return False, MAX, MIN, None, max(lcs, rcs)\\n            return True, MAX, MIN, 0, 0\\n        \\n        return traversal(root)[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813759,
                "title": "python-easy-to-read-postordertraversal-time-99",
                "content": "```\\n\"\"\"\\nRuntime: 368 ms, faster than 99.77% of Python3 online submissions for Maximum Sum BST in Binary Tree.\\nMemory Usage: 67.5 MB, less than 61.65% of Python3 online submissions for Maximum Sum BST in Binary Tree.\\n\\nmax sum of any BST subtree\\n- pretty much the same solution as problem 333 except you would return max sum\\n\\nHigh Level Approach:\\n- traverse tree in postOrder fashion\\n- if leaf node return (True,nodeval,nodeval,nodeval) --> (isBST,currSum,leftMin,leftMax)\\n- if left or right is not BST: return False\\n- if both are BST (one subtree could be Null), then just check if current value still maintains BST property\\n   - if so, add its value and see if sum > globalMaxSum\\n- return globalMaxSum\\n\\nBST Post Order Traversal:\\n- keep a globalSumVariable (will handle rolling sums that have negative values but are still valid BST)\\n- will do a postOrderTraversal recursion:\\n   - if variable is leaf node return (True,val,val,val) --> (isBST,currSum,leftNodeMin,leftNodeMax)\\n   - if node has left, recurse node.left\\n   - if node has right, recurse node.right\\n- if either left or right subtree is NOT BST: return False, max of the values\\n- ELSE:\\n   - if node.left and right and leftMaxVal < currVal < rightMinVal, add sum and check with globalSum\\n   - if node.left and not node.right: check if currVal > leftNodeMax: add sum and check globalSum\\n   - if node right and not left: check if currVal < rightMinVal: add sum and check globalSum\\n   - ELSE: \\n      if currVal is not valid BST return False\\n\\n\"\"\"\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        if not root: return 0\\n        \\n        globalMaxSum = 0\\n        def postOrderTraversal(node):\\n            nonlocal globalMaxSum\\n            \\n            # handle leaf nodes\\n            if not node.left and not node.right:\\n                if node.val > globalMaxSum: globalMaxSum = node.val\\n                return True, node.val,node.val,node.val\\n            \\n        \\n            currSum = node.val\\n            \\n            # recurse into leftNode\\n            isLeftBST,leftMaxSum = True, 0\\n            if node.left:\\n                isLeftBST,leftMaxSum,leftMinVal,leftMaxVal = postOrderTraversal(node.left)\\n            \\n            # recurse into rightNode\\n            isRightBST,rightMaxSum = True, 0\\n            if node.right:\\n                isRightBST,rightMaxSum,rightMinVal,rightMaxVal = postOrderTraversal(node.right)\\n            \\n            # first check if either is not BST, then just return False\\n            if not isLeftBST or not isRightBST:\\n                return False, 0,0,0\\n            \\n            # check if node maintains BST property, if so then add to currSum for subtree maxSum and compare to globalMaxSum\\n            if node.left and node.right and node.val > leftMaxVal and node.val < rightMinVal:\\n                currSum += leftMaxSum + rightMaxSum\\n                if currSum > globalMaxSum: globalMaxSum = currSum\\n                return True,currSum,leftMinVal,rightMaxVal\\n            elif node.left and not node.right and node.val > leftMaxVal:\\n                currSum += leftMaxSum\\n                if currSum > globalMaxSum: globalMaxSum = currSum\\n                return True,currSum,leftMinVal,node.val\\n            elif node.right and not node.left and node.val < rightMinVal:\\n                currSum += rightMaxSum\\n                if currSum > globalMaxSum: globalMaxSum = currSum\\n                return True,currSum,node.val,rightMaxVal\\n            else:   # does not maintain BST property :/\\n                return False, 0,0,0\\n            \\n        postOrderTraversal(root)\\n        return globalMaxSum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\n\"\"\"\\nRuntime: 368 ms, faster than 99.77% of Python3 online submissions for Maximum Sum BST in Binary Tree.\\nMemory Usage: 67.5 MB, less than 61.65% of Python3 online submissions for Maximum Sum BST in Binary Tree.\\n\\nmax sum of any BST subtree\\n- pretty much the same solution as problem 333 except you would return max sum\\n\\nHigh Level Approach:\\n- traverse tree in postOrder fashion\\n- if leaf node return (True,nodeval,nodeval,nodeval) --> (isBST,currSum,leftMin,leftMax)\\n- if left or right is not BST: return False\\n- if both are BST (one subtree could be Null), then just check if current value still maintains BST property\\n   - if so, add its value and see if sum > globalMaxSum\\n- return globalMaxSum\\n\\nBST Post Order Traversal:\\n- keep a globalSumVariable (will handle rolling sums that have negative values but are still valid BST)\\n- will do a postOrderTraversal recursion:\\n   - if variable is leaf node return (True,val,val,val) --> (isBST,currSum,leftNodeMin,leftNodeMax)\\n   - if node has left, recurse node.left\\n   - if node has right, recurse node.right\\n- if either left or right subtree is NOT BST: return False, max of the values\\n- ELSE:\\n   - if node.left and right and leftMaxVal < currVal < rightMinVal, add sum and check with globalSum\\n   - if node.left and not node.right: check if currVal > leftNodeMax: add sum and check globalSum\\n   - if node right and not left: check if currVal < rightMinVal: add sum and check globalSum\\n   - ELSE: \\n      if currVal is not valid BST return False\\n\\n\"\"\"\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        if not root: return 0\\n        \\n        globalMaxSum = 0\\n        def postOrderTraversal(node):\\n            nonlocal globalMaxSum\\n            \\n            # handle leaf nodes\\n            if not node.left and not node.right:\\n                if node.val > globalMaxSum: globalMaxSum = node.val\\n                return True, node.val,node.val,node.val\\n            \\n        \\n            currSum = node.val\\n            \\n            # recurse into leftNode\\n            isLeftBST,leftMaxSum = True, 0\\n            if node.left:\\n                isLeftBST,leftMaxSum,leftMinVal,leftMaxVal = postOrderTraversal(node.left)\\n            \\n            # recurse into rightNode\\n            isRightBST,rightMaxSum = True, 0\\n            if node.right:\\n                isRightBST,rightMaxSum,rightMinVal,rightMaxVal = postOrderTraversal(node.right)\\n            \\n            # first check if either is not BST, then just return False\\n            if not isLeftBST or not isRightBST:\\n                return False, 0,0,0\\n            \\n            # check if node maintains BST property, if so then add to currSum for subtree maxSum and compare to globalMaxSum\\n            if node.left and node.right and node.val > leftMaxVal and node.val < rightMinVal:\\n                currSum += leftMaxSum + rightMaxSum\\n                if currSum > globalMaxSum: globalMaxSum = currSum\\n                return True,currSum,leftMinVal,rightMaxVal\\n            elif node.left and not node.right and node.val > leftMaxVal:\\n                currSum += leftMaxSum\\n                if currSum > globalMaxSum: globalMaxSum = currSum\\n                return True,currSum,leftMinVal,node.val\\n            elif node.right and not node.left and node.val < rightMinVal:\\n                currSum += rightMaxSum\\n                if currSum > globalMaxSum: globalMaxSum = currSum\\n                return True,currSum,node.val,rightMaxVal\\n            else:   # does not maintain BST property :/\\n                return False, 0,0,0\\n            \\n        postOrderTraversal(root)\\n        return globalMaxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 572066,
                "title": "c-solution-o-n-using-tuples",
                "content": "```\\nclass Solution {\\npublic:\\n    tuple<int, int, int>findBst(TreeNode *root, int &ans){\\n        if(root==nullptr)return make_tuple(INT_MAX, INT_MIN, 0);\\n        tuple<int, int, int>l = findBst(root->left, ans);\\n        tuple<int, int, int>r = findBst(root->right, ans);\\n        if(root->val > get<1>(l) && root->val< get<0>(r)){\\n            ans = max(ans, get<2>(l)+get<2>(r)+root->val);\\n            return make_tuple(min(get<0>(l), root->val), max(root->val, get<1>(r)), get<2>(l)+get<2>(r)+root->val);\\n        }\\n        else{\\n            return make_tuple(INT_MIN, INT_MAX, 0);\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        tuple<int, int, int>pp = findBst(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    tuple<int, int, int>findBst(TreeNode *root, int &ans){\\n        if(root==nullptr)return make_tuple(INT_MAX, INT_MIN, 0);\\n        tuple<int, int, int>l = findBst(root->left, ans);\\n        tuple<int, int, int>r = findBst(root->right, ans);\\n        if(root->val > get<1>(l) && root->val< get<0>(r)){\\n            ans = max(ans, get<2>(l)+get<2>(r)+root->val);\\n            return make_tuple(min(get<0>(l), root->val), max(root->val, get<1>(r)), get<2>(l)+get<2>(r)+root->val);\\n        }\\n        else{\\n            return make_tuple(INT_MIN, INT_MAX, 0);\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        tuple<int, int, int>pp = findBst(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 571936,
                "title": "simple-c-code-easy-to-decipher",
                "content": "```\\nint ans=0;\\nclass pairp\\n{\\n    public:\\n    bool  is;\\n    int s;\\n    int mi;\\n    int ma;\\n    \\n};\\npairp  solve(TreeNode *root)\\n{   \\n    pairp  p;\\n    if(root->left==NULL && root->right==NULL)\\n    {\\n       p.is=true;\\n       p.s=root->val;\\n        ans=max(ans,root->val);\\n       p.mi=root->val; \\n       p.ma=root->val; \\n       return p; \\n    }\\n    \\n    pairp  x;\\n    pairp  y;\\n   \\n    if(root->left!=NULL &&  root->right!=NULL   )\\n    {\\n       x=solve(root->left);\\n       y=solve(root->right); \\n       if(x.is==false ||  y.is==false ||  root->val <=x.ma  ||  root->val >= y.mi)\\n       {\\n           p.is=false;\\n           p.s=0;\\n           p.mi=0;\\n           p.ma=0;\\n           return  p;\\n       }\\n       p.s=x.s+y.s+root->val;\\n        ans=max(ans,p.s);\\n       p.is=true;\\n        p.mi=x.mi;\\n        p.ma=y.ma;\\n        return  p;\\n    }\\n    if(root->left==NULL && root->right!=NULL)\\n    {\\n        y=solve(root->right);\\n        if(y.is==false || (root->val  >= y.mi))\\n        {\\n            p.is=false;\\n            p.s=0;\\n            p.mi=0;\\n            p.ma=0;\\n            return p;\\n        }\\n        p.is=true;\\n        p.s=y.s+root->val;\\n        ans=max(ans,p.s);\\n        p.mi=root->val;\\n        p.ma=y.ma;\\n        return  p;\\n    }\\n    if(root->left!=NULL && root->right==NULL)\\n    {\\n        x=solve(root->left);\\n        if(x.is==false ||  ( x.ma >= root->val))\\n        {\\n            p.is=false;\\n            p.s=0;\\n            p.mi=0;\\n            p.ma=0;\\n            return  p;\\n        }\\n        p.is=true;\\n        p.s=x.s+root->val;\\n        ans=max(ans,p.s); \\n        p.mi=x.mi;\\n        p.ma=root->val;    \\n        \\n        return  p;\\n    }\\n    cout<<\"xx\";\\n    \\n    return p;\\n}\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        pairp p=solve(root);\\n        if(p.s<0)\\n        {\\n            return  0;\\n        }\\n        return  ans;\\n        \\n    }```",
                "solutionTags": [],
                "code": "```\\nint ans=0;\\nclass pairp\\n{\\n    public:\\n    bool  is;\\n    int s;\\n    int mi;\\n    int ma;\\n    \\n};\\npairp  solve(TreeNode *root)\\n{   \\n    pairp  p;\\n    if(root->left==NULL && root->right==NULL)\\n    {\\n       p.is=true;\\n       p.s=root->val;\\n        ans=max(ans,root->val);\\n       p.mi=root->val; \\n       p.ma=root->val; \\n       return p; \\n    }\\n    \\n    pairp  x;\\n    pairp  y;\\n   \\n    if(root->left!=NULL &&  root->right!=NULL   )\\n    {\\n       x=solve(root->left);\\n       y=solve(root->right); \\n       if(x.is==false ||  y.is==false ||  root->val <=x.ma  ||  root->val >= y.mi)\\n       {\\n           p.is=false;\\n           p.s=0;\\n           p.mi=0;\\n           p.ma=0;\\n           return  p;\\n       }\\n       p.s=x.s+y.s+root->val;\\n        ans=max(ans,p.s);\\n       p.is=true;\\n        p.mi=x.mi;\\n        p.ma=y.ma;\\n        return  p;\\n    }\\n    if(root->left==NULL && root->right!=NULL)\\n    {\\n        y=solve(root->right);\\n        if(y.is==false || (root->val  >= y.mi))\\n        {\\n            p.is=false;\\n            p.s=0;\\n            p.mi=0;\\n            p.ma=0;\\n            return p;\\n        }\\n        p.is=true;\\n        p.s=y.s+root->val;\\n        ans=max(ans,p.s);\\n        p.mi=root->val;\\n        p.ma=y.ma;\\n        return  p;\\n    }\\n    if(root->left!=NULL && root->right==NULL)\\n    {\\n        x=solve(root->left);\\n        if(x.is==false ||  ( x.ma >= root->val))\\n        {\\n            p.is=false;\\n            p.s=0;\\n            p.mi=0;\\n            p.ma=0;\\n            return  p;\\n        }\\n        p.is=true;\\n        p.s=x.s+root->val;\\n        ans=max(ans,p.s); \\n        p.mi=x.mi;\\n        p.ma=root->val;    \\n        \\n        return  p;\\n    }\\n    cout<<\"xx\";\\n    \\n    return p;\\n}\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        pairp p=solve(root);\\n        if(p.s<0)\\n        {\\n            return  0;\\n        }\\n        return  ans;\\n        \\n    }```",
                "codeTag": "C++"
            },
            {
                "id": 569913,
                "title": "java-solution-uses-post-order-traverse",
                "content": "I use post-order traverse. For each node return an array of 3 elements.\\n- 1st element: minimum value in the tree\\n- 2nd element: maximum value in the tree\\n- 3rd element: sum of all elements in the tree\\n\\nSpecial case:\\n- leaf node: return {null, null, 0}\\n- node that is not a binary search tree: return null\\n\\n\\n```\\nclass Solution {\\n    private int res = 0;\\n\\n    public int maxSumBST(TreeNode root) {\\n        postorder(root);\\n        return res;\\n    }\\n\\n    private Integer[] postorder(TreeNode root) {\\n        if (root == null) return new Integer[]{null, null, 0}; // min, max, sum\\n\\n        Integer[] left = postorder(root.left);\\n        Integer[] right = postorder(root.right);\\n\\n        boolean isLeftBST = left != null && (left[1] == null || (left[1] != null && root.val > left[1]));\\n        boolean isRightBST = right != null && (right[0] == null || (right[0] != null && root.val < right[0]));\\n\\n        if (!isLeftBST || !isRightBST) return null; // not BST\\n\\n        int sum = root.val + left[2] + right[2];\\n        res = Math.max(res, sum);\\n\\n        int min = left[0] == null ? root.val : Math.min(root.val, left[0]);\\n        int max = right[1] == null ? root.val : Math.max(root.val, right[1]);\\n\\n        return new Integer[]{min, max, sum};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int res = 0;\\n\\n    public int maxSumBST(TreeNode root) {\\n        postorder(root);\\n        return res;\\n    }\\n\\n    private Integer[] postorder(TreeNode root) {\\n        if (root == null) return new Integer[]{null, null, 0}; // min, max, sum\\n\\n        Integer[] left = postorder(root.left);\\n        Integer[] right = postorder(root.right);\\n\\n        boolean isLeftBST = left != null && (left[1] == null || (left[1] != null && root.val > left[1]));\\n        boolean isRightBST = right != null && (right[0] == null || (right[0] != null && root.val < right[0]));\\n\\n        if (!isLeftBST || !isRightBST) return null; // not BST\\n\\n        int sum = root.val + left[2] + right[2];\\n        res = Math.max(res, sum);\\n\\n        int min = left[0] == null ? root.val : Math.min(root.val, left[0]);\\n        int max = right[1] == null ? root.val : Math.max(root.val, right[1]);\\n\\n        return new Integer[]{min, max, sum};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548438,
                "title": "python-o-n",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        \\n        def isBSTNode(node):\\n            if node.left and node.right:\\n                if not (node.left.val < node.val < node.right.val):\\n                    return False\\n                \\n            if not node.left and node.right:\\n                if not (node.right.val > node.val):\\n                    return False\\n            \\n            if not node.right and node.left:\\n                if not (node.left.val < node.val):\\n                    return False\\n            \\n            return True\\n        \\n        \\n        self.cost = 0\\n        \\n        def process(node):\\n            if not node:\\n                return 0\\n            \\n            lval = process(node.left)\\n            rval = process(node.right)\\n            \\n            if isBSTNode(node):\\n                result = node.val + lval + rval\\n                self.cost = max(self.cost, result)\\n                return result\\n            else:\\n                return float(\\'-inf\\') # We return -inf to ensure that, only BST node\\'s sum gets calculated\\n            \\n            \\n        process(root)\\n        return self.cost\\n",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def maxSumBST(self, root: TreeNode) -> int:\\n        \\n        def isBSTNode(node):\\n            if node.left and node.right:\\n                if not (node.left.val < node.val < node.right.val):\\n                    return False\\n                \\n            if not node.left and node.right:\\n                if not (node.right.val > node.val):\\n                    return False\\n            \\n            if not node.right and node.left:\\n                if not (node.left.val < node.val):\\n                    return False\\n            \\n            return True\\n        \\n        \\n        self.cost = 0\\n        \\n        def process(node):\\n            if not node:\\n                return 0\\n            \\n            lval = process(node.left)\\n            rval = process(node.right)\\n            \\n            if isBSTNode(node):\\n                result = node.val + lval + rval\\n                self.cost = max(self.cost, result)\\n                return result\\n            else:\\n                return float(\\'-inf\\') # We return -inf to ensure that, only BST node\\'s sum gets calculated\\n            \\n            \\n        process(root)\\n        return self.cost\\n",
                "codeTag": "Java"
            },
            {
                "id": 534568,
                "title": "java-using-an-extra-node-to-store-the-information",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    \\n    class Node {\\n        int min;\\n        int max;\\n        int sum;\\n        boolean isBST;\\n    }\\n    \\n    int max = 0;\\n    public int maxSumBST(TreeNode root) {\\n        visit(root);\\n        return max;\\n    }\\n    private Node visit(TreeNode root) {\\n        if (root == null) {\\n            Node node = new Node();\\n            node.min = Integer.MAX_VALUE;\\n            node.max = Integer.MIN_VALUE;\\n            node.isBST = true;\\n            return node;\\n        }\\n        Node left = visit(root.left);\\n        Node right = visit(root.right);\\n        if (!left.isBST || !right.isBST || left.max >= root.val || right.min <= root.val) {\\n            Node node = new Node();\\n            node.min = Math.min(root.val,left.min);\\n            node.max = Math.max(root.val, right.max);\\n            node.isBST = false;\\n          return node;   \\n        }\\n        Node node = new Node();\\n        node.min = Math.min(root.val,left.min);\\n        node.max = Math.max(root.val, right.max);\\n        node.sum = root.val + left.sum + right.sum;\\n        max = Math.max(node.sum,max);\\n        node.isBST = true;\\n        return node;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    \\n    class Node {\\n        int min;\\n        int max;\\n        int sum;\\n        boolean isBST;\\n    }\\n    \\n    int max = 0;\\n    public int maxSumBST(TreeNode root) {\\n        visit(root);\\n        return max;\\n    }\\n    private Node visit(TreeNode root) {\\n        if (root == null) {\\n            Node node = new Node();\\n            node.min = Integer.MAX_VALUE;\\n            node.max = Integer.MIN_VALUE;\\n            node.isBST = true;\\n            return node;\\n        }\\n        Node left = visit(root.left);\\n        Node right = visit(root.right);\\n        if (!left.isBST || !right.isBST || left.max >= root.val || right.min <= root.val) {\\n            Node node = new Node();\\n            node.min = Math.min(root.val,left.min);\\n            node.max = Math.max(root.val, right.max);\\n            node.isBST = false;\\n          return node;   \\n        }\\n        Node node = new Node();\\n        node.min = Math.min(root.val,left.min);\\n        node.max = Math.max(root.val, right.max);\\n        node.sum = root.val + left.sum + right.sum;\\n        max = Math.max(node.sum,max);\\n        node.isBST = true;\\n        return node;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532021,
                "title": "java-post-order",
                "content": "* the returned array contains 5 elements:\\n\\t* int[0] - a boolean value, 1 means the current tree is a BST, 0 means it\\'s not\\n\\t* int[1] - the sum of the tree\\n\\t* int[2] - BST left boundary\\n\\t* int[3] - BST right boundary\\n\\t* int[4] - track global maximum sum\\n```\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        return postorder(root)[4];\\n    }\\n    \\n    private int[] postorder(TreeNode node) {\\n        if (node == null) {\\n            return new int[]{1, 0, Integer.MAX_VALUE, Integer.MIN_VALUE, 0};\\n        }\\n        int[] ll = postorder(node.left);\\n        int[] rr = postorder(node.right);\\n        int local_max = Math.max(ll[4], rr[4]);\\n        \\n        if (ll[0] == 1 && rr[0] == 1 && node.val > ll[3] && node.val < rr[2]) { // it is a BST\\n            int sum = node.val + ll[1] + rr[1];\\n            return new int[]{1, sum, ll[2] == Integer.MAX_VALUE ? node.val : ll[2], rr[3] == Integer.MIN_VALUE ? node.val : rr[3], Math.max(sum, local_max)};\\n        } else {\\n            return new int[]{0, 0, 0, 0, local_max};\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        return postorder(root)[4];\\n    }\\n    \\n    private int[] postorder(TreeNode node) {\\n        if (node == null) {\\n            return new int[]{1, 0, Integer.MAX_VALUE, Integer.MIN_VALUE, 0};\\n        }\\n        int[] ll = postorder(node.left);\\n        int[] rr = postorder(node.right);\\n        int local_max = Math.max(ll[4], rr[4]);\\n        \\n        if (ll[0] == 1 && rr[0] == 1 && node.val > ll[3] && node.val < rr[2]) { // it is a BST\\n            int sum = node.val + ll[1] + rr[1];\\n            return new int[]{1, sum, ll[2] == Integer.MAX_VALUE ? node.val : ll[2], rr[3] == Integer.MIN_VALUE ? node.val : rr[3], Math.max(sum, local_max)};\\n        } else {\\n            return new int[]{0, 0, 0, 0, local_max};\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531955,
                "title": "c-recursion",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    int maxSum = 0;\\n    public int MaxSumBST(TreeNode root) {\\n        Helper(root);\\n        return maxSum;\\n    }\\n    \\n    private (bool IsBST, int Sum, TreeNode Min, TreeNode Max) Helper(TreeNode node)\\n    {\\n        if(node == null) return (true,0,null,null);\\n        var left = Helper(node.left);\\n        var right = Helper(node.right);\\n        bool isValid = false;\\n        int sum = node.val + left.Sum + right.Sum;\\n        if(left.IsBST && right.IsBST && (left.Max == null || node.val > left.Max.val) && (right.Min == null || node.val < right.Min.val))\\n        {\\n            isValid = true;\\n            maxSum = Math.Max(maxSum, sum);\\n        }\\n        \\n        return (isValid, sum, left.Min??node, right.Max??node);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    int maxSum = 0;\\n    public int MaxSumBST(TreeNode root) {\\n        Helper(root);\\n        return maxSum;\\n    }\\n    \\n    private (bool IsBST, int Sum, TreeNode Min, TreeNode Max) Helper(TreeNode node)\\n    {\\n        if(node == null) return (true,0,null,null);\\n        var left = Helper(node.left);\\n        var right = Helper(node.right);\\n        bool isValid = false;\\n        int sum = node.val + left.Sum + right.Sum;\\n        if(left.IsBST && right.IsBST && (left.Max == null || node.val > left.Max.val) && (right.Min == null || node.val < right.Min.val))\\n        {\\n            isValid = true;\\n            maxSum = Math.Max(maxSum, sum);\\n        }\\n        \\n        return (isValid, sum, left.Min??node, right.Max??node);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531879,
                "title": "simple-c-dfs-returning-multiple-states",
                "content": "```csharp\\npublic class Solution {\\n    int max = 0;\\n    public int MaxSumBST(TreeNode root) {\\n        Evaluate(root);\\n        return max;\\n    }\\n    \\n    public (bool isBST, int min, int max, int sum) Evaluate(TreeNode root){\\n        \\n        if(root is null) return (true, int.MaxValue, int.MinValue, 0);\\n        if(root.left is null && root.right is null){\\n            max = Math.Max(root.val, max);\\n            return (true, root.val, root.val, root.val);\\n        }\\n        var left = Evaluate(root.left);\\n        var right = Evaluate(root.right);\\n        bool isBSTree = left.isBST && right.isBST && left.max<root.val && right.min>root.val;\\n        if(isBSTree){\\n            (bool isBST, int min, int max, int sum) result = (\\n                left.isBST && right.isBST && left.max<root.val && right.min>root.val,\\n                Math.Min(left.min, root.val),\\n                Math.Max(right.max, root.val),\\n                left.sum+right.sum+root.val\\n            );\\n            \\n            max = Math.Max(result.sum, max);\\n            return result;\\n        }\\n        else{\\n            (bool isBST, int min, int max, int sum) result = (false, 0, 0,0);\\n            return result;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution {\\n    int max = 0;\\n    public int MaxSumBST(TreeNode root) {\\n        Evaluate(root);\\n        return max;\\n    }\\n    \\n    public (bool isBST, int min, int max, int sum) Evaluate(TreeNode root){\\n        \\n        if(root is null) return (true, int.MaxValue, int.MinValue, 0);\\n        if(root.left is null && root.right is null){\\n            max = Math.Max(root.val, max);\\n            return (true, root.val, root.val, root.val);\\n        }\\n        var left = Evaluate(root.left);\\n        var right = Evaluate(root.right);\\n        bool isBSTree = left.isBST && right.isBST && left.max<root.val && right.min>root.val;\\n        if(isBSTree){\\n            (bool isBST, int min, int max, int sum) result = (\\n                left.isBST && right.isBST && left.max<root.val && right.min>root.val,\\n                Math.Min(left.min, root.val),\\n                Math.Max(right.max, root.val),\\n                left.sum+right.sum+root.val\\n            );\\n            \\n            max = Math.Max(result.sum, max);\\n            return result;\\n        }\\n        else{\\n            (bool isBST, int min, int max, int sum) result = (false, 0, 0,0);\\n            return result;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 531801,
                "title": "java-recursion",
                "content": "```\\nclass Solution {\\n    class Triplet{\\n        int min;\\n        int max;\\n        int sum;\\n        Triplet(int min, int max, int sum){\\n            this.min = min;\\n            this.max = max;\\n            this.sum = sum;\\n        }\\n    }\\n    int ans ;\\n    public int maxSumBST(TreeNode root) {\\n        ans = 0;\\n        rec(root);\\n        return ans;\\n    }\\n    \\n    Triplet rec(TreeNode root){\\n        if(root == null){\\n            return new Triplet(0, 0, 0);\\n        }\\n        Triplet left = rec(root.left);\\n        Triplet right = rec(root.right);\\n        if(root.left == null && root.right == null){\\n            ans = Math.max(ans, root.val);\\n            return new Triplet(root.val, root.val , root.val);\\n        }\\n        if(root.left == null && root.val < right.min){\\n            ans = Math.max(ans, right.sum + root.val);\\n            return new Triplet(root.val, right.max , right.sum + root.val);\\n        }\\n        if(root.right == null && root.val > left.max){\\n            ans = Math.max(ans, left.sum + root.val);\\n            return new Triplet(left.min, root.val , left.sum + root.val);\\n        }\\n        if(root.val > left.max && root.val < right.min){\\n            ans = Math.max(ans, left.sum + right.sum + root.val);\\n            return new Triplet(left.min, right.max, left.sum + right.sum + root.val);\\n        }\\n        return new Triplet(Integer.MIN_VALUE, Integer.MAX_VALUE, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class Triplet{\\n        int min;\\n        int max;\\n        int sum;\\n        Triplet(int min, int max, int sum){\\n            this.min = min;\\n            this.max = max;\\n            this.sum = sum;\\n        }\\n    }\\n    int ans ;\\n    public int maxSumBST(TreeNode root) {\\n        ans = 0;\\n        rec(root);\\n        return ans;\\n    }\\n    \\n    Triplet rec(TreeNode root){\\n        if(root == null){\\n            return new Triplet(0, 0, 0);\\n        }\\n        Triplet left = rec(root.left);\\n        Triplet right = rec(root.right);\\n        if(root.left == null && root.right == null){\\n            ans = Math.max(ans, root.val);\\n            return new Triplet(root.val, root.val , root.val);\\n        }\\n        if(root.left == null && root.val < right.min){\\n            ans = Math.max(ans, right.sum + root.val);\\n            return new Triplet(root.val, right.max , right.sum + root.val);\\n        }\\n        if(root.right == null && root.val > left.max){\\n            ans = Math.max(ans, left.sum + root.val);\\n            return new Triplet(left.min, root.val , left.sum + root.val);\\n        }\\n        if(root.val > left.max && root.val < right.min){\\n            ans = Math.max(ans, left.sum + right.sum + root.val);\\n            return new Triplet(left.min, right.max, left.sum + right.sum + root.val);\\n        }\\n        return new Triplet(Integer.MIN_VALUE, Integer.MAX_VALUE, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008914,
                "title": "easy-solution-solved-by-using-class-with-o-n-space-complexity-ans-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(N);\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nclass info{\\n public:\\n    int maxi;\\n    int mini;\\n    bool isbst;\\n    int sum;\\n };\\n    info solve(TreeNode* root , int &ans){\\n           if( root ==NULL){\\n                 return {INT_MIN , INT_MAX   , 1 , 0}; }\\n           if( root->left ==NULL && root->right ==NULL){\\n                ans = max(ans , root->val);\\n                 return {root->val , root->val , true , root->val};\\n            }\\n\\n           info leftans = solve(root->left  , ans);\\n           info rightans = solve( root->right , ans);\\n\\n             info currentnode;\\n             currentnode.maxi = max(root->val , rightans.maxi);\\n             currentnode.mini  = min(root->val  , leftans.mini);\\n             currentnode.sum = root->val + rightans.sum + leftans.sum;\\n\\n             if( leftans.isbst && rightans.isbst && ( root->val > leftans.maxi &&              root->val<rightans.mini)){\\n                   currentnode.isbst = true;}\\n             else{\\n                   currentnode.isbst = false;\\n             }\\n             if(currentnode.isbst){\\n                   ans = max(ans, currentnode.sum);\\n             }\\n             return currentnode;\\n    }\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n               int ans = 0;\\n           solve( root , ans );\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nclass info{\\n public:\\n    int maxi;\\n    int mini;\\n    bool isbst;\\n    int sum;\\n };\\n    info solve(TreeNode* root , int &ans){\\n           if( root ==NULL){\\n                 return {INT_MIN , INT_MAX   , 1 , 0}; }\\n           if( root->left ==NULL && root->right ==NULL){\\n                ans = max(ans , root->val);\\n                 return {root->val , root->val , true , root->val};\\n            }\\n\\n           info leftans = solve(root->left  , ans);\\n           info rightans = solve( root->right , ans);\\n\\n             info currentnode;\\n             currentnode.maxi = max(root->val , rightans.maxi);\\n             currentnode.mini  = min(root->val  , leftans.mini);\\n             currentnode.sum = root->val + rightans.sum + leftans.sum;\\n\\n             if( leftans.isbst && rightans.isbst && ( root->val > leftans.maxi &&              root->val<rightans.mini)){\\n                   currentnode.isbst = true;}\\n             else{\\n                   currentnode.isbst = false;\\n             }\\n             if(currentnode.isbst){\\n                   ans = max(ans, currentnode.sum);\\n             }\\n             return currentnode;\\n    }\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n               int ans = 0;\\n           solve( root , ans );\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977843,
                "title": "c-cleanest-solution-using-custom-structure-detailed-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRecursion returns bottom to top\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(H)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    //create struct to store info about left and right subtree\\n    struct subtree{\\n        bool isBST; //check if subtree is a BST\\n        int minn; //minimum value in subtree\\n        int maxx; //maximum value in subtree\\n        int sum; //sum of all values in subtree\\n    };\\n\\n    struct subtree traverse(TreeNode* root, int &ans){\\n        if(!root) return {true, INT_MAX, INT_MIN, 0};\\n        //empty tree is a valid BST with sum 0 hence true\\n        //initialise min and max to +inf and -inf respectively\\n\\n        subtree lst = traverse(root->left, ans); //recurse left\\n        subtree rst = traverse(root->right, ans); //recurse right\\n\\n        //get information about current node\\n        bool flag = true; \\n        int minval = min({root->val, lst.minn, rst.minn});\\n        int maxval = max({root->val, lst.maxx, rst.maxx});\\n        int subtreeSum = root->val + lst.sum + rst.sum;\\n\\n    //for BST root is greater than all elements in left subtree\\n                //and smaller than all elements in right subtree\\n        if(root->val <= lst.maxx || root->val >= rst.minn)\\n            flag = false;\\n        \\n        //if we are at valid subtree then update ans\\n        if(flag && lst.isBST && rst.isBST)\\n            ans = max(ans, subtreeSum);\\n\\n        return {flag, minval, maxval, subtreeSum};\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        traverse(root, ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    //create struct to store info about left and right subtree\\n    struct subtree{\\n        bool isBST; //check if subtree is a BST\\n        int minn; //minimum value in subtree\\n        int maxx; //maximum value in subtree\\n        int sum; //sum of all values in subtree\\n    };\\n\\n    struct subtree traverse(TreeNode* root, int &ans){\\n        if(!root) return {true, INT_MAX, INT_MIN, 0};\\n        //empty tree is a valid BST with sum 0 hence true\\n        //initialise min and max to +inf and -inf respectively\\n\\n        subtree lst = traverse(root->left, ans); //recurse left\\n        subtree rst = traverse(root->right, ans); //recurse right\\n\\n        //get information about current node\\n        bool flag = true; \\n        int minval = min({root->val, lst.minn, rst.minn});\\n        int maxval = max({root->val, lst.maxx, rst.maxx});\\n        int subtreeSum = root->val + lst.sum + rst.sum;\\n\\n    //for BST root is greater than all elements in left subtree\\n                //and smaller than all elements in right subtree\\n        if(root->val <= lst.maxx || root->val >= rst.minn)\\n            flag = false;\\n        \\n        //if we are at valid subtree then update ans\\n        if(flag && lst.isBST && rst.isBST)\\n            ans = max(ans, subtreeSum);\\n\\n        return {flag, minval, maxval, subtreeSum};\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        traverse(root, ans);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818001,
                "title": "c-easy-to-understand-solution-with-explanation",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass f{\\n  public:\\n    int maxi,mini,maxv,s;\\n    f(int maxi,int mini,int s)\\n    {\\n        this->maxi=maxi;// used for storing maximum value\\n        this->mini=mini;//usd for storing minimum value\\n       // this->maxv=maxv;\\n        this->s=s;// used for running valid bst sum\\n    }\\n};\\nint maxi=INT_MIN;// used for calculating maximum sum\\n\\nclass Solution {\\npublic:\\n    f f1(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return f(INT_MIN,INT_MAX,0);// if root is null then we send sum as 0\\n        f l=f1(root->left);\\n        f r=f1(root->right);\\n        if(root->val>l.maxi and root->val<r.mini)// for valid bst we take maximum from left subtree and minimum fom right subtree and check if current node value lies in the range\\n        {\\n             maxi=max({maxi,l.s+r.s+root->val});//if condition is valid then \\n            //only check for maximum sum which is left sum +right sum +current value of root\\n            return f(max(r.maxi,root->val),min(l.mini,root->val),root->val+l.s+r.s);\\n        }\\n        return f(INT_MAX,INT_MIN,0);// if not bst then we send maximum value as maximum as possible and minimum as minimum as possible so it would never be bst \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        maxi=INT_MIN;\\n        f a=f1(root);\\n        return (maxi<0)?0:maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass f{\\n  public:\\n    int maxi,mini,maxv,s;\\n    f(int maxi,int mini,int s)\\n    {\\n        this->maxi=maxi;// used for storing maximum value\\n        this->mini=mini;//usd for storing minimum value\\n       // this->maxv=maxv;\\n        this->s=s;// used for running valid bst sum\\n    }\\n};\\nint maxi=INT_MIN;// used for calculating maximum sum\\n\\nclass Solution {\\npublic:\\n    f f1(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return f(INT_MIN,INT_MAX,0);// if root is null then we send sum as 0\\n        f l=f1(root->left);\\n        f r=f1(root->right);\\n        if(root->val>l.maxi and root->val<r.mini)// for valid bst we take maximum from left subtree and minimum fom right subtree and check if current node value lies in the range\\n        {\\n             maxi=max({maxi,l.s+r.s+root->val});//if condition is valid then \\n            //only check for maximum sum which is left sum +right sum +current value of root\\n            return f(max(r.maxi,root->val),min(l.mini,root->val),root->val+l.s+r.s);\\n        }\\n        return f(INT_MAX,INT_MIN,0);// if not bst then we send maximum value as maximum as possible and minimum as minimum as possible so it would never be bst \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        maxi=INT_MIN;\\n        f a=f1(root);\\n        return (maxi<0)?0:maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672062,
                "title": "very-easy-and-full-explained-c-solution",
                "content": "# Intuition\\nThe code recursively checks each subtree to determine if it is a valid BST and calculates the sum of its values. It keeps track of the maximum sum encountered and returns the overall maximum sum of a BST within the binary tree.\\n\\n# Approach\\n\\nThe provided code is a solution for finding the maximum sum of a binary search tree (BST) in a given binary tree. Here\\'s the intuition behind the code:\\n\\nThe code defines a struct/class called node, which represents information about a subtree in the binary tree. It contains the maximum value (maxi) and minimum value (mini) within the subtree, a boolean flag (isbst) indicating whether the subtree is a valid BST, and the sum of values within the subtree (sum).\\n\\nThe solve function is a recursive function that takes a TreeNode* representing the root of a subtree and a reference to an integer sum variable. It returns a node object representing the information about the subtree.\\n\\nThe base case of the solve function is when the current node is NULL, indicating an empty subtree. In this case, it returns a node object with INT_MIN as the maximum value, INT_MAX as the minimum value, 1 for the isbst flag (an empty subtree is considered a valid BST), and 0 as the sum.\\n\\nFor a non-empty subtree, the solve function recursively calls itself on the left and right subtrees to obtain the node objects representing the information about those subtrees.\\n\\nThe code then checks if the current subtree, rooted at root, is a valid BST. It verifies that both the left and right subtrees are valid BSTs (lf.isbst and rt.isbst are true) and that the value of the root node is greater than the maximum value in the left subtree and less than the minimum value in the right subtree.\\n\\nIf the subtree is a valid BST, the code updates the sum variable by adding the sum of values in the left subtree, right subtree, and the value of the current root node. It also returns a node object with the maximum value as the greater of the maximum values in the right subtree and the current root value, the minimum value as the lesser of the minimum values in the left subtree and the current root value, 1 for the isbst flag (indicating a valid BST), and the sum of values as calculated.\\n\\nIf the subtree is not a valid BST, the code returns a node object with INT_MAX as the maximum value, INT_MIN as the minimum value, 0 for the isbst flag (indicating an invalid BST), and 0 as the sum.\\n\\nFinally, the maxSumBST function initializes the ans variable to 0 and calls the solve function on the root of the entire tree, passing ans as a reference. It then returns the updated value of ans, which represents the maximum sum of a BST within the binary tree.\\n\\n# Complexity\\n- Time complexity:\\nO(N) where N is number of nodes.\\n\\n- Space complexity:\\nO(H) Auxilary space were H is hight of Binary Tree. In worst Case O(N).\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass node{\\n    public:\\n    int maxi;\\n    int mini;\\n    bool isbst;\\n    int sum;\\n};\\n\\nclass Solution {\\npublic:\\n    node solve(TreeNode* root,int &sum)\\n    {\\n        if(root==NULL)\\n        {\\n            return {INT_MIN,INT_MAX,1,0};\\n        }\\n        node lf = solve(root->left,sum);\\n        node rt = solve(root->right,sum);\\n        if(lf.isbst && rt.isbst && (root->val > lf.maxi) && (root->val <rt.mini))\\n        {\\n            sum = max(sum,lf.sum+rt.sum+root->val);\\n            return {max(rt.maxi,root->val),min(lf.mini,root->val),1,lf.sum+rt.sum+root->val};\\n        }\\n            return {INT_MAX,INT_MIN,0,0};\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        node val = solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass node{\\n    public:\\n    int maxi;\\n    int mini;\\n    bool isbst;\\n    int sum;\\n};\\n\\nclass Solution {\\npublic:\\n    node solve(TreeNode* root,int &sum)\\n    {\\n        if(root==NULL)\\n        {\\n            return {INT_MIN,INT_MAX,1,0};\\n        }\\n        node lf = solve(root->left,sum);\\n        node rt = solve(root->right,sum);\\n        if(lf.isbst && rt.isbst && (root->val > lf.maxi) && (root->val <rt.mini))\\n        {\\n            sum = max(sum,lf.sum+rt.sum+root->val);\\n            return {max(rt.maxi,root->val),min(lf.mini,root->val),1,lf.sum+rt.sum+root->val};\\n        }\\n            return {INT_MAX,INT_MIN,0,0};\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        node val = solve(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465913,
                "title": "easy-java-solution-using-recursion-dp-o-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ **(Ignoring recursive stack Space)** \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    class pair{\\n        int min;\\n        int max;\\n        boolean isBST;\\n        int treeSum;\\n\\n        pair(int min, int max, boolean isBST, int treeSum){\\n            this.min = min;\\n            this.max= max;\\n            this.isBST= isBST;\\n            this.treeSum= treeSum;\\n        }\\n    }\\n\\n    int maxSum;\\n    public int maxSumBST(TreeNode root) {\\n        maxSum= 0;\\n        check(root);\\n        return maxSum;\\n    }\\n\\n    public pair check(TreeNode root){\\n        if(root == null){\\n            return new pair(Integer.MAX_VALUE, Integer.MIN_VALUE, true, 0);\\n        }\\n\\n        pair left= check(root.left);\\n        pair right= check(root.right);\\n\\n        int newMin= Math.min(left.min, Math.min(root.val, right.min));\\n        int newMax= Math.max(left.max, Math.max(root.val, right.max));\\n        int newTreeSum= left.treeSum+ right.treeSum+ root.val;\\n\\n        if(left.isBST && right.isBST && left.max < root.val && root.val < right.min){\\n            maxSum= Math.max(maxSum, newTreeSum);\\n            return new pair(newMin, newMax, true, newTreeSum);\\n        }\\n        else{\\n            return new pair(newMin, newMax, false, newTreeSum);\\n        }\\n    }\\n}\\n```\\n![please-upvote.jpg](https://assets.leetcode.com/users/images/d3ffc9eb-9ce8-4e84-91db-43a47f58c337_1682764299.4043663.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    class pair{\\n        int min;\\n        int max;\\n        boolean isBST;\\n        int treeSum;\\n\\n        pair(int min, int max, boolean isBST, int treeSum){\\n            this.min = min;\\n            this.max= max;\\n            this.isBST= isBST;\\n            this.treeSum= treeSum;\\n        }\\n    }\\n\\n    int maxSum;\\n    public int maxSumBST(TreeNode root) {\\n        maxSum= 0;\\n        check(root);\\n        return maxSum;\\n    }\\n\\n    public pair check(TreeNode root){\\n        if(root == null){\\n            return new pair(Integer.MAX_VALUE, Integer.MIN_VALUE, true, 0);\\n        }\\n\\n        pair left= check(root.left);\\n        pair right= check(root.right);\\n\\n        int newMin= Math.min(left.min, Math.min(root.val, right.min));\\n        int newMax= Math.max(left.max, Math.max(root.val, right.max));\\n        int newTreeSum= left.treeSum+ right.treeSum+ root.val;\\n\\n        if(left.isBST && right.isBST && left.max < root.val && root.val < right.min){\\n            maxSum= Math.max(maxSum, newTreeSum);\\n            return new pair(newMin, newMax, true, newTreeSum);\\n        }\\n        else{\\n            return new pair(newMin, newMax, false, newTreeSum);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214829,
                "title": "1373-maximum-sum-bst-in-binary-tree-java",
                "content": "```\\nclass Solution {\\n    int max=0;\\n    public int maxSumBST(TreeNode root) {\\n          max=0;\\n        ans(root);\\n        return max;\\n    }\\n    class Pair {\\n        int sum,max,min;\\n        boolean bst;\\n        Pair (int s)\\n        {\\n            sum=s;\\n        }\\n        Pair(int s,int lmax,int rmin,boolean t)\\n        {\\n            sum=s;\\n            max= lmax;\\n            min=rmin;\\n            bst=t;\\n        }\\n    }\\n    public Pair ans(TreeNode root)\\n    {\\n        if(root==null)\\n            return new Pair (0,Integer.MIN_VALUE,Integer.MAX_VALUE,true);\\n        if(root.left==null&&root.right==null)\\n        {\\n            max=Math.max(root.val,max);\\n            return  new Pair(root.val,root.val,root.val,true);\\n        }\\n        Pair lp=ans(root.left),rp=ans(root.right);\\n        Pair np=new Pair(lp.sum+root.val+rp.sum);\\n        \\n        if(root.val>lp.max&&root.val<rp.min&&lp.bst&&rp.bst)\\n        {\\n            max=Math.max(max,np.sum);\\n            np.bst=true;\\n        }\\n        else\\n            np.bst=false;\\n        np.min=Math.min(root.val,lp.min);\\n        np.max=Math.max(root.val,rp.max);\\n        return np;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max=0;\\n    public int maxSumBST(TreeNode root) {\\n          max=0;\\n        ans(root);\\n        return max;\\n    }\\n    class Pair {\\n        int sum,max,min;\\n        boolean bst;\\n        Pair (int s)\\n        {\\n            sum=s;\\n        }\\n        Pair(int s,int lmax,int rmin,boolean t)\\n        {\\n            sum=s;\\n            max= lmax;\\n            min=rmin;\\n            bst=t;\\n        }\\n    }\\n    public Pair ans(TreeNode root)\\n    {\\n        if(root==null)\\n            return new Pair (0,Integer.MIN_VALUE,Integer.MAX_VALUE,true);\\n        if(root.left==null&&root.right==null)\\n        {\\n            max=Math.max(root.val,max);\\n            return  new Pair(root.val,root.val,root.val,true);\\n        }\\n        Pair lp=ans(root.left),rp=ans(root.right);\\n        Pair np=new Pair(lp.sum+root.val+rp.sum);\\n        \\n        if(root.val>lp.max&&root.val<rp.min&&lp.bst&&rp.bst)\\n        {\\n            max=Math.max(max,np.sum);\\n            np.bst=true;\\n        }\\n        else\\n            np.bst=false;\\n        np.min=Math.min(root.val,lp.min);\\n        np.max=Math.max(root.val,rp.max);\\n        return np;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101222,
                "title": "c-easiest-approach-using-reccursion",
                "content": "\\t   class info{\\n\\t\\tpublic:\\n\\t\\tint mini;\\n\\t\\tint maxi;\\n\\t\\tbool isBST;\\n\\t\\tint sum;\\n\\t};\\n\\tclass Solution {\\n\\tpublic:\\n\\n    info solve(TreeNode* root,int &sum){\\n        //base case\\n        if(root==NULL){\\n            return {INT_MAX,INT_MIN,true,0 };\\n        }\\n        \\n        info leftAns=solve(root->left,sum);\\n        info rightAns=solve(root->right,sum);\\n        \\n        info currNode;\\n        \\n        currNode.mini = min(root->val,leftAns.mini);\\n        currNode.maxi = max(root->val,rightAns.maxi);\\n        currNode.sum  = leftAns.sum + rightAns.sum + root->val;\\n        \\n        if(leftAns.isBST && rightAns.isBST && ( root->val > leftAns.maxi && root->val < rightAns.mini) ){\\n            currNode.isBST=true;\\n        }\\n        else{\\n            currNode.isBST=false;}\\n        \\n        if(currNode.isBST)\\n        sum=max(sum,currNode.sum);\\n        \\n        return currNode; \\n        \\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        int sum=0;\\n        info temp=solve(root,sum);\\n        return sum;\\n    }\\n};\\nPlease UPVOTE if It Helps!!",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n    info solve(TreeNode* root,int &sum){\\n        //base case\\n        if(root==NULL){\\n            return {INT_MAX,INT_MIN,true,0 }",
                "codeTag": "Java"
            },
            {
                "id": 3096897,
                "title": "little-bit-hard-as-level-suggested-postorder-traversal-tc-o-n",
                "content": "Striver\\'s Tree Series Solution\\n\\n# Complexity\\n- Time complexity: O(n) (n=number of nodes)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(1) (except recursion stack)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass nodeValue{\\n    public int maxValue, minValue, maxSum;\\n    public nodeValue(int maxValue, int minValue, int maxSum){\\n        this.maxValue=maxValue;\\n        this.minValue=minValue;\\n        this.maxSum=maxSum;\\n    }\\n}\\nclass Solution {\\n    int max=0;\\n    public nodeValue helper(TreeNode root){\\n        if(root==null)\\n            return new nodeValue(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        nodeValue left=helper(root.left);\\n        nodeValue right=helper(root.right);\\n        if(left.maxValue<root.val && root.val<right.minValue){\\n            max=Math.max(max,root.val+left.maxSum+right.maxSum);\\n            return new nodeValue(Math.max(root.val,right.maxValue),Math.min(root.val,left.minValue),root.val+left.maxSum+right.maxSum);\\n        }\\n        return new nodeValue(Integer.MAX_VALUE,Integer.MIN_VALUE,Math.max(left.maxSum,right.maxSum));\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass nodeValue{\\n    public int maxValue, minValue, maxSum;\\n    public nodeValue(int maxValue, int minValue, int maxSum){\\n        this.maxValue=maxValue;\\n        this.minValue=minValue;\\n        this.maxSum=maxSum;\\n    }\\n}\\nclass Solution {\\n    int max=0;\\n    public nodeValue helper(TreeNode root){\\n        if(root==null)\\n            return new nodeValue(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        nodeValue left=helper(root.left);\\n        nodeValue right=helper(root.right);\\n        if(left.maxValue<root.val && root.val<right.minValue){\\n            max=Math.max(max,root.val+left.maxSum+right.maxSum);\\n            return new nodeValue(Math.max(root.val,right.maxValue),Math.min(root.val,left.minValue),root.val+left.maxSum+right.maxSum);\\n        }\\n        return new nodeValue(Integer.MAX_VALUE,Integer.MIN_VALUE,Math.max(left.maxSum,right.maxSum));\\n    }\\n    public int maxSumBST(TreeNode root) {\\n        helper(root);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889690,
                "title": "c-post-order-traversal-with-intuition-and-approach-clean-and-easy-to-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf I have a node, then to be part of a BST it must be greater than the larget node on it\\'s left and smaller than the smallest value on it\\'s right.\\n\\n> **largest of all nodes(from left) < curr Node < smallest of all nodes(from right)**\\n\\nWe will use bottom up approach. Starting from the leaf node, if it follows the above condition, we will add it to BST.\\n\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\nWe will take a container to store (maxNode from left, minNode from right, and BST sum). In my code I have used class NodeValue(minNode, maxNode, BSTSum) for the same. This we will return each time recursively.\\nThe traversal used is POST order traversal. First we will take sum from left then from right and will add it to current node.\\n> **currSum = currNode + left tree sum + right tree sum**\\nMeanwhile we will store the max sum in a variable, which will we final answer at end of traversal.\\nIn case node is not a BST then we will return INT_MAX from left and INT_MIN from right so that parent cannot be a BST.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass NodeValue {\\npublic:\\n    int minNode, maxNode, BSTSum;\\n    NodeValue() {\\n        this->maxNode = INT_MIN;\\n        this->minNode = INT_MAX;\\n        this->BSTSum = 0;\\n    }\\n    NodeValue(int maxNode, int minNode, int BSTSum) {\\n        this->maxNode = maxNode;\\n        this->minNode = minNode;\\n        this->BSTSum = BSTSum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    NodeValue maxSumBSTHelper(TreeNode* root) {\\n        // An empty tree is a BST of size 0.\\n        if(!root) return NodeValue();\\n\\n        // Get values from left and right subtree of current tree.\\n        auto left = maxSumBSTHelper(root->left);\\n        auto right = maxSumBSTHelper(root->right);\\n\\n        // Current node is greater than max in left AND smaller than min in right, it is a BST.\\n        if(root->val > left.maxNode && root->val < right.minNode) {\\n            // Calculate sum of current node value, left subtree sum and right subtree sum in case of BST.\\n            int currSum = root->val + left.BSTSum + right.BSTSum;\\n            ans = max(ans, currSum);\\n            return NodeValue(max(right.maxNode, root->val), min(left.minNode, root->val), currSum);\\n        }\\n\\n        // Otherwise return [-inf, inf] so that parent can\\'t be valid BST.\\n        return NodeValue(INT_MAX, INT_MIN, max(left.BSTSum, right.BSTSum));\\n\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        maxSumBSTHelper(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass NodeValue {\\npublic:\\n    int minNode, maxNode, BSTSum;\\n    NodeValue() {\\n        this->maxNode = INT_MIN;\\n        this->minNode = INT_MAX;\\n        this->BSTSum = 0;\\n    }\\n    NodeValue(int maxNode, int minNode, int BSTSum) {\\n        this->maxNode = maxNode;\\n        this->minNode = minNode;\\n        this->BSTSum = BSTSum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    NodeValue maxSumBSTHelper(TreeNode* root) {\\n        // An empty tree is a BST of size 0.\\n        if(!root) return NodeValue();\\n\\n        // Get values from left and right subtree of current tree.\\n        auto left = maxSumBSTHelper(root->left);\\n        auto right = maxSumBSTHelper(root->right);\\n\\n        // Current node is greater than max in left AND smaller than min in right, it is a BST.\\n        if(root->val > left.maxNode && root->val < right.minNode) {\\n            // Calculate sum of current node value, left subtree sum and right subtree sum in case of BST.\\n            int currSum = root->val + left.BSTSum + right.BSTSum;\\n            ans = max(ans, currSum);\\n            return NodeValue(max(right.maxNode, root->val), min(left.minNode, root->val), currSum);\\n        }\\n\\n        // Otherwise return [-inf, inf] so that parent can\\'t be valid BST.\\n        return NodeValue(INT_MAX, INT_MIN, max(left.BSTSum, right.BSTSum));\\n\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        maxSumBSTHelper(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842783,
                "title": "cpp-dfs-solution-explained-every-step",
                "content": "**IF YOU FOUND THIS SOLUTION HELPFUL THEN PLEASE LIKE IT**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\t// return type store in vector<int>{check that child is binary search tree (-1 if tree is not bst and 1 if tree is bst),total sum below root,maximum value node till now,minimum value till now};\\n\\t\\tvector<int> func(TreeNode*root,int &ans)\\n\\t\\t{\\n\\t\\t\\t//if we reach leaf node then we return it.\\n\\t\\t\\tif(root->left==NULL and root->right==NULL)\\n\\t\\t\\t{\\n\\t\\t\\t\\tans=max(ans,root->val);\\n\\t\\t\\t\\treturn {1,root->val,root->val,root->val};\\n\\t\\t\\t}\\n\\t\\t\\t// a vector store information of left subtree.\\n\\t\\t\\tvector<int>a{1,0,INT_MIN,INT_MAX};\\n\\t\\t\\t// b node stores information of right subtree.\\n\\t\\t\\tvector<int>b{1,0,INT_MIN,INT_MAX};\\n\\t\\t\\tif(root->left)\\n\\t\\t\\t{\\n\\t\\t\\t\\ta=func(root->left,ans);\\n\\t\\t\\t}\\n\\t\\t\\tif(root->right)\\n\\t\\t\\t{\\n\\t\\t\\t\\tb=func(root->right,ans);\\n\\t\\t\\t}\\n\\t\\t\\tint g=-1,h=-1;\\n\\t\\t\\t// g and h are variables to check left and right child make it bst or not.\\n\\t\\t\\tif(root->left and root->left->val>=root->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\tg=1;\\n\\t\\t\\t}\\n\\t\\t\\tif(root->right and root->right->val<=root->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\th=1;\\n\\t\\t\\t}\\n\\t\\t\\t// check that right and left subtree are bst or not and also comparing maximum value of left subtree and minimum value of right subtree with root value.\\n\\t\\t\\tif(a[0]==1 and b[0]==1 and g==-1 and h==-1 and a[2]<root->val and b[3]>root->val)\\n\\t\\t\\t{\\n\\t\\t\\t\\t// ans variable stores the maximum sum of bst subtree.\\n\\t\\t\\t\\tans=max(ans,root->val+a[1]+b[1]);\\n\\t\\t\\t\\treturn {1,root->val+a[1]+b[1],max(b[2],root->val),min(a[3],root->val)};\\n\\t\\t\\t}\\n\\t\\t\\treturn {-1,-1,-1,-1};\\n\\t\\t}\\n\\t\\tint maxSumBST(TreeNode* root) {\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfunc(root,ans);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\t// return type store in vector<int>{check that child is binary search tree (-1 if tree is not bst and 1 if tree is bst),total sum below root,maximum value node till now,minimum value till now}",
                "codeTag": "Java"
            },
            {
                "id": 2662707,
                "title": "o-n-easy-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1- Try to think bottom-up approach\\n1a- Firsty we need to check for BST.\\n1b- leaf node is always BST \\n1c- If the current substree is not BST we will not get further BST(bottom-up approach). ie\\n\\n  \\n![New-Text-Document.jpg](https://assets.leetcode.com/users/images/74785c1a-1332-4287-943d-a1f808ed9b32_1664948351.0630493.jpeg)\\n\\n2- How to check for BST optimally(ie O(1) ) \\n2a- since in BST root value is greater than its left child value and less than its right child value so we need 2 parameter, store min value so far and store max value so far.\\n\\n3- If the current subtree is BST we will update our ans to max subtree sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint ans=0;\\n \\n    vector<int>solve(TreeNode *root)\\n    {\\n        if(!root) return {INT_MAX,INT_MIN,0};\\n        if(!root->left && !root->right)\\n        {\\n            ans=max(ans,root->val);\\n           return {root->val,root->val,root->val}; \\n        }\\n        vector<int>l=solve(root->left);\\n        vector<int>r=solve(root->right);\\n        if( root->val>l[1] && root->val<r[0]){\\n                ans=max(ans,root->val+l[2]+r[2]);\\n                return {min(root->val,l[0]),max(root->val,r[1]),root->val+l[2]+r[2]};\\n            }\\n        else return {INT_MIN,INT_MAX,0};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        solve(root);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nint ans=0;\\n \\n    vector<int>solve(TreeNode *root)\\n    {\\n        if(!root) return {INT_MAX,INT_MIN,0};\\n        if(!root->left && !root->right)\\n        {\\n            ans=max(ans,root->val);\\n           return {root->val,root->val,root->val}; \\n        }\\n        vector<int>l=solve(root->left);\\n        vector<int>r=solve(root->right);\\n        if( root->val>l[1] && root->val<r[0]){\\n                ans=max(ans,root->val+l[2]+r[2]);\\n                return {min(root->val,l[0]),max(root->val,r[1]),root->val+l[2]+r[2]};\\n            }\\n        else return {INT_MIN,INT_MAX,0};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        solve(root);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592030,
                "title": "c-easy-solution-commented-easy-to-understand",
                "content": "```\\n\\n///\\nCreating a structure for each node :\\n1. Sum of subtree of this node\\n2. Maximum element in the subtree\\n3. Minimum element in the subtree\\n4. if the curr subtree is BST or not -> isBST\\n///\\n\\nstruct tree_node{\\n    int sum;\\n    int max_;\\n    int min_;\\n    bool isBST;\\n};\\n\\nclass Solution {\\npublic:\\n    \\n\\t// Final maximum result \\n    int res = INT_MIN;\\n    \\n    \\n    tree_node solve(TreeNode * root){\\n        \\n// If the root is null then we have to return the structured node with max value -> \\n// INT_MIN , min value -> INT_MAX, isBST -> true , and sum -> 0 \\n\\t\\t\\n        if(root == NULL)\\n            return {0 , INT_MIN , INT_MAX , true};\\n        \\n        tree_node left = solve(root -> left);\\n        tree_node right = solve(root -> right);\\n        \\n\\t\\t// sum of the subtree \\n        int curr_sum = left.sum + right.sum + root->val;\\n\\t\\t\\n\\t\\t// max element is max of left , right and curr node\\n\\t\\tint max_ele = max(root->val , max(left.max_ , right.max_));\\n\\t\\t\\n\\t\\t// min element is min of left , right ans curr node\\n        int min_ele = min(root -> val, min(right.min_ , left.min_));\\n\\t\\t\\n\\t\\t// updating the max res value if the curr subtree is bst \\n        bool flag = false;\\n        if(root->val > left.max_ && root->val < right.min_ && left.isBST && right.isBST){\\n            res = max(curr_sum , res);\\n            flag = true; // if curr subtree is bst \\n        }\\n        \\n        return {curr_sum , max_ele, min_ele, flag}; return the tree node with all details \\n        \\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        solve(root);   \\n\\t\\t// if res is less than 0 then return 0 else return the positive res value\\n        return res < 0?0 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n\\n///\\nCreating a structure for each node :\\n1. Sum of subtree of this node\\n2. Maximum element in the subtree\\n3. Minimum element in the subtree\\n4. if the curr subtree is BST or not -> isBST\\n///\\n\\nstruct tree_node{\\n    int sum;\\n    int max_;\\n    int min_;\\n    bool isBST;\\n};\\n\\nclass Solution {\\npublic:\\n    \\n\\t// Final maximum result \\n    int res = INT_MIN;\\n    \\n    \\n    tree_node solve(TreeNode * root){\\n        \\n// If the root is null then we have to return the structured node with max value -> \\n// INT_MIN , min value -> INT_MAX, isBST -> true , and sum -> 0 \\n\\t\\t\\n        if(root == NULL)\\n            return {0 , INT_MIN , INT_MAX , true};\\n        \\n        tree_node left = solve(root -> left);\\n        tree_node right = solve(root -> right);\\n        \\n\\t\\t// sum of the subtree \\n        int curr_sum = left.sum + right.sum + root->val;\\n\\t\\t\\n\\t\\t// max element is max of left , right and curr node\\n\\t\\tint max_ele = max(root->val , max(left.max_ , right.max_));\\n\\t\\t\\n\\t\\t// min element is min of left , right ans curr node\\n        int min_ele = min(root -> val, min(right.min_ , left.min_));\\n\\t\\t\\n\\t\\t// updating the max res value if the curr subtree is bst \\n        bool flag = false;\\n        if(root->val > left.max_ && root->val < right.min_ && left.isBST && right.isBST){\\n            res = max(curr_sum , res);\\n            flag = true; // if curr subtree is bst \\n        }\\n        \\n        return {curr_sum , max_ele, min_ele, flag}; return the tree node with all details \\n        \\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        solve(root);   \\n\\t\\t// if res is less than 0 then return 0 else return the positive res value\\n        return res < 0?0 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515965,
                "title": "80-tc-and-67-sc-easy-python-solution",
                "content": "```\\ndef maxSumBST(self, root: Optional[TreeNode]) -> int:\\n\\tans = [0]\\n\\tdp = dict()\\n\\tdef summ(node):\\n\\t\\tif(not node):\\n\\t\\t\\treturn 0\\n\\t\\tif(node in dp):\\n\\t\\t\\treturn dp[node]\\n\\t\\tdp[node] = node.val + summ(node.left) + summ(node.right)\\n\\t\\treturn dp[node]\\n\\t\\t\\n\\tdef dfs(node):\\n\\t\\tif(node.left):\\n\\t\\t\\tl_min, l_max, isB_l = dfs(node.left)\\n\\t\\t\\tl = isB_l and l_max < node.val\\n\\t\\telse:\\n\\t\\t\\tl_min = node.val\\n\\t\\t\\tl = 1\\n\\t\\tif(node.right):\\n\\t\\t\\tr_min, r_max, isB_r = dfs(node.right)\\n\\t\\t\\tr = isB_r and r_min > node.val\\n\\t\\telse:\\n\\t\\t\\tr_max = node.val\\n\\t\\t\\tr = 1\\n\\t\\tif(l and r):\\n\\t\\t\\tans[0] = max(ans[0], summ(node))\\n\\t\\t\\treturn l_min, r_max, 1\\n\\t\\treturn -1, -1, 0\\n\\n\\t_, _, f = dfs(root)\\n\\tif(f): ans[0] = max(ans[0], summ(root))\\n\\treturn ans[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\ndef maxSumBST(self, root: Optional[TreeNode]) -> int:\\n\\tans = [0]\\n\\tdp = dict()\\n\\tdef summ(node):\\n\\t\\tif(not node):\\n\\t\\t\\treturn 0\\n\\t\\tif(node in dp):\\n\\t\\t\\treturn dp[node]\\n\\t\\tdp[node] = node.val + summ(node.left) + summ(node.right)\\n\\t\\treturn dp[node]\\n\\t\\t\\n\\tdef dfs(node):\\n\\t\\tif(node.left):\\n\\t\\t\\tl_min, l_max, isB_l = dfs(node.left)\\n\\t\\t\\tl = isB_l and l_max < node.val\\n\\t\\telse:\\n\\t\\t\\tl_min = node.val\\n\\t\\t\\tl = 1\\n\\t\\tif(node.right):\\n\\t\\t\\tr_min, r_max, isB_r = dfs(node.right)\\n\\t\\t\\tr = isB_r and r_min > node.val\\n\\t\\telse:\\n\\t\\t\\tr_max = node.val\\n\\t\\t\\tr = 1\\n\\t\\tif(l and r):\\n\\t\\t\\tans[0] = max(ans[0], summ(node))\\n\\t\\t\\treturn l_min, r_max, 1\\n\\t\\treturn -1, -1, 0\\n\\n\\t_, _, f = dfs(root)\\n\\tif(f): ans[0] = max(ans[0], summ(root))\\n\\treturn ans[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2469084,
                "title": "c-defining-structures-and-recursion",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\tclass Solution {\\n\\tpublic:\\n    struct prop{\\n        bool bst=true;\\n        int mini=INT_MAX;\\n        int maxi=INT_MIN;\\n        int sum=0;\\n    };\\n    int ans=0;\\n    prop solve(TreeNode* root)\\n    {\\n        prop p;\\n        if(root==NULL)\\n            return p;\\n        \\n        prop pl=solve(root->left);\\n        prop pr=solve(root->right);\\n        \\n        if(pl.bst && pr.bst && root->val>pl.maxi && root->val<pr.mini)\\n        {\\n            p.bst=true;\\n            p.sum=pl.sum+pr.sum+root->val;\\n            p.maxi=max(root->val,pr.maxi);\\n            p.mini=min(root->val,pl.mini);\\n        }\\n        else\\n        {\\n            p.bst=false;\\n            p.sum=max(pl.sum,pr.sum);\\n        }\\n        \\n        ans = max(ans,p.sum);\\n        return p;\\n    }\\n    int maxSumBST(TreeNode* root) \\n    {\\n        solve(root);\\n        \\n        return ans;\\n    }\\n\\t};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    struct prop{\\n        bool bst=true;\\n        int mini=INT_MAX;\\n        int maxi=INT_MIN;\\n        int sum=0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2425005,
                "title": "c-code-linear-time-complexity-o-n-easy-approach-with-comments",
                "content": "```\\nclass Solution {\\npublic:int max_s = 0; // initialise a variable outside for finding max_sum; \\n    \\n    struct info{\\n        \\n        bool isbst;\\n        int sum;\\n        int min_d;\\n        int max_d;\\n    };\\n    \\n    info find_max_sum_bst(TreeNode * root){\\n        \\n        if(root==NULL)\\n            return{1,0,INT_MAX,INT_MIN};\\n        \\n        info left = find_max_sum_bst(root->left);\\n        info right = find_max_sum_bst(root->right);\\n        \\n        bool isrootbst ;\\n        if(left.isbst && right.isbst && left.max_d < root->val && right.min_d > root->val) \\n            isrootbst = true;\\n        else\\n            isrootbst = false;\\n        \\n       \\n        int sumtillnow = root->val + left.sum + right.sum;//sum formed till this node;\\n        \\n        if(isrootbst)\\n            max_s = max(max_s,sumtillnow);//find max sum \\n        \\n         info bst;\\n        bst.isbst = isrootbst;\\n        bst.sum = sumtillnow;\\n        bst.min_d = min(root->val , min(left.min_d , right.min_d));// return min value down as it is going up;\\n        bst.max_d = max(root->val ,max(left.max_d, right.max_d));//return max value down as it is going up;\\n        \\n        return bst;\\n        \\n    }\\n    \\n    \\n    int maxSumBST(TreeNode* root) {\\n        \\n        find_max_sum_bst(root);\\n        \\n        return  max_s;\\n    }\\n};\\n\\n**UPVOTE IF YOU LIKE**\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:int max_s = 0; // initialise a variable outside for finding max_sum; \\n    \\n    struct info{\\n        \\n        bool isbst;\\n        int sum;\\n        int min_d;\\n        int max_d;\\n    };\\n    \\n    info find_max_sum_bst(TreeNode * root){\\n        \\n        if(root==NULL)\\n            return{1,0,INT_MAX,INT_MIN};\\n        \\n        info left = find_max_sum_bst(root->left);\\n        info right = find_max_sum_bst(root->right);\\n        \\n        bool isrootbst ;\\n        if(left.isbst && right.isbst && left.max_d < root->val && right.min_d > root->val) \\n            isrootbst = true;\\n        else\\n            isrootbst = false;\\n        \\n       \\n        int sumtillnow = root->val + left.sum + right.sum;//sum formed till this node;\\n        \\n        if(isrootbst)\\n            max_s = max(max_s,sumtillnow);//find max sum \\n        \\n         info bst;\\n        bst.isbst = isrootbst;\\n        bst.sum = sumtillnow;\\n        bst.min_d = min(root->val , min(left.min_d , right.min_d));// return min value down as it is going up;\\n        bst.max_d = max(root->val ,max(left.max_d, right.max_d));//return max value down as it is going up;\\n        \\n        return bst;\\n        \\n    }\\n    \\n    \\n    int maxSumBST(TreeNode* root) {\\n        \\n        find_max_sum_bst(root);\\n        \\n        return  max_s;\\n    }\\n};\\n\\n**UPVOTE IF YOU LIKE**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396036,
                "title": "c-solution-using-oops",
                "content": "```\\n\\nclass NodeValue {\\n    public:\\n        int maxSum, maxVal, minVal;\\n        NodeValue(int maxSum, int maxVal, int minVal){\\n            this->maxSum = maxSum;\\n            this->maxVal = maxVal;\\n            this->minVal = minVal;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    NodeValue solve(TreeNode *root, vector <int> &sums){\\n        if(!root) return {0, INT_MIN, INT_MAX};\\n        \\n        NodeValue valuesLeft = solve(root->left, sums);\\n        NodeValue valuesRight = solve(root->right, sums);\\n        \\n        if(root->val < valuesRight.minVal && root->val > valuesLeft.maxVal){\\n            sums.push_back(root->val + valuesRight.maxSum + valuesLeft.maxSum);\\n            return {root->val + valuesRight.maxSum + valuesLeft.maxSum, max(root->val, valuesRight.maxVal), min(root->val, valuesLeft.minVal)};\\n        }\\n        \\n        sums.push_back(max(valuesRight.maxSum, valuesLeft.maxSum));\\n        return {max(valuesRight.maxSum, valuesLeft.maxSum), INT_MAX, INT_MIN};\\n    }\\n        \\n    int maxSumBST(TreeNode* root) {\\n        vector <int> sums;\\n        sums.push_back(0);\\n\\t\\t\\n        int temp = max(0, solve(root, sums).maxSum);\\n        \\n        int ans = INT_MIN;\\n        for(int i = 0; i < sums.size(); i++){\\n            ans = max(ans, sums[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nReference: https://youtu.be/X0oXMdtUDwo",
                "solutionTags": [],
                "code": "```\\n\\nclass NodeValue {\\n    public:\\n        int maxSum, maxVal, minVal;\\n        NodeValue(int maxSum, int maxVal, int minVal){\\n            this->maxSum = maxSum;\\n            this->maxVal = maxVal;\\n            this->minVal = minVal;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    NodeValue solve(TreeNode *root, vector <int> &sums){\\n        if(!root) return {0, INT_MIN, INT_MAX};\\n        \\n        NodeValue valuesLeft = solve(root->left, sums);\\n        NodeValue valuesRight = solve(root->right, sums);\\n        \\n        if(root->val < valuesRight.minVal && root->val > valuesLeft.maxVal){\\n            sums.push_back(root->val + valuesRight.maxSum + valuesLeft.maxSum);\\n            return {root->val + valuesRight.maxSum + valuesLeft.maxSum, max(root->val, valuesRight.maxVal), min(root->val, valuesLeft.minVal)};\\n        }\\n        \\n        sums.push_back(max(valuesRight.maxSum, valuesLeft.maxSum));\\n        return {max(valuesRight.maxSum, valuesLeft.maxSum), INT_MAX, INT_MIN};\\n    }\\n        \\n    int maxSumBST(TreeNode* root) {\\n        vector <int> sums;\\n        sums.push_back(0);\\n\\t\\t\\n        int temp = max(0, solve(root, sums).maxSum);\\n        \\n        int ans = INT_MIN;\\n        for(int i = 0; i < sums.size(); i++){\\n            ans = max(ans, sums[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2387558,
                "title": "c-solution-post-order-validate-bst-inspired-solution",
                "content": "**Upvote If it helped**\\n```\\nclass Solution {\\npublic:\\n    bool valid(TreeNode* root,  int &smax, int &smin, int &ans, int &sum){\\n        if(!root) return true;\\n        int lans = -40001, rans =-40001, lmax = INT_MIN, lmin = INT_MAX, rmin = INT_MAX, rmax = INT_MIN, lsum = 0, rsum = 0;\\n        bool l = valid(root->left, lmax, lmin, lans, lsum);\\n        bool r = valid(root->right, rmax, rmin, rans, rsum);\\n        smax = max(max(lmax,max(rmax,root->val)), smax);\\n        smin = min(min(lmin,min(rmin,root->val)), smin);\\n        sum += root->val +lsum + rsum;\\n\\t\\t\\n        ans = max(ans, max(lans, rans));\\n        if(l&&r){\\n            if(root->val > lmax && root->val < rmin){\\n                ans = max(ans, lsum + rsum + root->val);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        if(!root) return 0;\\n        int ans = 0;\\n        int sum  = 0;\\n        int mx = INT_MIN, mn = INT_MAX;\\n        valid(root, mx, mn, ans, sum);\\n        return ans;\\n    }\\n};\\n```\\nSimilar Problem : - https://bit.ly/3fn6h5V",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool valid(TreeNode* root,  int &smax, int &smin, int &ans, int &sum){\\n        if(!root) return true;\\n        int lans = -40001, rans =-40001, lmax = INT_MIN, lmin = INT_MAX, rmin = INT_MAX, rmax = INT_MIN, lsum = 0, rsum = 0;\\n        bool l = valid(root->left, lmax, lmin, lans, lsum);\\n        bool r = valid(root->right, rmax, rmin, rans, rsum);\\n        smax = max(max(lmax,max(rmax,root->val)), smax);\\n        smin = min(min(lmin,min(rmin,root->val)), smin);\\n        sum += root->val +lsum + rsum;\\n\\t\\t\\n        ans = max(ans, max(lans, rans));\\n        if(l&&r){\\n            if(root->val > lmax && root->val < rmin){\\n                ans = max(ans, lsum + rsum + root->val);\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        if(!root) return 0;\\n        int ans = 0;\\n        int sum  = 0;\\n        int mx = INT_MIN, mn = INT_MAX;\\n        valid(root, mx, mn, ans, sum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377908,
                "title": "c-simple-recursion-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    //returns {sumOfBST,minElementOfBST,maxElementOfBST,isBST}\\n    vector<int> dfs(TreeNode* root){\\n        if(!root) // if nullptr\\n            return {0,INT_MAX,INT_MIN,true}; \\n        vector<int>left=dfs(root->left); \\n        vector<int>right=dfs(root->right);\\n        \\n        // conditions for the current subtree to be BST\\n        // 1. if left and right are both BST\\n        // 2. the maximum value of left subtree is less than node value\\n        // 3. the minimum value of right subtree is greater than the node value\\n        if(left[3] && right[3] && left[2]<root->val && right[1]>root->val){\\n            int sum=left[0]+right[0]+root->val;\\n            ans=max(sum,ans);\\n            // if left or right subtree is nullptr, then use current node\\'s value\\n            return {sum,left[1]==INT_MAX?root->val:left[1],right[2]==INT_MIN?root->val:right[2],true};\\n        }\\n        return {0,INT_MIN,INT_MAX,false};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans=0;\\n    //returns {sumOfBST,minElementOfBST,maxElementOfBST,isBST}\\n    vector<int> dfs(TreeNode* root){\\n        if(!root) // if nullptr\\n            return {0,INT_MAX,INT_MIN,true}; \\n        vector<int>left=dfs(root->left); \\n        vector<int>right=dfs(root->right);\\n        \\n        // conditions for the current subtree to be BST\\n        // 1. if left and right are both BST\\n        // 2. the maximum value of left subtree is less than node value\\n        // 3. the minimum value of right subtree is greater than the node value\\n        if(left[3] && right[3] && left[2]<root->val && right[1]>root->val){\\n            int sum=left[0]+right[0]+root->val;\\n            ans=max(sum,ans);\\n            // if left or right subtree is nullptr, then use current node\\'s value\\n            return {sum,left[1]==INT_MAX?root->val:left[1],right[2]==INT_MIN?root->val:right[2],true};\\n        }\\n        return {0,INT_MIN,INT_MAX,false};\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        dfs(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337301,
                "title": "explained-with-comments-recursive-simple-time-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    class info{\\n      public:  //declare it public so won\\'t need constructor\\n      int maxi; //max element in that tree\\n      int mini; //min element in that tree\\n      bool isBST; // is it a BST\\n      int sum; //sum of that tree\\n    };\\n    \\n    info fun(TreeNode* root , int &ans)\\n    {\\n        if(root==NULL) return {INT_MIN,INT_MAX,true,0}; //if we reached null will return max=INT_MIN min =INT_MAX isBST =true and sum=0 so it wont cause problem with isBST condition in upper level nodes\\n        info left = fun(root->left,ans);\\n        info right = fun(root->right,ans);\\n        info cur;\\n        cur.maxi= max(left.maxi,max(right.maxi,root->val)); //max off node will be max of left,right and root\\n        cur.mini= min(left.mini,min(right.mini,root->val)); //min off node will be min of left,right and root\\n        cur.isBST=(left.isBST && right.isBST &&(root->val<right.mini && root->val>left.maxi)); // tree including root will be bst only when left,right is BST and root >left.max and  root<right.min\\n        if(cur.isBST) // if it is BST if can calculate sum of this bst\\n        {\\n            cur.sum = left.sum+right.sum+root->val; // sum of new bst\\n            if(cur.sum>ans) // if it is greater than previous ans will update answer \\n                ans=cur.sum;\\n            return {cur.maxi,cur.mini,true,cur.sum}; //return cur node \\n        }\\n        else\\n            return{cur.maxi,cur.mini,false,cur.sum}; // return cur node and false\\n            \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        fun(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class info{\\n      public:  //declare it public so won\\'t need constructor\\n      int maxi; //max element in that tree\\n      int mini; //min element in that tree\\n      bool isBST; // is it a BST\\n      int sum; //sum of that tree\\n    };\\n    \\n    info fun(TreeNode* root , int &ans)\\n    {\\n        if(root==NULL) return {INT_MIN,INT_MAX,true,0}; //if we reached null will return max=INT_MIN min =INT_MAX isBST =true and sum=0 so it wont cause problem with isBST condition in upper level nodes\\n        info left = fun(root->left,ans);\\n        info right = fun(root->right,ans);\\n        info cur;\\n        cur.maxi= max(left.maxi,max(right.maxi,root->val)); //max off node will be max of left,right and root\\n        cur.mini= min(left.mini,min(right.mini,root->val)); //min off node will be min of left,right and root\\n        cur.isBST=(left.isBST && right.isBST &&(root->val<right.mini && root->val>left.maxi)); // tree including root will be bst only when left,right is BST and root >left.max and  root<right.min\\n        if(cur.isBST) // if it is BST if can calculate sum of this bst\\n        {\\n            cur.sum = left.sum+right.sum+root->val; // sum of new bst\\n            if(cur.sum>ans) // if it is greater than previous ans will update answer \\n                ans=cur.sum;\\n            return {cur.maxi,cur.mini,true,cur.sum}; //return cur node \\n        }\\n        else\\n            return{cur.maxi,cur.mini,false,cur.sum}; // return cur node and false\\n            \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        fun(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328031,
                "title": "bruteforce-optimal-app",
                "content": "**BruteForce Approach**\\n\\nTraverse the tree using recursion. For each node first check if it is a BST, if it is a BST then calculate the sum of node values of the subtree rooted at the current node. Use variable max to store the maximum BST sum calculated till now, and finally return the value of max.\\n\\n ```\\n class Solution {\\n    int max = 0;\\n    public int maxSumBST(TreeNode root) {\\n        maxSumBstUtil(root);\\n        return max;\\n    }\\n    public void maxSumBstUtil(TreeNode root){\\n        if(isBst(root)){\\n            int sum = subtreeSum(root);\\n            max  = Math.max(sum , max);\\n        }\\n        \\n        if(root.left != null){\\n            maxSumBstUtil(root.left);\\n            \\n        }\\n        \\n        if(root.right != null){\\n            maxSumBstUtil(root.right);\\n        }\\n       \\n    }\\n    \\n    public int subtreeSum(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        int currSum = root.val;\\n        currSum += subtreeSum(root.left);\\n        currSum += subtreeSum(root.right);\\n        \\n        return currSum;\\n    }\\n    \\n    \\n    \\n    public boolean isBst(TreeNode root){\\n        return isBstUtil(root , Integer.MIN_VALUE , Integer.MAX_VALUE);\\n    }\\n    \\n    public boolean isBstUtil(TreeNode root , int min , int max){\\n        if(root == null){\\n            return true;\\n        }\\n        \\n        if(root.val < min || root.val  > max){\\n            return false;\\n        }\\n        \\n        return (isBstUtil(root.left , min , root.val-1)  && isBstUtil(root.right , root.val+1 , max));\\n    }\\n}\\n ```\\n \\n \\n Note :- **TLE**\\n \\n \\n **Optimal APproach**\\n \\n \\n ```\\n class Solution {\\n    int maxSum = 0;\\n    class Pair{\\n        int min;\\n        int max; \\n        int sum;\\n    }\\n    \\n    public int maxSumBST(TreeNode root) {\\n       Pair sol =  utilFunction(root);\\n        return maxSum;\\n    }\\n    \\n    public Pair utilFunction(TreeNode root){\\n        if(root == null){\\n           Pair bp = new Pair();\\n            bp.min = Integer.MAX_VALUE;\\n            bp.max = Integer.MIN_VALUE;\\n            bp.sum = 0;\\n            \\n           return bp;\\n            \\n        }\\n        \\n        Pair lp = utilFunction(root.left);\\n        Pair rp = utilFunction(root.right);\\n        Pair mp = new Pair();\\n        if(root.val > lp.max && root.val < rp.min){ //valid bst\\n            mp.min = Math.min(lp.min , root.val);\\n            mp.max = Math.max(rp.max , root.val);\\n            mp.sum = lp.sum + rp.sum + root.val;\\n            maxSum = Math.max(maxSum , mp.sum);\\n        }\\n        else{ //not a valid bst\\n            mp.min = Integer.MIN_VALUE;\\n            mp.max = Integer.MAX_VALUE;\\n            mp.sum = Math.max(lp.sum , rp.sum);\\n        }\\n        return mp;\\n    }\\n    \\n    \\n}\\n ```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n class Solution {\\n    int max = 0;\\n    public int maxSumBST(TreeNode root) {\\n        maxSumBstUtil(root);\\n        return max;\\n    }\\n    public void maxSumBstUtil(TreeNode root){\\n        if(isBst(root)){\\n            int sum = subtreeSum(root);\\n            max  = Math.max(sum , max);\\n        }\\n        \\n        if(root.left != null){\\n            maxSumBstUtil(root.left);\\n            \\n        }\\n        \\n        if(root.right != null){\\n            maxSumBstUtil(root.right);\\n        }\\n       \\n    }\\n    \\n    public int subtreeSum(TreeNode root){\\n        if(root == null){\\n            return 0;\\n        }\\n        \\n        int currSum = root.val;\\n        currSum += subtreeSum(root.left);\\n        currSum += subtreeSum(root.right);\\n        \\n        return currSum;\\n    }\\n    \\n    \\n    \\n    public boolean isBst(TreeNode root){\\n        return isBstUtil(root , Integer.MIN_VALUE , Integer.MAX_VALUE);\\n    }\\n    \\n    public boolean isBstUtil(TreeNode root , int min , int max){\\n        if(root == null){\\n            return true;\\n        }\\n        \\n        if(root.val < min || root.val  > max){\\n            return false;\\n        }\\n        \\n        return (isBstUtil(root.left , min , root.val-1)  && isBstUtil(root.right , root.val+1 , max));\\n    }\\n}\\n ```\n```\\n class Solution {\\n    int maxSum = 0;\\n    class Pair{\\n        int min;\\n        int max; \\n        int sum;\\n    }\\n    \\n    public int maxSumBST(TreeNode root) {\\n       Pair sol =  utilFunction(root);\\n        return maxSum;\\n    }\\n    \\n    public Pair utilFunction(TreeNode root){\\n        if(root == null){\\n           Pair bp = new Pair();\\n            bp.min = Integer.MAX_VALUE;\\n            bp.max = Integer.MIN_VALUE;\\n            bp.sum = 0;\\n            \\n           return bp;\\n            \\n        }\\n        \\n        Pair lp = utilFunction(root.left);\\n        Pair rp = utilFunction(root.right);\\n        Pair mp = new Pair();\\n        if(root.val > lp.max && root.val < rp.min){ //valid bst\\n            mp.min = Math.min(lp.min , root.val);\\n            mp.max = Math.max(rp.max , root.val);\\n            mp.sum = lp.sum + rp.sum + root.val;\\n            maxSum = Math.max(maxSum , mp.sum);\\n        }\\n        else{ //not a valid bst\\n            mp.min = Integer.MIN_VALUE;\\n            mp.max = Integer.MAX_VALUE;\\n            mp.sum = Math.max(lp.sum , rp.sum);\\n        }\\n        return mp;\\n    }\\n    \\n    \\n}\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 2311578,
                "title": "c-easy-solution-using-class-with-video-solution",
                "content": "```\\nclass info{\\npublic:\\n    int mini;\\n    int maxi;\\n    bool isBST;\\n    int sum;\\n};\\nclass Solution {\\npublic:\\n    info solve(TreeNode* root, int &ans){\\n        // base case\\n        if (root==NULL){\\n            return {INT_MAX,INT_MIN,true,0};\\n        }\\n        \\n        info left=solve(root->left,ans);\\n        info right = solve(root->right,ans);\\n        \\n        info curr;\\n        \\n        curr.sum = left.sum + right.sum + root->val;\\n        curr.mini = min(root->val,left.mini);\\n        curr.maxi = max(root->val,right.maxi);\\n        if(left.isBST and right.isBST and (left.maxi < root->val) and (right.mini > root->val)){\\n            curr.isBST = true;\\n        }\\n        else{\\n            curr.isBST = false;\\n        }\\n        \\n        if(curr.isBST){\\n            ans = max(ans,curr.sum);\\n        }\\n        return curr;\\n          \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int  maxSum=0;\\n        solve(root,maxSum);\\n        return maxSum;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    info solve(TreeNode* root, int &ans){\\n        // base case\\n        if (root==NULL){\\n            return {INT_MAX,INT_MIN,true,0}",
                "codeTag": "Java"
            },
            {
                "id": 2308982,
                "title": "c-readable-class-of-required-params-dfs-recursion",
                "content": "```\\nclass info{\\n    public:\\n    int mn;\\n    int mx;\\n    bool isBST;\\n    int sum;\\n};\\nclass Solution {\\npublic:\\n    info Fn(TreeNode* root,int& ans){\\n        if(!root){\\n            return {INT_MAX,INT_MIN,true,0};\\n        }\\n        info left = Fn(root->left,ans);\\n        info right = Fn(root->right,ans);\\n        \\n        info curr;\\n        curr.mn = min(root->val,left.mn);\\n        curr.mx = max(root->val,right.mx);\\n        if(left.isBST and right.isBST and (left.mx < root->val) and (right.mn > root->val)){\\n            curr.isBST = true;\\n        }\\n        else{\\n            curr.isBST = false;\\n        }\\n        curr.sum = left.sum + right.sum + root->val;\\n        if(curr.isBST){\\n            ans = max(ans,curr.sum);\\n        }\\n        return curr;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        Fn(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass info{\\n    public:\\n    int mn;\\n    int mx;\\n    bool isBST;\\n    int sum;\\n};\\nclass Solution {\\npublic:\\n    info Fn(TreeNode* root,int& ans){\\n        if(!root){\\n            return {INT_MAX,INT_MIN,true,0};\\n        }\\n        info left = Fn(root->left,ans);\\n        info right = Fn(root->right,ans);\\n        \\n        info curr;\\n        curr.mn = min(root->val,left.mn);\\n        curr.mx = max(root->val,right.mx);\\n        if(left.isBST and right.isBST and (left.mx < root->val) and (right.mn > root->val)){\\n            curr.isBST = true;\\n        }\\n        else{\\n            curr.isBST = false;\\n        }\\n        curr.sum = left.sum + right.sum + root->val;\\n        if(curr.isBST){\\n            ans = max(ans,curr.sum);\\n        }\\n        return curr;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        Fn(root,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2296293,
                "title": "c-solution-easy-explanation",
                "content": "```\\nclass BSTNode{      // new node class to store extra information with respect to BST\\npublic:\\n    int maxNode, minNode, maxSum;\\n    \\n    BSTNode(int maxNode, int minNode, int maxSum){      // parameterized constructor\\n        this->maxNode = maxNode;    // maximum value among nodes seen till BSTNode\\n        this->minNode = minNode;    // minimum value among nodes seen till BSTNode\\n        this->maxSum = maxSum;      // sum of all the nodes forming BST considering BSTNode as root\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    BSTNode helper(TreeNode* root){\\n        // an empty tree is a BST with maxSum 0\\n        if(!root){\\n            return BSTNode(INT_MIN, INT_MAX, 0);\\n        }\\n        \\n        // get values from the left and right subtree of current tree i.e. post-order traversal\\n        auto left = helper(root->left);\\n        auto right = helper(root->right);\\n        \\n        // if current node is greater than max in left and is smaller than min in right, then it is a BST\\n        if(left.maxNode < root->val && root->val < right.minNode){\\n            // it is a BST, so the parent\\'s maxNode, minNode, maxSum will get updated with max in right, min in left and currSum including root respectively\\n            int currSum = left.maxSum + right.maxSum + root->val;\\n            ans = max(ans, currSum);     // keeping track of the maximum currSum\\n            return BSTNode(max(root->val, right.maxNode), min(root->val, left.minNode), currSum);\\n        }\\n        \\n        // otherwise return [-INF, INF] so that parent can\\'t be a valid BST. Here we still keep maxSum = max(left.maxSum, right.maxSum) to keep track of previous valid BST that found before current invalid BST\\n        return BSTNode(INT_MAX, INT_MIN, max(left.maxSum, right.maxSum));\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        helper(root);  // The final maxSum value will be our answer\\n        \\n        return (ans>0) ? ans : 0;   // handling the case when all the nodes are negative, then we have to return empty BST\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass BSTNode{      // new node class to store extra information with respect to BST\\npublic:\\n    int maxNode, minNode, maxSum;\\n    \\n    BSTNode(int maxNode, int minNode, int maxSum){      // parameterized constructor\\n        this->maxNode = maxNode;    // maximum value among nodes seen till BSTNode\\n        this->minNode = minNode;    // minimum value among nodes seen till BSTNode\\n        this->maxSum = maxSum;      // sum of all the nodes forming BST considering BSTNode as root\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    BSTNode helper(TreeNode* root){\\n        // an empty tree is a BST with maxSum 0\\n        if(!root){\\n            return BSTNode(INT_MIN, INT_MAX, 0);\\n        }\\n        \\n        // get values from the left and right subtree of current tree i.e. post-order traversal\\n        auto left = helper(root->left);\\n        auto right = helper(root->right);\\n        \\n        // if current node is greater than max in left and is smaller than min in right, then it is a BST\\n        if(left.maxNode < root->val && root->val < right.minNode){\\n            // it is a BST, so the parent\\'s maxNode, minNode, maxSum will get updated with max in right, min in left and currSum including root respectively\\n            int currSum = left.maxSum + right.maxSum + root->val;\\n            ans = max(ans, currSum);     // keeping track of the maximum currSum\\n            return BSTNode(max(root->val, right.maxNode), min(root->val, left.minNode), currSum);\\n        }\\n        \\n        // otherwise return [-INF, INF] so that parent can\\'t be a valid BST. Here we still keep maxSum = max(left.maxSum, right.maxSum) to keep track of previous valid BST that found before current invalid BST\\n        return BSTNode(INT_MAX, INT_MIN, max(left.maxSum, right.maxSum));\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        helper(root);  // The final maxSum value will be our answer\\n        \\n        return (ans>0) ? ans : 0;   // handling the case when all the nodes are negative, then we have to return empty BST\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2285453,
                "title": "c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Info {\\npublic:\\n    int minimum;\\n    int maximum;\\n    bool isBST;\\n    int runningSum;\\n    int maxSum;\\n};\\n\\nclass Solution {\\npublic:\\n    Info helper(TreeNode* root) {\\n        Info inf;\\n        if (!root) {\\n            inf.minimum = INT_MAX;\\n            inf.maximum = INT_MIN;\\n            inf.isBST = true;\\n            inf.runningSum = 0;\\n            inf.maxSum = 0;\\n            return inf;\\n        }\\n        \\n        Info left = helper(root->left);\\n        Info right = helper(root->right);\\n        \\n        inf.minimum = min(root->val, min(left.minimum, right.minimum));\\n        inf.maximum = max(root->val, max(left.maximum, right.maximum));\\n        inf.isBST = left.isBST && right.isBST && (root->val > left.maximum) && (root->val < right.minimum);\\n        inf.runningSum = left.runningSum + right.runningSum + root->val;\\n        \\n        if (inf.isBST) {\\n            inf.maxSum = max(inf.runningSum, max(left.maxSum, right.maxSum));\\n        }\\n        else\\n            inf.maxSum = max(left.maxSum, right.maxSum);\\n        \\n        return inf;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        return helper(root).maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\nclass Info {\\npublic:\\n    int minimum;\\n    int maximum;\\n    bool isBST;\\n    int runningSum;\\n    int maxSum;\\n};\\n\\nclass Solution {\\npublic:\\n    Info helper(TreeNode* root) {\\n        Info inf;\\n        if (!root) {\\n            inf.minimum = INT_MAX;\\n            inf.maximum = INT_MIN;\\n            inf.isBST = true;\\n            inf.runningSum = 0;\\n            inf.maxSum = 0;\\n            return inf;\\n        }\\n        \\n        Info left = helper(root->left);\\n        Info right = helper(root->right);\\n        \\n        inf.minimum = min(root->val, min(left.minimum, right.minimum));\\n        inf.maximum = max(root->val, max(left.maximum, right.maximum));\\n        inf.isBST = left.isBST && right.isBST && (root->val > left.maximum) && (root->val < right.minimum);\\n        inf.runningSum = left.runningSum + right.runningSum + root->val;\\n        \\n        if (inf.isBST) {\\n            inf.maxSum = max(inf.runningSum, max(left.maxSum, right.maxSum));\\n        }\\n        else\\n            inf.maxSum = max(left.maxSum, right.maxSum);\\n        \\n        return inf;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        return helper(root).maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269544,
                "title": "java-easy-to-understand-code",
                "content": "```\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        int ans = helper(root).currmax;\\n        return ans > 0 ? ans : 0;\\n    }\\n    public Val helper(TreeNode root)\\n    {\\n        if(root==null)\\n            return new Val(Integer.MAX_VALUE,Integer.MIN_VALUE,0,true,0);\\n        \\n        if(root.left==null && root.right==null)\\n            return new Val(root.val,root.val,root.val,true,root.val);\\n        \\n        Val l = helper(root.left);\\n        Val r = helper(root.right);\\n        \\n        Val curr = new Val();\\n        \\n        if(l.isBST && r.isBST && l.max < root.val && r.min > root.val)\\n        {\\n            curr.min = Math.min(l.min,root.val);\\n            curr.max = Math.max(r.max,root.val);\\n            curr.sum = root.val + l.sum + r.sum;\\n            curr.isBST = true;\\n            curr.currmax = Math.max(Math.max(l.currmax,r.currmax),curr.sum);\\n            return curr;\\n        }\\n        \\n        curr.min = Math.min(root.val,Math.min(l.min,r.min));\\n        curr.max = Math.max(root.val,Math.max(l.max,r.max));\\n        curr.sum = Integer.MIN_VALUE;\\n        curr.isBST = false;\\n        curr.currmax = Math.max(l.currmax,r.currmax);\\n        \\n        return curr;\\n    }\\n}\\nclass Val{\\n    int min;\\n    int max;\\n    int sum;\\n    boolean isBST;\\n    int currmax;\\n    public Val(int mi,int ma,int s,boolean ibt,int curr)\\n    {\\n        min = mi;\\n        max = ma;\\n        sum = s;\\n        isBST = ibt;\\n        currmax = curr;\\n    }\\n    public Val()\\n    {\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        int ans = helper(root).currmax;\\n        return ans > 0 ? ans : 0;\\n    }\\n    public Val helper(TreeNode root)\\n    {\\n        if(root==null)\\n            return new Val(Integer.MAX_VALUE,Integer.MIN_VALUE,0,true,0);\\n        \\n        if(root.left==null && root.right==null)\\n            return new Val(root.val,root.val,root.val,true,root.val);\\n        \\n        Val l = helper(root.left);\\n        Val r = helper(root.right);\\n        \\n        Val curr = new Val();\\n        \\n        if(l.isBST && r.isBST && l.max < root.val && r.min > root.val)\\n        {\\n            curr.min = Math.min(l.min,root.val);\\n            curr.max = Math.max(r.max,root.val);\\n            curr.sum = root.val + l.sum + r.sum;\\n            curr.isBST = true;\\n            curr.currmax = Math.max(Math.max(l.currmax,r.currmax),curr.sum);\\n            return curr;\\n        }\\n        \\n        curr.min = Math.min(root.val,Math.min(l.min,r.min));\\n        curr.max = Math.max(root.val,Math.max(l.max,r.max));\\n        curr.sum = Integer.MIN_VALUE;\\n        curr.isBST = false;\\n        curr.currmax = Math.max(l.currmax,r.currmax);\\n        \\n        return curr;\\n    }\\n}\\nclass Val{\\n    int min;\\n    int max;\\n    int sum;\\n    boolean isBST;\\n    int currmax;\\n    public Val(int mi,int ma,int s,boolean ibt,int curr)\\n    {\\n        min = mi;\\n        max = ma;\\n        sum = s;\\n        isBST = ibt;\\n        currmax = curr;\\n    }\\n    public Val()\\n    {\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2250264,
                "title": "easy-to-understand-c-solution",
                "content": "```\\nstruct Info{\\n    int maxSum;\\n    int totSum;\\n    bool isBst;\\n    int minVal;\\n    int maxVal;\\n};\\n\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        \\n        int ans=helper(root).maxSum;\\n        return ans<0?0:ans;\\n    }\\n    \\n    Info helper(TreeNode* root){\\n        \\n        if(root==NULL){\\n            return {0,0,true,INT_MAX,INT_MIN};\\n        }\\n        if(root->right==NULL && root->left==NULL){\\n            return {root->val,root->val,true,root->val,root->val};\\n        }\\n        \\n        Info left=helper(root->left);\\n        Info right=helper(root->right);\\n        Info curr;\\n        if(left.isBst && right.isBst && root->val>left.maxVal && root->val<right.minVal){\\n            curr.totSum=left.totSum+right.totSum+root->val;\\n            curr.maxSum=max({curr.totSum,left.maxSum,right.maxSum});\\n            curr.isBst=true;\\n            curr.minVal=min({root->val,left.minVal,right.minVal});\\n            curr.maxVal=max({root->val,left.maxVal,right.maxVal});\\n            return curr;\\n        }else{\\n            curr.isBst=false;\\n            curr.maxSum=max(left.maxSum,right.maxSum);\\n            curr.totSum=root->val+left.totSum+right.totSum;\\n            curr.minVal=min({root->val,left.minVal,right.minVal});\\n            curr.maxVal=max({root->val,left.maxVal,right.maxVal});\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct Info{\\n    int maxSum;\\n    int totSum;\\n    bool isBst;\\n    int minVal;\\n    int maxVal;\\n};\\n\\nclass Solution {\\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        \\n        int ans=helper(root).maxSum;\\n        return ans<0?0:ans;\\n    }\\n    \\n    Info helper(TreeNode* root){\\n        \\n        if(root==NULL){\\n            return {0,0,true,INT_MAX,INT_MIN};\\n        }\\n        if(root->right==NULL && root->left==NULL){\\n            return {root->val,root->val,true,root->val,root->val};\\n        }\\n        \\n        Info left=helper(root->left);\\n        Info right=helper(root->right);\\n        Info curr;\\n        if(left.isBst && right.isBst && root->val>left.maxVal && root->val<right.minVal){\\n            curr.totSum=left.totSum+right.totSum+root->val;\\n            curr.maxSum=max({curr.totSum,left.maxSum,right.maxSum});\\n            curr.isBst=true;\\n            curr.minVal=min({root->val,left.minVal,right.minVal});\\n            curr.maxVal=max({root->val,left.maxVal,right.maxVal});\\n            return curr;\\n        }else{\\n            curr.isBst=false;\\n            curr.maxSum=max(left.maxSum,right.maxSum);\\n            curr.totSum=root->val+left.totSum+right.totSum;\\n            curr.minVal=min({root->val,left.minVal,right.minVal});\\n            curr.maxVal=max({root->val,left.maxVal,right.maxVal});\\n        }\\n        return curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2239264,
                "title": "java-easy-solution-time-complexity-o-n-and-space-o-1",
                "content": "```\\nclass Solution {\\n    static class Pair{\\n        int max;\\n        int min;\\n        int sum;\\n        boolean isBst;\\n        Pair(int l,int r,int m,boolean b){\\n            this.max=l;\\n            this.min=r;\\n            this.sum=m;\\n            this.isBst=b;\\n           \\n        }\\n\\t\\t//1 Every Node will return the above parameters above .\\n\\t\\t//2 If the root value is  larger than max left value the it will be larger than all left values .\\n\\t//\\t3 If the root value is less than min value of right that it will be less than all other values hence will form a bst and we are also tracking sum.\\n    }\\n   \\n    static Pair recur(TreeNode r,int a[]){\\n        if(r==null){\\n            return new Pair(Integer.MIN_VALUE,Integer.MAX_VALUE,0,true);\\n        }\\n        Pair lobj=recur(r.left,a);\\n        Pair robj=recur(r.right,a);\\n        if(r.val<=lobj.max||r.val>=robj.min)\\n        return new Pair(Integer.MIN_VALUE,Integer.MAX_VALUE,0,false);\\n         int maxLeft=Math.max(r.val,Math.max(lobj.max,robj.max));\\n         int minRight=Math.min(r.val,Math.min(lobj.min,robj.min));\\n        boolean chk=false;\\n         if(lobj.isBst&&robj.isBst){\\n             a[0]=Math.max(a[0],lobj.sum+robj.sum+r.val);\\n             chk=true;   \\n         }\\n        else if(lobj.isBst){\\n            a[0]=Math.max(a[0],lobj.sum);\\n            chk=false;\\n        }\\n        else if(robj.isBst){\\n            a[0]=Math.max(a[0],robj.sum);\\n            chk=false;\\n        }\\n        return new Pair(maxLeft,minRight,lobj.sum+robj.sum+r.val,chk);\\n        \\n    }\\n     public int maxSumBST(TreeNode root) {\\n         int a[]=new int[1];\\n          recur(root,a);\\n        return a[0];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    static class Pair{\\n        int max;\\n        int min;\\n        int sum;\\n        boolean isBst;\\n        Pair(int l,int r,int m,boolean b){\\n            this.max=l;\\n            this.min=r;\\n            this.sum=m;\\n            this.isBst=b;\\n           \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2217830,
                "title": "c-solution-o-n-bst-100-faster-easy-to-understand",
                "content": "\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    ll sum=0;\\n    //ll currsum=0;\\n   vector<pair<ll,TreeNode*>> v;\\n    int tsum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int l=tsum(root->left);\\n        int r=tsum(root->right);\\n       v.push_back({root->val+l+r,root});\\n        return root->val+l+r;\\n    }\\n    bool check(TreeNode* root,int high,int low)\\n    {\\n        if(root==NULL)\\n            return true;\\n        if(root->val>low && root->val<high)\\n            return check(root->left,root->val,low) && check(root->right,high,root->val);\\n        return false;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        tsum(root);\\n        sort(v.begin(),v.end(),greater<pair<ll,TreeNode*>>());\\n        for(int i=0;i<v.size();i++)\\n        {\\n           int high=INT_MAX;\\n           int low=INT_MIN;\\n            if(v[i].first<0)\\n                break;\\n           if(check(v[i].second,high,low))\\n               return v[i].first;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    \\n    ll sum=0;\\n    //ll currsum=0;\\n   vector<pair<ll,TreeNode*>> v;\\n    int tsum(TreeNode* root)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int l=tsum(root->left);\\n        int r=tsum(root->right);\\n       v.push_back({root->val+l+r,root});\\n        return root->val+l+r;\\n    }\\n    bool check(TreeNode* root,int high,int low)\\n    {\\n        if(root==NULL)\\n            return true;\\n        if(root->val>low && root->val<high)\\n            return check(root->left,root->val,low) && check(root->right,high,root->val);\\n        return false;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        tsum(root);\\n        sort(v.begin(),v.end(),greater<pair<ll,TreeNode*>>());\\n        for(int i=0;i<v.size();i++)\\n        {\\n           int high=INT_MAX;\\n           int low=INT_MIN;\\n            if(v[i].first<0)\\n                break;\\n           if(check(v[i].second,high,low))\\n               return v[i].first;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217829,
                "title": "c-100-faster-easy-and-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    map<TreeNode * ,int> mp;\\n    vector<pair<int ,TreeNode *>> v;\\n    int maxSumBST(TreeNode* root) {\\n        cal(root);\\n        int max=0;\\n        sort(v.rbegin(),v.rend());\\n         for(int i=0;i<v.size();i++){\\n             if(v[i].first<0)\\n                 break;\\n             if(isBST(v[i].second))\\n                 return v[i].first;\\n         }\\n        return 0;\\n    }\\n    \\n    int cal(TreeNode * root){\\n        if(root==NULL)\\n            return 0;\\n        int l=cal(root->left); \\n        int r=cal(root->right);\\n        mp[root]=l+r+root->val;\\n        v.push_back({mp[root],root});\\n        return mp[root];\\n        \\n    }\\nint isBST(TreeNode* node)\\n{\\n    return(isBSTUtil(node, INT_MIN, INT_MAX));\\n}\\nint isBSTUtil(TreeNode* node, int min, int max){\\n\\n    if (node==NULL)\\n        return 1;\\n             \\n    if (node->val < min || node->val > max)\\n        return 0;\\n     return\\n        isBSTUtil(node->left, min, node->val-1) &&\\n        isBSTUtil(node->right, node->val+1, max); \\n}\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<TreeNode * ,int> mp;\\n    vector<pair<int ,TreeNode *>> v;\\n    int maxSumBST(TreeNode* root) {\\n        cal(root);\\n        int max=0;\\n        sort(v.rbegin(),v.rend());\\n         for(int i=0;i<v.size();i++){\\n             if(v[i].first<0)\\n                 break;\\n             if(isBST(v[i].second))\\n                 return v[i].first;\\n         }\\n        return 0;\\n    }\\n    \\n    int cal(TreeNode * root){\\n        if(root==NULL)\\n            return 0;\\n        int l=cal(root->left); \\n        int r=cal(root->right);\\n        mp[root]=l+r+root->val;\\n        v.push_back({mp[root],root});\\n        return mp[root];\\n        \\n    }\\nint isBST(TreeNode* node)\\n{\\n    return(isBSTUtil(node, INT_MIN, INT_MAX));\\n}\\nint isBSTUtil(TreeNode* node, int min, int max){\\n\\n    if (node==NULL)\\n        return 1;\\n             \\n    if (node->val < min || node->val > max)\\n        return 0;\\n     return\\n        isBSTUtil(node->left, min, node->val-1) &&\\n        isBSTUtil(node->right, node->val+1, max); \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212754,
                "title": "java-post-order-dfs-save-4-states-bst-sum-max-min",
                "content": "If we can verify \\n1. The left subtree and right subtree are both BSTs\\n2. The smallest value in the right subtree is > the current root value.\\n3. The largest value in the left subtree is < the current root value.\\n\\nThen, we are able to conclude the current subtree rooted at the current node is a BST.\\n```Java\\nclass Solution {\\n    int res;\\n    int VALID = 0;\\n    public int maxSumBST(TreeNode root) {\\n        dfs(root);\\n        return res;\\n    }\\n\\n    // valid, sum, min, max;\\n    private int[] dfs(TreeNode root){\\n        if (root == null){\\n            return new int[]{VALID, 0, Integer.MAX_VALUE, Integer.MIN_VALUE};\\n        }\\n        int[] r = dfs(root.right);\\n        int[] l = dfs(root.left);\\n        int[] ans = new int[4];\\n        ans[0] = r[0]==VALID&&l[0]==VALID&&root.val < r[2] && root.val > l[3]? VALID : 1;\\n        ans[1] = r[1]+l[1]+root.val;\\n        ans[2] = Math.min(root.val, l[2]);\\n        ans[3] = Math.max(root.val, r[3]);\\n        if (ans[0]==VALID){\\n            res = Math.max(ans[1], res);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```Java\\nclass Solution {\\n    int res;\\n    int VALID = 0;\\n    public int maxSumBST(TreeNode root) {\\n        dfs(root);\\n        return res;\\n    }\\n\\n    // valid, sum, min, max;\\n    private int[] dfs(TreeNode root){\\n        if (root == null){\\n            return new int[]{VALID, 0, Integer.MAX_VALUE, Integer.MIN_VALUE};\\n        }\\n        int[] r = dfs(root.right);\\n        int[] l = dfs(root.left);\\n        int[] ans = new int[4];\\n        ans[0] = r[0]==VALID&&l[0]==VALID&&root.val < r[2] && root.val > l[3]? VALID : 1;\\n        ans[1] = r[1]+l[1]+root.val;\\n        ans[2] = Math.min(root.val, l[2]);\\n        ans[3] = Math.max(root.val, r[3]);\\n        if (ans[0]==VALID){\\n            res = Math.max(ans[1], res);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208521,
                "title": "shortest-and-easy-code-c",
                "content": "```\\n\\nstruct dat{\\n    int sum = 0;\\n    int check = true;\\n    int mi = INT_MAX;\\n    int ma = INT_MIN;\\n};\\n\\nint value = INT_MIN;\\ndat func(TreeNode *root)\\n{\\n    dat ans,ll,rr;\\n    \\n    if (root == nullptr)\\n        return ans;\\n\\n    ll = func(root->left);\\n    rr = func(root->right);\\n    \\n    ans.sum = ll.sum + rr.sum + root->val;\\n    ans.check = ((root->val) > ll.ma ) && ((root->val) < rr.mi) && ll.check && rr.check;\\n    ans.mi = min(root->val,ll.mi);\\n    ans.ma = max(root->val,rr.ma);\\n    \\n    if (ans.check)\\n        value = max(value, ans.sum);\\n\\n    return ans;\\n\\n}\\nclass Solution\\n{\\n    public:\\n        int maxSumBST(TreeNode *root)\\n        {\\n            value = INT_MIN;\\n            func(root);\\n            return ((value<0)?0:value);\\n        }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nstruct dat{\\n    int sum = 0;\\n    int check = true;\\n    int mi = INT_MAX;\\n    int ma = INT_MIN;\\n};\\n\\nint value = INT_MIN;\\ndat func(TreeNode *root)\\n{\\n    dat ans,ll,rr;\\n    \\n    if (root == nullptr)\\n        return ans;\\n\\n    ll = func(root->left);\\n    rr = func(root->right);\\n    \\n    ans.sum = ll.sum + rr.sum + root->val;\\n    ans.check = ((root->val) > ll.ma ) && ((root->val) < rr.mi) && ll.check && rr.check;\\n    ans.mi = min(root->val,ll.mi);\\n    ans.ma = max(root->val,rr.ma);\\n    \\n    if (ans.check)\\n        value = max(value, ans.sum);\\n\\n    return ans;\\n\\n}\\nclass Solution\\n{\\n    public:\\n        int maxSumBST(TreeNode *root)\\n        {\\n            value = INT_MIN;\\n            func(root);\\n            return ((value<0)?0:value);\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206751,
                "title": "post-order-dfs-recursion-hindi-explanation",
                "content": "Given,\\nHume ek binary tree ka root node diya hua hai\\nTask,\\nEk aise subtree ko find krna jo ek binary search tree hai aur jiske nodes ka sum maximum hai\\n\\n**Task ko ache se samajhne ke liye aap example test cases ko refer kr sakte hai**\\n\\n\\n**Solution,**\\nHum pure tree ko traverse karenge using post order traversal kyu ki agar humare pass left aur right ka information nahi aayega tab tk hum apne current node ke value ko undono se compare nahi kr payenge\\nMaan lo ki humara current node apne subtree ka root node hai\\nHum is node ke liye kuch chize pata krni hogi\\n\\n**1. Iss subtree Ka Sum \\n2. Kya humara current node BST ka part hai (0 mean NO , 1 mean Yes)\\n3. Iss subtree ka maximum value\\n4. Iss subtree ka minimum value**\\n\\nye sari information ko hum ek vector ke through return karenge harr ek node ke liye.\\n\\nHum recursion ke through hrr ek node ke left subtree aur right subtree ke liye ye sari 4 information nikalnege\\n\\n1. Aur uske baad hum ye check karenge ki kya iska left subtree ya right subtree BST hai ya nahi.\\n2. Agar dono subtree bst hue tab hi humare current node ke bst mai add hone ke chances hai agar koi ek subtree bhi BST nahi hua then ye confirm hai ki humare current node ke liye BST ke conditions true nahi honge (I hope you know the conditions for BST).\\n3. Agar Dono BST hue then hum ye check karenge ki \\n\\t\\t\\t\\t\\t* humara current node ka value, left subtree ke maximum value se jyada hai ki nahi and \\n\\t\\t\\t\\t\\t* humara current node ka value, right subtree ke minimum value se kam hai ki nahi \\n**Agar ye dono cases true hote hai then hum ye kah sakte hai humara current BST ka part hai aur hum iss subtree ke sum ko apne ans variable se compare krke answer store kr lenge aur agar BST ka part nahi hua to hum iss case mai answer ko compare nahi karenge .** \\n\\n\\n**Aur iss subtree ke liye return karenge,**\\n**1. Subtree sum**\\n**2. Current node BST ka part hai ya nahi**\\n**3. subtree ka maximum value\\n4. subtree ka minimum value**\\n\\nOtherwise\\nHumara current node BST ka part nahi \\n\\n\\n\\n```\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    vector<int> solve(TreeNode *root,int &ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return {0,1,INT_MIN,INT_MAX};\\n        }\\n        \\n        \\n        vector<int> left=solve(root->left,ans);\\n        vector<int> right=solve(root->right,ans);\\n        \\n        \\n        if(left[1]==1 && right[1]==1 && root->val>left[2] && root->val<right[3])\\n        {\\n            ans=max(ans,left[0]+right[0]+root->val);\\n             return {left[0]+right[0]+root->val,1,max(root->val,right[2]),min(left[3],root->val)};\\n        }\\n        else\\n        {\\n            return {left[0]+right[0]+root->val,0,max(root->val,right[2]),min(left[3],root->val)};\\n        }\\n            \\n        \\n    }\\n    int maxSumBST(TreeNode* root) \\n    {\\n        int ans=0;\\n        solve(root,ans);\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    vector<int> solve(TreeNode *root,int &ans)\\n    {\\n        if(root==NULL)\\n        {\\n            return {0,1,INT_MIN,INT_MAX};\\n        }\\n        \\n        \\n        vector<int> left=solve(root->left,ans);\\n        vector<int> right=solve(root->right,ans);\\n        \\n        \\n        if(left[1]==1 && right[1]==1 && root->val>left[2] && root->val<right[3])\\n        {\\n            ans=max(ans,left[0]+right[0]+root->val);\\n             return {left[0]+right[0]+root->val,1,max(root->val,right[2]),min(left[3],root->val)};\\n        }\\n        else\\n        {\\n            return {left[0]+right[0]+root->val,0,max(root->val,right[2]),min(left[3],root->val)};\\n        }\\n            \\n        \\n    }\\n    int maxSumBST(TreeNode* root) \\n    {\\n        int ans=0;\\n        solve(root,ans);\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177322,
                "title": "post-order-traverse-basic-bst-property-is-used-cpp",
                "content": "**Hello Guys,**\\n\\nthis is a very simple solution for `Maximum Sum BST in Binary Tree` problem.\\n\\nwe are using a tuple of `<mn, mx, sum>`\\n**Let** currently we are on a `node`\\n`mn`=minimum value of a node in this subtree\\n`mx`=maximum value of a node in this subtree\\n`sum`=sum of all the nodes of this subtree\\n\\n* `if` current node\\'s value is between max node from left to min node from right, then it is a valid BST \\n\\t* then we add this current node\\'s value in `left_sum+right_sum` and return tuple for current node, which have min node till this tree, max node till this tree and sum of this tree\\n* `else` it is not a valid BST\\n\\t* then return min node as INT_MIN, max node as INT_MAX and sum as 0\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    \\n    // tuple <min, max, sum>\\n    int ans=0;\\n    tuple<int,int,int> fun(TreeNode* cr)\\n    {\\n        tuple<int,int,int>t;\\n        \\n        if(!cr)\\n        {\\n            t=make_tuple(1e7,-1e7,0);\\n            return t;\\n        }\\n        \\n        if(!cr->left && !cr->right) ans=max(ans, cr->val);\\n        tuple<int,int,int>l_tp,r_tp;\\n        \\n        // max from left\\n        l_tp=fun(cr->left);\\n        int mx=get<1>(l_tp);\\n        \\n        // min from right\\n        r_tp=fun(cr->right);\\n        int mn=get<0>(r_tp);\\n        \\n        int mid=cr->val;\\n        int sum=get<2>(l_tp)+get<2>(r_tp);\\n        \\n        // check if this is valid bst and will return valid min, max and sum of nodes\\n        if(mx<mid && mid<mn)\\n        {\\n            ans=max(ans, sum+mid);\\n            mn=get<0>(l_tp), mx=get<1>(r_tp);\\n            t=make_tuple(min(mn,mid), max(mx, mid), sum+mid);\\n            return t;\\n        }\\n        \\n\\t\\t// BST is not valid so return corner value so it will not be included as a valid BST in above nodes\\n        t=make_tuple(-1e7, 1e7, 0);\\n        return t;\\n        \\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        \\n        ans=0;\\n        tuple<int,int,int>tt=fun(root);\\n        return ans;\\n    }\\n};\\n```\\nThanks...",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // tuple <min, max, sum>\\n    int ans=0;\\n    tuple<int,int,int> fun(TreeNode* cr)\\n    {\\n        tuple<int,int,int>t;\\n        \\n        if(!cr)\\n        {\\n            t=make_tuple(1e7,-1e7,0);\\n            return t;\\n        }\\n        \\n        if(!cr->left && !cr->right) ans=max(ans, cr->val);\\n        tuple<int,int,int>l_tp,r_tp;\\n        \\n        // max from left\\n        l_tp=fun(cr->left);\\n        int mx=get<1>(l_tp);\\n        \\n        // min from right\\n        r_tp=fun(cr->right);\\n        int mn=get<0>(r_tp);\\n        \\n        int mid=cr->val;\\n        int sum=get<2>(l_tp)+get<2>(r_tp);\\n        \\n        // check if this is valid bst and will return valid min, max and sum of nodes\\n        if(mx<mid && mid<mn)\\n        {\\n            ans=max(ans, sum+mid);\\n            mn=get<0>(l_tp), mx=get<1>(r_tp);\\n            t=make_tuple(min(mn,mid), max(mx, mid), sum+mid);\\n            return t;\\n        }\\n        \\n\\t\\t// BST is not valid so return corner value so it will not be included as a valid BST in above nodes\\n        t=make_tuple(-1e7, 1e7, 0);\\n        return t;\\n        \\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        \\n        ans=0;\\n        tuple<int,int,int>tt=fun(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177295,
                "title": "faster-than-93-66-easy-c-recursive-explained-solution",
                "content": "```\\nint helper(TreeNode* root,int &min,int &max,bool &is_bst,int &max_sum)\\n    {\\n        if(!root){  // for empty Binary Tree\\n            is_bst=1;\\n            return 0;\\n        }\\n        int tmp=INT_MAX; \\n        bool left_bst=false,right_bst=false; //initialize for left and right subtree bst check \\n         max=INT_MIN; // for maximum element in left subtree\\n        int left_sum=0;\\n            left_sum+=helper(root->left,min,max,is_bst,max_sum);\\n     \\n     if(is_bst && root->val > max)  //condition for left subtree as bst or not\\n      left_bst=true;\\n      // update the min for right subtree\\n      tmp=min;\\n\\t  // same intution for right subtree\\n      min=INT_MAX;\\n      int right_sum=0;\\n        right_sum+=helper(root->right,min,max,is_bst,max_sum);\\n      \\n      if(is_bst && root->val < min)\\n       right_bst=true;\\n           \\n        if(tmp<min)\\n          min=tmp;\\n    //   for leaf nodes\\n        if(root->val <min)\\n         min=root->val;\\n        if(root->val > max)\\n        max = root->val;\\n    \\n\\t// return max_sum \\n    if(left_bst && right_bst)\\n        {\\n            if(left_sum + right_sum + root->val > max_sum)\\n             max_sum=left_sum + right_sum + root->val ;\\n           return left_sum + right_sum + root->val ; \\n        }\\n        else{\\n            is_bst=0;\\n            return 0;\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int min=INT_MAX;\\n        int max=INT_MIN;\\n        bool is_bst=0;\\n        int max_sum=0;\\n        helper(root,min,max,is_bst,max_sum);\\n        return max_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nint helper(TreeNode* root,int &min,int &max,bool &is_bst,int &max_sum)\\n    {\\n        if(!root){  // for empty Binary Tree\\n            is_bst=1;\\n            return 0;\\n        }\\n        int tmp=INT_MAX; \\n        bool left_bst=false,right_bst=false; //initialize for left and right subtree bst check \\n         max=INT_MIN; // for maximum element in left subtree\\n        int left_sum=0;\\n            left_sum+=helper(root->left,min,max,is_bst,max_sum);\\n     \\n     if(is_bst && root->val > max)  //condition for left subtree as bst or not\\n      left_bst=true;\\n      // update the min for right subtree\\n      tmp=min;\\n\\t  // same intution for right subtree\\n      min=INT_MAX;\\n      int right_sum=0;\\n        right_sum+=helper(root->right,min,max,is_bst,max_sum);\\n      \\n      if(is_bst && root->val < min)\\n       right_bst=true;\\n           \\n        if(tmp<min)\\n          min=tmp;\\n    //   for leaf nodes\\n        if(root->val <min)\\n         min=root->val;\\n        if(root->val > max)\\n        max = root->val;\\n    \\n\\t// return max_sum \\n    if(left_bst && right_bst)\\n        {\\n            if(left_sum + right_sum + root->val > max_sum)\\n             max_sum=left_sum + right_sum + root->val ;\\n           return left_sum + right_sum + root->val ; \\n        }\\n        else{\\n            is_bst=0;\\n            return 0;\\n        }\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int min=INT_MAX;\\n        int max=INT_MIN;\\n        bool is_bst=0;\\n        int max_sum=0;\\n        helper(root,min,max,is_bst,max_sum);\\n        return max_sum;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2171517,
                "title": "c-dfs-pairs-beginner-friendly-superfast-no-class-object",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    pair<int,pair<int,int>>solve(TreeNode*root,int mini,int maxi,int sum)\\n    {\\n\\t\\t//if root is null then it must be bst as it is a single node\\n        if(!root)\\n        {\\n            pair<int,pair<int,int>>curr;\\n            curr.first=0;\\n            curr.second.first=INT_MAX;\\n            curr.second.second=INT_MIN;\\n            return curr;\\n        }\\n        auto l=solve(root->left,mini,maxi,sum);\\n        auto r=solve(root->right,mini,maxi,sum);\\n        \\n        pair<int,pair<int,int>>curr;\\n\\t\\t//if left and right are bst\\n        if(root->val>l.second.second && root->val<r.second.first)\\n        {\\n\\t\\t//sum will be root->val+left +right\\n            curr.first=l.first+r.first+root->val;\\n\\t\\t//min will be root,left,right\\n            curr.second.first=min(r.second.first,min(root->val,l.second.first));\\n\\t\\t//max will be root,left,right\\n            curr.second.second=max(l.second.second,max(root->val,r.second.second));\\n\\t\\t//store max ans;\\n            ans=max(ans,curr.first);\\n            return curr;\\n        }\\n\\t\\t//if left and right are not bst\\n        curr.first=0;\\n\\t\\t//initialise with int min and int max so that it will always false when comparing\\n        curr.second.first=INT_MIN;\\n        curr.second.second=INT_MAX;\\n        return curr;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        solve(root,INT_MIN,INT_MAX,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int ans=0;\\n    pair<int,pair<int,int>>solve(TreeNode*root,int mini,int maxi,int sum)\\n    {\\n\\t\\t//if root is null then it must be bst as it is a single node\\n        if(!root)\\n        {\\n            pair<int,pair<int,int>>curr;\\n            curr.first=0;\\n            curr.second.first=INT_MAX;\\n            curr.second.second=INT_MIN;\\n            return curr;\\n        }\\n        auto l=solve(root->left,mini,maxi,sum);\\n        auto r=solve(root->right,mini,maxi,sum);\\n        \\n        pair<int,pair<int,int>>curr;\\n\\t\\t//if left and right are bst\\n        if(root->val>l.second.second && root->val<r.second.first)\\n        {\\n\\t\\t//sum will be root->val+left +right\\n            curr.first=l.first+r.first+root->val;\\n\\t\\t//min will be root,left,right\\n            curr.second.first=min(r.second.first,min(root->val,l.second.first));\\n\\t\\t//max will be root,left,right\\n            curr.second.second=max(l.second.second,max(root->val,r.second.second));\\n\\t\\t//store max ans;\\n            ans=max(ans,curr.first);\\n            return curr;\\n        }\\n\\t\\t//if left and right are not bst\\n        curr.first=0;\\n\\t\\t//initialise with int min and int max so that it will always false when comparing\\n        curr.second.first=INT_MIN;\\n        curr.second.second=INT_MAX;\\n        return curr;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        solve(root,INT_MIN,INT_MAX,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109013,
                "title": "c-postorder-traversal-with-comments-clean-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    struct bst{\\n         bool isbst;\\n      int max;\\n      int min;\\n      int sum;\\n    };\\n    \\n    bst Bst(TreeNode* root)\\n    {\\n        //we are at end of tree where node->left or node->right==nullprt\\n        //if we find a nullptr, we initialize a newbst to compare it with nodes above\\n       if(root==nullptr)\\n       {\\n        bst newbst;           \\n        newbst.isbst = true;\\n        newbst.max = INT_MIN;\\n        newbst.min = INT_MAX;\\n        newbst.sum = 0;\\n        return newbst;\\n       }\\n        \\n       //postorder traversal\\n      bst l = Bst(root->left); // left sub-tree\\n      bst r = Bst(root->right); // right sub-tree\\n        \\n        //our current node to check\\n        bst currnode;\\n        \\n        //check if its a bst\\n        \\n        //conditions->its left and right subrees must be a BST\\n        //->current node value > than max value of left subtree and <min value in right subtree\\n        currnode.isbst= l.isbst && r.isbst && (l.max < root->val && r.min > root->val);\\n        \\n        //find the max value of the subtree -> max of(max of left subtree,max of right subtree,root)\\n      currnode.max = max(root->val, max(l.max, r.max));\\n        \\n        //find the min value of the subtree -> min of(min of left subtree,min of right subtree,root)\\n      currnode.min = min(root->val, min(l.min, r.min));\\n        \\n        //we are keeping track of min and max value to finally check if currnode is bst or not from whole of its left and right subtree max and min respectively and for finding max and min value of whole subtree to use it for its parent.\\n        \\n        //if currnode is BST, we need to store its sum along with its min and max value from left and right subtree\\n        if(currnode.isbst){\\n          currnode.sum = l.sum + r.sum + root->val;\\n          currnode.min = min(root->val, min(l.min, r.min));\\n          currnode.max = max(root->val, max(l.max, r.max));\\n      }\\n        \\n        //if not a BST , then see in left subtree which stores max sum of BST in l.sum and right subtree which stores max sum of BST in r.sum and update current sum with that.\\n      else\\n          currnode.sum = max(l.sum, r.sum);\\n        \\n     //now my currnode , whether or not its a BST, contains the sum of BST ,either be it from its left subtree or its right subtree\\n      \\n        //check if its greater than max sum and store the ans\\n      res = max(res, currnode.sum);\\n        \\n      return currnode;\\n        \\n    }\\n    int res = INT_MIN;\\n    int maxSumBST(TreeNode* root) {\\n        Bst(root);\\n        return res > 0 ? res : 0;\\n    }\\n};\\n```\\n\\nIf you like the solution do give it an upvote! Thanks",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    struct bst{\\n         bool isbst;\\n      int max;\\n      int min;\\n      int sum;\\n    };\\n    \\n    bst Bst(TreeNode* root)\\n    {\\n        //we are at end of tree where node->left or node->right==nullprt\\n        //if we find a nullptr, we initialize a newbst to compare it with nodes above\\n       if(root==nullptr)\\n       {\\n        bst newbst;           \\n        newbst.isbst = true;\\n        newbst.max = INT_MIN;\\n        newbst.min = INT_MAX;\\n        newbst.sum = 0;\\n        return newbst;\\n       }\\n        \\n       //postorder traversal\\n      bst l = Bst(root->left); // left sub-tree\\n      bst r = Bst(root->right); // right sub-tree\\n        \\n        //our current node to check\\n        bst currnode;\\n        \\n        //check if its a bst\\n        \\n        //conditions->its left and right subrees must be a BST\\n        //->current node value > than max value of left subtree and <min value in right subtree\\n        currnode.isbst= l.isbst && r.isbst && (l.max < root->val && r.min > root->val);\\n        \\n        //find the max value of the subtree -> max of(max of left subtree,max of right subtree,root)\\n      currnode.max = max(root->val, max(l.max, r.max));\\n        \\n        //find the min value of the subtree -> min of(min of left subtree,min of right subtree,root)\\n      currnode.min = min(root->val, min(l.min, r.min));\\n        \\n        //we are keeping track of min and max value to finally check if currnode is bst or not from whole of its left and right subtree max and min respectively and for finding max and min value of whole subtree to use it for its parent.\\n        \\n        //if currnode is BST, we need to store its sum along with its min and max value from left and right subtree\\n        if(currnode.isbst){\\n          currnode.sum = l.sum + r.sum + root->val;\\n          currnode.min = min(root->val, min(l.min, r.min));\\n          currnode.max = max(root->val, max(l.max, r.max));\\n      }\\n        \\n        //if not a BST , then see in left subtree which stores max sum of BST in l.sum and right subtree which stores max sum of BST in r.sum and update current sum with that.\\n      else\\n          currnode.sum = max(l.sum, r.sum);\\n        \\n     //now my currnode , whether or not its a BST, contains the sum of BST ,either be it from its left subtree or its right subtree\\n      \\n        //check if its greater than max sum and store the ans\\n      res = max(res, currnode.sum);\\n        \\n      return currnode;\\n        \\n    }\\n    int res = INT_MIN;\\n    int maxSumBST(TreeNode* root) {\\n        Bst(root);\\n        return res > 0 ? res : 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2095948,
                "title": "java-solution",
                "content": "class Solution {\\n    class BSTtriplet{\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        boolean isBST = true;\\n        TreeNode lbstNode = null;\\n        int lbstSum =0;\\n    }\\n    \\n    int maxSum = Integer.MIN_VALUE;\\n    \\n    public BSTtriplet isBST(TreeNode node){\\n        if(node == null){\\n            return new BSTtriplet();\\n        }\\n        \\n        BSTtriplet lt = isBST(node.left);\\n        BSTtriplet rt = isBST(node.right);\\n        \\n        BSTtriplet mt = new BSTtriplet();\\n        mt.min = Math.min(node.val, Math.min(lt.min, rt.min));\\n        mt.max = Math.max(node.val, Math.max(lt.max, rt.max));\\n        \\n        boolean nodeIsBST = node.val>lt.max && node.val<rt.min;\\n        mt.isBST = (lt.isBST == true) && (rt.isBST == true) && (nodeIsBST == true);\\n        \\n        if(mt.isBST == true){\\n            mt.lbstNode = node;\\n            mt.lbstSum = lt.lbstSum + rt.lbstSum + node.val;\\n            if(mt.lbstSum > maxSum){\\n                maxSum = mt.lbstSum;\\n            }\\n        }else if(lt.lbstSum > rt.lbstSum){\\n            mt.lbstNode = lt.lbstNode;\\n            mt.lbstSum = lt.lbstSum;\\n        }else{\\n            mt.lbstNode = rt.lbstNode;\\n            mt.lbstSum = rt.lbstSum;\\n        }\\n        \\n        \\n        return mt;\\n        \\n    }\\n\\n    \\n    public int maxSumBST(TreeNode root) {\\n        \\n        \\n        \\n        BSTtriplet ans = new BSTtriplet();\\n        ans = isBST(root);\\n        \\n        return maxSum > 0 ? maxSum : 0 ;\\n        \\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    class BSTtriplet{\\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n        boolean isBST = true;\\n        TreeNode lbstNode = null;\\n        int lbstSum =0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2080814,
                "title": "java-wrapper-class",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        boolean isBst;\\n        int min, max, sum;\\n        Pair() {}\\n        Pair (boolean isBst, int min, int max, int sum) {\\n            this.isBst = isBst;\\n            this.min = min;\\n            this.max = max;\\n            this.sum = sum;\\n        }\\n    }\\n    \\n    int answer = Integer.MIN_VALUE;\\n    public int maxSumBST(TreeNode root) {\\n        findMax(root);\\n        return answer < 0 ? 0 : answer;\\n    }\\n    \\n    public Pair findMax(TreeNode root) {\\n        if (root == null) {\\n            return new Pair(true, Integer.MAX_VALUE, Integer.MIN_VALUE, 0);\\n        }\\n        Pair myPair = new Pair();\\n        Pair l = findMax(root.left);\\n        Pair r = findMax(root.right);\\n\\t\\t//  checking if the subtree with this root is BST or NOT\\n        myPair.isBst = l.isBst && r.isBst && (root.val > l.max && root.val < r.min);\\n        //  updating the max ans min\\n\\t\\tmyPair.min = Math.min(l.min, Math.min(root.val, r.min));\\n        myPair.max = Math.max(l.max, Math.max(root.val, r.max));\\n        myPair.sum = l.sum + r.sum + root.val;\\n        //  if isBst update the answer\\n\\t\\tif (myPair.isBst) {\\n            answer = Math.max(answer, myPair.sum);\\n        }\\n        return myPair;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    class Pair {\\n        boolean isBst;\\n        int min, max, sum;\\n        Pair() {}",
                "codeTag": "Java"
            },
            {
                "id": 2078677,
                "title": "most-simplest-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n\\t// We need to track three variables\\n\\t//1. Max value on the left aka lmax\\n\\t//2. Min value on the right aka rmin\\n\\t//3. Is left and right subtree a BST\\n\\t\\n    int ans = 0;\\n    int solve(TreeNode *root,int &minv,int &maxv,int &isbst)\\n    {\\n        if(!root)\\n        {\\n            maxv = INT_MIN,minv = INT_MAX,isbst=1;\\n            return 0;\\n        }\\n        \\n        int lmin,lmax,rmin,rmax,lbst,rbst;\\n        \\n        int lsum = solve(root->left,lmin,lmax,lbst);\\n        int rsum = solve(root->right,rmin,rmax,rbst);\\n        \\n        if(lmax<root->val and rmin>root->val and lbst and rbst)\\n        {\\n            isbst = 1;\\n            ans = max(ans,lsum + rsum + root->val);\\n        }\\n        else\\n            isbst = 0;\\n        minv = min(lmin,root->val);\\n        maxv = max(rmax,root->val);\\n        \\n        return lsum+rsum+root->val;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int min=INT_MIN,max=INT_MAX,isbst=1;\\n        solve(root,min,max,isbst);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// We need to track three variables\\n\\t//1. Max value on the left aka lmax\\n\\t//2. Min value on the right aka rmin\\n\\t//3. Is left and right subtree a BST\\n\\t\\n    int ans = 0;\\n    int solve(TreeNode *root,int &minv,int &maxv,int &isbst)\\n    {\\n        if(!root)\\n        {\\n            maxv = INT_MIN,minv = INT_MAX,isbst=1;\\n            return 0;\\n        }\\n        \\n        int lmin,lmax,rmin,rmax,lbst,rbst;\\n        \\n        int lsum = solve(root->left,lmin,lmax,lbst);\\n        int rsum = solve(root->right,rmin,rmax,rbst);\\n        \\n        if(lmax<root->val and rmin>root->val and lbst and rbst)\\n        {\\n            isbst = 1;\\n            ans = max(ans,lsum + rsum + root->val);\\n        }\\n        else\\n            isbst = 0;\\n        minv = min(lmin,root->val);\\n        maxv = max(rmax,root->val);\\n        \\n        return lsum+rsum+root->val;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int min=INT_MIN,max=INT_MAX,isbst=1;\\n        solve(root,min,max,isbst);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2078243,
                "title": "simple-and-easy-solution",
                "content": "```\\nclass NodeValue {\\n    public int maxNode, minNode, sum;\\n    \\n    public NodeValue(int minNode, int maxNode, int sum) {\\n        this.minNode = minNode;\\n        this.maxNode = maxNode;\\n        this.sum = sum;\\n    }\\n}\\n    \\nclass Solution {\\n    int maxSum = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        NodeValue obj = largestBSTSubtreeSum(root);\\n        return maxSum > 0 ? maxSum : 0;\\n    }\\n    \\n    private NodeValue largestBSTSubtreeSum(TreeNode root) {\\n        if (root == null) {\\n            return new NodeValue(Integer.MAX_VALUE, Integer.MIN_VALUE, 0);\\n        }\\n        \\n        // Get values from left & right subtree of current tree\\n        NodeValue left = largestBSTSubtreeSum(root.left);\\n        NodeValue right = largestBSTSubtreeSum(root.right);\\n        \\n        // Current node is greater than max in left & smaller than\\n        // min in right, it is a BST\\n        if (left.maxNode < root.val && root.val < right.minNode) {\\n            maxSum = Math.max(maxSum, root.val + left.sum + right.sum);\\n            return new NodeValue(Math.min(root.val, left.minNode), Math.max(root.val, right.maxNode), root.val + left.sum + right.sum);\\n        }\\n        \\n        // Otherwise return [-int, int] so that parent can\\'t be\\n        // valid BST\\n        return new NodeValue (Integer.MIN_VALUE, Integer.MAX_VALUE, Math.max(left.sum, right.sum));\\n    }    \\n}\\n// Please upvote if you  find this usefull.\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass NodeValue {\\n    public int maxNode, minNode, sum;\\n    \\n    public NodeValue(int minNode, int maxNode, int sum) {\\n        this.minNode = minNode;\\n        this.maxNode = maxNode;\\n        this.sum = sum;\\n    }\\n}\\n    \\nclass Solution {\\n    int maxSum = 0;\\n    \\n    public int maxSumBST(TreeNode root) {\\n        NodeValue obj = largestBSTSubtreeSum(root);\\n        return maxSum > 0 ? maxSum : 0;\\n    }\\n    \\n    private NodeValue largestBSTSubtreeSum(TreeNode root) {\\n        if (root == null) {\\n            return new NodeValue(Integer.MAX_VALUE, Integer.MIN_VALUE, 0);\\n        }\\n        \\n        // Get values from left & right subtree of current tree\\n        NodeValue left = largestBSTSubtreeSum(root.left);\\n        NodeValue right = largestBSTSubtreeSum(root.right);\\n        \\n        // Current node is greater than max in left & smaller than\\n        // min in right, it is a BST\\n        if (left.maxNode < root.val && root.val < right.minNode) {\\n            maxSum = Math.max(maxSum, root.val + left.sum + right.sum);\\n            return new NodeValue(Math.min(root.val, left.minNode), Math.max(root.val, right.maxNode), root.val + left.sum + right.sum);\\n        }\\n        \\n        // Otherwise return [-int, int] so that parent can\\'t be\\n        // valid BST\\n        return new NodeValue (Integer.MIN_VALUE, Integer.MAX_VALUE, Math.max(left.sum, right.sum));\\n    }    \\n}\\n// Please upvote if you  find this usefull.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2075167,
                "title": "python-postorder-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        self.val=0\\n        self.bst(root)\\n        return self.val\\n    def bst(self,root):\\n        if not root: return 0, inf ,-inf\\n        \\n        si1,minl1,maxl1=self.bst(root.left)\\n        si2,minl2,maxl2=self.bst(root.right)\\n        \\n        if maxl1<root.val<minl2:\\n            si=root.val+si1+si2\\n            self.val=max(self.val,si)\\n            return si,min(root.val,minl1),max(root.val,maxl2)\\n        return 0,-inf,inf\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        self.val=0\\n        self.bst(root)\\n        return self.val\\n    def bst(self,root):\\n        if not root: return 0, inf ,-inf\\n        \\n        si1,minl1,maxl1=self.bst(root.left)\\n        si2,minl2,maxl2=self.bst(root.right)\\n        \\n        if maxl1<root.val<minl2:\\n            si=root.val+si1+si2\\n            self.val=max(self.val,si)\\n            return si,min(root.val,minl1),max(root.val,maxl2)\\n        return 0,-inf,inf\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067322,
                "title": "c-solution-using-struct-inside-a-class",
                "content": "```\\n//will be using struct inside class to solve this question\\nclass Solution {\\npublic:\\n    //this struct will contain subtree\\'s min and max value , sum of left and right subtrees ,\\n\\t//ans that conatins sum of nodes of largest bst formed yet \\n\\t//and isBst conatins boolean value that whether the subtree is bst or not\\n    struct Info{\\n        int min;\\n        int max;\\n        int sum;\\n        int ans;\\n        bool isBst;\\n    };\\n    \\n    Info sol(TreeNode* root){\\n        if(!root)return {INT_MAX, INT_MIN,0,INT_MIN,true};//if root==NULL\\n        if(!root->left&&!root->right){\\n            return {root->val,root->val,root->val,root->val,true};//if leaf node\\n        }\\n        //recursive calls for left and right subtree\\n        Info left= sol(root->left);\\n        Info right= sol(root->right);\\n        \\n        \\n        Info cur; //for current info\\n        //checks condition whether cur node forms bst or not\\n        if(left.isBst && right.isBst && root->val>left.max&&root->val < right.min){\\n            cur.min= min(left.min,min(right.min,root->val));//for bst validation purpose\\n            cur.max= max(left.max, max(right.max,root->val));//for bst validation purpose\\n            \\n            cur.sum=left.sum+right.sum+root->val;//left part + right part+root value\\n            \\n            //either ans will be left.ans or right.ans or cur.sum\\n            if(left.sum==INT_MIN){//if left subtree is NULL\\n                cur.ans = max(left.ans,max(right.ans,right.sum+root->val));    \\n            }\\n            else if(right.sum==INT_MIN){//ifright subtree is NULL\\n                cur.ans = max(left.ans,max(right.ans,left.sum+root->val));    \\n            }\\n            else{\\n                cur.ans = max(left.ans,max(right.ans,cur.sum));    \\n            }\\n            \\n            cur.isBst=true;\\n            return cur;\\n        }\\n        cur.sum=left.sum+right.sum+root->val;//cur.sum is of no use now\\n        cur.ans= max(left.ans, right.ans);//only check max from left.ans and right.ans\\n        cur.isBst= false;//set bst to false\\n        return cur;\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        Info a= sol(root);\\n        if(a.ans<0)return 0;\\n        return a.ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//will be using struct inside class to solve this question\\nclass Solution {\\npublic:\\n    //this struct will contain subtree\\'s min and max value , sum of left and right subtrees ,\\n\\t//ans that conatins sum of nodes of largest bst formed yet \\n\\t//and isBst conatins boolean value that whether the subtree is bst or not\\n    struct Info{\\n        int min;\\n        int max;\\n        int sum;\\n        int ans;\\n        bool isBst;\\n    };\\n    \\n    Info sol(TreeNode* root){\\n        if(!root)return {INT_MAX, INT_MIN,0,INT_MIN,true};//if root==NULL\\n        if(!root->left&&!root->right){\\n            return {root->val,root->val,root->val,root->val,true};//if leaf node\\n        }\\n        //recursive calls for left and right subtree\\n        Info left= sol(root->left);\\n        Info right= sol(root->right);\\n        \\n        \\n        Info cur; //for current info\\n        //checks condition whether cur node forms bst or not\\n        if(left.isBst && right.isBst && root->val>left.max&&root->val < right.min){\\n            cur.min= min(left.min,min(right.min,root->val));//for bst validation purpose\\n            cur.max= max(left.max, max(right.max,root->val));//for bst validation purpose\\n            \\n            cur.sum=left.sum+right.sum+root->val;//left part + right part+root value\\n            \\n            //either ans will be left.ans or right.ans or cur.sum\\n            if(left.sum==INT_MIN){//if left subtree is NULL\\n                cur.ans = max(left.ans,max(right.ans,right.sum+root->val));    \\n            }\\n            else if(right.sum==INT_MIN){//ifright subtree is NULL\\n                cur.ans = max(left.ans,max(right.ans,left.sum+root->val));    \\n            }\\n            else{\\n                cur.ans = max(left.ans,max(right.ans,cur.sum));    \\n            }\\n            \\n            cur.isBst=true;\\n            return cur;\\n        }\\n        cur.sum=left.sum+right.sum+root->val;//cur.sum is of no use now\\n        cur.ans= max(left.ans, right.ans);//only check max from left.ans and right.ans\\n        cur.isBst= false;//set bst to false\\n        return cur;\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        Info a= sol(root);\\n        if(a.ans<0)return 0;\\n        return a.ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063925,
                "title": "c-recursive-o-n-no-custom-class",
                "content": "```\\n//Refernce and recursion overloaded\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maximumBSTSum = 0;\\n    \\n    bool isBST(TreeNode* root, int &minVal, int &maxVal, int &currentSum) {\\n        if(!root)return true;\\n        \\n        int leftSum = 0;\\n        int rightSum = 0;\\n        int minLeft = INT_MIN;\\n        int maxLeft = INT_MAX;\\n        int minRight = INT_MIN;\\n        int maxRight = INT_MAX;\\n        auto leftHalf = isBST(root->left, minLeft, maxLeft, leftSum);\\n        auto rightHalf = isBST(root->right, minRight, maxRight, rightSum);\\n        \\n        //cout<<minLeft<<\" \"<<maxLeft<<\" maxLR \"<<minRight<<\" \"<<maxRight<<endl;\\n        if(!root->left && !root->right){\\n            minVal = root->val;\\n            maxVal = root->val;\\n        }else if(!root->left) {\\n            if(minRight <= root->val)return false;\\n            minVal = root->val;\\n            maxVal = maxRight;\\n        }else if(!root->right){\\n            if(maxLeft >= root->val)return false;\\n            minVal = minLeft;\\n            maxVal = root->val;\\n        }else {\\n            if(minRight <= root->val || maxLeft >= root->val)return false;\\n            minVal = minLeft;\\n            maxVal = maxRight;\\n        }\\n        \\n        if(leftHalf&&rightHalf){\\n            currentSum += root->val+leftSum+rightSum;\\n        } else currentSum = 0;\\n        \\n        maximumBSTSum = max(maximumBSTSum, currentSum);\\n        \\n        return leftHalf && rightHalf;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        int currentSum = 0;\\n        int minVal = INT_MIN;\\n        int maxVal = INT_MAX;\\n        isBST(root, minVal, maxVal, currentSum);\\n        return maximumBSTSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n//Refernce and recursion overloaded\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maximumBSTSum = 0;\\n    \\n    bool isBST(TreeNode* root, int &minVal, int &maxVal, int &currentSum) {\\n        if(!root)return true;\\n        \\n        int leftSum = 0;\\n        int rightSum = 0;\\n        int minLeft = INT_MIN;\\n        int maxLeft = INT_MAX;\\n        int minRight = INT_MIN;\\n        int maxRight = INT_MAX;\\n        auto leftHalf = isBST(root->left, minLeft, maxLeft, leftSum);\\n        auto rightHalf = isBST(root->right, minRight, maxRight, rightSum);\\n        \\n        //cout<<minLeft<<\" \"<<maxLeft<<\" maxLR \"<<minRight<<\" \"<<maxRight<<endl;\\n        if(!root->left && !root->right){\\n            minVal = root->val;\\n            maxVal = root->val;\\n        }else if(!root->left) {\\n            if(minRight <= root->val)return false;\\n            minVal = root->val;\\n            maxVal = maxRight;\\n        }else if(!root->right){\\n            if(maxLeft >= root->val)return false;\\n            minVal = minLeft;\\n            maxVal = root->val;\\n        }else {\\n            if(minRight <= root->val || maxLeft >= root->val)return false;\\n            minVal = minLeft;\\n            maxVal = maxRight;\\n        }\\n        \\n        if(leftHalf&&rightHalf){\\n            currentSum += root->val+leftSum+rightSum;\\n        } else currentSum = 0;\\n        \\n        maximumBSTSum = max(maximumBSTSum, currentSum);\\n        \\n        return leftHalf && rightHalf;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        int currentSum = 0;\\n        int minVal = INT_MIN;\\n        int maxVal = INT_MAX;\\n        isBST(root, minVal, maxVal, currentSum);\\n        return maximumBSTSum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1974777,
                "title": "java-beats-71-recursive-o-n",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        Sum sum = new Sum();\\n        findLargestBST(root,sum);\\n       \\treturn sum.max;\\n\\t}\\n\\t\\n\\tpublic static Tuple findLargestBST(TreeNode root,Sum sum){\\n\\t\\tif(root==null) return new Tuple(0,Integer.MAX_VALUE,Integer.MIN_VALUE);\\n\\t\\tTuple left = findLargestBST(root.left,sum);\\n\\t\\tTuple right = findLargestBST(root.right,sum);\\n\\t\\tif(left.max<root.val&&right.min>root.val){\\n            sum.max = Math.max(sum.max,left.sum+right.sum+root.val);\\n\\t\\t\\treturn new Tuple(left.sum+right.sum+root.val,Math.min(left.min,root.val),Math.max(root.val,right.max));\\n\\t\\t}\\n\\t\\treturn new Tuple(0,Integer.MIN_VALUE,Integer.MAX_VALUE);\\n\\t}\\n}\\n\\n\\n\\nclass Tuple{\\n    int sum;\\n\\tint min;\\n\\tint max;\\n\\tpublic Tuple(int sum,int min,int max){\\n\\t\\tthis.sum = sum;\\n\\t\\tthis.min = min;\\n\\t\\tthis.max = max;\\n\\t}\\n}\\n\\nclass Sum{\\n    int max;\\n    public Sum(){}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        Sum sum = new Sum();\\n        findLargestBST(root,sum);\\n       \\treturn sum.max;\\n\\t}\\n\\t\\n\\tpublic static Tuple findLargestBST(TreeNode root,Sum sum){\\n\\t\\tif(root==null) return new Tuple(0,Integer.MAX_VALUE,Integer.MIN_VALUE);\\n\\t\\tTuple left = findLargestBST(root.left,sum);\\n\\t\\tTuple right = findLargestBST(root.right,sum);\\n\\t\\tif(left.max<root.val&&right.min>root.val){\\n            sum.max = Math.max(sum.max,left.sum+right.sum+root.val);\\n\\t\\t\\treturn new Tuple(left.sum+right.sum+root.val,Math.min(left.min,root.val),Math.max(root.val,right.max));\\n\\t\\t}\\n\\t\\treturn new Tuple(0,Integer.MIN_VALUE,Integer.MAX_VALUE);\\n\\t}\\n}\\n\\n\\n\\nclass Tuple{\\n    int sum;\\n\\tint min;\\n\\tint max;\\n\\tpublic Tuple(int sum,int min,int max){\\n\\t\\tthis.sum = sum;\\n\\t\\tthis.min = min;\\n\\t\\tthis.max = max;\\n\\t}\\n}\\n\\nclass Sum{\\n    int max;\\n    public Sum(){}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960238,
                "title": "python-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        \\n        def check(root):\\n            def validate(root,low=-math.inf,high=math.inf):\\n                if not root:\\n                    return\\n                if not low<root.val<high:\\n                    self.bst=False\\n                self.sm+=root.val\\n                validate(root.left,low,root.val)\\n                validate(root.right,root.val,high)\\n            \\n            self.bst=True\\n            self.sm=0\\n            validate(root)\\n            if self.bst==True:\\n                return self.sm\\n            return 0\\n        \\n        def dfs(root):\\n            if not root:\\n                return\\n            self.ans=max(self.ans,check(root))\\n            dfs(root.left)\\n            dfs(root.right)\\n        \\n        self.ans=0\\n        dfs(root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        \\n        def check(root):\\n            def validate(root,low=-math.inf,high=math.inf):\\n                if not root:\\n                    return\\n                if not low<root.val<high:\\n                    self.bst=False\\n                self.sm+=root.val\\n                validate(root.left,low,root.val)\\n                validate(root.right,root.val,high)\\n            \\n            self.bst=True\\n            self.sm=0\\n            validate(root)\\n            if self.bst==True:\\n                return self.sm\\n            return 0\\n        \\n        def dfs(root):\\n            if not root:\\n                return\\n            self.ans=max(self.ans,check(root))\\n            dfs(root.left)\\n            dfs(root.right)\\n        \\n        self.ans=0\\n        dfs(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957290,
                "title": "c-using-struct-dfs-clean-code-short-solution",
                "content": "```\\n */\\nclass Solution {\\npublic:\\n    \\n     struct s\\n     {\\n         bool isBST;\\n         int minv , maxv , sum;\\n     };\\n    // storing the maxe , mine for each node \\n    \\n    s func(TreeNode* root , int& res)\\n    {\\n        if(root==NULL)\\n        {\\n            return { true , INT_MAX , INT_MIN , 0};\\n        }\\n        \\n        \\n        s left_subtree=func(root->left , res);\\n        s right_subtree=func(root->right , res);\\n        \\n        if( left_subtree.isBST && right_subtree.isBST && root->val>left_subtree.maxv && root->val < right_subtree.minv)\\n        {\\n            int curr_sum= left_subtree.sum + right_subtree.sum + root->val;\\n            \\n            res=max(res , curr_sum);\\n            return {true , min(left_subtree.minv , root->val) , max(right_subtree.maxv , root->val) , curr_sum};\\n        }\\n        else\\n        {\\n            return {false , 0 , 0 , 0};\\n        }\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int res=0;\\n        func(root , res);\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n */\\nclass Solution {\\npublic:\\n    \\n     struct s\\n     {\\n         bool isBST;\\n         int minv , maxv , sum;\\n     };\\n    // storing the maxe , mine for each node \\n    \\n    s func(TreeNode* root , int& res)\\n    {\\n        if(root==NULL)\\n        {\\n            return { true , INT_MAX , INT_MIN , 0};\\n        }\\n        \\n        \\n        s left_subtree=func(root->left , res);\\n        s right_subtree=func(root->right , res);\\n        \\n        if( left_subtree.isBST && right_subtree.isBST && root->val>left_subtree.maxv && root->val < right_subtree.minv)\\n        {\\n            int curr_sum= left_subtree.sum + right_subtree.sum + root->val;\\n            \\n            res=max(res , curr_sum);\\n            return {true , min(left_subtree.minv , root->val) , max(right_subtree.maxv , root->val) , curr_sum};\\n        }\\n        else\\n        {\\n            return {false , 0 , 0 , 0};\\n        }\\n        \\n    }\\n    int maxSumBST(TreeNode* root) {\\n        int res=0;\\n        func(root , res);\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929601,
                "title": "java-post-order-traversal",
                "content": "```\\n\\tclass BSTInfo {\\n        int max;\\n        int min;\\n        int sum;\\n        \\n        public BSTInfo(int max, int min, int sum){\\n            this.max = max;\\n            this.min = min;\\n            this.sum = sum;\\n        }\\n    }\\n    \\n    int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n        maxSum = 0;\\n        getSum(root);\\n        return maxSum;\\n    }\\n    \\n    private BSTInfo getSum(TreeNode root){\\n        if(root == null) return new BSTInfo(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        \\n        BSTInfo left = getSum(root.left);\\n        BSTInfo right = getSum(root.right);\\n        \\n        // Check if tree from current node is BST or not (If BST only then we can use sum else its 0)\\n        boolean isBST = left != null && right != null && root.val > left.max && root.val < right.min;\\n        if(!isBST) return null;\\n        \\n        int maxCurrent = Math.max(root.val,right.max);\\n        int minCurrent = Math.min(root.val,left.min);\\n        int currSum = root.val + left.sum + right.sum;\\n        maxSum = Math.max(maxSum, currSum);\\n        \\n        return new BSTInfo(maxCurrent, minCurrent, currSum);\\n    }\\n```\\t",
                "solutionTags": [],
                "code": "```\\n\\tclass BSTInfo {\\n        int max;\\n        int min;\\n        int sum;\\n        \\n        public BSTInfo(int max, int min, int sum){\\n            this.max = max;\\n            this.min = min;\\n            this.sum = sum;\\n        }\\n    }\\n    \\n    int maxSum = 0;\\n    public int maxSumBST(TreeNode root) {\\n        if(root == null) return 0;\\n        maxSum = 0;\\n        getSum(root);\\n        return maxSum;\\n    }\\n    \\n    private BSTInfo getSum(TreeNode root){\\n        if(root == null) return new BSTInfo(Integer.MIN_VALUE,Integer.MAX_VALUE,0);\\n        \\n        BSTInfo left = getSum(root.left);\\n        BSTInfo right = getSum(root.right);\\n        \\n        // Check if tree from current node is BST or not (If BST only then we can use sum else its 0)\\n        boolean isBST = left != null && right != null && root.val > left.max && root.val < right.min;\\n        if(!isBST) return null;\\n        \\n        int maxCurrent = Math.max(root.val,right.max);\\n        int minCurrent = Math.min(root.val,left.min);\\n        int currSum = root.val + left.sum + right.sum;\\n        maxSum = Math.max(maxSum, currSum);\\n        \\n        return new BSTInfo(maxCurrent, minCurrent, currSum);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809776,
                "title": "dp-on-trees",
                "content": "**Short Code often takes BIG BRAINS!!**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int ans;\\npublic:\\n    vector<int> isBST(TreeNode* root){\\n        if(!root)return {INT_MAX, INT_MIN, 1, 0};   //{minval, maxval, isBST, sumOfNodesInBST}\\n        vector<int> l = isBST(root->left);\\n        vector<int> r = isBST(root->right);\\n        vector<int> rt = {min({root->val,l[0],r[0]}),max({root->val,l[1],r[1]}),(root->val>l[1] and root->val<r[0] and l[2] and r[2])?1:0,root->val+l[3]+r[3]};\\n        if(rt[2])ans=max(ans,rt[3]);\\n        return rt;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        isBST(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    int ans;\\npublic:\\n    vector<int> isBST(TreeNode* root){\\n        if(!root)return {INT_MAX, INT_MIN, 1, 0};   //{minval, maxval, isBST, sumOfNodesInBST}\\n        vector<int> l = isBST(root->left);\\n        vector<int> r = isBST(root->right);\\n        vector<int> rt = {min({root->val,l[0],r[0]}),max({root->val,l[1],r[1]}),(root->val>l[1] and root->val<r[0] and l[2] and r[2])?1:0,root->val+l[3]+r[3]};\\n        if(rt[2])ans=max(ans,rt[3]);\\n        return rt;\\n    }\\n    int maxSumBST(TreeNode* root) {\\n        ans=0;\\n        isBST(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1798932,
                "title": "java-post-order-traversal-clean-code",
                "content": "Please upvote, if you find it useful :)\\n\\n```\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        isBST temp = checkBST(root);\\n        \\n        return temp.maxSum < 0 ? 0 : temp.maxSum;\\n    }\\n    \\n    public class isBST {\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        boolean isBST = true;\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n    }\\n    \\n    public isBST checkBST(TreeNode root) {\\n        if(root == null) {\\n            return new isBST();\\n        }\\n        \\n        isBST lp = checkBST(root.left);\\n        isBST rp = checkBST(root.right);\\n        \\n        isBST mp = new isBST();\\n        mp.max = Math.max(root.val, Math.max(lp.max, rp.max));\\n        mp.min = Math.min(root.val, Math.min(lp.min, rp.min));\\n        mp.sum = lp.sum + rp.sum + root.val;\\n        \\n        boolean check = root.val > lp.max && root.val < rp.min;\\n        if(lp.isBST && rp.isBST && check) {\\n            mp.isBST = true;\\n            \\n            int tempMax = Math.max(mp.sum, Math.max(lp.sum, rp.sum));\\n            mp.maxSum = Math.max(tempMax, Math.max(lp.maxSum, rp.maxSum));\\n            \\n        } else {\\n            mp.isBST = false;\\n            mp.maxSum = Math.max(lp.maxSum, rp.maxSum);\\n        }\\n        return mp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int maxSumBST(TreeNode root) {\\n        isBST temp = checkBST(root);\\n        \\n        return temp.maxSum < 0 ? 0 : temp.maxSum;\\n    }\\n    \\n    public class isBST {\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        boolean isBST = true;\\n        int sum = 0;\\n        int maxSum = Integer.MIN_VALUE;\\n    }\\n    \\n    public isBST checkBST(TreeNode root) {\\n        if(root == null) {\\n            return new isBST();\\n        }\\n        \\n        isBST lp = checkBST(root.left);\\n        isBST rp = checkBST(root.right);\\n        \\n        isBST mp = new isBST();\\n        mp.max = Math.max(root.val, Math.max(lp.max, rp.max));\\n        mp.min = Math.min(root.val, Math.min(lp.min, rp.min));\\n        mp.sum = lp.sum + rp.sum + root.val;\\n        \\n        boolean check = root.val > lp.max && root.val < rp.min;\\n        if(lp.isBST && rp.isBST && check) {\\n            mp.isBST = true;\\n            \\n            int tempMax = Math.max(mp.sum, Math.max(lp.sum, rp.sum));\\n            mp.maxSum = Math.max(tempMax, Math.max(lp.maxSum, rp.maxSum));\\n            \\n        } else {\\n            mp.isBST = false;\\n            mp.maxSum = Math.max(lp.maxSum, rp.maxSum);\\n        }\\n        return mp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1783868,
                "title": "dfs-o-n-recursion-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Sol{\\n        \\n   public:\\n    int mn, mx, sum;\\n    Sol(int mn_, int mx_, int sum_){\\n        mn = mn_;\\n        mx = mx_;\\n        sum = sum_;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    \\n    Sol findAns(TreeNode * root){\\n       if(root==NULL) {\\n           return Sol(INT_MAX, INT_MIN, 0);\\n       }\\n       int x = root->val;\\n       Sol l = findAns(root->left);\\n        Sol r = findAns(root->right);\\n        if(l.mx < x and x< r.mn){\\n            if(root->left!=NULL and root->right!=NULL){ // has both children\\n                ans = max(ans, l.sum+r.sum+x);\\n                return Sol(l.mn, r.mx, l.sum+r.sum+x);\\n            }\\n            else if(root->left!=NULL){ // has only left child\\n               ans = max(ans, l.sum+x);\\n                return Sol(l.mn, x, l.sum+x);\\n            }\\n            else if(root->right!=NULL){ // has only right child\\n               ans = max(ans, r.sum+x) ;\\n                return Sol(x, r.mx, r.sum+x);\\n            }\\n            else{ // no children present\\n                ans = max(ans, x);\\n                return Sol(x, x, x);\\n            }\\n        }\\n        else{\\n            return Sol(INT_MIN, INT_MAX, 0);\\n        }\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        findAns(root);\\n        return max(0, ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Sol{\\n        \\n   public:\\n    int mn, mx, sum;\\n    Sol(int mn_, int mx_, int sum_){\\n        mn = mn_;\\n        mx = mx_;\\n        sum = sum_;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = INT_MIN;\\n    \\n    Sol findAns(TreeNode * root){\\n       if(root==NULL) {\\n           return Sol(INT_MAX, INT_MIN, 0);\\n       }\\n       int x = root->val;\\n       Sol l = findAns(root->left);\\n        Sol r = findAns(root->right);\\n        if(l.mx < x and x< r.mn){\\n            if(root->left!=NULL and root->right!=NULL){ // has both children\\n                ans = max(ans, l.sum+r.sum+x);\\n                return Sol(l.mn, r.mx, l.sum+r.sum+x);\\n            }\\n            else if(root->left!=NULL){ // has only left child\\n               ans = max(ans, l.sum+x);\\n                return Sol(l.mn, x, l.sum+x);\\n            }\\n            else if(root->right!=NULL){ // has only right child\\n               ans = max(ans, r.sum+x) ;\\n                return Sol(x, r.mx, r.sum+x);\\n            }\\n            else{ // no children present\\n                ans = max(ans, x);\\n                return Sol(x, x, x);\\n            }\\n        }\\n        else{\\n            return Sol(INT_MIN, INT_MAX, 0);\\n        }\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        findAns(root);\\n        return max(0, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1704712,
                "title": "java-solution-o-n-easy",
                "content": "```\\nclass Solution {\\n    \\n    public class pair {  \\n        int max, min;   //max and min value of that TreeNode\\n        boolean isBST;   // whetherthe root is a bst or not\\n        int sum;   // here sum is the sum of  whole tre nodes\\n    }\\n    \\n    public pair BSTHelper(TreeNode root) {\\n        pair p = new pair();\\n        if(root == null) {\\n            p.max = Integer.MIN_VALUE;\\n            p.min = Integer.MAX_VALUE;\\n            p.isBST = true;\\n            p.sum = 0;\\n            return p;\\n        }\\n        \\n        pair left = BSTHelper(root.left);\\n        pair right = BSTHelper(root.right);\\n        p.max = Math.max(root.val, Math.max(left.max, right.max));\\n        p.min = Math.min(root.val, Math.min(left.min, right.min));\\n p.isBST = left.isBST && right.isBST && left.max < root.val && root.val < right.min;\\n        p.sum = root.val + left.sum + right.sum;\\n        \\n        if(p.isBST) {\\n          maxSum = Math.max(maxSum, p.sum);\\n        }\\n        return p;\\n    }\\n     \\n    int maxSum = 0;      // Final Answer\\n    public int maxSumBST(TreeNode root) {\\n        pair p = BSTHelper(root);\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public class pair {  \\n        int max, min;   //max and min value of that TreeNode\\n        boolean isBST;   // whetherthe root is a bst or not\\n        int sum;   // here sum is the sum of  whole tre nodes\\n    }\\n    \\n    public pair BSTHelper(TreeNode root) {\\n        pair p = new pair();\\n        if(root == null) {\\n            p.max = Integer.MIN_VALUE;\\n            p.min = Integer.MAX_VALUE;\\n            p.isBST = true;\\n            p.sum = 0;\\n            return p;\\n        }\\n        \\n        pair left = BSTHelper(root.left);\\n        pair right = BSTHelper(root.right);\\n        p.max = Math.max(root.val, Math.max(left.max, right.max));\\n        p.min = Math.min(root.val, Math.min(left.min, right.min));\\n p.isBST = left.isBST && right.isBST && left.max < root.val && root.val < right.min;\\n        p.sum = root.val + left.sum + right.sum;\\n        \\n        if(p.isBST) {\\n          maxSum = Math.max(maxSum, p.sum);\\n        }\\n        return p;\\n    }\\n     \\n    int maxSum = 0;      // Final Answer\\n    public int maxSumBST(TreeNode root) {\\n        pair p = BSTHelper(root);\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679699,
                "title": "python-very-easy-understand-postorder-solution-o-n",
                "content": "```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        maxSum = 0\\n        def traverse(root):\\n            nonlocal maxSum\\n            if not root:\\n                return float(\\'inf\\'), float(\\'-inf\\'), 0\\n            # \\n            left = traverse(root.left)\\n            right = traverse(root.right)\\n            if not left or not right:\\n                return \\n            leftMin, leftMax, leftSum = left[0], left[1], left[2]\\n            rightMin, rightMax, rightSum = right[0], right[1], right[2]\\n            if root.val > leftMax and root.val < rightMin:\\n                rootMax = max(rightMax, root.val)\\n                rootMin = min(leftMin, root.val)\\n                rootSum = leftSum + rightSum + root.val\\n                maxSum = max(maxSum, rootSum)\\n                return rootMin, rootMax, rootSum\\n        traverse(root)\\n        return maxSum\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxSumBST(self, root: Optional[TreeNode]) -> int:\\n        maxSum = 0\\n        def traverse(root):\\n            nonlocal maxSum\\n            if not root:\\n                return float(\\'inf\\'), float(\\'-inf\\'), 0\\n            # \\n            left = traverse(root.left)\\n            right = traverse(root.right)\\n            if not left or not right:\\n                return \\n            leftMin, leftMax, leftSum = left[0], left[1], left[2]\\n            rightMin, rightMax, rightSum = right[0], right[1], right[2]\\n            if root.val > leftMax and root.val < rightMin:\\n                rootMax = max(rightMax, root.val)\\n                rootMin = min(leftMin, root.val)\\n                rootSum = leftSum + rightSum + root.val\\n                maxSum = max(maxSum, rootSum)\\n                return rootMin, rootMax, rootSum\\n        traverse(root)\\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676003,
                "title": "postorder-one-pass",
                "content": "```\\nclass res{\\npublic:\\n    bool isbst;\\n    int mx;\\n    int mn;\\n    int sum;\\n    res(){\\n        isbst=true;\\n        mx=INT_MIN;\\n        mn=INT_MAX;\\n        sum = 0;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    res help(TreeNode* root){\\n        res r;\\n        if(!root) return r;\\n        res rl = help(root->left);\\n        res rr = help(root->right);\\n        if(rl.isbst && rr.isbst && root->val>rl.mx && root->val<rr.mn){\\n            r.mx = max(root->val,rr.mx);\\n            r.mn = min(rl.mn,root->val);\\n            r.sum = rl.sum+rr.sum+root->val;\\n            ans = max(ans,r.sum);\\n        }else{\\n            r.isbst = false;\\n        }\\n        return r;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        help(root);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass res{\\npublic:\\n    bool isbst;\\n    int mx;\\n    int mn;\\n    int sum;\\n    res(){\\n        isbst=true;\\n        mx=INT_MIN;\\n        mn=INT_MAX;\\n        sum = 0;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    res help(TreeNode* root){\\n        res r;\\n        if(!root) return r;\\n        res rl = help(root->left);\\n        res rr = help(root->right);\\n        if(rl.isbst && rr.isbst && root->val>rl.mx && root->val<rr.mn){\\n            r.mx = max(root->val,rr.mx);\\n            r.mn = min(rl.mn,root->val);\\n            r.sum = rl.sum+rr.sum+root->val;\\n            ans = max(ans,r.sum);\\n        }else{\\n            r.isbst = false;\\n        }\\n        return r;\\n    }\\n    \\n    int maxSumBST(TreeNode* root) {\\n        help(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652344,
                "title": "my-short-solution",
                "content": "```\\n\\n\\n// {bst, leftMax, rightMin, sum}\\n\\nclass Solution {\\n    const int min_val = -(40000+1);\\n    const int max_val = (40000+1);\\n    vector<int> process(TreeNode* root,int& ans){\\n        if(root==NULL){\\n            return {1, min_val, max_val, 0};\\n        }\\n        \\n        vector<int> left = process(root->left, ans);\\n        vector<int> right = process(root->right, ans);\\n        \\n        \\n        int leftMax = max({left[1], right[1], root->val});\\n        int rightMin = min({left[2], right[2], root->val});\\n        int sum = left[3] + right[3] + root->val;\\n        \\n        vector<int> cur = {0, leftMax, rightMin, sum};\\n                \\n        if(left[1]<root->val && right[2] > root->val && left[0] && right[0]){\\n            cur[0] = 1;\\n            ans = max(ans, sum);\\n        }\\n        \\n        return cur;\\n    }\\n    \\n    \\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        \\n        process(root, ans);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\n\\n// {bst, leftMax, rightMin, sum}\\n\\nclass Solution {\\n    const int min_val = -(40000+1);\\n    const int max_val = (40000+1);\\n    vector<int> process(TreeNode* root,int& ans){\\n        if(root==NULL){\\n            return {1, min_val, max_val, 0};\\n        }\\n        \\n        vector<int> left = process(root->left, ans);\\n        vector<int> right = process(root->right, ans);\\n        \\n        \\n        int leftMax = max({left[1], right[1], root->val});\\n        int rightMin = min({left[2], right[2], root->val});\\n        int sum = left[3] + right[3] + root->val;\\n        \\n        vector<int> cur = {0, leftMax, rightMin, sum};\\n                \\n        if(left[1]<root->val && right[2] > root->val && left[0] && right[0]){\\n            cur[0] = 1;\\n            ans = max(ans, sum);\\n        }\\n        \\n        return cur;\\n    }\\n    \\n    \\npublic:\\n    int maxSumBST(TreeNode* root) {\\n        int ans = 0;\\n        \\n        process(root, ans);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565055,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1574666,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1567548,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1576031,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1575892,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1575216,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1573657,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1567457,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1969753,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1576542,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1565055,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1574666,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1567548,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1576031,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1575892,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1575216,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1573657,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1567457,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1969753,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1576542,
                "content": [
                    {
                        "username": "purifier1990",
                        "content": "Example 3:\\n\\nInput: root = [-4,-2,-5]\\nOutput: 0\\nExplanation: All values are negatives. Return an empty BST.\\n\\nSo at least -2 itself is a valid BST, and this is not an empty BST, why 0?"
                    },
                    {
                        "username": "Divy_Jindal",
                        "content": "[@markmarincek](/markmarincek) This is shit logic...they should give that in description\\n"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The empty node is a valid BST, and its sum is 0, which is greater than -2."
                    },
                    {
                        "username": "jas_1994",
                        "content": "[1,null,10,-5,20]\\n\\nWhy the expected O/P is 25? Shouldn\\'t it be 26?"
                    },
                    {
                        "username": "markmarincek",
                        "content": "The root node is not a valid BST because ALL values on the right have to be larger than the node\\'s value, and in this case the subtree on the right includes -5, which is lower than 1."
                    },
                    {
                        "username": "lancewang",
                        "content": "BST Trees with negative numbers are not handled properly in OJ. Its max sum should not be 0."
                    },
                    {
                        "username": "LukeAlbertSimonssonHastings",
                        "content": "An empty tree is a subtree of all trees and its sum of nodes is zero. We also know that an empty tree is also a BST by definition."
                    },
                    {
                        "username": "echerkansky",
                        "content": "Can someone please explain why for this case: [1,null,10,-5,20] the answer is 25 and not 26? Isn\\'t the root a BST?"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "Because -5 is less than 1 but it is present in right subtree of 1. so its not a bst rooted at 1.\\n"
                    },
                    {
                        "username": "Charuthapa",
                        "content": "[1,null,10,-5,20]"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "\nBecause -5 is less than 1 but it is present in right subtree of 1. so its not a bst.\nBST is \n> The left SUBTREE of a node contains only nodes with keys lesser than the nodes key.\n> The right SUBTREE of a node contains only nodes with keys greater than the nodes key.\n>The left and right SUBTREE each must also be a binary search tree."
                    },
                    {
                        "username": "xjd001",
                        "content": "![image](https://assets.leetcode.com/users/images/b133e1a1-3fa1-4a72-8de7-d5284e065a02_1619909259.420757.jpeg)\\n\\n\\nMaybe I\\'m making it harder than it really needs to be but this problem had me worried sick for several days before I finally cracked it, albeit with a solution near the bottom in terms of time and space."
                    },
                    {
                        "username": "jhchoi",
                        "content": "I am wondering how a test case [4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] is possible.\\n\\n                 4\\n\\t\\t   8          n\\n\\t    6     1    9     n\\n\\t -5  4  n  n  n -3  n 10"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "[@PabloLION](/PabloLION) bro because subtree with root node 1 valid but overall sum of this bst is smaller than 14 "
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you build wrong treee bro"
                    },
                    {
                        "username": "PabloLION",
                        "content": "It's like this. But I don't know why the expected answer is 14. I can have 15 by picking the subtree [1, 4, 10].\n```plaintext\n               4               \n       8               n       \n   6       1                   \n 9   n   -5   4                 \nn n     n -3 n 10                \n```"
                    },
                    {
                        "username": "marson",
                        "content": "[0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\nIt expects 84.\\n\\nThe sub tree rooted at **13** is a valid BST and sums to 68. So there is 16 more to be 84.\\nI cant figure out why 13\\'s parent **8** and it\\'s left sub tree [1,-1,2,null,null,null,6] could contribute to the expected sum.\\nWhile (8+1+(-1)+2+6) indeed equals 16, [1,-1,2,null,null,null,6] is not a valid BST, so why? Could anyone explain it please?\\n\\n---- Update ----\\nAccording to the latest comments, I\\'d like to elaborate my question: my initial motivation is based on description example#2. It says **[-4,-2,-5] is an empty tree**, so I was thinking negative nodes are invalid. However based on many peoples\\' comments, negative nodes are fine, then [1,-1,2,null,null,null,6] is valid. So this question becomes to clarifying the definition of empty tree. What\\'s the difference between [-4,-2,-5] and [1,-1,2,null,null,null,6]?\\n\\n![image](https://assets.leetcode.com/users/marson/image_1583600636.png)\\n"
                    },
                    {
                        "username": "infinity_91",
                        "content": "Failing on test case 58/59 , which is a very large test case (not allowing to paste here). If anyone faced failure on the same test case, please help me out as it\\'s impossible to figure out why"
                    },
                    {
                        "username": "Code_Breaker5521",
                        "content": "![image](https://assets.leetcode.com/users/images/3892a7d0-45d5-441d-a34b-34029b6345d7_1648045230.395054.png)\\n\\n![image](https://assets.leetcode.com/users/images/3264ac7b-c2ec-49da-b760-055147d4607d_1648045275.604121.png)\\nPlease Upvote if you get any help from this post and also if you have any doubt then let me know in the Comments.\\nThank You !!!"
                    }
                ]
            },
            {
                "id": 1573937,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1573509,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1569850,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 2051987,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1985465,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1953347,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1947743,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1903855,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1882435,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            },
            {
                "id": 1846339,
                "content": [
                    {
                        "username": "leetcode0613",
                        "content": "[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10] \\nwhy not the answer as 9? 1->-5->-3 are still in bst format"
                    },
                    {
                        "username": "stonov",
                        "content": "4->10 is also a BST and the sum of all of its keys is larger than the sum of the keys of the BST tree rooted at 1."
                    },
                    {
                        "username": "codedayday",
                        "content": "Example:\\nInput: [0,9,-8,6,-6,9,3,-5,1,7,1,0,null,-6,null,-4,1,null,3,2,null,null,null,null,null,null,null,null,null,null,null,4,null,10,8,null,null,null,null,1,13,-1,2,10,16,null,null,null,6,null,12,null,17]\\noutput: 84\\n\\n![image](https://assets.leetcode.com/users/codedayday/image_1583860901.png)\\n\\n\\n\\nWhy?\\nAs some friend asked in: \\nhttps://leetcode.com/problems/maximum-sum-bst-in-binary-tree/discuss/531926/Why-does-this-test-case-expect-84-(with-picture)\\n\\nTo better illustrate my point with figure, I write a new post here.\\nThis also give me some headache. However, after some research. I realized there are few things need to be clarified here:\\n1)  If we simply check:  [1,-1,2], this is a valid BST itself for sure. \\n2) But wait a minute,  what is the definition of a subtree? \\n    By definition of wikipedia [1] : A subtree of a tree T is a tree consisting of a node in T and all of its descendants in T\\n\\t\\n\\tSo this means that after you remove the subtree, the remains should to be a single tree (can be empty), instead of several trees or a forest.\\n\\t\\n3) So when you check the thing in 1) in the larger tree, you can tell [1,-1, 2, null, null, null, 6] is a subtree. [1, -1, 2] is not. In another words, the nodes within red circle is not a subtree. The nodes within the green circles are all valid subtrees. And the bigger green circles are the desired subtree.\\n By excluding \\'6\\' out, you simply violate the principle behind the beautiful recursion law and thus you can expect the bug either appear in our code or our mind.\\n\\nReference:\\n[1] https://en.wikipedia.org/wiki/Tree_(data_structure)\\n"
                    },
                    {
                        "username": "pjcougz",
                        "content": "Can someone explain to me why the answer for any of the examples make sense?\\n\\n*My rationale for believing the examples are wrong:*\\nExample 1 should be the sum of the entire tree, as all values are >= 0.\\nExample 2 should be the sum of the entire tree, as all values are >= 0.\\nExample 3 should be the maximum value, as all values are <= 0. It shouldn\\'t matter if they\\'re negative because there is still a maximum sub tree.\\nExample 4 does as expected, but the logic differs from Example 1, Example 2, and Example 5.\\nExample 5 should be the sum of the entire tree, as all values are >= 0."
                    },
                    {
                        "username": "Ross_Stark",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root,map<TreeNode*,pair<pair<int,int>,int>> &mp)\\n    {\\n       if(root==NULL)return;\\n       \\n       solve(root->left,mp);\\n       solve(root->right,mp);\\n       cout<<root->val<<\" \";\\n       if(root->right==NULL&&root->left==NULL)\\n       {\\n           mp[root].second=root->val;\\n           mp[root].first.first=root->val;\\n           mp[root].first.second=root->val;\\n       }\\n       else if(root->right!=NULL&&root->left!=NULL)\\n       {\\n           if(root->val>=mp[root->left].first.second&&root->val<=mp[root->right].first.first)\\n           {\\n             mp[root].second=mp[root->left].second+mp[root->right].second+root->val;\\n             mp[root].first.first=mp[root->left].first.first;\\n             mp[root].first.second=mp[root->right].first.second;\\n           }\\n           else\\n           {\\n               mp[root].second=max(mp[root->left].second,mp[root->right].second);\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n           }\\n       }\\n       else if(root->left==NULL)\\n       {\\n          if(root->val<=mp[root->right].first.first)\\n          {\\n              mp[root].second=mp[root->right].second+root->val;\\n              mp[root].first.first=INT_MAX;\\n              mp[root].first.second=mp[root->right].first.second;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->right].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n       else\\n       {\\n          if(root->val>=mp[root->left].first.second)\\n          {\\n              mp[root].second=mp[root->left].second+root->val;\\n              mp[root].first.first=mp[root->left].first.first;\\n              mp[root].first.second=INT_MIN;\\n          }\\n          else\\n          {\\n               mp[root].second=mp[root->left].second;\\n               mp[root].first.first=INT_MIN;\\n               mp[root].first.second=INT_MAX;\\n          }\\n       }\\n\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        if(root==NULL)return ans;\\n        map<TreeNode*,pair<pair<int,int>,int>> mp;\\n        solve(root,mp);\\n        for(auto it:mp)\\n        {\\n            ans=max(it.second.second,ans);\\n        }\\n        return  ans;\\n\\n    }\\n};\\n\\n\\ncan anyone tell me whats wrong here."
                    },
                    {
                        "username": "deepanshuyadav875",
                        "content": "what is the correct ans for this test case?\\n`[4,8,null,6,1,9,null,-5,4,null,null,null,-3,null,10]`\\nexpected it is showing -> 14.\\nI am not able to find that why it\\'s 14.\\ncan someone help in this?\\n"
                    },
                    {
                        "username": "tifv",
                        "content": "There are two maximal (by node set) BST subtrees: the one starting with node `1` and the one starting with node `9`. The sums of those trees are 7 and 9, respectively. However, the subtree starting with `1` has a subsubtree with a greater sum: namely, subtree starting with `4` has a sum of 14. This is the maximum sum of a BST subtree in this tree."
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Is a node by itself not a valid BST? How?"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Yes, it is. Unless it has value positive."
                    },
                    {
                        "username": "IamSinha27",
                        "content": "I have been trying this question for a while now. My code has passed 57/59 test cases, can someone please lemme know where I am going wrong with my logic. I\\'ll be grateful.   \\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool isLeaf(TreeNode *node)\\n    {\\n        if(!node->left && !node->right)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n\\n    pair<bool,int> maxSumHelper(TreeNode *root, int &maxSum)\\n    {\\n        if(isLeaf(root))\\n        {\\n            maxSum=max(maxSum,root->val);\\n            return {true,root->val};\\n        }\\n\\n        pair<bool,int>leftAns={};\\n        pair<bool,int>rightAns={};\\n        \\n        if(root->left!=NULL)\\n        {\\n            leftAns=maxSumHelper(root->left, maxSum);\\n        }\\n        else\\n        {\\n            leftAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->right!=NULL)\\n        {\\n            rightAns=maxSumHelper(root->right, maxSum);\\n        }\\n        else\\n        {\\n            rightAns={true,0};\\n            maxSum=max(maxSum,0);\\n\\n        }\\n\\n        if(root->left!=NULL && root->right!=NULL)\\n        {\\n\\n           if(leftAns.first==true && rightAns.first==true && root->val>root->left->val && root->val<root->right->val)\\n           {\\n             maxSum=max(maxSum,leftAns.second+rightAns.second+root->val);\\n            return {true,leftAns.second+rightAns.second+root->val};\\n           }\\n           else\\n           {\\n               return {false,0};\\n           }\\n        }\\n\\n        else if(root->left==NULL)\\n        {\\n            if(leftAns.first==true && rightAns.first==true && root->right->val>root->val)\\n            {\\n                maxSum=max(maxSum,rightAns.second+root->val);\\n                return {true, rightAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        }\\n\\n        \\n        \\n            if(rightAns.first==true && leftAns.first==true && root->left->val<root->val)\\n            {\\n                maxSum=max(maxSum,leftAns.second+root->val);\\n                return {true, leftAns.second+root->val};\\n            }\\n            else\\n            {\\n                return {false,0};\\n            }\\n        \\n\\n\\n    }\\n\\n\\n    int maxSumBST(TreeNode* root) {\\n        \\n      if(root==NULL)\\n      {\\n          return 0;\\n      }\\n\\n      int maxSum=0;\\n\\n      maxSumHelper(root,maxSum);\\n       return maxSum;\\n\\n\\n        \\n        \\n        \\n    }\\n};"
                    },
                    {
                        "username": "Vivek120303",
                        "content": "Hey, could you plz, help me debug my code. I dont why this is going for TLE. Passed 58/59 cases.\\n\\nclass Solution {\\npublic:\\n    int totalSum(TreeNode* node, int &ans){\\n        if(!node) return 0;\\n\\n        int lsum=totalSum(node->left,ans);\\n        int rsum=totalSum(node->right,ans);\\n        ans=max(ans, max(lsum,rsum));\\n\\n        int sum=node->val + lsum + rsum;\\n        ans=max(ans,sum);\\n        return sum;\\n    }\\n\\n    bool isBST(TreeNode* node, int min_value, int max_value)\\n    {\\n        if(!node) return true;\\n\\n        if(node->val<=min_value || node->val>=max_value) return false;\\n\\n        return isBST(node->left,min_value,node->val) \\n                && isBST(node->right,node->val,max_value);\\n    }\\n\\n    void helper(TreeNode* node, int &ans)\\n    {\\n        if(!node) return;\\n\\n        if(isBST(node,INT_MIN,INT_MAX)){\\n            ans=max(ans,totalSum(node,ans));\\n            return;\\n        }\\n\\n        helper(node->left,ans);\\n        helper(node->right,ans);\\n    }\\n\\n    int maxSumBST(TreeNode* root) {\\n        int ans=0;\\n        helper(root,ans);\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "TTDLC",
                        "content": "why are we not directly using maxSum variable of user defined class ? why using global variable sum"
                    },
                    {
                        "username": "rxhul-jangid",
                        "content": "I have used more than three approaches for this question, But the output for all the test cases is 20. I don\\'t know what is wrong with this question. Did anybody experience the same issue?\\n "
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "more like replacing maxSize if we consider it with Largest BST in a Binary Tree"
                    }
                ]
            }
        ]
    },
    {
        "title": "Generate a String With Characters That Have Odd Counts",
        "question_content": "<p>Given an&nbsp;integer <code>n</code>, <em>return a string with <code>n</code>&nbsp;characters such that each character in such string occurs <strong>an odd number of times</strong></em>.</p>\n\n<p>The returned string must contain only lowercase English letters. If there are multiples valid strings, return <strong>any</strong> of them. &nbsp;</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 4\n<strong>Output:</strong> &quot;pppz&quot;\n<strong>Explanation:</strong> &quot;pppz&quot; is a valid string since the character &#39;p&#39; occurs three times and the character &#39;z&#39; occurs once. Note that there are many other valid strings such as &quot;ohhh&quot; and &quot;love&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 2\n<strong>Output:</strong> &quot;xy&quot;\n<strong>Explanation:</strong> &quot;xy&quot; is a valid string since the characters &#39;x&#39; and &#39;y&#39; occur once. Note that there are many other valid strings such as &quot;ag&quot; and &quot;ur&quot;.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 7\n<strong>Output:</strong> &quot;holasss&quot;\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 532520,
                "title": "java-c-python-one-lines",
                "content": "## **Explanation**\\nIf `n` is odd, we return `\"bbbb....b\"`.\\nIf `n` is even, we return `\"baaa...a\"`.\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Java:**\\n```java\\n    public String generateTheString(int n) {\\n        return \"b\" + \"ab\".substring(n % 2, 1 + n % 2).repeat(n - 1);\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    string generateTheString(int n) {\\n        return \"b\" + string(n - 1, \\'a\\' + n % 2);\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def generateTheString(self, n):\\n        return \\'b\\' + \\'ab\\'[n & 1] * (n - 1)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public String generateTheString(int n) {\\n        return \"b\" + \"ab\".substring(n % 2, 1 + n % 2).repeat(n - 1);\\n    }\\n```\n```cpp\\n    string generateTheString(int n) {\\n        return \"b\" + string(n - 1, \\'a\\' + n % 2);\\n    }\\n```\n```py\\n    def generateTheString(self, n):\\n        return \\'b\\' + \\'ab\\'[n & 1] * (n - 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 538947,
                "title": "java-100-speed-and-100-memory",
                "content": "Use a character array\\n\\n```\\npublic String generateTheString(int n) {\\n    char[] str = new char[n];\\n    Arrays.fill(str, \\'a\\');\\n    if(n%2==0) {\\n        str[0] = \\'b\\';\\n    }\\n    return new String(str);\\n}\\n\\n```\\n\\nI have created a video explaining the solution \\nhttps://www.youtube.com/watch?v=x61_G5le9jM",
                "solutionTags": [],
                "code": "```\\npublic String generateTheString(int n) {\\n    char[] str = new char[n];\\n    Arrays.fill(str, \\'a\\');\\n    if(n%2==0) {\\n        str[0] = \\'b\\';\\n    }\\n    return new String(str);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532907,
                "title": "python-easy",
                "content": "ALGORITHM: \\n1. If n is odd, return return a string of a.....a of length n\\n2. If b is even, return a string on (n-1) a and b (a.....ab)\\nRUNTIME COMPLEXITY: O(N)\\nSPACE COMPLEXITY: O(N)\\n\\n```\\nclass Solution(object):\\n    def generateTheString(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        if n % 2 == 1:\\n            return \\'a\\' * n\\n        else:\\n            return \\'a\\' * (n-1) + \\'b\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def generateTheString(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: str\\n        \"\"\"\\n        if n % 2 == 1:\\n            return \\'a\\' * n\\n        else:\\n            return \\'a\\' * (n-1) + \\'b\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543710,
                "title": "javascript-o-n-96-100",
                "content": "```\\nvar generateTheString = function(n) {\\n  return n % 2 === 0 ? `${\\'a\\'.repeat(n - 1)}b` : \\'a\\'.repeat(n);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateTheString = function(n) {\\n  return n % 2 === 0 ? `${\\'a\\'.repeat(n - 1)}b` : \\'a\\'.repeat(n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532474,
                "title": "c-simple-construction-one-line",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        return n % 2 ? string(n, \\'a\\') : string(n - 1, \\'a\\') + \\'b\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        return n % 2 ? string(n, \\'a\\') : string(n - 1, \\'a\\') + \\'b\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752772,
                "title": "c-easy-100-faster-simple-short",
                "content": "# 1374. Generate a String With Characters That Have Odd Counts\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Begginer Friendly Approach.\\n3. PLease Upvote if it Helps.\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\\n\\n[https://github.com/knockcat/Leetcode](http://)\\n\\n**0 ms || 100 % Solution**\\n![image](https://assets.leetcode.com/users/images/c3d451b6-b091-49d8-ad74-3bcc1a041a8d_1644239245.310297.png)\\n\\n**CODE**\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s;\\n\\n            if(n% 2 == 0)\\n            {\\n                for(int i = 0; i<n-1; ++i)\\n                    s.push_back(\\'a\\');\\n                s.push_back(\\'b\\');\\n            }\\n            else\\n            {\\n                for(int i = 0; i<n; ++i)\\n                    s.push_back(\\'a\\');\\n            }\\n           \\n            return s;\\n        // \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n1. Easy C++\\n2. Begginer Friendly Approach.\\n3. PLease Upvote if it Helps.\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s;\\n\\n            if(n% 2 == 0)\\n            {\\n                for(int i = 0; i<n-1; ++i)\\n                    s.push_back(\\'a\\');\\n                s.push_back(\\'b\\');\\n            }\\n            else\\n            {\\n                for(int i = 0; i<n; ++i)\\n                    s.push_back(\\'a\\');\\n            }\\n           \\n            return s;\\n        // \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560986,
                "title": "python-one-line-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef generateTheString(self, n: int) -> str:\\n\\treturn \"a\" * n if n % 2 else \"a\" * (n - 1) + \"b\"\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef generateTheString(self, n: int) -> str:\\n\\treturn \"a\" * n if n % 2 else \"a\" * (n - 1) + \"b\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 836918,
                "title": "java-0-ms-100-faster",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        int count = (n % 2 == 0) ? n - 1 : n;\\n        StringBuilder result  = new StringBuilder();\\n        \\n        for (int i = 0; i < count; i++){\\n            result.append(\\'a\\');\\n        }\\n        \\n        if( n % 2 == 0){\\n            result.append(\\'b\\');\\n        }\\n        return result.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n        int count = (n % 2 == 0) ? n - 1 : n;\\n        StringBuilder result  = new StringBuilder();\\n        \\n        for (int i = 0; i < count; i++){\\n            result.append(\\'a\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3459992,
                "title": "c-c-easy-and-fast-solution-beats-100-explained",
                "content": "# Intuition:First of all,we have to determine that the given number is odd or even.If the given number is odd,then we return a new string which contains only \\'a\\' n times.Otherwise we create a string with \\'a\\' n-1 times and one \\'b\\'.\\n![photo_2023-04-27_12-57-53.jpg](https://assets.leetcode.com/users/images/00387a28-78ff-4618-adf3-9064a3025da3_1682582431.708815.jpeg)\\n\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```C++ []\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s(n-1, \\'a\\');\\n        s += n%2==0? \\'b\\':\\'a\\';\\n        return s;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public string GenerateTheString(int n) {\\n       string s=s=new string(\\'a\\',n-1);\\n      s+=n%2==0? \\'b\\':\\'a\\';\\n      return s;\\n    }\\n}\\n```\\n![Vote.png](https://assets.leetcode.com/users/images/bac3988f-3b05-4f33-8058-c08600af7b9f_1682582443.352482.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s(n-1, \\'a\\');\\n        s += n%2==0? \\'b\\':\\'a\\';\\n        return s;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public string GenerateTheString(int n) {\\n       string s=s=new string(\\'a\\',n-1);\\n      s+=n%2==0? \\'b\\':\\'a\\';\\n      return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068473,
                "title": "java-clean-solution-100-speed-and-memory",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        var result = new char[n];\\n        Arrays.fill(result, \\'a\\');       \\n        if (n % 2 == 0) result[0] = \\'b\\';\\n        return new String(result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        var result = new char[n];\\n        Arrays.fill(result, \\'a\\');       \\n        if (n % 2 == 0) result[0] = \\'b\\';\\n        return new String(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782613,
                "title": "c-simplest-shortest-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res = \"\";\\n        if (n%2 == 0)\\n        {\\n            res += \\'b\\';\\n            n-=1;\\n        }\\n        for (int i=0;i < n;i++)\\n            res += \\'a\\';\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res = \"\";\\n        if (n%2 == 0)\\n        {\\n            res += \\'b\\';\\n            n-=1;\\n        }\\n        for (int i=0;i < n;i++)\\n            res += \\'a\\';\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532633,
                "title": "simple-javascript-o-n",
                "content": "if n is odd, every letter has to be an \\'a\\', else the last one is \\'b\\'\\n```\\nvar generateTheString = function(n) {\\n    let res=Array(n).fill(\\'a\\')\\n    if(!(n&1))\\n        res[n-1]=\\'b\\'\\n    return res.join(\\'\\')\\n};\\n```\\n**Complexity**\\nTime: O(n),  Space: O(n)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateTheString = function(n) {\\n    let res=Array(n).fill(\\'a\\')\\n    if(!(n&1))\\n        res[n-1]=\\'b\\'\\n    return res.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3069560,
                "title": "c-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n         string ans=\"\";\\n         if(n%2==0)\\n         {\\n             for(int i=0;i<n-1;i++)\\n             {\\n                   ans=ans+\\'x\\';\\n             }\\n             ans=ans+\\'y\\';\\n         }\\n         else\\n         {\\n             for(int i=0;i<n;i++)\\n             {\\n                 ans=ans+\\'x\\';\\n             }\\n         }\\n         return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n         string ans=\"\";\\n         if(n%2==0)\\n         {\\n             for(int i=0;i<n-1;i++)\\n             {\\n                   ans=ans+\\'x\\';\\n             }\\n             ans=ans+\\'y\\';\\n         }\\n         else\\n         {\\n             for(int i=0;i<n;i++)\\n             {\\n                 ans=ans+\\'x\\';\\n             }\\n         }\\n         return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945878,
                "title": "java-one-liner",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return \"baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\".substring(n%2,n+n%2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return \"baaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\".substring(n%2,n+n%2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 841084,
                "title": "3approaches-runtime-0ms-faster-than-100-00-eay-understanding-c",
                "content": "```\\n//1.\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string str=\"\";\\n        if(n%2==0){\\n            str.append(1,\\'a\\');\\n            str.append(n-1,\\'b\\');\\n        }\\n        else{\\n            str.append(n,\\'a\\');\\n        }\\n        return str;\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        int count = (n % 2 == 0) ? n - 1 : n;\\n        string result=\"\";\\n        \\n        for (int i = 0; i < count; i++){\\n            result+=\\'a\\';\\n        }\\n        \\n        if( n % 2 == 0){\\n            result+=\\'b\\';\\n        }\\n        return result;\\n    }\\n};\\n//3.\\nclass Solution {\\npublic:\\n        string generateTheString(int n) {\\n        return (n & 1) ? string(n, \\'a\\') : string(n - 1, \\'a\\') + string(1, \\'b\\');\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n//1.\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string str=\"\";\\n        if(n%2==0){\\n            str.append(1,\\'a\\');\\n            str.append(n-1,\\'b\\');\\n        }\\n        else{\\n            str.append(n,\\'a\\');\\n        }\\n        return str;\\n    }\\n};\\n//2.\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        int count = (n % 2 == 0) ? n - 1 : n;\\n        string result=\"\";\\n        \\n        for (int i = 0; i < count; i++){\\n            result+=\\'a\\';\\n        }\\n        \\n        if( n % 2 == 0){\\n            result+=\\'b\\';\\n        }\\n        return result;\\n    }\\n};\\n//3.\\nclass Solution {\\npublic:\\n        string generateTheString(int n) {\\n        return (n & 1) ? string(n, \\'a\\') : string(n - 1, \\'a\\') + string(1, \\'b\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533785,
                "title": "javascript-solution",
                "content": "```\\nlet generateTheString = function(n) {\\n    return n % 2 === 0 ? \\'a\\'.repeat(n - 1) + \\'b\\' : \\'a\\'.repeat(n)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet generateTheString = function(n) {\\n    return n % 2 === 0 ? \\'a\\'.repeat(n - 1) + \\'b\\' : \\'a\\'.repeat(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532477,
                "title": "java-straightforward",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        if(n % 2 == 0) {\\n            for(int i = 0; i < n - 1; i++) sb.append(\\'a\\');\\n            sb.append(\\'b\\');\\n        } else {\\n            for(int i = 0; i < n; i++) sb.append(\\'a\\');\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        if(n % 2 == 0) {\\n            for(int i = 0; i < n - 1; i++) sb.append(\\'a\\');\\n            sb.append(\\'b\\');\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1127849,
                "title": "simple-python-solution-faster-than-99-83",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 != 0:\\n            return \\'x\\'*n\\n        return (\\'x\\'*(n-1)) + \\'y\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 != 0:\\n            return \\'x\\'*n\\n        return (\\'x\\'*(n-1)) + \\'y\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620263,
                "title": "js-simple-solution-one-liner",
                "content": "Runtime: 48 ms, faster than 94.64%\\n\\n```\\nvar generateTheString = function(n) {\\n     \\n  return  n & 1  ? Array(n).fill(\\'a\\').join(\\'\\') : Array(n-1).fill(\\'a\\').join(\\'\\')  + \\'b\\';\\n   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateTheString = function(n) {\\n     \\n  return  n & 1  ? Array(n).fill(\\'a\\').join(\\'\\') : Array(n-1).fill(\\'a\\').join(\\'\\')  + \\'b\\';\\n   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 549921,
                "title": "100-100-super-easy-python3",
                "content": "```\\n        if n%2!=0: return \\'a\\'*n \\n        else: return \"a\"*(n-1)+\\'b\\'\\n```\\n\\nHaha, don\\'t facepalm :P",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        if n%2!=0: return \\'a\\'*n \\n        else: return \"a\"*(n-1)+\\'b\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2739948,
                "title": "c-easy-explained",
                "content": "#### 1. If n is Odd\\n#####          simply add a charecter n times in ans String\\n#### 2. If n is even\\n#####            add a charecter n-1 times and add another charecter 1 time in ans string\\n#### 3. Return ans String\\n\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";\\n        if(n%2==1)\\n        {\\n            for(int i=0;i<n;i++)\\n                ans+=\\'t\\';\\n        }\\n        else\\n        {\\n            for(int i=0;i<n-1;i++)\\n                ans+=\\'p\\';\\n            ans+=\\'t\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";\\n        if(n%2==1)\\n        {\\n            for(int i=0;i<n;i++)\\n                ans+=\\'t\\';\\n        }\\n        else\\n        {\\n            for(int i=0;i<n-1;i++)\\n                ans+=\\'p\\';\\n            ans+=\\'t\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685407,
                "title": "js-one-line-solution",
                "content": "```\\nvar generateTheString = function(n) {\\n    return n%2 ? new Array(n).fill(\\'a\\').join(\\'\\') : new Array(n - 1).fill(\\'a\\').join(\\'\\') + \\'b\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateTheString = function(n) {\\n    return n%2 ? new Array(n).fill(\\'a\\').join(\\'\\') : new Array(n - 1).fill(\\'a\\').join(\\'\\') + \\'b\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1463808,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        if (n%2 == 0){\\n            sb.append(\"a\".repeat(Math.max(0,n-1)));\\n            sb.append(\"b\");\\n        }\\n        else{\\n            sb.append(\"a\".repeat(Math.max(0, n)));\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb = new StringBuilder();\\n        if (n%2 == 0){\\n            sb.append(\"a\".repeat(Math.max(0,n-1)));\\n            sb.append(\"b\");\\n        }\\n        else{\\n            sb.append(\"a\".repeat(Math.max(0, n)));\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336105,
                "title": "java-solution-in-2-lines",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        String s = \"a\".repeat(n-1);\\n        return n % 2 == 0 ? s + \"b\" : s + \"a\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        String s = \"a\".repeat(n-1);\\n        return n % 2 == 0 ? s + \"b\" : s + \"a\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250676,
                "title": "simplest-c-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n)\\n    {\\n        string ans;\\n        if(n%2 == 0)\\n        {\\n            ans = \"a\";\\n            n--;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans += \"b\";\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**If you like the solution? Please upvote.....**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n)\\n    {\\n        string ans;\\n        if(n%2 == 0)\\n        {\\n            ans = \"a\";\\n            n--;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            ans += \"b\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 808501,
                "title": "cpp-faster-than-100-easy",
                "content": "A very simple approach, we check first if the number is either odd or even. If the number is odd, we simply loop n times and add \\'a\\' to the result string, else if the number n is even we subtract 1 to convert it into odd number and add a single character \\'b\\', and run the same loop to make the length of the result even.\\n\\n```\\n\\tConsider the following test case :-\\n\\t\\tn = 28;\\n\\t\\t\\t\\n\\t\\t\\t1. n%2 == 0, n = 27, s = \"b\";\\n\\t\\t\\t2. n = 27, s = \"ba\"\\n\\t\\t\\t3. n = 26, s = \"baa\"\\n\\t\\t\\t4. n = 25, s = \"baaa\".............\\n\\n\\t\\t\\ts = \"baaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\t\\t\\t\\n\\t\\t\\ts is returned.\\n\\t\\n```\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s {};\\n        if(n%2 == 0){\\n            n -= 1;\\n            s += \\'b\\';\\n        }\\n\\t\\twhile(n--){\\n                s += \\'a\\';\\n            }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\tConsider the following test case :-\\n\\t\\tn = 28;\\n\\t\\t\\t\\n\\t\\t\\t1. n%2 == 0, n = 27, s = \"b\";\\n\\t\\t\\t2. n = 27, s = \"ba\"\\n\\t\\t\\t3. n = 26, s = \"baa\"\\n\\t\\t\\t4. n = 25, s = \"baaa\".............\\n\\n\\t\\t\\ts = \"baaaaaaaaaaaaaaaaaaaaaaaaaaa\"\\n\\t\\t\\t\\n\\t\\t\\ts is returned.\\n\\t\\n```\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s {};\\n        if(n%2 == 0){\\n            n -= 1;\\n            s += \\'b\\';\\n        }\\n\\t\\twhile(n--){\\n                s += \\'a\\';\\n            }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740108,
                "title": "python3-one-liner",
                "content": "The code is self-explanatory. \\n```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return (\"a\" * (n-1) + \"b\" if n%2 == 0 else \"b\" * n)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return (\"a\" * (n-1) + \"b\" if n%2 == 0 else \"b\" * n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695361,
                "title": "faster-than-100-in-c-3-line-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n     string s(n,\\'a\\');\\n\\n        if(n%2==0)s[n-1]=\\'b\\';\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n     string s(n,\\'a\\');\\n\\n        if(n%2==0)s[n-1]=\\'b\\';\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532654,
                "title": "c-python3-construct-the-solution",
                "content": "Given an integer `n`, return a string of length `n` so that each character in the string occurs odd number of times.\\n\\n# Explanation\\n\\nJust consider two cases: `n % 2 = 0` and `n % 2 = 1`.\\n\\nIf `n % 2 = 0`, return 1 \"a\" and `n-1` \"b\"s.\\n\\nIf `n % 2 = 1`, return `n` \"a\"s.\\n\\n# C++ Solution\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans;\\n        if (n % 2 == 1) {\\n            for (int i = 0; i < n; i++)\\n                ans += \"a\";\\n        }\\n        else {\\n            ans += \"a\";\\n            for (int i = 1; i < n; i++)\\n                ans += \"b\";\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python3 Solution\\n\\n```python\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 == 1:\\n            return \"a\" * n\\n        else:\\n            return \"a\" + \"b\" * (n - 1)\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans;\\n        if (n % 2 == 1) {\\n            for (int i = 0; i < n; i++)\\n                ans += \"a\";\\n        }\\n        else {\\n            ans += \"a\";\\n            for (int i = 1; i < n; i++)\\n                ans += \"b\";\\n        }\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 == 1:\\n            return \"a\" * n\\n        else:\\n            return \"a\" + \"b\" * (n - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3678044,
                "title": "1374-generate-a-string-with-characters-that-have-odd-counts-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        String str = \"\";\\n     if(n%2==0){\\n         for(int i=1; i<=n;i++){\\n             if(i<=n-1){\\n                 str+=\"p\";\\n             }\\n             else{\\n                 str+=\"d\";\\n             }\\n         }\\n     }\\n     else{\\n         for(int i=1; i<=n;i++){\\n             if(i==n){\\n                 str+=\"u\";\\n             }\\n             else if(i==1){\\n                 str+=\"o\";\\n             }\\n             else{\\n                 str+=\"y\";\\n             }\\n         }\\n     }\\n     return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        String str = \"\";\\n     if(n%2==0){\\n         for(int i=1; i<=n;i++){\\n             if(i<=n-1){\\n                 str+=\"p\";\\n             }\\n             else{\\n                 str+=\"d\";\\n             }\\n         }\\n     }\\n     else{\\n         for(int i=1; i<=n;i++){\\n             if(i==n){\\n                 str+=\"u\";\\n             }\\n             else if(i==1){\\n                 str+=\"o\";\\n             }\\n             else{\\n                 str+=\"y\";\\n             }\\n         }\\n     }\\n     return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241465,
                "title": "one-liner-python3",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        \\n        return \\'a\\' * n if n % 2 != 0 else \\'a\\' * (n-1) + \\'b\\'\\n\\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        \\n        return \\'a\\' * n if n % 2 != 0 else \\'a\\' * (n-1) + \\'b\\'\\n\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857987,
                "title": "python-easy-94-60-faster-one-line-solution",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \\'a\\'*(n-1)+\\'b\\' if n%2==0 else \\'a\\'*n\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \\'a\\'*(n-1)+\\'b\\' if n%2==0 else \\'a\\'*n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857829,
                "title": "beats-99-easy-python-solution",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 == 0:\\n            return \"x\" * (n - 1) + \"y\"\\n        else:\\n            return \"x\" * n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 == 0:\\n            return \"x\" * (n - 1) + \"y\"\\n        else:\\n            return \"x\" * n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622490,
                "title": "python-o-1",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n == 1:\\n            return \\'a\\'\\n        elif n%2==0:\\n            return(\\'a\\' + \\'b\\'*(n-1))\\n        else:\\n            return(\\'ab\\' + \\'c\\'*(n-2))\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n == 1:\\n            return \\'a\\'\\n        elif n%2==0:\\n            return(\\'a\\' + \\'b\\'*(n-1))\\n        else:\\n            return(\\'ab\\' + \\'c\\'*(n-2))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839523,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans;\\n        if(n&1){\\n            ans.append(n,\\'a\\');\\n        }\\n        else{\\n            ans.append(1,\\'a\\');\\n            ans.append(n-1,\\'b\\');\\n           \\n        }\\n        return ans;\\n    }\\n};\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans;\\n        if(n&1){\\n            ans.append(n,\\'a\\');\\n        }\\n        else{\\n            ans.append(1,\\'a\\');\\n            ans.append(n-1,\\'b\\');\\n           \\n        }\\n        return ans;\\n    }\\n};\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1759755,
                "title": "java-1-liner-explained",
                "content": "**Idea:** If n is odd return any letter repeated n times, else return any letter repeated n - 1 (odd) times and append a different letter 1 time (odd)\\n>**T/S:** O(n)/O(n)\\n```\\npublic String generateTheString(int n) {\\n\\treturn \"a\".repeat(n - 1) + (char) (\\'b\\' - (n & 1));\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String generateTheString(int n) {\\n\\treturn \"a\".repeat(n - 1) + (char) (\\'b\\' - (n & 1));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1548114,
                "title": "go-time-o-n-0-ms-100-space-o-1-2-2-mb-100",
                "content": "```\\nfunc generateTheString(n int) string {\\n    return \"b\" + strings.Repeat(string(\\'a\\' + n % 2), n - 1)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc generateTheString(n int) string {\\n    return \"b\" + strings.Repeat(string(\\'a\\' + n % 2), n - 1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1442777,
                "title": "javascript-js",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar generateTheString = function (n) {\\n  const letterA = \"a\";\\n  const letterB = \"b\";\\n\\n  if (n % 2 !== 0) {\\n    return letterA.repeat(n);\\n  }\\n\\n  return letterA.repeat(n - 1) + letterB;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar generateTheString = function (n) {\\n  const letterA = \"a\";\\n  const letterB = \"b\";\\n\\n  if (n % 2 !== 0) {\\n    return letterA.repeat(n);\\n  }\\n\\n  return letterA.repeat(n - 1) + letterB;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1383113,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public String generateTheString(int n) {\\n        if(n%2==1)\\n        {\\n            String a=\"\";\\n            int i;\\n            for(i=1,a=\"\";i<=n;i++,a=a+\"a\");\\n            return a;\\n        }\\n        else\\n        {\\n            String a=\"\";\\n            int i;\\n            for(i=1,a=\"\";i<n;i++,a=a+\"a\");\\n            a=a+\"b\";\\n            return a;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public String generateTheString(int n) {\\n        if(n%2==1)\\n        {\\n            String a=\"\";\\n            int i;\\n            for(i=1,a=\"\";i<=n;i++,a=a+\"a\");\\n            return a;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1232027,
                "title": "easy-code-in-python-with-explanation",
                "content": "* here if n%2==0 i.e. if n is even we return a string with n-1 number of a and 1 b\\n* else we return n that is odd number of a.\\n* if you like it please vote so it can reach other pepoles too\\n\\n```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        a=\"a\"\\n        b=\"b\"\\n        if n%2==0:\\n            return (((n-1)*a)+b)\\n        return (n*a)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        a=\"a\"\\n        b=\"b\"\\n        if n%2==0:\\n            return (((n-1)*a)+b)\\n        return (n*a)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070127,
                "title": "java-stringbuilder-beats-100-0ms-o-n",
                "content": "\\n    public String generateTheString(int n) {\\n       StringBuilder sb = new StringBuilder();\\n\\t\\tif (n % 2 != 0) {\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tsb.append(\\'a\\');\\n\\t\\t} else {\\n\\t\\t\\tfor (int i = 0; i < n - 1; i++)\\n\\t\\t\\t\\tsb.append(\\'a\\');\\n\\t\\t\\tsb.append(\\'b\\');\\n\\t\\t}\\n\\t\\treturn sb.toString(); \\n    }\\n",
                "solutionTags": [],
                "code": "\\n    public String generateTheString(int n) {\\n       StringBuilder sb = new StringBuilder();\\n\\t\\tif (n % 2 != 0) {\\n\\t\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\t\\tsb.append(\\'a\\');\\n\\t\\t} else {\\n\\t\\t\\tfor (int i = 0; i < n - 1; i++)\\n\\t\\t\\t\\tsb.append(\\'a\\');\\n\\t\\t\\tsb.append(\\'b\\');\\n\\t\\t}\\n\\t\\treturn sb.toString(); \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 985739,
                "title": "0-ms-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        if(n%2!=0)\\n        {\\n            string res(n,\\'a\\');\\n            return res;\\n        }\\n        string res(n-1,\\'a\\');\\n        res+=\\'r\\';\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        if(n%2!=0)\\n        {\\n            string res(n,\\'a\\');\\n            return res;\\n        }\\n        string res(n-1,\\'a\\');\\n        res+=\\'r\\';\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923659,
                "title": "javascript-one-liner-solution",
                "content": "```js\\nvar generateTheString = function(n) {\\n    return (n%2 == 0)? \\'a\\'.repeat(n-1)+\\'b\\' : \\'a\\'.repeat(n)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar generateTheString = function(n) {\\n    return (n%2 == 0)? \\'a\\'.repeat(n-1)+\\'b\\' : \\'a\\'.repeat(n)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 915849,
                "title": "python-one-liner-lol",
                "content": "\\n        \\n        return \"a\"*(n-1)+\"b\" if n % 2 == 0 else \"a\"*n \\n",
                "solutionTags": [],
                "code": "\\n        \\n        return \"a\"*(n-1)+\"b\" if n % 2 == 0 else \"a\"*n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 859713,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public String generateTheString(int n) {\\n        \\n       StringBuilder res = new StringBuilder();\\n        \\n        for(int i=0; i<n-1; i++)\\n            res.append(\"a\");\\n        if(n%2 == 0)\\n            res.append(\"b\");\\n        else\\n            res.append(\"a\");\\n        \\n        return res.toString();\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n        \\n       StringBuilder res = new StringBuilder();\\n        \\n        for(int i=0; i<n-1; i++)\\n            res.append(\"a\");\\n        if(n%2 == 0)\\n            res.append(\"b\");\\n        else\\n            res.append(\"a\");\\n        \\n        return res.toString();\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 546878,
                "title": "javascript-easy-solution",
                "content": "```\\nvar generateTheString = function(n) {\\n    let result = \\'a\\'.repeat(n-1); // push \\'a\\' n-1 times\\n    return (n % 2 === 0) ? result + \\'b\\'  : result + \\'a\\';\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateTheString = function(n) {\\n    let result = \\'a\\'.repeat(n-1); // push \\'a\\' n-1 times\\n    return (n % 2 === 0) ? result + \\'b\\'  : result + \\'a\\';\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 534890,
                "title": "with-explaination-c-greedy-solution-easiest-solution-beats-100-in-both-memory-and-time",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string generateTheString(int n) \\n    {\\n         string s=\"abcdefghijklmnopqrstuvwxyz\";\\n        if(n<26)\\n          return s.substr(0,n);\\n   \\n         string res=\"\";\\n        if(n%2!=0)\\n        {\\n           for(int i=0;i<n;i++)\\n                  res+=\\'a\\';  \\n        }\\n        else\\n        {\\n            for(int i=0;i<(n-1);i++)\\n                  res+=\\'a\\';\\n            res+=\\'b\\';\\n        }\\n        return res;\\n    }\\n};\\n```\\nsimply see if n is odd then return string with only character a\\nif n is even then n-1 times a and 1 time b\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string generateTheString(int n) \\n    {\\n         string s=\"abcdefghijklmnopqrstuvwxyz\";\\n        if(n<26)\\n          return s.substr(0,n);\\n   \\n         string res=\"\";\\n        if(n%2!=0)\\n        {\\n           for(int i=0;i<n;i++)\\n                  res+=\\'a\\';  \\n        }\\n        else\\n        {\\n            for(int i=0;i<(n-1);i++)\\n                  res+=\\'a\\';\\n            res+=\\'b\\';\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532525,
                "title": "c-simple-strings",
                "content": "Straight forward approach\\nIf `n` is odd, we can directly return a string of all `a`. Otherwise just create `n` length string containing `n-1` `a`\\'s and one `b`.\\n\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        \\n        if(n % 2 == 1)\\n            return string(n, \\'a\\');\\n        string s = string(n - 1, \\'a\\');\\n        s.push_back(\\'b\\');\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        \\n        if(n % 2 == 1)\\n            return string(n, \\'a\\');\\n        string s = string(n - 1, \\'a\\');\\n        s.push_back(\\'b\\');\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874901,
                "title": "simple-code-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        res = \"\"\\n        if n%2 != 0:\\n            return \"a\"*n\\n        res = \"a\"*(n-1)\\n        return res+\"b\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        res = \"\"\\n        if n%2 != 0:\\n            return \"a\"*n\\n        res = \"a\"*(n-1)\\n        return res+\"b\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745207,
                "title": "easy-and-simple-solution-in-c-beats-100-runtime",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";\\n        if (n%2!=0)\\n        {\\n            for (int i=0; i<n; i++) ans+=\\'a\\';\\n        }\\n        else\\n        {\\n            for (int i=0; i<n-1; i++) ans+=\\'a\\';\\n            ans+=\\'b\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";\\n        if (n%2!=0)\\n        {\\n            for (int i=0; i<n; i++) ans+=\\'a\\';\\n        }\\n        else\\n        {\\n            for (int i=0; i<n-1; i++) ans+=\\'a\\';\\n            ans+=\\'b\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745191,
                "title": "easy-solution-in-c-0ms-runtime",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";\\n        if (n%2!=0)\\n        {\\n            for (int i=0; i<n; i++) ans+=\\'a\\';\\n        }\\n        else\\n        {\\n            for (int i=0; i<n-1; i++) ans+=\\'a\\';\\n            ans+=\\'b\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";\\n        if (n%2!=0)\\n        {\\n            for (int i=0; i<n; i++) ans+=\\'a\\';\\n        }\\n        else\\n        {\\n            for (int i=0; i<n-1; i++) ans+=\\'a\\';\\n            ans+=\\'b\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460316,
                "title": "go-and-javasctipt-one-line-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n## Go\\n```\\nfunc generateTheString(n int) string {\\n    s := strings.Repeat(\"a\", n-1)\\n    if n%2 == 0 {\\n        s += \"b\"\\n    } else {\\n        s += \"a\"\\n    }\\n    return s\\n}\\n\\n```\\n## Javascript\\n```\\nfunction generateTheString(n) {\\n  return \\'a\\'.repeat(n - 1) + (n % 2 ? \\'a\\' : \\'b\\');\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Go"
                ],
                "code": "```\\nfunc generateTheString(n int) string {\\n    s := strings.Repeat(\"a\", n-1)\\n    if n%2 == 0 {\\n        s += \"b\"\\n    } else {\\n        s += \"a\"\\n    }\\n    return s\\n}\\n\\n```\n```\\nfunction generateTheString(n) {\\n  return \\'a\\'.repeat(n - 1) + (n % 2 ? \\'a\\' : \\'b\\');\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3295968,
                "title": "beats-100",
                "content": "\\n# Code\\n```\\n\\nclass Solution\\n{\\n    public String generateTheString(int n)\\n    {\\n        StringBuilder s=new StringBuilder();\\n        if(n%2==0)\\n        {\\n            s.append(\"a\".repeat(n-1));\\n            s.append(\"d\");\\n        }\\n        else\\n        {\\n            s.append(\"a\".repeat(n));\\n        }\\n        return s.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution\\n{\\n    public String generateTheString(int n)\\n    {\\n        StringBuilder s=new StringBuilder();\\n        if(n%2==0)\\n        {\\n            s.append(\"a\".repeat(n-1));\\n            s.append(\"d\");\\n        }\\n        else\\n        {\\n            s.append(\"a\".repeat(n));\\n        }\\n        return s.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153642,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string result(n, \\'a\\');\\n        if (n % 2 == 0) result[0] = \\'b\\';\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string result(n, \\'a\\');\\n        if (n % 2 == 0) result[0] = \\'b\\';\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929560,
                "title": "fastest-c-solution",
                "content": "# Approach\\n**If n is odd, return a string of size n formed only by \\'a\\', else return string formed with (n-1) \\'a\\' and 1 \\'b\\'.**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n\\n       //declared an empty string ans \\n       string ans = \"\";\\n\\n       //FOR ODD LENGTH STRING\\n       if(n%2!=0) {\\n           while(n--){\\n               //return a string of size n formed only by \\'a\\'\\n               ans+=\\'a\\';\\n           }\\n       } \\n       //FOR EVEN LENGTH STRING\\n       else{\\n           int m=n-1;\\n           while(m--){\\n               //string formed with (n-1) \\'a\\'\\n               ans+=\\'a\\';\\n           }\\n           // string formed with  1 \\'b\\'\\n           ans+=\\'b\\';\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n\\n       //declared an empty string ans \\n       string ans = \"\";\\n\\n       //FOR ODD LENGTH STRING\\n       if(n%2!=0) {\\n           while(n--){\\n               //return a string of size n formed only by \\'a\\'\\n               ans+=\\'a\\';\\n           }\\n       } \\n       //FOR EVEN LENGTH STRING\\n       else{\\n           int m=n-1;\\n           while(m--){\\n               //string formed with (n-1) \\'a\\'\\n               ans+=\\'a\\';\\n           }\\n           // string formed with  1 \\'b\\'\\n           ans+=\\'b\\';\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924572,
                "title": "generate-a-string-with-characters-that-have-odd-counts-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuffer sb = new StringBuffer();\\n        if (n % 2 == 0) {\\n            sb.append(\\'a\\');\\n            for (int i = 1; i < n; i++)\\n                sb.append(\\'b\\');\\n        } else {\\n            for (int i = 0; i < n; i++)\\n                sb.append(\\'a\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuffer sb = new StringBuffer();\\n        if (n % 2 == 0) {\\n            sb.append(\\'a\\');\\n            for (int i = 1; i < n; i++)\\n                sb.append(\\'b\\');\\n        } else {\\n            for (int i = 0; i < n; i++)\\n                sb.append(\\'a\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919295,
                "title": "0ms-fastest-solution-for-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        \\nStringBuilder s = new StringBuilder();\\n\\n    if(n%2==0){\\n        s.append(\"t\".repeat(n-1));\\n        s.append(\"e\");\\n}else{\\n        s.append(\"t\".repeat(n));\\n}\\n\\nreturn s.toString();\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        \\nStringBuilder s = new StringBuilder();\\n\\n    if(n%2==0){\\n        s.append(\"t\".repeat(n-1));\\n        s.append(\"e\");\\n}else{\\n        s.append(\"t\".repeat(n));\\n}\\n\\nreturn s.toString();\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2919294,
                "title": "beats-100-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder res=new StringBuilder();\\n        if(n%2==1) {\\n            res.append(\"a\".repeat(n));\\n        }\\n        else {\\n            res.append(\"a\".repeat(n-1));\\n            res.append(\\'b\\');\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder res=new StringBuilder();\\n        if(n%2==1) {\\n            res.append(\"a\".repeat(n));\\n        }\\n        else {\\n            res.append(\"a\".repeat(n-1));\\n            res.append(\\'b\\');\\n        }\\n        return res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2867224,
                "title": "q1374-accepted-c-sol-o-n-100-fastest-easy-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2==1){\\n            while(n--){\\n                s+=\\'a\\';\\n            }\\n        }\\n        else{\\n            while(n--){\\n                if(n==0){\\n                    s+=\\'b\\';\\n                    break;\\n                }\\n                s+=\\'a\\';\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2==1){\\n            while(n--){\\n                s+=\\'a\\';\\n            }\\n        }\\n        else{\\n            while(n--){\\n                if(n==0){\\n                    s+=\\'b\\';\\n                    break;\\n                }\\n                s+=\\'a\\';\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792594,
                "title": "java-understandable-solution",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        String s=\"\";\\n        if(n%2!=0){\\n            for(int i=0;i<n;i++){\\n                s=s+\\'a\\';\\n            }\\n            return s;\\n        }\\n        \\n        for(int i=0;i<n-1;i++){\\n            s=s+\\'x\\';\\n        }\\n        int x=n-s.length();\\n        for(int i=0;i<x;i++){\\n            s=s+\\'y\\';\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        String s=\"\";\\n        if(n%2!=0){\\n            for(int i=0;i<n;i++){\\n                s=s+\\'a\\';\\n            }\\n            return s;\\n        }\\n        \\n        for(int i=0;i<n-1;i++){\\n            s=s+\\'x\\';\\n        }\\n        int x=n-s.length();\\n        for(int i=0;i<x;i++){\\n            s=s+\\'y\\';\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2685448,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] arr = new char[n];\\n        Arrays.fill(arr, \\'a\\');\\n        if(n % 2 == 1) return String.valueOf(arr);\\n        \\n        int oddN = n - 1;\\n        for(int i = 0; i < oddN; i++){\\n            arr[i] = \\'b\\';\\n        }\\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] arr = new char[n];\\n        Arrays.fill(arr, \\'a\\');\\n        if(n % 2 == 1) return String.valueOf(arr);\\n        \\n        int oddN = n - 1;\\n        for(int i = 0; i < oddN; i++){\\n            arr[i] = \\'b\\';\\n        }\\n        return String.valueOf(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654837,
                "title": "java-simple-easy-solution",
                "content": "class Solution {\\n    public String generateTheString(int n) {\\n     String str=\"\";\\n      if(n%2==0){\\n          for(int i=0;i<n-1;i++)\\n            str+=\\'a\\';\\n          str+=\\'b\\';\\n      }\\n    else{\\n        for(int i=0;i<n;i++)\\n            str+=\\'a\\';\\n    }\\n        return str;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n     String str=\"\";\\n      if(n%2==0){\\n          for(int i=0;i<n-1;i++)\\n            str+=\\'a\\';\\n          str+=\\'b\\';\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 2654828,
                "title": "java-simple-fast-easy-solution",
                "content": "class Solution {\\n    public String generateTheString(int n) {\\n    if(n%2==0)\\n    {\\n        String str=\"\";\\n        for(int i=0;i<n-1;i++){\\n            str=str+\\'a\\';\\n        }\\n        str=str+\\'b\\';\\n        return str;\\n    }\\n        else\\n        {\\n            \\n            String str=\"\";\\n        for(int i=0;i<n;i++){\\n            str=str+\\'a\\';\\n        }\\n       \\n        return str;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n    if(n%2==0)\\n    {\\n        String str=\"\";\\n        for(int i=0;i<n-1;i++){\\n            str=str+\\'a\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2608250,
                "title": "c-beginner-friendly-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string k=\"\";\\n        if(n%2==0)\\n        {\\n            for(int i=0;i<n-1;i++)\\n               k+=\\'p\\';\\n            k+=\\'z\\';\\n        }\\n        else{\\n            for(int i=0;i<n;i++)\\n                k+=\\'p\\';\\n        }\\n        return k;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string k=\"\";\\n        if(n%2==0)\\n        {\\n            for(int i=0;i<n-1;i++)\\n               k+=\\'p\\';\\n            k+=\\'z\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2570913,
                "title": "java-simple-fast-easy-solution-with-explanation",
                "content": "Only 2 possiblities are there, i.e n can be odd or even. \\nIf n is Odd, then we can return odd number of same characters ex:- aaa .\\nIf n is even, then we can send odd numbers of two characters, ex:-  aaa + b\\n\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n       \\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(n%2==0){\\n            for(int i=1;i<=n-1;i++){\\n                sb.append(\"a\");\\n            }\\n            sb.append(\"b\");\\n        }else{\\n            for(int i=1;i<=n;i++){\\n                sb.append(\"a\");\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n       \\n        \\n        StringBuilder sb = new StringBuilder();\\n        \\n        if(n%2==0){\\n            for(int i=1;i<=n-1;i++){\\n                sb.append(\"a\");\\n            }\\n            sb.append(\"b\");\\n        }else{\\n            for(int i=1;i<=n;i++){\\n                sb.append(\"a\");\\n            }\\n        }\\n        \\n        return sb.toString();\\n        \\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453638,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n\\n    string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2!=0){\\n            for(int i=0;i<n;i++)\\n                s+=\"a\";\\n        }\\n        else{\\n            for(int i=0;i<n-1;i++)\\n                s+=\"a\";\\n               s+=\"b\";\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2!=0){\\n            for(int i=0;i<n;i++)\\n                s+=\"a\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2410683,
                "title": "100-fast-simple-o-n-optimal-solution",
                "content": "Algorithm:\\n1. Checked if n is odd or even.\\n2. If n is odd, pushed same character to string n times. if it is even, push same character to string (n-1) times and another character 1 time.\\n3. Returned the final string as result. \\n\\nTime Complexity: O(n)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s;\\n        int i=0;\\n        if (n%2==0) {\\n            while(i<n-1) {\\n                s.push_back(\\'h\\');\\n                i++;\\n            }\\n            s.push_back(\\'d\\');\\n        } else {\\n            while(i<n) {\\n                s.push_back(\\'h\\');\\n                i++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s;\\n        int i=0;\\n        if (n%2==0) {\\n            while(i<n-1) {\\n                s.push_back(\\'h\\');\\n                i++;\\n            }\\n            s.push_back(\\'d\\');\\n        } else {\\n            while(i<n) {\\n                s.push_back(\\'h\\');\\n                i++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359198,
                "title": "typescript-javascript-returning-one-or-two-character-based-string",
                "content": "When `n` is odd you can just return a string of length `n` filled with any one specific character (e.g. `aaa`, `aaaaa`, `aaaaaaa` etc.). When `n` is even you can return `n - 1` of `a`s and add another arbitrary letter, say, `b`.\\n`97` is the code of `a`, `98` is the code of `b`.\\n`new Array(10).fill(11)` creates a 10-element array all filled with `11`s.\\n```\\nfunction generateTheString(n: number): string {\\n  if (n % 2 === 1) {\\n    return String.fromCharCode(...new Array(n).fill(97));\\n  }\\n  \\n  return String.fromCharCode(...new Array(n - 1).fill(97), 98);\\n}\\n```\\nLet me know if you have any questions. Please hit upvote if you find it useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nfunction generateTheString(n: number): string {\\n  if (n % 2 === 1) {\\n    return String.fromCharCode(...new Array(n).fill(97));\\n  }\\n  \\n  return String.fromCharCode(...new Array(n - 1).fill(97), 98);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2336834,
                "title": "generate-a-string-with-characters-that-have-odd-counts",
                "content": "var generateTheString = function(n) {\\n    let str=\"\";\\n    for(let i=0;i<n-1;i++)\\n        str+=\"k\";\\n    return str+=(n%2==0)?\"n\":\"k\";    \\n};",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "var generateTheString = function(n) {\\n    let str=\"\";\\n    for(let i=0;i<n-1;i++)\\n        str+=\"k\";\\n    return str+=(n%2==0)?\"n\":\"k\";    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2327093,
                "title": "another-simple-solution-in-python",
                "content": "```\\ndef generateTheString(self, n: int) -> str:\\n\\ts = [\\'a\\'] * n      # generate a list of \\'a\\'s of length n\\n    if n % 2 == 0:     # if n is even\\n\\t\\ts[-1] = \\'b\\'    # replace the last element (\\'a\\') with \\'b\\', so count of \\'a\\' becomes odd and count of \\'b\\' is also odd\\n\\treturn \\'\\'.join(s)  # join chars and return\\n```",
                "solutionTags": [
                    "Python",
                    "Math"
                ],
                "code": "```\\ndef generateTheString(self, n: int) -> str:\\n\\ts = [\\'a\\'] * n      # generate a list of \\'a\\'s of length n\\n    if n % 2 == 0:     # if n is even\\n\\t\\ts[-1] = \\'b\\'    # replace the last element (\\'a\\') with \\'b\\', so count of \\'a\\' becomes odd and count of \\'b\\' is also odd\\n\\treturn \\'\\'.join(s)  # join chars and return\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2278428,
                "title": "java-runtime-0-ms-faster-than-100-00",
                "content": "```\\n    public String generateTheString(int n) {\\n        if(n == 0) return \"\";\\n        if(n == 1) return \"a\";\\n        char[] charArray = new char[n];\\n        for(int i = 0; i < n; i++) charArray[i] = \\'a\\';\\n        if(n % 2 == 0) charArray[n-1] = \\'b\\';\\n        return new String(charArray);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n    public String generateTheString(int n) {\\n        if(n == 0) return \"\";\\n        if(n == 1) return \"a\";\\n        char[] charArray = new char[n];\\n        for(int i = 0; i < n; i++) charArray[i] = \\'a\\';\\n        if(n % 2 == 0) charArray[n-1] = \\'b\\';\\n        return new String(charArray);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2177099,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        _str = \"\"\\n        random_num = random.randrange(98,123)\\n        print(random_num)\\n        if n > 0:\\n            if n % 2 == 0:\\n                _str += (str(chr(97)) * (n -1)) + chr(random_num)\\n            else:\\n                _str += chr(random_num) * n\\n        return _str\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        _str = \"\"\\n        random_num = random.randrange(98,123)\\n        print(random_num)\\n        if n > 0:\\n            if n % 2 == 0:\\n                _str += (str(chr(97)) * (n -1)) + chr(random_num)\\n            else:\\n                _str += chr(random_num) * n\\n        return _str\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147125,
                "title": "easy-java-solution-beginner-friendly-o-n",
                "content": "***Please Upvote if You Liked The Solution.***\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb=new StringBuilder(\"\");\\n        if (n%2==0)\\n        {\\n            for (int i=0;i<n-1;i++){sb.append(\"p\");}\\n            sb.append(\\'z\\');\\n        }\\n        else{for (int i=0;i<n;i++){sb.append(\"p\");}}\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb=new StringBuilder(\"\");\\n        if (n%2==0)\\n        {\\n            for (int i=0;i<n-1;i++){sb.append(\"p\");}\\n            sb.append(\\'z\\');\\n        }\\n        else{for (int i=0;i<n;i++){sb.append(\"p\");}}\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136175,
                "title": "java-easy-apporach",
                "content": "This is the best solution\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder str=new StringBuilder(\"\");\\n        if(n%2==0)\\n        {\\n            for(int i=0;i<n-1;i++)\\n            {\\n                str.append(\"p\");\\n            }\\n            str.append(\"z\");\\n        }\\n        else\\n        {\\n           \\n            for(int i=0;i<n;i++)\\n            {\\n                str.append(\"a\");\\n            }\\n\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder str=new StringBuilder(\"\");\\n        if(n%2==0)\\n        {\\n            for(int i=0;i<n-1;i++)\\n            {\\n                str.append(\"p\");\\n            }\\n            str.append(\"z\");\\n        }\\n        else\\n        {\\n           \\n            for(int i=0;i<n;i++)\\n            {\\n                str.append(\"a\");\\n            }\\n\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2088402,
                "title": "0ms-run-time-easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res = \"\";\\n        if(n%2 != 0) {while(n--) {res.push_back(\\'z\\');} return res;}\\n        while(n > 1) {res.push_back(\\'z\\');n--;}\\n        res.push_back(\\'y\\');\\n        return res;\\n        /*  here i select char z and y . apart from this you can select any random char */\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/a1e9da1c-37fc-4ffe-82eb-3d08cb314b02_1653845251.2235584.png)\\n\\n**Please Upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res = \"\";\\n        if(n%2 != 0) {while(n--) {res.push_back(\\'z\\');} return res;}\\n        while(n > 1) {res.push_back(\\'z\\');n--;}\\n        res.push_back(\\'y\\');\\n        return res;\\n        /*  here i select char z and y . apart from this you can select any random char */\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073384,
                "title": "java-solution-2-line",
                "content": "```java \\nclass Solution {\\n    public String generateTheString(int n) {\\n        String s=\"a\".repeat(n-1);\\n        return n%2==0? s+\\'b\\':s+\\'a\\';\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n        String s=\"a\".repeat(n-1);\\n        return n%2==0? s+\\'b\\':s+\\'a\\';\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2063004,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        int count = (n % 2 == 0) ? n - 1 : n;\\n        StringBuilder result  = new StringBuilder();\\n        \\n        for (int i = 0; i < count; i++) result.append(\\'a\\');\\n        \\n        if( n % 2 == 0) result.append(\\'b\\');\\n        \\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        int count = (n % 2 == 0) ? n - 1 : n;\\n        StringBuilder result  = new StringBuilder();\\n        \\n        for (int i = 0; i < count; i++) result.append(\\'a\\');\\n        \\n        if( n % 2 == 0) result.append(\\'b\\');\\n        \\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2030162,
                "title": "python-solution",
                "content": "**Upvote** if you like solution and feel **free to ask** If you have any question.\\n```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 == 0:\\n            return (\\'a\\' * (n-1) + \\'b\\')\\n        else:\\n            return (\\'a\\' * n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n % 2 == 0:\\n            return (\\'a\\' * (n-1) + \\'b\\')\\n        else:\\n            return (\\'a\\' * n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959906,
                "title": "94-faster-easy-code",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2:\\n            return \\'a\\'*n\\n        else:\\n            return \\'a\\'*(n-1)+\\'b\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2:\\n            return \\'a\\'*n\\n        else:\\n            return \\'a\\'*(n-1)+\\'b\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945616,
                "title": "cpp-easy-to-understand",
                "content": "Feel Free To UpVote\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans = \"\";\\n        if(n&1){\\n            while(n){\\n                ans+=\\'a\\';\\n                n--;\\n            }\\n        }\\n        else{\\n            while(n>1){\\n                ans+=\\'a\\';\\n                n--;\\n            }\\n            ans+=\\'b\\';\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans = \"\";\\n        if(n&1){\\n            while(n){\\n                ans+=\\'a\\';\\n                n--;\\n            }\\n        }\\n        else{\\n            while(n>1){\\n                ans+=\\'a\\';\\n                n--;\\n            }\\n            ans+=\\'b\\';\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845157,
                "title": "easy-java",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder s=new StringBuilder();\\n        if(n%2==0){\\n            for(int i=0;i<n-1;i++){\\n                s.append(\"x\");\\n            }\\n            s.append(\"y\");\\n        }\\n        else{\\n            for(int i=0;i<=n-1;i++){\\n                s.append(\"x\");\\n            }\\n        }\\n        return s.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder s=new StringBuilder();\\n        if(n%2==0){\\n            for(int i=0;i<n-1;i++){\\n                s.append(\"x\");\\n            }\\n            s.append(\"y\");\\n        }\\n        else{\\n            for(int i=0;i<=n-1;i++){\\n                s.append(\"x\");\\n            }\\n        }\\n        return s.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833276,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n         if (n == 1) {\\n            return \"o\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        if (n % 2 == 0) {\\n            for (int i = 0; i < n - 1; i++) {\\n                sb.append(\"o\");\\n            }\\n            sb.append(\"h\");\\n        } else {\\n            for (int i = 0; i < n - 2; i++) {\\n                sb.append(\"o\");\\n            }\\n            sb.append(\"hc\");\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n         if (n == 1) {\\n            return \"o\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        if (n % 2 == 0) {\\n            for (int i = 0; i < n - 1; i++) {\\n                sb.append(\"o\");\\n            }\\n            sb.append(\"h\");\\n        } else {\\n            for (int i = 0; i < n - 2; i++) {\\n                sb.append(\"o\");\\n            }\\n            sb.append(\"hc\");\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1819348,
                "title": "easy-one-liner-solution-with-comments",
                "content": "```\\n\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return n % 2 == 0 ? \"a\".repeat(n-1) + \"b\" : \"a\".repeat(n);\\n    }\\n}\\n//If \\'n\\' is even print \\'a\\' odd number of times i.e. (n-1) and print \\'b\\' once i.e. odd\\n//If \\'n\\' is odd just print any letter n times",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n        return n % 2 == 0 ? \"a\".repeat(n-1) + \"b\" : \"a\".repeat(n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1797988,
                "title": "python-3-one-line-solution",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\"*n if n%2 == 1 else \"a\"*(n-1)+\"b\"     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\"*n if n%2 == 1 else \"a\"*(n-1)+\"b\"     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765942,
                "title": "c-100-faster-beginner-friendly-easy-to-understand",
                "content": "**Please Upvote if you found this useful.**\\n\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) \\n    {\\n        string ans= \"\";\\n        if(n%2!= 0)\\n        {\\n            while(n--)\\n            {\\n                ans+= \\'a\\';\\n            }\\n        }\\n        else\\n        {\\n            while(n!=1)\\n            {\\n                ans+= \\'a\\';\\n                n--;\\n            }\\n            ans+= \\'b\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) \\n    {\\n        string ans= \"\";\\n        if(n%2!= 0)\\n        {\\n            while(n--)\\n            {\\n                ans+= \\'a\\';\\n            }\\n        }\\n        else\\n        {\\n            while(n!=1)\\n            {\\n                ans+= \\'a\\';\\n                n--;\\n            }\\n            ans+= \\'b\\';\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655816,
                "title": "100-faster-0ms-simple-c-solution",
                "content": "Making use of string initialization \\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans(n, \\'a\\');\\n        if(!(n & 1)) ans[0] = \\'b\\';\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans(n, \\'a\\');\\n        if(!(n & 1)) ans[0] = \\'b\\';\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639207,
                "title": "python-simple-and-fast-95",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2==1:\\n            return \\'p\\'*n\\n        else:\\n            return \\'p\\'*(n-1)+\\'z\\'\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2==1:\\n            return \\'p\\'*n\\n        else:\\n            return \\'p\\'*(n-1)+\\'z\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567384,
                "title": "c-100-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string str=\"\";\\n        if(n%2==0){\\n            for(int i=0;i<n;i++){\\n                if(i==n-1)\\n                    str+=\\'b\\';\\n                else\\n                    str+=\\'a\\';\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n;i++){\\n                str+=\\'a\\';\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string str=\"\";\\n        if(n%2==0){\\n            for(int i=0;i<n;i++){\\n                if(i==n-1)\\n                    str+=\\'b\\';\\n                else\\n                    str+=\\'a\\';\\n            }\\n        }\\n        else{\\n            for(int i=0;i<n;i++){\\n                str+=\\'a\\';\\n            }\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563219,
                "title": "java-1ms-one-liner",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return n % 2 == 0 ? \"a\".repeat(n-1) + \"b\" : \"a\".repeat(n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return n % 2 == 0 ? \"a\".repeat(n-1) + \"b\" : \"a\".repeat(n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532538,
                "title": "python-easy-to-understand-code",
                "content": "```\\n    def generateTheString(self, n: int) -> str:\\n        if n==1:\\n            return \\'x\\'\\n        elif n%2==0:\\n            return \\'x\\'*(n-1)+\\'y\\'\\n        else:\\n            return \\'x\\'*(n-2)+\\'y\\'+\\'z\\'\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def generateTheString(self, n: int) -> str:\\n        if n==1:\\n            return \\'x\\'\\n        elif n%2==0:\\n            return \\'x\\'*(n-1)+\\'y\\'\\n        else:\\n            return \\'x\\'*(n-2)+\\'y\\'+\\'z\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1529546,
                "title": "java-easy-solution",
                "content": "# ******class Solution {\\n    public String generateTheString(int n) {\\n        if((n&1)==0){\\n            String temp=\"\";\\n            for(int i=0;i<n-1;i++)\\n                temp+=\\'a\\';\\n            temp+=\\'b\\';\\n            return temp;\\n        }\\n        else{\\n            String temp=\"\";\\n            for(int i=0;i<n;i++)\\n                temp+=\\'a\\';\\n            return temp;\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n        if((n&1)==0){\\n            String temp=\"\";\\n            for(int i=0;i<n-1;i++)\\n                temp+=\\'a\\';\\n            temp+=\\'b\\';\\n            return temp;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1366624,
                "title": "0-ms-faster-than-100-00-of-c-6-1-mb-less-than-68-33-of-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans;\\n        if(n % 2 == 0){\\n            for(int i=0;i<n-1;i++)\\n                ans+=\"a\";\\n            ans+=\"b\";\\n        }\\n        if(n % 2 != 0){\\n            for(int i=0;i<n;i++)\\n                ans+=\"a\";\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans;\\n        if(n % 2 == 0){\\n            for(int i=0;i<n-1;i++)\\n                ans+=\"a\";\\n            ans+=\"b\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1335545,
                "title": "simple-c-solution",
                "content": "```\\n    string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2==0){\\n            \\n            for(int i=0;i<n-1;i++){\\n                s+=\\'a\\';\\n            }\\n            s+=\\'b\\';\\n            \\n        }\\n        else{\\n            for(int i=0;i<=n-1;i++){\\n                s+=\\'a\\';\\n            } \\n        }\\n        \\n        return s;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2==0){\\n            \\n            for(int i=0;i<n-1;i++){\\n                s+=\\'a\\';\\n            }\\n            s+=\\'b\\';\\n            \\n        }\\n        else{\\n            for(int i=0;i<=n-1;i++){\\n                s+=\\'a\\';\\n            } \\n        }\\n        \\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1332416,
                "title": "c-solution-100-faster-easy-to-read",
                "content": "```\\nchar * generateTheString(int n){\\n    char *result = (char *)malloc((n+1) * sizeof(char));\\n    if(n % 2 == 1)\\n        for(int i = 0; i < n; i++)\\n            result[i] = \\'a\\';\\n    else{\\n        for(int i = 0; i < n-1; i++)\\n            result[i] = \\'a\\';\\n        result[n-1] = \\'b\\';\\n    }\\n    \\n    result[n] = \\'\\\\0\\';\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * generateTheString(int n){\\n    char *result = (char *)malloc((n+1) * sizeof(char));\\n    if(n % 2 == 1)\\n        for(int i = 0; i < n; i++)\\n            result[i] = \\'a\\';\\n    else{\\n        for(int i = 0; i < n-1; i++)\\n            result[i] = \\'a\\';\\n        result[n-1] = \\'b\\';\\n    }\\n    \\n    result[n] = \\'\\\\0\\';\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1311738,
                "title": "python3-faster-than-88-one-liner",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\" * (n-1) + \"b\" if n % 2 == 0 else \"a\" * n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\" * (n-1) + \"b\" if n % 2 == 0 else \"a\" * n",
                "codeTag": "Java"
            },
            {
                "id": 1303409,
                "title": "java-simple-solution-runtime-0-ms",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for Generate a String With Characters That Have Odd Counts.\\nMemory Usage: 36.3 MB, less than 71.11% of Java online submissions for Generate a String With Characters That Have Odd Counts.**\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] result = new char[n];\\n        Arrays.fill(result,\\'a\\');\\n        if(n%2 == 0)result[0] = \\'b\\';\\n        return new String(result);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] result = new char[n];\\n        Arrays.fill(result,\\'a\\');\\n        if(n%2 == 0)result[0] = \\'b\\';\\n        return new String(result);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265288,
                "title": "python-solution-generate-a-string-with-characters-that-have-odd-counts",
                "content": "class Solution(object):\\n    \\n\\tdef generateTheString(self, n):\\n        if n%2==0:\\n            return \"a\"*(n-1)+\"b\"\\n        elif n%2!=0:\\n            return \"a\"*n",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution(object):\\n    \\n\\tdef generateTheString(self, n):\\n        if n%2==0:\\n            return \"a\"*(n-1)+\"b\"\\n        elif n%2!=0:\\n            return \"a\"*n",
                "codeTag": "Java"
            },
            {
                "id": 1219248,
                "title": "python3-one-liner-string",
                "content": "```\\nclass Solution:\\n     def generateTheString(self, n: int) -> str:\\n\\t\\t# we can use any of the 2 alphabets of our choice\\n        return \"v\" * n if n % 2 else \"v\" * (n-1) + \"m\"\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n     def generateTheString(self, n: int) -> str:\\n\\t\\t# we can use any of the 2 alphabets of our choice\\n        return \"v\" * n if n % 2 else \"v\" * (n-1) + \"m\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218745,
                "title": "elixir-solution",
                "content": "```\\ndef generate_the_string(n) do\\n  last_char = if rem(n, 2) === 0, do: \"b\", else: \"a\"\\n  String.duplicate(\"a\", n - 1) <> last_char\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef generate_the_string(n) do\\n  last_char = if rem(n, 2) === 0, do: \"b\", else: \"a\"\\n  String.duplicate(\"a\", n - 1) <> last_char\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1204839,
                "title": "easy-understanding-100-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";    \\n        if(n%2==0)\\n        {\\n       for(int i=0;i<n-1;i++)\\n       {\\n           ans.push_back(\\'a\\');\\n       }\\n            ans.push_back(\\'b\\');\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                ans.push_back(\\'a\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nupvote if u like",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string ans=\"\";    \\n        if(n%2==0)\\n        {\\n       for(int i=0;i<n-1;i++)\\n       {\\n           ans.push_back(\\'a\\');\\n       }\\n            ans.push_back(\\'b\\');\\n        }\\n        else\\n        {\\n            for(int i=0;i<n;i++)\\n            {\\n                ans.push_back(\\'a\\');\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166022,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if(n % 2 == 0): return \\'a\\' + \\'b\\' * (n - 1)\\n        \\n        return \\'a\\' * n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if(n % 2 == 0): return \\'a\\' + \\'b\\' * (n - 1)\\n        \\n        return \\'a\\' * n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162729,
                "title": "one-line-java-soltion-100",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return n % 2 == 0? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n); \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String generateTheString(int n) {\\n        return n % 2 == 0? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n); \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1138438,
                "title": "js-no-inbuilt-methods-only-while-loop",
                "content": "```\\nvar generateTheString = function(n) {\\n\\n    let str=\\'\\', a = n%2===0 ? n-1 : n;\\n    \\n    while(a--){\\n        str+=\\'a\\'\\n    }\\n\\n    return n%2===0? str+=\\'b\\' : str;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateTheString = function(n) {\\n\\n    let str=\\'\\', a = n%2===0 ? n-1 : n;\\n    \\n    while(a--){\\n        str+=\\'a\\'\\n    }\\n\\n    return n%2===0? str+=\\'b\\' : str;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1137520,
                "title": "java-easy",
                "content": "```\\n\\n\\npublic String generateTheString(int n) {\\n\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\\'a\\');\\n        \\n        for(int i = 1; i < n; i++ ) {\\n            if(n % 2 == 0) {\\n                sb.append(\\'b\\');\\n            } else {\\n                sb.append(\\'a\\');\\n            }   \\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\npublic String generateTheString(int n) {\\n\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(\\'a\\');\\n        \\n        for(int i = 1; i < n; i++ ) {\\n            if(n % 2 == 0) {\\n                sb.append(\\'b\\');\\n            } else {\\n                sb.append(\\'a\\');\\n            }   \\n        }\\n        \\n        return sb.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1127516,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n<=26:\\n            return string.ascii_lowercase[:n]\\n        else:\\n            if n%2 == 0:\\n                return \"a\"*(n-1) + \"b\"   \\n            else:\\n                return \"a\"*(n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n<=26:\\n            return string.ascii_lowercase[:n]\\n        else:\\n            if n%2 == 0:\\n                return \"a\"*(n-1) + \"b\"   \\n            else:\\n                return \"a\"*(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124693,
                "title": "100-c-4-lines-of-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string answer(n, \\'a\\');\\n\\n        if(n % 2) \\n            return answer;\\n\\n        answer[n - 1] = \\'b\\';\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string answer(n, \\'a\\');\\n\\n        if(n % 2) \\n            return answer;\\n\\n        answer[n - 1] = \\'b\\';\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1122719,
                "title": "python-3-beats-99-83-runtime",
                "content": "I don\\'t see any catch in this problem, since it does not ask for a particular pattern of return string.\\nSolution is pretty simple, return a string that has:\\n* (n-1) times the letter \"a\" (or any letter)\\n* for the last letter:\\n\\t* if the number \"n\" is odd then the final letter would be also \"a\" (or the same letter),\\n\\t* otherwise (\"n\" is even) it would be the letter \"b\" (or any other letter except the one used for the first (n-1) places).\\n```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\"*(n-1) + \"a\"*(n%2) + \"b\"*((n+1)%2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\"*(n-1) + \"a\"*(n%2) + \"b\"*((n+1)%2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116940,
                "title": "one-line-100-100-javascript",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar generateTheString = function(n) {\\n    return n % 2 === 0 ? \\'a\\'.repeat(n-1)+\\'b\\' : \\'a\\'.repeat(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {string}\\n */\\nvar generateTheString = function(n) {\\n    return n % 2 === 0 ? \\'a\\'.repeat(n-1)+\\'b\\' : \\'a\\'.repeat(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1113822,
                "title": "rust-0m",
                "content": "```\\nimpl Solution {\\n    pub fn generate_the_string(n: i32) -> String {\\n         let n = n as usize;\\n    if n % 2 != 0 {\\n        return \"a\".repeat(n);\\n    } else {\\n        return \"a\".repeat(n-1) + \"b\";\\n    }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn generate_the_string(n: i32) -> String {\\n         let n = n as usize;\\n    if n % 2 != 0 {\\n        return \"a\".repeat(n);\\n    } else {\\n        return \"a\".repeat(n-1) + \"b\";\\n    }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1101595,
                "title": "simple-code",
                "content": "class Solution\\n{\\n public String generateTheString(int n)\\n {\\n   var result = new char[n];\\n   Arrays.fill(result, \\'a\\');\\n   if (n % 2 == 0) result[0] = \\'b\\';\\n   return new String(result);\\n }\\n}",
                "solutionTags": [],
                "code": "class Solution\\n{\\n public String generateTheString(int n)\\n {\\n   var result = new char[n];\\n   Arrays.fill(result, \\'a\\');\\n   if (n % 2 == 0) result[0] = \\'b\\';\\n   return new String(result);\\n }",
                "codeTag": "Java"
            },
            {
                "id": 1073652,
                "title": "very-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) \\n    {\\n        String res=\"\";\\n        if(n%2==0)\\n        {\\n            for(int i=1;i<n;i++)\\n                res+=\\'a\\';\\n            res+=\\'b\\';\\n        }\\n        else\\n        {\\n            for(int i=1;i<=n;i++)\\n                res+=\\'a\\';\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n//By Arindam Ghosh\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) \\n    {\\n        String res=\"\";\\n        if(n%2==0)\\n        {\\n            for(int i=1;i<n;i++)\\n                res+=\\'a\\';\\n            res+=\\'b\\';\\n        }\\n        else\\n        {\\n            for(int i=1;i<=n;i++)\\n                res+=\\'a\\';\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n//By Arindam Ghosh\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1069832,
                "title": "easy-c-generate-a-string",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        return n&1 ? string(n,\\'a\\') : string(n-1,\\'a\\')+\\'b\\';\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        return n&1 ? string(n,\\'a\\') : string(n-1,\\'a\\')+\\'b\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066965,
                "title": "runtime-0ms-faster-than-100-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string p;\\n        if(n%2==0){\\n            for(int i=0;i<n-1;i++){\\n                p+=\\'a\\';\\n            }\\n            p+=\\'b\\';\\n        }\\n        else{\\n            for(int i=0;i<n;i++){\\n                p+=\\'a\\';\\n            }\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string p;\\n        if(n%2==0){\\n            for(int i=0;i<n-1;i++){\\n                p+=\\'a\\';\\n            }\\n            p+=\\'b\\';\\n        }\\n        else{\\n            for(int i=0;i<n;i++){\\n                p+=\\'a\\';\\n            }\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1066461,
                "title": "c-3lines-beats-100-by-the-way-this-is-the-borest-problem-ever",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res(n,\\'a\\');\\n        if(n%2 == 0) res[0] =\\'b\\';\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res(n,\\'a\\');\\n        if(n%2 == 0) res[0] =\\'b\\';\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1063388,
                "title": "java-easy-solution-comment-explained",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder result = new StringBuilder();\\n        if ((n & 1) != 1){                    // if its even\\n            result.append(\"a\");               // add \\'a\\' character\\n            n = n-1;                          // reduce n by 1\\n        }\\n        while (n-- > 0) result.append(\"b\");   //loop and add character \\'b\\' until n becomes 0\\n        return result.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder result = new StringBuilder();\\n        if ((n & 1) != 1){                    // if its even\\n            result.append(\"a\");               // add \\'a\\' character\\n            n = n-1;                          // reduce n by 1\\n        }\\n        while (n-- > 0) result.append(\"b\");   //loop and add character \\'b\\' until n becomes 0\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038583,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] characters = new char[n];\\n        Arrays.fill(characters, \\'a\\');\\n        if (n % 2 == 0) characters[0] = \\'b\\';\\n        return new String(characters);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] characters = new char[n];\\n        Arrays.fill(characters, \\'a\\');\\n        if (n % 2 == 0) characters[0] = \\'b\\';\\n        return new String(characters);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1035083,
                "title": "python3-beautiful-clean-number-magic",
                "content": "Several important points:\\n* We only need one type of character (e.g. `\\'a\\'`) for an odd-length string, and two (e.g. `\\'a\\'`, `\\'b\\'`) for an even-length string.\\n* In Python, you can use the `*` operator to repeat strings and lists.\\n* `n & 1` is 1 if odd, 0 if even\\n\\n```python\\nclass Solution:\\n  def generateTheString(self, n: int) -> str:\\n    e = 1 - n & 1                     # e is 1 if even, 0 if odd\\n    return \\'a\\' * (n - e) + \\'b\\' * e\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n  def generateTheString(self, n: int) -> str:\\n    e = 1 - n & 1                     # e is 1 if even, 0 if odd\\n    return \\'a\\' * (n - e) + \\'b\\' * e\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008038,
                "title": "kotlin-minimalistic-no-if",
                "content": "```\\nclass Solution {\\n    fun generateTheString(n: Int): String {\\n        val p = n + n % 2 - 1\\n        return \"p\".repeat(p) + \"q\".repeat(n - p)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun generateTheString(n: Int): String {\\n        val p = n + n % 2 - 1\\n        return \"p\".repeat(p) + \"q\".repeat(n - p)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998720,
                "title": "ruby-very-short-1-liner",
                "content": "```\\ndef generate_the_string(n)\\n    ?a*~-n+[?b,?a][n&1]\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef generate_the_string(n)\\n    ?a*~-n+[?b,?a][n&1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 998045,
                "title": "simple-one-liner-in-pytohon",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\" * n if n % 2 else \"a\" * (n - 1) + \"b\" \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        return \"a\" * n if n % 2 else \"a\" * (n - 1) + \"b\" \\n```",
                "codeTag": "Java"
            },
            {
                "id": 988107,
                "title": "java-0ms",
                "content": "```\\n public String generateTheString(int n) {\\n        if(n%2==0){\\n            return \"e\".repeat(n-1)+\"i\";\\n        }\\n        else{\\n            return \"e\".repeat(n);\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public String generateTheString(int n) {\\n        if(n%2==0){\\n            return \"e\".repeat(n-1)+\"i\";\\n        }\\n        else{\\n            return \"e\".repeat(n);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 975567,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res = \"\";\\n        \\n        if ((n % 2) == 0)\\n        {\\n            res += \\'a\\';\\n            for (size_t i = 1; i < n; i++)\\n            {\\n                res += \\'b\\';\\n            }\\n        }\\n        \\n        else\\n        {\\n            for (size_t i = 0; i < n; i++)\\n            {\\n                res += \\'b\\';\\n            }            \\n        }\\n   \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string res = \"\";\\n        \\n        if ((n % 2) == 0)\\n        {\\n            res += \\'a\\';\\n            for (size_t i = 1; i < n; i++)\\n            {\\n                res += \\'b\\';\\n            }\\n        }\\n        \\n        else\\n        {\\n            for (size_t i = 0; i < n; i++)\\n            {\\n                res += \\'b\\';\\n            }            \\n        }\\n   \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 958810,
                "title": "scala-simple-solution",
                "content": "```\\ndef generateTheString(n: Int): String = n match {\\n\\tcase 0 => \"\"\\n\\tcase odd if odd % 2 == 1 => \"a\" * odd\\n\\tcase even => \"a\" * (even - 1) + \"b\"\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndef generateTheString(n: Int): String = n match {\\n\\tcase 0 => \"\"\\n\\tcase odd if odd % 2 == 1 => \"a\" * odd\\n\\tcase even => \"a\" * (even - 1) + \"b\"\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 954134,
                "title": "simple-python",
                "content": "```\\n    def generateTheString(self, n):\\n        return \\'a\\'*n if n%2==1 else \\'a\\'*(n-1)+\\'b\\'        \\n```",
                "solutionTags": [],
                "code": "```\\n    def generateTheString(self, n):\\n        return \\'a\\'*n if n%2==1 else \\'a\\'*(n-1)+\\'b\\'        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 949957,
                "title": "c-cpp-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n)\\n    {\\n        string str(n,\\'a\\');\\n        if(!(n&1))//even\\n        {\\n            str.back()=\\'b\\';\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n)\\n    {\\n        string str(n,\\'a\\');\\n        if(!(n&1))//even\\n        {\\n            str.back()=\\'b\\';\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 947066,
                "title": "javascript-solution",
                "content": "```\\nvar generateTheString = function(n) {\\n    if (n % 2 === 0) {\\n        return \"a\".repeat(n - 1) + \"b\";\\n    }\\n    \\n    return \"a\".repeat(n);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar generateTheString = function(n) {\\n    if (n % 2 === 0) {\\n        return \"a\".repeat(n - 1) + \"b\";\\n    }\\n    \\n    return \"a\".repeat(n);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 935469,
                "title": "java-2-simple-solutions-with-stringbuilder-and-arrays-fill",
                "content": "\\n**V1**\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder str = new StringBuilder();\\n\\t\\t\\n        if (n % 2 == 0) {\\n            str.append(\"x\");\\n            n--;\\n        }\\n\\n        while (n > 0) {\\n            str.append(\"a\");\\n            n--;\\n        }\\n\\n        return str.toString();\\n    }\\n}\\n```\\n\\n**V2**\\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] arr = new char[n];\\n        \\n\\t\\tArrays.fill(arr, \\'a\\'); \\n        if (n % 2 == 0) arr[0] = \\'x\\';\\n\\t\\t\\n        return String.valueOf(arr);       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder str = new StringBuilder();\\n\\t\\t\\n        if (n % 2 == 0) {\\n            str.append(\"x\");\\n            n--;\\n        }\\n\\n        while (n > 0) {\\n            str.append(\"a\");\\n            n--;\\n        }\\n\\n        return str.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] arr = new char[n];\\n        \\n\\t\\tArrays.fill(arr, \\'a\\'); \\n        if (n % 2 == 0) arr[0] = \\'x\\';\\n\\t\\t\\n        return String.valueOf(arr);       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 923632,
                "title": "python-one-liner",
                "content": "``` \\n        return \\'a\\' * n if n % 2 else \\'a\\' * 1 + \\'b\\' * (n - 1)\\n```",
                "solutionTags": [],
                "code": "``` \\n        return \\'a\\' * n if n % 2 else \\'a\\' * 1 + \\'b\\' * (n - 1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 922944,
                "title": "cpp-very-simple-and-efficient-i-think",
                "content": "very simple and efficient, I think\\n\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s = \"\";\\n        \\n        if( n%2 == 1){\\n            for(int i =0 ;i<n;i++)\\n                s+=\\'a\\';\\n        } else{\\n            for(int i=0 ;i<n-1;i++)\\n                s+=\\'a\\';\\n            s+=\\'b\\';\\n        }\\n        \\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string s = \"\";\\n        \\n        if( n%2 == 1){\\n            for(int i =0 ;i<n;i++)\\n                s+=\\'a\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 913858,
                "title": "c-easy-and-force",
                "content": "if n = even add \\'z\\'\\n```\\npublic class Solution {\\n    public string GenerateTheString(int n) {\\n        if(n%2==0)\\n            return new string(new char[n-1]).Replace(\"\\\\u0000\",\"a\")+\\'z\\';\\n        else\\n            return new string(new char[n]).Replace(\"\\\\u0000\",\"a\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string GenerateTheString(int n) {\\n        if(n%2==0)\\n            return new string(new char[n-1]).Replace(\"\\\\u0000\",\"a\")+\\'z\\';\\n        else\\n            return new string(new char[n]).Replace(\"\\\\u0000\",\"a\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911730,
                "title": "java-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb = new StringBuilder(n);\\n        while (sb.length() < n - 1) {\\n            sb.append(\\'a\\');\\n        }\\n        if (n % 2 == 0) {\\n            sb.append(\\'b\\');\\n        } else {\\n            sb.append(\\'a\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        StringBuilder sb = new StringBuilder(n);\\n        while (sb.length() < n - 1) {\\n            sb.append(\\'a\\');\\n        }\\n        if (n % 2 == 0) {\\n            sb.append(\\'b\\');\\n        } else {\\n            sb.append(\\'a\\');\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 904694,
                "title": "python-if-else-easy-solution",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n == 1: return \"x\"\\n        if n % 2 == 0:\\n            return \"x\" * (n-1) + \"z\"\\n        else:\\n            return \"z\" * (n-2) + \"x\" + \"y\"\\n```\\nFor more solutions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n == 1: return \"x\"\\n        if n % 2 == 0:\\n            return \"x\" * (n-1) + \"z\"\\n        else:\\n            return \"z\" * (n-2) + \"x\" + \"y\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 886035,
                "title": "very-concise-and-very-easy-best-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string S(n,\\'a\\');\\n        if(n % 2 == 0)\\n            S[S.size() - 1] = \\'b\\';\\n        return S;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        string S(n,\\'a\\');\\n        if(n % 2 == 0)\\n            S[S.size() - 1] = \\'b\\';\\n        return S;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 881252,
                "title": "only-a-and-b-are-used-0ms-100-faster-c",
                "content": "[https://github.com/sarimurrab](https://github.com/sarimurrab)\\n```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        \\n        string res =\"\";\\n        char abc[27]= {\\'a\\',\\'b\\'};\\n        \\n        \\n        if(n&1)                 // if ODD- simple add \\'a\\' character n times\\n            for(int i=0;i<n;i++)             //       aaa\\n            {\\n                res += abc[0];          \\n            }\\n        else                    // if even, \\'a\\' add one time and \\'b\\' n-1 times\\n        {                                     //      abbb\\n            for(int i=0;i<1;i++)\\n            {\\n                res += abc[0];          \\n            }\\n            for(int i=1;i<n;i++)\\n            {\\n                res += abc[1];          \\n            }\\n            \\n        }\\n        return res;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string generateTheString(int n) {\\n        \\n        string res =\"\";\\n        char abc[27]= {\\'a\\',\\'b\\'};\\n        \\n        \\n        if(n&1)                 // if ODD- simple add \\'a\\' character n times\\n            for(int i=0;i<n;i++)             //       aaa\\n            {\\n                res += abc[0];          \\n            }\\n        else                    // if even, \\'a\\' add one time and \\'b\\' n-1 times\\n        {                                     //      abbb\\n            for(int i=0;i<1;i++)\\n            {\\n                res += abc[0];          \\n            }\\n            for(int i=1;i<n;i++)\\n            {\\n                res += abc[1];          \\n            }\\n            \\n        }\\n        return res;\\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 876900,
                "title": "1ms-java-solution-no-loops",
                "content": "```class Solution {\\n    public String generateTheString(int n) {\\n        \\n        //if n is even, create a string of n-1 \"a\"\\'s and append a \"b\".\\n        if(n%2 == 0){\\n            //create an array of chars of length n-1 and replace all chars with an \"a\" before converting to String.\\n            String a = new String(new char[n-1]).replace(\"\\\\0\", \"a\");\\n            return (a + \"b\");\\n        }\\n        //otherwise return a String of n \"a\"\\'s.\\n        return new String(new char[n]).replace(\"\\\\0\", \"a\");\\n    }\\n}```\\n",
                "solutionTags": [],
                "code": "```class Solution {\\n    public String generateTheString(int n) {\\n        \\n        //if n is even, create a string of n-1 \"a\"\\'s and append a \"b\".\\n        if(n%2 == 0){\\n            //create an array of chars of length n-1 and replace all chars with an \"a\" before converting to String.\\n            String a = new String(new char[n-1]).replace(\"\\\\0\", \"a\");\\n            return (a + \"b\");\\n        }\\n        //otherwise return a String of n \"a\"\\'s.\\n        return new String(new char[n]).replace(\"\\\\0\", \"a\");\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 871843,
                "title": "simple-c-code-self-explanatory-beats-100",
                "content": "```\\nchar * generateTheString(int n){\\n    char *res = (char *)malloc(sizeof(char)*(n+1));\\n    res[n]= \\'\\\\0\\';\\n    if(n%2 == 0){\\n        for(int i=0; i<=n-2; i++){\\n            res[i] = \\'a\\';\\n        }\\n        res[n-1]= \\'b\\';\\n    }\\n    else{\\n        for(int i=0; i<n ;i++){\\n            res[i]= \\'a\\';\\n        }\\n    }\\n    return res;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * generateTheString(int n){\\n    char *res = (char *)malloc(sizeof(char)*(n+1));\\n    res[n]= \\'\\\\0\\';\\n    if(n%2 == 0){\\n        for(int i=0; i<=n-2; i++){\\n            res[i] = \\'a\\';\\n        }\\n        res[n-1]= \\'b\\';\\n    }\\n    else{\\n        for(int i=0; i<n ;i++){\\n            res[i]= \\'a\\';\\n        }\\n    }\\n    return res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 866994,
                "title": "100-faster-than-other-c-solutions",
                "content": "string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2!=0)\\n        {\\n            for(int i=0;i<n;i++)\\n                s+=\"a\";\\n        }\\n        else\\n        {\\n            if((n/2)%2!=0)\\n            {\\n                for(int i=0;i<n/2;i++)\\n                    s+=\"a\";\\n                for(int i=0;i<n/2;i++)\\n                    s+=\"b\";\\n            }\\n            else\\n            {\\n                for(int i=0;i<n/2+1;i++)\\n                    s+=\"a\";\\n                for(int i=0;i<n/2-1;i++)\\n                    s+=\"b\";\\n            }\\n        }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "string generateTheString(int n) {\\n        string s=\"\";\\n        if(n%2!=0)\\n        {\\n            for(int i=0;i<n;i++)\\n                s+=\"a\";\\n        }\\n        else\\n        {\\n            if((n/2)%2!=0)\\n            {\\n                for(int i=0;i<n/2;i++)\\n                    s+=\"a\";\\n                for(int i=0;i<n/2;i++)\\n                    s+=\"b\";\\n            }\\n            else\\n            {\\n                for(int i=0;i<n/2+1;i++)\\n                    s+=\"a\";\\n                for(int i=0;i<n/2-1;i++)\\n                    s+=\"b\";\\n            }\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 801292,
                "title": "java-one-line-solution",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return n%2 == 0 ? \\n            new String(new char[n-1]).replace(\"\\\\0\", \"x\") + \"y\" : \\n            new String(new char[n]).replace(\"\\\\0\", \"x\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        return n%2 == 0 ? \\n            new String(new char[n-1]).replace(\"\\\\0\", \"x\") + \"y\" : \\n            new String(new char[n]).replace(\"\\\\0\", \"x\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796344,
                "title": "two-lines-golang-solution-faster-than-100-2-1mb-beats-97",
                "content": "```\\nfunc generateTheString(n int) string {\\n    if n % 2 == 0 { return strings.Repeat(\"a\", n-1) + \"b\" }\\n    return strings.Repeat(\"a\", n)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc generateTheString(n int) string {\\n    if n % 2 == 0 { return strings.Repeat(\"a\", n-1) + \"b\" }\\n    return strings.Repeat(\"a\", n)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 795765,
                "title": "java-faster-than-100-less-mem-than-97",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] str = new char[n];\\n        Arrays.fill(str, \\'b\\');\\n        \\n        if(n%2==0) str[0] = \\'a\\';\\n        \\n        return new String(str);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] str = new char[n];\\n        Arrays.fill(str, \\'b\\');\\n        \\n        if(n%2==0) str[0] = \\'a\\';\\n        \\n        return new String(str);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790000,
                "title": "java-solution-using-string-builder-and-arrays-fill",
                "content": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] string = new char[n];\\n        Arrays.fill(string, \\'a\\');\\n        if(n%2 == 0) string[n-1] = \\'b\\';\\n        \\n        return new String(string);\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String generateTheString(int n) {\\n        char[] string = new char[n];\\n        Arrays.fill(string, \\'a\\');\\n        if(n%2 == 0) string[n-1] = \\'b\\';\\n        \\n        return new String(string);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 782644,
                "title": "python-3-faster-than-99-less-memory-than-78",
                "content": "\\n\"\"\"\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2 == 0:\\n            return \\'a\\'*(n-1) + \\'b\\'\\n        return \\'a\\'*n\\n\"\"\"",
                "solutionTags": [],
                "code": "\\n\"\"\"\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2 == 0:\\n            return \\'a\\'*(n-1) + \\'b\\'\\n        return \\'a\\'*n\\n\"\"\"",
                "codeTag": "Java"
            },
            {
                "id": 732603,
                "title": "c-solution-o-1-100-speed-and-memory",
                "content": "```\\n\\nchar * generateTheString(int n){\\n    char *string = (char*)malloc((n+1)*sizeof(char));\\n    memset(string, \\'a\\', n);\\n    if(n%2==0)\\n        string[n-1]=\\'b\\';\\n    string[n]=\\'\\\\0\\';\\n    return string;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nchar * generateTheString(int n){\\n    char *string = (char*)malloc((n+1)*sizeof(char));\\n    memset(string, \\'a\\', n);\\n    if(n%2==0)\\n        string[n-1]=\\'b\\';\\n    string[n]=\\'\\\\0\\';\\n    return string;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 728811,
                "title": "very-easy-5-line-solution-100-fast",
                "content": "string generateTheString(int n) {\\n        string s=\"\";\\n        s.insert(0,n,\\'a\\');\\n        if(n%2==0)\\n            s[n-1]=\\'b\\';\\n        return s;  \\n    }",
                "solutionTags": [],
                "code": "string generateTheString(int n) {\\n        string s=\"\";\\n        s.insert(0,n,\\'a\\');\\n        if(n%2==0)\\n            s[n-1]=\\'b\\';\\n        return s;  \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 726426,
                "title": "go",
                "content": "How is this problem on LeetCode. I bet a 6th-grader could solve this problem on Minecraft Java Edition using red stones.\\n\\n```\\nfunc generateTheString(n int) string {\\n    res := make([]byte, n, n)\\n    \\n    idx := 0\\n    if n % 2 == 0 {\\n        res[idx] = \\'a\\';\\n        idx++\\n    }\\n    \\n    for ; idx < n; idx++ {\\n        res[idx] = \\'b\\'\\n    }\\n    return string(res)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc generateTheString(n int) string {\\n    res := make([]byte, n, n)\\n    \\n    idx := 0\\n    if n % 2 == 0 {\\n        res[idx] = \\'a\\';\\n        idx++\\n    }\\n    \\n    for ; idx < n; idx++ {\\n        res[idx] = \\'b\\'\\n    }\\n    return string(res)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 715364,
                "title": "python-one-line-solution-faster-than-95",
                "content": "```\\ndef generateTheString(self, n: int) -> str:\\n        return \"a\"*n if n&1 else \"a\"*(n-1)+\"b\"\\n```",
                "solutionTags": [],
                "code": "```\\ndef generateTheString(self, n: int) -> str:\\n        return \"a\"*n if n&1 else \"a\"*(n-1)+\"b\"\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 686728,
                "title": "o-logn-solution-implementing-string-repeat-method-in-a-readable-way",
                "content": "```\\nclass Solution {\\n    func generateTheString(_ n: Int) -> String {\\n        var outputString = String()\\n        if n % 2 == 0 {\\n            outputString = repeatCharacter(char: \"c\", count: n - 1)\\n            outputString.append(\"x\")\\n            return outputString\\n        }\\n        outputString = repeatCharacter(char: \"c\", count: n)\\n        return outputString\\n    }\\n    \\n    // Time complexity O(logn)\\n    func repeatCharacter(char: Character, count targetCount: Int) -> String {\\n        var outputString = String(char)\\n        \\n        // This is a computed property which gives you the \\n        // up to date value everytime its accessed\\n        var count: Int {\\n            return outputString.count\\n        }\\n        \\n        while count < targetCount {\\n            // If appending the string to itself will cause the count to exceed the desired count,\\n            // we find the num of char required to complete the output by finding the difference\\n            // and take a substring and append to itself\\n            if (count * 2) > targetCount {\\n                let startIndex = outputString.startIndex\\n                let endIndex = outputString.index(outputString.startIndex, offsetBy: targetCount - count)\\n                outputString.append(String(outputString[startIndex..<endIndex]))\\n            } else {\\n                // Append the string to itself\\n                outputString.append(outputString)\\n            }\\n        }\\n        return outputString\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func generateTheString(_ n: Int) -> String {\\n        var outputString = String()\\n        if n % 2 == 0 {\\n            outputString = repeatCharacter(char: \"c\", count: n - 1)\\n            outputString.append(\"x\")\\n            return outputString\\n        }\\n        outputString = repeatCharacter(char: \"c\", count: n)\\n        return outputString\\n    }\\n    \\n    // Time complexity O(logn)\\n    func repeatCharacter(char: Character, count targetCount: Int) -> String {\\n        var outputString = String(char)\\n        \\n        // This is a computed property which gives you the \\n        // up to date value everytime its accessed\\n        var count: Int {\\n            return outputString.count\\n        }\\n        \\n        while count < targetCount {\\n            // If appending the string to itself will cause the count to exceed the desired count,\\n            // we find the num of char required to complete the output by finding the difference\\n            // and take a substring and append to itself\\n            if (count * 2) > targetCount {\\n                let startIndex = outputString.startIndex\\n                let endIndex = outputString.index(outputString.startIndex, offsetBy: targetCount - count)\\n                outputString.append(String(outputString[startIndex..<endIndex]))\\n            } else {\\n                // Append the string to itself\\n                outputString.append(outputString)\\n            }\\n        }\\n        return outputString\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676111,
                "title": "java-solution-0-ms-100-simple",
                "content": "public String generateTheString(int n) {\\n        //string of length n\\n        //if string is odd length just return a string with the same char\\n        //if it is even: just add a different char to the last potision \\n    \\n        char[] ch = new char[n];\\n           \\n        for(int i = 0; i < n - 1; i++){\\n               ch[i] = \\'a\\';\\n            }\\n        \\n        if(n % 2 != 0){\\n            ch[n-1] = \\'a\\';\\n        }else{\\n            ch[n-1] = \\'b\\';\\n        }\\n\\n        return String.valueOf(ch);\\n    }",
                "solutionTags": [],
                "code": "public String generateTheString(int n) {\\n        //string of length n\\n        //if string is odd length just return a string with the same char\\n        //if it is even: just add a different char to the last potision \\n    \\n        char[] ch = new char[n];\\n           \\n        for(int i = 0; i < n - 1; i++){\\n               ch[i] = \\'a\\';\\n            }\\n        \\n        if(n % 2 != 0){\\n            ch[n-1] = \\'a\\';\\n        }else{\\n            ch[n-1] = \\'b\\';\\n        }\\n\\n        return String.valueOf(ch);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 675579,
                "title": "0ms-simple-c-code",
                "content": "```\\nchar * generateTheString(int n){\\n    if (n==0) return NULL;\\n    \\n    char *c = (char*)malloc((n+1)*sizeof(char));\\n    memset(c, \\'a\\', (n-1)*sizeof(char));\\n\\n    c[n-1] = n%2?\\'a\\':\\'b\\';\\n    c[n] = \\'\\\\0\\';\\n\\t\\n    return c;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * generateTheString(int n){\\n    if (n==0) return NULL;\\n    \\n    char *c = (char*)malloc((n+1)*sizeof(char));\\n    memset(c, \\'a\\', (n-1)*sizeof(char));\\n\\n    c[n-1] = n%2?\\'a\\':\\'b\\';\\n    c[n] = \\'\\\\0\\';\\n\\t\\n    return c;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 669204,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2 == 0 and (n//2)%2 != 0:\\n            return \\'a\\'*(n//2)+\\'b\\'*(n//2)\\n        elif n%2 == 0 and (n//2)%2 == 0:\\n            return \\'a\\'*((n//2)+1)+\\'b\\'*((n//2)-1)\\n        else:\\n            return \\'a\\'*n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def generateTheString(self, n: int) -> str:\\n        if n%2 == 0 and (n//2)%2 != 0:\\n            return \\'a\\'*(n//2)+\\'b\\'*(n//2)\\n        elif n%2 == 0 and (n//2)%2 == 0:\\n            return \\'a\\'*((n//2)+1)+\\'b\\'*((n//2)-1)\\n        else:\\n            return \\'a\\'*n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565787,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1575506,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1863251,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1835880,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1569803,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1938351,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1749928,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1966778,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1845042,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1826989,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1565787,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1575506,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1863251,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1835880,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1569803,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1938351,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1749928,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1966778,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1845042,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            },
            {
                "id": 1826989,
                "content": [
                    {
                        "username": "tanchiyuxx",
                        "content": "If interviewer give you such question, I think you could quite the interview directly. because this company will collapse in some day!"
                    },
                    {
                        "username": "prathishgm14",
                        "content": "Lol \\uD83D\\uDE02"
                    },
                    {
                        "username": "Ezdies",
                        "content": "This exerciste should be removed. Like if you agree :)"
                    },
                    {
                        "username": "vavilovnv",
                        "content": "Wow, I solved that. Will I get hired at google now? )))"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This question should be removed - I thought in the beggining.\n\nBut actually it helps to learn how to read task more carefully :) I liked this one even though it is strange :)"
                    },
                    {
                        "username": "user4503H",
                        "content": "\\tdef generateTheString(self, n: int) -> str:\\n\\t\\treturn \\'a\\' * (n - 1) + \\'b\\' if n % 2 == 0 else \\'a\\' * n"
                    },
                    {
                        "username": "Jason-Law",
                        "content": "Or `return \\'a\\' * n if n % 2 else \\'a\\' * (n - 1) + \\'b\\'` \\uD83D\\uDE05"
                    },
                    {
                        "username": "clrql",
                        "content": "there is no need to check if n%2 is equal to 0 just invert the return values in the ternary operator:\\n`      return n % 2 ? \"a\".repeat(n) : \"a\".repeat(n-1) + \"b\"     ` \\uD83D\\uDE44"
                    },
                    {
                        "username": "HamzaElkotb",
                        "content": "I hope this question came in google interview\\nJS Solution:\\n` \\nif(n%2==0) return \"a\".repeat(n-1)+\"b\";\\nreturn \"a\".repeat(n)\\n`"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "please don\\'t share complete answers in the discussion session, even if they fit on one line"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "My solution:  (doesn't work for some reason)\n\n`return \"x{}\".format(\"y\" * (n - 1)) if n % 2 == 0 else \"x{}\".format(\"y\" * n)`\n\n----\n\nThe solution taken from comments: (works for some reason)\n\n`return 'a' * (n - 1) + 'b' if n % 2 == 0 else 'a' * n`\n\nAhaa, I should use \"A\" and \"B\", instead of other characeters. Okay. \n\n-----\nActually, thanks to Leetcode, I found Zen.\n\n```\nSome people grew up in a normal family, whereas someone's mom was smoking, drinking during pregancy and saying 'this won't affect my kid.'\n\nPeople are different. We need to agree on that, and find our Zen.\n```\n"
                    },
                    {
                        "username": "PrashDev001",
                        "content": "1 Line\\nreturn n % 2 == 0 ? \"a\".repeat(n - 1) + \"b\" : \"a\".repeat(n);"
                    },
                    {
                        "username": "RendraAndriansyah",
                        "content": "I don\\'t get this question, isn\\'t make sense they accepted differences output & expected \\uD83E\\uDD14"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Times Binary String Is Prefix-Aligned",
        "question_content": "<p>You have a <strong>1-indexed</strong> binary string of length <code>n</code> where all the bits are <code>0</code> initially. We will flip all the bits of this binary string (i.e., change them from <code>0</code> to <code>1</code>) one by one. You are given a <strong>1-indexed</strong> integer array <code>flips</code> where <code>flips[i]</code> indicates that the bit at index <code>i</code> will be flipped in the <code>i<sup>th</sup></code> step.</p>\n\n<p>A binary string is <strong>prefix-aligned</strong> if, after the <code>i<sup>th</sup></code> step, all the bits in the <strong>inclusive</strong> range <code>[1, i]</code> are ones and all the other bits are zeros.</p>\n\n<p>Return <em>the number of times the binary string is <strong>prefix-aligned</strong> during the flipping process</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> flips = [3,2,4,1,5]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The binary string is initially &quot;00000&quot;.\nAfter applying step 1: The string becomes &quot;00100&quot;, which is not prefix-aligned.\nAfter applying step 2: The string becomes &quot;01100&quot;, which is not prefix-aligned.\nAfter applying step 3: The string becomes &quot;01110&quot;, which is not prefix-aligned.\nAfter applying step 4: The string becomes &quot;11110&quot;, which is prefix-aligned.\nAfter applying step 5: The string becomes &quot;11111&quot;, which is prefix-aligned.\nWe can see that the string was prefix-aligned 2 times, so we return 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> flips = [4,1,2,3]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The binary string is initially &quot;0000&quot;.\nAfter applying step 1: The string becomes &quot;0001&quot;, which is not prefix-aligned.\nAfter applying step 2: The string becomes &quot;1001&quot;, which is not prefix-aligned.\nAfter applying step 3: The string becomes &quot;1101&quot;, which is not prefix-aligned.\nAfter applying step 4: The string becomes &quot;1111&quot;, which is prefix-aligned.\nWe can see that the string was prefix-aligned 1 time, so we return 1.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == flips.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>flips</code> is a permutation of the integers in the range <code>[1, n]</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 532538,
                "title": "java-c-python-straight-forward-o-1-space",
                "content": "## **Explanation**\\n`right` is the number of the right most lighted bulb.\\n\\nIterate the input light `A`,\\nupdate `right = max(right, A[i])`.\\n\\nNow we have lighted up `i + 1` bulbs,\\nif `right == i + 1`,\\nit means that all the previous bulbs (to the left) are turned on too.\\nThen we increment `res`\\n<br>\\n\\n## **Complexity**\\nTime `O(N)`\\nSpace `O(1)`\\n<br>\\n\\n**Java:**\\n```java\\n    public int numTimesAllBlue(int[] A) {\\n        int right = 0, res = 0, n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            right = Math.max(right, A[i]);\\n            if (right == i + 1) ++res;\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    int numTimesAllBlue(vector<int>& A) {\\n        int right = 0, res = 0, n = A.size();\\n        for (int i = 0; i < n; ++i)\\n            res += (right = max(right, A[i])) == i + 1;\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n```py\\n    def numTimesAllBlue(self, A):\\n        right = res = 0\\n        for i, a in enumerate(A, 1):\\n            right = max(right, a)\\n            res += right == i\\n        return res\\n```\\n\\n**1-line Python3**\\nBy @ManuelP\\n```py\\ndef numTimesAllBlue(self, A):\\n    return sum(map(operator.eq, itertools.accumulate(A, max), itertools.count(1)))\\n```\\n```py\\ndef numTimesAllBlue(self, A):\\n    return sum(i == m for i, m in enumerate(itertools.accumulate(A, max), 1))\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int numTimesAllBlue(int[] A) {\\n        int right = 0, res = 0, n = A.length;\\n        for (int i = 0; i < n; ++i) {\\n            right = Math.max(right, A[i]);\\n            if (right == i + 1) ++res;\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int numTimesAllBlue(vector<int>& A) {\\n        int right = 0, res = 0, n = A.size();\\n        for (int i = 0; i < n; ++i)\\n            res += (right = max(right, A[i])) == i + 1;\\n        return res;\\n    }\\n```\n```py\\n    def numTimesAllBlue(self, A):\\n        right = res = 0\\n        for i, a in enumerate(A, 1):\\n            right = max(right, a)\\n            res += right == i\\n        return res\\n```\n```py\\ndef numTimesAllBlue(self, A):\\n    return sum(map(operator.eq, itertools.accumulate(A, max), itertools.count(1)))\\n```\n```py\\ndef numTimesAllBlue(self, A):\\n    return sum(i == m for i, m in enumerate(itertools.accumulate(A, max), 1))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 625201,
                "title": "python-99-explained-step-by-step-basic-python-tip",
                "content": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        res = hi = on = 0\\n        for l in light:\\n            on += 1\\n            if l>hi:\\n                hi = l\\n            if on==hi:\\n                res+=1\\n        return res\\n```\\n\\nso the idea is very simple:\\n\\nwe have an event (all lights are blue) only when all lights are on and there are no gaps.\\n\\nso let\\'s define 3 variables:\\n\\n`res` - this is the event counter\\n`hi` - this is the highest index of the bulb on\\n`on` - this is the number of bulbs on\\n\\n```\\nres = hi = on = 0\\n```\\n\\nNow we need to do some basic operations:\\n\\n1. Check bulbs one by one:\\n\\n```\\n        for l in light:\\n```\\n\\n2. For evey bulb we increment the number of bulbs on:\\n\\n```\\n            on += 1\\n```\\n\\n3. Also, we need to check if the highest index of a bulb on needs to be updated:\\n```\\n            if l>hi:\\n                hi = l\\n```\\n4. Finally, if all bulbs up to `hi` are on, then all bulbs are blue and we increment the counter:\\n```\\n            if on==hi:\\n                res+=1\\n```\\n5. Return the result:\\n```\\n        return res\\n```\\n\\n\\nInterestingly, replacing \\n```\\n            if l>hi:\\n                hi = l\\n```\\nwith\\n```\\n\\t\\thi = max(hi,l)\\n```\\nsaves a line but the tests show slower runtime (97% vs >99%) , so it looks like that extra line is worth it.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        res = hi = on = 0\\n        for l in light:\\n            on += 1\\n            if l>hi:\\n                hi = l\\n            if on==hi:\\n                res+=1\\n        return res\\n```\n```\\nres = hi = on = 0\\n```\n```\\n        for l in light:\\n```\n```\\n            on += 1\\n```\n```\\n            if l>hi:\\n                hi = l\\n```\n```\\n            if on==hi:\\n                res+=1\\n```\n```\\n        return res\\n```\n```\\n            if l>hi:\\n                hi = l\\n```\n```\\n\\t\\thi = max(hi,l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532478,
                "title": "c-checking-for-contiguous-sequence",
                "content": "**Observation**\\nWe can keep track of maximum `blue` bulbs that are switched on from the first bulb.\\nEverytime we switch on a bulb we can check if it forms a contiguous sequence of switched on bulbs/blue bulbs.\\nWhenever the number of blue bulbs is equal to the number of bulbs switched on we can add 1 to the result.\\nThe key here is to always start the check of contiguous sequence from the previous found end of the blue bulbs sequence.\\n\\n**Solution**\\n```c++\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) \\n    {\\n        vector<bool> on(light.size(),false);\\n        int maxBlue=0,result=0;\\n        for(int i=0;i<light.size();i++)\\n        {\\n            on[light[i]-1]=true;\\n            while(maxBlue<light.size()&&on[maxBlue])   //Increase the end of blue bulbs sequence starting from 0,\\n                maxBlue++;\\n            result+=maxBlue==i+1;                  \\t\\t//If number of blue bulbs is equal to number of switched on bulbs.\\n        }\\n        return result;\\n    }\\n};\\n```\\n**Complexity**\\nSpace: `O(n)`.\\nTime `O(n)`,",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) \\n    {\\n        vector<bool> on(light.size(),false);\\n        int maxBlue=0,result=0;\\n        for(int i=0;i<light.size();i++)\\n        {\\n            on[light[i]-1]=true;\\n            while(maxBlue<light.size()&&on[maxBlue])   //Increase the end of blue bulbs sequence starting from 0,\\n                maxBlue++;\\n            result+=maxBlue==i+1;                  \\t\\t//If number of blue bulbs is equal to number of switched on bulbs.\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532526,
                "title": "java-beautiful-math-to-rescue-sum-of-first-n-natural-numbers-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int n = light.length, ans = 0, currMax = 0;\\n        long currSum = 0;\\n        for(int i = 0; i < n; i++) {\\n            currMax = Math.max(currMax, light[i]);\\n            currSum += (long)light[i];\\n            if(currSum == ((long)currMax * (currMax + 1)) / 2) ans++;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int n = light.length, ans = 0, currMax = 0;\\n        long currSum = 0;\\n        for(int i = 0; i < n; i++) {\\n            currMax = Math.max(currMax, light[i]);\\n            currSum += (long)light[i];\\n            if(currSum == ((long)currMax * (currMax + 1)) / 2) ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 533357,
                "title": "java-unique-short-solution-with-explanation",
                "content": "So when looking at examples I noticed one thing:\\nwe only have all lights blue when we have all numbers from 1 to the current index in order.\\n\\nFollow me (let\\'s count indexes from 1 for demonstrartion):\\ninput [2,1,3,5,4]\\ninput[1] = 2, do we have 1, no\\ninput[2] = 1, do we have 1,2? yes - all lights blue\\ninput[3] = 3, do we have 1,2,3? yes - all lights blue\\ninput[4] = 5, do we have 1,2,3,4? no\\ninput[5] = 4, do we have 1,2,3,4,5? yes - all lights blue\\n\\nSo answer is 3. 3 times we had all numbers from 1 to current index in order.\\nHow do I implement it? You could use a sum, but during the contest I came up with this solution:\\nwe keep current max number we encountered. \\nIf the current iteration step is equals to that number then we have all numbers up to this in order.\\nIt works because we know we have all unique numbers from 1 to n.\\n\\ninput [2,1,3,5,4]\\ninput[1] = 2, maxIndexOn = 2. 2 !=1\\ninput[2] = 1, maxIndexOn = 2. 2 == 2 => blueCount++\\ninput[3] = 3, maxIndexOn = 3. 3 == 3 => blueCount++\\ninput[4] = 5, maxIndexOn = 5. 5 != 4\\ninput[5] = 4, maxIndexOn = 5. 5 == 5 => blueCount++\\n```\\npublic int numTimesAllBlue(int[] light) {\\n        int allBlueCount = 0;\\n        int maxIndexOn = 0;\\n        \\n        for (int i = 0; i < light.length; i++) {\\n            maxIndexOn = Math.max(maxIndexOn, light[i]);\\n            if (i + 1 == maxIndexOn) {\\n                allBlueCount++;\\n            }\\n        }\\n    \\n        return allBlueCount;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numTimesAllBlue(int[] light) {\\n        int allBlueCount = 0;\\n        int maxIndexOn = 0;\\n        \\n        for (int i = 0; i < light.length; i++) {\\n            maxIndexOn = Math.max(maxIndexOn, light[i]);\\n            if (i + 1 == maxIndexOn) {\\n                allBlueCount++;\\n            }\\n        }\\n    \\n        return allBlueCount;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532552,
                "title": "c-simple-maths-o-n-check-number-of-sorted-chunks-from-start-o-1-space",
                "content": "This problem is exactly same as [Sorted chunks](https://leetcode.com/problems/max-chunks-to-make-sorted/)\\n\\nI used the same approach to solve this problem, at any time sum2 will maintain the sum of elements of sorted array and sum1 will maintain the sum due to on-bulbs. When they both are same i.e. a blue moment! :D\\n\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int n = light.size();\\n        \\n        int chunk = 0, sum1 = 0, sum2 = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sum1 += light[i] - 1;\\n            sum2 += i;\\n            \\n            if(sum1 == sum2)\\n                chunk++;\\n        }\\n        return chunk;\\n    }\\n};\\n```\\n\\nTime : `O(n)`\\nSpace: `O(1)`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int n = light.size();\\n        \\n        int chunk = 0, sum1 = 0, sum2 = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            sum1 += light[i] - 1;\\n            sum2 += i;\\n            \\n            if(sum1 == sum2)\\n                chunk++;\\n        }\\n        return chunk;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532567,
                "title": "java-10-line-simple-solution-priorityqueue",
                "content": "if current maximum bulb number is equal to current index + 1 (because of the 0-based indices), the situation of bulbs satisfies the condition. \\nHere I used PriorityQueue to get the maximum bulb number.\\n```\\n\\tpublic int numTimesAllBlue(int[] light) {\\n        int count = 1;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n        for(int i = 0; i < light.length - 1; i++) {\\n            pq.offer(light[i]);\\n            if(pq.peek() == i + 1) \\n\\t\\t\\t\\tcount++;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic int numTimesAllBlue(int[] light) {\\n        int count = 1;\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> (b - a));\\n        for(int i = 0; i < light.length - 1; i++) {\\n            pq.offer(light[i]);\\n            if(pq.peek() == i + 1) \\n\\t\\t\\t\\tcount++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 544283,
                "title": "c-o-n-time-o-1-space-neat",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int> &light) {\\n        int rIdx = 0, cnt = 0, openCnt = 0;\\n        for (int i = 0; i < light.size(); i++) {\\n            openCnt++;\\n            rIdx = max(rIdx, light[i]);\\n            if (openCnt == rIdx) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int> &light) {\\n        int rIdx = 0, cnt = 0, openCnt = 0;\\n        for (int i = 0; i < light.size(); i++) {\\n            openCnt++;\\n            rIdx = max(rIdx, light[i]);\\n            if (openCnt == rIdx) {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1005071,
                "title": "python3-solution-99-with-detailed-explanation",
                "content": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        highest_bulb = 0 # keep track of the highest index bulb\\n        moments = 0      # keep track of the moments\\n        turned_on = 0    # keep track of the number of bulbs turned on\\n        \\n        for bulb in light:\\n            turned_on += 1\\n            \\n            if bulb > highest_bulb:\\n                highest_bulb = bulb\\n            \\n            if turned_on == highest_bulb:\\n                moments += 1\\n        return moments \\n```     \\n                           ####### EXPLANATION ##########\\n\\n#### When does a light turn blue? -> If it is turned on and all of the previous bulbs are also turned on\\n\\n#### Let\\'s say we\\'ve encountered three bulbs [4, 1, 2] so far\\n\\n#### Now for a moment to occur all the turned_on bulbs must also be blue\\n\\n### Bulbs that are turned on : [1, 2, 4]\\n\\n#### Bulbs that are blue: 1 (always turns blue after it\\'s on) , 2 (because 1 is on)\\n\\n#### Noticed that 4 is not blue? Why is that? => Because the 3 is missing \\n\\n#### From this we can see that moments depend on the highest bulb that has been encountered because if all previous bulbs for the highest bulb are turned_on then all of the lower index bulbs will also have their previous bulbs turned_on. \\n\\n\\n#### So we keep track of the highest bulb encountered and compare it against the number of bulbs that are turned so far\\n\\n## Why? \\n\\n#### Because we\\'ve turned on 4 bulbs and the highest bulb is 4 then that means bulbs 1, 2, 3, 4 must be turned on (only possible case). This is a moment where all turned on bulbs are also blue, you can cross check if you want to :) \\n\\n\\n            \\n            \\n        \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        highest_bulb = 0 # keep track of the highest index bulb\\n        moments = 0      # keep track of the moments\\n        turned_on = 0    # keep track of the number of bulbs turned on\\n        \\n        for bulb in light:\\n            turned_on += 1\\n            \\n            if bulb > highest_bulb:\\n                highest_bulb = bulb\\n            \\n            if turned_on == highest_bulb:\\n                moments += 1\\n        return moments \\n```",
                "codeTag": "Java"
            },
            {
                "id": 532518,
                "title": "java-easy-to-understand-amortized-o-1-for-each-light-operation-o-n-for-all",
                "content": "```Java\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int n = light.length;\\n        int[] status = new int[n]; // 0 -> off, 1 -> yellow, 2 -> blue\\n        int yellow = 0;\\n        int res = 0;\\n        for (int i: light) {\\n            status[i - 1] = 1;\\n            yellow++;\\n            if (i == 1 || status[i - 2] == 2) { // check if left light is in blue \\n                status[i - 1] = 2;\\n                yellow--;\\n                while (i < n && status[i] == 1) { // update all continuous yellow lights to blue in right\\n                    status[i] = 2;\\n                    yellow--;\\n                    i++;\\n                }\\n            }\\n            \\n            if (yellow == 0)\\n                res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Java\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int n = light.length;\\n        int[] status = new int[n]; // 0 -> off, 1 -> yellow, 2 -> blue\\n        int yellow = 0;\\n        int res = 0;\\n        for (int i: light) {\\n            status[i - 1] = 1;\\n            yellow++;\\n            if (i == 1 || status[i - 2] == 2) { // check if left light is in blue \\n                status[i - 1] = 2;\\n                yellow--;\\n                while (i < n && status[i] == 1) { // update all continuous yellow lights to blue in right\\n                    status[i] = 2;\\n                    yellow--;\\n                    i++;\\n                }\\n            }\\n            \\n            if (yellow == 0)\\n                res++;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884695,
                "title": "python-3-6-lines-w-explanation-t-m-90-96",
                "content": "Here\\'s the plan:\\n- The binary string is prefix-aligned if and only if the flips comprise a set of consecutive integers beginning with one (`123` is valid, `234` or `125` is not)\\n- The indices will always comprise a set of consecutive integers beginning with zero.\\n- The binary string is prefix-aligned after `k` flips if and only if `sum (i+1) = sum (flips[:i+1])` for `i < k`.\\n```\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n\\n        ans = fSum = iSum = 0\\n\\n        for i,flip in enumerate(flips):\\n\\n            fSum+= flip\\n            iSum+= i+1\\n\\n            ans+= (iSum==fSum)\\n\\n        return ans\\n\\n```\\n[https://leetcode.com/problems/number-of-times-binary-string-is-prefix-aligned/submissions/855688402/](http://)\\n\\n\\nI could be wrong, but I think that time is *O*(*N*) and space is *O*(1).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n\\n        ans = fSum = iSum = 0\\n\\n        for i,flip in enumerate(flips):\\n\\n            fSum+= flip\\n            iSum+= i+1\\n\\n            ans+= (iSum==fSum)\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900538,
                "title": "java-time-o-n-space-o-1-with-simple-explanation",
                "content": "Since all numbers are distinct and none can be repeated, for any index i, if the max till that is equal to i+1 then only all the switches are lit up. Because all the elements from 1 to i+1 are covered. We can simply prove this by taking contradiction. If we assume that one of the bulbs from 1 to i+1 is not on to complete the network, then we will obviously have another value greater than i+1 at a ceratin index which will be greater than our maximum(i+1) and hence we will have all the bulbs turned on at that new max index since all the bulbs from 1 to new max must be on to complete the network. \\n\\n```\\n    public int numTimesAllBlue(int[] light) {\\n        int max=light[0];\\n        int ans=0;\\n        for(int i=0;i<light.length; i++){\\n            if(light[i]>max)\\n                max=light[i];\\n            \\n            if(max==i+1)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numTimesAllBlue(int[] light) {\\n        int max=light[0];\\n        int ans=0;\\n        for(int i=0;i<light.length; i++){\\n            if(light[i]>max)\\n                max=light[i];\\n            \\n            if(max==i+1)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532602,
                "title": "python-greedy-method-o-n-time-and-o-1-space",
                "content": "The key point is updating the current max value while traversing, once we meet i + 1 == cur_max, then it means all the lights are blue.\\n```\\nclass Solution(object):\\n    def numTimesAllBlue(self, light):\\n        \"\"\"\\n        :type light: List[int]\\n        :rtype: int\\n        \"\"\"\\n        rst = 0\\n        cur_max = 0\\n        for i, l in enumerate(light):\\n            cur_max = max(cur_max, l)\\n            # everytime meet max, increase rst\\n            if i + 1 == cur_max:\\n                rst += 1\\n        return rst\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def numTimesAllBlue(self, light):\\n        \"\"\"\\n        :type light: List[int]\\n        :rtype: int\\n        \"\"\"\\n        rst = 0\\n        cur_max = 0\\n        for i, l in enumerate(light):\\n            cur_max = max(cur_max, l)\\n            # everytime meet max, increase rst\\n            if i + 1 == cur_max:\\n                rst += 1\\n        return rst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532493,
                "title": "python-one-pass",
                "content": "Let `right` be the index of the rightmost bulb we have lit so far. \\n```\\ndef numTimesAllBlue(light):\\n    cnt = right = 0\\n    for i, x in enumerate(light, 1):\\n        right = max(right, x)\\n        cnt += (right == i)\\n    return cnt\\n```\\nIf total number of bulbs we have lit (indicated by `i`) equals to `right`, then we have all lit bulbs being blue and we add `cnt`",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef numTimesAllBlue(light):\\n    cnt = right = 0\\n    for i, x in enumerate(light, 1):\\n        right = max(right, x)\\n        cnt += (right == i)\\n    return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 532489,
                "title": "c-set-manimuplation-compare-max-with-length",
                "content": "Method 1:\\n* Time Complexity: O(N)\\n* Space Complexity: O(N)\\n```cpp\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        set<int> bulbs;\\n        int ans(0);\\n        for (const int& i: light) {\\n            bulbs.insert(i);\\n            ans += *bulbs.rbegin() == bulbs.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\\nBy observation, we only care about the last element and the size of the set, and thus the space complexity can be reduced to O(1).\\nMethod 2:\\n* Time Complexity: O(N)\\n* Space Complexity: O(1)\\n```cpp\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int right(0), ans(0);\\n        for (int i = 0; i < light.size(); ++i) {\\n            right = max(right, light[i]);\\n            ans += right == i + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        set<int> bulbs;\\n        int ans(0);\\n        for (const int& i: light) {\\n            bulbs.insert(i);\\n            ans += *bulbs.rbegin() == bulbs.size();\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int right(0), ans(0);\\n        for (int i = 0; i < light.size(); ++i) {\\n            right = max(right, light[i]);\\n            ans += right == i + 1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061173,
                "title": "keep-track-of-the-largest-bit",
                "content": "# Intuition\\nTo solve this problem we need to note one intricacy that will always hold true\\n* Each bit only appears in `flips` once. \\n* Therefore, if bit x is on (one based), then it is only possible to be \"Prefix-Aligned\" if we are on flip x (also one based). \\n\\nWe can now keep track of the largest bit, and the number of flips. After each flip we can check if it is possible to be \"Prefix-Aligned\"\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* To keep the book keeping simple, we will count the number of flips starting at 1\\n* `largest_bit` will keep track of the largest bit\\n* `count` will keep track of the number of times we have been \"Prefix-Aligned\"\\n\\n# Complexity\\n- Time complexity `O(|flips|)`:\\nSingle pass through all the flips\\n\\n- Space complexity `O(1)`:\\nA few constant variables\\n\\n# Code\\n```\\n# Keep track of the largest bit that is on\\n\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        largest_bit = 0\\n        count = 0\\n        for i, bit in enumerate(flips, 1):\\n            largest_bit = max(largest_bit, bit)\\n            if largest_bit == i:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Keep track of the largest bit that is on\\n\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        largest_bit = 0\\n        count = 0\\n        for i, bit in enumerate(flips, 1):\\n            largest_bit = max(largest_bit, bit)\\n            if largest_bit == i:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1330283,
                "title": "python3-solution-o-n-time-and-o-1-space-complexity",
                "content": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        max = count = 0\\n        for i in range(len(light)):\\n            if max < light[i]:\\n                max = light[i]\\n            if max == i + 1:\\n                count += 1\\n        return count\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        max = count = 0\\n        for i in range(len(light)):\\n            if max < light[i]:\\n                max = light[i]\\n            if max == i + 1:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 643444,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int res=0;\\n        int right=0;\\n        for(int i=0;i<light.size();i++)\\n        {\\n            right=max(right,light[i]);\\n            if(right==i+1)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\nSuggestions are always welcome regarding improvement.",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int res=0;\\n        int right=0;\\n        for(int i=0;i<light.size();i++)\\n        {\\n            right=max(right,light[i]);\\n            if(right==i+1)\\n                res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575585,
                "title": "python-o-1-space",
                "content": "The Blue bulb contibutes to the answer only if all bulb left to it are turned blue and all bulb left to current bulb  are turned blue if and only if we have encountered all the elements less than current bulb(element),so here act represents the  sum when all the bulb to the left of current bulb are on and sm represents the actual sum we get from input . If at any moment , we found both to be equal, means all the bulb to the left are On and current bulb contributes to solution.\\n```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        c=0\\n        sm=0\\n        act=0\\n        for i in range(len(light)):\\n            sm+=light[i]\\n            act+=i+1\\n            if sm==act:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        c=0\\n        sm=0\\n        act=0\\n        for i in range(len(light)):\\n            sm+=light[i]\\n            act+=i+1\\n            if sm==act:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532696,
                "title": "java-o-1-space-one-pass-find-right-most-position",
                "content": "```\\npublic int numTimesAllBlue(int[] light) {\\n        int res=0;\\n        int right=1;\\n        for(int i=0;i<light.length;i++){\\n            right=Math.max(right,light[i]);\\n            if(right-1==i) res++;\\n        }\\n        return res;\\n    }\\n```\\n\\nWe can convert this question into finding the number of postion i where all numbers from 0th to ith are filled in the array.",
                "solutionTags": [],
                "code": "```\\npublic int numTimesAllBlue(int[] light) {\\n        int res=0;\\n        int right=1;\\n        for(int i=0;i<light.length;i++){\\n            right=Math.max(right,light[i]);\\n            if(right-1==i) res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1605600,
                "title": "easy-to-understand-c-solution",
                "content": "##### class Solution {***\\n##### public:\\n#####     int numTimesAllBlue(vector<int>& light) {\\n#####         int numofmoment=0;\\n#####        int sum1=0,sum2=0;\\n#####       for(int i=0;i<light.size();i++)\\n#####       {\\n#####           sum1+=light[i];\\n#####           sum2+=(i+1);\\n#####           if(sum1==sum2)\\n#####           {\\n#####               numofmoment++;\\n#####           }\\n##### \\n#####       }\\n#####         return numofmoment;\\n#####         \\n#####         \\n#####     }\\n##### };*",
                "solutionTags": [],
                "code": "class Solution {***\\n##### public:\\n#####     int numTimesAllBlue(vector<int>& light) {\\n#####         int numofmoment=0;\\n#####        int sum1=0,sum2=0;\\n#####       for(int i=0;i<light.size();i++)\\n#####       {\\n#####           sum1+=light[i];\\n#####           sum2+=(i+1);\\n#####           if(sum1==sum2)\\n#####           {\\n#####               numofmoment++;\\n#####           }",
                "codeTag": "Java"
            },
            {
                "id": 1336566,
                "title": "cpp-no-extra-space-linear-time-easy",
                "content": "```\\n// 1375. Bulb Switcher III\\n\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int res=0,countofbulbson=0,rightmostbulb=0;\\n        for(int i=0; i<light.size(); i++){\\n            rightmostbulb = max(rightmostbulb,light[i]);\\n            if(rightmostbulb==++countofbulbson) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// 1375. Bulb Switcher III\\n\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int res=0,countofbulbson=0,rightmostbulb=0;\\n        for(int i=0; i<light.size(); i++){\\n            rightmostbulb = max(rightmostbulb,light[i]);\\n            if(rightmostbulb==++countofbulbson) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1259425,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) \\n    {\\n        long long total=0, sum=0;\\n        int n=light.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum += i+1;\\n            total += light[i];\\n            if(sum==total)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) \\n    {\\n        long long total=0, sum=0;\\n        int n=light.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum += i+1;\\n            total += light[i];\\n            if(sum==total)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133177,
                "title": "python-easy-solution-99-faster-98-less-memory",
                "content": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        max=0\\n        c=0\\n        for i in range(len(light)):\\n            if(light[i]>max):\\n                max=light[i]\\n            if(max==i+1):\\n                c=c+1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        max=0\\n        c=0\\n        for i in range(len(light)):\\n            if(light[i]>max):\\n                max=light[i]\\n            if(max==i+1):\\n                c=c+1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1013386,
                "title": "java-o-n-video-tutorial",
                "content": "https://www.youtube.com/watch?v=2M3WSSyyRLY",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=2M3WSSyyRLY",
                "codeTag": "Unknown"
            },
            {
                "id": 896593,
                "title": "python-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution(object):\\n    def numTimesAllBlue(self, light):\\n        \"\"\"\\n        :type light: List[int]\\n        :rtype: int\\n        \"\"\"\\n        currentSum = answer = highest = 0\\n        for l in light:\\n            currentSum += l\\n            highest = max(highest, l)\\n\\t\\t\\tif (highest*(highest+1))/2 == currentSum:\\n\\t\\t\\t\\tanswer+=1\\n        return answer",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numTimesAllBlue(self, light):\\n        \"\"\"\\n        :type light: List[int]\\n        :rtype: int\\n        \"\"\"\\n        currentSum = answer = highest = 0\\n        for l in light:\\n            currentSum += l\\n            highest = max(highest, l)\\n\\t\\t\\tif (highest*(highest+1))/2 == currentSum:\\n\\t\\t\\t\\tanswer+=1\\n        return answer",
                "codeTag": "Java"
            },
            {
                "id": 865744,
                "title": "java-o-n-video-tutorial",
                "content": "https://www.youtube.com/watch?v=2M3WSSyyRLY",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=2M3WSSyyRLY",
                "codeTag": "Unknown"
            },
            {
                "id": 840501,
                "title": "python-o-1-space-easy-to-understand",
                "content": "All turned blue if and only if the number of turned on lights equals the max number of the turned on light index\\n```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        curr_max = 0\\n        res = 0\\n        for idx, val in enumerate(light):\\n            curr_max = max(curr_max, val)\\n            if curr_max == idx + 1:\\n                res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        curr_max = 0\\n        res = 0\\n        for idx, val in enumerate(light):\\n            curr_max = max(curr_max, val)\\n            if curr_max == idx + 1:\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835991,
                "title": "simple-java-solution-using-index-sum-and-switched-on-bulbs",
                "content": "```\\npublic int numTimesAllBlue(int[] light) {\\n\\tint switchedOnbulbsSum = 0, count = 0, indexSum = 0;\\n\\n\\tfor(int i=0; i<light.length; i++) {\\n\\t\\tswitchedOnbulbsSum+= light[i];\\n\\t\\tindexSum += i+1;\\n\\n\\t\\tif(switchedOnbulbsSum == indexSum) count++;\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numTimesAllBlue(int[] light) {\\n\\tint switchedOnbulbsSum = 0, count = 0, indexSum = 0;\\n\\n\\tfor(int i=0; i<light.length; i++) {\\n\\t\\tswitchedOnbulbsSum+= light[i];\\n\\t\\tindexSum += i+1;\\n\\n\\t\\tif(switchedOnbulbsSum == indexSum) count++;\\n\\t}\\n\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736001,
                "title": "c-o-n-solution-keep-track-of-the-right-most-bulb",
                "content": "```rightBulb``` keeps track of the right most bulb that is turned on at any moment\\n\\niterate the input array and keep updating the rightBulb variable with the right most bulb on.\\n\\nupdate rightBulb only if at ith postion the bulb that is turned on is greater than the already turned on rightMost bulb.\\n\\nso now we have lighted up ```i+1``` bulbs\\nthen we check ```if (rightBulb == i+1)```\\nthis means that all the bulbs to the left of rightBulb are switched on too.\\nthen we increment the ```count``` variable which keeps track of the number of times all bulbs that are turned on are blue. \\n```\\nint numTimesAllBlue(vector<int>& light) {\\n\\tint rightBulb = -1;\\n\\tint count = 0, len = light.size();\\n\\tfor(int i = 0; i < len; i++){\\n\\t\\trightBulb = max(rightBulb , light[i]);\\n\\t\\tif(rightBulb == i + 1){\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```\\n****Complexity:****\\ntime = O(n)\\nspace = O(1)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```rightBulb```\n```i+1```\n```if (rightBulb == i+1)```\n```count```\n```\\nint numTimesAllBlue(vector<int>& light) {\\n\\tint rightBulb = -1;\\n\\tint count = 0, len = light.size();\\n\\tfor(int i = 0; i < len; i++){\\n\\t\\trightBulb = max(rightBulb , light[i]);\\n\\t\\tif(rightBulb == i + 1){\\n\\t\\t\\tcount++;\\n\\t\\t}\\n\\t}\\n\\treturn count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 533595,
                "title": "javascript-simple-solution-time-o-n-and-space-o-1",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(1)\\n\\n```\\nvar numTimesAllBlue = function(light) {\\n    let total = 0;\\n    let target = 0;\\n    let moments = 0;\\n    \\n    for(let i = 0; i < light.length; i++){\\n        total += light[i];      // add up all the bulbs number\\n        target += i + 1;        // add up the index of each array plus 1\\n        \\n        if(total === target) moments++;\\n    }    \\n    \\n    return moments;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numTimesAllBlue = function(light) {\\n    let total = 0;\\n    let target = 0;\\n    let moments = 0;\\n    \\n    for(let i = 0; i < light.length; i++){\\n        total += light[i];      // add up all the bulbs number\\n        target += i + 1;        // add up the index of each array plus 1\\n        \\n        if(total === target) moments++;\\n    }    \\n    \\n    return moments;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532708,
                "title": "tracking-sum-linear-o-1-space",
                "content": "I used sum variable to add as I go through the array then check if i * (i + 1) / 2 == sum then I will increment my counter\\n```\\n    int numTimesAllBlue(vector<int>& light) {\\n        long int sum = 0;\\n        int n = light.size();\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            long long int num = i + 1, num2 = i + 2;\\n            sum += light[i];\\n            if (sum == num * num2 / 2) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    int numTimesAllBlue(vector<int>& light) {\\n        long int sum = 0;\\n        int n = light.size();\\n        int count = 0;\\n        for (int i = 0; i < n; i++) {\\n            long long int num = i + 1, num2 = i + 2;\\n            sum += light[i];\\n            if (sum == num * num2 / 2) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532640,
                "title": "c-python3-maintain-a-prefix-of-shining-bulbs",
                "content": "There is a line of bulbs. Each moment an off bulb is turned on. How many moments are there when all bulbs has all bulbs on its left (and itself) on (called \"shine\")?\\n\\n# Explanation\\n\\nInstead of turning on the bulbs one by one, we first light up all the bulbs and turn them off one by one. At each moment, only a prefix of bulbs can \"shine\", which has no off bulbs in them. And the end of the shining bulbs must be an off bulb (or all bulbs are shining). \\n\\nEach time when a bulb is turned off, check if the bulb is in the \"prefix\". If not, then the \"prefix\" stays shining. Else, update the length of the \"prefix\" by the position of the off bulb.\\n\\n# C++ Solution\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numShineMoment(vector<int>& light) {\\n        int ans = 0, n = light.size();\\n        bool on[50005];\\n        memset(on, 1, sizeof(on));\\n        int on_cnt = n;\\n        int shine_cnt = n;\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            if (on_cnt == shine_cnt) ans++;\\n            on_cnt--;\\n            if (light[i] <= shine_cnt)\\n                shine_cnt = light[i] - 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n# Python3 Solution\\n\\n```python\\nclass Solution:\\n    def numShineMoment(self, light: List[int]) -> int:\\n        ans = 0\\n        n = len(light)\\n        on = [1] * n\\n        on_cnt = n\\n        shine_cnt = n\\n        for i in range(n - 1, -1, -1):\\n            if on_cnt == shine_cnt:\\n                ans += 1\\n            on_cnt -= 1\\n            if light[i] <= shine_cnt:\\n                shine_cnt = light[i] - 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numShineMoment(vector<int>& light) {\\n        int ans = 0, n = light.size();\\n        bool on[50005];\\n        memset(on, 1, sizeof(on));\\n        int on_cnt = n;\\n        int shine_cnt = n;\\n        \\n        for (int i = n - 1; i >= 0; i--) {\\n            if (on_cnt == shine_cnt) ans++;\\n            on_cnt--;\\n            if (light[i] <= shine_cnt)\\n                shine_cnt = light[i] - 1;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def numShineMoment(self, light: List[int]) -> int:\\n        ans = 0\\n        n = len(light)\\n        on = [1] * n\\n        on_cnt = n\\n        shine_cnt = n\\n        for i in range(n - 1, -1, -1):\\n            if on_cnt == shine_cnt:\\n                ans += 1\\n            on_cnt -= 1\\n            if light[i] <= shine_cnt:\\n                shine_cnt = light[i] - 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532546,
                "title": "python-o-n-compare-current-sum-with-supposed-sum",
                "content": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        res = 0\\n        curr_sum = 0\\n        object_sum = 0\\n        for i, bulb in enumerate(light):\\n            object_sum += i + 1\\n            curr_sum += bulb\\n            if curr_sum == object_sum:\\n                res += 1\\n        return res\\n ```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        res = 0\\n        curr_sum = 0\\n        object_sum = 0\\n        for i, bulb in enumerate(light):\\n            object_sum += i + 1\\n            curr_sum += bulb\\n            if curr_sum == object_sum:\\n                res += 1\\n        return res\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 532528,
                "title": "python-5-liner-o-n-time-o-1-space",
                "content": "```\\nclass Solution(object):\\n    def numTimesAllBlue(self, light):\\n        res,cur_max = 0, 0\\n        for n,i in enumerate(light):\\n            cur_max = max(i,cur_max)\\n            if cur_max == n+1:  res += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numTimesAllBlue(self, light):\\n        res,cur_max = 0, 0\\n        for n,i in enumerate(light):\\n            cur_max = max(i,cur_max)\\n            if cur_max == n+1:  res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375971,
                "title": "easy-c-solution-using-priority-queue",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n      priority_queue<int> maxh;\\n      int cnt=0;\\n      for(int i=0; i<flips.size(); i++){\\n          maxh.push(flips[i]);\\n\\n          if(maxh.size()==maxh.top()){\\n              cnt++;\\n          }\\n      }\\n      return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n      priority_queue<int> maxh;\\n      int cnt=0;\\n      for(int i=0; i<flips.size(); i++){\\n          maxh.push(flips[i]);\\n\\n          if(maxh.size()==maxh.top()){\\n              cnt++;\\n          }\\n      }\\n      return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2950286,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int n = flips.size(), ans = 0, p = 0, last = 0;\\n        vector<int> v(n);\\n\\n        for(int i : flips) {\\n            v[i - 1] = 1;\\n            last = max(last, i - 1);\\n            while(p < n && v[p]) p++;\\n            if(p == last + 1) ans++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int n = flips.size(), ans = 0, p = 0, last = 0;\\n        vector<int> v(n);\\n\\n        for(int i : flips) {\\n            v[i - 1] = 1;\\n            last = max(last, i - 1);\\n            while(p < n && v[p]) p++;\\n            if(p == last + 1) ans++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172662,
                "title": "c-easy-to-understand-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int c=0;\\n        int last_one=0;\\n        int n=flips.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            last_one=max(last_one,flips[i]);\\n            if(last_one==i+1)\\n            {\\n                cout<<i<<endl;\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int c=0;\\n        int last_one=0;\\n        int n=flips.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            last_one=max(last_one,flips[i]);\\n            if(last_one==i+1)\\n            {\\n                cout<<i<<endl;\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1188876,
                "title": "simple-o-n-java-solution",
                "content": "```\\npublic int numTimesAllBlue1(int[] light) {\\n        int rightMax = -1 , count = 0;\\n        for(int i=0 ; i<light.length ; i++){\\n            if(light[i]>rightMax)\\n                rightMax = light[i];\\n\\n            if(i+1==rightMax)\\n                count++;\\n        }\\n\\n        return count;\\n    }\\n\\t\\n\\t//Here i+1 is the number of bulbs that are switched on and if number of bulbs that are switched on is equal to\\n\\t//right most bulb that is switched on that means all the bulbs upto that right most bulb are switched on and\\n\\t//thus all will be blue at that moment\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numTimesAllBlue1(int[] light) {\\n        int rightMax = -1 , count = 0;\\n        for(int i=0 ; i<light.length ; i++){\\n            if(light[i]>rightMax)\\n                rightMax = light[i];\\n\\n            if(i+1==rightMax)\\n                count++;\\n        }\\n\\n        return count;\\n    }\\n\\t\\n\\t//Here i+1 is the number of bulbs that are switched on and if number of bulbs that are switched on is equal to\\n\\t//right most bulb that is switched on that means all the bulbs upto that right most bulb are switched on and\\n\\t//thus all will be blue at that moment\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1169147,
                "title": "c-o-n-time-and-o-1-space-solutin",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        \\n        int mx=INT_MIN;\\n        int ans=0;\\n        for(int i=0;i<light.size();i++){\\n            mx=max(light[i],mx);\\n            if(mx==i+1)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        \\n        int mx=INT_MIN;\\n        int ans=0;\\n        for(int i=0;i<light.size();i++){\\n            mx=max(light[i],mx);\\n            if(mx==i+1)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114277,
                "title": "o-n-java-solution",
                "content": "The idea is: A blue bulb glows only when all the bulbs before it are already glowing.\\nSo keep track of the largest bulb in the array till iteration i.\\nif the total flipped bulbs till iteration i  is equal to the largest bulb then the blue glows blue as all the previous bulbs are turned on. :)\\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        \\n        int largest_bulb = Integer.MIN_VALUE;\\n        int total_flipped = 0;\\n        int blue = 0;\\n        \\n        for(int i=0;i<light.length;i++)\\n        {\\n            int current = light[i];\\n            total_flipped++;\\n            largest_bulb = Math.max(largest_bulb,current);\\n            \\n            if(total_flipped == largest_bulb)\\n                blue++;\\n        }\\n        return blue;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        \\n        int largest_bulb = Integer.MIN_VALUE;\\n        int total_flipped = 0;\\n        int blue = 0;\\n        \\n        for(int i=0;i<light.length;i++)\\n        {\\n            int current = light[i];\\n            total_flipped++;\\n            largest_bulb = Math.max(largest_bulb,current);\\n            \\n            if(total_flipped == largest_bulb)\\n                blue++;\\n        }\\n        return blue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1110699,
                "title": "python-solution-one-pass-with-comments",
                "content": "class Solution:\\n\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        ans = 0\\n        m = 0 # record the maximum light we turned on before \\n        for i,x in enumerate(light):\\n            m = max(x,m)\\n            if m == i+1: # if the m == i+1, it means all lights before m have been turned on \\n                ans+=1\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        ans = 0\\n        m = 0 # record the maximum light we turned on before \\n        for i,x in enumerate(light):\\n            m = max(x,m)\\n            if m == i+1: # if the m == i+1, it means all lights before m have been turned on \\n                ans+=1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 931505,
                "title": "c-o-n-o-1-using-consecutive-sum",
                "content": "class Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n       long long i,j=0;long long c;\\n        int k=0;\\n        for(i=0;i<light.size();i++)\\n        {\\n            j=j+light[i];\\n            c=(i+1);\\n            c=c*(i+2);\\n            c=c/2;\\n            if(j==c)\\n                k++;\\n            \\n        }\\n        return k;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n       long long i,j=0;long long c;\\n        int k=0;\\n        for(i=0;i<light.size();i++)\\n        {\\n            j=j+light[i];\\n            c=(i+1);\\n            c=c*(i+2);\\n            c=c/2;\\n            if(j==c)\\n                k++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 922850,
                "title": "c-o-n-time-and-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int res = 0;\\n        int mx = 0, bulbs = 0;\\n        \\n        for(int i = 0; i < light.size(); i++){\\n            mx = max(mx, light[i]);\\n            bulbs++;\\n            if(mx == bulbs) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int res = 0;\\n        int mx = 0, bulbs = 0;\\n        \\n        for(int i = 0; i < light.size(); i++){\\n            mx = max(mx, light[i]);\\n            bulbs++;\\n            if(mx == bulbs) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922589,
                "title": "java-100-fast-o-1-space-using-natural-numbers-sum-property",
                "content": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int ans=0,sum=0,blue=0;\\n        for(int i=0;i<light.length;i++)\\n        {\\n            sum+=(i+1);\\n            blue+=light[i];\\n            if(sum==blue)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int ans=0,sum=0,blue=0;\\n        for(int i=0;i<light.length;i++)\\n        {\\n            sum+=(i+1);\\n            blue+=light[i];\\n            if(sum==blue)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 885309,
                "title": "c-o-n-time-o-1-space-with-easy-explanation-short-code",
                "content": "The aim is to keep track of number of lit bulbs and if all the bulbs are lit, then we increment our answer.\\nSo we maintain a variable `maxi` for the position of highest number lit bulb. If the highest number lit bulb is equal to the total number of lit bulbs then we can say all the currently lit bulbs are in a sequence and hence all are blue.\\n```\\n    int numTimesAllBlue(vector<int>& light) {\\n        int res = 0, maxi = 0;\\n        for(int i=0;i<light.size();i++)\\n        {\\n            maxi = max(maxi,light[i]);\\n            if(maxi==i+1) res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numTimesAllBlue(vector<int>& light) {\\n        int res = 0, maxi = 0;\\n        for(int i=0;i<light.size();i++)\\n        {\\n            maxi = max(maxi,light[i]);\\n            if(maxi==i+1) res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 847623,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int maxm = -1;\\n        int ans = 0;\\n        for(int i = 0 ; i < light.size() ; ++i){\\n            maxm = max(maxm, light[i]);\\n            if(maxm == i + 1)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int maxm = -1;\\n        int ans = 0;\\n        for(int i = 0 ; i < light.size() ; ++i){\\n            maxm = max(maxm, light[i]);\\n            if(maxm == i + 1)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842162,
                "title": "java-very-simple-o-n",
                "content": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {        \\n        int moments = 0;\\n        \\n        int maxBulb = Integer.MIN_VALUE;\\n        int turnedOnCount = 0;\\n        for(int bulb : light) {\\n            turnedOnCount++;\\n            maxBulb = Math.max(maxBulb, bulb);\\n            if(maxBulb == turnedOnCount) {\\n                moments++;\\n            }\\n        }\\n        \\n        return moments;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {        \\n        int moments = 0;\\n        \\n        int maxBulb = Integer.MIN_VALUE;\\n        int turnedOnCount = 0;\\n        for(int bulb : light) {\\n            turnedOnCount++;\\n            maxBulb = Math.max(maxBulb, bulb);\\n            if(maxBulb == turnedOnCount) {\\n                moments++;\\n            }\\n        }\\n        \\n        return moments;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780444,
                "title": "c-time-complexity-o-n-space-complexity-o-1",
                "content": "```\\npublic static int NumTimesAllBlue(int[] light)\\n        {\\n            int count = 0;\\n            int lastOnLampIndex = 0;\\n            for (int i = 0; i < light.Length; i++)\\n            {\\n                lastOnLampIndex = Math.Max(lastOnLampIndex, light[i]);\\n                if (lastOnLampIndex == i + 1)\\n                    count++;\\n            }\\n            return count;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int NumTimesAllBlue(int[] light)\\n        {\\n            int count = 0;\\n            int lastOnLampIndex = 0;\\n            for (int i = 0; i < light.Length; i++)\\n            {\\n                lastOnLampIndex = Math.Max(lastOnLampIndex, light[i]);\\n                if (lastOnLampIndex == i + 1)\\n                    count++;\\n            }\\n            return count;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 617100,
                "title": "python-math-approach",
                "content": "```\\nclass Solution(object):\\n    def numTimesAllBlue(self, light):\\n        sum_day = 0\\n        sum_bulb = 0\\n        count = 0\\n        for i in range(len(light)):\\n            sum_day += i + 1\\n            sum_bulb += light[i]\\n            if sum_day == sum_bulb:\\n                count += 1\\n        \\n        return count",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numTimesAllBlue(self, light):\\n        sum_day = 0\\n        sum_bulb = 0\\n        count = 0\\n        for i in range(len(light)):\\n            sum_day += i + 1\\n            sum_bulb += light[i]\\n            if sum_day == sum_bulb:\\n                count += 1\\n        \\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 615794,
                "title": "c-easy-logical-solution",
                "content": "class Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n       long long int n=light.size();\\n         if(n==0)\\n           return 0;\\n      long long int sum1=0;\\n      long long int sum2=0;\\n       long long int count=0;\\n      for(long long int i=0;i<n;i++)\\n      {\\n        sum1+=(i+1);\\n        sum2+=light[i];\\n        if(sum1==sum2)\\n          count++;\\n      }\\n      \\n      return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n       long long int n=light.size();\\n         if(n==0)\\n           return 0;\\n      long long int sum1=0;\\n      long long int sum2=0;\\n       long long int count=0;\\n      for(long long int i=0;i<n;i++)\\n      {\\n        sum1+=(i+1);\\n        sum2+=light[i];\\n        if(sum1==sum2)\\n          count++;\\n      }",
                "codeTag": "Java"
            },
            {
                "id": 615068,
                "title": "java-1ms-100-time-100-space-using-totalsum",
                "content": "```\\n /* Idea : When the actualSum and expectedSum are equal, that means all the left side bulbs are covered\\n    */\\n    private int numTimesAllBlue(int[] light){\\n       int i = 1;\\n       int expectedSum = 0;\\n       int actualSum = 0; \\n       int ans = 0; \\n       for(int num:light){\\n           actualSum += num;\\n           expectedSum += i;\\n           if(actualSum == expectedSum) ans++;\\n           i++;\\n       }\\n       return ans; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n /* Idea : When the actualSum and expectedSum are equal, that means all the left side bulbs are covered\\n    */\\n    private int numTimesAllBlue(int[] light){\\n       int i = 1;\\n       int expectedSum = 0;\\n       int actualSum = 0; \\n       int ans = 0; \\n       for(int num:light){\\n           actualSum += num;\\n           expectedSum += i;\\n           if(actualSum == expectedSum) ans++;\\n           i++;\\n       }\\n       return ans; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 587023,
                "title": "c-super-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        \\n        int n = light.size();\\n        int sum1 = 0, sum2 = 0, count = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += light[i];\\n            sum2 += (i+1);\\n            if (sum1 == sum2)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        \\n        int n = light.size();\\n        int sum1 = 0, sum2 = 0, count = 0;\\n        for (int i = 0; i < n; i++) {\\n            sum1 += light[i];\\n            sum2 += (i+1);\\n            if (sum1 == sum2)\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582641,
                "title": "java-100-space-and-100-runtime",
                "content": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int ans = 0, max = 0;\\n        for(int i = 0 ; i < light.length ; i++)\\n        {\\n            if(max < light[i]) max = light[i];\\n            if(max == (i+1)) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int ans = 0, max = 0;\\n        for(int i = 0 ; i < light.length ; i++)\\n        {\\n            if(max < light[i]) max = light[i];\\n            if(max == (i+1)) ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 558175,
                "title": "java-o-n-simple-solution",
                "content": "```\\npublic int numTimesAllBlue(int[] light) {\\n        int rightMostLight = 0;\\n        int blueMoments = 0;\\n        int onLights = 0;\\n        \\n        for(int index = 0; index < light.length; index++){\\n            rightMostLight = Math.max(rightMostLight, light[index]);\\n            onLights++;\\n            \\n            if(rightMostLight == onLights){\\n                blueMoments++;\\n            }\\n        }\\n        \\n        \\n        return blueMoments;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numTimesAllBlue(int[] light) {\\n        int rightMostLight = 0;\\n        int blueMoments = 0;\\n        int onLights = 0;\\n        \\n        for(int index = 0; index < light.length; index++){\\n            rightMostLight = Math.max(rightMostLight, light[index]);\\n            onLights++;\\n            \\n            if(rightMostLight == onLights){\\n                blueMoments++;\\n            }\\n        }\\n        \\n        \\n        return blueMoments;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 556477,
                "title": "simplest-ever-c-solution-o-n-o-1",
                "content": "My bulbs turn blue if at any point, I have all the elements upto the max element (till now)\\nAt every step, *i* tells me the number of elements traversed except the current element (obvious)\\nSo at every step, I keep checking if I have *(max-1)* (*max* = max till now) elements (which will all be obviously smaller than max).\\n\\n```\\nfor(int i = 0; i < n; i++){\\n\\tif(A[i] > max) max = A[i];\\n\\tif(max - i == 1) answer++;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfor(int i = 0; i < n; i++){\\n\\tif(A[i] > max) max = A[i];\\n\\tif(max - i == 1) answer++;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 542920,
                "title": "optimized-go-solution-faster-than-90-08-of-go-online-submissions",
                "content": "* Runtime: 56 ms, faster than 90.08% of Go online submissions for Bulb Switcher III.\\n* Memory Usage: 7 MB, less than 100.00% of Go online submissions for Bulb Switcher III.\\n\\n\\n<img src=\"https://assets.leetcode.com/users/dhiatn/image_1584489695.png\" width=\"40%\" style=\"margin: 0 0 25px 25px\">\\n\\n```go\\nfunc numTimesAllBlue(A []int) int {\\n    maxOnBulb := 0\\n\\ttimesAllBlue := 0\\n\\n\\tfor i, bulbNum := range A {\\n\\t\\tif bulbNum > maxOnBulb {\\n\\t\\t\\tmaxOnBulb = bulbNum\\n\\t\\t}\\n\\t\\tif maxOnBulb == i + 1 {\\n\\t\\t\\ttimesAllBlue++\\n\\t\\t}\\n\\t}\\n   return timesAllBlue\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc numTimesAllBlue(A []int) int {\\n    maxOnBulb := 0\\n\\ttimesAllBlue := 0\\n\\n\\tfor i, bulbNum := range A {\\n\\t\\tif bulbNum > maxOnBulb {\\n\\t\\t\\tmaxOnBulb = bulbNum\\n\\t\\t}\\n\\t\\tif maxOnBulb == i + 1 {\\n\\t\\t\\ttimesAllBlue++\\n\\t\\t}\\n\\t}\\n   return timesAllBlue\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537485,
                "title": "python-3-one-line-o-1-space-faster-than-100",
                "content": "# Explanation\\n\\n1. Use `itertools.accumulate(nums, max)` to generate running maximums\\n2. Anytime the running max == the number of elements we\\'ve seen, all lightbulbs are blue\\n\\n# Code\\n\\n```python\\nclass Solution:\\n  def numTimesAllBlue(self, nums: List[int]) -> int:\\n    return sum(i == val for i, val in enumerate(itertools.accumulate(nums, max), 1))\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n  def numTimesAllBlue(self, nums: List[int]) -> int:\\n    return sum(i == val for i, val in enumerate(itertools.accumulate(nums, max), 1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537348,
                "title": "c-unusual-method-fenwick-tree-and-union-find",
                "content": "1. Fenwick Tree\\n```\\nclass FenwickTree {\\npublic:\\n    FenwickTree(int n):sums(n + 1, 0) {}\\n    \\n    void update(int i, int delta) {\\n        while(i < sums.size()) {\\n            sums[i] += delta;\\n            i += lowbit(i);\\n        }\\n    }\\n    \\n    int query(int i) {\\n        int sum = 0;\\n        while(i > 0) {\\n            sum += sums[i];\\n            i -= lowbit(i);\\n        }\\n        return sum;\\n    }\\nprivate:\\n    vector<int> sums;\\n    int lowbit(int x) {\\n        return x & (-x);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        const int n = light.size();\\n        auto tree = new FenwickTree(n + 1);\\n        unordered_set<int> on;\\n        \\n        int cnt = 0;\\n        for(int idx : light) {\\n            tree->update(idx, 1);\\n            if(tree->query(idx) == idx) {\\n                while(on.count(idx + 1)) {\\n                    on.erase(++idx);\\n                }\\n                if(on.size() == 0)\\n                    cnt++;\\n            }else {\\n                on.insert(idx);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n2. UnionFind \\n```\\nclass DSU {\\nprivate:\\n    vector<int> pa;\\n    vector<int> rank;\\n    \\npublic:\\n    DSU(int n){\\n        pa = vector<int>(n + 1, 0);\\n        rank = vector<int>(n + 1, 0);\\n        for(int i = 0; i < n + 1; ++i)\\n            pa[i] = i;\\n    }\\n    \\n    int find(int x) {\\n        return pa[x] = (pa[x] == x ? x : find(pa[x]));\\n    }\\n    \\n    void merge(int a, int b) {\\n        int fa = find(a), fb = find(b);\\n        if(fa == fb) return;\\n        if(rank[fa] > rank[fb])\\n            pa[fb] = fa;\\n        else if(rank[fa] < rank[fb])\\n            pa[fa] = fb;\\n        else {\\n            pa[fa] = fb;\\n            rank[fa] += 1;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int n = light.size();\\n        auto dsu = new DSU(n);\\n        \\n        vector<bool> islight(n + 1, false);\\n        int cur = 0, ans = 0;\\n        for(int i = 0; i < n; ++i) {\\n            int k = light[i];\\n            \\n            islight[k] = true;\\n            if(k > 1 && islight[k - 1]) dsu->merge(k-1, k);\\n            if(k + 1 <= n && islight[k + 1]) dsu->merge(k + 1, k);\\n            \\n            cur += 1;\\n            if(islight[1] && dsu->find(cur) == dsu->find(1)) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass FenwickTree {\\npublic:\\n    FenwickTree(int n):sums(n + 1, 0) {}\\n    \\n    void update(int i, int delta) {\\n        while(i < sums.size()) {\\n            sums[i] += delta;\\n            i += lowbit(i);\\n        }\\n    }\\n    \\n    int query(int i) {\\n        int sum = 0;\\n        while(i > 0) {\\n            sum += sums[i];\\n            i -= lowbit(i);\\n        }\\n        return sum;\\n    }\\nprivate:\\n    vector<int> sums;\\n    int lowbit(int x) {\\n        return x & (-x);\\n    }\\n};\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        const int n = light.size();\\n        auto tree = new FenwickTree(n + 1);\\n        unordered_set<int> on;\\n        \\n        int cnt = 0;\\n        for(int idx : light) {\\n            tree->update(idx, 1);\\n            if(tree->query(idx) == idx) {\\n                while(on.count(idx + 1)) {\\n                    on.erase(++idx);\\n                }\\n                if(on.size() == 0)\\n                    cnt++;\\n            }else {\\n                on.insert(idx);\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass DSU {\\nprivate:\\n    vector<int> pa;\\n    vector<int> rank;\\n    \\npublic:\\n    DSU(int n){\\n        pa = vector<int>(n + 1, 0);\\n        rank = vector<int>(n + 1, 0);\\n        for(int i = 0; i < n + 1; ++i)\\n            pa[i] = i;\\n    }\\n    \\n    int find(int x) {\\n        return pa[x] = (pa[x] == x ? x : find(pa[x]));\\n    }\\n    \\n    void merge(int a, int b) {\\n        int fa = find(a), fb = find(b);\\n        if(fa == fb) return;\\n        if(rank[fa] > rank[fb])\\n            pa[fb] = fa;\\n        else if(rank[fa] < rank[fb])\\n            pa[fa] = fb;\\n        else {\\n            pa[fa] = fb;\\n            rank[fa] += 1;\\n        }\\n    }\\n};\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int n = light.size();\\n        auto dsu = new DSU(n);\\n        \\n        vector<bool> islight(n + 1, false);\\n        int cur = 0, ans = 0;\\n        for(int i = 0; i < n; ++i) {\\n            int k = light[i];\\n            \\n            islight[k] = true;\\n            if(k > 1 && islight[k - 1]) dsu->merge(k-1, k);\\n            if(k + 1 <= n && islight[k + 1]) dsu->merge(k + 1, k);\\n            \\n            cur += 1;\\n            if(islight[1] && dsu->find(cur) == dsu->find(1)) ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533467,
                "title": "java-simple-solution-runtime-o-n-and-space-o-1",
                "content": "This solution is based off the idea that in order for all of the bulbs to be blue, the bulbs seen should sum up to the running sum of the index. It is easier to understand with an example: \\n\\nif n = 6 and light = [2,1,4,3,6,5] {0 := off, 1:= on, 2:= blue}\\n|   | 1 | 2 | 3 | 4 | 5 | 6 |   | bulbs seen sum | sum of indices |\\n|---|---|---|---|---|---|---|---|------------|----------------|\\n| i | 0 | 0 | 0 | 0 | 0 | 0 |   | 0          | 0              |\\n| 1 | 0 | 1 | 0 | 0 | 0 | 0 |   | 2          | 1              |\\n| 2 | 2 | 2 | 0 | 0 | 0 | 0 |   | 3          | 3              |\\n| 3 | 2 | 2 | 0 | 1 | 0 | 0 |   | 7          | 6              |\\n| 4 | 2 | 2 | 2 | 2 | 0 | 0 |   | 10         | 10             |\\n| 5 | 2 | 2 | 2 | 2 | 0 | 1 |   | 16         | 15             |\\n| 6 | 2 | 2 | 2 | 2 | 2 | 2 |   | 21         | 21             |\\n\\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int bulbsSeenSum = 0;\\n        int allLeftSeenSum = 0;\\n        int out = 0;\\n        \\n        for(int i = 0; i < light.length; i++) {\\n            bulbsSeenSum += light[i];\\n            allLeftSeenSum += (i+1);\\n            if(bulbsSeenSum == allLeftSeenSum) out += 1;\\n        }\\n        \\n        return out;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int bulbsSeenSum = 0;\\n        int allLeftSeenSum = 0;\\n        int out = 0;\\n        \\n        for(int i = 0; i < light.length; i++) {\\n            bulbsSeenSum += light[i];\\n            allLeftSeenSum += (i+1);\\n            if(bulbsSeenSum == allLeftSeenSum) out += 1;\\n        }\\n        \\n        return out;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532787,
                "title": "c-very-simple-answer-o-n-space-o-1",
                "content": "Here is the idea of my answer: \\n\\nWe know that the bulbs are arranged in a row, this means that first 2 bulbs should be 1 + 2 = 3 if both are on right?\\n\\nIf we get same value when we sum the first two items in the light array, this means that the first and second bulb are on, meaning they are blue so I add 1 to my counter. Follow the same till the end of the array.\\n\\nHope this answer helps someone out there! :) \\n\\n\\tpublic int NumTimesAllBlue(int[] light) {\\n        \\n        int index_sum = 0;\\n        int sum = 0;\\n        int ans = 0;\\n        \\n        for(int i = 0; i < light.Length;i++) {\\n            index_sum += (i + 1);\\n            sum += light[i];\\n            if(index_sum == sum)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "Here is the idea of my answer: \\n\\nWe know that the bulbs are arranged in a row, this means that first 2 bulbs should be 1 + 2 = 3 if both are on right?\\n\\nIf we get same value when we sum the first two items in the light array, this means that the first and second bulb are on, meaning they are blue so I add 1 to my counter. Follow the same till the end of the array.\\n\\nHope this answer helps someone out there! :) \\n\\n\\tpublic int NumTimesAllBlue(int[] light) {\\n        \\n        int index_sum = 0;\\n        int sum = 0;\\n        int ans = 0;\\n        \\n        for(int i = 0; i < light.Length;i++) {\\n            index_sum += (i + 1);\\n            sum += light[i];\\n            if(index_sum == sum)\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 532585,
                "title": "c-o-n-bulb-is-switched-on-only-so-last-all-blue-can-be-remembered-and-check-only-right-part",
                "content": "```csharp\\npublic int NumTimesAllBlue(int[] light) \\n{\\n\\tbool[] bulbs = new bool[light.Length];\\n\\tint start = 0;\\n\\tint max = 0;\\n\\tint count = 0;\\n\\n\\tfor(int i = 0; i < light.Length; i++)\\n\\t{\\n\\t\\tint bulb = light[i] - 1;\\n\\t\\tmax = Math.Max(max, bulb);\\n\\t\\tbulbs[bulb] = true;\\n\\t\\tbool isValid = true;\\n\\n\\t\\tfor(int j = start; j < max; j++)\\n\\t\\t{\\n\\t\\t\\tif(!bulbs[j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tisValid = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\n\\t\\tif(isValid)\\n\\t\\t{\\n\\t\\t\\tcount++;                \\n\\t\\t}\\n\\t}\\n\\n\\treturn count;    \\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int NumTimesAllBlue(int[] light) \\n{\\n\\tbool[] bulbs = new bool[light.Length];\\n\\tint start = 0;\\n\\tint max = 0;\\n\\tint count = 0;\\n\\n\\tfor(int i = 0; i < light.Length; i++)\\n\\t{\\n\\t\\tint bulb = light[i] - 1;\\n\\t\\tmax = Math.Max(max, bulb);\\n\\t\\tbulbs[bulb] = true;\\n\\t\\tbool isValid = true;\\n\\n\\t\\tfor(int j = start; j < max; j++)\\n\\t\\t{\\n\\t\\t\\tif(!bulbs[j])\\n\\t\\t\\t{\\n\\t\\t\\t\\tisValid = false;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\n\\t\\tif(isValid)\\n\\t\\t{\\n\\t\\t\\tcount++;                \\n\\t\\t}\\n\\t}\\n\\n\\treturn count;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532580,
                "title": "javascript-and-c-solutions",
                "content": "**Synopsis:**\\n\\nKeep track of the right-most bulb `max`, whenever `max` equals `i + 1` we know all bulbs are blue.\\n\\n**Note:** we add `1` to `i` because `max` is 1-base indexed while `i` is 0-base indexed.\\n\\n*Javascript*\\n```\\nlet numTimesAllBlue = (A, max = 0, ans = 0) => {\\n    for (let i = 0; i < A.length; ++i) {\\n        max = Math.max(max, A[i]);\\n        if (max == i + 1)\\n            ++ans;\\n    }\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int numTimesAllBlue(VI& A, int max = 0, int ans = 0) {\\n        for (auto i = 0; i < A.size(); ++i) {\\n            max = std::max(max, A[i]);\\n            if (max == i + 1)\\n                ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nlet numTimesAllBlue = (A, max = 0, ans = 0) => {\\n    for (let i = 0; i < A.length; ++i) {\\n        max = Math.max(max, A[i]);\\n        if (max == i + 1)\\n            ++ans;\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int numTimesAllBlue(VI& A, int max = 0, int ans = 0) {\\n        for (auto i = 0; i < A.size(); ++i) {\\n            max = std::max(max, A[i]);\\n            if (max == i + 1)\\n                ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621561,
                "title": "beats-100-time-and-space-o-n-java-solution-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    /* Idea : When the actualSum and expectedSum are equal, that means all the left side bulbs are covered\\n    */\\n    public int numTimesAllBlue(int[] light){\\n       int i = 1;\\n       int expectedSum = 0;\\n       int actualSum = 0; \\n       int ans = 0; \\n       for(int num:light){\\n           actualSum += num;\\n           expectedSum += i;\\n           if(actualSum == expectedSum) ans++;\\n           i++;\\n       }\\n       return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    /* Idea : When the actualSum and expectedSum are equal, that means all the left side bulbs are covered\\n    */\\n    public int numTimesAllBlue(int[] light){\\n       int i = 1;\\n       int expectedSum = 0;\\n       int actualSum = 0; \\n       int ans = 0; \\n       for(int num:light){\\n           actualSum += num;\\n           expectedSum += i;\\n           if(actualSum == expectedSum) ans++;\\n           i++;\\n       }\\n       return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3380978,
                "title": "cpp-solution-using-strings-with-explanation",
                "content": "# Approach\\n-> The Approach which i applied uses 2 strings one is for Flipping the bits of mentioned in flips vector another string will simply flip the ith bit.\\n\\n-> Then we will compare both of the strings if they are equal or not.If they are equal increase the counter by 1.\\n\\n```\\nLet Input: flips = [3,2,4,1,5], five bits(n = 5)\\nstring s1 = \"00000\" and s2 = \"00000\"\\n So,\\n 1st iteration -> flips[i] = 3, s1 = \"00100\" and s2 = \"10000\" count = 0\\n 2nd iteration -> flips[i] = 2, s1 = \"01100\" and s2 = \"11000\" count = 0\\n 3rd iteration -> flips[i] = 4, s1 = \"01110\" and s2 = \"11100\" count = 0\\n 4th iteration -> flips[i] = 1, s1 = \"11110\" and s2 = \"11110\" count = 1\\n 5th iteration -> flips[i] = 5, s1 = \"11111\" and s2 = \"11111\" count = 2\\n```\\n```\\nRemember to do flips[i]-1 while flipping the bits because question is 1-indexed\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& f) {\\n        int cnt=0;\\n        string s1=\"\",s2=\"\";\\n        for(int i=0;i<f.size();i++)\\n        {\\n            s1+=\\'0\\';\\n            s2+=\\'0\\';\\n        }\\n        for(int i=0;i<f.size();i++)\\n        {\\n            s1[f[i]-1]=\\'1\\';\\n            s2[i]=\\'1\\';\\n            if(s1==s2)\\n            cnt++;\\n        }\\n    return cnt;}\\n};\\n```\\nIf you like the Explanation an upvote will be appreciated and if there is any error please comment down \\uD83D\\uDE0A\\uD83D\\uDE0A",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nLet Input: flips = [3,2,4,1,5], five bits(n = 5)\\nstring s1 = \"00000\" and s2 = \"00000\"\\n So,\\n 1st iteration -> flips[i] = 3, s1 = \"00100\" and s2 = \"10000\" count = 0\\n 2nd iteration -> flips[i] = 2, s1 = \"01100\" and s2 = \"11000\" count = 0\\n 3rd iteration -> flips[i] = 4, s1 = \"01110\" and s2 = \"11100\" count = 0\\n 4th iteration -> flips[i] = 1, s1 = \"11110\" and s2 = \"11110\" count = 1\\n 5th iteration -> flips[i] = 5, s1 = \"11111\" and s2 = \"11111\" count = 2\\n```\n```\\nRemember to do flips[i]-1 while flipping the bits because question is 1-indexed\\n```\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& f) {\\n        int cnt=0;\\n        string s1=\"\",s2=\"\";\\n        for(int i=0;i<f.size();i++)\\n        {\\n            s1+=\\'0\\';\\n            s2+=\\'0\\';\\n        }\\n        for(int i=0;i<f.size();i++)\\n        {\\n            s1[f[i]-1]=\\'1\\';\\n            s2[i]=\\'1\\';\\n            if(s1==s2)\\n            cnt++;\\n        }\\n    return cnt;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093805,
                "title": "with-thought-iterations-python",
                "content": "idea: sum on the left side of last index of 1 should be equal to the index itself\\nProcess1: convert everything in question exactly into code with all redundant steps\\n```\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        #do n^2 algorithm\\n        b=[0]*len(flips)\\n        preCount=0\\n        max1Index=0\\n        for i in flips:\\n            b[i-1]=1\\n            max1Index=max(max1Index, i)\\n            #check Prefix\\n            if sum(b[:max1Index-1+1])==max1Index:\\n                preCount+=1          \\n        return preCount\\n```\\n\\n\\nProcess2: minimize redundant parts\\nbetter idea: how to avoid summing at each step?--> maintain **curLeftSum** with the sum towards the left side of the **max1Index**, **preCount** **as the number of times curLeftSum==max1Index**\\nmax1Index=4,  curLeftSum=4, preCount=1\\neg)[3,2,4,1,5]\\nb=[0,0,0,0,0]\\nat 3, [0,0,1,0,0], here max1Index=3,  curLeftSum=1, preCount=0\\nat 2, [0,1,1,0,0], here max1Index=3,  curLeftSum=2, preCount=0\\nat 4, [0,1,1,1,0], here max1Index=4,  curLeftSum=3, preCount=0\\nat 1, [1,1,1,1,0], here **max1Index=4,  curLeftSum=4, preCount=1**\\nat 5, [1,1,1,1,1], here **max1Index=5,  curLeftSum=5, preCount=2**\\n```        \\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        preCount=0\\n        max1Index=0\\n        curLeftSum=0\\n        for i in flips:\\n            max1Index=max(max1Index, i)\\n            curLeftSum+=1\\n            if curLeftSum==max1Index:\\n                preCount+=1\\n        return preCount\\n```\\nTime O(n), Space O(1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        #do n^2 algorithm\\n        b=[0]*len(flips)\\n        preCount=0\\n        max1Index=0\\n        for i in flips:\\n            b[i-1]=1\\n            max1Index=max(max1Index, i)\\n            #check Prefix\\n            if sum(b[:max1Index-1+1])==max1Index:\\n                preCount+=1          \\n        return preCount\\n```\n```        \\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        preCount=0\\n        max1Index=0\\n        curLeftSum=0\\n        for i in flips:\\n            max1Index=max(max1Index, i)\\n            curLeftSum+=1\\n            if curLeftSum==max1Index:\\n                preCount+=1\\n        return preCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553436,
                "title": "java-single-pass-solution-o-1-space-optimized",
                "content": "class Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        \\n        int prefixAlligns=0;\\n        int max = 0;\\n        for(int i=0;i<flips.length;i++){\\n            \\n            max = Math.max(max,flips[i]);\\n            if(max == i+1){   // No need to Maintain Exta Counter\\n                prefixAlligns++;\\n            }\\n        }\\n        return prefixAlligns;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        \\n        int prefixAlligns=0;\\n        int max = 0;\\n        for(int i=0;i<flips.length;i++){\\n            \\n            max = Math.max(max,flips[i]);\\n            if(max == i+1){   // No need to Maintain Exta Counter\\n                prefixAlligns++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2460218,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n  public int numTimesAllBlue(int[] flips) {\\n    return secondTry(flips);\\n  }\\n  \\n  public int secondTry(int[] flips) {\\n    int maxFlipBit = Integer.MIN_VALUE;\\n    \\n    int count = 0;\\n    for(int i = 0; i < flips.length; i++) {\\n      maxFlipBit = Math.max(maxFlipBit, flips[i]);\\n      if(maxFlipBit - 1 == i) {\\n        ++count;\\n      }\\n    }\\n    \\n    return count;\\n  }\\n  \\n  public int firstTry(int[] flips) {\\n    if(flips.length == 1) {\\n      return flips[0] == 1 ? 1 : 0;\\n    }\\n    \\n    int maxFlipBit = Integer.MIN_VALUE;\\n    int minFlipBit = Integer.MAX_VALUE;\\n    \\n    int count = 0;\\n    for(int i = 0; i < flips.length; i++) {\\n      maxFlipBit = Math.max(maxFlipBit, flips[i]);\\n      minFlipBit = Math.min(minFlipBit, flips[i]);\\n      if(maxFlipBit - minFlipBit == i && maxFlipBit - 1 == i) {\\n        ++count;\\n      }\\n    }\\n    \\n    return count;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public int numTimesAllBlue(int[] flips) {\\n    return secondTry(flips);\\n  }\\n  \\n  public int secondTry(int[] flips) {\\n    int maxFlipBit = Integer.MIN_VALUE;\\n    \\n    int count = 0;\\n    for(int i = 0; i < flips.length; i++) {\\n      maxFlipBit = Math.max(maxFlipBit, flips[i]);\\n      if(maxFlipBit - 1 == i) {\\n        ++count;\\n      }\\n    }\\n    \\n    return count;\\n  }\\n  \\n  public int firstTry(int[] flips) {\\n    if(flips.length == 1) {\\n      return flips[0] == 1 ? 1 : 0;\\n    }\\n    \\n    int maxFlipBit = Integer.MIN_VALUE;\\n    int minFlipBit = Integer.MAX_VALUE;\\n    \\n    int count = 0;\\n    for(int i = 0; i < flips.length; i++) {\\n      maxFlipBit = Math.max(maxFlipBit, flips[i]);\\n      minFlipBit = Math.min(minFlipBit, flips[i]);\\n      if(maxFlipBit - minFlipBit == i && maxFlipBit - 1 == i) {\\n        ++count;\\n      }\\n    }\\n    \\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363400,
                "title": "java-6-line-solution-with-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        int counter=0,total=0,max=Integer.MIN_VALUE;\\n        for(int i=0;i<flips.length;i++){\\n            if(max<flips[i])max=flips[i];\\n            if(++counter==max)total++;\\n        }\\n        return total;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        int counter=0,total=0,max=Integer.MIN_VALUE;\\n        for(int i=0;i<flips.length;i++){\\n            if(max<flips[i])max=flips[i];\\n            if(++counter==max)total++;\\n        }\\n        return total;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165420,
                "title": "python-o-n-space-and-time-easy",
                "content": "Please Upvote if you liked my solution\\n\\t\\n\\tdef numTimesAllBlue(self, flips: List[int]) -> int:   \\n\\t\\t\\tn=len(flips)\\n\\t\\t\\tps=[0]\\n\\t\\t\\tps_natural=[0]\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tps.append(flips[i]+ps[-1])\\n\\t\\t\\t\\tps_natural.append(ps_natural[-1]+i+1)\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor i in range(1,len(ps)):\\n\\t\\t\\t\\tif(ps[i]==ps_natural[i]):\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\treturn count",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "Please Upvote if you liked my solution\\n\\t\\n\\tdef numTimesAllBlue(self, flips: List[int]) -> int:   \\n\\t\\t\\tn=len(flips)\\n\\t\\t\\tps=[0]\\n\\t\\t\\tps_natural=[0]\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\tps.append(flips[i]+ps[-1])\\n\\t\\t\\t\\tps_natural.append(ps_natural[-1]+i+1)\\n\\t\\t\\tcount=0\\n\\t\\t\\tfor i in range(1,len(ps)):\\n\\t\\t\\t\\tif(ps[i]==ps_natural[i]):\\n\\t\\t\\t\\t\\tcount+=1\\n\\t\\t\\treturn count",
                "codeTag": "Python3"
            },
            {
                "id": 1967349,
                "title": "java-simple-o-n-time-o-1-space-explained",
                "content": "General Idea -\\nWe need to understand, When we need to add 1 to the counter.\\nwe need to 1 to the counder, only if all the steps before me add a 1 to the right index, they dont have to do it in the right order, but if will happend, i need to add 1 in the current step.\\nHow we know if all the steps before me add 1? We will save the max.\\n\\nfor example: \\nlets take the input  2 3 1\\nwhen we at step 1, we add 2 - no need to add - max is 2 (2 != step 1)\\nin step 2 -  we add 3 - no need to add, the max is 3 (3 != step 2)\\nin step 3 - we add 1 - max still 3 (3 == step 3) - it means that 1 2 3 indexes are 1, so now, we add 1 to the counter.\\nIf in any time we got a value that is bigger then the step, we will not be able to add 1, until the max value will be the same as step.\\n\\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        int res = 0;\\n        int max = 0;\\n        for(int step=1; step<=flips.length; step++){\\n           max = Math.max(max, flips[step-1]);\\n            if(max == step)\\n              res++;  \\n           \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        int res = 0;\\n        int max = 0;\\n        for(int step=1; step<=flips.length; step++){\\n           max = Math.max(max, flips[step-1]);\\n            if(max == step)\\n              res++;  \\n           \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916571,
                "title": "golang-tc-o-n-sc-o-1-faster-than-80",
                "content": "```\\nfunc numTimesAllBlue(A []int) int {\\n    n:=len(A)\\n    maxIn:=int(-1e9)\\n    result:=0\\n    for i:=1; i<=n; i++ {\\n        if A[i-1]>maxIn {\\n            maxIn=A[i-1]\\n        }\\n        if maxIn==i {\\n            result++\\n        }\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numTimesAllBlue(A []int) int {\\n    n:=len(A)\\n    maxIn:=int(-1e9)\\n    result:=0\\n    for i:=1; i<=n; i++ {\\n        if A[i-1]>maxIn {\\n            maxIn=A[i-1]\\n        }\\n        if maxIn==i {\\n            result++\\n        }\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1886179,
                "title": "n-time-linear-approach-c-70-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int count = 0;\\n        int mx = -1;\\n        for(int i = 0; i < flips.size(); i++){\\n            mx = max(mx, flips[i]);\\n            if(mx -1 == i) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int count = 0;\\n        int mx = -1;\\n        for(int i = 0; i < flips.size(); i++){\\n            mx = max(mx, flips[i]);\\n            if(mx -1 == i) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1882485,
                "title": "c-straight-forward-o-n",
                "content": "class Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n     int start=0,steps=0,ans=0;\\n        int n=flips.size();\\n        vector<int> vec(n,0);\\n        for(int i=0;i<n;i++){\\n            steps++;\\n            while(vec[start]==1){\\n                start++;\\n            }\\n            if(start==steps-1)ans++;\\n            vec[flips[i]-1]=1;\\n        }\\n       \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n     int start=0,steps=0,ans=0;\\n        int n=flips.size();\\n        vector<int> vec(n,0);\\n        for(int i=0;i<n;i++){\\n            steps++;\\n            while(vec[start]==1){\\n                start++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1839611,
                "title": "c-easy-solution-few-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int ma=0;\\n        int ans=0;\\n        for(int i=0;i<flips.size();i++){\\n            ma=max(ma,flips[i]);\\n            if(ma==(i+1)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int ma=0;\\n        int ans=0;\\n        for(int i=0;i<flips.size();i++){\\n            ma=max(ma,flips[i]);\\n            if(ma==(i+1)){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822126,
                "title": "simple-solution-in-java-two-approaches-1-by-keeping-track-of-max-set-bit-2-by-union-find",
                "content": "**By keeping the track of the max set bit**\\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        // Keep the track of the max bit that has been flipped\\n        \\n        int ans = 0;\\n\\t\\tint max = 0;\\n        for(int i=0; i<flips.length; i++){\\n            max = Math.max(max, flips[i]);\\n            \\n            // If max bit flipped is i + 1, then the number of bits flipped till now will be i + 1, hence there is a prefix aligned string obtained \\n            if(max == i+1){\\n                ++ans;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\n**By Union Find**\\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        UnionFind uf = new UnionFind(flips.length);\\n        \\n        int ans = 0;\\n        HashSet<Integer> set = new HashSet<>(); // To store the positions at which the bit has been flipped \\n        int k = 0;\\n        for(int f : flips){\\n            set.add(f);\\n            k++;\\n            \\n            if(f >= 2){\\n               if(set.contains(f-1)) uf.union(f, f-1);\\n            }\\n            if(f < flips.length){\\n                 if(set.contains(f + 1)) uf.union(f, f+1);\\n            }\\n            if(set.contains(1)) ans += uf.checkPrefixAligned(k);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private class UnionFind{\\n        private int[] parent;\\n        private HashMap<Integer, Integer> map; // <Parent, Size>\\n        \\n        public UnionFind(int n){\\n            this.parent = new int[n+1];\\n            this.map = new HashMap<>();\\n            \\n            for(int i=1; i<=n; i++){\\n                parent[i] = i;\\n                map.put(i, 1);\\n            }\\n        }\\n        \\n        public int findParent(int i){\\n            while(parent[i] != i){\\n                parent[i] = parent[parent[i]];\\n                i = parent[i];\\n            }\\n            \\n            return i;\\n        }\\n        \\n        public void union(int i, int j){\\n            int p1 = findParent(i);\\n            int p2 = findParent(j);\\n            \\n            if(p1 != p2){\\n                parent[p2] = p1;\\n\\t\\t\\t\\t// Update the size of the group with parent p1 \\n                map.put(p1, map.get(p1) + map.get(p2));\\n                map.remove(p2);\\n            }\\n            \\n            return;\\n        }\\n        \\n        public int checkPrefixAligned(int num){\\n            int p = findParent(num); // Find the parent of the group \\n            \\n\\t\\t\\t// If the parent of the 1 and num is same and the size is also num, then there is a group of continuous 1 from 1,2 .... num\\n\\t\\t\\tif(map.containsKey(p) && map.get(p) == num){\\n                if(findParent(1) == p){\\n                    return 1;\\n                }\\n            }\\n            \\n            return 0;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        // Keep the track of the max bit that has been flipped\\n        \\n        int ans = 0;\\n\\t\\tint max = 0;\\n        for(int i=0; i<flips.length; i++){\\n            max = Math.max(max, flips[i]);\\n            \\n            // If max bit flipped is i + 1, then the number of bits flipped till now will be i + 1, hence there is a prefix aligned string obtained \\n            if(max == i+1){\\n                ++ans;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        UnionFind uf = new UnionFind(flips.length);\\n        \\n        int ans = 0;\\n        HashSet<Integer> set = new HashSet<>(); // To store the positions at which the bit has been flipped \\n        int k = 0;\\n        for(int f : flips){\\n            set.add(f);\\n            k++;\\n            \\n            if(f >= 2){\\n               if(set.contains(f-1)) uf.union(f, f-1);\\n            }\\n            if(f < flips.length){\\n                 if(set.contains(f + 1)) uf.union(f, f+1);\\n            }\\n            if(set.contains(1)) ans += uf.checkPrefixAligned(k);\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private class UnionFind{\\n        private int[] parent;\\n        private HashMap<Integer, Integer> map; // <Parent, Size>\\n        \\n        public UnionFind(int n){\\n            this.parent = new int[n+1];\\n            this.map = new HashMap<>();\\n            \\n            for(int i=1; i<=n; i++){\\n                parent[i] = i;\\n                map.put(i, 1);\\n            }\\n        }\\n        \\n        public int findParent(int i){\\n            while(parent[i] != i){\\n                parent[i] = parent[parent[i]];\\n                i = parent[i];\\n            }\\n            \\n            return i;\\n        }\\n        \\n        public void union(int i, int j){\\n            int p1 = findParent(i);\\n            int p2 = findParent(j);\\n            \\n            if(p1 != p2){\\n                parent[p2] = p1;\\n\\t\\t\\t\\t// Update the size of the group with parent p1 \\n                map.put(p1, map.get(p1) + map.get(p2));\\n                map.remove(p2);\\n            }\\n            \\n            return;\\n        }\\n        \\n        public int checkPrefixAligned(int num){\\n            int p = findParent(num); // Find the parent of the group \\n            \\n\\t\\t\\t// If the parent of the 1 and num is same and the size is also num, then there is a group of continuous 1 from 1,2 .... num\\n\\t\\t\\tif(map.containsKey(p) && map.get(p) == num){\\n                if(findParent(1) == p){\\n                    return 1;\\n                }\\n            }\\n            \\n            return 0;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1820707,
                "title": "java-faster-than-100-o-n-time-o-1-space",
                "content": "The idea here is to check at every index \\'i\\', whether we cover all positions upto \\'i\\'.\\n\\nFor that case, I just maintained a varible \\'max\\'. This max represents the rightmost bulb that is lighted.\\n\\nIf this \\'max\\' is less than or equal to current index position, then it is the required answer.\\n\\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        int max = 0;\\n        int ans = 0, n = flips.length;\\n        \\n        for(int i=0; i<n; i++){\\n            max = Math.max( flips[i], max);\\n            if(max <= (i+1)){\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nTC : O(n)\\nSC : O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        int max = 0;\\n        int ans = 0, n = flips.length;\\n        \\n        for(int i=0; i<n; i++){\\n            max = Math.max( flips[i], max);\\n            if(max <= (i+1)){\\n                ans++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1794053,
                "title": "easy-c-3-ways-1-solved",
                "content": "**Assuming 1-indexed array.**\\nif i am at index ```i``` and max element till now is is also ```i``` then it means that there are ```i``` elements and all are in the range of 1 to ```i``` because there are no duplicates.Which makes contiguous sequence.\\nOther approaches:-\\n1. Using PBDS.\\n2. Using BIT or Fenwick tree.\\n3. Think about these approches as well.\\n\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int maxi=0,ans=0;\\n        for(int i=0;i<flips.size();i++){\\n            maxi=max(maxi,flips[i]);\\n            if(i+1==maxi)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```i```\n```i```\n```i```\n```i```\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int maxi=0,ans=0;\\n        for(int i=0;i<flips.size();i++){\\n            maxi=max(maxi,flips[i]);\\n            if(i+1==maxi)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724581,
                "title": "c-easy-solution-with-explanation",
                "content": "**Analysis:**\\n\\nObserve that when the array becomes prefix-aligned, *the **maximum** flip happened so far needs to be equal to the **number of steps** that took place*. This is the only condition such that the array can become prefix-aligned.\\n\\nWith that, we just need to iterate through the flips, keep track of the number of steps taken place, and keep track of the maximum flip so far after each step. If at the end of any step the max so far is equal to the number of steps, then increment the result by one.\\n\\n**Solution:**\\n\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(std::vector<int>& flips) {\\n        int mx = 0;\\n\\n        int res = 0;\\n\\n        int step = 0;\\n        for (auto f : flips) {\\n            ++step;\\n            mx = std::max(mx, f);\\n\\n            if (mx == step) {\\n                ++res;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(std::vector<int>& flips) {\\n        int mx = 0;\\n\\n        int res = 0;\\n\\n        int step = 0;\\n        for (auto f : flips) {\\n            ++step;\\n            mx = std::max(mx, f);\\n\\n            if (mx == step) {\\n                ++res;\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659633,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        \\n        int min=Integer.MAX_VALUE;\\n        int max=Integer.MIN_VALUE;\\n        int result=0;\\n        for(int i=0;i<flips.length;i++){\\n            min=Math.min(min,flips[i]);\\n            max=Math.max(max,flips[i]);\\n            if(max-min==i&&min==1)result++;\\n        }\\n    return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        \\n        int min=Integer.MAX_VALUE;\\n        int max=Integer.MIN_VALUE;\\n        int result=0;\\n        for(int i=0;i<flips.length;i++){\\n            min=Math.min(min,flips[i]);\\n            max=Math.max(max,flips[i]);\\n            if(max-min==i&&min==1)result++;\\n        }\\n    return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428492,
                "title": "c-priority-queue-5-lines-easy",
                "content": "```\\n\\n```public:\\n    int numTimesAllBlue(vector<int>& light) {\\n        priority_queue<int>pq;\\n        int count=0;\\n        for(int i=0;i<light.size();i++)\\n        {\\n            pq.push(light[i]);\\n            if(pq.top()==pq.size())\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1408667,
                "title": "easy-java",
                "content": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int c=0;\\n        int k=0;\\n        int ans=0;\\n        for(int i=0;i<light.length;i++){\\n            c+=light[i];\\n            k+=i+1;\\n            if(c==k)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int c=0;\\n        int k=0;\\n        int ans=0;\\n        for(int i=0;i<light.length;i++){\\n            c+=light[i];\\n            k+=i+1;\\n            if(c==k)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1387640,
                "title": "python-linear",
                "content": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        ans, right = 0, -1\\n        is_on = 0\\n        \\n        for i in range(len(light)):\\n            is_on += 1\\n            right = max(right, light[i])\\n            ans += int(is_on == right)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        ans, right = 0, -1\\n        is_on = 0\\n        \\n        for i in range(len(light)):\\n            is_on += 1\\n            right = max(right, light[i])\\n            ans += int(is_on == right)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266758,
                "title": "javascript-o-n-and-o-1",
                "content": "```\\n/**\\n * @param {number[]} light\\n * @return {number}\\n */\\nvar numTimesAllBlue = function(light) {\\n   var max = 0, count = 0\\n    for(let i=0; i<light.length; i++){\\n        max = Math.max(max, light[i]);\\n        if(max === i+1)count++\\n    }\\n    return count\\n};\\n   \\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} light\\n * @return {number}\\n */\\nvar numTimesAllBlue = function(light) {\\n   var max = 0, count = 0\\n    for(let i=0; i<light.length; i++){\\n        max = Math.max(max, light[i]);\\n        if(max === i+1)count++\\n    }\\n    return count\\n};\\n   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1258428,
                "title": "using-2-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n       \\n        unordered_map<int,int>temp1;\\n        unordered_map<int,int>temp2;\\n        temp2[0] = 2;\\n        int result = 0;\\n        for(int i = 0;i<light.size();i++)\\n        {\\n            if(temp2.find(light[i] - 1) != temp2.end())\\n            {\\n                temp2[light[i]] = 2;\\n            }\\n            else\\n                temp1[light[i]] = 1;\\n            int val = light[i] + 1;\\n            while(temp1.find(val) != temp1.end())\\n            {\\n                temp2[val] = 2;\\n                temp1.erase(val);\\n                val++;\\n            }\\n            if(temp1.size() == 0)\\n                result++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n       \\n        unordered_map<int,int>temp1;\\n        unordered_map<int,int>temp2;\\n        temp2[0] = 2;\\n        int result = 0;\\n        for(int i = 0;i<light.size();i++)\\n        {\\n            if(temp2.find(light[i] - 1) != temp2.end())\\n            {\\n                temp2[light[i]] = 2;\\n            }\\n            else\\n                temp1[light[i]] = 1;\\n            int val = light[i] + 1;\\n            while(temp1.find(val) != temp1.end())\\n            {\\n                temp2[val] = 2;\\n                temp1.erase(val);\\n                val++;\\n            }\\n            if(temp1.size() == 0)\\n                result++;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249645,
                "title": "good-practice",
                "content": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        lightCount = 0\\n        lightSum = 0\\n        retCount = 0\\n        for i in range(len(light)):\\n            lightSum += light[i]\\n            lightCount += (i + 1)\\n            if lightCount == lightSum:\\n                retCount += 1\\n        return retCount\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        lightCount = 0\\n        lightSum = 0\\n        retCount = 0\\n        for i in range(len(light)):\\n            lightSum += light[i]\\n            lightCount += (i + 1)\\n            if lightCount == lightSum:\\n                retCount += 1\\n        return retCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1209754,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n        double sum(double n){\\n                return n*(n+1)/2;\\n                \\n        }\\n    int numTimesAllBlue(vector<int>& light) {\\n     \\n            int res=0;\\n            double  curr=0;\\n         for(double i=0;i<light.size();i++){\\n           curr+=light[i];\\n                 if(curr==sum(i+1)){\\n                         res++;\\n                 }\\n         }\\n            return res;\\n           \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n        double sum(double n){\\n                return n*(n+1)/2;\\n                \\n        }\\n    int numTimesAllBlue(vector<int>& light) {\\n     \\n            int res=0;\\n            double  curr=0;\\n         for(double i=0;i<light.size();i++){\\n           curr+=light[i];\\n                 if(curr==sum(i+1)){\\n                         res++;\\n                 }\\n         }\\n            return res;\\n           \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1193479,
                "title": "python-easy-for-beginners",
                "content": "class Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        maximo = 0\\n        respuesta = 0\\n        j=0\\n        while j<len(light):\\n            maximo=max(maximo,light[j])\\n            if maximo==j+1:\\n                respuesta=respuesta+1\\n            j=j+1\\n        return respuesta",
                "solutionTags": [],
                "code": "class Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        maximo = 0\\n        respuesta = 0\\n        j=0\\n        while j<len(light):\\n            maximo=max(maximo,light[j])\\n            if maximo==j+1:\\n                respuesta=respuesta+1\\n            j=j+1\\n        return respuesta",
                "codeTag": "Java"
            },
            {
                "id": 1118604,
                "title": "java-easy-solution-with-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] arr) {\\n        long max = Integer.MIN_VALUE, sum = 0, count=0;\\n        for(int i=0;i<arr.length;i++) {\\n            sum+=arr[i];\\n            max = Math.max(max,arr[i]);\\n            if(sum == (max*(max+1))/2) count++;\\n        }\\n        return (int)count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] arr) {\\n        long max = Integer.MIN_VALUE, sum = 0, count=0;\\n        for(int i=0;i<arr.length;i++) {\\n            sum+=arr[i];\\n            max = Math.max(max,arr[i]);\\n            if(sum == (max*(max+1))/2) count++;\\n        }\\n        return (int)count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1054276,
                "title": "python-0-n-simple-approach",
                "content": "```\\ndef numTimesAllBlue(self, light: List[int]) -> int:\\n        sums=0\\n        ans=0\\n        n=len(light)\\n        for i in range(0,n):\\n            sums+=light[i]\\n            if sums==(i+1)*(i+2)//2:\\n                ans+=1\\n        return ans\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef numTimesAllBlue(self, light: List[int]) -> int:\\n        sums=0\\n        ans=0\\n        n=len(light)\\n        for i in range(0,n):\\n            sums+=light[i]\\n            if sums==(i+1)*(i+2)//2:\\n                ans+=1\\n        return ans\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1021749,
                "title": "java-o-n-clean-code",
                "content": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int rightMost = 0;\\n        int count = 0;\\n        \\n        for(int i = 0; i < light.length; i++) {\\n            rightMost = Math.max(rightMost, light[i]);\\n            if(rightMost == i+1) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int rightMost = 0;\\n        int count = 0;\\n        \\n        for(int i = 0; i < light.length; i++) {\\n            rightMost = Math.max(rightMost, light[i]);\\n            if(rightMost == i+1) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1016570,
                "title": "c-100-100",
                "content": "This uses the fact that the sum of a series (1..N) = (N^2 + N) / 2\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        size_t highest = 0;\\n        size_t sum = 0;\\n        size_t needed = 0;\\n        int rv = 0;\\n        for(auto l: light){\\n            sum += l;\\n            if(l > highest){\\n                highest = l;\\n                needed = (highest * highest + highest) >> 1;\\n            }\\n            if (sum == needed) ++rv;\\n        }\\n        return rv;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        size_t highest = 0;\\n        size_t sum = 0;\\n        size_t needed = 0;\\n        int rv = 0;\\n        for(auto l: light){\\n            sum += l;\\n            if(l > highest){\\n                highest = l;\\n                needed = (highest * highest + highest) >> 1;\\n            }\\n            if (sum == needed) ++rv;\\n        }\\n        return rv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998495,
                "title": "simple-math-series-1-2-3-4",
                "content": "When ith bulb is turned ON, all turned bulbs will become blue only and only when all bulbes before this bub are turned on.\\n\\nIn that case, sum of all the bulbs (numbers) will be 1+2+3... i.\\nWe can keep two variable...\\nsum = actual sum of tuned ON bulbs and \\nrsum = expected sum when ith bulb is turned ON.\\n\\nWhen both sum and rsum are equal, all the turned ON bulbs will be blue.\\n\\n```\\nvar numTimesAllBlue = function(light) {\\n    let sum = 0, rsum = 0, result = 0;\\n    \\n    for(let i = 0; i < light.length; i++){\\n        sum += light[i]; \\n        rsum += (i+1);\\n        if(sum === rsum) result++;\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numTimesAllBlue = function(light) {\\n    let sum = 0, rsum = 0, result = 0;\\n    \\n    for(let i = 0; i < light.length; i++){\\n        sum += light[i]; \\n        rsum += (i+1);\\n        if(sum === rsum) result++;\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 944951,
                "title": "two-java-solutions",
                "content": "### Solution 1 : Using a set. O(n) S(n)\\n``` java\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        if (light == null || light.length == 0) return 0;\\n        Set<Integer> set = new HashSet<>();\\n        int p = 1, cnt = 0;\\n        for (int v : light) {\\n            set.add(v);\\n            while (set.contains(p)) {\\n                set.remove(p++);\\n            }\\n            if (set.isEmpty()) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n\\n### Solution 2 : O(n) S(1)\\n``` java\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        if (light == null || light.length == 0) return 0;\\n        int max = 0x80000000, cnt = 0;\\n        for (int i = 0; i < light.length; ++i) {\\n            max = Math.max(max, light[i]);\\n            if (i + 1 == max) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        if (light == null || light.length == 0) return 0;\\n        Set<Integer> set = new HashSet<>();\\n        int p = 1, cnt = 0;\\n        for (int v : light) {\\n            set.add(v);\\n            while (set.contains(p)) {\\n                set.remove(p++);\\n            }\\n            if (set.isEmpty()) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```\n``` java\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        if (light == null || light.length == 0) return 0;\\n        int max = 0x80000000, cnt = 0;\\n        for (int i = 0; i < light.length; ++i) {\\n            max = Math.max(max, light[i]);\\n            if (i + 1 == max) cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 875545,
                "title": "c-2-methods-no-max-thingy",
                "content": "solution from: https://leetcode.com/problems/bulb-switcher-iii/discuss/532787/C-very-simple-answer-O(n)-space-o(1)\\n      \\n   since light bulbs are labeled, 1, 2, 3, ... consecutively\\n      \\n   to see if all bulbs from index 0 to 1 are on we do 1 + 2 = 3\\n      so we make two counters\\n      \\n  - sumIndex to add all indexes -> no. needed to be on consecutively\\n  - bulbCnt  to add all bulbs   -> no. of bulbs on\\n        \\n  - if they are the same this means the bulbs are on consecutively so we increment our answer\\n        \\n      time  O(n)\\n      space O(1)\\n```\\n public int NumTimesAllBlue(int[] light) {\\n        int n = light.Length;\\n        int sumIndex = 0;\\n        int sumBlb = 0;\\n        int ans = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            sumIndex += (i+1);\\n            sumBlb   += light[i];\\n            \\n            if(sumBlb == sumIndex) ans++;\\n        }\\n        \\n        return ans;    \\n    }\\n```\\n\\n   time 30 mins\\n        solution: simulation\\n        3 cases\\n           - look left if blue be blue look right and turn consecutive On to Blue\\n            - look left if off be onn\\n            - look left if index == 0 be blue loop right and turn Consecutive On to Blue\\n            - increment blue and litcnt at each step\\n            - every loop if bluCnt == litCnt increment answer\\n             my crappy ass  answer\\n            time O(n Log n) \\n           space O(n)\\n  ```\\n   public int NumTimesAllBlue(int[] light) {\\n        int n = light.Length;\\n        \\n        if(n == 1 && light[0] == 1)return 1;\\n        \\n        var smlC = new char[n]; \\n        \\n        int bluCnt = 0;\\n        int litCnt = 0;\\n        int mmnCnt = 0;\\n        \\n        Array.Fill(smlC, \\'X\\');\\n        \\n        for(int i = 0; i < n; i++){\\n            int index = light[i];\\n            \\n            //look left\\n            if(index == 1){\\n                //iterate right\\n                bluCnt++;\\n                litCnt++;\\n                smlC[0] = \\'B\\';\\n                int j = 1;\\n                while(j < n && smlC[j] !=  \\'X\\'){\\n                    smlC[j] = \\'B\\';\\n                    bluCnt++;\\n                    j++;\\n                }\\n                \\n            }\\n            else if(smlC[index - 2] == \\'X\\' || smlC[index - 2] == \\'O\\' ){\\n                smlC[index-1] = \\'O\\';\\n                litCnt++;\\n             }\\n            else if(smlC[index-2] == \\'B\\'){\\n                smlC[index-1] = \\'B\\';\\n                litCnt++;\\n                bluCnt++;\\n                //simulate right again.\\n                int j = index;\\n                while(j < n && smlC[j] !=  \\'X\\'){\\n                    smlC[j] = \\'B\\';\\n                    bluCnt++;\\n                    j++;\\n                }\\n            }\\n            \\n            if(bluCnt == litCnt){\\n                mmnCnt++;\\n            }\\n            \\n        }\\n        return mmnCnt;\\n        \\n    }\\n  ```",
                "solutionTags": [],
                "code": "```\\n public int NumTimesAllBlue(int[] light) {\\n        int n = light.Length;\\n        int sumIndex = 0;\\n        int sumBlb = 0;\\n        int ans = 0;\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            sumIndex += (i+1);\\n            sumBlb   += light[i];\\n            \\n            if(sumBlb == sumIndex) ans++;\\n        }\\n        \\n        return ans;    \\n    }\\n```\n```\\n   public int NumTimesAllBlue(int[] light) {\\n        int n = light.Length;\\n        \\n        if(n == 1 && light[0] == 1)return 1;\\n        \\n        var smlC = new char[n]; \\n        \\n        int bluCnt = 0;\\n        int litCnt = 0;\\n        int mmnCnt = 0;\\n        \\n        Array.Fill(smlC, \\'X\\');\\n        \\n        for(int i = 0; i < n; i++){\\n            int index = light[i];\\n            \\n            //look left\\n            if(index == 1){\\n                //iterate right\\n                bluCnt++;\\n                litCnt++;\\n                smlC[0] = \\'B\\';\\n                int j = 1;\\n                while(j < n && smlC[j] !=  \\'X\\'){\\n                    smlC[j] = \\'B\\';\\n                    bluCnt++;\\n                    j++;\\n                }\\n                \\n            }\\n            else if(smlC[index - 2] == \\'X\\' || smlC[index - 2] == \\'O\\' ){\\n                smlC[index-1] = \\'O\\';\\n                litCnt++;\\n             }\\n            else if(smlC[index-2] == \\'B\\'){\\n                smlC[index-1] = \\'B\\';\\n                litCnt++;\\n                bluCnt++;\\n                //simulate right again.\\n                int j = index;\\n                while(j < n && smlC[j] !=  \\'X\\'){\\n                    smlC[j] = \\'B\\';\\n                    bluCnt++;\\n                    j++;\\n                }\\n            }\\n            \\n            if(bluCnt == litCnt){\\n                mmnCnt++;\\n            }\\n            \\n        }\\n        return mmnCnt;\\n        \\n    }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 863167,
                "title": "simple-java-o-1-space-with-clear-explanation",
                "content": "The intution here is that if the lights are turned on in sorted ascending order then all the moments has all turned on light to be blue. That means if there is a partial sorted array we only need to count those cases when we would have swapped a on light with another to make the array sorted. \\n\\nAll the prev lights will be turned on only if number of turned on lights is equals to the partially sorted array paritiion size. if all prev lights are turned on they all of them are blue on the partition. We intend to count only these cases.\\n\\n```\\n    public int numTimesAllBlue(int[] light) {\\n        // the partition after which all lights are off\\n        int p = -1;\\n        int count = 0;\\n        for(int k = 0; k < light.length; k++){\\n            // if the lights are turned on in ascending sorted order then\\n            // p is always equals to the index aka moment of turning on \\n            // and hence each time we turn on a light all the prev lights\\n            // are also turned on hence blue. But the lights are not turned on\\n            // in that sorted order. \\n            // That means if there is a partial sorted array we only need to count\\n            // those cases when we would have swapped a on light with another to make\\n            // the array sorted. \\n            p = Math.max(p, light[k]);\\n            // all the prev lights will be turned on only if number of turned on \\n            // lights is equals to the partially sorted array paritiion size (k-0+1)\\n            // if all prev lights are turned on they all of them are blue on the\\n            // partition. We intend to count only these cases.\\n            if(p == k+1){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numTimesAllBlue(int[] light) {\\n        // the partition after which all lights are off\\n        int p = -1;\\n        int count = 0;\\n        for(int k = 0; k < light.length; k++){\\n            // if the lights are turned on in ascending sorted order then\\n            // p is always equals to the index aka moment of turning on \\n            // and hence each time we turn on a light all the prev lights\\n            // are also turned on hence blue. But the lights are not turned on\\n            // in that sorted order. \\n            // That means if there is a partial sorted array we only need to count\\n            // those cases when we would have swapped a on light with another to make\\n            // the array sorted. \\n            p = Math.max(p, light[k]);\\n            // all the prev lights will be turned on only if number of turned on \\n            // lights is equals to the partially sorted array paritiion size (k-0+1)\\n            // if all prev lights are turned on they all of them are blue on the\\n            // partition. We intend to count only these cases.\\n            if(p == k+1){\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 863159,
                "title": "my-java-solution-with-my-thought-process",
                "content": "```\\n/*\\nMy thought process:\\n\\nHere we have several bulbs and at each moment k, we turn on bulbs. A bulb changes to blue only if its previous  bulbs are turned on. \\nSo whats the idea here.\\nIf we have say 5 th bulb shine, then 1, 2, 3, 4 will shine too and it will be blue also. So we got a moment where all the bulbs turn blue.\\nSo we start from zero, \\nWe iterate throught the light array, then we take the max from the lightsOn and elements.\\nIf the lightsOn == i+1, then we have all the bulbs blue..\\n\\nEg: lights = [2, 1, 3, 5, 4]   and lightsOn = 0;\\nlights[0] = 2 -> lightsOn = max(0, 2) = 2 but 2 != 0+1, thus we donot increment moment.\\nlights[1] = 1 -> lightsOn = max(2, 1) = 2, 2 == 1+1, so we have all blue, increment moment = 1\\nlights[2] = 3 -> lightsOn = max(2, 3) = 3,  3 == 2+1, so we have all blue, increment moment = 1+1 = 2\\nlights[3] = 5 -> lightsOn = max(3, 5) = 5, but 5 != 3+1, thus we do not incrememt our moment.\\nlights[4] = 4 -> lightsOn = max(5, 4) = 5, 5 == 4+1, so we have all blue, incrememnt moment = 2+1 = 3\\n\\nAnd finally return the answer.\\n*/\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int moment = 0;\\n        int lightsOn = 0;\\n        int length = light.length;\\n        for (int i=0; i<length; i++) {\\n            lightsOn = Math.max(lightsOn, light[i]);\\n            if (lightsOn == i+1)\\n                moment += 1;\\n        }\\n        return moment;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nMy thought process:\\n\\nHere we have several bulbs and at each moment k, we turn on bulbs. A bulb changes to blue only if its previous  bulbs are turned on. \\nSo whats the idea here.\\nIf we have say 5 th bulb shine, then 1, 2, 3, 4 will shine too and it will be blue also. So we got a moment where all the bulbs turn blue.\\nSo we start from zero, \\nWe iterate throught the light array, then we take the max from the lightsOn and elements.\\nIf the lightsOn == i+1, then we have all the bulbs blue..\\n\\nEg: lights = [2, 1, 3, 5, 4]   and lightsOn = 0;\\nlights[0] = 2 -> lightsOn = max(0, 2) = 2 but 2 != 0+1, thus we donot increment moment.\\nlights[1] = 1 -> lightsOn = max(2, 1) = 2, 2 == 1+1, so we have all blue, increment moment = 1\\nlights[2] = 3 -> lightsOn = max(2, 3) = 3,  3 == 2+1, so we have all blue, increment moment = 1+1 = 2\\nlights[3] = 5 -> lightsOn = max(3, 5) = 5, but 5 != 3+1, thus we do not incrememt our moment.\\nlights[4] = 4 -> lightsOn = max(5, 4) = 5, 5 == 4+1, so we have all blue, incrememnt moment = 2+1 = 3\\n\\nAnd finally return the answer.\\n*/\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int moment = 0;\\n        int lightsOn = 0;\\n        int length = light.length;\\n        for (int i=0; i<length; i++) {\\n            lightsOn = Math.max(lightsOn, light[i]);\\n            if (lightsOn == i+1)\\n                moment += 1;\\n        }\\n        return moment;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833670,
                "title": "my-java-solution",
                "content": "The idea is that when all bulbs are blue, the size of the `on` bulbs equals to the highest number of the bulb which is on.\\n\\n```\\n    public int numTimesAllBlue(int[] light) {\\n        int size = 0, high = 0;\\n        int res = 0;\\n        for (int n : light) {\\n            size++;\\n            high = Math.max(high, n);\\n            if (size == high) res++;\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n    public int numTimesAllBlue(int[] light) {\\n        int size = 0, high = 0;\\n        int res = 0;\\n        for (int n : light) {\\n            size++;\\n            high = Math.max(high, n);\\n            if (size == high) res++;\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 827123,
                "title": "c-o-n-easy-to-understand",
                "content": "```\\nint numTimesAllBlue(vector<int>& light) {\\n        int n = light.size();\\n        int largest = 0;\\n        unordered_set<int> on;\\n        unordered_set<int> blue;\\n        int res = 0;\\n        for (int i : light) {\\n            on.insert(i);\\n            while (on.find(largest+1) != on.end()) {\\n                blue.insert(++largest);\\n            }\\n            if (blue.size() == on.size()) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numTimesAllBlue(vector<int>& light) {\\n        int n = light.size();\\n        int largest = 0;\\n        unordered_set<int> on;\\n        unordered_set<int> blue;\\n        int res = 0;\\n        for (int i : light) {\\n            on.insert(i);\\n            while (on.find(largest+1) != on.end()) {\\n                blue.insert(++largest);\\n            }\\n            if (blue.size() == on.size()) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820792,
                "title": "python-o-n-using-max",
                "content": "The valid moment: max turned on buld index == i+1\\n\\n```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        max_v = 0\\n        res = 0\\n\\n        for i,v in enumerate(light):\\n            max_v = max(max_v, v)\\n            if max_v == i+1:\\n                res += 1\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        max_v = 0\\n        res = 0\\n\\n        for i,v in enumerate(light):\\n            max_v = max(max_v, v)\\n            if max_v == i+1:\\n                res += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797672,
                "title": "python-beat-99-one-pass",
                "content": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        ans = 0\\n        \\n        maxindex = 0\\n        \\n        for i, e in enumerate(light):\\n            maxindex = max(maxindex, e)\\n            if i+1 == maxindex:\\n                ans += 1\\n        \\n        return ans\\n    \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        ans = 0\\n        \\n        maxindex = 0\\n        \\n        for i, e in enumerate(light):\\n            maxindex = max(maxindex, e)\\n            if i+1 == maxindex:\\n                ans += 1\\n        \\n        return ans\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762178,
                "title": "easiest-explanation-o-n-and-o-1-space-c",
                "content": "Some Key Points.\\n\\n* We can observe that there is a **minimum of 1 solution** at the end,\\n*  Total number of solutions depend on the value of bulb[i] for the index which is going to be filled.\\n*  The count of times all bulbs are blue also depends when the maximum element of bulb[i] is equal to index\\n\\nBecause whenever the maximum element till now  and its index is  equal \\nit means that the all the previous element to it has been already filled,\\nbecause we are filling the index based on the value of bulb[i], and when all the elements less than bulb[i] has been filled, so we will increment the count.\\n\\n**Take a copy and pen and Dry Run the approach and you will get it, why it is working.**\\n\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& A) \\n    {\\n      int count = 0, maxM = INT_MIN;\\n      for (int i = 0; i < A.size(); i++)\\n      {\\n        maxM = max(maxM, A[i]);\\n        \\n        if (maxM == i + 1) count++;\\n      }\\n\\n      return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& A) \\n    {\\n      int count = 0, maxM = INT_MIN;\\n      for (int i = 0; i < A.size(); i++)\\n      {\\n        maxM = max(maxM, A[i]);\\n        \\n        if (maxM == i + 1) count++;\\n      }\\n\\n      return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 758588,
                "title": "c-easy-to-understand",
                "content": "```\\nint numTimesAllBlue(vector<int>& light) {\\n        int n = light.size();\\n        int res = 0, sum = 0, bulbSum = 0;\\n        for(int i = 0; i < n; i++){\\n            sum = sum + i + 1;\\n            bulbSum = bulbSum + light[i];\\n            if(bulbSum == sum) res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numTimesAllBlue(vector<int>& light) {\\n        int n = light.size();\\n        int res = 0, sum = 0, bulbSum = 0;\\n        for(int i = 0; i < n; i++){\\n            sum = sum + i + 1;\\n            bulbSum = bulbSum + light[i];\\n            if(bulbSum == sum) res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 758053,
                "title": "c-6-line",
                "content": "```\\n    int numTimesAllBlue(vector<int>& light) {\\n        int curBiggest = 0, cnt =0, res = 0;\\n        for(auto x:light){\\n            curBiggest = max(curBiggest, x);\\n            if(curBiggest == ++cnt) res++;\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int numTimesAllBlue(vector<int>& light) {\\n        int curBiggest = 0, cnt =0, res = 0;\\n        for(auto x:light){\\n            curBiggest = max(curBiggest, x);\\n            if(curBiggest == ++cnt) res++;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 740377,
                "title": "c-o-n-solution-3-liner",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int count = 0, maxi = 0;\\n        for (int i = 0; i < light.size(); i++) {\\n            maxi = max(maxi, light[i]);\\n            if (maxi == i + 1)  count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int count = 0, maxi = 0;\\n        for (int i = 0; i < light.size(); i++) {\\n            maxi = max(maxi, light[i]);\\n            if (maxi == i + 1)  count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702729,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        total_seen = 0\\n        max_seen = 0\\n        count = 0\\n\\n        for val in light:\\n            if val > max_seen:\\n                max_seen = val\\n            total_seen += 1\\n            if total_seen == max_seen:\\n                count += 1\\n            \\n        return count\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        total_seen = 0\\n        max_seen = 0\\n        count = 0\\n\\n        for val in light:\\n            if val > max_seen:\\n                max_seen = val\\n            total_seen += 1\\n            if total_seen == max_seen:\\n                count += 1\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681773,
                "title": "simple-solution-o-n",
                "content": "\\n\\n\\nint numTimesAllBlue(int* light, int lightSize)\\n{\\nlong long int res=0;long long int flag=0;long long int sum=0;long long int k=1;\\nfor(int i=0;i<lightSize;i++)\\n{\\nsum+=light[i];\\nlong int temp=(long long int)((k)*(k+1)/2);\\nif(sum==temp)\\n{\\nres++;\\n}\\nk++;\\n}\\nreturn res;\\n}",
                "solutionTags": [],
                "code": "\\n\\n\\nint numTimesAllBlue(int* light, int lightSize)\\n{\\nlong long int res=0;long long int flag=0;long long int sum=0;long long int k=1;\\nfor(int i=0;i<lightSize;i++)\\n{\\nsum+=light[i];\\nlong int temp=(long long int)((k)*(k+1)/2);\\nif(sum==temp)\\n{\\nres++;\\n}\\nk++;\\n}\\nreturn res;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 636780,
                "title": "simple-sum-of-a-p",
                "content": "Accumulate sum and compare against expected sum of Arithematic Progression so far.\\n\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        \\n        unsigned long int  expected_sum;\\n        unsigned long int  actual_sum =0;\\n        int count = 0;\\n    \\n        for (unsigned long int i =0; i< light.size();i++) {\\n            actual_sum += light[i];\\n            expected_sum = ((i+1)*(i+2))/2;\\n            if (actual_sum == expected_sum)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        \\n        unsigned long int  expected_sum;\\n        unsigned long int  actual_sum =0;\\n        int count = 0;\\n    \\n        for (unsigned long int i =0; i< light.size();i++) {\\n            actual_sum += light[i];\\n            expected_sum = ((i+1)*(i+2))/2;\\n            if (actual_sum == expected_sum)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615433,
                "title": "orgasmic-approach",
                "content": "Combination of two problems\\n1. Next smaller element\\n2. Trapping Rainwater Problem\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int n=light.size();\\n        vector<int> nextsmaller(n,-1);\\n        vector<int> tilllarger;\\n        stack<int> Stack;\\n        for(int i=0;i<light.size();i++){\\n            if(Stack.empty())\\n                Stack.push(i);\\n            else if(light[i] > light[Stack.top()])\\n                Stack.push(i);\\n            else{\\n                while(light[Stack.top()] > light[i]){\\n                    nextsmaller[Stack.top()]=light[i];\\n                    Stack.pop();\\n                    if(Stack.empty())\\n                        break;\\n                }\\n                Stack.push(i);\\n            }\\n        }\\n        int tillmax=INT_MIN;\\n        for(int i=0;i<light.size();i++){\\n            tillmax=max(tillmax,light[i]);\\n            tilllarger.push_back(tillmax);\\n        }\\n        int blue_bulbs=0;\\n        for(int i=0;i<n;i++){\\n            if(nextsmaller[i]==-1 & tilllarger[i]==i+1){\\n             blue_bulbs++;\\n            }\\n        }\\n        return blue_bulbs;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int n=light.size();\\n        vector<int> nextsmaller(n,-1);\\n        vector<int> tilllarger;\\n        stack<int> Stack;\\n        for(int i=0;i<light.size();i++){\\n            if(Stack.empty())\\n                Stack.push(i);\\n            else if(light[i] > light[Stack.top()])\\n                Stack.push(i);\\n            else{\\n                while(light[Stack.top()] > light[i]){\\n                    nextsmaller[Stack.top()]=light[i];\\n                    Stack.pop();\\n                    if(Stack.empty())\\n                        break;\\n                }\\n                Stack.push(i);\\n            }\\n        }\\n        int tillmax=INT_MIN;\\n        for(int i=0;i<light.size();i++){\\n            tillmax=max(tillmax,light[i]);\\n            tilllarger.push_back(tillmax);\\n        }\\n        int blue_bulbs=0;\\n        for(int i=0;i<n;i++){\\n            if(nextsmaller[i]==-1 & tilllarger[i]==i+1){\\n             blue_bulbs++;\\n            }\\n        }\\n        return blue_bulbs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 597232,
                "title": "5-lines-simple-cpp-o-n-and-2-variables-only",
                "content": "Think of it as when do we get a permutation of 1 to k when we  on the first k bulbs\\n\\n- See the logic is simple you need to identify the points when all bulbs will glow.\\n- This will happen only when bulbs from [1,2,..k] will glow \\n- That is at the instant when we \"ON\"  first k bulbs with any permutation of [1,2,3,...k] we will get all blue\\n- To check a range (0,i) is a  permutation logic is  **max(arr[0],arr[i])==i+1** i.e max of array from **(0,i)**  will be equal to its size i.e. **(i+1)**\\n- Count such instances \\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int n=light.size(),mxele=light[0],c=0;\\n        for(int i=0;i<n;i++){\\n            mxele=max(light[i],mxele);\\n            if(mxele==(i+1)) c++;  }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int n=light.size(),mxele=light[0],c=0;\\n        for(int i=0;i<n;i++){\\n            mxele=max(light[i],mxele);\\n            if(mxele==(i+1)) c++;  }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 596907,
                "title": "easy-to-understand-beats-100",
                "content": "\\n\\tclass Solution {\\n\\n\\t\\tpublic int numTimesAllBlue(int[] light) {\\n\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint sum=0, total=0;\\n\\t\\t\\tfor(int i = 0; i < light.length; i++){\\n\\t\\t\\t\\tsum+= light[i];\\n\\t\\t\\t\\ttotal +=(i+1);\\n\\t\\t\\t\\tif(sum == total)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n\\t\\tpublic int numTimesAllBlue(int[] light) {\\n\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tint sum=0, total=0;\\n\\t\\t\\tfor(int i = 0; i < light.length; i++){\\n\\t\\t\\t\\tsum+= light[i];\\n\\t\\t\\t\\ttotal +=(i+1);\\n\\t\\t\\t\\tif(sum == total)\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 593088,
                "title": "simple-count-the-bulbs-on-and-compare-with-max-on-java",
                "content": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int on=0, res = 0, max = -1;\\n        for(int i=0; i<light.length; i++){\\n            max = Math.max(max, light[i]);\\n            on++;\\n            if(on==max) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int on=0, res = 0, max = -1;\\n        for(int i=0; i<light.length; i++){\\n            max = Math.max(max, light[i]);\\n            on++;\\n            if(on==max) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543673,
                "title": "java-beats-100-small-code-and-explanation",
                "content": "Rephrasing the question as:\\nWhen the element index  \"i\" divide the array in to 2 parts such that the left part (including element at i) of the array has all the elements between \"1\" and \"i\" on the number series.  \\n```\\nclass Solution {\\n       public int numTimesAllBlue(int[] light) {\\n        int sum_so_far = 0;\\n        int numberSum = 0;\\n        int answer = 0;\\n        for (int i = 0; i < light.length; i++) {\\n            numberSum += (i + 1);\\n            sum_so_far += light[i];\\n            answer += numberSum == sum_so_far ? 1 : 0;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n       public int numTimesAllBlue(int[] light) {\\n        int sum_so_far = 0;\\n        int numberSum = 0;\\n        int answer = 0;\\n        for (int i = 0; i < light.length; i++) {\\n            numberSum += (i + 1);\\n            sum_so_far += light[i];\\n            answer += numberSum == sum_so_far ? 1 : 0;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533481,
                "title": "c-simple-solution-20-ms-100-w-explanation",
                "content": "The idea is to keep track of the most to-the-right on lightbulb. Say if we have lightbulb at index `n`, then that means to get blue ,we need at least `n` lightbulbs. Furthermore, all these `n` lightbulbs must occupy location `1 ... n`. If this happens, then we have a blue. If it doesn\\'t happen, then by pigeonhole principle we must have some on lightbulb(s) that are greater than `n`. But now our most to-the-right lightbulb would be updated to reflect this.\\n\\nThus under this invariance, we always have a blue if we have `n` lightbulbs lit and the most to-the-right lightbulb is `n`. This can be used to construct a simple `O(N)` solution.\\n\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int count = 0, max_ = 0, blue = 0;\\n        for(const auto &i: light) {\\n            max_ = max(max_, i);\\n            if(max_ == ++count) ++blue;\\n        }\\n        return blue;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int count = 0, max_ = 0, blue = 0;\\n        for(const auto &i: light) {\\n            max_ = max(max_, i);\\n            if(max_ == ++count) ++blue;\\n        }\\n        return blue;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 533169,
                "title": "c-simple-solution-using-stl",
                "content": "This was a **simple question** if we observed the explained testcase correctly. We keep on inserting the elements from the array in a **set**. After addition of each element, we check the size of the set and the value of the largest element of the set. If the size of the set is equal to the largest element, the scenario mentioned in the question was created. This was because only the bulbs on the left would be in blue color and the right ones have to be in off state. If any one of the bulbs on the right of the last blue bulb would be in on state, the mentioned scenario would not have been created.\\n\\nThus, the **space complexity** of the solution is **O(N)**\\nand the **time complexity** is **O(NlogN)** since we are using set and the set keeps the data sorted in ascending order by default.\\n\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int n = light.size();\\n        set<int>s;\\n        int res=0;\\n        for(int i=0; i<n; ++i){\\n            s.insert(light[i]);\\n            if(s.size() == *s.rbegin()) res+=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int n = light.size();\\n        set<int>s;\\n        int res=0;\\n        for(int i=0; i<n; ++i){\\n            s.insert(light[i]);\\n            if(s.size() == *s.rbegin()) res+=1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532962,
                "title": "greedy-o-1-space-o-n-time-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int maxsofar = 0;\\n        int ans = 0;\\n        for(int i =0; i < light.size(); i++){\\n            if(maxsofar < light[i]) maxsofar = light[i];\\n            if(maxsofar - i <= 1) ans++;\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        int maxsofar = 0;\\n        int ans = 0;\\n        for(int i =0; i < light.size(); i++){\\n            if(maxsofar < light[i]) maxsofar = light[i];\\n            if(maxsofar - i <= 1) ans++;\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532870,
                "title": "i-ms-100-faster-100-memory-java-5-line-solution-simple-arithmetic-operations",
                "content": "**CHECK SUM TO 0 from index - element**\\n\\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int sum =0, count =0;\\n        for(int i =0;i<light.length;i++)\\n        {\\n            sum = sum + ((i+1)-light[i]);\\n            if( sum == 0 )\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        int sum =0, count =0;\\n        for(int i =0;i<light.length;i++)\\n        {\\n            sum = sum + ((i+1)-light[i]);\\n            if( sum == 0 )\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532866,
                "title": "java-fenwick-tree-o-nlogn-time",
                "content": "- Time: `O(NlogN)`\\n-  Space: `O(N)`\\n\\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        if (light == null || light.length == 0) {\\n            return 0;\\n        }\\n\\n        final int N = light.length;\\n        int[] tree = new int[N + 1];\\n        Set<Integer> yellow = new HashSet<>();\\n\\n        int count = 0;\\n        for (int idx : light) {\\n            addNum(tree, idx, 1);\\n            if (query(tree, idx) == idx) {\\n                while (yellow.contains(idx + 1)) {\\n                    yellow.remove(++idx);\\n                }\\n                if (yellow.size() == 0) {\\n                    count++;\\n                }\\n            } else {\\n                yellow.add(idx);\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private void addNum(int[] tree, int idx, int num) {\\n        for (int i = idx; i < tree.length; i += lowbit(i)) {\\n            tree[i] += num;\\n        }\\n    }\\n\\n    private int query(int[] tree, int idx) {\\n        int sum = 0;\\n        for (int i = idx; i > 0; i -= lowbit(i)) {\\n            sum += tree[i];\\n        }\\n        return sum;\\n    }\\n\\n    private int lowbit(int x) {\\n        return x & -x;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] light) {\\n        if (light == null || light.length == 0) {\\n            return 0;\\n        }\\n\\n        final int N = light.length;\\n        int[] tree = new int[N + 1];\\n        Set<Integer> yellow = new HashSet<>();\\n\\n        int count = 0;\\n        for (int idx : light) {\\n            addNum(tree, idx, 1);\\n            if (query(tree, idx) == idx) {\\n                while (yellow.contains(idx + 1)) {\\n                    yellow.remove(++idx);\\n                }\\n                if (yellow.size() == 0) {\\n                    count++;\\n                }\\n            } else {\\n                yellow.add(idx);\\n            }\\n        }\\n        return count;\\n    }\\n\\n    private void addNum(int[] tree, int idx, int num) {\\n        for (int i = idx; i < tree.length; i += lowbit(i)) {\\n            tree[i] += num;\\n        }\\n    }\\n\\n    private int query(int[] tree, int idx) {\\n        int sum = 0;\\n        for (int i = idx; i > 0; i -= lowbit(i)) {\\n            sum += tree[i];\\n        }\\n        return sum;\\n    }\\n\\n    private int lowbit(int x) {\\n        return x & -x;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532576,
                "title": "simple-python-solution-in-o-n-time-and-o-1-space",
                "content": "Time Complexity: O(N)\\nSpace Complexity: O(1)\\n```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        cur_sum = max_sum = count = 0\\n        max_value = -1 \\n        for pos in light:\\n          cur_sum += pos\\n          if max_value < pos:\\n            max_value = pos\\n            max_sum = (pos*(pos+1))//2  #Calculating sum from 1 to pos\\n          if cur_sum == max_sum:\\n            count += 1\\n        return count\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, light: List[int]) -> int:\\n        cur_sum = max_sum = count = 0\\n        max_value = -1 \\n        for pos in light:\\n          cur_sum += pos\\n          if max_value < pos:\\n            max_value = pos\\n            max_sum = (pos*(pos+1))//2  #Calculating sum from 1 to pos\\n          if cur_sum == max_sum:\\n            count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532575,
                "title": "c-o-1-space-o-n-time",
                "content": "It\\'s important to note that once a bulb is turned ON it won\\'t be turned OFF. \\n\\nSo all you need to do is keep track of how many lightbulbs are currently turned on and the farthest right bulb that is turned on. \\n* If the number of ON lightbulbs == the farthest right bulb, then all of the bulbs to the left of the right bulb are ON, so we increment the count. \\n\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        if(light.size() == 0) return 0;\\n        \\n        int farthestRight = 0;\\n        int lightsOn = 0;\\n        int result = 0;\\n\\n        for(int i = 0; i < light.size(); i++)\\n        {\\n            farthestRight = max(farthestRight, light[i]);\\n            result += (farthestRight-1 == i);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& light) {\\n        if(light.size() == 0) return 0;\\n        \\n        int farthestRight = 0;\\n        int lightsOn = 0;\\n        int result = 0;\\n\\n        for(int i = 0; i < light.size(); i++)\\n        {\\n            farthestRight = max(farthestRight, light[i]);\\n            result += (farthestRight-1 == i);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532553,
                "title": "java-one-pass-solution-the-key-is-how-to-track-all-the-previous-left-bulbs-status",
                "content": "To solve this problem, we need to find a way to track all the previous(left) bulbs whether being turned on or not. \\n\\nOne trick I came up with is that we can use a **sorted array** to track the bulbs\\' status. We can imagine that **if a light is turned on then we add the light number to a sum**, that is, **if the sum of the current sorted array is equal to the light array, that means all the left bulbs are turned on**.\\n\\nFor example, given the lights array: [2, 1], the sorted array should be [1, 2]. When all the previous(left) bulb are turned on, the sum should be equal, which is 3. And **there is 1 time those 2 sum values are equal, so the answer is 1**.\\n\\nThe number of blue bulb = How many times do the light array and sorted array have the same sum.\\n\\nBy knowing this, the solution of this problem will be extremly easy and clean. Here is my code:\\n\\n```\\n    public int numTimesAllBlue(int[] light) {\\n        if (light.length == 1) {\\n            return 1;\\n        }\\n        int res = 0, sum1 = 0, sum2 = 0;\\n        int[] temp = light.clone();\\n        Arrays.sort(temp);\\n        for (int i = 0; i < temp.length; i++) {\\n            sum1 += temp[i];\\n            sum2 += light[i];\\n            if (sum1 == sum2) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numTimesAllBlue(int[] light) {\\n        if (light.length == 1) {\\n            return 1;\\n        }\\n        int res = 0, sum1 = 0, sum2 = 0;\\n        int[] temp = light.clone();\\n        Arrays.sort(temp);\\n        for (int i = 0; i < temp.length; i++) {\\n            sum1 += temp[i];\\n            sum2 += light[i];\\n            if (sum1 == sum2) {\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532532,
                "title": "o-1-space-o-n-time-solution-very-simple",
                "content": "Key observation:\\n1. `index + 1` equals num of lights were turned on.\\n2. track the maximum id of lights was turned on so far.  if `max === index +1`, we know that all lights we seen were turned on.\\n\\n```js\\n/**\\n * @param {number[]} light\\n * @return {number}\\n */\\nconst numTimesAllBlue = function (light) {\\n  let moment = 0\\n  let max = -1\\n  for (let i = 0; i < light.length; i++) {\\n    max = Math.max(max, light[i])\\n    if (i + 1 === max) {\\n      moment += 1\\n    }\\n  }\\n  return moment\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[]} light\\n * @return {number}\\n */\\nconst numTimesAllBlue = function (light) {\\n  let moment = 0\\n  let max = -1\\n  for (let i = 0; i < light.length; i++) {\\n    max = Math.max(max, light[i])\\n    if (i + 1 === max) {\\n      moment += 1\\n    }\\n  }\\n  return moment\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532522,
                "title": "java-union-find-o-n-alpha",
                "content": "```\\nclass Solution {\\n    class DSU{\\n        int[] parent;\\n        int[] size;\\n        \\n        public DSU(int N){\\n            parent = new int[N];\\n            size = new int[N];\\n            for(int i=0; i<parent.length; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int x){\\n            if(parent[x]!=x){\\n                parent[x] = find(parent[x]);\\n            }\\n            return parent[x];\\n        }\\n        \\n        public void union(int x, int y){\\n            int xParent = find(x);\\n            int yParent = find(y);\\n            if(xParent==yParent) return;\\n            if(size[xParent]<=size[yParent]){\\n                parent[xParent] = yParent;\\n                size[yParent]+=size[xParent];\\n            }\\n            else{\\n                parent[yParent] = xParent;\\n                size[xParent] = yParent;\\n            }\\n        }\\n    }\\n    \\n    public int numTimesAllBlue(int[] light) {\\n        int n = light.length;\\n        DSU dsu = new DSU(n+1);\\n        int last = 0;\\n        boolean[] bulbs = new boolean[n+1];\\n        int res = 0;\\n        for(int l : light){\\n            last = Math.max(last, l);\\n            bulbs[l] = true;\\n            if(bulbs[l-1]){\\n                dsu.union(l, l-1);\\n            }\\n            if(l+1<n+1&&bulbs[l+1]){\\n                dsu.union(l, l+1);\\n            }\\n            if(dsu.find(last)==dsu.find(1)){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class DSU{\\n        int[] parent;\\n        int[] size;\\n        \\n        public DSU(int N){\\n            parent = new int[N];\\n            size = new int[N];\\n            for(int i=0; i<parent.length; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        public int find(int x){\\n            if(parent[x]!=x){\\n                parent[x] = find(parent[x]);\\n            }\\n            return parent[x];\\n        }\\n        \\n        public void union(int x, int y){\\n            int xParent = find(x);\\n            int yParent = find(y);\\n            if(xParent==yParent) return;\\n            if(size[xParent]<=size[yParent]){\\n                parent[xParent] = yParent;\\n                size[yParent]+=size[xParent];\\n            }\\n            else{\\n                parent[yParent] = xParent;\\n                size[xParent] = yParent;\\n            }\\n        }\\n    }\\n    \\n    public int numTimesAllBlue(int[] light) {\\n        int n = light.length;\\n        DSU dsu = new DSU(n+1);\\n        int last = 0;\\n        boolean[] bulbs = new boolean[n+1];\\n        int res = 0;\\n        for(int l : light){\\n            last = Math.max(last, l);\\n            bulbs[l] = true;\\n            if(bulbs[l-1]){\\n                dsu.union(l, l-1);\\n            }\\n            if(l+1<n+1&&bulbs[l+1]){\\n                dsu.union(l, l+1);\\n            }\\n            if(dsu.find(last)==dsu.find(1)){\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035607,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        rs = 0\\n        n = len(flips)\\n        a = [0] * n\\n        ans = 0\\n\\n        for i in range(n):\\n            idx = flips[i] - 1\\n            a[idx] = 1\\n\\n            rs += a[i]\\n\\n            if idx < i:\\n                rs += 1\\n            \\n            if rs == i + 1:\\n                ans += 1\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        rs = 0\\n        n = len(flips)\\n        a = [0] * n\\n        ans = 0\\n\\n        for i in range(n):\\n            idx = flips[i] - 1\\n            a[idx] = 1\\n\\n            rs += a[i]\\n\\n            if idx < i:\\n                rs += 1\\n            \\n            if rs == i + 1:\\n                ans += 1\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035606,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        rs = 0\\n        n = len(flips)\\n        a = [0] * n\\n        ans = 0\\n\\n        for i in range(n):\\n            idx = flips[i] - 1\\n            a[idx] = 1\\n\\n            rs += a[i]\\n\\n            if idx < i:\\n                rs += 1\\n            \\n            if rs == i + 1:\\n                ans += 1\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        rs = 0\\n        n = len(flips)\\n        a = [0] * n\\n        ans = 0\\n\\n        for i in range(n):\\n            idx = flips[i] - 1\\n            a[idx] = 1\\n\\n            rs += a[i]\\n\\n            if idx < i:\\n                rs += 1\\n            \\n            if rs == i + 1:\\n                ans += 1\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022410,
                "title": "python3-concise-straight-forward-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        \\n        n=len(flips)\\n        ans=mask=curr=0\\n        \\n        for i,f in enumerate(flips):\\n            curr+=(1<<(n-i-1))\\n            mask=mask^(1<<(n-f))\\n            if curr==mask:\\n                ans+=1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        \\n        n=len(flips)\\n        ans=mask=curr=0\\n        \\n        for i,f in enumerate(flips):\\n            curr+=(1<<(n-i-1))\\n            mask=mask^(1<<(n-f))\\n            if curr==mask:\\n                ans+=1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4012065,
                "title": "java-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        // /lets throw it \\n        int throwd = flips[0] , res= 0 ;\\n        for( int i = 0 ; i < flips.length ; i++){\\n            throwd = Math.max(throwd , flips[i]);\\n            if(i+1 == throwd ) res++;\\n        }\\n        return res;\\n\\n    }\\n}\\n// 1 2 3 4 5\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        // /lets throw it \\n        int throwd = flips[0] , res= 0 ;\\n        for( int i = 0 ; i < flips.length ; i++){\\n            throwd = Math.max(throwd , flips[i]);\\n            if(i+1 == throwd ) res++;\\n        }\\n        return res;\\n\\n    }\\n}\\n// 1 2 3 4 5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969299,
                "title": "typescript-o-n-simple-solution-with-explanation",
                "content": "# Intuition\\nBy the definition of 1-prefixed in this problem, if we\\'re given a flip index of i, which causes the array to be 1-prefiex, we must have seen flips for `1, 2, 3, ... i - 1` already. This can only happen if the largest flip we\\'ve seen so far is equal to the index of the flip in `flips`, meaning all prior index flips happened in the prefix of `i`. If any flip happened after `i`, then at least one bit before `i` must be 0.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction numTimesAllBlue(flips: number[]): number {\\n    let max = 0, res = 0;\\n    for (let i = 0; i < flips.length; i++) {\\n        if (flips[i] > max) max = flips[i];\\n        if (max === i + 1) res += 1;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction numTimesAllBlue(flips: number[]): number {\\n    let max = 0, res = 0;\\n    for (let i = 0; i < flips.length; i++) {\\n        if (flips[i] > max) max = flips[i];\\n        if (max === i + 1) res += 1;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941755,
                "title": "python-solution-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        n = len(flips)\\n        l = 1e9\\n        r = 0\\n        res = 0\\n        flipOne = False\\n        for i in range(n):\\n            if flips[i] == 1: flipOne = True\\n            if flips[i] < l:\\n                l = flips[i]\\n            if flips[i] > r:\\n                r = flips[i]\\n            if (r - l + 1) == i + 1 and flipOne:\\n                res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        n = len(flips)\\n        l = 1e9\\n        r = 0\\n        res = 0\\n        flipOne = False\\n        for i in range(n):\\n            if flips[i] == 1: flipOne = True\\n            if flips[i] < l:\\n                l = flips[i]\\n            if flips[i] > r:\\n                r = flips[i]\\n            if (r - l + 1) == i + 1 and flipOne:\\n                res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3933504,
                "title": "simple-c-compare-highest-flipped-position-to-number-of-flips",
                "content": "# Intuition\\nIf the highest flipped position equals to number of flips, all positions before it must have been flipped too. This is true because of the constraint: **`flip`s is a permutation of the integers in the range `[1, n]`**, so no position can be flipped twice.\\n\\n# Approach\\nIterate over flips and compare with number of flips so far (number of flips is `i + 1` because `i` starts with 0 for the first flip). `flip_end` is inclusive.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int flip_end = flips[0];\\n        int result = 0;\\n        \\n        for (int i = 0; i < flips.size(); i++) {\\n            if (flips[i] > flip_end) {\\n                flip_end = flips[i];\\n            }\\n\\n            result += (flip_end == i + 1);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int flip_end = flips[0];\\n        int result = 0;\\n        \\n        for (int i = 0; i < flips.size(); i++) {\\n            if (flips[i] > flip_end) {\\n                flip_end = flips[i];\\n            }\\n\\n            result += (flip_end == i + 1);\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928695,
                "title": "c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int maximum = 0, ans = 0;\\n        for(int i = 0; i < flips.size(); i++) {\\n            maximum = max(maximum, flips[i]);\\n            if(i + 1 == maximum) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int maximum = 0, ans = 0;\\n        for(int i = 0; i < flips.size(); i++) {\\n            maximum = max(maximum, flips[i]);\\n            if(i + 1 == maximum) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928157,
                "title": "c-solution-time-o-n-space-o-1",
                "content": "# Complexity\\n- Time complexity: O(n) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int NumTimesAllBlue(int[] flips) {\\n        int count = 0, sum = 1;\\n\\n            if (flips[0] == sum)\\n            {\\n                count++;\\n            }\\n            for (int i = 1; i < flips.Length; i++)\\n            {\\n                sum += i+1;\\n                flips[i] += flips[i - 1];\\n                if(sum == flips[i])\\n                {\\n                    count++;\\n                }\\n            }\\n\\n            return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumTimesAllBlue(int[] flips) {\\n        int count = 0, sum = 1;\\n\\n            if (flips[0] == sum)\\n            {\\n                count++;\\n            }\\n            for (int i = 1; i < flips.Length; i++)\\n            {\\n                sum += i+1;\\n                flips[i] += flips[i - 1];\\n                if(sum == flips[i])\\n                {\\n                    count++;\\n                }\\n            }\\n\\n            return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919633,
                "title": "easy-cpp-solution",
                "content": "\\n# Approach\\nkeep track of maximum flip[i] element from 0th index to ith index.\\nwhen i + 1 == flip[i](1-index based), increase the count.\\nbecause we have flipped maximum flip[i] element and we need all the bits between 0 to flip[i] should be \\'1\\'. and i + 1 indicate that we have fliped i+1 \\'0\\' to \\'1\\'.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int n = flips.size(), maxi = 0;\\n        int count = 0;\\n        for(int i = 0; i < flips.size(); i++){\\n            maxi = max(maxi,flips[i]);\\n            if(i + 1 == maxi){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int n = flips.size(), maxi = 0;\\n        int count = 0;\\n        for(int i = 0; i < flips.size(); i++){\\n            maxi = max(maxi,flips[i]);\\n            if(i + 1 == maxi){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919371,
                "title": "c-simple-soluton-time-complexity-o-n-space-complexity-o-1",
                "content": "Intuition\\nThink of situation , when the string string contains all 1 to left half of string and all 0 in rest half .\\nWe starts traversing the array and when we are at ith index ,  we have seen all numbers from 1 to i only then  binary string will be prefix aligned .\\nFor example :\\nflips = [3,2,4,1,5]\\nstring 00000\\nStart traversing\\nflips = [**3**,2,4,1,5]\\nstring 00100\\nflips = [3,**2**,4,1,5]\\nstring 01100\\nflips = [3,2,**4**,1,5]\\nstring 01110\\nflips = [3,2,4,**1**,5]\\nstring 11110\\n\\nnow you can observe , we got all 1 in lefthalf when we see all conseutive number from 1 to 4 from array.\\n\\nflips = [3,2,4,1,**5**]\\nstring 11111\\nanother valid string so the anwer will be 2.\\n\\nNow what is the easiest way to check when we have seen all element in range [1,i]  , just sum up all element till ith index and the expected sum will be the AP sum of i term and increment count if they are equal.\\n\\n**Time Complexity : O(N)\\nSpace Complexity : O(1)**\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int count=0;\\n        long long sum=0;\\n        for(long long i=1;i<=flips.size();i++){\\n            sum+=flips[i-1];\\n            long long expectedSum = i*(i+1)/2;\\n            count+=(sum==expectedSum);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int count=0;\\n        long long sum=0;\\n        for(long long i=1;i<=flips.size();i++){\\n            sum+=flips[i-1];\\n            long long expectedSum = i*(i+1)/2;\\n            count+=(sum==expectedSum);\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3912470,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n                return retr(flips);        \\n    \\n    }\\n       public static  int retr(int arr[]){\\n\\n        int ans = 0;\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max) max = arr[i];\\n            if(max==i+1) ans++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n                return retr(flips);        \\n    \\n    }\\n       public static  int retr(int arr[]){\\n\\n        int ans = 0;\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max) max = arr[i];\\n            if(max==i+1) ans++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897871,
                "title": "python-bitwise",
                "content": "# Intuition\\nSet bit of flip[i], and check [1, i] are all ones by masking.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        n = len(flips)\\n        count = n-1\\n        mask = 1 << count\\n        initial = 0\\n        res = 0\\n        for idx in range(1, n+1):\\n            b = flips[idx - 1]\\n            initial |= (1 << (n - b))\\n            # print(\"{0:b}\".format(initial))\\n            # print(\"{0:b}\".format(mask))\\n            # print(\"{0:b}\".format(initial & mask))\\n            # print(\"----\")\\n            if initial & mask == mask:\\n                res += 1\\n            count -= 1\\n            if count > 0:\\n                mask |= 1 << count\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        n = len(flips)\\n        count = n-1\\n        mask = 1 << count\\n        initial = 0\\n        res = 0\\n        for idx in range(1, n+1):\\n            b = flips[idx - 1]\\n            initial |= (1 << (n - b))\\n            # print(\"{0:b}\".format(initial))\\n            # print(\"{0:b}\".format(mask))\\n            # print(\"{0:b}\".format(initial & mask))\\n            # print(\"----\")\\n            if initial & mask == mask:\\n                res += 1\\n            count -= 1\\n            if count > 0:\\n                mask |= 1 << count\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842848,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    \\n /*   static boolean check(int arr[],int a){\\n        int n = arr.length;\\n\\n        for(int i=0; i<=a; i++){\\n            if(arr[i]==0) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n\\n    static int helper(int flips[]){\\n        int n = flips.length;\\n        int arr[] = new int[n];\\n\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            arr[flips[i]-1]=1;\\n            if(check(arr,i)) ans++;\\n        }\\n\\n        return ans;\\n    }\\n    */\\n\\n    static int helper2(int arr[]){\\n        int n = arr.length;\\n\\n        int ans = 0;\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i=0; i<n; i++){\\n            if(arr[i]>max) max = arr[i];\\n            if(max==i+1) ans++;\\n        }\\n\\n        return ans;\\n    }\\n    public int numTimesAllBlue(int[] flips) {\\n\\n        return helper2(flips);        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n /*   static boolean check(int arr[],int a){\\n        int n = arr.length;\\n\\n        for(int i=0; i<=a; i++){\\n            if(arr[i]==0) return false;\\n        }\\n\\n        return true;\\n\\n    }\\n\\n    static int helper(int flips[]){\\n        int n = flips.length;\\n        int arr[] = new int[n];\\n\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<n; i++){\\n            arr[flips[i]-1]=1;\\n            if(check(arr,i)) ans++;\\n        }\\n\\n        return ans;\\n    }\\n    */\\n\\n    static int helper2(int arr[]){\\n        int n = arr.length;\\n\\n        int ans = 0;\\n        int max = Integer.MIN_VALUE;\\n\\n        for(int i=0; i<n; i++){\\n            if(arr[i]>max) max = arr[i];\\n            if(max==i+1) ans++;\\n        }\\n\\n        return ans;\\n    }\\n    public int numTimesAllBlue(int[] flips) {\\n\\n        return helper2(flips);        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841614,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) \\n    {\\n        int cnt=0;\\n        int highest=0;\\n        int ans=0;\\n        for (int i=0;i<flips.size();i++)\\n        {\\n            highest=max(flips[i],highest);\\n            cnt++;\\n            if (cnt==i+1 && highest==i+1) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) \\n    {\\n        int cnt=0;\\n        int highest=0;\\n        int ans=0;\\n        for (int i=0;i<flips.size();i++)\\n        {\\n            highest=max(flips[i],highest);\\n            cnt++;\\n            if (cnt==i+1 && highest==i+1) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788957,
                "title": "short-and-intuitive-solution-c",
                "content": "# Intuition\\n\\n\\n# Approach\\nvectors contains permutation of numbers from 1 to n where n is the size of given vector.\\nso for 1-indexed vector if we check the max value at any index and if it is equal to the index itself it means that till ith index it contains all the number from 1 to i and it means that all the numbers are 1\\'s from 1 to i and rest are 0,in this case we will increase our count. this is the simple approach for this problem,hope you get it.\\n\\n# Complexity\\n- Time complexity:\\n0(n)\\n\\n- Space complexity:\\n0(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n       int n=flips.size();\\n      int count=0;\\n      int maxi=0;\\n      for(int i=0;i<n;i++){\\n          maxi=max(maxi,flips[i]);\\n          if(maxi==i+1)\\n          count++;\\n      }\\n      return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n       int n=flips.size();\\n      int count=0;\\n      int maxi=0;\\n      for(int i=0;i<n;i++){\\n          maxi=max(maxi,flips[i]);\\n          if(maxi==i+1)\\n          count++;\\n      }\\n      return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786037,
                "title": "best-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. --> Traverse the array and count when the consecutive integer number sum is equal to the array consequtive element sum.\\n\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int n = flips.size();\\n        int sum =0,csum =0,ans =0;\\n        for(int i=0;i<n;i++){\\n            sum+=flips[i];\\n            csum+=i+1;\\n            if(sum==csum) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int n = flips.size();\\n        int sum =0,csum =0,ans =0;\\n        for(int i=0;i<n;i++){\\n            sum+=flips[i];\\n            csum+=i+1;\\n            if(sum==csum) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782105,
                "title": "direct-approach-using-java",
                "content": "\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] nums) {\\n        int count = 0,max = -999999;\\n        for(int i=0;i<nums.length;i++){\\n            if(max<nums[i])\\n                max = nums[i];\\n            if(max==(i+1))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] nums) {\\n        int count = 0,max = -999999;\\n        for(int i=0;i<nums.length;i++){\\n            if(max<nums[i])\\n                max = nums[i];\\n            if(max==(i+1))\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780997,
                "title": "my-solutions",
                "content": "**1. Use the Fenwick Tree**\\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `flips`\\n */\\nclass Solution {\\n private:\\n  class FenwickTree {\\n   public:\\n    FenwickTree(const int n) : tree_(n) {\\n    }\\n    \\n    int read(const int i) {\\n      int ret = 0;\\n      for (int index = i; index > 0; index -= index & -index) {\\n        ret += tree_[index - 1];\\n      }\\n      return ret;\\n    }\\n    \\n    void update(const int i, const int delta) {\\n      const int n = static_cast<int>(tree_.size());\\n      for (int index = i; index <= n; index += index & -index) {\\n        tree_[index - 1] += delta;\\n      }\\n    }\\n    \\n   private:\\n    vector<int> tree_;\\n  };\\n  \\n public:\\n  int numTimesAllBlue(const vector<int> &flips) {\\n    const int n = static_cast<int>(flips.size());\\n    FenwickTree fenwick_tree(n);\\n    int ret = 0;\\n    for (int i = 0; i < n; ++i) {\\n      fenwick_tree.update(flips[i], 1);\\n      if (fenwick_tree.read(i + 1) == i + 1) {\\n        ++ret;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Check whether the maximum bit which has been flipped is equal to the number of bits which have been flipped**\\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `flips`\\n */\\nclass Solution {\\n public:\\n  int numTimesAllBlue(const vector<int> &flips) {\\n    const int n = static_cast<int>(flips.size());\\n    int ret = 0;\\n    int max_bit = 0;\\n    for (int i = 0; i < n; ++i) {\\n      const int bit = flips[i];\\n      max_bit = max(max_bit, bit);\\n      if (max_bit == i + 1) {\\n        ++ret;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `flips`\\n */\\nclass Solution {\\n private:\\n  class FenwickTree {\\n   public:\\n    FenwickTree(const int n) : tree_(n) {\\n    }\\n    \\n    int read(const int i) {\\n      int ret = 0;\\n      for (int index = i; index > 0; index -= index & -index) {\\n        ret += tree_[index - 1];\\n      }\\n      return ret;\\n    }\\n    \\n    void update(const int i, const int delta) {\\n      const int n = static_cast<int>(tree_.size());\\n      for (int index = i; index <= n; index += index & -index) {\\n        tree_[index - 1] += delta;\\n      }\\n    }\\n    \\n   private:\\n    vector<int> tree_;\\n  };\\n  \\n public:\\n  int numTimesAllBlue(const vector<int> &flips) {\\n    const int n = static_cast<int>(flips.size());\\n    FenwickTree fenwick_tree(n);\\n    int ret = 0;\\n    for (int i = 0; i < n; ++i) {\\n      fenwick_tree.update(flips[i], 1);\\n      if (fenwick_tree.read(i + 1) == i + 1) {\\n        ++ret;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(1)\\n * where `n` is the length of the vector `flips`\\n */\\nclass Solution {\\n public:\\n  int numTimesAllBlue(const vector<int> &flips) {\\n    const int n = static_cast<int>(flips.size());\\n    int ret = 0;\\n    int max_bit = 0;\\n    for (int i = 0; i < n; ++i) {\\n      const int bit = flips[i];\\n      max_bit = max(max_bit, bit);\\n      if (max_bit == i + 1) {\\n        ++ret;\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780161,
                "title": "easy-and-coincise-solution-beats-91-37-of-runtime",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def numTimesAllBlue(self, flips):\\n\\n        pivot = flips[0]\\n        ans = 1 if pivot == 1 else 0\\n        left = 0\\n        \\n        for i in range(1, len(flips)):\\n            \\n            if flips[i] > pivot:\\n                pivot = flips[i]\\n\\n            left += 1\\n            \\n            if left == pivot - 1: \\n                ans += 1 \\n\\n        return ans\\n\\n                \\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution(object):\\n    def numTimesAllBlue(self, flips):\\n\\n        pivot = flips[0]\\n        ans = 1 if pivot == 1 else 0\\n        left = 0\\n        \\n        for i in range(1, len(flips)):\\n            \\n            if flips[i] > pivot:\\n                pivot = flips[i]\\n\\n            left += 1\\n            \\n            if left == pivot - 1: \\n                ans += 1 \\n\\n        return ans\\n\\n                \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3779157,
                "title": "c-simple-math-solution-o-n",
                "content": "Since we want to check if at any point we have a continuous block of 1s starting from index 0, we just need to continuously sum the index values and compare them to the sum of the array values at each point. If they are equal, we have a continuous block of 1s starting from index 0.\\n```\\nclass Solution {\\npublic:\\n  int numTimesAllBlue(vector<int>& flips) {\\n    long long maxsum = 0;\\n    long long currsum = 0;\\n    int ans = 0;\\n    for (int i = 0; i < flips.size(); i++) {\\n      maxsum += i+1;\\n      currsum += flips[i];\\n      if (maxsum == currsum) ans++;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int numTimesAllBlue(vector<int>& flips) {\\n    long long maxsum = 0;\\n    long long currsum = 0;\\n    int ans = 0;\\n    for (int i = 0; i < flips.size(); i++) {\\n      maxsum += i+1;\\n      currsum += flips[i];\\n      if (maxsum == currsum) ans++;\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750257,
                "title": "interesting-solution-using-union-find-not-optimal-time-o-nlogn-space-o-n",
                "content": "**PLEASE NOTE** : This is not an optimal solution. The optimal solution has:\\n* Time complexity: $$O(n)$$\\n* Space complexity: $$O(1)$$\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nConnect all the flipped bits and if the farthest (from first bit) flipped bit has first bit as its root the the string is prefix aligned.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nUse Disjoint set to form the flipped bits connection.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n    \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            self.root[rootY] = rootX\\n\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        ones = set()\\n        maxi = 0\\n        n = len(flips)\\n        uf = UnionFind(n)\\n        count = 0\\n        for flip in flips:\\n            flip -= 1\\n            ones.add(flip)\\n            maxi = max(maxi, flip)\\n            if flip-1 in ones:\\n                uf.union(flip-1, flip)\\n            \\n            if flip + 1 in ones:\\n                uf.union(flip, flip+1)\\n\\n            if uf.find(maxi) == 0:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass UnionFind:\\n    def __init__(self, size):\\n        self.root = [i for i in range(size)]\\n    \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n\\n    def union(self, x, y):\\n        rootX = self.find(x)\\n        rootY = self.find(y)\\n        if rootX != rootY:\\n            self.root[rootY] = rootX\\n\\nclass Solution:\\n    def numTimesAllBlue(self, flips: List[int]) -> int:\\n        ones = set()\\n        maxi = 0\\n        n = len(flips)\\n        uf = UnionFind(n)\\n        count = 0\\n        for flip in flips:\\n            flip -= 1\\n            ones.add(flip)\\n            maxi = max(maxi, flip)\\n            if flip-1 in ones:\\n                uf.union(flip-1, flip)\\n            \\n            if flip + 1 in ones:\\n                uf.union(flip, flip+1)\\n\\n            if uf.find(maxi) == 0:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3718296,
                "title": "java-from-16-to-100-faster-with-and-without-hashset",
                "content": "# Intuition\\nl - is the largest number so far.\\nUsing HashSet to keep the indices and check whether size of it equals largest number so far.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Solution 1 | 14ms | 16% Faster\\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        int l = 0, count = 0;\\n        Set<Integer> setIndOfOne = new HashSet<>();\\n        for (int i = 0; i < flips.length; i++) {\\n            int curr = flips[i];\\n            setIndOfOne.add(curr);\\n            if (l < curr) l = curr;\\n            if (setIndOfOne.size() == l) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Intuition\\nWhen I understood the basic idea I just keep l - largest number and increment c - counter of 1s. \\n\\nIf c == l, then increment result, thus counting cases when there only 1s on left and 0s on the right.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n# Solution 2 | 1ms | 100% Faster\\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        int l = 0, c = 0, res = 0;\\n        for (int i = 0; i < flips.length; i++) {\\n            int curr = flips[i];\\n            if (l < curr) l = curr;  \\n            if (++c >= l) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        int l = 0, count = 0;\\n        Set<Integer> setIndOfOne = new HashSet<>();\\n        for (int i = 0; i < flips.length; i++) {\\n            int curr = flips[i];\\n            setIndOfOne.add(curr);\\n            if (l < curr) l = curr;\\n            if (setIndOfOne.size() == l) count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numTimesAllBlue(int[] flips) {\\n        int l = 0, c = 0, res = 0;\\n        for (int i = 0; i < flips.length; i++) {\\n            int curr = flips[i];\\n            if (l < curr) l = curr;  \\n            if (++c >= l) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679628,
                "title": "easy-to-understand-javascript-solution",
                "content": "```\\nvar numTimesAllBlue = function(flips) {\\n    let end = count = result = 0;\\n\\n    for (const flip of flips) {\\n        end = Math.max(end, flip);\\n        count += 1;\\n        if (end !== count) continue;\\n        result += 1;  \\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numTimesAllBlue = function(flips) {\\n    let end = count = result = 0;\\n\\n    for (const flip of flips) {\\n        end = Math.max(end, flip);\\n        count += 1;\\n        if (end !== count) continue;\\n        result += 1;  \\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3649600,
                "title": "c-easy-solution-using-set-and-left-and-right-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        multiset<int> s;\\n        int c=0;\\n        for(auto it: flips){\\n            s.insert(it);\\n            \\n            if(*rbegin(s)==s.size() and *(s.begin())==1){\\n                c+=1;\\n\\n            }\\n        }\\n        \\n        return c;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        multiset<int> s;\\n        int c=0;\\n        for(auto it: flips){\\n            s.insert(it);\\n            \\n            if(*rbegin(s)==s.size() and *(s.begin())==1){\\n                c+=1;\\n\\n            }\\n        }\\n        \\n        return c;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639385,
                "title": "java-by-use-bit",
                "content": "```\\nclass Solution {\\n    /*\\n    Input: light = [2,1,3,5,4]\\n    Output: 3\\n    Explanation: The moments when all the lights that are on turn blue are 1, 2 and 4 respectively.\\n      \\n    We can map the lights to the subscripts of a tree array and initialise each position with a 1 to represent the lights that are off at each position.\\n    When we need to turn on a light at a location, we update the value of that location to 0, record the maximum number of lights that are currently on, and then query the status of all lights before that number.\\n    If the prefix sum is 0 at this point, then all lights are on.\\n     */\\n    int[] tree;\\n\\n    public int numTimesAllBlue(int[] light) {\\n        int n = light.length;\\n        tree = new int[n + 1]; // Tree arrays\\n        for (int i = 1; i <= n; i++) update(i, 1); // \\n\\n        int res = 0;\\n        int max = 0; \\n        // Record the maximum number of lights that are currently illuminated\\n        for (int i = 0;i<light.length;i++) {\\n            int l = light[i];\\n            update(l, -1);\\n            max = Math.max(max, l);\\n\\n            if (sum(i+1) == 0) res++;\\n        }\\n        return res;\\n    }\\n\\n    void update(int index, int delta) {\\n        while (index < tree.length) {\\n            tree[index] += delta;\\n            index += lowBit(index);\\n        }\\n    }\\n\\n    int sum(int index) {\\n        int res = 0;\\n        while (index > 0) {\\n            res += tree[index];\\n            index -= lowBit(index);\\n        }\\n        return res;\\n    }\\n\\n    int lowBit(int x) {\\n        return x & (-x);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    /*\\n    Input: light = [2,1,3,5,4]\\n    Output: 3\\n    Explanation: The moments when all the lights that are on turn blue are 1, 2 and 4 respectively.\\n      \\n    We can map the lights to the subscripts of a tree array and initialise each position with a 1 to represent the lights that are off at each position.\\n    When we need to turn on a light at a location, we update the value of that location to 0, record the maximum number of lights that are currently on, and then query the status of all lights before that number.\\n    If the prefix sum is 0 at this point, then all lights are on.\\n     */\\n    int[] tree;\\n\\n    public int numTimesAllBlue(int[] light) {\\n        int n = light.length;\\n        tree = new int[n + 1]; // Tree arrays\\n        for (int i = 1; i <= n; i++) update(i, 1); // \\n\\n        int res = 0;\\n        int max = 0; \\n        // Record the maximum number of lights that are currently illuminated\\n        for (int i = 0;i<light.length;i++) {\\n            int l = light[i];\\n            update(l, -1);\\n            max = Math.max(max, l);\\n\\n            if (sum(i+1) == 0) res++;\\n        }\\n        return res;\\n    }\\n\\n    void update(int index, int delta) {\\n        while (index < tree.length) {\\n            tree[index] += delta;\\n            index += lowBit(index);\\n        }\\n    }\\n\\n    int sum(int index) {\\n        int res = 0;\\n        while (index > 0) {\\n            res += tree[index];\\n            index -= lowBit(index);\\n        }\\n        return res;\\n    }\\n\\n    int lowBit(int x) {\\n        return x & (-x);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3637401,
                "title": "simple-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int maxIdx = 0;\\n        int zeroCount = 0;\\n\\n        int ans = 0;\\n        for(int flip: flips) {\\n            if (flip > maxIdx) {\\n                int diff = flip - maxIdx;\\n                maxIdx = flip;\\n                zeroCount = diff + zeroCount - 1;\\n            } else {\\n                zeroCount--;\\n            }\\n\\n            if (zeroCount == 0) {\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTimesAllBlue(vector<int>& flips) {\\n        int maxIdx = 0;\\n        int zeroCount = 0;\\n\\n        int ans = 0;\\n        for(int flip: flips) {\\n            if (flip > maxIdx) {\\n                int diff = flip - maxIdx;\\n                maxIdx = flip;\\n                zeroCount = diff + zeroCount - 1;\\n            } else {\\n                zeroCount--;\\n            }\\n\\n            if (zeroCount == 0) {\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569796,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "For the test case `light = [4,1,2,3]`, we would have:\\n(I am using `0` to indicate off and `1` for on and `B` for blue)\\nmoment 0: 0001\\nmoment 1: B001 (Here bulb-1 is on and there\\'s no other bulbs left of it, it should turn blue)\\nmoment 2: BB01 (Here bulb-2 is on and bulb-1 is on therefore bulb-2 should turn blue)\\nmoment 3: BBBB (Here bulb-2 and bulb-1 are on and therefore bulb-3 turns blue)\\n\\nSo the result should be 3?\\n"
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "no because it is clearly mentioned that only those bits that are in the range of [1,i](where i is the step you are at) should be 1, rest of the bits should be 0 as well...as you can see that during \"moment1\", [1,i] condition is satisfied, but the 4th bit is 1 too. similarly in \"moment2\" and 3 as well, the 4th bit is violating the criteria. and it is satisfied only for the last step, that is 4th, where all bits from [1,4] are 1."
                    },
                    {
                        "username": "worldnihao",
                        "content": "The prefix align problem is a little different from bulbs"
                    },
                    {
                        "username": "Anurag-S1ngh",
                        "content": "i applied simple xor operation and it work for 57/63 cases\\n        int cnt = 0;\\n        int xor = 0;\\n\\n        for(int i=0; i<flips.length; i++){\\n            xor ^= flips[i] ^ i+1;\\n            if(xor == 0) cnt++;\\n        }\\n        return cnt;\\n\\nbut why is not working for this test case\\n[1,2,3,10,13,6,7,12,5,4,11,8,9,14,15,16,17,18,19,20,21]\\no/p = 14\\nexpected = 12"
                    },
                    {
                        "username": "anmoldau_50",
                        "content": "They are saying--> A binary string is prefix-aligned if, after the ith step, all the bits in the inclusive range [1, i] are ones and all the other bits are zeros.\nNote that the line says all other bits other than the range should be zero but in the very first example at step 4\n\n--> After applying step 4: The string becomes \"11110\", which is prefix-aligned.\n i is 1 so according to question only the bit 1 should be 1 and other 2,3,4,5 should be zero\n then only the given criteria should match\n but they are considering it as answer dont know what the shit the write in description."
                    }
                ]
            },
            {
                "id": 1868684,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "For the test case `light = [4,1,2,3]`, we would have:\\n(I am using `0` to indicate off and `1` for on and `B` for blue)\\nmoment 0: 0001\\nmoment 1: B001 (Here bulb-1 is on and there\\'s no other bulbs left of it, it should turn blue)\\nmoment 2: BB01 (Here bulb-2 is on and bulb-1 is on therefore bulb-2 should turn blue)\\nmoment 3: BBBB (Here bulb-2 and bulb-1 are on and therefore bulb-3 turns blue)\\n\\nSo the result should be 3?\\n"
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "no because it is clearly mentioned that only those bits that are in the range of [1,i](where i is the step you are at) should be 1, rest of the bits should be 0 as well...as you can see that during \"moment1\", [1,i] condition is satisfied, but the 4th bit is 1 too. similarly in \"moment2\" and 3 as well, the 4th bit is violating the criteria. and it is satisfied only for the last step, that is 4th, where all bits from [1,4] are 1."
                    },
                    {
                        "username": "worldnihao",
                        "content": "The prefix align problem is a little different from bulbs"
                    },
                    {
                        "username": "Anurag-S1ngh",
                        "content": "i applied simple xor operation and it work for 57/63 cases\\n        int cnt = 0;\\n        int xor = 0;\\n\\n        for(int i=0; i<flips.length; i++){\\n            xor ^= flips[i] ^ i+1;\\n            if(xor == 0) cnt++;\\n        }\\n        return cnt;\\n\\nbut why is not working for this test case\\n[1,2,3,10,13,6,7,12,5,4,11,8,9,14,15,16,17,18,19,20,21]\\no/p = 14\\nexpected = 12"
                    },
                    {
                        "username": "anmoldau_50",
                        "content": "They are saying--> A binary string is prefix-aligned if, after the ith step, all the bits in the inclusive range [1, i] are ones and all the other bits are zeros.\nNote that the line says all other bits other than the range should be zero but in the very first example at step 4\n\n--> After applying step 4: The string becomes \"11110\", which is prefix-aligned.\n i is 1 so according to question only the bit 1 should be 1 and other 2,3,4,5 should be zero\n then only the given criteria should match\n but they are considering it as answer dont know what the shit the write in description."
                    }
                ]
            },
            {
                "id": 1974944,
                "content": [
                    {
                        "username": "algomelon",
                        "content": "For the test case `light = [4,1,2,3]`, we would have:\\n(I am using `0` to indicate off and `1` for on and `B` for blue)\\nmoment 0: 0001\\nmoment 1: B001 (Here bulb-1 is on and there\\'s no other bulbs left of it, it should turn blue)\\nmoment 2: BB01 (Here bulb-2 is on and bulb-1 is on therefore bulb-2 should turn blue)\\nmoment 3: BBBB (Here bulb-2 and bulb-1 are on and therefore bulb-3 turns blue)\\n\\nSo the result should be 3?\\n"
                    },
                    {
                        "username": "shashankkr2590",
                        "content": "no because it is clearly mentioned that only those bits that are in the range of [1,i](where i is the step you are at) should be 1, rest of the bits should be 0 as well...as you can see that during \"moment1\", [1,i] condition is satisfied, but the 4th bit is 1 too. similarly in \"moment2\" and 3 as well, the 4th bit is violating the criteria. and it is satisfied only for the last step, that is 4th, where all bits from [1,4] are 1."
                    },
                    {
                        "username": "worldnihao",
                        "content": "The prefix align problem is a little different from bulbs"
                    },
                    {
                        "username": "Anurag-S1ngh",
                        "content": "i applied simple xor operation and it work for 57/63 cases\\n        int cnt = 0;\\n        int xor = 0;\\n\\n        for(int i=0; i<flips.length; i++){\\n            xor ^= flips[i] ^ i+1;\\n            if(xor == 0) cnt++;\\n        }\\n        return cnt;\\n\\nbut why is not working for this test case\\n[1,2,3,10,13,6,7,12,5,4,11,8,9,14,15,16,17,18,19,20,21]\\no/p = 14\\nexpected = 12"
                    },
                    {
                        "username": "anmoldau_50",
                        "content": "They are saying--> A binary string is prefix-aligned if, after the ith step, all the bits in the inclusive range [1, i] are ones and all the other bits are zeros.\nNote that the line says all other bits other than the range should be zero but in the very first example at step 4\n\n--> After applying step 4: The string becomes \"11110\", which is prefix-aligned.\n i is 1 so according to question only the bit 1 should be 1 and other 2,3,4,5 should be zero\n then only the given criteria should match\n but they are considering it as answer dont know what the shit the write in description."
                    }
                ]
            }
        ]
    },
    {
        "title": "Time Needed to Inform All Employees",
        "question_content": "<p>A company has <code>n</code> employees with a unique ID for each employee from <code>0</code> to <code>n - 1</code>. The head of the company is the one with <code>headID</code>.</p>\n\n<p>Each employee has one direct manager given in the <code>manager</code> array where <code>manager[i]</code> is the direct manager of the <code>i-th</code> employee, <code>manager[headID] = -1</code>. Also, it is guaranteed that the subordination relationships have a tree structure.</p>\n\n<p>The head of the company wants to inform all the company employees of an urgent piece of news. He will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news.</p>\n\n<p>The <code>i-th</code> employee needs <code>informTime[i]</code> minutes to inform all of his direct subordinates (i.e., After informTime[i] minutes, all his direct subordinates can start spreading the news).</p>\n\n<p>Return <em>the number of minutes</em> needed to inform all the employees about the urgent news.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, headID = 0, manager = [-1], informTime = [0]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> The head of the company is the only employee in the company.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/27/graph.png\" style=\"width: 404px; height: 174px;\" />\n<pre>\n<strong>Input:</strong> n = 6, headID = 2, manager = [2,2,-1,2,2,2], informTime = [0,0,1,0,0,0]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> The head of the company with id = 2 is the direct manager of all the employees in the company and needs 1 minute to inform them all.\nThe tree structure of the employees in the company is shown.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= headID &lt; n</code></li>\n\t<li><code>manager.length == n</code></li>\n\t<li><code>0 &lt;= manager[i] &lt; n</code></li>\n\t<li><code>manager[headID] == -1</code></li>\n\t<li><code>informTime.length == n</code></li>\n\t<li><code>0 &lt;= informTime[i] &lt;= 1000</code></li>\n\t<li><code>informTime[i] == 0</code> if employee <code>i</code> has no subordinates.</li>\n\t<li>It is <strong>guaranteed</strong> that all the employees can be informed.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 532560,
                "title": "java-c-python-dfs",
                "content": "# Solution 1: Top down DFS\\n`dfs` find out the time needed for each employees.\\nThe time for a manager = `max(manager\\'s employees) + informTime[manager]`\\n\\nTime `O(N)`, Space `O(N)`\\n<br>\\n\\n**Java**\\n@Caloplaca\\n```java\\n    public int numOfMinutes(final int n, final int headID, final int[] manager, final int[] informTime) {\\n        final Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int total = 0;\\n        for (int i = 0; i < manager.length; i++) {\\n            int j = manager[i];\\n            if (!graph.containsKey(j))\\n                graph.put(j, new ArrayList<>());\\n            graph.get(j).add(i);\\n        }\\n        return dfs(graph, informTime, headID);\\n    }\\n\\n    private int dfs(final Map<Integer, List<Integer>> graph, final int[] informTime, final int cur) {\\n        int max = 0;\\n        if (!graph.containsKey(cur))\\n            return max;\\n        for (int i = 0; i < graph.get(cur).size(); i++)\\n            max = Math.max(max, dfs(graph, informTime, graph.get(cur).get(i)));\\n        return max + informTime[cur];\\n    }\\n```\\n**Python:**\\n```py\\n    def numOfMinutes(self, n, headID, manager, informTime):\\n        children = [[] for i in xrange(n)]\\n        for i, m in enumerate(manager):\\n            if m >= 0: children[m].append(i)\\n\\n        def dfs(i):\\n            return max([dfs(j) for j in children[i]] or [0]) + informTime[i]\\n        return dfs(headID)\\n```\\n<br>\\n\\n# Solution 2: Bottom Up DFS\\n**C++**\\n```cpp\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        int res = 0;\\n        for (int i = 0; i < n; ++i)\\n            res = max(res, dfs(i, manager, informTime));\\n        return res;\\n    }\\n\\n    int dfs(int i, vector<int>& manager, vector<int>& informTime) {\\n        if (manager[i] != -1) {\\n            informTime[i] += dfs(manager[i], manager, informTime);\\n            manager[i] = -1;\\n        }\\n        return informTime[i];\\n    }\\n```\\n**Java**\\n```java\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        int res = 0;\\n        for (int i = 0; i < n; ++i)\\n            res = Math.max(res, dfs(i, manager, informTime));\\n        return res;\\n    }\\n    public int dfs(int i, int[] manager, int[] informTime) {\\n        if (manager[i] != -1) {\\n            informTime[i] += dfs(manager[i], manager, informTime);\\n            manager[i] = -1;\\n        }\\n        return informTime[i];\\n    }\\n```\\n**Python**\\ninspired by @easternbadge\\n```py\\n    def numOfMinutes(self, n, headID, manager, informTime):\\n        def dfs(i):\\n            if manager[i] != -1:\\n                informTime[i] += dfs(manager[i])\\n                manager[i] = -1\\n            return informTime[i]\\n        return max(map(dfs, range(n)))\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int numOfMinutes(final int n, final int headID, final int[] manager, final int[] informTime) {\\n        final Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int total = 0;\\n        for (int i = 0; i < manager.length; i++) {\\n            int j = manager[i];\\n            if (!graph.containsKey(j))\\n                graph.put(j, new ArrayList<>());\\n            graph.get(j).add(i);\\n        }\\n        return dfs(graph, informTime, headID);\\n    }\\n\\n    private int dfs(final Map<Integer, List<Integer>> graph, final int[] informTime, final int cur) {\\n        int max = 0;\\n        if (!graph.containsKey(cur))\\n            return max;\\n        for (int i = 0; i < graph.get(cur).size(); i++)\\n            max = Math.max(max, dfs(graph, informTime, graph.get(cur).get(i)));\\n        return max + informTime[cur];\\n    }\\n```\n```py\\n    def numOfMinutes(self, n, headID, manager, informTime):\\n        children = [[] for i in xrange(n)]\\n        for i, m in enumerate(manager):\\n            if m >= 0: children[m].append(i)\\n\\n        def dfs(i):\\n            return max([dfs(j) for j in children[i]] or [0]) + informTime[i]\\n        return dfs(headID)\\n```\n```cpp\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        int res = 0;\\n        for (int i = 0; i < n; ++i)\\n            res = max(res, dfs(i, manager, informTime));\\n        return res;\\n    }\\n\\n    int dfs(int i, vector<int>& manager, vector<int>& informTime) {\\n        if (manager[i] != -1) {\\n            informTime[i] += dfs(manager[i], manager, informTime);\\n            manager[i] = -1;\\n        }\\n        return informTime[i];\\n    }\\n```\n```java\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        int res = 0;\\n        for (int i = 0; i < n; ++i)\\n            res = Math.max(res, dfs(i, manager, informTime));\\n        return res;\\n    }\\n    public int dfs(int i, int[] manager, int[] informTime) {\\n        if (manager[i] != -1) {\\n            informTime[i] += dfs(manager[i], manager, informTime);\\n            manager[i] = -1;\\n        }\\n        return informTime[i];\\n    }\\n```\n```py\\n    def numOfMinutes(self, n, headID, manager, informTime):\\n        def dfs(i):\\n            if manager[i] != -1:\\n                informTime[i] += dfs(manager[i])\\n                manager[i] = -1\\n            return informTime[i]\\n        return max(map(dfs, range(n)))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 533109,
                "title": "java-python-bfs-dfs-solutions-clean-code",
                "content": "**\\u2714\\uFE0F Solution 1: BFS**\\n**Java**\\n```java\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int i = 0; i < n; i++) if (manager[i] != -1) graph[manager[i]].add(i);\\n        Queue<int[]> q = new LinkedList<>(); // Since it\\'s a tree, we don\\'t need `visited` array\\n        q.offer(new int[]{headID, 0});\\n        int ans = 0;\\n        while (!q.isEmpty()) {\\n            int[] top = q.poll();\\n            int u = top[0], w = top[1];\\n            ans = Math.max(w, ans);\\n            for (int v : graph[u]) q.offer(new int[]{v, w + informTime[u]});\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time & Space: `O(N)`\\n\\n---\\n\\n**\\u2714\\uFE0F Solution 2: DFS**\\n**Python**\\n```python\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for i in range(len(manager)):\\n            graph[manager[i]].append(i)\\n        \\n        def dfs(u):\\n            ans = 0\\n            for v in graph[u]:\\n                ans = max(dfs(v) + informTime[u], ans)\\n            return ans\\n        \\n        return dfs(headID)\\n```\\n\\n**Java**\\n```java\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int i = 0; i < n; i++) if (manager[i] != -1) graph[manager[i]].add(i);\\n        return dfs(graph, headID, informTime);\\n    }\\n    private int dfs(List<Integer>[] graph, int u, int[] informTime) {\\n        int ans = 0;\\n        for (int v : graph[u])\\n            ans = Math.max(ans, dfs(graph, v, informTime));\\n        return ans + informTime[u];\\n    }\\n}\\n```\\nComplexity:\\n- Time & Space: `O(N)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int i = 0; i < n; i++) if (manager[i] != -1) graph[manager[i]].add(i);\\n        Queue<int[]> q = new LinkedList<>(); // Since it\\'s a tree, we don\\'t need `visited` array\\n        q.offer(new int[]{headID, 0});\\n        int ans = 0;\\n        while (!q.isEmpty()) {\\n            int[] top = q.poll();\\n            int u = top[0], w = top[1];\\n            ans = Math.max(w, ans);\\n            for (int v : graph[u]) q.offer(new int[]{v, w + informTime[u]});\\n        }\\n        return ans;\\n    }\\n}\\n```\n```python\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        graph = defaultdict(list)\\n        for i in range(len(manager)):\\n            graph[manager[i]].append(i)\\n        \\n        def dfs(u):\\n            ans = 0\\n            for v in graph[u]:\\n                ans = max(dfs(v) + informTime[u], ans)\\n            return ans\\n        \\n        return dfs(headID)\\n```\n```java\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int i = 0; i < n; i++) if (manager[i] != -1) graph[manager[i]].add(i);\\n        return dfs(graph, headID, informTime);\\n    }\\n    private int dfs(List<Integer>[] graph, int u, int[] informTime) {\\n        int ans = 0;\\n        for (int v : graph[u])\\n            ans = Math.max(ans, dfs(graph, v, informTime));\\n        return ans + informTime[u];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532530,
                "title": "python3-easy-python-solution-dijkstra-bfs-dfs",
                "content": "##### Dijkstra\\nJust look at this as a network problem. We are trying to find the bottleneck of the network.\\nTreat the managers and employees as the nodes and the inform time as the weight of the edges.\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        graph = collections.defaultdict(list)\\n        \\n        for i, managerId in enumerate(manager):\\n            graph[managerId].append((informTime[i], i))\\n        \\n        dist = {}\\n        heap = [(informTime[headID], headID)] \\n        \\n        while heap:\\n            time, u = heapq.heappop(heap)\\n            if u in dist:\\n                continue\\n            dist[u] = time    \\n            for w, v in graph[u]:\\n                if v in dist:\\n                    continue\\n                heapq.heappush(heap, (time+w, v))    \\n        return max(dist.values()) \\n```\\n##### DFS\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        subordinates = collections.defaultdict(list)\\n        self.res = 0\\n        for i, v in enumerate(manager):\\n            subordinates[v].append(i)\\n        \\n        def dfs(manager, time):\\n            self.res = max(self.res, time)\\n            for subordinate in subordinates[manager]:\\n                dfs(subordinate, time + informTime[manager])\\n        dfs(headID, 0)        \\n        return self.res\\n```\\n##### BFS\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        q = collections.deque([(headID, 0)])\\n        subordinates = collections.defaultdict(list)\\n        res = 0\\n        for i, v in enumerate(manager):\\n            subordinates[v].append(i)\\n            \\n        while q:\\n            u, time = q.popleft()\\n            res = max(res, time)\\n            for v in subordinates[u]:\\n                q.append((v, time + informTime[u]))\\n        return res",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        graph = collections.defaultdict(list)\\n        \\n        for i, managerId in enumerate(manager):\\n            graph[managerId].append((informTime[i], i))\\n        \\n        dist = {}\\n        heap = [(informTime[headID], headID)] \\n        \\n        while heap:\\n            time, u = heapq.heappop(heap)\\n            if u in dist:\\n                continue\\n            dist[u] = time    \\n            for w, v in graph[u]:\\n                if v in dist:\\n                    continue\\n                heapq.heappush(heap, (time+w, v))    \\n        return max(dist.values()) \\n```\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        subordinates = collections.defaultdict(list)\\n        self.res = 0\\n        for i, v in enumerate(manager):\\n            subordinates[v].append(i)\\n        \\n        def dfs(manager, time):\\n            self.res = max(self.res, time)\\n            for subordinate in subordinates[manager]:\\n                dfs(subordinate, time + informTime[manager])\\n        dfs(headID, 0)        \\n        return self.res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532573,
                "title": "i-don-t-know-why-this-case-failed",
                "content": "class Solution:\\n\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        if n == 0:\\n            return 0\\n        \\n        if n == 1:\\n            return informTime[0]\\n        \\n        tim = informTime[headID]\\n        \\n        nxt = [headID]\\n\\n        while nxt:\\n            m, temp = 0, []\\n            for e in range(len(manager)):\\n                if manager[e] in nxt:\\n                    m = max(m, informTime[e])\\n                    temp.append(e)\\n            tim += m\\n            nxt = temp\\n\\n        return tim\\n\\t\\t\\n\\t\\t\\ncase:\\n\\n11\\n4\\n[5,9,6,10,-1,8,9,1,9,3,4]\\n[0,213,0,253,686,170,975,0,261,309,337]\\n\\nmy output is 2730 but the answer is 2560",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        if n == 0:\\n            return 0\\n        \\n        if n == 1:\\n            return informTime[0]\\n        \\n        tim = informTime[headID]\\n        \\n        nxt = [headID]\\n\\n        while nxt:\\n            m, temp = 0, []\\n            for e in range(len(manager)):\\n                if manager[e] in nxt:\\n                    m = max(m, informTime[e])\\n                    temp.append(e)\\n            tim += m\\n            nxt = temp\\n\\n        return tim\\n\\t\\t\\n\\t\\t\\ncase:\\n\\n11\\n4\\n[5,9,6,10,-1,8,9,1,9,3,4]\\n[0,213,0,253,686,170,975,0,261,309,337]\\n\\nmy output is 2730 but the answer is 2560",
                "codeTag": "Java"
            },
            {
                "id": 794935,
                "title": "c-very-simple-bfs-solution-using-standard-approach",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        unordered_map<int,vector<int> >m;\\n        for(int i=0;i<manager.size();i++) {\\n            m[manager[i]].push_back(i);\\n        }\\n        queue<pair<int,int>>q;\\n        q.push(make_pair(headID,0));\\n        int maxi=0;\\n        while(!q.empty()) {\\n            int n=q.size();\\n            for(int i=0;i<n;i++) {\\n                int head=q.front().first;\\n                int timeTaken=q.front().second;\\n                q.pop();\\n                int dur=informTime[head]+timeTaken;\\n                maxi=max(maxi,dur);\\n                for(auto it:m[head]) {\\n                    q.push(make_pair(it,dur));\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        unordered_map<int,vector<int> >m;\\n        for(int i=0;i<manager.size();i++) {\\n            m[manager[i]].push_back(i);\\n        }\\n        queue<pair<int,int>>q;\\n        q.push(make_pair(headID,0));\\n        int maxi=0;\\n        while(!q.empty()) {\\n            int n=q.size();\\n            for(int i=0;i<n;i++) {\\n                int head=q.front().first;\\n                int timeTaken=q.front().second;\\n                q.pop();\\n                int dur=informTime[head]+timeTaken;\\n                maxi=max(maxi,dur);\\n                for(auto it:m[head]) {\\n                    q.push(make_pair(it,dur));\\n                }\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 566818,
                "title": "c-o-n-path-compression",
                "content": "No need to generate adjacency list and run DFS up to bottom.\\nWe can use path compression idea from Union Find algorithm.\\nSuppose we have next input:\\n```\\nn=8\\nheadID=7\\nmanager=[3,5,4,5,6,7,7,-1]\\ninformTime[0,0,0,3,3,2,2,1]\\n```\\nIt can be represented with following tree:\\n![image](https://assets.leetcode.com/users/tifon/image_1586205553.png)\\nWhere inside node you see time to inform and node id in square parentheses.\\nGreen colour - next node to process.\\nYellow colour - node updated on previous step.\\nLet\\'s try to find path from each node to Head, but with some path compression inside, thus we will not follow each path more than 1 time:\\n![image](https://assets.leetcode.com/users/tifon/image_1586205725.png)\\nNodes 0 and 3 were moved under Head, and their time was updated correspondingly.\\n![image](https://assets.leetcode.com/users/tifon/image_1586205768.png)\\nNode 1 was moved under Head.\\n![image](https://assets.leetcode.com/users/tifon/image_1586205794.png)\\nNodes 2 and 4 were moved under Head.\\n\\n```\\nclass Solution {\\nprivate:\\n    using Manager = int;\\n    using Time = int;\\n    pair<Time, Manager> moveUnderHead(vector<int>& manager, vector<int>& informTime, int v) {\\n        if (manager[manager[v]] != -1) { \\n            // we are not under Head manager\\n            auto timeManager = moveUnderHead(manager, informTime, manager[v]);  // compress path\\n            informTime[v] += timeManager.first;\\n            manager[v] = timeManager.second;\\n        }\\n        return {informTime[v], manager[v]};\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        int result = 0;\\n        for (int i=0; i<n; ++i) {\\n            if (i==headID) continue;\\n            auto a = moveUnderHead(manager, informTime, i);\\n            result = max(result, a.first);\\n        }\\n        \\n        return result + informTime[headID];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nn=8\\nheadID=7\\nmanager=[3,5,4,5,6,7,7,-1]\\ninformTime[0,0,0,3,3,2,2,1]\\n```\n```\\nclass Solution {\\nprivate:\\n    using Manager = int;\\n    using Time = int;\\n    pair<Time, Manager> moveUnderHead(vector<int>& manager, vector<int>& informTime, int v) {\\n        if (manager[manager[v]] != -1) { \\n            // we are not under Head manager\\n            auto timeManager = moveUnderHead(manager, informTime, manager[v]);  // compress path\\n            informTime[v] += timeManager.first;\\n            manager[v] = timeManager.second;\\n        }\\n        return {informTime[v], manager[v]};\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        int result = 0;\\n        for (int i=0; i<n; ++i) {\\n            if (i==headID) continue;\\n            auto a = moveUnderHead(manager, informTime, i);\\n            result = max(result, a.first);\\n        }\\n        \\n        return result + informTime[headID];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532987,
                "title": "c-dfs",
                "content": "We go from root (head) to all leaves (employees). Since the procedure happens in parallel in tree branches, we need to return the longest time from head to a leaf.\\n```cpp\\nint dfs(int i, vector<vector<int>> &m, vector<int>& informTime, int mx = 0) {\\n    for (auto d : m[i])\\n        mx = max(mx, dfs(d, m, informTime));\\n    return informTime[i] + mx;\\n}\\nint numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n    vector<vector<int>> m(n);\\n    for(auto i = 0; i < manager.size(); ++i)\\n        if (manager[i] != -1)\\n            m[manager[i]].push_back(i);\\n    return dfs(headID, m, informTime);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dfs(int i, vector<vector<int>> &m, vector<int>& informTime, int mx = 0) {\\n    for (auto d : m[i])\\n        mx = max(mx, dfs(d, m, informTime));\\n    return informTime[i] + mx;\\n}\\nint numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n    vector<vector<int>> m(n);\\n    for(auto i = 0; i < manager.size(); ++i)\\n        if (manager[i] != -1)\\n            m[manager[i]].push_back(i);\\n    return dfs(headID, m, informTime);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532615,
                "title": "python-straightforward-bfs-o-n-solution",
                "content": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution(object):\\n    def numOfMinutes(self, n, headID, manager, informTime):\\n        \"\"\"\\n        :type n: int\\n        :type headID: int\\n        :type manager: List[int]\\n        :type informTime: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if n <= 1:\\n            return 0\\n        rst = 0\\n        childs = defaultdict(list)\\n        for idx, parent in enumerate(manager):\\n            childs[parent].append(idx)\\n\\n        q = deque([(headID, informTime[headID])])\\n        while q:\\n            cur_id, cur_time = q.popleft()\\n            # calculate max\\n            rst = max(rst, cur_time)\\n            for child in childs[cur_id]:\\n                q.append((child, cur_time + informTime[child]))\\n        return rst\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution(object):\\n    def numOfMinutes(self, n, headID, manager, informTime):\\n        \"\"\"\\n        :type n: int\\n        :type headID: int\\n        :type manager: List[int]\\n        :type informTime: List[int]\\n        :rtype: int\\n        \"\"\"\\n        if n <= 1:\\n            return 0\\n        rst = 0\\n        childs = defaultdict(list)\\n        for idx, parent in enumerate(manager):\\n            childs[parent].append(idx)\\n\\n        q = deque([(headID, informTime[headID])])\\n        while q:\\n            cur_id, cur_time = q.popleft()\\n            # calculate max\\n            rst = max(rst, cur_time)\\n            for child in childs[cur_id]:\\n                q.append((child, cur_time + informTime[child]))\\n        return rst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532480,
                "title": "java-python-3-bfs-and-dfs-w-brief-explanation-and-analysis",
                "content": "\\n**BFS**\\n1. Clone `informTime` and build subordinates relations;\\n2. Starting from `headID`, the root, do BFS to find the max time needed to reach the leaves.\\n\\n```java\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        int[] time = informTime.clone();\\n        List<Integer>[] subordinates = new List[n];\\n        for (int i = 0; i < n; ++i)\\n            subordinates[i] = new ArrayList<>();\\n        for (int i = 0; i < n; ++i)\\n            if (manager[i] >= 0)\\n                subordinates[manager[i]].add(i);\\n        Queue<Integer> q = new LinkedList<>(Arrays.asList(headID));\\n        int max = 0;\\n        while (!q.isEmpty()) {\\n            int e = q.poll();\\n            if (manager[e] >= 0)\\n                time[e] += time[manager[e]];\\n            max = Math.max(max, time[e]);\\n            q.addAll(subordinates[e]);\\n        }\\n        return max;\\n    }\\n```\\n```python\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        subordinates, time = collections.defaultdict(list), informTime[:]\\n        for i, m in enumerate(manager):\\n            if m >= 0:\\n                subordinates.setdefault(m,[]).append(i)\\n        dq, ans = collections.deque([headID]), 0\\n        while dq:\\n            e = dq.popleft()\\n            if manager[e] >= 0:\\n                time[e] += time[manager[e]]        \\n            ans = max(ans, time[e])\\n            if subordinates[e]:\\n                dq.extend(subordinates[e])\\n        return ans\\n```\\n**DFS**\\n1. Build subordinates relations;\\n2. Starting from `headID`, the root, do DFS to find the max time needed to reach the leaves.\\n\\n```java\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        final List<Integer>[] subordinates = new List[n];\\n        for (int i = 0; i < n; ++i)\\n            subordinates[i] = new ArrayList<>();\\n        for (int i = 0; i < n; ++i)\\n            if (manager[i] >= 0)\\n                subordinates[manager[i]].add(i);\\n        return dfs(headID, subordinates, informTime);\\n    }\\n    private int dfs(int id, List<Integer>[] subordinates, int[] informTime) {\\n        int max = 0;\\n        for (int sub : subordinates[id]) {\\n            max = Math.max(informTime[id] + dfs(sub, subordinates, informTime), max);\\n        }\\n        return max;\\n    }\\n```\\n```python\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        def dfs(id: int) -> int:\\n            return max(informTime[id] + dfs(sub) for sub in subordinates[id]) if id in subordinates else 0\\n        \\n        subordinates = collections.defaultdict(list)\\n        for i, m in enumerate(manager):\\n            if i != headID:\\n                subordinates.setdefault(m,[]).append(i)\\n        return dfs(headID)\\n```\\n**Analysis:**\\n\\nTime & space: O(n), where n = manager.length.",
                "solutionTags": [],
                "code": "```java\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        int[] time = informTime.clone();\\n        List<Integer>[] subordinates = new List[n];\\n        for (int i = 0; i < n; ++i)\\n            subordinates[i] = new ArrayList<>();\\n        for (int i = 0; i < n; ++i)\\n            if (manager[i] >= 0)\\n                subordinates[manager[i]].add(i);\\n        Queue<Integer> q = new LinkedList<>(Arrays.asList(headID));\\n        int max = 0;\\n        while (!q.isEmpty()) {\\n            int e = q.poll();\\n            if (manager[e] >= 0)\\n                time[e] += time[manager[e]];\\n            max = Math.max(max, time[e]);\\n            q.addAll(subordinates[e]);\\n        }\\n        return max;\\n    }\\n```\n```python\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        subordinates, time = collections.defaultdict(list), informTime[:]\\n        for i, m in enumerate(manager):\\n            if m >= 0:\\n                subordinates.setdefault(m,[]).append(i)\\n        dq, ans = collections.deque([headID]), 0\\n        while dq:\\n            e = dq.popleft()\\n            if manager[e] >= 0:\\n                time[e] += time[manager[e]]        \\n            ans = max(ans, time[e])\\n            if subordinates[e]:\\n                dq.extend(subordinates[e])\\n        return ans\\n```\n```java\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        final List<Integer>[] subordinates = new List[n];\\n        for (int i = 0; i < n; ++i)\\n            subordinates[i] = new ArrayList<>();\\n        for (int i = 0; i < n; ++i)\\n            if (manager[i] >= 0)\\n                subordinates[manager[i]].add(i);\\n        return dfs(headID, subordinates, informTime);\\n    }\\n    private int dfs(int id, List<Integer>[] subordinates, int[] informTime) {\\n        int max = 0;\\n        for (int sub : subordinates[id]) {\\n            max = Math.max(informTime[id] + dfs(sub, subordinates, informTime), max);\\n        }\\n        return max;\\n    }\\n```\n```python\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        def dfs(id: int) -> int:\\n            return max(informTime[id] + dfs(sub) for sub in subordinates[id]) if id in subordinates else 0\\n        \\n        subordinates = collections.defaultdict(list)\\n        for i, m in enumerate(manager):\\n            if i != headID:\\n                subordinates.setdefault(m,[]).append(i)\\n        return dfs(headID)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1106599,
                "title": "javascript-super-short-w-explanation-100-98",
                "content": "![image](https://assets.leetcode.com/users/images/2fd51b42-6502-4e1a-806e-ea821eba786b_1626901886.101005.png)\\n\\nBasic approach is as follows - We are given a list of all employees (manager contains all employees / managers) and a list of the time to reach those employees from their direct managers.  We loop through every employee and calculate the time it takes to reach the head of the company from that employee. (Pretty straight forward, just the time from employee -> manager -> ... n manager -> owner.  No branches, straight path.)  Since managers can have many employees, but employees only have one manager - this approach is nice since we can change the \\'manager\\' value to -1 after traversing to the owner node from there and storing the updated total calculated value in the informTime array.  This approach keeps us from calculating time from said manager to owner multiple times.  If another employee under the same manager comes up again, when we run our helper function on the manager, we\\'ll see that his value is -1 (same as owner) and simply return the previously calculated value.  After we calculate the time for All employees, we can then return the maximum value within the informTime array as it will be the longest it takes for news to reach the entire company.  Big O(numEmployees * TreeDepth)\\n\\t\\n```\\nvar numOfMinutes = function(n, headID, manager, informTime) {\\n    manager.forEach((_, index) => timeFromEmployeeToHead(index))\\n        \\n    return Math.max(...informTime);\\n    \\n    function timeFromEmployeeToHead(id) {\\n        if (manager[id] !== -1) {\\n            informTime[id] += timeFromEmployeeToHead(manager[id]);\\n            manager[id] = -1\\n        }\\n        return informTime[id];\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numOfMinutes = function(n, headID, manager, informTime) {\\n    manager.forEach((_, index) => timeFromEmployeeToHead(index))\\n        \\n    return Math.max(...informTime);\\n    \\n    function timeFromEmployeeToHead(id) {\\n        if (manager[id] !== -1) {\\n            informTime[id] += timeFromEmployeeToHead(manager[id]);\\n            manager[id] = -1\\n        }\\n        return informTime[id];\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1206574,
                "title": "python3-path-compression-clean-code-beats-99",
                "content": "```python\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        def find(i):\\n            if manager[i] != -1:\\n                informTime[i] += find(manager[i])\\n                manager[i] = -1\\n            return informTime[i]\\n        return max(map(find, range(n)))\\n```\\n\\nThe idea is, for each node, find out the total time it takes until the node has reached out to its subordinates (starting from the root node). For example, if a path looks like: `[root, ..., i, (i\\'s subordinate), ...]` and we called the function `find(i)` then we would like to know `time(root -> ... -> i\\'s subordinate)`.\\n\\nBut traversing the tree every time would be inefficient; In order to make this more efficient, we traverse the path from the `i`th node only once, and compress the path along the way, just like in union-find.\\n\\nOnce we understand what the `find` function does, all that\\'s remaining is to call it for every node and take the maximum.\\n\\nTime complexity: `O(n * a(n)) =(close to)= O(n)`, where `a()` is the Ackermann function.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```python\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        def find(i):\\n            if manager[i] != -1:\\n                informTime[i] += find(manager[i])\\n                manager[i] = -1\\n            return informTime[i]\\n        return max(map(find, range(n)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532496,
                "title": "java-bfs-and-store-time-for-each-node",
                "content": "```\\nclass Pair {\\n    int node;\\n    int time;\\n    Pair(int node, int time) {\\n        this.node = node;\\n        this.time = time;\\n    }\\n}\\nclass Solution {\\n    public int numOfMinutes(int n, int head, int[] manager, int[] informTime) {\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        int ans = 0;\\n        for(int i = 0; i < manager.length; i++) {\\n            if(manager[i] == -1) continue;\\n            if(!map.containsKey(manager[i])) map.put(manager[i], new ArrayList<>());\\n            map.get(manager[i]).add(i);\\n        }\\n        Queue<Pair> q = new LinkedList<>();\\n        q.add(new Pair(head, 0));\\n        while(q.size() > 0) {\\n            Pair p = q.remove();\\n            ans = Math.max(ans, p.time);\\n            if(informTime[p.node] != 0) {\\n                List<Integer> children = map.get(p.node);\\n                for(int i = 0; i < children.size(); i++) q.add(new Pair(children.get(i), p.time + informTime[p.node]));\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numOfMinutes(int n, int head, int[] manager, int[] informTime) {\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        int ans = 0;\\n        for(int i = 0; i < manager.length; i++) {\\n            if(manager[i] == -1) continue;\\n            if(!map.containsKey(manager[i])) map.put(manager[i], new ArrayList<>());\\n            map.get(manager[i]).add(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 755436,
                "title": "c-bfs-solution-explained-80-time-50-space",
                "content": "So, this one looks like a nice use case for a BFS approach - we proceed down the hierarchy, layer by layer.\\n\\nFirst of all we initialise a bunch of support variables and then reshape the graph in order to be a bit easier (and more performing to navigate, creating `paths`: you might consider using an `unordered_map` or similar, but since we know we are going to need to need something in the `[0, n - 1]` range, I would rather go for a `vector`, since access time it is still going to be constant (as long as you do access it knowing the index in advance) and with much less overhead (not all constant times are created equal).\\n\\nBasically the index `id` in `paths` will give me a list of all the nodes I can access from there.\\n\\nNow, BFS time!\\n\\nWe will use the `queue` `layer` to store all the information about each specific layer and progress from there; as per problem description, we know that the first layer is always going to be one single node, the head manager passed as `headID`; our `layer` will then store pairs of `int`s: the `cumulatedTime`, as we will call it soon after, and `currNode`, matching the id of - you guessed it - the current node.\\n\\nThen we move on with a loop that will progress as long as we have something in our queue: we store its current length into `len` (it is necessary since we will expand it or shorten it as we go) and loop through it, extracting its first element, getting info from it?: if it is not a leaf (ie: there are more nodes behind it), we proceed looping through its all children nodes and add to `layer` pairs of the increased `cumulatedTime` (the current value, plus the value of the child at hand) and the id of the child node. If `currNode` is a leaf, we update `res` to make sure it will always keep track of the largest time value found so far.\\n\\nOnce we are all set and done, we return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        // support variables declared here\\n\\t\\tint res = 0, len, currCumulatedTime, currNode;\\n        pair<int, int> currNodeInfo;\\n        // getting the graph in a more navigable format\\n        vector<vector<int>> paths(n);\\n        for (int id = 0; id < n; id++) if (id != headID) paths[manager[id]].push_back(id);\\n        // preparing layers for a BFS approach to be in the <cumulated time, id> format\\n        queue<pair<int, int>> layer;\\n        layer.push({0, headID});\\n        while (layer.size()) {\\n            len = layer.size();\\n            for (int i = 0; i < len; i++) {\\n                // extracting the stored node information\\n                currNodeInfo = layer.front();\\n                currCumulatedTime = currNodeInfo.first;\\n                currNode = currNodeInfo.second;\\n                // adding more nodes to be connected if this is not a terminal one\\n                if (paths[currNode].size()) {\\n                    for (auto node: paths[currNode]) layer.push({currCumulatedTime + informTime[currNode], node});\\n                }\\n                // else updating res\\n                else res = max(currCumulatedTime, res);\\n                // removing the parsed node from the queue\\n                layer.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        // support variables declared here\\n\\t\\tint res = 0, len, currCumulatedTime, currNode;\\n        pair<int, int> currNodeInfo;\\n        // getting the graph in a more navigable format\\n        vector<vector<int>> paths(n);\\n        for (int id = 0; id < n; id++) if (id != headID) paths[manager[id]].push_back(id);\\n        // preparing layers for a BFS approach to be in the <cumulated time, id> format\\n        queue<pair<int, int>> layer;\\n        layer.push({0, headID});\\n        while (layer.size()) {\\n            len = layer.size();\\n            for (int i = 0; i < len; i++) {\\n                // extracting the stored node information\\n                currNodeInfo = layer.front();\\n                currCumulatedTime = currNodeInfo.first;\\n                currNode = currNodeInfo.second;\\n                // adding more nodes to be connected if this is not a terminal one\\n                if (paths[currNode].size()) {\\n                    for (auto node: paths[currNode]) layer.push({currCumulatedTime + informTime[currNode], node});\\n                }\\n                // else updating res\\n                else res = max(currCumulatedTime, res);\\n                // removing the parsed node from the queue\\n                layer.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532544,
                "title": "javascript-dfs-clean-code",
                "content": "```js\\nfunction numOfMinutes(n, headID, manager, informTime) {\\n  const employeesMap = new Map(Array.from(manager, (_, i) => [i, []]));\\n  for (const [i, head] of manager.entries()) {\\n    if (head !== -1) {\\n      employeesMap.get(head).push(i);\\n    }\\n  }\\n  return dfs(headID);\\n\\n  function dfs(head) {\\n    return Math.max(0, ...employeesMap.get(head).map(dfs)) + informTime[head];\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nfunction numOfMinutes(n, headID, manager, informTime) {\\n  const employeesMap = new Map(Array.from(manager, (_, i) => [i, []]));\\n  for (const [i, head] of manager.entries()) {\\n    if (head !== -1) {\\n      employeesMap.get(head).push(i);\\n    }\\n  }\\n  return dfs(headID);\\n\\n  function dfs(head) {\\n    return Math.max(0, ...employeesMap.get(head).map(dfs)) + informTime[head];\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591550,
                "title": "c-easy-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(int id,vector<int>&vis,vector<int>ad[],vector<int>&it){\\n        vis[id]=1;\\n        int ans=it[id];\\n        int mx=0;\\n        for(auto k : ad[id]){\\n            if(!vis[k]){\\n                mx= max(mx,dfs(k,vis,ad,it));\\n            }\\n        }\\n        return ans+mx;\\n    }\\n    int numOfMinutes(int n, int id, vector<int>& manager, vector<int>& it) {\\n        vector<int>ad[n];\\n        for(int i=0;i<n;i++){\\n            if(manager[i]!=-1){\\n                ad[manager[i]].push_back(i);\\n            }\\n        }\\n        vector<int>vis(n,0);\\n        vis[id]=1;\\n        return dfs(id,vis,ad,it);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/3eed183f-674a-42dc-80aa-c31f398ed4bf_1685768372.7229211.jpeg)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int id,vector<int>&vis,vector<int>ad[],vector<int>&it){\\n        vis[id]=1;\\n        int ans=it[id];\\n        int mx=0;\\n        for(auto k : ad[id]){\\n            if(!vis[k]){\\n                mx= max(mx,dfs(k,vis,ad,it));\\n            }\\n        }\\n        return ans+mx;\\n    }\\n    int numOfMinutes(int n, int id, vector<int>& manager, vector<int>& it) {\\n        vector<int>ad[n];\\n        for(int i=0;i<n;i++){\\n            if(manager[i]!=-1){\\n                ad[manager[i]].push_back(i);\\n            }\\n        }\\n        vector<int>vis(n,0);\\n        vis[id]=1;\\n        return dfs(id,vis,ad,it);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589738,
                "title": "java-dfs-memoization-w-explanation-complexity-analysis",
                "content": "This is the same as many other \"bottom up\" DFS solutions - we start at each employee, working backwards towards the head of the company. \\n\\nHowever, in this solution, we cache our answers for however much time it took for each employee to be informed. \\n\\nThis way, *we avoid repeating the work of calculating how much time it takes for each manager to inform their superiors*. \\n\\n**TIme Complexity**\\nO(n) - we traverse backwards on each employee at most once.\\n\\n**Space Complexity**\\nO(n) - we store the time it takes to inform each employee\\n\\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer, Integer> times = new HashMap<>();\\n        int max = 0;\\n        for(int i = 0; i < n; i++) {\\n            max = Math.max(max, dfs(i, manager, informTime, times));\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int dfs(int e_id, int[] manager, int[] informTime, Map<Integer, Integer> times) {\\n        if(manager[e_id] == -1) return 0;\\n        \\n        if(times.containsKey(e_id)) return times.get(e_id);\\n        \\n        times.put(e_id, informTime[manager[e_id]] + dfs(manager[e_id], manager, informTime, times));\\n\\t\\t\\n        return times.get(e_id);\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer, Integer> times = new HashMap<>();\\n        int max = 0;\\n        for(int i = 0; i < n; i++) {\\n            max = Math.max(max, dfs(i, manager, informTime, times));\\n        }\\n        \\n        return max;\\n    }\\n    \\n    private int dfs(int e_id, int[] manager, int[] informTime, Map<Integer, Integer> times) {\\n        if(manager[e_id] == -1) return 0;\\n        \\n        if(times.containsKey(e_id)) return times.get(e_id);\\n        \\n        times.put(e_id, informTime[manager[e_id]] + dfs(manager[e_id], manager, informTime, times));\\n\\t\\t\\n        return times.get(e_id);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591420,
                "title": "video-explanation-including-visualization-and-similar-problems",
                "content": "# Approach:\\nhttps://www.youtube.com/watch?v=5flgvcwKBjo\\n\\n# Similar Problems: \\n- [104. Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)\\n- [110. Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)\\n- [111. Minimum Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree/)\\n- [559. Maximum Depth of N-ary Tree](https://leetcode.com/problems/maximum-depth-of-n-ary-tree/)\\n- [2385. Amount of Time for Binary Tree to Be Infected](https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/)\\n- [124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)\\n- [112. Path Sum](https://leetcode.com/problems/path-sum/)\\n- [129. Sum Root to Leaf Numbers](https://leetcode.com/problems/sum-root-to-leaf-numbers/)\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\nWe first iterate over the employees to create the adjacency list; then, we perform the DFS, where we iterate over each node once to find when they get the information from **headID**.\\n\\n- Space complexity: $$O(N)$$\\nThe size of the adjacency list is $$N$$, and there will be only $$N\\u22121$$ edges in the tree.\\n\\n# Code:\\n``` Java []\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i=0; i<n; i++) {\\n            graph.putIfAbsent(manager[i], new ArrayList<>());\\n            graph.get(manager[i]).add(i);\\n        }\\n        return dfs(graph, headID, informTime);\\n    }\\n\\n    int dfs(Map<Integer, List<Integer>> graph, int curHead, int[] informTime) {\\n        int curMax = 0;\\n        if(!graph.containsKey(curHead)){\\n            return curMax;\\n        }\\n        for(int subordinate : graph.get(curHead)) {\\n            curMax = Math.max(curMax, dfs(graph, subordinate, informTime));\\n        }\\n        return curMax + informTime[curHead];\\n    }\\n}\\n```\\n\\n``` C++ []\\n// Solved using BFS\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n\\t\\tint res = 0, len, curTime, curNode;\\n        pair<int, int> curNodeInfo;\\n        vector<vector<int>> paths(n);\\n        for (int id = 0; id < n; id++) if (id != headID) paths[manager[id]].push_back(id);\\n        queue<pair<int, int>> q;\\n        q.push({0, headID});\\n        while (q.size()) {\\n            len = q.size();\\n            for (int i = 0; i < len; i++) {\\n                curNodeInfo = q.front();\\n                curTime = curNodeInfo.first;\\n                curNode = curNodeInfo.second;\\n                if (paths[curNode].size()) {\\n                    for (auto node: paths[curNode]) q.push({curTime + informTime[curNode], node});\\n                }\\n                else res = max(curTime, res);\\n                q.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n![cc404213-285c-48ca-bce1-256072316360_1675559254.9353127.png](https://assets.leetcode.com/users/images/699f4bcc-bec3-49ba-a313-3e57f54fb99c_1685766975.7889187.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "``` Java []\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        for(int i=0; i<n; i++) {\\n            graph.putIfAbsent(manager[i], new ArrayList<>());\\n            graph.get(manager[i]).add(i);\\n        }\\n        return dfs(graph, headID, informTime);\\n    }\\n\\n    int dfs(Map<Integer, List<Integer>> graph, int curHead, int[] informTime) {\\n        int curMax = 0;\\n        if(!graph.containsKey(curHead)){\\n            return curMax;\\n        }\\n        for(int subordinate : graph.get(curHead)) {\\n            curMax = Math.max(curMax, dfs(graph, subordinate, informTime));\\n        }\\n        return curMax + informTime[curHead];\\n    }\\n}\\n```\n``` C++ []\\n// Solved using BFS\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n\\t\\tint res = 0, len, curTime, curNode;\\n        pair<int, int> curNodeInfo;\\n        vector<vector<int>> paths(n);\\n        for (int id = 0; id < n; id++) if (id != headID) paths[manager[id]].push_back(id);\\n        queue<pair<int, int>> q;\\n        q.push({0, headID});\\n        while (q.size()) {\\n            len = q.size();\\n            for (int i = 0; i < len; i++) {\\n                curNodeInfo = q.front();\\n                curTime = curNodeInfo.first;\\n                curNode = curNodeInfo.second;\\n                if (paths[curNode].size()) {\\n                    for (auto node: paths[curNode]) q.push({curTime + informTime[curNode], node});\\n                }\\n                else res = max(curTime, res);\\n                q.pop();\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094141,
                "title": "javascript-simple-dfs-solution",
                "content": "```javascript\\nvar numOfMinutes = function(n, headID, manager, informTime) {\\n    \\n    const tree = [...Array(n)].map(() => [])\\n    \\n    for(let i = 0; i < n; i++) {\\n        if(manager[i] !== -1) tree[manager[i]].push(i);\\n    }\\n    \\n    function traverse(node) {\\n        let maxTime = 0;\\n        \\n        for(let subordinate of tree[node]) {\\n            maxTime = Math.max(maxTime, traverse(subordinate));\\n        }\\n        return maxTime + informTime[node];\\n    }\\n    return traverse(headID);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```javascript\\nvar numOfMinutes = function(n, headID, manager, informTime) {\\n    \\n    const tree = [...Array(n)].map(() => [])\\n    \\n    for(let i = 0; i < n; i++) {\\n        if(manager[i] !== -1) tree[manager[i]].push(i);\\n    }\\n    \\n    function traverse(node) {\\n        let maxTime = 0;\\n        \\n        for(let subordinate of tree[node]) {\\n            maxTime = Math.max(maxTime, traverse(subordinate));\\n        }\\n        return maxTime + informTime[node];\\n    }\\n    return traverse(headID);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840606,
                "title": "python3-very-simple-w-explanation-100",
                "content": "Basic approach is as follows - We are given a list of all employees (manager contains all employees / managers) and a list of the time to reach those employees from their direct managers. We loop through every employee and calculate the time it takes to reach the head of the company from that employee. (Pretty straight forward, just the time from employee -> manager -> ... n manager -> owner. No branches, straight path.) Since managers can have many employees, but employees only have one manager - this approach is nice since we can change the \\'manager\\' value to -1 after traversing to the owner node from there and storing the updated total calculated value in the informTime array. This approach keeps us from calculating time from said manager to owner multiple times. If another employee under the same manager comes up again, when we run our helper function on the manager, we\\'ll see that his value is -1 (same as owner) and simply return the previously calculated value. After we calculate the time for All employees, we can then return the maximum value within the informTime array as it will be the longest it takes for news to reach the entire company. Big O(numEmployees * TreeDepth)\\n\\nNote:  I\\'m new-ish to Python, so I\\'m going through and translating some of my more well-received JS solutions to Python.  For the Python pros out there - If there\\'s anyway the code / syntax could be cleaned up or improved, please let me know!  I\\'ve been coding in almost exclusively JS for years, so my other languages are a WIP.\\n\\n\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:        \\n        def calculateTime(n: int) -> int:\\n            if manager[n] != -1:\\n                informTime[n] += calculateTime(manager[n])\\n                manager[n] = -1\\n            return informTime[n]\\n        \\n        for idx in range(len(manager)):\\n            calculateTime(idx)\\n            \\n        return max(informTime)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:        \\n        def calculateTime(n: int) -> int:\\n            if manager[n] != -1:\\n                informTime[n] += calculateTime(manager[n])\\n                manager[n] = -1\\n            return informTime[n]\\n        \\n        for idx in range(len(manager)):\\n            calculateTime(idx)\\n            \\n        return max(informTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 708757,
                "title": "java-solution-dfs-bottom-up",
                "content": "I like this bottom up DFS solution because of its simplicity and shortness comparing to the top down approach. \\n\\nThe time to inform all employees depends on when the last person get informed, that\\'s why we are using `Math.max()` to pick the largest time. \\n\\nSome people feel this bottom up solution is similar to union-find (\"find\" especially), I would say they are not same thing but they do have similarities: both of them are tracing back to the root and compressing the path, and the updated `informTime` is like the cost from each node to the root.  \\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        int timeLastPersonInformed = 0;\\n        for (int i = 0; i < n; i++) {\\n            timeLastPersonInformed = Math.max(timeLastPersonInformed, traceBack(i, manager, informTime));\\n        }\\n        return timeLastPersonInformed;\\n    }\\n    \\n    public int traceBack(int i, int[] manager, int[] informTime) {\\n        if (manager[i] != -1) {\\n            informTime[i] += traceBack(manager[i], manager, informTime);\\n            manager[i] = -1;\\n        }\\n        return informTime[i];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        int timeLastPersonInformed = 0;\\n        for (int i = 0; i < n; i++) {\\n            timeLastPersonInformed = Math.max(timeLastPersonInformed, traceBack(i, manager, informTime));\\n        }\\n        return timeLastPersonInformed;\\n    }\\n    \\n    public int traceBack(int i, int[] manager, int[] informTime) {\\n        if (manager[i] != -1) {\\n            informTime[i] += traceBack(manager[i], manager, informTime);\\n            manager[i] = -1;\\n        }\\n        return informTime[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601988,
                "title": "java-clean-code-dfs-bfs",
                "content": "[Must read discussion thread](https://leetcode.com/problems/time-needed-to-inform-all-employees/discuss/532573/I-don\\'t-know-why-this-case-failed...)\\n\\n**DFS**\\n```java\\npublic int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n\\tMap<Integer, List<Integer>> map = new HashMap<>();\\n\\tconstructGraph(map, manager, headID);\\n\\n\\treturn dfs(map, headID, informTime);\\n}\\n\\nprivate int dfs(Map<Integer, List<Integer>> map, int manager, int[] informTime) {\\n\\n\\tint max = 0;\\n\\n\\tfor (int emp : map.getOrDefault(manager, new ArrayList<>()))\\n\\t\\tmax = Math.max(max, dfs(map, emp, informTime));\\n\\n\\treturn max + informTime[manager];\\n}\\n\\n```\\n\\n**BFS**\\n\\n```java\\npublic int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    constructGraph(map, manager, headID);\\n\\n    Queue<int[]> queue = new LinkedList<>();\\n    queue.offer(new int[] {headID, 0});\\n\\n    int totalTime = 0;\\n\\n    while (!queue.isEmpty()) {\\n\\n        for (int size = queue.size(); size > 0; size--) {\\n            int[] employeeTime = queue.poll();\\n            int emp = employeeTime[0];\\n            int time = employeeTime[1];\\n\\n            totalTime = Math.max(totalTime, time);\\n\\n            for (int employee : map.getOrDefault(emp, new ArrayList<>())) {\\n                queue.offer(new int[] { employee, time + informTime[emp] });\\n            }\\n        }\\n    }\\n    return totalTime;\\n}\\n````\\n\\n**Graph Construction**\\n```java\\nprivate void constructGraph(Map<Integer, List<Integer>> map, \\n\\t\\t\\t\\t\\t\\t\\tint[] manager, int headID) {\\n\\n\\tint n = manager.length;\\n\\n\\tfor (int i = 0; i < manager.length; i++) {\\n\\t\\tif (manager[i] == -1) continue;\\n\\n\\t\\tmap.putIfAbsent(manager[i], new ArrayList<>());\\n\\t\\tmap.get(manager[i]).add(i); // Keep manager index and employee index mapping\\n\\t}\\n}\\n``` \\n\\n**Common edge cases**\\n\\n```java\\nif (n == 0 || headID < 0) return -1;\\nif (manager == null || manager.length == 0) return -1;\\nif (informTime == null || informTime.length == 0) return -1; \\n```\\n\\n**Runtime analysis**\\n\\nBoth these methods take O(V + E) for a graph G (V, E) and in this problem that is O(n) where n is the number of employees.\\n\\n**Space analysis**\\n\\nDFS takes space due to its call stack, which can go as deep as the total employee count, i.e. n. Hence, space complexity is O(n).\\n\\nFor BFS, the queue can hold up to n - 1 elements, having all employees reporting to one manager. Hence, at worst case, space complexity can be O(n).\\n\\n**NOTE**\\nIf you liked my solution, please upvote. And keep leetcoding! :)\\n",
                "solutionTags": [],
                "code": "```java\\npublic int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n\\tMap<Integer, List<Integer>> map = new HashMap<>();\\n\\tconstructGraph(map, manager, headID);\\n\\n\\treturn dfs(map, headID, informTime);\\n}\\n\\nprivate int dfs(Map<Integer, List<Integer>> map, int manager, int[] informTime) {\\n\\n\\tint max = 0;\\n\\n\\tfor (int emp : map.getOrDefault(manager, new ArrayList<>()))\\n\\t\\tmax = Math.max(max, dfs(map, emp, informTime));\\n\\n\\treturn max + informTime[manager];\\n}\\n\\n```\n```java\\npublic int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n    Map<Integer, List<Integer>> map = new HashMap<>();\\n    constructGraph(map, manager, headID);\\n\\n    Queue<int[]> queue = new LinkedList<>();\\n    queue.offer(new int[] {headID, 0});\\n\\n    int totalTime = 0;\\n\\n    while (!queue.isEmpty()) {\\n\\n        for (int size = queue.size(); size > 0; size--) {\\n            int[] employeeTime = queue.poll();\\n            int emp = employeeTime[0];\\n            int time = employeeTime[1];\\n\\n            totalTime = Math.max(totalTime, time);\\n\\n            for (int employee : map.getOrDefault(emp, new ArrayList<>())) {\\n                queue.offer(new int[] { employee, time + informTime[emp] });\\n            }\\n        }\\n    }\\n    return totalTime;\\n}\\n```\n```java\\nprivate void constructGraph(Map<Integer, List<Integer>> map, \\n\\t\\t\\t\\t\\t\\t\\tint[] manager, int headID) {\\n\\n\\tint n = manager.length;\\n\\n\\tfor (int i = 0; i < manager.length; i++) {\\n\\t\\tif (manager[i] == -1) continue;\\n\\n\\t\\tmap.putIfAbsent(manager[i], new ArrayList<>());\\n\\t\\tmap.get(manager[i]).add(i); // Keep manager index and employee index mapping\\n\\t}\\n}\\n```\n```java\\nif (n == 0 || headID < 0) return -1;\\nif (manager == null || manager.length == 0) return -1;\\nif (informTime == null || informTime.length == 0) return -1; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591992,
                "title": "c-easy-solution-beginner-friendly",
                "content": "###      **\\uD83D\\uDD25 Donn Forget to upvote if you liked the Approach \\uD83D\\uDD25**\\n\\n# Approach\\nApproach to this problem is pretty simple. We\\'ll try to make a tree with the ***headID*** as the root of the tree and we\\'ll calculate the maximum length of the tree where the edge length of each node is equal to the ***informTime***. Basically we\\'re converting the problem into Weighted Tree Problem.\\n\\n*Note: We\\'ll make Directed Edges.*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int check(vector<int> adj[], int itr,vector<int>& informTime)\\n    {\\n        int ans=0;\\n// Iterating through the tree nodes and checking for the path with maximum length.\\n        for(int i=0;i<adj[itr].size();i++)\\n        {\\n            ans=max(ans,check(adj,adj[itr][i],informTime));\\n        }\\n        ans+=informTime[itr];\\n\\n        return ans;\\n    }\\n    \\n    \\n    \\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n// Creating the structure of Tree.\\n        vector<int> adj[n];\\n        for(int i=0;i<manager.size();i++)\\n        {\\n            if(manager[i]==-1) continue;\\n            adj[manager[i]].push_back(i);\\n        }\\n\\n        int ans=check(adj,headID,informTime);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int check(vector<int> adj[], int itr,vector<int>& informTime)\\n    {\\n        int ans=0;\\n// Iterating through the tree nodes and checking for the path with maximum length.\\n        for(int i=0;i<adj[itr].size();i++)\\n        {\\n            ans=max(ans,check(adj,adj[itr][i],informTime));\\n        }\\n        ans+=informTime[itr];\\n\\n        return ans;\\n    }\\n    \\n    \\n    \\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n// Creating the structure of Tree.\\n        vector<int> adj[n];\\n        for(int i=0;i<manager.size();i++)\\n        {\\n            if(manager[i]==-1) continue;\\n            adj[manager[i]].push_back(i);\\n        }\\n\\n        int ans=check(adj,headID,informTime);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2255697,
                "title": "simple-c-dfs-based-recusrive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int> adj[],int src,vector<int>& informTime)\\n    {\\n        int k=informTime[src];\\n        int mx=0;\\n        for(auto u:adj[src])\\n        {\\n            mx=max(mx,dfs(adj,u,informTime));\\n        }\\n        return k+mx;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(manager[i]==-1)\\n                continue;\\n            adj[manager[i]].push_back(i);\\n        }\\n        return dfs(adj,headID,informTime);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int> adj[],int src,vector<int>& informTime)\\n    {\\n        int k=informTime[src];\\n        int mx=0;\\n        for(auto u:adj[src])\\n        {\\n            mx=max(mx,dfs(adj,u,informTime));\\n        }\\n        return k+mx;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(manager[i]==-1)\\n                continue;\\n            adj[manager[i]].push_back(i);\\n        }\\n        return dfs(adj,headID,informTime);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591903,
                "title": "detailed-image-explanation-with-time-and-space-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n![1New Document - Selection.png](https://assets.leetcode.com/users/images/71d5e424-695b-48ea-a70d-ed008bade22c_1685774537.9340808.png)\\n![2New Document - Selection.png](https://assets.leetcode.com/users/images/f6e95cf0-fa0f-4587-9b78-4e45e0d0f884_1685774602.3406441.png)\\n![3New Document - Selection.png](https://assets.leetcode.com/users/images/7ece57c2-bb84-4ddc-a03c-a78c3f73ed1f_1685774691.1817122.png)\\n![4New Document - Selection.png](https://assets.leetcode.com/users/images/a3466f7c-2787-470c-b60b-93dcf2bf0b55_1685774754.7457108.png)\\n\\n\\n\\n# Code (BFS)\\n```\\nclass Pair {\\n    int u;\\n    int minutes;\\n\\n    Pair(int u, int minutes) {\\n        this.u = u;\\n        this.minutes = minutes;\\n    }\\n}\\n\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        // Create an adjacency list to represent the hierarchy\\n        List<List<Integer>> adjList = new ArrayList<>();\\n\\n        // Initialize the adjacency list with empty lists\\n        for (int i = 0; i < n; i++) {\\n            adjList.add(new ArrayList<>());\\n        }\\n\\n        // Build the adjacency list based on the manager array\\n        for (int i = 0; i < n; i++) {\\n            int u = i; // Employee i\\n            int v = manager[i]; // Manager of employee i\\n\\n            if (v != -1) {\\n                adjList.get(v).add(u); // Add employee i to the list of subordinates of manager v\\n            }\\n        }\\n\\n        // Create a queue for the breadth-first search traversal\\n        Queue<Pair> queue = new LinkedList<>();\\n        queue.offer(new Pair(headID, 0)); // Enqueue the headID (starting point) with 0 minutes\\n\\n        int totalMinutes = 0;\\n\\n        // Perform the breadth-first search traversal\\n        while (!queue.isEmpty()) {\\n            Pair pair = queue.poll();\\n            int node = pair.u; // Current node\\n            int minutes = pair.minutes; // Minutes taken to reach the current node\\n\\n            // Update the total minutes to the maximum of the current total and the minutes taken to reach the current node\\n            totalMinutes = Math.max(totalMinutes, minutes);\\n\\n            // Explore the subordinates of the current node\\n            for (Integer adjNode : adjList.get(node)) {\\n                // Enqueue the subordinates with updated minutes (minutes + informTime[node])\\n                queue.offer(new Pair(adjNode, minutes + informTime[node]));\\n            }\\n        }\\n\\n        return totalMinutes;\\n    }\\n}\\n```\\n\\n# Complexity\\n### Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- We are doing BFS and we visit each node at most 1. Because of that our time complexity will be $$ O(n) $$. n is number of nodes in the graph.\\n\\n### Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- We have used List to store our graph representation and Queue for BFS traversal and both will take $$O(n)$$ space complexity.\\n\\n\\n# Code (DFS)\\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        List<List<Integer>> adjList = new ArrayList<>();\\n\\n        // Create an adjacency list to represent the hierarchy\\n        for (int i = 0; i < n; i++) {\\n            adjList.add(new ArrayList<>());\\n        }\\n\\n        // Build the adjacency list based on the manager array\\n        for (int i = 0; i < n; i++) {\\n            int u = i; // Employee i\\n            int v = manager[i]; // Manager of employee i\\n\\n            if (v != -1) {\\n                adjList.get(v).add(u); // Add employee i to the list of subordinates of manager v\\n            }\\n        }\\n\\n        // Start the depth-first search from the headID and return the result\\n        return dfs(headID, adjList, informTime);\\n    }\\n\\n    public int dfs(int node, List<List<Integer>> adjList, int informTime[]) {\\n        int ans = 0;\\n\\n        // Traverse the subordinates of the current node\\n        for (Integer adjNode : adjList.get(node)) {\\n            // Recursively call the dfs function for each subordinate and update the maximum time\\n            ans = Math.max(ans, dfs(adjNode, adjList, informTime));\\n        }\\n\\n        // Return the maximum time for the current node and add the informTime for this node\\n        return ans + informTime[node];\\n    }\\n}\\n\\n```\\n\\n# Complexity\\n### Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- We are doing DFS and we visit each node at most 1. Because of that our time complexity will be $$ O(n) $$. n is number of nodes in the graph.\\n\\n### Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- We have used List to store our graph representation required $$O(n)$$ space and for recursive call it\\'ll take $$O(n)$$ at worst space complexity.\\n\\n\\n### Please upvote if it helps you.\\n\\nAnything wrong please feel free to comment down.",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Pair {\\n    int u;\\n    int minutes;\\n\\n    Pair(int u, int minutes) {\\n        this.u = u;\\n        this.minutes = minutes;\\n    }\\n}\\n\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        // Create an adjacency list to represent the hierarchy\\n        List<List<Integer>> adjList = new ArrayList<>();\\n\\n        // Initialize the adjacency list with empty lists\\n        for (int i = 0; i < n; i++) {\\n            adjList.add(new ArrayList<>());\\n        }\\n\\n        // Build the adjacency list based on the manager array\\n        for (int i = 0; i < n; i++) {\\n            int u = i; // Employee i\\n            int v = manager[i]; // Manager of employee i\\n\\n            if (v != -1) {\\n                adjList.get(v).add(u); // Add employee i to the list of subordinates of manager v\\n            }\\n        }\\n\\n        // Create a queue for the breadth-first search traversal\\n        Queue<Pair> queue = new LinkedList<>();\\n        queue.offer(new Pair(headID, 0)); // Enqueue the headID (starting point) with 0 minutes\\n\\n        int totalMinutes = 0;\\n\\n        // Perform the breadth-first search traversal\\n        while (!queue.isEmpty()) {\\n            Pair pair = queue.poll();\\n            int node = pair.u; // Current node\\n            int minutes = pair.minutes; // Minutes taken to reach the current node\\n\\n            // Update the total minutes to the maximum of the current total and the minutes taken to reach the current node\\n            totalMinutes = Math.max(totalMinutes, minutes);\\n\\n            // Explore the subordinates of the current node\\n            for (Integer adjNode : adjList.get(node)) {\\n                // Enqueue the subordinates with updated minutes (minutes + informTime[node])\\n                queue.offer(new Pair(adjNode, minutes + informTime[node]));\\n            }\\n        }\\n\\n        return totalMinutes;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        List<List<Integer>> adjList = new ArrayList<>();\\n\\n        // Create an adjacency list to represent the hierarchy\\n        for (int i = 0; i < n; i++) {\\n            adjList.add(new ArrayList<>());\\n        }\\n\\n        // Build the adjacency list based on the manager array\\n        for (int i = 0; i < n; i++) {\\n            int u = i; // Employee i\\n            int v = manager[i]; // Manager of employee i\\n\\n            if (v != -1) {\\n                adjList.get(v).add(u); // Add employee i to the list of subordinates of manager v\\n            }\\n        }\\n\\n        // Start the depth-first search from the headID and return the result\\n        return dfs(headID, adjList, informTime);\\n    }\\n\\n    public int dfs(int node, List<List<Integer>> adjList, int informTime[]) {\\n        int ans = 0;\\n\\n        // Traverse the subordinates of the current node\\n        for (Integer adjNode : adjList.get(node)) {\\n            // Recursively call the dfs function for each subordinate and update the maximum time\\n            ans = Math.max(ans, dfs(adjNode, adjList, informTime));\\n        }\\n\\n        // Return the maximum time for the current node and add the informTime for this node\\n        return ans + informTime[node];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591489,
                "title": "c-easy-solution-bfs-queue",
                "content": "# Intuition\\nHere head is the root node and the time required to inform is called weight of the edge. We need to find the max time required to inform all the employees. This problems seems like we need to find the min-cost from root node to all other nodes and find the maximum among them. This problem will be solved by Dijkstra\\'s Algorithm.\\n\\n# Approach\\nLet us make adjacency list which contains the direct employee to a certain manager.\\n**vector<int>adj[n].**\\n\\nTo store the minimum time to be informed we make a vector time initialised with large number.\\n**vector<int>time(n,INT_MAX)**\\n\\nNow let us apply BFS from the source node with a queue of pairs. Initially to inform a head we need 0 minutes so we push 0 and headId.\\n**queue<pair<int,int>>q**\\n**q.push({0,headID})**\\n\\nLet u = q.front().second.\\nLet t = q.front().first (t is time required for u to receive message).\\n\\nFor every node v belongs to u, we need time required for u to receive message + time required to inform v.\\nLet that be reqtime = t+informTime[u]\\n\\nIf reqtime<time[v], we can update the time[v] and push into queue.\\n\\nReturn the maximum time from the vector time to get the required answer.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int>adj[n];\\n        for(int i = 0;i<n;i++){\\n            if(manager[i] == -1){\\n                continue;\\n            }\\n            adj[manager[i]].push_back(i);\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({0,headID});\\n        vector<int>time(n,INT_MAX);\\n        time[headID] = 0;\\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            int t = temp.first;\\n            int u = temp.second;\\n            for(auto v:adj[head]){\\n                int reqtime = t+informTime[u];\\n                if(reqtime<time[v]){\\n                    q.push({reqtime,v});\\n                    time[v] = reqtime;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0;i<n;i++){\\n            ans = max(ans,time[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int>adj[n];\\n        for(int i = 0;i<n;i++){\\n            if(manager[i] == -1){\\n                continue;\\n            }\\n            adj[manager[i]].push_back(i);\\n        }\\n        queue<pair<int,int>>q;\\n        q.push({0,headID});\\n        vector<int>time(n,INT_MAX);\\n        time[headID] = 0;\\n        while(!q.empty()){\\n            auto temp = q.front();\\n            q.pop();\\n            int t = temp.first;\\n            int u = temp.second;\\n            for(auto v:adj[head]){\\n                int reqtime = t+informTime[u];\\n                if(reqtime<time[v]){\\n                    q.push({reqtime,v});\\n                    time[v] = reqtime;\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0;i<n;i++){\\n            ans = max(ans,time[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591373,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Initialize an adjacency list to represent the hierarchical structure of the organization.\\n2.Perform a depth-first search (DFS) traversal starting from the head employee.\\n3.During the DFS traversal, track the accumulated time for each employee.\\n4.Update the maximum time needed whenever a greater time is encountered.\\n5.Return the maximum time needed for information propagation.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> adjList;\\n    int maxTimeNeeded = 0;\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) \\n    {\\n        initialize(manager,n);\\n        dfs(headID,0,informTime);\\n        return maxTimeNeeded;\\n    }\\n\\n    void initialize(vector<int>& manager,int n) \\n    {\\n        adjList.resize(n);\\n        int employeeIndex = 0;\\n        for (int managerIndex : manager) \\n        {\\n            if (managerIndex != -1) \\n            {\\n                adjList[managerIndex].push_back(employeeIndex);\\n            }\\n            employeeIndex++;\\n        }\\n    }\\n\\n    void dfs(int currentNode, int currentTime, vector<int>& informTime) \\n    {\\n        if (currentTime > maxTimeNeeded) \\n        {\\n            maxTimeNeeded = currentTime; \\n        }\\n        \\n        for (int subordinate : adjList[currentNode]) \\n        {\\n            int updatedTime = currentTime + informTime[currentNode];\\n            dfs(subordinate, updatedTime, informTime);\\n        }\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<vector<int>> adjList;\\n    int maxTimeNeeded = 0;\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) \\n    {\\n        initialize(manager,n);\\n        dfs(headID,0,informTime);\\n        return maxTimeNeeded;\\n    }\\n\\n    void initialize(vector<int>& manager,int n) \\n    {\\n        adjList.resize(n);\\n        int employeeIndex = 0;\\n        for (int managerIndex : manager) \\n        {\\n            if (managerIndex != -1) \\n            {\\n                adjList[managerIndex].push_back(employeeIndex);\\n            }\\n            employeeIndex++;\\n        }\\n    }\\n\\n    void dfs(int currentNode, int currentTime, vector<int>& informTime) \\n    {\\n        if (currentTime > maxTimeNeeded) \\n        {\\n            maxTimeNeeded = currentTime; \\n        }\\n        \\n        for (int subordinate : adjList[currentNode]) \\n        {\\n            int updatedTime = currentTime + informTime[currentNode];\\n            dfs(subordinate, updatedTime, informTime);\\n        }\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591244,
                "title": "python3-c-java-bfs-dict",
                "content": "# Please Upvote \\uD83D\\uDE07\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, std::vector<int>& a, std::vector<int>& b) {\\n        std::unordered_map<int, std::vector<int>> mp;\\n        for (int i = 0; i < a.size(); i++) {\\n            mp[a[i]].push_back(i);\\n        }\\n        std::deque<std::vector<int>> v;\\n        v.push_back({headID, b[headID]});\\n        int ans = 0;\\n        while (!v.empty()) {\\n            std::vector<int> x = v.front();\\n            v.pop_front();\\n            for (int i : mp[x[0]]) {\\n                v.push_back({i, x[1] + b[i]});\\n                ans = std::max(ans, x[1] + b[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Python3\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, a: List[int], b: List[int]) -> int:\\n        mp=defaultdict(list)\\n        for i in range(len(a)):\\n            mp[a[i]].append(i)\\n        v=deque()\\n        v+=[[headID,b[headID]]]\\n        ans=0\\n        while v:\\n            x=v[0]\\n            v.popleft()\\n            for i in mp[x[0]]:\\n                v+=[[i,x[1]+b[i]]]\\n                ans=max(ans,x[1]+b[i])\\n        return ans\\n            \\n            \\n```\\n# JAVA\\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] a, int[] b) {\\n        Map<Integer, List<Integer>> mp = new HashMap<>();\\n        for (int i = 0; i < a.length; i++) {\\n            mp.computeIfAbsent(a[i], k -> new ArrayList<>()).add(i);\\n        }\\n        Deque<int[]> v = new ArrayDeque<>();\\n        v.add(new int[]{headID, b[headID]});\\n        int ans = 0;\\n        while (!v.isEmpty()) {\\n            int[] x = v.pollFirst();\\n            for (int i : mp.getOrDefault(x[0], new ArrayList<>())) {\\n                v.add(new int[]{i, x[1] + b[i]});\\n                ans = Math.max(ans, x[1] + b[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/2e8406f3-dd08-44bf-8b74-b4c1e3d63cb1_1685761147.083231.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, std::vector<int>& a, std::vector<int>& b) {\\n        std::unordered_map<int, std::vector<int>> mp;\\n        for (int i = 0; i < a.size(); i++) {\\n            mp[a[i]].push_back(i);\\n        }\\n        std::deque<std::vector<int>> v;\\n        v.push_back({headID, b[headID]});\\n        int ans = 0;\\n        while (!v.empty()) {\\n            std::vector<int> x = v.front();\\n            v.pop_front();\\n            for (int i : mp[x[0]]) {\\n                v.push_back({i, x[1] + b[i]});\\n                ans = std::max(ans, x[1] + b[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, a: List[int], b: List[int]) -> int:\\n        mp=defaultdict(list)\\n        for i in range(len(a)):\\n            mp[a[i]].append(i)\\n        v=deque()\\n        v+=[[headID,b[headID]]]\\n        ans=0\\n        while v:\\n            x=v[0]\\n            v.popleft()\\n            for i in mp[x[0]]:\\n                v+=[[i,x[1]+b[i]]]\\n                ans=max(ans,x[1]+b[i])\\n        return ans\\n            \\n            \\n```\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] a, int[] b) {\\n        Map<Integer, List<Integer>> mp = new HashMap<>();\\n        for (int i = 0; i < a.length; i++) {\\n            mp.computeIfAbsent(a[i], k -> new ArrayList<>()).add(i);\\n        }\\n        Deque<int[]> v = new ArrayDeque<>();\\n        v.add(new int[]{headID, b[headID]});\\n        int ans = 0;\\n        while (!v.isEmpty()) {\\n            int[] x = v.pollFirst();\\n            for (int i : mp.getOrDefault(x[0], new ArrayList<>())) {\\n                v.add(new int[]{i, x[1] + b[i]});\\n                ans = Math.max(ans, x[1] + b[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966936,
                "title": "cpp-adjacency-list-easy-and-fast-solution",
                "content": "# Intuition\\nfirst select headID and then recursively go through all employee under it the employee at the lowest level will take maximum time to get the news and this time will be our required answer.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &v,int head, vector<int>& informTime,int curr,int &ans){\\n        ans=max(ans,curr);\\n        for(auto node :v[head]){\\n            dfs(v,node,informTime,curr+informTime[head],ans);\\n        }\\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> v(n);\\n        for(int i=0;i<n;i++){\\n            if(manager[i]!=-1){\\n                v[manager[i]].push_back(i);\\n            }\\n        }\\n        int ans=0;\\n        dfs(v,headID,informTime,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &v,int head, vector<int>& informTime,int curr,int &ans){\\n        ans=max(ans,curr);\\n        for(auto node :v[head]){\\n            dfs(v,node,informTime,curr+informTime[head],ans);\\n        }\\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> v(n);\\n        for(int i=0;i<n;i++){\\n            if(manager[i]!=-1){\\n                v[manager[i]].push_back(i);\\n            }\\n        }\\n        int ans=0;\\n        dfs(v,headID,informTime,0,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 931896,
                "title": "top-down-solution-no-need-to-build-any-graph-or-tree",
                "content": "TLDR; here is the code:\\n```\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n\\t\\tthis.memo = new int[n];\\n\\t\\tint ans = 0;\\n        for (int i = 0; i < n; i++) ans = Math.max(ans, solve(i));\\n        return ans;\\n    }\\n    \\n    private int solve(int emp) {\\n        if (memo[emp] != 0) return memo[emp];\\n        if (emp == headID) return 0;\\n        \\n        memo[emp] = informTime[manager[emp]] + solve(manager[emp]);\\n        return memo[emp];\\n    }\\n```\\n\\nThe idea of this solution is very simple. We don\\'t need to build the actual tree or a graph on even calculate the children of any node.\\n\\nThe solution relies of this very simple recurrence relation:\\nlet `T(i)` be the time needed for a message to reach the i-th employee, then:\\n`T(i) = T(manager[i]) + informTime[manager[i]]`\\n\\nand the base case is `T(headID) = 0`\\n\\nin plain English, this says that the the time needed for a message to reach the an employee is the time needed for a message to reach his manager + the time needed for the message to get from the manager to the employee himself.\\n\\nWe just need to get the max of `T(i)` for all `i`.\\n\\nWe need to memoize the answers though because there could be repeated recursive calls. To see why, imagine we already calculated T(x) where x is an arbitrary employee, then when calculating T(y) where y is a child of x, we are going to need to calculate T(x) again because `T(y) = T(x) + T(informTime[x])`\\n\\nThe time complexity is O(n) since we visit any employee only once (we memoize solutions of visited employees) and space complexity is O(n) since we need a memoization array of size n.\\n\\nThe solution is a top down solution because we build the solutions of larger problems (leaf nodes) using solutions of smaller sub problems (parents of leaf nodes)",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n\\t\\tthis.memo = new int[n];\\n\\t\\tint ans = 0;\\n        for (int i = 0; i < n; i++) ans = Math.max(ans, solve(i));\\n        return ans;\\n    }\\n    \\n    private int solve(int emp) {\\n        if (memo[emp] != 0) return memo[emp];\\n        if (emp == headID) return 0;\\n        \\n        memo[emp] = informTime[manager[emp]] + solve(manager[emp]);\\n        return memo[emp];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591695,
                "title": "c-easy-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nvoid sumi(int node, int time, int &ans, vector<pair<int,int>> adj[]){\\n    if(adj[node].size()==0) ans=max(time,ans);\\n    for(auto child:adj[node]){\\n        sumi(child.first,time+child.second,ans,adj);\\n    }\\n}\\n\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<pair<int,int>> adj[n];\\n        for(int i=0;i<n;i++){\\n            if(manager[i]!=-1) adj[manager[i]].push_back({i,informTime[manager[i]]});\\n        } \\n        int ans=0;\\n        int time=0;\\n        sumi(headID,time,ans,adj);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nvoid sumi(int node, int time, int &ans, vector<pair<int,int>> adj[]){\\n    if(adj[node].size()==0) ans=max(time,ans);\\n    for(auto child:adj[node]){\\n        sumi(child.first,time+child.second,ans,adj);\\n    }\\n}\\n\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<pair<int,int>> adj[n];\\n        for(int i=0;i<n;i++){\\n            if(manager[i]!=-1) adj[manager[i]].push_back({i,informTime[manager[i]]});\\n        } \\n        int ans=0;\\n        int time=0;\\n        sumi(headID,time,ans,adj);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591200,
                "title": "optimized-solution-daily-leetcode-challenge-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(int employee, vector<vector<int>>& adjList, vector<int>& informTime) {\\n        int totalTime = 0;\\n        \\n        // Iterate through subordinates\\n        for (int subordinate : adjList[employee]) {\\n            // Recursive call\\n            int subordinateTime = dfs(subordinate, adjList, informTime);\\n            \\n            // Update totalTime\\n            totalTime = max(totalTime, subordinateTime);\\n        }\\n        \\n        //  Return totalTime\\n        return totalTime + informTime[employee];\\n    }\\n    \\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        // Create adjacency list\\n        vector<vector<int>> adjList(n);\\n        for (int i = 0; i < n; i++) {\\n            if (manager[i] != -1) {\\n                adjList[manager[i]].push_back(i);\\n            }\\n        }\\n        \\n        // Call DFS function\\n        return dfs(headID, adjList, informTime);\\n    }\\n};\\n```\\n**PLEASE UPVOTE :)**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int employee, vector<vector<int>>& adjList, vector<int>& informTime) {\\n        int totalTime = 0;\\n        \\n        // Iterate through subordinates\\n        for (int subordinate : adjList[employee]) {\\n            // Recursive call\\n            int subordinateTime = dfs(subordinate, adjList, informTime);\\n            \\n            // Update totalTime\\n            totalTime = max(totalTime, subordinateTime);\\n        }\\n        \\n        //  Return totalTime\\n        return totalTime + informTime[employee];\\n    }\\n    \\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        // Create adjacency list\\n        vector<vector<int>> adjList(n);\\n        for (int i = 0; i < n; i++) {\\n            if (manager[i] != -1) {\\n                adjList[manager[i]].push_back(i);\\n            }\\n        }\\n        \\n        // Call DFS function\\n        return dfs(headID, adjList, informTime);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591016,
                "title": "java-dfs-beats-68-14-lines-clean-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe company hierarcy can be thought of as a tree data structure. Traverse the tree beginning the `headID` using DFS and figure out the max time out of all the sequences from the head to any leaf node.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  private List<Integer>[] adj;\\n\\n  private int dfs(int id, int[] manager, int[] informTime) {\\n    var time = 0;\\n\\n    for (var emp : adj[id])\\n      time = Math.max(time, dfs(emp, manager, informTime));\\n\\n    return time + informTime[id];\\n  }\\n\\n  public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n    adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var i=0; i<n; i++) {\\n      if (i == headID) continue;\\n      adj[manager[i]].add(i);\\n    }\\n    return dfs(headID, manager, informTime);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  private List<Integer>[] adj;\\n\\n  private int dfs(int id, int[] manager, int[] informTime) {\\n    var time = 0;\\n\\n    for (var emp : adj[id])\\n      time = Math.max(time, dfs(emp, manager, informTime));\\n\\n    return time + informTime[id];\\n  }\\n\\n  public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n    adj = new ArrayList[n];\\n\\n    for (var i=0; i<n; i++)\\n      adj[i] = new ArrayList<>();\\n\\n    for (var i=0; i<n; i++) {\\n      if (i == headID) continue;\\n      adj[manager[i]].add(i);\\n    }\\n    return dfs(headID, manager, informTime);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769211,
                "title": "java-solution-dfs",
                "content": "```\\nclass Solution {\\n public int numOfMinutes(final int n, final int headID, final int[] manager, final int[] informTime) {\\n        final Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int total = 0;\\n        for (int i = 0; i < manager.length; i++) {\\n            int j = manager[i];\\n            if (!graph.containsKey(j))\\n                graph.put(j, new ArrayList<>());\\n            graph.get(j).add(i);\\n        }\\n        return dfs(graph, informTime, headID);\\n    }\\n\\n    private int dfs(final Map<Integer, List<Integer>> graph, final int[] informTime, final int cur) {\\n        int max = 0;\\n        if (!graph.containsKey(cur))\\n            return max;\\n        for (int i = 0; i < graph.get(cur).size(); i++)\\n            max = Math.max(max, dfs(graph, informTime, graph.get(cur).get(i)));\\n        return max + informTime[cur];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n public int numOfMinutes(final int n, final int headID, final int[] manager, final int[] informTime) {\\n        final Map<Integer, List<Integer>> graph = new HashMap<>();\\n        int total = 0;\\n        for (int i = 0; i < manager.length; i++) {\\n            int j = manager[i];\\n            if (!graph.containsKey(j))\\n                graph.put(j, new ArrayList<>());\\n            graph.get(j).add(i);\\n        }\\n        return dfs(graph, informTime, headID);\\n    }\\n\\n    private int dfs(final Map<Integer, List<Integer>> graph, final int[] informTime, final int cur) {\\n        int max = 0;\\n        if (!graph.containsKey(cur))\\n            return max;\\n        for (int i = 0; i < graph.get(cur).size(); i++)\\n            max = Math.max(max, dfs(graph, informTime, graph.get(cur).get(i)));\\n        return max + informTime[cur];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2097204,
                "title": "c-dfs-bfs-solution-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int> &informTime,vector<vector<int>> &Adjlist,int headID){\\n        \\n        int time=0;\\n        int node=headID;\\n        for(int &neighb :Adjlist[node]){\\n            time=max(time,dfs(informTime,Adjlist,neighb));\\n        }\\n        \\n        return informTime[node]+time; // maxtime to send info till this node \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        \\n        \\n        vector<vector<int>> Adjlist(n+1);\\n        //make graph out of manager connection info \\n        for(int i=0;i<n;i++){\\n           if(manager[i]==-1) continue;\\n            Adjlist[manager[i]].push_back(i);\\n        }\\n        \\n        return dfs(informTime,Adjlist,headID);\\n       // return bfs(informTime,Adjlist,headID);\\n        \\n      \\n        \\n    }\\n    int bfs(vector<int> &informTime,vector<vector<int>> &Adjlist,int headID){\\n          queue<pair<int,int>> q;\\n        q.push({headID,0});\\n        int maxtime=0;\\n        \\n        //BFS for every direct subordinates \\n        while(!q.empty()){\\n            int n=q.size();\\n            // BFS on current level \\n            for(int i=0;i<n;i++){\\n                int parent=q.front().first; // source \\n                int timetillparent=q.front().second; //timetaken for news to reach till // source\\n                q.pop();\\n                // time taken for news to reach neighbouring nodes \\n                // = timetaken for news to reach till parent + time taken for parent to // inform to its neighbours \\n                int nexttime=informTime[parent]+timetillparent;\\n                maxtime=max(maxtime,nexttime);\\n                for(auto node:Adjlist[parent]){\\n                    //Adjnode, timetaken for news to reach till that node \\n                    q.push({node,nexttime});\\n                }\\n            }\\n            \\n            \\n        }\\n        return maxtime;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int> &informTime,vector<vector<int>> &Adjlist,int headID){\\n        \\n        int time=0;\\n        int node=headID;\\n        for(int &neighb :Adjlist[node]){\\n            time=max(time,dfs(informTime,Adjlist,neighb));\\n        }\\n        \\n        return informTime[node]+time; // maxtime to send info till this node \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        \\n        \\n        vector<vector<int>> Adjlist(n+1);\\n        //make graph out of manager connection info \\n        for(int i=0;i<n;i++){\\n           if(manager[i]==-1) continue;\\n            Adjlist[manager[i]].push_back(i);\\n        }\\n        \\n        return dfs(informTime,Adjlist,headID);\\n       // return bfs(informTime,Adjlist,headID);\\n        \\n      \\n        \\n    }\\n    int bfs(vector<int> &informTime,vector<vector<int>> &Adjlist,int headID){\\n          queue<pair<int,int>> q;\\n        q.push({headID,0});\\n        int maxtime=0;\\n        \\n        //BFS for every direct subordinates \\n        while(!q.empty()){\\n            int n=q.size();\\n            // BFS on current level \\n            for(int i=0;i<n;i++){\\n                int parent=q.front().first; // source \\n                int timetillparent=q.front().second; //timetaken for news to reach till // source\\n                q.pop();\\n                // time taken for news to reach neighbouring nodes \\n                // = timetaken for news to reach till parent + time taken for parent to // inform to its neighbours \\n                int nexttime=informTime[parent]+timetillparent;\\n                maxtime=max(maxtime,nexttime);\\n                for(auto node:Adjlist[parent]){\\n                    //Adjnode, timetaken for news to reach till that node \\n                    q.push({node,nexttime});\\n                }\\n            }\\n            \\n            \\n        }\\n        return maxtime;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769736,
                "title": "simple-c-with-explanation",
                "content": "/***Approach:-** This question is treated as maximum depth of of tree +DFS.\\nOne each level we check what is the maximum time taken to spread the urgent news.\\n\\n**-->We will make adjacency List of the employees with their respective manegers.\\n-->Initially our root maneger is head maneger.\\n-->Inside the solve function ,we check time taken to spread the news by root manger to its employee\\n-->Dry the code for better understanding.**\\n-->I have taken some suitable variable name for easy understanding.*/\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    int solve(int root,vector<int>&informTime)\\n    {\\n        int time_for_that_node=informTime[root],maximu_time_for_its_child_node=0;;\\n        for(int i=0;i<adj[root].size();i++)\\n            maximu_time_for_its_child_node=max(maximu_time_for_its_child_node,solve(adj[root][i],informTime));\\n        \\n        return time_for_that_node+maximu_time_for_its_child_node;\\n    }\\n    \\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        adj.resize(n);\\n        int root=headID;\\n       /*Here , we are making adjacency List.*/ \\n        for(int i=0;i<n;i++)\\n        {\\n            if(manager[i]!=-1)\\n            adj[manager[i]].push_back(i);\\n        }\\n        \\n        return solve(root,informTime);\\n    }\\n};\\n```\\n*If you find it helpful. Please upvote. *",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>adj;\\n    int solve(int root,vector<int>&informTime)\\n    {\\n        int time_for_that_node=informTime[root],maximu_time_for_its_child_node=0;;\\n        for(int i=0;i<adj[root].size();i++)\\n            maximu_time_for_its_child_node=max(maximu_time_for_its_child_node,solve(adj[root][i],informTime));\\n        \\n        return time_for_that_node+maximu_time_for_its_child_node;\\n    }\\n    \\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        adj.resize(n);\\n        int root=headID;\\n       /*Here , we are making adjacency List.*/ \\n        for(int i=0;i<n;i++)\\n        {\\n            if(manager[i]!=-1)\\n            adj[manager[i]].push_back(i);\\n        }\\n        \\n        return solve(root,informTime);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390032,
                "title": "python-dfs-very-easy",
                "content": "```\\n\\ndef numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        \"\"\"\\n        This is a very easy question, we need dict/graph mapping managers to employees and then\\n        we can do dfs to find time for each leaf node to be informed. The max of such leaf node\\n        times is the answer as that will be the maximum time taken to inform all employees\\n        \"\"\"\\n        rel_map = collections.defaultdict(list)\\n        ans = 0\\n        \\n        # initalizing rel_map for building graph\\n        for emp,manager in enumerate(manager):\\n            rel_map[manager].append(emp)\\n            \\n        # now calculate time for each leaf node and find max\\n        def dfs(eid):\\n            # no further subordinate\\n            if not rel_map.get(eid):\\n                return 0\\n            \\n            time = informTime[eid] \\n            time += max([ dfs(cid) for cid in rel_map.get(eid)])\\n            \\n            return time\\n        \\n        return dfs(headID)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n\\ndef numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        \"\"\"\\n        This is a very easy question, we need dict/graph mapping managers to employees and then\\n        we can do dfs to find time for each leaf node to be informed. The max of such leaf node\\n        times is the answer as that will be the maximum time taken to inform all employees\\n        \"\"\"\\n        rel_map = collections.defaultdict(list)\\n        ans = 0\\n        \\n        # initalizing rel_map for building graph\\n        for emp,manager in enumerate(manager):\\n            rel_map[manager].append(emp)\\n            \\n        # now calculate time for each leaf node and find max\\n        def dfs(eid):\\n            # no further subordinate\\n            if not rel_map.get(eid):\\n                return 0\\n            \\n            time = informTime[eid] \\n            time += max([ dfs(cid) for cid in rel_map.get(eid)])\\n            \\n            return time\\n        \\n        return dfs(headID)\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1386365,
                "title": "bfs-dfs-java-easy",
                "content": "**BFS**\\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        // ************* Make graph *****************************\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        for( int i = 0 ; i < n ; i++ ){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for( int i = 0 ; i < manager.length ; i++ ){\\n            int par = manager[i];\\n            if( par != -1 ){ \\n                graph[par].add(i);\\n            }\\n        }\\n        // *******************************************************\\n    \\n        LinkedList<Pair> que = new LinkedList<>();\\n        que.addLast( new Pair( headID , 0 ) );\\n        \\n        // ********* Apply BFS**************************\\n        int maxTime = 0;\\n        while( que.size() > 0 ){\\n            int size = que.size();\\n            while(size-- > 0){\\n                Pair rem = que.removeFirst();\\n                int rVtx = rem.vtx;\\n                int rTime = rem.time;\\n                \\n                maxTime = Math.max( maxTime , rTime );\\n                \\n                int timeForNbr = informTime[rVtx];\\n                for( Integer nbr : graph[rVtx] ){\\n                    que.addLast( new Pair( nbr , rTime + timeForNbr ) );\\n                }\\n                \\n            }\\n        }\\n        return maxTime;\\n    }\\n    public class Pair{\\n        int vtx;\\n        int time;\\n        Pair(int vtx , int time){\\n            this.vtx = vtx;\\n            this.time = time;\\n        }\\n    }\\n}\\n```\\n**DFS**\\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        // ************* Make graph *****************************\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        for( int i = 0 ; i < n ; i++ ){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for( int i = 0 ; i < manager.length ; i++ ){\\n            int par = manager[i];\\n            if( par != -1 ){ \\n                graph[par].add(i);\\n            }\\n        }\\n        // ********* Apply DFS**************************\\n        \\n        return dfs(graph,headID,informTime);   \\n    }\\n    public int dfs(ArrayList<Integer>[] graph , int src , int[] informTime){\\n        int childTime = 0;\\n        for( Integer nbr : graph[src] ){\\n            childTime = Math.max( childTime , dfs( graph , nbr , informTime) );\\n        }\\n        int totalTime = childTime + informTime[src];\\n        return totalTime;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        // ************* Make graph *****************************\\n        ArrayList<Integer>[] graph = new ArrayList[n];\\n        for( int i = 0 ; i < n ; i++ ){\\n            graph[i] = new ArrayList<>();\\n        }\\n        for( int i = 0 ; i < manager.length ; i++ ){\\n            int par = manager[i];\\n            if( par != -1 ){ \\n                graph[par].add(i);\\n            }\\n        }\\n        // *******************************************************\\n    \\n        LinkedList<Pair> que = new LinkedList<>();\\n        que.addLast( new Pair( headID , 0 ) );\\n        \\n        // ********* Apply BFS**************************\\n        int maxTime = 0;\\n        while( que.size() > 0 ){\\n            int size = que.size();\\n            while(size-- > 0){\\n                Pair rem = que.removeFirst();\\n                int rVtx = rem.vtx;\\n                int rTime = rem.time;\\n                \\n                maxTime = Math.max( maxTime , rTime );\\n                \\n                int timeForNbr = informTime[rVtx];\\n                for( Integer nbr : graph[rVtx] ){\\n                    que.addLast( new Pair( nbr , rTime + timeForNbr ) );\\n                }\\n                \\n            }\\n        }\\n        return maxTime;\\n    }\\n    public class Pair{\\n        int vtx;\\n        int time;\\n        Pair(int vtx , int time){\\n            this.vtx = vtx;\\n            this.time = time;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384419,
                "title": "c-bfs",
                "content": "The answer is the maximum time taken to each  employee with no subordinates. \\n\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++){\\n            if(manager[i]!=-1)\\n                adj[manager[i]].push_back(i);\\n        }\\n        int ans = 0;\\n        queue<pair<int,int>> q;\\n        q.push({headID , 0});\\n        \\n        while(!q.empty()){\\n            auto top = q.front();\\n            int curr = top.first;\\n            int cost = top.second;\\n            q.pop();\\n            ans = max(ans , cost);             \\n            for(int j=0;j<adj[curr].size();j++){\\n                q.push({adj[curr][j] , cost + informTime[curr]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<n;i++){\\n            if(manager[i]!=-1)\\n                adj[manager[i]].push_back(i);\\n        }\\n        int ans = 0;\\n        queue<pair<int,int>> q;\\n        q.push({headID , 0});\\n        \\n        while(!q.empty()){\\n            auto top = q.front();\\n            int curr = top.first;\\n            int cost = top.second;\\n            q.pop();\\n            ans = max(ans , cost);             \\n            for(int j=0;j<adj[curr].size();j++){\\n                q.push({adj[curr][j] , cost + informTime[curr]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3211486,
                "title": "easy-to-understand-c-solution-using-bfs",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int NumOfMinutes(int n, int headID, int[] manager, int[] informTime)\\n    {\\n        var graph = new List<int>[n];\\n        for (var i = 0; i < n; i++)\\n        {\\n            graph[i] = new List<int>();\\n        }\\n\\n        for (var i = 0; i < manager.Length; i++)\\n        {\\n            if (manager[i] != -1)\\n            {\\n                graph[manager[i]].Add(i);\\n            }\\n        }\\n\\n        var queue = new Queue<(int Employee, int Time)>();\\n        queue.Enqueue((headID, 0));\\n\\n        var result = 0;\\n\\n        while (queue.Count != 0)\\n        {\\n            var size = queue.Count;\\n            for (var i = 0; i < size; i++)\\n            {\\n                var current = queue.Dequeue();\\n\\n                result = Math.Max(result, current.Time);\\n\\n                for (var j = 0; j < graph[current.Employee].Count; j++)\\n                {\\n                    queue.Enqueue((graph[current.Employee][j], current.Time + informTime[current.Employee]));\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n![pleaseupvote.jpg](https://assets.leetcode.com/users/images/ce562311-0d0b-4422-80c8-c7cb7cf8ff8e_1676919742.9708703.jpeg)\\n\\n",
                "solutionTags": [
                    "C#",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int NumOfMinutes(int n, int headID, int[] manager, int[] informTime)\\n    {\\n        var graph = new List<int>[n];\\n        for (var i = 0; i < n; i++)\\n        {\\n            graph[i] = new List<int>();\\n        }\\n\\n        for (var i = 0; i < manager.Length; i++)\\n        {\\n            if (manager[i] != -1)\\n            {\\n                graph[manager[i]].Add(i);\\n            }\\n        }\\n\\n        var queue = new Queue<(int Employee, int Time)>();\\n        queue.Enqueue((headID, 0));\\n\\n        var result = 0;\\n\\n        while (queue.Count != 0)\\n        {\\n            var size = queue.Count;\\n            for (var i = 0; i < size; i++)\\n            {\\n                var current = queue.Dequeue();\\n\\n                result = Math.Max(result, current.Time);\\n\\n                for (var j = 0; j < graph[current.Employee].Count; j++)\\n                {\\n                    queue.Enqueue((graph[current.Employee][j], current.Time + informTime[current.Employee]));\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975675,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int> v[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(manager[i]!=-1)\\n            v[manager[i]].push_back(i);\\n        }\\n        queue<pair<int, int>> q;\\n        q.push({headID, 0});\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                auto p=q.front();\\n                ans=max(ans, p.second);\\n                q.pop();\\n                for(int j=0;j<v[p.first].size();j++)\\n                q.push({v[p.first][j], p.second+informTime[p.first]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int> v[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(manager[i]!=-1)\\n            v[manager[i]].push_back(i);\\n        }\\n        queue<pair<int, int>> q;\\n        q.push({headID, 0});\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                auto p=q.front();\\n                ans=max(ans, p.second);\\n                q.pop();\\n                for(int j=0;j<v[p.first].size();j++)\\n                q.push({v[p.first][j], p.second+informTime[p.first]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2704896,
                "title": "c-dfs-graph-dp-approach-99-fast-easy-explained",
                "content": "\\n\\n### **First Approach - Graph ( TLE )**\\n```\\nclass Solution {\\n    int n1, headID1;\\n    vector<int> manager1, informTime1;\\n    \\n    int dfs(int i, vector<int> &vis){\\n        vis[i] = 1;\\n        \\n        int time = 0;\\n        for(int j = 0; j < n1; j++){\\n            if(manager1[j] == i && vis[j] == 0)\\n                time = max(time, dfs(j, vis));\\n        }\\n        \\n        time += informTime1[i];\\n        return time;\\n    }\\n    \\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        n1 = n, headID1 = headID, manager1 = manager, informTime1 = informTime;\\n        \\n        vector<int> vis(n, 0);\\n        return dfs(headID, vis);\\n    }\\n};\\n```\\n##### But, this gives TLE because it calling a \\'for loop\\' for scanning all employee with that manager every time it is calling a dfs function. So to reduce its time complexity we will form a graph in main function only which store opposite value, i.e., value of its employee.\\n<br>\\n\\n---\\n\\n### **Second Approach - Graph**\\n```\\nclass Solution {\\n    int n1, headID1;\\n    vector<int> informTime1;\\n    vector<vector<int>> graph;\\n    \\n    int dfs(int i, vector<int> &vis){\\n        vis[i] = 1;\\n        \\n        int time = 0;\\n        for(auto j : graph[i]){\\n            if(vis[j] == 0)\\n                time = max(time, dfs(j, vis));\\n        }\\n        \\n        time += informTime1[i];\\n        return time;\\n    }\\n    \\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        n1 = n, headID1 = headID, informTime1 = informTime;\\n        \\n\\t\\t\\n\\t\\t// Start -> Forming Graph\\n        graph = vector<vector<int>>(n);\\n        for(int i = 0; i<n; i++){\\n            if(i != headID)\\n                graph[manager[i]].push_back(i);\\n        }\\n\\t\\t// End\\n\\t\\t\\n        vector<int> vis(n, 0);\\n        return dfs(headID, vis);\\n    }\\n};\\n```\\n<br>\\n\\n---\\n\\n### **Third Approach - DP**\\n\\n\\n```\\nclass Solution {\\n    vector<int> dp;\\n    int dfs(int i, int headID, vector<int> &manager, vector<int>& informTime){\\n        // If i = -1 then it means we reached the top of the root\\n        if(i == -1) return 0;\\n\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        // Taking current node time and asking the upper branch to calculate its time.\\n        int ans = informTime[i] + dfs(manager[i], headID, manager, informTime); \\n        return dp[i] = ans;\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        dp = vector<int>(n, -1);\\n\\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            // Leaf node will have informTime as 0\\n            if(informTime[i] == 0)  \\n              // Ask the time required in a particular branch of tree starting from the leaf node\\n              ans = max(ans, dfs(i, headID, manager, informTime));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n<br>\\n\\n---\\n\\n```\\nThank you\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    int n1, headID1;\\n    vector<int> manager1, informTime1;\\n    \\n    int dfs(int i, vector<int> &vis){\\n        vis[i] = 1;\\n        \\n        int time = 0;\\n        for(int j = 0; j < n1; j++){\\n            if(manager1[j] == i && vis[j] == 0)\\n                time = max(time, dfs(j, vis));\\n        }\\n        \\n        time += informTime1[i];\\n        return time;\\n    }\\n    \\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        n1 = n, headID1 = headID, manager1 = manager, informTime1 = informTime;\\n        \\n        vector<int> vis(n, 0);\\n        return dfs(headID, vis);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int n1, headID1;\\n    vector<int> informTime1;\\n    vector<vector<int>> graph;\\n    \\n    int dfs(int i, vector<int> &vis){\\n        vis[i] = 1;\\n        \\n        int time = 0;\\n        for(auto j : graph[i]){\\n            if(vis[j] == 0)\\n                time = max(time, dfs(j, vis));\\n        }\\n        \\n        time += informTime1[i];\\n        return time;\\n    }\\n    \\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        n1 = n, headID1 = headID, informTime1 = informTime;\\n        \\n\\t\\t\\n\\t\\t// Start -> Forming Graph\\n        graph = vector<vector<int>>(n);\\n        for(int i = 0; i<n; i++){\\n            if(i != headID)\\n                graph[manager[i]].push_back(i);\\n        }\\n\\t\\t// End\\n\\t\\t\\n        vector<int> vis(n, 0);\\n        return dfs(headID, vis);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int> dp;\\n    int dfs(int i, int headID, vector<int> &manager, vector<int>& informTime){\\n        // If i = -1 then it means we reached the top of the root\\n        if(i == -1) return 0;\\n\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        // Taking current node time and asking the upper branch to calculate its time.\\n        int ans = informTime[i] + dfs(manager[i], headID, manager, informTime); \\n        return dp[i] = ans;\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        dp = vector<int>(n, -1);\\n\\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            // Leaf node will have informTime as 0\\n            if(informTime[i] == 0)  \\n              // Ask the time required in a particular branch of tree starting from the leaf node\\n              ans = max(ans, dfs(i, headID, manager, informTime));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nThank you\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303043,
                "title": "dfs-and-bfs-both-solution-o-n",
                "content": "Using BFS Algo\\n```\\nclass Solution {\\n    \\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n\\t\\t// graph creation\\n\\t\\tArrayList<ArrayList<Integer>> a = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            a.add(new ArrayList<Integer>());\\n        }\\n        \\n        for(int i=0;i<manager.length;i++){\\n            if(manager[i]>=0)\\n                a.get(manager[i]).add(i);\\n        }\\n\\t\\t\\n\\t\\t//bfs\\n        Queue<int[]> q = new LinkedList<>();\\n        int max=0;\\n        q.add(new int[]{headID,0});\\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            for(int i=0;i<s;i++){\\n                int[] temp = q.poll();\\n                max= Math.max(max,temp[1]);\\n                if(a.get(temp[0]).size()==0) continue;\\n                for(int j:a.get(temp[0])){\\n                    q.add(new int[]{j,temp[1]+informTime[temp[0]]});\\n                }\\n            }\\n        }\\n      return max;\\n \\n\\t }\\n }\\n        \\n```\\n\\nusing DFS Algo\\n\\n```\\nclass Solution {\\n    ArrayList<ArrayList<Integer>> a = new ArrayList<>();\\n\\t//dfs\\n    private int dfs(int node,int[] informTime){\\n        \\n        int max = 0;\\n        for(int i:a.get(node)){\\n            max = Math.max(max,dfs(i,informTime)+informTime[node]);\\n        }\\n        return max;\\n    }\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n\\t\\t// graph creation\\n        for(int i=0;i<n;i++){\\n            a.add(new ArrayList<Integer>());\\n        }\\n        \\n        for(int i=0;i<manager.length;i++){\\n            if(manager[i]>=0)\\n                a.get(manager[i]).add(i);\\n        }\\n        return dfs(headID,informTime);\\n       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n\\t\\t// graph creation\\n\\t\\tArrayList<ArrayList<Integer>> a = new ArrayList<>();\\n        for(int i=0;i<n;i++){\\n            a.add(new ArrayList<Integer>());\\n        }\\n        \\n        for(int i=0;i<manager.length;i++){\\n            if(manager[i]>=0)\\n                a.get(manager[i]).add(i);\\n        }\\n\\t\\t\\n\\t\\t//bfs\\n        Queue<int[]> q = new LinkedList<>();\\n        int max=0;\\n        q.add(new int[]{headID,0});\\n        while(!q.isEmpty()){\\n            int s = q.size();\\n            for(int i=0;i<s;i++){\\n                int[] temp = q.poll();\\n                max= Math.max(max,temp[1]);\\n                if(a.get(temp[0]).size()==0) continue;\\n                for(int j:a.get(temp[0])){\\n                    q.add(new int[]{j,temp[1]+informTime[temp[0]]});\\n                }\\n            }\\n        }\\n      return max;\\n \\n\\t }\\n }\\n        \\n```\n```\\nclass Solution {\\n    ArrayList<ArrayList<Integer>> a = new ArrayList<>();\\n\\t//dfs\\n    private int dfs(int node,int[] informTime){\\n        \\n        int max = 0;\\n        for(int i:a.get(node)){\\n            max = Math.max(max,dfs(i,informTime)+informTime[node]);\\n        }\\n        return max;\\n    }\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n\\t\\t// graph creation\\n        for(int i=0;i<n;i++){\\n            a.add(new ArrayList<Integer>());\\n        }\\n        \\n        for(int i=0;i<manager.length;i++){\\n            if(manager[i]>=0)\\n                a.get(manager[i]).add(i);\\n        }\\n        return dfs(headID,informTime);\\n       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 914131,
                "title": "python3-easy-o-n-time-and-space-solutions-with-comments",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        \\n        # build a tree from data, mapping employee to subordinates\\n        # dfs to find max sum path in tree\\n        \\n        # O(n) time and space\\n        \\n        # O(n) space to build tree\\n        # O(n) space in recursion stack to dfs (in the case of unbalanced tree)\\n        \\n        # O(n) time to build tree\\n        # O(n) time to dfs since we only visit each node once\\n\\n        tree = defaultdict(list)\\n        \\n        for i in range(len(manager)):\\n            man, sub = manager[i], i\\n            tree[man].append(sub)\\n            \\n        def dfs(node):\\n            \\n            # leaf\\n            if not tree[node]:\\n                return 0\\n            \\n            return informTime[node] + max(dfs(sub) for sub in tree[node])\\n        \\n        return dfs(headID)\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        \\n        # build a tree from data, mapping employee to subordinates\\n        # dfs to find max sum path in tree\\n        \\n        # O(n) time and space\\n        \\n        # O(n) space to build tree\\n        # O(n) space in recursion stack to dfs (in the case of unbalanced tree)\\n        \\n        # O(n) time to build tree\\n        # O(n) time to dfs since we only visit each node once\\n\\n        tree = defaultdict(list)\\n        \\n        for i in range(len(manager)):\\n            man, sub = manager[i], i\\n            tree[man].append(sub)\\n            \\n        def dfs(node):\\n            \\n            # leaf\\n            if not tree[node]:\\n                return 0\\n            \\n            return informTime[node] + max(dfs(sub) for sub in tree[node])\\n        \\n        return dfs(headID)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 600993,
                "title": "java-backtrack",
                "content": "```\\nclass Solution {\\n    \\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        for(int eid = 0; eid < manager.length; eid++) {\\n            int time = 0, mid = manager[eid];\\n            while (mid != -1) {\\n                time += informTime[mid];\\n                mid = manager[mid];\\n            }\\n            informTime[eid] += time;\\n            manager[eid] = -1;\\n        }\\n        int max = 0;\\n        for (int time : informTime) max = Math.max(max, time);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        for(int eid = 0; eid < manager.length; eid++) {\\n            int time = 0, mid = manager[eid];\\n            while (mid != -1) {\\n                time += informTime[mid];\\n                mid = manager[mid];\\n            }\\n            informTime[eid] += time;\\n            manager[eid] = -1;\\n        }\\n        int max = 0;\\n        for (int time : informTime) max = Math.max(max, time);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532718,
                "title": "straight-forward-c-simulating-passing-message",
                "content": "For each employee, the time is the sum of time passed to its manager, and manager informing him. So I just simulated the process, passing message to all employees, and all new informed people to the queue. Then I picked and returned the largest time. \\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> man(n);\\n        vector<int> time(n);\\n        for(int i = 0; i < manager.size(); i++){\\n            if(manager[i]==-1)  continue;\\n            man[manager[i]].push_back(i);\\n        }\\n        queue<int> q;\\n        \\n        for(auto e : man[headID])\\n            q.push(e);\\n        time[headID] = 0;\\n        while(!q.empty()){\\n            int cur = q.front();\\n            time[cur] = time[manager[cur]] + informTime[manager[cur]];\\n            q.pop();\\n            for(auto e : man[cur])\\n                q.push(e);\\n        }\\n        return *max_element(time.begin(), time.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> man(n);\\n        vector<int> time(n);\\n        for(int i = 0; i < manager.size(); i++){\\n            if(manager[i]==-1)  continue;\\n            man[manager[i]].push_back(i);\\n        }\\n        queue<int> q;\\n        \\n        for(auto e : man[headID])\\n            q.push(e);\\n        time[headID] = 0;\\n        while(!q.empty()){\\n            int cur = q.front();\\n            time[cur] = time[manager[cur]] + informTime[manager[cur]];\\n            q.pop();\\n            for(auto e : man[cur])\\n                q.push(e);\\n        }\\n        return *max_element(time.begin(), time.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532593,
                "title": "java-bfs",
                "content": "```java\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.putIfAbsent(manager[i], new HashSet<>());\\n            graph.get(manager[i]).add(i);\\n        }\\n        Queue<int[]> queue = new ArrayDeque<>();\\n\\t\\t// the first value is the id, and the second is the time to reach the children of id\\n        queue.offer(new int[]{-1, 0});\\n        int max = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                int[] cur = queue.poll();\\n                max = Math.max(max, cur[1]);\\n                if (!graph.containsKey(cur[0])) continue;\\n                for (int next : graph.get(cur[0])) {\\n                    queue.offer(new int[]{next, cur[1] + informTime[next]});\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.putIfAbsent(manager[i], new HashSet<>());\\n            graph.get(manager[i]).add(i);\\n        }\\n        Queue<int[]> queue = new ArrayDeque<>();\\n\\t\\t// the first value is the id, and the second is the time to reach the children of id\\n        queue.offer(new int[]{-1, 0});\\n        int max = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                int[] cur = queue.poll();\\n                max = Math.max(max, cur[1]);\\n                if (!graph.containsKey(cur[0])) continue;\\n                for (int next : graph.get(cur[0])) {\\n                    queue.offer(new int[]{next, cur[1] + informTime[next]});\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532537,
                "title": "c-simple-bfs-of-employee-with-time-o-n",
                "content": "Use a Queue-based level order traversal, calculate the maximum time at which the information can\\'t further proceed.\\n\\nStart from head and propagate further. Since it\\'s a tree, therefore we don\\'t need to take care of visited. \\nPre-compute the list of employees, managed by every person and then propagate information when received by any manager.\\n\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        int time = 0;\\n        queue<pair<int, int>> q;\\n        unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i < manager.size(); i++)\\n        {\\n            mp[manager[i]].push_back(i);\\n        }\\n        \\n        q.push({headID, 0});\\n        \\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                pair<int, int> p = q.front();\\n                q.pop();\\n                int e = p.first, t = p.second;\\n                t += informTime[e];\\n                \\n                if(mp.find(e) != mp.end() && mp[e].size() > 0)\\n                {\\n                    for(int i = 0; i < mp[e].size(); i++)\\n                        q.push({mp[e][i], t});\\n                }\\n                else\\n                    time = max(time, t);\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```\\n\\nTime : `O(n)`\\nSpace : `O(n)`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        int time = 0;\\n        queue<pair<int, int>> q;\\n        unordered_map<int, vector<int>> mp;\\n        for(int i = 0; i < manager.size(); i++)\\n        {\\n            mp[manager[i]].push_back(i);\\n        }\\n        \\n        q.push({headID, 0});\\n        \\n        while(!q.empty())\\n        {\\n            int s = q.size();\\n            while(s--)\\n            {\\n                pair<int, int> p = q.front();\\n                q.pop();\\n                int e = p.first, t = p.second;\\n                t += informTime[e];\\n                \\n                if(mp.find(e) != mp.end() && mp[e].size() > 0)\\n                {\\n                    for(int i = 0; i < mp[e].size(); i++)\\n                        q.push({mp[e][i], t});\\n                }\\n                else\\n                    time = max(time, t);\\n            }\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532498,
                "title": "c-dfs",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        int ans(0);\\n        vector<vector<int>> relations(n);\\n        \\n        for (int i = 0; i < n; ++i)\\n            if (manager[i] != -1)\\n                relations[manager[i]].push_back(i);\\n        \\n        function<void(int, int)> dfs = [&](int id, int t){\\n            for (const int& e: relations[id])\\n                dfs(e, t + informTime[id]);\\n            ans = max(ans, t);\\n        };\\n        \\n        dfs(headID, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        int ans(0);\\n        vector<vector<int>> relations(n);\\n        \\n        for (int i = 0; i < n; ++i)\\n            if (manager[i] != -1)\\n                relations[manager[i]].push_back(i);\\n        \\n        function<void(int, int)> dfs = [&](int id, int t){\\n            for (const int& e: relations[id])\\n                dfs(e, t + informTime[id]);\\n            ans = max(ans, t);\\n        };\\n        \\n        dfs(headID, 0);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593289,
                "title": "c-solution-using-bfs",
                "content": "# Complexity\\n- Time complexity:\\nO(n + edges)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        //make a directed graph between the nodes and their subordinate nodes\\n        vector<int> adj[n];\\n\\n        for(int i=0; i<n; i++){\\n            if(manager[i] != -1){\\n                adj[manager[i]].push_back(i);\\n            }\\n        }\\n\\n        vector<int> visited(n, 0);\\n        visited[headID] = 1;\\n\\n        queue<pair<int, int>> q;\\n        q.push({headID, 0});\\n\\n        int maxTime = INT_MIN;\\n        while(!q.empty()){\\n            int node = q.front().first;\\n            int time = q.front().second;\\n            q.pop(); \\n\\n            for(auto neighbour: adj[node]){\\n                if(!visited[neighbour]){\\n                    visited[neighbour] = 1;\\n                    q.push({neighbour, time + informTime[node]});\\n\\n                    maxTime = max(maxTime, time + informTime[node]);\\n                }\\n            }\\n        }\\n\\n        if(maxTime == INT_MIN) return 0;\\n        return maxTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        //make a directed graph between the nodes and their subordinate nodes\\n        vector<int> adj[n];\\n\\n        for(int i=0; i<n; i++){\\n            if(manager[i] != -1){\\n                adj[manager[i]].push_back(i);\\n            }\\n        }\\n\\n        vector<int> visited(n, 0);\\n        visited[headID] = 1;\\n\\n        queue<pair<int, int>> q;\\n        q.push({headID, 0});\\n\\n        int maxTime = INT_MIN;\\n        while(!q.empty()){\\n            int node = q.front().first;\\n            int time = q.front().second;\\n            q.pop(); \\n\\n            for(auto neighbour: adj[node]){\\n                if(!visited[neighbour]){\\n                    visited[neighbour] = 1;\\n                    q.push({neighbour, time + informTime[node]});\\n\\n                    maxTime = max(maxTime, time + informTime[node]);\\n                }\\n            }\\n        }\\n\\n        if(maxTime == INT_MIN) return 0;\\n        return maxTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593063,
                "title": "easy-5-line-solution-without-bfs-dfs-memory-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            int find = i, time = 0;\\n            while(find != -1){\\n                time += informTime[find];\\n                find = manager[find];\\n            }\\n            ans = max(ans, time);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        \\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            int find = i, time = 0;\\n            while(find != -1){\\n                time += informTime[find];\\n                find = manager[find];\\n            }\\n            ans = max(ans, time);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592913,
                "title": "c-solution-using-dfs-depth-first-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTime = INT_MIN;\\n    \\n    void dfs(vector<int> adjList[], vector<int>& informTime, int curr, int time) {\\n        \\n        maxTime = max(maxTime, time);\\n        \\n        for (int adjacent : adjList[curr]) { \\n        \\n            dfs(adjList, informTime, adjacent, time + informTime[curr]);\\n        }\\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int> adjList[n];\\n        \\n    \\n        for (int i = 0; i < n; i++) {\\n            if (manager[i] != -1) {\\n                adjList[manager[i]].push_back(i);\\n            }\\n        }\\n        \\n        dfs(adjList, informTime, headID, 0);\\n        return maxTime;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTime = INT_MIN;\\n    \\n    void dfs(vector<int> adjList[], vector<int>& informTime, int curr, int time) {\\n        \\n        maxTime = max(maxTime, time);\\n        \\n        for (int adjacent : adjList[curr]) { \\n        \\n            dfs(adjList, informTime, adjacent, time + informTime[curr]);\\n        }\\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int> adjList[n];\\n        \\n    \\n        for (int i = 0; i < n; i++) {\\n            if (manager[i] != -1) {\\n                adjList[manager[i]].push_back(i);\\n            }\\n        }\\n        \\n        dfs(adjList, informTime, headID, 0);\\n        return maxTime;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592466,
                "title": "easy-begineer-friendly-solution-bfs-c-understanding-with-comments-and-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIs to see which index is connected with which index.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck go through neighbours and see infromTime[i] at any index i and add it up and maximize it to give ans.\\n\\n\\nFEEL FREE TO COMMENT AND KEEP HEALTHY DISCUSSION LETS HELP EACH OTHER.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        \\n        //Creating adjacency list \\n        vector<int>adj[n];\\n\\n        for(int i=0;i<manager.size();i++){\\n            if(manager[i] != -1){\\n                //as per the question manager[i] is the manager of any index i\\n                adj[manager[i]].push_back(i);\\n            }\\n        }\\n\\n        //here keeping headId in queue as it is boss of company so everthing will start from it\\n        queue<pair<int,int>>q;\\n        q.push({headID,0});\\n\\n        vector<bool>vis(n,false);\\n        vis[headID]=true;\\n\\n        int time=0,ans=0;\\n        while(!q.empty()){\\n            //manger will be our new manager and it will take infromTime[manger]\\n            //to inform its employee under him\\n            int manager=q.front().first;\\n            time=q.front().second;\\n            //taking maximum as our answer\\n            ans=max(ans,time);\\n            q.pop();\\n            //Going through all neighbours\\n            for(auto &neigh:adj[manager]){\\n                if(vis[neigh] == false){\\n                    vis[neigh]=true;\\n                    //Updating time with informTime[manager]\\n                    q.push({neigh,time+informTime[manager]});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        \\n        //Creating adjacency list \\n        vector<int>adj[n];\\n\\n        for(int i=0;i<manager.size();i++){\\n            if(manager[i] != -1){\\n                //as per the question manager[i] is the manager of any index i\\n                adj[manager[i]].push_back(i);\\n            }\\n        }\\n\\n        //here keeping headId in queue as it is boss of company so everthing will start from it\\n        queue<pair<int,int>>q;\\n        q.push({headID,0});\\n\\n        vector<bool>vis(n,false);\\n        vis[headID]=true;\\n\\n        int time=0,ans=0;\\n        while(!q.empty()){\\n            //manger will be our new manager and it will take infromTime[manger]\\n            //to inform its employee under him\\n            int manager=q.front().first;\\n            time=q.front().second;\\n            //taking maximum as our answer\\n            ans=max(ans,time);\\n            q.pop();\\n            //Going through all neighbours\\n            for(auto &neigh:adj[manager]){\\n                if(vis[neigh] == false){\\n                    vis[neigh]=true;\\n                    //Updating time with informTime[manager]\\n                    q.push({neigh,time+informTime[manager]});\\n                }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591852,
                "title": "video-directed-graph-dfs-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI recommend attempting the problem for 25 minutes before reviewing the solution.\\nYou can approach this problem using either Breadth-First Search (BFS) or Depth-First Search (DFS) algorithms and the graph is directed.\\n\\n\\nhttps://youtu.be/Y3AlvhSVXOA\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The `dfs` function is a helper function that performs a depth-first search (DFS) traversal on the graph represented by the adjacency list `adj`. It takes the current vertex `n`, the adjacency list, a boolean array `vis` to track visited vertices, and an array `informTime` that contains the time it takes for each employee to inform their subordinates.\\n\\n2. Within the `dfs` function, an integer `ans` is initialized to 0, representing the accumulated time taken for information dissemination from the current vertex.\\n\\n3. The function iterates over the adjacent vertices of the current vertex `n` using a range-based for loop. For each adjacent vertex `i`, it recursively calls `dfs` and updates `ans` with the maximum time taken considering the information dissemination time of the current employee (`informTime[n]`) and the time taken by their subordinates.\\n\\n4. The `numOfMinutes` function is the entry point of the solution. It takes the total number of employees `n`, the ID of the head employee `headID`, an array `manager` representing the immediate manager of each employee, and an array `informTime` containing the time taken for each employee to inform their subordinates.\\n\\n5. Within the `numOfMinutes` function, an adjacency list `adj` is created. For each employee (represented by index `i`), if they have a manager (indicated by `manager[i] != -1`), an edge is added to the adjacency list with the manager as the source vertex and the employee as the destination vertex, along with the time taken (`informTime[i]`).\\n\\n6. A boolean array `vis` is initialized to track visited vertices, with all values set to `false`.\\n\\n7. The function calls the `dfs` function with the head employee ID (`headID`), the adjacency list `adj`, the `vis` array, and the `informTime` array.\\n\\n8. The result of the DFS traversal, representing the maximum time taken for complete information dissemination, is stored in the variable `ans`.\\n\\n9. The function returns the value of `ans`.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution depends on the size of the input graph and the DFS traversal. Assuming m as the total number of edges in the graph, the time complexity can be considered as O(n + m) because each vertex and edge are visited once during the DFS traversal.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this solution is O(n) because additional space is used to store the adjacency list (adj), the boolean array (vis), and the recursive call stack for DFS.    \\n\\n```C++ []\\nclass Solution {\\npublic:\\n    int dfs(int n,vector<pair<int,int>>adj[],vector<bool>&vis,vector<int>& informTime)\\n    {\\n        int ans=0;\\n        for(auto i:adj[n])\\n        {\\n            ans=max(ans,informTime[n]+dfs(i.first,adj,vis,informTime));\\n        }\\n        return ans;\\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<pair<int,int>>adj[n];\\n        for(int i=0;i<n;i++)\\n        {   \\n            if(manager[i]!=-1)\\n                adj[manager[i]].push_back({i,informTime[i]});\\n        }\\n        vector<bool>vis(n,0);\\n        int ans=dfs(headID,adj,vis,informTime);\\n        return ans;\\n    }\\n};\\n```\\n```python []\\nfrom typing import List\\n\\nclass Solution:\\n    def dfs(self, n: int, adj: List[List[int]], vis: List[bool], informTime: List[int]) -> int:\\n        ans = 0\\n        for i, time in adj[n]:\\n            ans = max(ans, informTime[n] + self.dfs(i, adj, vis, informTime))\\n        return ans\\n\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for i in range(n):\\n            if manager[i] != -1:\\n                adj[manager[i]].append((i, informTime[i]))\\n        vis = [False] * n\\n        ans = self.dfs(headID, adj, vis, informTime)\\n        return ans\\n\\n```\\n```JAVA []\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public int dfs(int n, List<Pair<Integer, Integer>>[] adj, boolean[] vis, int[] informTime) {\\n        int ans = 0;\\n        for (Pair<Integer, Integer> i : adj[n]) {\\n            ans = Math.max(ans, informTime[n] + dfs(i.getKey(), adj, vis, informTime));\\n        }\\n        return ans;\\n    }\\n\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        List<Pair<Integer, Integer>>[] adj = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (manager[i] != -1) {\\n                adj[manager[i]].add(new Pair<>(i, informTime[i]));\\n            }\\n        }\\n        boolean[] vis = new boolean[n];\\n        int ans = dfs(headID, adj, vis, informTime);\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int dfs(int n,vector<pair<int,int>>adj[],vector<bool>&vis,vector<int>& informTime)\\n    {\\n        int ans=0;\\n        for(auto i:adj[n])\\n        {\\n            ans=max(ans,informTime[n]+dfs(i.first,adj,vis,informTime));\\n        }\\n        return ans;\\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<pair<int,int>>adj[n];\\n        for(int i=0;i<n;i++)\\n        {   \\n            if(manager[i]!=-1)\\n                adj[manager[i]].push_back({i,informTime[i]});\\n        }\\n        vector<bool>vis(n,0);\\n        int ans=dfs(headID,adj,vis,informTime);\\n        return ans;\\n    }\\n};\\n```\n```python []\\nfrom typing import List\\n\\nclass Solution:\\n    def dfs(self, n: int, adj: List[List[int]], vis: List[bool], informTime: List[int]) -> int:\\n        ans = 0\\n        for i, time in adj[n]:\\n            ans = max(ans, informTime[n] + self.dfs(i, adj, vis, informTime))\\n        return ans\\n\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        adj = [[] for _ in range(n)]\\n        for i in range(n):\\n            if manager[i] != -1:\\n                adj[manager[i]].append((i, informTime[i]))\\n        vis = [False] * n\\n        ans = self.dfs(headID, adj, vis, informTime)\\n        return ans\\n\\n```\n```JAVA []\\nimport java.util.ArrayList;\\nimport java.util.List;\\n\\nclass Solution {\\n    public int dfs(int n, List<Pair<Integer, Integer>>[] adj, boolean[] vis, int[] informTime) {\\n        int ans = 0;\\n        for (Pair<Integer, Integer> i : adj[n]) {\\n            ans = Math.max(ans, informTime[n] + dfs(i.getKey(), adj, vis, informTime));\\n        }\\n        return ans;\\n    }\\n\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        List<Pair<Integer, Integer>>[] adj = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            adj[i] = new ArrayList<>();\\n        }\\n        for (int i = 0; i < n; i++) {\\n            if (manager[i] != -1) {\\n                adj[manager[i]].add(new Pair<>(i, informTime[i]));\\n            }\\n        }\\n        boolean[] vis = new boolean[n];\\n        int ans = dfs(headID, adj, vis, informTime);\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591783,
                "title": "dfs-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvoid solve(int s,int &ans,int sum,vector<int> &v,vector<vector<int>> &g){\\n    sum += v[s];\\n    ans = max(ans,sum);\\n    for(auto &i: g[s]){\\n        solve(i,ans,sum,v,g);\\n    }\\n}\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& v) {\\n        vector<vector<int>> g(n);\\n        int i;\\n        for(i = 0; i < n; i++){\\n            if(manager[i] != -1){\\n                g[manager[i]].push_back(i);\\n            }\\n        }\\n        int ans = 0;\\n        solve(headID,ans,0,v,g);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid solve(int s,int &ans,int sum,vector<int> &v,vector<vector<int>> &g){\\n    sum += v[s];\\n    ans = max(ans,sum);\\n    for(auto &i: g[s]){\\n        solve(i,ans,sum,v,g);\\n    }\\n}\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& v) {\\n        vector<vector<int>> g(n);\\n        int i;\\n        for(i = 0; i < n; i++){\\n            if(manager[i] != -1){\\n                g[manager[i]].push_back(i);\\n            }\\n        }\\n        int ans = 0;\\n        solve(headID,ans,0,v,g);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591739,
                "title": "easy-dfs-solution-c-best-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint dfs(vector<int> adj[], vector<int> &vis, int h, vector<int> &t)\\n{\\n    vis[h] = 1;\\n    int maxt=0;\\n    for(auto it:adj[h])\\n    {\\n        if(!vis[it])\\n        {\\n            maxt = max(maxt,dfs(adj,vis,it,t));\\n        }\\n    }\\n    return maxt+t[h];\\n}\\n\\n    int numOfMinutes(int n, int h, vector<int>& m, vector<int>& t) {\\n      vector<int> adj[n];\\n      vector<int> vis(n,0);\\n      for(int i=0;i<n;i++)\\n      {\\n          if(m[i] != -1)\\n          adj[m[i]].push_back(i);\\n      }  \\n      return dfs(adj,vis,h,t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint dfs(vector<int> adj[], vector<int> &vis, int h, vector<int> &t)\\n{\\n    vis[h] = 1;\\n    int maxt=0;\\n    for(auto it:adj[h])\\n    {\\n        if(!vis[it])\\n        {\\n            maxt = max(maxt,dfs(adj,vis,it,t));\\n        }\\n    }\\n    return maxt+t[h];\\n}\\n\\n    int numOfMinutes(int n, int h, vector<int>& m, vector<int>& t) {\\n      vector<int> adj[n];\\n      vector<int> vis(n,0);\\n      for(int i=0;i<n;i++)\\n      {\\n          if(m[i] != -1)\\n          adj[m[i]].push_back(i);\\n      }  \\n      return dfs(adj,vis,h,t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591191,
                "title": "c-solution-breadth-first-search-graph-explained-solution",
                "content": "# Intuition\\nAs the structure of manager-subordinates represent a tree so BFS or DFS can be applied.\\n\\n# Approach\\nWe\\'ll start a Breadth-first-search from the headID and we\\'ll maintain two variables in the queue:- Current Node and Current Time (Time needed to convey message till that currentnode). We\\'ll maintain an ans variable which will contain the final answer and we\\'ll update ans to max(ans, currenttime) whenever we pop out of the queue. The answer variable will contain the maximum of all current times we have encountered in our BFS.\\n\\n# Complexity\\n- Time complexity:\\nO(N) to traverse all nodes in the graph\\n\\n- Space complexity:\\nO(N) + O(N) \\n(For Graph formed + queue space(in worst case it can reach till O(N)))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>>graph(n);\\n        for(int i = 0;i < n; i++)\\n        {\\n            if(manager[i] != -1)\\n            {\\n                graph[manager[i]].push_back(i);\\n            }\\n        }\\n        return solvebfs(n, headID, graph, informTime);\\n    }\\n\\n    int solvebfs(int& n, int& root, vector<vector<int>>& graph, vector<int>& informtime)\\n    {\\n        int ans = INT_MIN;\\n        queue<pair<int,int>>q; // currentnode and currenttime\\n        q.push({root,0});\\n        while(!q.empty())\\n        {\\n            int currentnode = q.front().first;\\n            int currenttime = q.front().second;\\n            q.pop();\\n            ans = max(ans, currenttime);\\n            for(int i = 0;i < graph[currentnode].size(); i++)\\n            {\\n                q.push({graph[currentnode][i], currenttime+informtime[currentnode]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Do upvote if you found it helpful\\uD83D\\uDE00**",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>>graph(n);\\n        for(int i = 0;i < n; i++)\\n        {\\n            if(manager[i] != -1)\\n            {\\n                graph[manager[i]].push_back(i);\\n            }\\n        }\\n        return solvebfs(n, headID, graph, informTime);\\n    }\\n\\n    int solvebfs(int& n, int& root, vector<vector<int>>& graph, vector<int>& informtime)\\n    {\\n        int ans = INT_MIN;\\n        queue<pair<int,int>>q; // currentnode and currenttime\\n        q.push({root,0});\\n        while(!q.empty())\\n        {\\n            int currentnode = q.front().first;\\n            int currenttime = q.front().second;\\n            q.pop();\\n            ans = max(ans, currenttime);\\n            for(int i = 0;i < graph[currentnode].size(); i++)\\n            {\\n                q.push({graph[currentnode][i], currenttime+informtime[currentnode]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591057,
                "title": "easy-c-dfs-solution-with-video-explanation-tracing-all-paths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses a technique called Depth-First Search (DFS) to find the maximum time needed to inform all employees.\\n\\n[Please turn on English subtitles if necessary] \\n[https://youtu.be/kVr-59Qg9Nk](https://youtu.be/kVr-59Qg9Nk)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)\\n\\n\\nFirst, the adj_ini function initializes the adjacency list, which represents the relationships between employees and their direct reports. It creates the appropriate connections in the adjacency list based on the given manager list( in fact parent node list).\\n\\nThe dfs function performs a DFS traversal starting from the headheadID. It keeps track of the maximum time (timeNeed) needed to inform all employees.\\n\\nInside the dfs function, for each direct report of the current employee, it recursively calls the dfs function, passing the updated time by adding the time (informTime[i]) it takes for the current employee to inform their subordinates( i.e. children).\\n\\nDuring the DFS traversal, the timeNeed variable is updated to store the maximum time needed among all the paths.\\n\\nFinally, the numOfMinutes function calls the adj_ini function to initialize the adjacency list, and then it calls the dfs function to perform the DFS traversal starting from the headID (tree node). It returns the timeNeed!\\n\\nFor test case \\n```\\n22\\n7\\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n```\\nTrace the computations for every path:\\n```\\n[7->1:486][1->17:1026] pathTime=1026\\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\\n[14->12:7655][12->0:8308] pathTime=8308\\n[12->6:8308][6->8:9132] pathTime=9132\\n[11->16:5894] pathTime=5894\\n[13->15:5692] pathTime=5692\\n\\ntimeNeed=9132\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code Runtime 289 ms Beats 87.48%\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n\\n    void adj_ini(int n, vector<int>& manager){\\n        adj.resize(n);\\n        for(int i = 0; i < n; i++){\\n            int x = manager[i];\\n            if (x != -1)\\n                adj[x].push_back(i);\\n        }\\n    }\\n\\n    int timeNeed = 0;\\n\\n    void dfs(int i, int time, vector<int>& informTime){\\n        timeNeed = max(timeNeed, time); // Update the maximum time needed\\n        for(auto v: adj[i])\\n            dfs(v, time + informTime[i], informTime);\\n    }\\n\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime){\\n        adj_ini(n, manager);\\n        dfs(headID, 0, informTime);\\n        return timeNeed;\\n    }\\n};\\n\\n```\\n# Code with Explanation in Comments\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj; \\n// Adjacency list to represent the organizational hierarchy\\n\\n    // Function to initialize the adjacency list\\n    void adj_ini(int n, vector<int>& manager){\\n        adj.resize(n); \\n// Resize the adjacency list to accommodate \\'n\\' vertices\\n\\n        for(int i = 0; i < n; i++){\\n            int x = manager[i];//manager \\'x\\' is the parent node\\n            if (x != -1) //i!=headID is special\\n                adj[x].push_back(i); \\n// Add \\'i\\' as a direct report of manager \\'x\\'\\n        }\\n    }\\n\\n    int timeNeed = 0; // Variable to store the maximum time needed to inform all employees\\n\\n    // Depth-First Search (DFS) to calculate the maximum time needed\\n    void dfs(int i, int time, vector<int>& informTime){\\n        timeNeed = max(timeNeed, time); // Update the maximum time needed\\n        for(auto v: adj[i])\\n            dfs(v, time + informTime[i], informTime); // Recursive call for each direct report of employee \\'i\\'\\n    }\\n\\n    // Function to calculate the total time needed to inform all employees\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime){\\n        adj_ini(n, manager); // Initialize the adjacency list\\n        dfs(headID, 0, informTime); \\n// Perform DFS starting from the headID (tree root)\\n\\n        return timeNeed; // Return the maximum time needed\\n    }\\n};\\n\\n```\\n# Replace the dfs by dfs with tracing will give the tracing info\\n\\n```\\nvoid dfs(int i, int time, vector<int>& informTime){//dfs with tracing \\n        timeNeed = max(timeNeed, time); // Update the maximum time needed\\n        for(int v: adj[i]){\\n            int vtime=time + informTime[i];\\n            cout<<\"[\"<<i<<\"->\"<<v<<\":\"<<vtime<<\"]\";\\n            if (adj[v].size()==0) //Whether the node is a leaf \\n              cout<<\" pathTime=\"<<vtime<<endl;\\n            dfs(v, vtime, informTime);\\n        }         \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n22\\n7\\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n```\n```\\n[7->1:486][1->17:1026] pathTime=1026\\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\\n[14->12:7655][12->0:8308] pathTime=8308\\n[12->6:8308][6->8:9132] pathTime=9132\\n[11->16:5894] pathTime=5894\\n[13->15:5692] pathTime=5692\\n\\ntimeNeed=9132\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n\\n    void adj_ini(int n, vector<int>& manager){\\n        adj.resize(n);\\n        for(int i = 0; i < n; i++){\\n            int x = manager[i];\\n            if (x != -1)\\n                adj[x].push_back(i);\\n        }\\n    }\\n\\n    int timeNeed = 0;\\n\\n    void dfs(int i, int time, vector<int>& informTime){\\n        timeNeed = max(timeNeed, time); // Update the maximum time needed\\n        for(auto v: adj[i])\\n            dfs(v, time + informTime[i], informTime);\\n    }\\n\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime){\\n        adj_ini(n, manager);\\n        dfs(headID, 0, informTime);\\n        return timeNeed;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj; \\n// Adjacency list to represent the organizational hierarchy\\n\\n    // Function to initialize the adjacency list\\n    void adj_ini(int n, vector<int>& manager){\\n        adj.resize(n); \\n// Resize the adjacency list to accommodate \\'n\\' vertices\\n\\n        for(int i = 0; i < n; i++){\\n            int x = manager[i];//manager \\'x\\' is the parent node\\n            if (x != -1) //i!=headID is special\\n                adj[x].push_back(i); \\n// Add \\'i\\' as a direct report of manager \\'x\\'\\n        }\\n    }\\n\\n    int timeNeed = 0; // Variable to store the maximum time needed to inform all employees\\n\\n    // Depth-First Search (DFS) to calculate the maximum time needed\\n    void dfs(int i, int time, vector<int>& informTime){\\n        timeNeed = max(timeNeed, time); // Update the maximum time needed\\n        for(auto v: adj[i])\\n            dfs(v, time + informTime[i], informTime); // Recursive call for each direct report of employee \\'i\\'\\n    }\\n\\n    // Function to calculate the total time needed to inform all employees\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime){\\n        adj_ini(n, manager); // Initialize the adjacency list\\n        dfs(headID, 0, informTime); \\n// Perform DFS starting from the headID (tree root)\\n\\n        return timeNeed; // Return the maximum time needed\\n    }\\n};\\n\\n```\n```\\nvoid dfs(int i, int time, vector<int>& informTime){//dfs with tracing \\n        timeNeed = max(timeNeed, time); // Update the maximum time needed\\n        for(int v: adj[i]){\\n            int vtime=time + informTime[i];\\n            cout<<\"[\"<<i<<\"->\"<<v<<\":\"<<vtime<<\"]\";\\n            if (adj[v].size()==0) //Whether the node is a leaf \\n              cout<<\" pathTime=\"<<vtime<<endl;\\n            dfs(v, vtime, informTime);\\n        }         \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3591040,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> g[100005];\\n    int vis[100005], dis[100005];\\n    void bfs(int s, vector<int>& informTime) \\n    {\\n        queue<int> q;\\n        vis[s] = 1;\\n        dis[s] = 0;\\n        q.push(s);\\n        while(!q.empty()) \\n        {\\n            int u = q.front();\\n            q.pop();\\n            for(auto v: g[u]) \\n            {\\n                if(!vis[v])\\n                 {\\n                    vis[v] = 1;\\n                    dis[v] = dis[u] + informTime[u];\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) \\n    {\\n        memset(vis, 0, sizeof(vis));\\n        memset(dis, 0, sizeof(dis));\\n        for(int i=0; i<n; i++) \\n        {\\n            if(manager[i] != -1) g[manager[i]].push_back(i);\\n        }\\n        bfs(headID, informTime);\\n        int ans = 0;\\n        for(int i=0; i<n; i++) ans = max(ans, dis[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> g[100005];\\n    int vis[100005], dis[100005];\\n    void bfs(int s, vector<int>& informTime) \\n    {\\n        queue<int> q;\\n        vis[s] = 1;\\n        dis[s] = 0;\\n        q.push(s);\\n        while(!q.empty()) \\n        {\\n            int u = q.front();\\n            q.pop();\\n            for(auto v: g[u]) \\n            {\\n                if(!vis[v])\\n                 {\\n                    vis[v] = 1;\\n                    dis[v] = dis[u] + informTime[u];\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) \\n    {\\n        memset(vis, 0, sizeof(vis));\\n        memset(dis, 0, sizeof(dis));\\n        for(int i=0; i<n; i++) \\n        {\\n            if(manager[i] != -1) g[manager[i]].push_back(i);\\n        }\\n        bfs(headID, informTime);\\n        int ans = 0;\\n        for(int i=0; i<n; i++) ans = max(ans, dis[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846662,
                "title": "c-dfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int headID, vector<int>& informTime, int ans, int& maxi, unordered_map<int, vector<int>>& adj){\\n\\t\\t\\tmaxi=max(maxi, ans);\\n\\t\\t\\tfor(auto it: adj[headID]){\\n\\t\\t\\t\\tans+=informTime[headID];\\n\\t\\t\\t\\tdfs(it, informTime, ans, maxi, adj);\\n\\t\\t\\t\\tans-=informTime[headID];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tint numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n\\t\\t\\tunordered_map<int, vector<int>>adj;\\n\\t\\t\\tint ans=0, maxi=0;\\n\\t\\t\\tfor(int i=0; i<manager.size(); i++){\\n\\t\\t\\t\\tif(manager[i]!=-1){\\n\\t\\t\\t\\t\\tadj[manager[i]].push_back(i);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tdfs(headID, informTime, ans, maxi, adj);\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int headID, vector<int>& informTime, int ans, int& maxi, unordered_map<int, vector<int>>& adj){\\n\\t\\t\\tmaxi=max(maxi, ans);\\n\\t\\t\\tfor(auto it: adj[headID]){\\n\\t\\t\\t\\tans+=informTime[headID];\\n\\t\\t\\t\\tdfs(it, informTime, ans, maxi, adj);\\n\\t\\t\\t\\tans-=informTime[headID];\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2728167,
                "title": "easy-python-solution-using-bfs",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        visited=[-1]*n\\n        queue=[[0,headID]]\\n        heapq.heapify(queue)\\n        adj=[[] for i in range(n)]\\n        for i in range(n):\\n            if manager[i]!=-1:\\n                adj[manager[i]].append(i)\\n        time=[float(\"infinity\")]*n\\n        time[headID]=0\\n        while queue:\\n            t,x=heapq.heappop(queue)\\n            for i in range(len(adj[x])):\\n                if t+informTime[x]<time[adj[x][i]]:\\n                    heapq.heappush(queue,[t+informTime[x],adj[x][i]])\\n                    time[adj[x][i]]=t+informTime[x]\\n        return max(time)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        visited=[-1]*n\\n        queue=[[0,headID]]\\n        heapq.heapify(queue)\\n        adj=[[] for i in range(n)]\\n        for i in range(n):\\n            if manager[i]!=-1:\\n                adj[manager[i]].append(i)\\n        time=[float(\"infinity\")]*n\\n        time[headID]=0\\n        while queue:\\n            t,x=heapq.heappop(queue)\\n            for i in range(len(adj[x])):\\n                if t+informTime[x]<time[adj[x][i]]:\\n                    heapq.heappush(queue,[t+informTime[x],adj[x][i]])\\n                    time[adj[x][i]]=t+informTime[x]\\n        return max(time)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555509,
                "title": "c-fast-clean-iterative-dfs",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    // Run-time: O(n) (each vertex visited only once)\\n\\t//\\n    // Memory: O(n) (at most n items in stack; this also applies to recursive DFS solutions \\n\\t// except they also have stack frames stored on the stack)\\n\\t//\\n    // Beats 97% for run-time and 90% for memory usage.\\n    int numOfMinutes(const int n, const int headID, \\n                     vector<int>& managers, vector<int>& informTime) {\\n        \\n        // This DFS stores a pair of (employee, subordinate).\\n        std::stack<std::pair<int, int>> s;\\n        \\n        auto total_time = 0;\\n        \\n        for (auto i = 0; i < n; ++i) {\\n            // We use the managers array as a \"visited\" array. \\n\\t\\t\\t// (-1) indicates that we have already visited.\\n            // We could also use a vector of our own or an unordered_set \\n\\t\\t\\t// to preserve the input, at the cost of extra memory and a slower program.\\n            if (managers[i] < 0) {\\n                continue;\\n            }\\n            \\n            s.push({i, -1});\\n            \\n            // We visit in depth-first order, getting to the highest-level manager who has\\n            // a correct inform time. Once we do, we add the inform time in reverse order using\\n            // the stack until we reach the employee we started with.\\n            while (!s.empty()) {\\n                const auto [employee, _] = s.top();\\n                const auto manager = managers[employee];\\n                \\n                if (manager != -1) {\\n                    s.push({manager, employee});\\n                    continue;\\n                }\\n                \\n                while (true) {\\n                    const auto [employee, subordinate] = s.top();\\n                    s.pop();\\n                    // Mark as visited using managers array\\n                    managers[employee] = -1;\\n                    // If this is the bottom level, we should break since there are\\n                    // no more subordinates.\\n                    if (s.empty()) {\\n                        break;\\n                    }\\n                    // Otherwise, add this employee\\'s adjusted inform time to their\\n                    // subordinate.\\n                    informTime[subordinate] += informTime[employee];\\n                }\\n            }\\n            \\n            // Update the total time using the bottom-level employee we start with.\\n            total_time = max(informTime[i], total_time);\\n        }\\n        \\n        return total_time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Run-time: O(n) (each vertex visited only once)\\n\\t//\\n    // Memory: O(n) (at most n items in stack; this also applies to recursive DFS solutions \\n\\t// except they also have stack frames stored on the stack)\\n\\t//\\n    // Beats 97% for run-time and 90% for memory usage.\\n    int numOfMinutes(const int n, const int headID, \\n                     vector<int>& managers, vector<int>& informTime) {\\n        \\n        // This DFS stores a pair of (employee, subordinate).\\n        std::stack<std::pair<int, int>> s;\\n        \\n        auto total_time = 0;\\n        \\n        for (auto i = 0; i < n; ++i) {\\n            // We use the managers array as a \"visited\" array. \\n\\t\\t\\t// (-1) indicates that we have already visited.\\n            // We could also use a vector of our own or an unordered_set \\n\\t\\t\\t// to preserve the input, at the cost of extra memory and a slower program.\\n            if (managers[i] < 0) {\\n                continue;\\n            }\\n            \\n            s.push({i, -1});\\n            \\n            // We visit in depth-first order, getting to the highest-level manager who has\\n            // a correct inform time. Once we do, we add the inform time in reverse order using\\n            // the stack until we reach the employee we started with.\\n            while (!s.empty()) {\\n                const auto [employee, _] = s.top();\\n                const auto manager = managers[employee];\\n                \\n                if (manager != -1) {\\n                    s.push({manager, employee});\\n                    continue;\\n                }\\n                \\n                while (true) {\\n                    const auto [employee, subordinate] = s.top();\\n                    s.pop();\\n                    // Mark as visited using managers array\\n                    managers[employee] = -1;\\n                    // If this is the bottom level, we should break since there are\\n                    // no more subordinates.\\n                    if (s.empty()) {\\n                        break;\\n                    }\\n                    // Otherwise, add this employee\\'s adjusted inform time to their\\n                    // subordinate.\\n                    informTime[subordinate] += informTime[employee];\\n                }\\n            }\\n            \\n            // Update the total time using the bottom-level employee we start with.\\n            total_time = max(informTime[i], total_time);\\n        }\\n        \\n        return total_time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2424340,
                "title": "just-one-trick-explained-bfs-with-diagram",
                "content": "\\n\\nin the queue we will be pushing the id of the employee under a\\nmanager at a particluar level, and the total time the info has taken \\nto reach him/her.\\n\\nwhile calculating the duration for each employee, we will compare it with \\nmaximum time , becuase for eg:\\n\\nn=11\\nheadID=4\\nmanager =[5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime =[0,213,0,253,686,170,975,0,261,309,337]\\n\\nhere if you will see that the total time  taken \\nto reach at 2nd ID is 2560 minutes \\nand for 5th ID is 1846.\\n\\nthereofre , our answer will be 2560 , not 2730\\nbeacuse the information from 5->0 would have already \\nreached to 0th ID before the 2nd ID , therefore no need to add 170\\n\\nwrong:   686+337+253+309+975+170 = 2730\\ncorrect: 686+337+253+309+975 = 2560\\n![image](https://assets.leetcode.com/users/images/4714fa3d-22c8-4fc4-8137-02ca79ec6da1_1660478086.1728394.jpeg)\\n\\ntherepfore we will be maintaing  the maxTime which will \\nbe our answer , and in the queue we will store \\nthe ID  & the time it has taken for the info to reach this ID.\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime){\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++){\\n            int ceo=manager[i];\\n            if(ceo!=-1)\\n                adj[ceo].push_back(i);\\n        }\\n        \\n        queue<pair<int,int>> q;\\n        int maxi=0;\\n        q.push({headID,0});\\n        \\n        while(!q.empty()){\\n            \\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                \\n                int head=q.front().first;\\n                int timeTaken=q.front().second;\\n                q.pop();\\n                int dur=informTime[head]+timeTaken;\\n                maxi=max(maxi,dur);\\n                for(auto it:adj[head]) {\\n                    q.push({it,dur});\\n                }  \\n            } \\n        }\\n       return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime){\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++){\\n            int ceo=manager[i];\\n            if(ceo!=-1)\\n                adj[ceo].push_back(i);\\n        }\\n        \\n        queue<pair<int,int>> q;\\n        int maxi=0;\\n        q.push({headID,0});\\n        \\n        while(!q.empty()){\\n            \\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                \\n                int head=q.front().first;\\n                int timeTaken=q.front().second;\\n                q.pop();\\n                int dur=informTime[head]+timeTaken;\\n                maxi=max(maxi,dur);\\n                for(auto it:adj[head]) {\\n                    q.push({it,dur});\\n                }  \\n            } \\n        }\\n       return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2335827,
                "title": "java-solution-with-2-approach-dfs-bfs",
                "content": "DFS solution\\n```\\nclass Solution {\\n    int max;\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        if(n == 1)\\n            return 0;\\n        int[] time = new int[n];\\n        List<List<Integer>> edge = new ArrayList<>();\\n        for(int i = 0;i < n;i++)\\n            edge.add(new ArrayList<>());\\n        for(int i = 0;i < n;i++){\\n            if(manager[i] != -1)\\n                edge.get(manager[i]).add(i);\\n        }\\n        max = 0;\\n        dfs(edge, headID, informTime, 0);\\n        return max;\\n    }\\n    public void dfs(List<List<Integer>> edge, int curr, int[] inform, int time){\\n        int informNext = time + inform[curr];\\n        max = Math.max(informNext, max);\\n        for(int nei : edge.get(curr))\\n            dfs(edge, nei, inform, informNext);\\n    }\\n}\\n```\\nBFS solution\\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        if(n == 1)\\n            return 0;\\n        int[] time = new int[n];\\n        List<List<Integer>> edge = new ArrayList<>();\\n        for(int i = 0;i < n;i++)\\n            edge.add(new ArrayList<>());\\n        for(int i = 0;i < n;i++){\\n            if(manager[i] != -1)\\n                edge.get(manager[i]).add(i);\\n        }\\n        int max = 0;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(headID);\\n        while(!q.isEmpty()){\\n            int curr = q.poll();\\n            for(int sub : edge.get(curr)){\\n                time[sub] = time[curr] + informTime[curr];\\n                max = Math.max(max, time[sub]);\\n                q.add(sub);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int max;\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        if(n == 1)\\n            return 0;\\n        int[] time = new int[n];\\n        List<List<Integer>> edge = new ArrayList<>();\\n        for(int i = 0;i < n;i++)\\n            edge.add(new ArrayList<>());\\n        for(int i = 0;i < n;i++){\\n            if(manager[i] != -1)\\n                edge.get(manager[i]).add(i);\\n        }\\n        max = 0;\\n        dfs(edge, headID, informTime, 0);\\n        return max;\\n    }\\n    public void dfs(List<List<Integer>> edge, int curr, int[] inform, int time){\\n        int informNext = time + inform[curr];\\n        max = Math.max(informNext, max);\\n        for(int nei : edge.get(curr))\\n            dfs(edge, nei, inform, informNext);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        if(n == 1)\\n            return 0;\\n        int[] time = new int[n];\\n        List<List<Integer>> edge = new ArrayList<>();\\n        for(int i = 0;i < n;i++)\\n            edge.add(new ArrayList<>());\\n        for(int i = 0;i < n;i++){\\n            if(manager[i] != -1)\\n                edge.get(manager[i]).add(i);\\n        }\\n        int max = 0;\\n        Queue<Integer> q = new LinkedList<>();\\n        q.add(headID);\\n        while(!q.isEmpty()){\\n            int curr = q.poll();\\n            for(int sub : edge.get(curr)){\\n                time[sub] = time[curr] + informTime[curr];\\n                max = Math.max(max, time[sub]);\\n                q.add(sub);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2182543,
                "title": "c-bfs-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        \\n        vector<pair<int,int>> graph[n];\\n        vector<int> dis(n , INT_MAX);\\n        for ( int i=0; i<manager.size(); i++) {\\n            if( manager[i]==-1) continue;\\n            graph[manager[i]].push_back({ i ,  informTime[i]});\\n        }\\n        queue<pair<int , int>> q;\\n        q.push({headID , informTime[headID]});\\n        dis[headID] = informTime[headID];\\n        \\n        while ( !q.empty() ) {\\n            pair<int , int> p = q.front(); q.pop();\\n            for ( auto z : graph[p.first] ) {\\n                if( dis[z.first]>dis[p.first]+informTime[z.first]) {\\n                    dis[z.first] = dis[p.first]+informTime[z.first];\\n                    q.push({ z.first , dis[z.first]});\\n                }\\n            }\\n        }\\n        int maxi = 0;\\n        for ( int i=0; i<n; i++){\\n            maxi = max(maxi ,  dis[i]);\\n        }\\n        if( maxi == INT_MAX) return -1;\\n        else return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        \\n        vector<pair<int,int>> graph[n];\\n        vector<int> dis(n , INT_MAX);\\n        for ( int i=0; i<manager.size(); i++) {\\n            if( manager[i]==-1) continue;\\n            graph[manager[i]].push_back({ i ,  informTime[i]});\\n        }\\n        queue<pair<int , int>> q;\\n        q.push({headID , informTime[headID]});\\n        dis[headID] = informTime[headID];\\n        \\n        while ( !q.empty() ) {\\n            pair<int , int> p = q.front(); q.pop();\\n            for ( auto z : graph[p.first] ) {\\n                if( dis[z.first]>dis[p.first]+informTime[z.first]) {\\n                    dis[z.first] = dis[p.first]+informTime[z.first];\\n                    q.push({ z.first , dis[z.first]});\\n                }\\n            }\\n        }\\n        int maxi = 0;\\n        for ( int i=0; i<n; i++){\\n            maxi = max(maxi ,  dis[i]);\\n        }\\n        if( maxi == INT_MAX) return -1;\\n        else return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1606637,
                "title": "easiest-approach-well-coded-explained",
                "content": "## IDEA :\\n*So, this one looks like a nice use case for a BFS approach - we proceed down the hierarchy, layer by layer.*\\n\\nA first thought one might have when trying to solve this problem is that **The deepest employee in tree is going to require the most time until that become informed.** \\n* So first we are going to build this tree stucture. We will do this with the use of a dictionary here `graph`, where tree is a mapping from employee_id -> list of subordinates. \\n\\n* Now for the BFS approach we will maintain a queue which will contain `tuples of an employees id and the time` at which they have been informed. \\n* If an employee has subordinates then employee_id will be a key for the `graph` and we will add the employees subordinates and time needed to inform said subordinates to the queue.\\n\\nIn BFS we move on with a loop that will progress as long as we have something in our queue: \\nwe store its current manager and loop through it, extracting its first element, getting info from it?: \\nif it is not a leaf (ie: there are more nodes behind it), we proceed looping through its all children nodes and add to layer pairs of the increased cumulatedTime (the current value, plus the value of the child at hand) and the id of the child node. If currNode is a leaf, we update res to make sure it will always keep track of the largest time value found so far.\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\tfor e,m in enumerate(manager):\\n\\t\\t\\t\\tgraph[m].append(e)\\n\\n\\t\\t\\tq = [[headID,0]]\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\tnewq = []\\n\\t\\t\\t\\tlocal = 0\\n\\t\\t\\t\\tfor m,t in q:\\n\\t\\t\\t\\t\\tres = max(res,t)\\n\\t\\t\\t\\t\\tfor e in graph[m]:\\n\\t\\t\\t\\t\\t\\tnewq.append([e,t+informTime[m]])\\n\\n\\t\\t\\t\\tq = newq[::]\\n\\n\\t\\t\\treturn res\\n\\t\\n#### Thanks & Upvote if you like the Idea or got any help !!\\uD83E\\uDD1E\\n#### Feel free to ask if you have any doubt !!\\uD83E\\uDD17",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "## IDEA :\\n*So, this one looks like a nice use case for a BFS approach - we proceed down the hierarchy, layer by layer.*\\n\\nA first thought one might have when trying to solve this problem is that **The deepest employee in tree is going to require the most time until that become informed.** \\n* So first we are going to build this tree stucture. We will do this with the use of a dictionary here `graph`, where tree is a mapping from employee_id -> list of subordinates. \\n\\n* Now for the BFS approach we will maintain a queue which will contain `tuples of an employees id and the time` at which they have been informed. \\n* If an employee has subordinates then employee_id will be a key for the `graph` and we will add the employees subordinates and time needed to inform said subordinates to the queue.\\n\\nIn BFS we move on with a loop that will progress as long as we have something in our queue: \\nwe store its current manager and loop through it, extracting its first element, getting info from it?: \\nif it is not a leaf (ie: there are more nodes behind it), we proceed looping through its all children nodes and add to layer pairs of the increased cumulatedTime (the current value, plus the value of the child at hand) and the id of the child node. If currNode is a leaf, we update res to make sure it will always keep track of the largest time value found so far.\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\tfor e,m in enumerate(manager):\\n\\t\\t\\t\\tgraph[m].append(e)\\n\\n\\t\\t\\tq = [[headID,0]]\\n\\t\\t\\tres = 0\\n\\t\\t\\twhile q:\\n\\t\\t\\t\\tnewq = []\\n\\t\\t\\t\\tlocal = 0\\n\\t\\t\\t\\tfor m,t in q:\\n\\t\\t\\t\\t\\tres = max(res,t)\\n\\t\\t\\t\\t\\tfor e in graph[m]:\\n\\t\\t\\t\\t\\t\\tnewq.append([e,t+informTime[m]])\\n\\n\\t\\t\\t\\tq = newq[::]\\n\\n\\t\\t\\treturn res\\n\\t\\n#### Thanks & Upvote if you like the Idea or got any help !!\\uD83E\\uDD1E\\n#### Feel free to ask if you have any doubt !!\\uD83E\\uDD17",
                "codeTag": "Java"
            },
            {
                "id": 1572835,
                "title": "java-8ms-solution-beats-99-8",
                "content": "Use informTime as a DP array and flatten managerial heirarchy in a memoized DFS manner.\\n\\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        int maxTime = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < n; i++) {\\n            maxTime = Math.max(maxTime, getNewsTimeForEmployee(i, manager, informTime));\\n        }\\n        return maxTime;\\n    }\\n    \\n    private int getNewsTimeForEmployee(int i, int[] manager, int[] informTime) {\\n        if(manager[i] != -1) {\\n            informTime[i] += getNewsTimeForEmployee(manager[i], manager, informTime);\\n            manager[i] = -1;\\n        }   \\n        return informTime[i];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        int maxTime = Integer.MIN_VALUE;\\n        \\n        for(int i = 0; i < n; i++) {\\n            maxTime = Math.max(maxTime, getNewsTimeForEmployee(i, manager, informTime));\\n        }\\n        return maxTime;\\n    }\\n    \\n    private int getNewsTimeForEmployee(int i, int[] manager, int[] informTime) {\\n        if(manager[i] != -1) {\\n            informTime[i] += getNewsTimeForEmployee(manager[i], manager, informTime);\\n            manager[i] = -1;\\n        }   \\n        return informTime[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541321,
                "title": "dfs-time-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int id, vector<int> adj[], int count, int& res, vector<int> & informTime){\\n        \\n        if(adj[id].size()==0){\\n            res= max(res,count);\\n            return;\\n        }\\n        \\n        // pushing condition\\n        \\n        for(auto j: adj[id]){\\n            dfs(j,adj,count+informTime[id], res,informTime);\\n        }\\n        return;\\n    }\\n    \\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        \\n        vector<int> adj[n];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(manager[i]==-1){\\n                continue;\\n            }\\n            adj[manager[i]].push_back(i);\\n        }\\n        \\n        int res = 0;\\n        \\n        dfs(headID, adj,0,res,informTime);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int id, vector<int> adj[], int count, int& res, vector<int> & informTime){\\n        \\n        if(adj[id].size()==0){\\n            res= max(res,count);\\n            return;\\n        }\\n        \\n        // pushing condition\\n        \\n        for(auto j: adj[id]){\\n            dfs(j,adj,count+informTime[id], res,informTime);\\n        }\\n        return;\\n    }\\n    \\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        \\n        vector<int> adj[n];\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            if(manager[i]==-1){\\n                continue;\\n            }\\n            adj[manager[i]].push_back(i);\\n        }\\n        \\n        int res = 0;\\n        \\n        dfs(headID, adj,0,res,informTime);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1450149,
                "title": "c-dfs-commented-solution-80-space-80-time",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    int dfs(int n,vector<int> adj[],vector<int>& informTime){\\n        int time=informTime[n];\\n        if(adj[n].size()==0) return time;\\n        int temp=INT_MIN;\\n        for(auto x:adj[n]){\\n            // FIND TEMPORARY ANS FOR EVERY BRANCH and CALCULATE MAXIMUM FROM IT\\n            temp=max(temp,dfs(x,adj,informTime));\\n        }\\n        // TOTAL MINUTES REQUIRED IS MAXIMUM TIME REQUIRED FROM ALL THE BRANCHES STARTING FROM THAT NODE\\n        // SO SUM = informTime(node) + temp\\n        return time+temp;\\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        // CREATE ADJACENCY LIST\\n        \\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++){\\n            if(manager[i]!=-1){\\n                adj[manager[i]].push_back(i);\\n            }\\n        }\\n        // RUN DFS USING headID\\n        int ans=dfs(headID,adj,informTime);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1044754,
                "title": "java-bottom-up-dfs-beats-99-o-n-8ms",
                "content": "\\n\\tpublic int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tmax = Math.max(max, dfs(i, manager, informTime));\\n\\t\\treturn max;\\n\\t}\\n\\n\\tpublic int dfs(int curr, int[] manager, int[] informTime) {\\n\\t\\tif (manager[curr] != -1) {\\n\\t\\t\\tinformTime[curr] += dfs(manager[curr], manager, informTime);\\n\\t\\t\\tmanager[curr] = -1; \\n\\t\\t}\\n\\t\\treturn informTime[curr];\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n\\tpublic int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n\\t\\tint max = 0;\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tmax = Math.max(max, dfs(i, manager, informTime));\\n\\t\\treturn max;\\n\\t}\\n\\n\\tpublic int dfs(int curr, int[] manager, int[] informTime) {\\n\\t\\tif (manager[curr] != -1) {\\n\\t\\t\\tinformTime[curr] += dfs(manager[curr], manager, informTime);\\n\\t\\t\\tmanager[curr] = -1; \\n\\t\\t}\\n\\t\\treturn informTime[curr];\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1006304,
                "title": "help-in-understanding-test-case",
                "content": "```\\n15\\n0\\n[-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\n[1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n```\\n\\nThe expected time for this test case is 3. Can you please help me understand this case?",
                "solutionTags": [],
                "code": "```\\n15\\n0\\n[-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\n[1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 703237,
                "title": "python-3-straight-forward-solution-dfs-recursion",
                "content": "```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        def dfs(node , curTime):\\n            nonlocal totalTime\\n            visited.add(node)\\n            totalTime = max(curTime , totalTime)\\n            for nextNode in graph[node]:\\n                if nextNode not in visited:\\n                    dfs(nextNode , curTime + informTime[node])\\n        graph = defaultdict(set)\\n        totalTime = 0\\n        visited = set()\\n        for u , v in enumerate(manager):\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        visited.add(-1)\\n        dfs(headID , 0)\\n        return totalTime\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        def dfs(node , curTime):\\n            nonlocal totalTime\\n            visited.add(node)\\n            totalTime = max(curTime , totalTime)\\n            for nextNode in graph[node]:\\n                if nextNode not in visited:\\n                    dfs(nextNode , curTime + informTime[node])\\n        graph = defaultdict(set)\\n        totalTime = 0\\n        visited = set()\\n        for u , v in enumerate(manager):\\n            graph[u].add(v)\\n            graph[v].add(u)\\n        visited.add(-1)\\n        dfs(headID , 0)\\n        return totalTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681139,
                "title": "java-simple-graph-and-dfs",
                "content": "```\\nclass Solution {\\n    Map<Integer, Set<Integer>> map = new HashMap<>();\\n    int[] is;\\n    public int numOfMinutes(int n, int headID, int[] ms, int[] informTime) {\\n        is = informTime;\\n        for (int i = 0; i < ms.length; i++) {\\n            if (i == headID) continue;\\n            map.computeIfAbsent(ms[i], k -> new HashSet<>());\\n            map.get(ms[i]).add(i);\\n        }\\n        return dfs(headID);\\n    }\\n    private int dfs(int i) {\\n        if (!map.containsKey(i) || map.get(i).size() < 1) return 0;\\n        int res = 0;\\n        for (int j : map.get(i)) {\\n            res = Math.max(res, dfs(j));\\n        }\\n        return res + is[i];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Set<Integer>> map = new HashMap<>();\\n    int[] is;\\n    public int numOfMinutes(int n, int headID, int[] ms, int[] informTime) {\\n        is = informTime;\\n        for (int i = 0; i < ms.length; i++) {\\n            if (i == headID) continue;\\n            map.computeIfAbsent(ms[i], k -> new HashSet<>());\\n            map.get(ms[i]).add(i);\\n        }\\n        return dfs(headID);\\n    }\\n    private int dfs(int i) {\\n        if (!map.containsKey(i) || map.get(i).size() < 1) return 0;\\n        int res = 0;\\n        for (int j : map.get(i)) {\\n            res = Math.max(res, dfs(j));\\n        }\\n        return res + is[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601467,
                "title": "javascript-bfs-commented-clear-with-intuition-video-from-another-person",
                "content": "NB: if you see any error, improvement or correction I\\'d appreciate you adding a comment!\\n\\nThe key principle is to understand that you need to build a graph (tree) that represents to \"org structure\" with the big boss at the top and all the employees below him, along the heirarchy.  Do this using the classic graph adjancy list since a tree is a type of graph.\\n\\nthen you go level by level (BFS)  and for each employee you calculate the *cumulative* time taken to inform that employee, which is the time taken to inform their manager + the informTime value for themselves. Each employee added to the stack is in a tuple (or you can create an object with two keys) that is the employee id and the cumulative time to reach that employee.\\n\\nEach time you pop an employee of the BFS Queue and process him/her, you update the maxTime using Math.max as you want to record the maximum time needed.  This will be clearer when you read the code below.\\n\\n```\\n/**\\n * @param {number} n\\n * @param {number} headID\\n * @param {number[]} managers\\n * @param {number[]} informTime\\n * @return {number}\\n */\\nvar numOfMinutes = function (n, headID, managers, informTime) {\\n  // build org chart\\n  const directReportsOf = {};\\n\\n  for (let i = 0; i < n; i++) {\\n    directReportsOf[i] = [];\\n  }\\n\\n  // build direct reports in org chart\\n  for (let i = 0; i < managers.length; i++) {\\n    const employee = i;\\n    if (employee === headID) continue; // head does not have a boss\\n\\n    const manager = managers[employee];\\n    // if(manager === -1) continue // already handled above\\n    directReportsOf[manager].push(employee);\\n  }\\n\\n  // create tuple for each employee, with their id, and the TOTAL time to inform that employee\\n  const head = [headID, informTime[headID]];\\n  let maxTime = 0; // final answer\\n\\n  // BFS\\n  const Q = [head];\\n  while (Q.length > 0) {\\n    let [emp, empTotalTime] = Q.pop();\\n\\n    // update max time with the greater of last stored and current emp\\'s total\\n    maxTime = Math.max(maxTime, empTotalTime);\\n\\n    // add emp\\'s subordinates to Q\\n    const subords = directReportsOf[emp];\\n\\n    subords.forEach((minion) => {\\n      let pair = [minion, informTime[minion] + empTotalTime];\\n      Q.unshift(pair);\\n    });\\n  }\\n\\n  return maxTime;\\n};\\n```\\n\\nAlso recommend you look at [this video](https://www.youtube.com/watch?v=6wzOFeeIFKk) for the intuition.\\n\\nTime complexity is O(N) as we iterate over 0 to N-1 employees to create the graph and then the BFS over that graph is also O(N).  We also iterate over the managers M - and M < N so thats O(M).  \\n**Total Time Complexity**  O(N+M) which is O(N)\\n\\n**Space**:  graph + Queue so thats also O(N+N) which is O(N)\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @param {number} headID\\n * @param {number[]} managers\\n * @param {number[]} informTime\\n * @return {number}\\n */\\nvar numOfMinutes = function (n, headID, managers, informTime) {\\n  // build org chart\\n  const directReportsOf = {};\\n\\n  for (let i = 0; i < n; i++) {\\n    directReportsOf[i] = [];\\n  }\\n\\n  // build direct reports in org chart\\n  for (let i = 0; i < managers.length; i++) {\\n    const employee = i;\\n    if (employee === headID) continue; // head does not have a boss\\n\\n    const manager = managers[employee];\\n    // if(manager === -1) continue // already handled above\\n    directReportsOf[manager].push(employee);\\n  }\\n\\n  // create tuple for each employee, with their id, and the TOTAL time to inform that employee\\n  const head = [headID, informTime[headID]];\\n  let maxTime = 0; // final answer\\n\\n  // BFS\\n  const Q = [head];\\n  while (Q.length > 0) {\\n    let [emp, empTotalTime] = Q.pop();\\n\\n    // update max time with the greater of last stored and current emp\\'s total\\n    maxTime = Math.max(maxTime, empTotalTime);\\n\\n    // add emp\\'s subordinates to Q\\n    const subords = directReportsOf[emp];\\n\\n    subords.forEach((minion) => {\\n      let pair = [minion, informTime[minion] + empTotalTime];\\n      Q.unshift(pair);\\n    });\\n  }\\n\\n  return maxTime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612666,
                "title": "c-without-extra-space-unique-approach-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe basic idea is to check the maximum time taken to inform the leaf node. But here the implementation of tree is given in the format of array which slightly makes it a unique problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo we are starting from the first element of the array assuming it as a leaf node and using the information in the array which is the id of its manager we would be going up till we find the manager, once we find the manager we would be updating the maximum time. \\n\\nHere we are updating the maximum value even if the start node isn\\'t the leaf node as time is always positive and it always increases, we get maximum only from the leaf nodes not the non-leaf nodes. Every calculation takes atmost logN time making the total time as NlogN. We aren\\'t using any extra space for this calculation as directly we are using the property of the trees.\\n\\n# Complexity\\n- Time complexity: O(NlogN)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& v, vector<int>& t) {\\n        int ans=0;\\n        for(int i=0;i<v.size();i++){\\n              int curr=v[i],tot=0;\\n              while(curr!=-1){\\n                  tot+=t[curr];\\n                  if(v[curr]==-1){break;}\\n                  curr=v[curr];\\n              }\\n              ans=max(ans,tot);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& v, vector<int>& t) {\\n        int ans=0;\\n        for(int i=0;i<v.size();i++){\\n              int curr=v[i],tot=0;\\n              while(curr!=-1){\\n                  tot+=t[curr];\\n                  if(v[curr]==-1){break;}\\n                  curr=v[curr];\\n              }\\n              ans=max(ans,tot);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594002,
                "title": "simple-most-optimized-javascript-solution",
                "content": "\\n# Code\\n```\\nfunction dfs(emp, manager, informTime) {\\n    if (manager[emp] != -1) {\\n        informTime[emp] += dfs(manager[emp], manager, informTime);\\n        manager[emp] = -1;\\n    }\\n    return informTime[emp];\\n}\\n\\nvar numOfMinutes = function(n, headID, manager, informTime) {\\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (informTime[i] == 0) {\\n            continue;\\n        }\\n        max = Math.max(max, dfs(i, manager, informTime));\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunction dfs(emp, manager, informTime) {\\n    if (manager[emp] != -1) {\\n        informTime[emp] += dfs(manager[emp], manager, informTime);\\n        manager[emp] = -1;\\n    }\\n    return informTime[emp];\\n}\\n\\nvar numOfMinutes = function(n, headID, manager, informTime) {\\n    let max = 0;\\n    for (let i = 0; i < n; i++) {\\n        if (informTime[i] == 0) {\\n            continue;\\n        }\\n        max = Math.max(max, dfs(i, manager, informTime));\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593224,
                "title": "c-dfs-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nvoid dfs(int node, vector<int> adj[], vector<int> &dp, vector<int>& informTime){\\n    for(auto it: adj[node]){\\n        dfs(it, adj, dp, informTime);\\n        dp[node] = max(informTime[node] + dp[it], dp[node]);\\n    }\\n}\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++){\\n            if(manager[i] != -1) adj[manager[i]].push_back(i);\\n        }\\n        vector<int> dp(n, 0);\\n        dfs(headID, adj, dp, informTime);\\n        return dp[headID];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvoid dfs(int node, vector<int> adj[], vector<int> &dp, vector<int>& informTime){\\n    for(auto it: adj[node]){\\n        dfs(it, adj, dp, informTime);\\n        dp[node] = max(informTime[node] + dp[it], dp[node]);\\n    }\\n}\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++){\\n            if(manager[i] != -1) adj[manager[i]].push_back(i);\\n        }\\n        vector<int> dp(n, 0);\\n        dfs(headID, adj, dp, informTime);\\n        return dp[headID];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592621,
                "title": "c-3-approach-bfs-dfs-dp-99-fast-easy",
                "content": "\\n### **Approach 1 - Graph (BFS)**\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        for(int i = 0; i<n; i++){\\n            if(i == headID) continue;\\n        \\n            adj[manager[i]].push_back(i);\\n        }\\n\\n        queue<pair<int, int>> q;\\n        q.push({headID, 0});\\n\\n        int ans = 0;\\n        while(!q.empty()){\\n            auto [node, currTime] = q.front();\\n            q.pop();\\n\\n            int newTime = currTime + informTime[node];\\n            ans = max(ans, newTime);\\n            for(auto j : adj[node])\\n                q.push({j, newTime});\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n<br>\\n\\n---\\n### **Approach 2 - Graph (DFS)**\\n```\\nclass Solution {\\n    int n1, headID1;\\n    vector<int> informTime1;\\n    vector<vector<int>> graph;\\n    \\n    int dfs(int i){\\n        int time = 0;\\n        for(auto j : graph[i])\\n            time = max(time, dfs(j));\\n        \\n        time += informTime1[i];\\n        return time;\\n    }\\n    \\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        n1 = n, headID1 = headID, informTime1 = informTime;\\n        \\n\\t\\t\\n\\t\\t// Start -> Forming Graph\\n        graph = vector<vector<int>>(n);\\n        for(int i = 0; i<n; i++){\\n            if(i != headID)\\n                graph[manager[i]].push_back(i);\\n        }\\n\\t\\t// End\\n\\t\\t\\n        return dfs(headID);\\n    }\\n};\\n```\\n<br>\\n\\n---\\n\\n### **Approach 3 - DP (99% Fast)**\\n\\n\\n```\\nclass Solution {\\n    vector<int> dp;\\n    int dfs(int i, int headID, vector<int> &manager, vector<int>& informTime){\\n        // If i = -1 then it means we reached the top of the root\\n        if(i == -1) return 0;\\n\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        // Taking current node time and asking the upper branch to calculate its time.\\n        int ans = informTime[i] + dfs(manager[i], headID, manager, informTime); \\n        return dp[i] = ans;\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        dp = vector<int>(n, -1);\\n\\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            // Leaf node will have informTime as 0\\n            if(informTime[i] == 0)  \\n              // Ask the time required in a particular branch of tree starting from the leaf node\\n              ans = max(ans, dfs(i, headID, manager, informTime));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n<br>\\n\\n---\\n\\n```\\nThank you\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```\\n---",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        for(int i = 0; i<n; i++){\\n            if(i == headID) continue;\\n        \\n            adj[manager[i]].push_back(i);\\n        }\\n\\n        queue<pair<int, int>> q;\\n        q.push({headID, 0});\\n\\n        int ans = 0;\\n        while(!q.empty()){\\n            auto [node, currTime] = q.front();\\n            q.pop();\\n\\n            int newTime = currTime + informTime[node];\\n            ans = max(ans, newTime);\\n            for(auto j : adj[node])\\n                q.push({j, newTime});\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int n1, headID1;\\n    vector<int> informTime1;\\n    vector<vector<int>> graph;\\n    \\n    int dfs(int i){\\n        int time = 0;\\n        for(auto j : graph[i])\\n            time = max(time, dfs(j));\\n        \\n        time += informTime1[i];\\n        return time;\\n    }\\n    \\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        n1 = n, headID1 = headID, informTime1 = informTime;\\n        \\n\\t\\t\\n\\t\\t// Start -> Forming Graph\\n        graph = vector<vector<int>>(n);\\n        for(int i = 0; i<n; i++){\\n            if(i != headID)\\n                graph[manager[i]].push_back(i);\\n        }\\n\\t\\t// End\\n\\t\\t\\n        return dfs(headID);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int> dp;\\n    int dfs(int i, int headID, vector<int> &manager, vector<int>& informTime){\\n        // If i = -1 then it means we reached the top of the root\\n        if(i == -1) return 0;\\n\\n        if(dp[i] != -1)\\n            return dp[i];\\n\\n        // Taking current node time and asking the upper branch to calculate its time.\\n        int ans = informTime[i] + dfs(manager[i], headID, manager, informTime); \\n        return dp[i] = ans;\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        dp = vector<int>(n, -1);\\n\\n        int ans = 0;\\n        for(int i = 0; i<n; i++){\\n            // Leaf node will have informTime as 0\\n            if(informTime[i] == 0)  \\n              // Ask the time required in a particular branch of tree starting from the leaf node\\n              ans = max(ans, dfs(i, headID, manager, informTime));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nThank you\\nIf you learn/found something new, please Upvote \\uD83D\\uDC4D\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592386,
                "title": "beats-100-ts-tree-time-needed-to-inform-all-employees-easy-solution-with-explanation",
                "content": "![image.png](https://assets.leetcode.com/users/images/bcf793be-2aae-4a44-b9eb-94b5c6cc7419_1685783663.7815363.png)\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy main goal was to traverse the organisation using Depth-First Search and to simplify the solution I used TypeScript as it\\'s easier to figure out which parameters I need to use.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Define a helper function `timeFromEmployeeToHead` that takes an employee ID (`id`) as a parameter and calculates the time required for information to flow from that employee to the head of the organization.\\n    - Inside the helper function, check if the current employee has a manager (identified by `manager[id]`). \\n    - If the manager exists (not equal to `-1`), it means the current employee is not the head.\\n    - If the employee has a manager, recursively call the `timeFromEmployeeToHead` function for the manager\\'s ID. This step ensures that the information flows through the hierarchy until it reaches the head.\\n    - Update the `informTime` array for the current employee by adding the time it takes for the information to reach their manager (obtained from the recursive call).\\n    - Set the manager of the current employee to `-1` to mark that the information has been passed along. This prevents redundant calculations for the same employee.\\n    - Return the updated `informTime` for the current employee.\\n- In the main function `numOfMinutes`, iterate over each employee using the `forEach` method on the manager array.\\n- For each employee, call the `timeFromEmployeeToHead` function, which updates the `informTime` array with the total time required for information to reach the head.\\n- Finally, return the maximum value from the `informTime` array using the `Math.max` function, which represents the longest time taken for information to flow from any employee to the head.\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction numOfMinutes(n: number, headID: number, manager: number[], informTime: number[]): number {\\n    const timeFromEmployeeToHead = (id: number): number => {\\n        if(manager[id] != -1) {\\n            informTime[id] += timeFromEmployeeToHead(manager[id]);\\n            manager[id] = -1;\\n        }\\n        return informTime[id];\\n    }\\n\\n    manager.forEach((_, index) => timeFromEmployeeToHead(index));\\n\\n    return Math.max(...informTime);\\n};\\n```\\n\\n# Feedback\\nI would appreciate your feedback and would like to receive your comments and perspectives regarding my approach. I would also enjoy suggestions about how to hone my DSA skills because I am very new to this sector and it\\'s challenging at first. Thanks a lot!",
                "solutionTags": [
                    "TypeScript",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunction numOfMinutes(n: number, headID: number, manager: number[], informTime: number[]): number {\\n    const timeFromEmployeeToHead = (id: number): number => {\\n        if(manager[id] != -1) {\\n            informTime[id] += timeFromEmployeeToHead(manager[id]);\\n            manager[id] = -1;\\n        }\\n        return informTime[id];\\n    }\\n\\n    manager.forEach((_, index) => timeFromEmployeeToHead(index));\\n\\n    return Math.max(...informTime);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592213,
                "title": "python-elegant-short-1-line-dfs",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, head_id: int, manager: List[int], inform_time: List[int]) -> int:\\n        def dfs(boss: int) -> int:\\n            return inform_time[boss] + max((dfs(emp) for emp in subordinates[boss]), default=0)\\n\\n        subordinates = defaultdict(set)\\n\\n        for u, v in enumerate(manager):\\n            subordinates[v].add(u)\\n\\n        return dfs(head_id)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def numOfMinutes(self, n: int, head_id: int, manager: List[int], inform_time: List[int]) -> int:\\n        def dfs(boss: int) -> int:\\n            return inform_time[boss] + max((dfs(emp) for emp in subordinates[boss]), default=0)\\n\\n        subordinates = defaultdict(set)\\n\\n        for u, v in enumerate(manager):\\n            subordinates[v].add(u)\\n\\n        return dfs(head_id)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591904,
                "title": "java-solution-using-bfs",
                "content": "# Simple and Easy Solution in java using BFS \\n \\n\\n---\\n\\n\\n# Code\\n```\\nclass Pair\\n{\\n    int val = 0;\\n    int time = 0;\\n    Pair(int val,int time)\\n    {\\n        this.val = val;\\n        this.time = time;\\n    }\\n}\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>(n);\\n        for(int i = 0;i<n;i++)\\n        {\\n            ArrayList<Integer> arr = new ArrayList<>();\\n            graph.add(arr);\\n        }\\n        int source = headID;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(manager[i]!=-1)\\n            {\\n                graph.get(manager[i]).add(i);\\n            }\\n        }\\n        int result = 0;\\n        Queue<Pair> queue = new LinkedList<>();\\n        queue.add(new Pair(source,informTime[source]));\\n        while(queue.size() > 0)\\n        {\\n            Pair curr = queue.poll();\\n            for(int item : graph.get(curr.val))\\n            {\\n                queue.add(new Pair(item,curr.time+informTime[item]));\\n                result = Math.max(result,curr.time+informTime[item]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n\\n\\n#### *Please don\\'t forget to upvote if you\\'ve liked my solution.*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Pair\\n{\\n    int val = 0;\\n    int time = 0;\\n    Pair(int val,int time)\\n    {\\n        this.val = val;\\n        this.time = time;\\n    }\\n}\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        ArrayList<ArrayList<Integer>> graph = new ArrayList<>(n);\\n        for(int i = 0;i<n;i++)\\n        {\\n            ArrayList<Integer> arr = new ArrayList<>();\\n            graph.add(arr);\\n        }\\n        int source = headID;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(manager[i]!=-1)\\n            {\\n                graph.get(manager[i]).add(i);\\n            }\\n        }\\n        int result = 0;\\n        Queue<Pair> queue = new LinkedList<>();\\n        queue.add(new Pair(source,informTime[source]));\\n        while(queue.size() > 0)\\n        {\\n            Pair curr = queue.poll();\\n            for(int item : graph.get(curr.val))\\n            {\\n                queue.add(new Pair(item,curr.time+informTime[item]));\\n                result = Math.max(result,curr.time+informTime[item]);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591862,
                "title": "simple-and-intuitive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nDifferent managers give messages to their employees at different times.\\nso we need to do bfs based on time in increasing order\\n\\n\\n# Approach\\n\\nThen, we have to implement BFS in growing time so that we use min heap.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headid, vector<int>& manager, vector<int>& informtime) {\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++){\\n            if(i!=headid)adj[manager[i]].push_back(i);\\n        }\\n        int time=0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>> , greater<pair<int,int>>> pq;\\n        pq.push({informtime[headid]+time,headid});\\n\\nwhile(pq.size()!=0){\\n    auto it=pq.top();\\n    int node=it.second;\\n    int t=it.first;\\n    time=t;\\n    pq.pop();\\n    for(auto it:adj[node]){\\n        pq.push({t+informtime[it],it});\\n    }\\n}\\nreturn time;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headid, vector<int>& manager, vector<int>& informtime) {\\n        vector<int> adj[n+1];\\n        for(int i=0;i<n;i++){\\n            if(i!=headid)adj[manager[i]].push_back(i);\\n        }\\n        int time=0;\\n        priority_queue<pair<int,int>,vector<pair<int,int>> , greater<pair<int,int>>> pq;\\n        pq.push({informtime[headid]+time,headid});\\n\\nwhile(pq.size()!=0){\\n    auto it=pq.top();\\n    int node=it.second;\\n    int t=it.first;\\n    time=t;\\n    pq.pop();\\n    for(auto it:adj[node]){\\n        pq.push({t+informtime[it],it});\\n    }\\n}\\nreturn time;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591755,
                "title": "simple-solution-adjacency-list-and-dfs-c",
                "content": "First of all, I have created an adjacency list connecting managers to their subordinates, which I\\'m using to traversse from head of tree (the head manager) to the leaves of the tree.\\n\\nThen, with a simple DFS, I\\'m calculating the maximum possible time required.\\n\\n\\n```\\nvoid dfs(vector<int> adj[], int id, vector<int>& informTime, int& time, int tempTime) {\\n        tempTime += informTime[id];\\n        time = max(tempTime, time);\\n        \\n        for(auto it : adj[id]) dfs(adj, it, informTime, time, tempTime);\\n    }\\n    \\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int> adj[n];\\n        \\n        for(int i=0;i<n;i++) {\\n            if(manager[i] != -1) adj[manager[i]].push_back(i);\\n        }\\n        \\n        int time = 0;\\n        dfs(adj, headID, informTime, time, 0);\\n        \\n        return time;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid dfs(vector<int> adj[], int id, vector<int>& informTime, int& time, int tempTime) {\\n        tempTime += informTime[id];\\n        time = max(tempTime, time);\\n        \\n        for(auto it : adj[id]) dfs(adj, it, informTime, time, tempTime);\\n    }\\n    \\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int> adj[n];\\n        \\n        for(int i=0;i<n;i++) {\\n            if(manager[i] != -1) adj[manager[i]].push_back(i);\\n        }\\n        \\n        int time = 0;\\n        dfs(adj, headID, informTime, time, 0);\\n        \\n        return time;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591592,
                "title": "time-needed-to-inform-easy-c-solution-using-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\nNeeded DS :\\n1) vector_of_vector [n] which stores index of employee depend on i         n=number_of_employee\\n2) queue<pair<int,int>> first = store index till message has reached , second = inform_time need to reach message to that index \\n\\nAt first we have headID who generate message so index = headId , time = 0\\nstep 1 :Push {headID,0} in queue\\nstep 2: pop and mark ind=first , time=second\\nstep 3: Traverse :v[ind] to get all employee , Push that {it,time+informTime[ind]} in queue\\nstep 4:Run till queue become empty\\n\\nNote : we dont need visited array here because , there is no indirect dependancy like if 0 -> 1,2 then no other that 0 have 1,2\\n```\\n# Complexity\\n- Time complexity:```O(N)+O(N)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:```O(N+N)+O(N)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>>v(n);\\n        for(int i=0;i<n;i++){\\n           if(manager[i]!= -1){\\n               v[manager[i]].push_back(i);\\n           }\\n        }\\n  \\n        queue<pair<int,int>>dq;\\n        int maxi=0;\\n        dq.push({headID,0});\\n        while(!dq.empty()){\\n\\n           int ind = dq.front().first;\\n           int cnt = dq.front().second; \\n           maxi=max(cnt,maxi);\\n           dq.pop();\\n           for(auto it : v[ind]){\\n                dq.push({it,cnt+informTime[ind]});\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n//Happy coding \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nNeeded DS :\\n1) vector_of_vector [n] which stores index of employee depend on i         n=number_of_employee\\n2) queue<pair<int,int>> first = store index till message has reached , second = inform_time need to reach message to that index \\n\\nAt first we have headID who generate message so index = headId , time = 0\\nstep 1 :Push {headID,0} in queue\\nstep 2: pop and mark ind=first , time=second\\nstep 3: Traverse :v[ind] to get all employee , Push that {it,time+informTime[ind]} in queue\\nstep 4:Run till queue become empty\\n\\nNote : we dont need visited array here because , there is no indirect dependancy like if 0 -> 1,2 then no other that 0 have 1,2\\n```\n```O(N)+O(N)```\n```O(N+N)+O(N)```\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>>v(n);\\n        for(int i=0;i<n;i++){\\n           if(manager[i]!= -1){\\n               v[manager[i]].push_back(i);\\n           }\\n        }\\n  \\n        queue<pair<int,int>>dq;\\n        int maxi=0;\\n        dq.push({headID,0});\\n        while(!dq.empty()){\\n\\n           int ind = dq.front().first;\\n           int cnt = dq.front().second; \\n           maxi=max(cnt,maxi);\\n           dq.pop();\\n           for(auto it : v[ind]){\\n                dq.push({it,cnt+informTime[ind]});\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n//Happy coding \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591563,
                "title": "python-short-and-clean-dfs-functional-programming",
                "content": "# Approach\\n1. Construct an `WeightedTree` of the form,\\n    `WeightedTree = (Weight, List of child WeightedTrees)`,\\n    with managers as parent nodes and employees as child nodes, `inform_time` as `Weight`.\\n\\n2. Define, `max_path_sum of root = Weight of root + max(max_path_sum of all children)`.\\n\\n3. Return `max_path_sum` with `head_id` node as root.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def numOfMinutes(self, n: int, head_id: int, manager: list[int], inform_time: list[int]) -> int:\\n        Weight = int | float\\n        WeightedTree = tuple[Weight, Iterable[\\'WeightedTree\\']]\\n\\n        def max_path_sum(tree: WeightedTree) -> Weight:\\n            return tree[0] + max(map(max_path_sum, tree[1]), default=0)\\n\\n        nodes = defaultdict(lambda: (0, []), {e: (t, []) for e, t in enumerate(inform_time)})\\n        for e, m in enumerate(manager): nodes[m][1].append(nodes[e])\\n        \\n        return max_path_sum(nodes[head_id])\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def numOfMinutes(self, n: int, head_id: int, manager: list[int], inform_time: list[int]) -> int:\\n        Weight = int | float\\n        WeightedTree = tuple[Weight, Iterable[\\'WeightedTree\\']]\\n\\n        def max_path_sum(tree: WeightedTree) -> Weight:\\n            return tree[0] + max(map(max_path_sum, tree[1]), default=0)\\n\\n        nodes = defaultdict(lambda: (0, []), {e: (t, []) for e, t in enumerate(inform_time)})\\n        for e, m in enumerate(manager): nodes[m][1].append(nodes[e])\\n        \\n        return max_path_sum(nodes[head_id])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591502,
                "title": "java-solution-for-time-needed-to-inform-all-employees-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe company has a tree structure of employees, where each employee has a unique ID and a direct manager.\\nThe head of the company wants to inform all employees about an urgent news.\\nEach employee takes a certain amount of time to inform their direct subordinates.\\nThe goal is to find the total time needed for all employees to be informed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a list of employees to represent the tree structure. Each index of the list corresponds to an employee, and the list contains their direct subordinates.\\n1. Build the tree structure using the manager array. Iterate over the manager array and add each employee to the list of their direct manager\\'s subordinates.\\n1. Define a recursive helper function to calculate the time needed for each employee and their subordinates.\\n1. In the recursive function, iterate over the subordinates of the current employee.\\n- For each subordinate, recursively call the function to calculate the time needed to inform their subordinates.\\n- Keep track of the maximum time among all subordinates.\\n5. Return the maximum time among all subordinates plus the informTime of the current employee as the total time needed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nConstructing the tree structure and calculating the total time for each employee requires visiting each employee once, resulting in O(n) time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is determined by the size of the list representing the tree structure, which is O(n) since there can be up to n employees.\\n\\n# Code\\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        // Create a list of employees to represent the tree structure\\n        List<List<Integer>> employees = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            employees.add(new ArrayList<>());\\n        }\\n\\n        // Build the tree structure using the manager array\\n        for (int i = 0; i < n; i++) {\\n            if (manager[i] != -1) {\\n                employees.get(manager[i]).add(i);\\n            }\\n        }\\n\\n        // Call the recursive helper function to calculate the time needed for each employee\\n        return informSubordinates(headID, employees, informTime);\\n    }\\n    private int informSubordinates(int currentEmployee, List<List<Integer>> employees, int[] informTime) {\\n        int maxTime = 0;\\n\\n        // Iterate over the subordinates of the current employee\\n        for (int subordinate : employees.get(currentEmployee)) {\\n            // Calculate the time needed to inform the subordinate and recursively inform its subordinates\\n            int time = informSubordinates(subordinate, employees, informTime);\\n            maxTime = Math.max(maxTime, time);\\n        }\\n\\n        // Return the total time needed for the current employee and its subordinates\\n        return maxTime + informTime[currentEmployee];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        // Create a list of employees to represent the tree structure\\n        List<List<Integer>> employees = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            employees.add(new ArrayList<>());\\n        }\\n\\n        // Build the tree structure using the manager array\\n        for (int i = 0; i < n; i++) {\\n            if (manager[i] != -1) {\\n                employees.get(manager[i]).add(i);\\n            }\\n        }\\n\\n        // Call the recursive helper function to calculate the time needed for each employee\\n        return informSubordinates(headID, employees, informTime);\\n    }\\n    private int informSubordinates(int currentEmployee, List<List<Integer>> employees, int[] informTime) {\\n        int maxTime = 0;\\n\\n        // Iterate over the subordinates of the current employee\\n        for (int subordinate : employees.get(currentEmployee)) {\\n            // Calculate the time needed to inform the subordinate and recursively inform its subordinates\\n            int time = informSubordinates(subordinate, employees, informTime);\\n            maxTime = Math.max(maxTime, time);\\n        }\\n\\n        // Return the total time needed for the current employee and its subordinates\\n        return maxTime + informTime[currentEmployee];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591457,
                "title": "easy-python-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        dct=defaultdict(lambda :[])\\n        for i in range(n):\\n            dct[manager[i]].append(i)\\n        lst=[0]*n\\n        mx=0\\n        queue=[headID]\\n        while queue:\\n            x=queue.pop(0)\\n            for j in dct[x]:\\n                lst[j]=(informTime[x]+lst[x])\\n                mx=max(mx,lst[j])\\n                queue.append(j)\\n        return mx\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        dct=defaultdict(lambda :[])\\n        for i in range(n):\\n            dct[manager[i]].append(i)\\n        lst=[0]*n\\n        mx=0\\n        queue=[headID]\\n        while queue:\\n            x=queue.pop(0)\\n            for j in dct[x]:\\n                lst[j]=(informTime[x]+lst[x])\\n                mx=max(mx,lst[j])\\n                queue.append(j)\\n        return mx\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3591056,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        def find(i):\\n            if manager[i]!=-1:\\n                informTime[i]+=find(manager[i])\\n                manager[i]=-1\\n\\n            return informTime[i]\\n\\n        return max(map(find,range(n)))        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        def find(i):\\n            if manager[i]!=-1:\\n                informTime[i]+=find(manager[i])\\n                manager[i]=-1\\n\\n            return informTime[i]\\n\\n        return max(map(find,range(n)))        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552665,
                "title": "c-dfs-just-like-maximum-path-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Given that , it is guaranteed that the subordination relationships have a tree structure means no need of visited array\\n- If we consider head to last sub-ordinate (i.e,leaf node) as a path , then we just need to find the max time taken path .\\n\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int curr=0,maxx=0;\\n    void dfs(vector<int> adj[],vector<int>& informTime,int src)\\n    {\\n        if(adj[src].size()==0)//leaf node or last subordinate\\n        {\\n            maxx=max(maxx,curr);\\n            return ;\\n        }\\n        curr+=informTime[src];\\n        for(auto it : adj[src])\\n            dfs(adj,informTime,it);\\n        curr-=informTime[src];\\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) \\n    {\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++)\\n            if(manager[i]!=-1)\\n                adj[manager[i]].push_back(i);\\n        dfs(adj,informTime,headID);\\n        return maxx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int curr=0,maxx=0;\\n    void dfs(vector<int> adj[],vector<int>& informTime,int src)\\n    {\\n        if(adj[src].size()==0)//leaf node or last subordinate\\n        {\\n            maxx=max(maxx,curr);\\n            return ;\\n        }\\n        curr+=informTime[src];\\n        for(auto it : adj[src])\\n            dfs(adj,informTime,it);\\n        curr-=informTime[src];\\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) \\n    {\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++)\\n            if(manager[i]!=-1)\\n                adj[manager[i]].push_back(i);\\n        dfs(adj,informTime,headID);\\n        return maxx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077609,
                "title": "java-solution-9-ms-beats-95",
                "content": "# Code\\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            result = Math.max(result, dfs(i, informTime, manager));\\n        }\\n        return result;\\n    }\\n    private int dfs(int i, int[] informTime, int[] manager) {\\n        if (manager[i] != -1) {\\n            informTime[i] += dfs(manager[i], informTime, manager);\\n            manager[i] = -1;\\n        }\\n        return informTime[i];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        int result = 0;\\n        for (int i = 0; i < n; i++) {\\n            result = Math.max(result, dfs(i, informTime, manager));\\n        }\\n        return result;\\n    }\\n    private int dfs(int i, int[] informTime, int[] manager) {\\n        if (manager[i] != -1) {\\n            informTime[i] += dfs(manager[i], informTime, manager);\\n            manager[i] = -1;\\n        }\\n        return informTime[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2894516,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> g[100005];\\n    int vis[100005], dis[100005];\\n\\n    void bfs(int s, vector<int>& informTime) {\\n        queue<int> q;\\n        vis[s] = 1;\\n        dis[s] = 0;\\n        q.push(s);\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(auto v: g[u]) {\\n                if(!vis[v]) {\\n                    vis[v] = 1;\\n                    dis[v] = dis[u] + informTime[u];\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        memset(vis, 0, sizeof(vis));\\n        memset(dis, 0, sizeof(dis));\\n        for(int i=0; i<n; i++) {\\n            if(manager[i] != -1) g[manager[i]].push_back(i);\\n        }\\n\\n        bfs(headID, informTime);\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++) ans = max(ans, dis[i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> g[100005];\\n    int vis[100005], dis[100005];\\n\\n    void bfs(int s, vector<int>& informTime) {\\n        queue<int> q;\\n        vis[s] = 1;\\n        dis[s] = 0;\\n        q.push(s);\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(auto v: g[u]) {\\n                if(!vis[v]) {\\n                    vis[v] = 1;\\n                    dis[v] = dis[u] + informTime[u];\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        memset(vis, 0, sizeof(vis));\\n        memset(dis, 0, sizeof(dis));\\n        for(int i=0; i<n; i++) {\\n            if(manager[i] != -1) g[manager[i]].push_back(i);\\n        }\\n\\n        bfs(headID, informTime);\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++) ans = max(ans, dis[i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707162,
                "title": "go-map-and-recursive-solution",
                "content": "```\\nvar urgentTime int\\nfunc numOfMinutes(n int, headID int, manager []int, informTime []int) int {\\n    urgentTime = 0\\n    managerMap := make(map[int][]int)\\n    for employeeId, managerId := range manager {\\n        managerMap[managerId] = append(managerMap[managerId], employeeId)\\n    }\\n    tracePath(headID, managerMap, informTime, 0)\\n    return urgentTime\\n}\\n\\nfunc tracePath(employee int, managerMap map[int][]int, informTime []int, time int) {\\n    time += informTime[employee]\\n    if urgentTime < time {\\n        urgentTime = time\\n    }\\n    employeeIds, ok := managerMap[employee]\\n    if ok {\\n        for _, employeeId := range employeeIds {\\n            tracePath(employeeId, managerMap, informTime, time)\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nvar urgentTime int\\nfunc numOfMinutes(n int, headID int, manager []int, informTime []int) int {\\n    urgentTime = 0\\n    managerMap := make(map[int][]int)\\n    for employeeId, managerId := range manager {\\n        managerMap[managerId] = append(managerMap[managerId], employeeId)\\n    }\\n    tracePath(headID, managerMap, informTime, 0)\\n    return urgentTime\\n}\\n\\nfunc tracePath(employee int, managerMap map[int][]int, informTime []int, time int) {\\n    time += informTime[employee]\\n    if urgentTime < time {\\n        urgentTime = time\\n    }\\n    employeeIds, ok := managerMap[employee]\\n    if ok {\\n        for _, employeeId := range employeeIds {\\n            tracePath(employeeId, managerMap, informTime, time)\\n        }\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2638217,
                "title": "java-bfs-map-list",
                "content": "Variation of [124. Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)\\n\\nSame approach (DFS), different Data-structure (Map and List)\\nList approach is much faster\\n\\nApproach: 1 (Map)\\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            map.putIfAbsent(manager[i], new ArrayList<>());\\n            map.get(manager[i]).add(i);\\n        }\\n        return helper(informTime, map, headID);\\n    }\\n    \\n    private int helper(int[] informTime, Map<Integer, List<Integer>> map, int curr){\\n        if(!map.containsKey(curr)) return 0;\\n        \\n        int min = 0;\\n        List<Integer> list = map.get(curr);\\n        \\n        for(int i = 0; i < list.size(); i++){\\n            min = Math.max(helper(informTime, map, list.get(i)), min);\\n        }\\n        \\n        return min + informTime[curr];\\n    }\\n}\\n```\\n\\nApproach 2: (List)\\n\\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        for(int i = 0; i < n; i++) list.add(new ArrayList<>());\\n        \\n        for(int i = 0; i < n; i++){\\n            if(manager[i] != -1)\\n            list.get(manager[i]).add(i);\\n        }\\n        return helper(informTime, list, headID);\\n    }\\n    \\n    private int helper(int[] informTime, List<List<Integer>> list, int curr){\\n        if(list.get(curr).size() == 0) return 0;\\n        \\n        int min = 0;\\n        List<Integer> temp = list.get(curr);\\n        \\n        for(int i = 0; i < temp.size(); i++){\\n            min = Math.max(helper(informTime, list, temp.get(i)), min);\\n        }\\n        \\n        return min + informTime[curr];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        for(int i = 0; i < n; i++){\\n            map.putIfAbsent(manager[i], new ArrayList<>());\\n            map.get(manager[i]).add(i);\\n        }\\n        return helper(informTime, map, headID);\\n    }\\n    \\n    private int helper(int[] informTime, Map<Integer, List<Integer>> map, int curr){\\n        if(!map.containsKey(curr)) return 0;\\n        \\n        int min = 0;\\n        List<Integer> list = map.get(curr);\\n        \\n        for(int i = 0; i < list.size(); i++){\\n            min = Math.max(helper(informTime, map, list.get(i)), min);\\n        }\\n        \\n        return min + informTime[curr];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        for(int i = 0; i < n; i++) list.add(new ArrayList<>());\\n        \\n        for(int i = 0; i < n; i++){\\n            if(manager[i] != -1)\\n            list.get(manager[i]).add(i);\\n        }\\n        return helper(informTime, list, headID);\\n    }\\n    \\n    private int helper(int[] informTime, List<List<Integer>> list, int curr){\\n        if(list.get(curr).size() == 0) return 0;\\n        \\n        int min = 0;\\n        List<Integer> temp = list.get(curr);\\n        \\n        for(int i = 0; i < temp.size(); i++){\\n            min = Math.max(helper(informTime, list, temp.get(i)), min);\\n        }\\n        \\n        return min + informTime[curr];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2427175,
                "title": "simple-bfs-c",
                "content": "```\\nint numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        queue<vector<int>> q;\\n        \\n        vector<vector<int>> adj(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(manager[i]!=-1)\\n            {\\n                adj[manager[i]].push_back(i);\\n            }\\n            else\\n            {\\n                q.push({i,-1,0});\\n            }\\n        }\\n        \\n        int m=0;\\n        while(!q.empty())\\n        {\\n            int i = q.front()[0];\\n            int parent = q.front()[1];\\n            int d = q.front()[2];\\n            q.pop();\\n            for(auto it:adj[i]){\\n                q.push({it,i,d+informTime[i]});\\n                m = max(m,d+informTime[i]);\\n            }\\n        }\\n        return m;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        queue<vector<int>> q;\\n        \\n        vector<vector<int>> adj(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(manager[i]!=-1)\\n            {\\n                adj[manager[i]].push_back(i);\\n            }\\n            else\\n            {\\n                q.push({i,-1,0});\\n            }\\n        }\\n        \\n        int m=0;\\n        while(!q.empty())\\n        {\\n            int i = q.front()[0];\\n            int parent = q.front()[1];\\n            int d = q.front()[2];\\n            q.pop();\\n            for(auto it:adj[i]){\\n                q.push({it,i,d+informTime[i]});\\n                m = max(m,d+informTime[i]);\\n            }\\n        }\\n        return m;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2377234,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int h, int[] m, int[] a) {\\n        List<List<Integer>> nm=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            nm.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<m.length;i++)\\n        {\\n            if(m[i]!=-1)\\n                nm.get(m[i]).add(i);\\n        }\\n        return task(nm,h,a);\\n    }\\n    public int task(List<List<Integer>> nm, int i, int a[])\\n    {\\n        int max=0;\\n        for(int p:nm.get(i))\\n        {\\n            max=Math.max(max, task(nm,p,a));\\n        }\\n        return max+a[i];\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public int numOfMinutes(int n, int h, int[] m, int[] a) {\\n        List<List<Integer>> nm=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            nm.add(new ArrayList<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2349466,
                "title": "basic-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(int u,vector<vector<int>>& adj, vector<int>& informTime){\\n        \\n        if(adj[u].size() == 0){\\n            return 0;\\n        }\\n        \\n        int ans = 0;\\n        for(int v:adj[u]){\\n            ans = max(ans,solve(v,adj,informTime));\\n        }\\n        return  informTime[u] +  ans;\\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n       vector<vector<int>> adj(n);\\n        int u;\\n        for(int i=0;i<n;i++){\\n            if(manager[i] == -1)\\n                u = i;\\n            else\\n                adj[manager[i]].push_back(i);\\n        }\\n        \\n        return solve(u,adj,informTime);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\npublic:\\n    int solve(int u,vector<vector<int>>& adj, vector<int>& informTime){\\n        \\n        if(adj[u].size() == 0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2308430,
                "title": "c-easy-to-understand-dfs-adj-list",
                "content": "```\\nclass Solution {\\npublic:\\n    int dfs(int node,vector<int>&inTime,vector<int>*adj)\\n    {\\n\\t//Base case for the leaf nodes\\n        if(inTime[node]==0)\\n            return 0;\\n\\t\\tint time;\\n        int maxi=-1e9;\\n\\t\\t//Traversing all the paths from the parent node\\n        for(int it:adj[node])\\n        {\\n            time=inTime[node]+dfs(it,inTime,adj);\\n            maxi=max(maxi,time);\\n        }\\n        //for ex if path 1 takes 4 mins and path 2 takes 9 minutes then we have to take the maximum of all the paths\\n        return maxi;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n\\t//no time needed for one node\\n        if(n==1)\\n            return 0;\\n\\t\\t\\n\\t\\t//make an adjacency list from the manager list\\n        vector<int>adj[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i!=headID)\\n                adj[manager[i]].push_back(i);\\n        }\\n        \\n        return dfs(headID,informTime,adj);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node,vector<int>&inTime,vector<int>*adj)\\n    {\\n\\t//Base case for the leaf nodes\\n        if(inTime[node]==0)\\n            return 0;\\n\\t\\tint time;\\n        int maxi=-1e9;\\n\\t\\t//Traversing all the paths from the parent node\\n        for(int it:adj[node])\\n        {\\n            time=inTime[node]+dfs(it,inTime,adj);\\n            maxi=max(maxi,time);\\n        }\\n        //for ex if path 1 takes 4 mins and path 2 takes 9 minutes then we have to take the maximum of all the paths\\n        return maxi;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n\\t//no time needed for one node\\n        if(n==1)\\n            return 0;\\n\\t\\t\\n\\t\\t//make an adjacency list from the manager list\\n        vector<int>adj[n];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i!=headID)\\n                adj[manager[i]].push_back(i);\\n        }\\n        \\n        return dfs(headID,informTime,adj);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266745,
                "title": "graph-dfs-c",
                "content": "```\\nclass Solution {\\npublic:\\n     int dfs(vector<int> tree[],int vertex,vector<int>& informTime) {\\n        int ans=0;\\n        for(auto child:tree[vertex]){\\n             int k=informTime[vertex]+dfs(tree,child,informTime);\\n            ans=max(ans,k);\\n        }\\n        return ans;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int> tree[n];\\n        for(int i=0;i<n;i++) {\\n            if(manager[i]==-1)continue;\\n            tree[manager[i]].push_back(i);\\n        }\\n        return dfs(tree,headID,informTime);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n     int dfs(vector<int> tree[],int vertex,vector<int>& informTime) {\\n        int ans=0;\\n        for(auto child:tree[vertex]){\\n             int k=informTime[vertex]+dfs(tree,child,informTime);\\n            ans=max(ans,k);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2232090,
                "title": "doubt",
                "content": "\\n\\n11\\n4\\n[5,9,6,10,-1,8,9,1,9,3,4]\\n[0,213,0,253,686,170,975,0,261,309,337]\\n\\nFor this case, shouldn\\'t the answer be 2730\\nBut the answer is 2560.\\n```\\nAs the tree is\\n                                           4\\n                                           |\\n                                           10\\n                                           |\\n                                           3\\n                                           |\\n                                           9\\n                                 /         |        \\\\\\n                               1           6           8\\n                               |           |           |\\n                               7          2             5\\n                                                        |\\n                                                        0 \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\nIf you trace it down, you will find out we are not adding the time \\'5\\' will take to inform \\'0\\'.  \\nCan anybody explain why?",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2223677,
                "title": "dfs-java",
                "content": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Graph graph = new Graph(manager, n);\\n        return graph.getNumOfMinutes(headID, informTime);\\n    }\\n    \\n    static class Graph {\\n        List<List<Integer>> adjacencyList;\\n        int nodes;\\n        \\n        Graph(int[] manager, int n) {\\n            this.nodes = n;\\n            this.adjacencyList = new ArrayList();\\n            \\n            for (int node = 0; node < nodes; node++) {\\n                this.adjacencyList.add(new LinkedList());\\n            }\\n            \\n            for (int reportee = 0; reportee < nodes; reportee++) {\\n                if (manager[reportee] == -1) continue;\\n                this.adjacencyList.get(manager[reportee]).add(reportee);\\n            }\\n        }\\n        \\n        public int getNumOfMinutes(int headId, int[] informTime) {\\n            return getNumOfMinutes1(headId, informTime);\\n        }\\n        \\n        private int getNumOfMinutes1(int node, int[] informTime) {\\n            int ans = 0;\\n            for (int adjacentNode: this.adjacencyList.get(node)) {\\n                ans = Math.max(ans, informTime[node] + getNumOfMinutes1(adjacentNode, informTime));\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Graph graph = new Graph(manager, n);\\n        return graph.getNumOfMinutes(headID, informTime);\\n    }\\n    \\n    static class Graph {\\n        List<List<Integer>> adjacencyList;\\n        int nodes;\\n        \\n        Graph(int[] manager, int n) {\\n            this.nodes = n;\\n            this.adjacencyList = new ArrayList();\\n            \\n            for (int node = 0; node < nodes; node++) {\\n                this.adjacencyList.add(new LinkedList());\\n            }\\n            \\n            for (int reportee = 0; reportee < nodes; reportee++) {\\n                if (manager[reportee] == -1) continue;\\n                this.adjacencyList.get(manager[reportee]).add(reportee);\\n            }\\n        }\\n        \\n        public int getNumOfMinutes(int headId, int[] informTime) {\\n            return getNumOfMinutes1(headId, informTime);\\n        }\\n        \\n        private int getNumOfMinutes1(int node, int[] informTime) {\\n            int ans = 0;\\n            for (int adjacentNode: this.adjacencyList.get(node)) {\\n                ans = Math.max(ans, informTime[node] + getNumOfMinutes1(adjacentNode, informTime));\\n            }\\n            return ans;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2199520,
                "title": "java-bfs-simple",
                "content": "```\\nclass Solution {\\n    \\n    class EmployeeNode {\\n        int empId;\\n        int timeTakenToInform;\\n        \\n        EmployeeNode(int empId, int timeTakenToInform) {\\n            this.empId = empId;\\n            this.timeTakenToInform = timeTakenToInform;\\n        }\\n    }\\n    \\n    private boolean isManager(int emp, Map<Integer, List<Integer>> tree) {\\n        return tree.containsKey(emp);\\n    }\\n    \\n    private boolean hasManager(int managerId) {\\n        return managerId != -1;\\n    }\\n    \\n    private void createTree(Map<Integer, List<Integer>> tree, int n, int[] manager) {\\n        for(int emp = 0; emp<n; emp++) {\\n            int managerId = manager[emp];\\n            if(hasManager(managerId)) {\\n                tree.putIfAbsent(managerId, new ArrayList<>());\\n                tree.get(managerId).add(emp);\\n            }\\n        }\\n    }\\n    \\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {    \\n        Queue<EmployeeNode> bfs = new LinkedList<>();\\n        bfs.add(new EmployeeNode(headID, 0));\\n        int totalInformTime = 0;\\n        Map<Integer, List<Integer>> tree = new HashMap<>();\\n        createTree(tree, n, manager);\\n        \\n        while(bfs.size() > 0) {            \\n                 EmployeeNode emp = bfs.poll();\\n                 totalInformTime = Math.max(totalInformTime, emp.timeTakenToInform);\\n                 int timeToInformWorker =  emp.timeTakenToInform + informTime[emp.empId];\\n                 \\n                 if(isManager(emp.empId, tree)) {\\n                     for(int worker : tree.get(emp.empId)) {\\n                         bfs.add(new EmployeeNode(worker, timeToInformWorker));\\n                     }\\n                 }\\n        }\\n        \\n        return totalInformTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class EmployeeNode {\\n        int empId;\\n        int timeTakenToInform;\\n        \\n        EmployeeNode(int empId, int timeTakenToInform) {\\n            this.empId = empId;\\n            this.timeTakenToInform = timeTakenToInform;\\n        }\\n    }\\n    \\n    private boolean isManager(int emp, Map<Integer, List<Integer>> tree) {\\n        return tree.containsKey(emp);\\n    }\\n    \\n    private boolean hasManager(int managerId) {\\n        return managerId != -1;\\n    }\\n    \\n    private void createTree(Map<Integer, List<Integer>> tree, int n, int[] manager) {\\n        for(int emp = 0; emp<n; emp++) {\\n            int managerId = manager[emp];\\n            if(hasManager(managerId)) {\\n                tree.putIfAbsent(managerId, new ArrayList<>());\\n                tree.get(managerId).add(emp);\\n            }\\n        }\\n    }\\n    \\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {    \\n        Queue<EmployeeNode> bfs = new LinkedList<>();\\n        bfs.add(new EmployeeNode(headID, 0));\\n        int totalInformTime = 0;\\n        Map<Integer, List<Integer>> tree = new HashMap<>();\\n        createTree(tree, n, manager);\\n        \\n        while(bfs.size() > 0) {            \\n                 EmployeeNode emp = bfs.poll();\\n                 totalInformTime = Math.max(totalInformTime, emp.timeTakenToInform);\\n                 int timeToInformWorker =  emp.timeTakenToInform + informTime[emp.empId];\\n                 \\n                 if(isManager(emp.empId, tree)) {\\n                     for(int worker : tree.get(emp.empId)) {\\n                         bfs.add(new EmployeeNode(worker, timeToInformWorker));\\n                     }\\n                 }\\n        }\\n        \\n        return totalInformTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2068150,
                "title": "java-bfs-approach-comments-written-for-explanation",
                "content": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        //Manager -> list<employees>\\n        for(int i=0;i<n;i++){\\n            if(!map.containsKey(manager[i]))\\n                map.put(manager[i], new ArrayList<>());\\n            \\n            map.get(manager[i]).add(i);\\n        }\\n        \\n        LinkedList<Integer> queue = new LinkedList<>();\\n        queue.add(headID);  //add the head\\n        \\n        int[] time = new int[n];\\n        time[headID] = 0;   //head takes 0 time to know the information\\n        int max = 0;\\n        \\n        while(!queue.isEmpty()){\\n            Integer u = queue.poll();\\n            int timetaken = informTime[u];  //time it takes for u to inform\\n            \\n            //traverse only if there are employees reporting to U\\n            if(map.get(u)!=null){\\n                \\n                //take every employee and find how much time it takes to inform\\n                for(Integer v: map.get(u)){\\n                    \\n                    //time[u] is how much time u took? that is v\\'s manager and timetaken-> how much time it takes to inform v\\n                    time[v] = time[u] + timetaken;\\n                    \\n                    //also keep finding the maxTime\\n                    max = Math.max(max, time[v]);\\n                    queue.add(v);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        \\n        //Manager -> list<employees>\\n        for(int i=0;i<n;i++){\\n            if(!map.containsKey(manager[i]))\\n                map.put(manager[i], new ArrayList<>());\\n            \\n            map.get(manager[i]).add(i);\\n        }\\n        \\n        LinkedList<Integer> queue = new LinkedList<>();\\n        queue.add(headID);  //add the head\\n        \\n        int[] time = new int[n];\\n        time[headID] = 0;   //head takes 0 time to know the information\\n        int max = 0;\\n        \\n        while(!queue.isEmpty()){\\n            Integer u = queue.poll();\\n            int timetaken = informTime[u];  //time it takes for u to inform\\n            \\n            //traverse only if there are employees reporting to U\\n            if(map.get(u)!=null){\\n                \\n                //take every employee and find how much time it takes to inform\\n                for(Integer v: map.get(u)){\\n                    \\n                    //time[u] is how much time u took? that is v\\'s manager and timetaken-> how much time it takes to inform v\\n                    time[v] = time[u] + timetaken;\\n                    \\n                    //also keep finding the maxTime\\n                    max = Math.max(max, time[v]);\\n                    queue.add(v);\\n                }\\n            }\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1914681,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        int maxTime = 0;\\n        for(int i = 0; i < n; i++) {\\n            maxTime = Math.max(maxTime, dfs(i, informTime, manager));\\n        }\\n        return maxTime;\\n    }\\n    private int dfs(int index, int[] informTime, int[] manager) {\\n        if(manager[index] != -1) {\\n            informTime[index] += dfs(manager[index], informTime, manager);\\n            manager[index] = -1;\\n        } \\n        return informTime[index];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        int maxTime = 0;\\n        for(int i = 0; i < n; i++) {\\n            maxTime = Math.max(maxTime, dfs(i, informTime, manager));\\n        }\\n        return maxTime;\\n    }\\n    private int dfs(int index, int[] informTime, int[] manager) {\\n        if(manager[index] != -1) {\\n            informTime[index] += dfs(manager[index], informTime, manager);\\n            manager[index] = -1;\\n        } \\n        return informTime[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832831,
                "title": "c-bfs",
                "content": "```\\nint numOfMinutes(int n, int head, vector<int>& manager, vector<int>& info) {\\n        vector<int> g[n];\\n        for(int i=0;i<n;i++){\\n            if(manager[i]==-1) continue;\\n            g[manager[i]].push_back(i);\\n        }\\n        queue<int> q;\\n        q.push(head);\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto &child:g[node]){\\n                info[child]+=info[node];\\n                q.push(child);\\n            }\\n        }\\n        int res=0;\\n        for(auto &time:info) res=max(res,time);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numOfMinutes(int n, int head, vector<int>& manager, vector<int>& info) {\\n        vector<int> g[n];\\n        for(int i=0;i<n;i++){\\n            if(manager[i]==-1) continue;\\n            g[manager[i]].push_back(i);\\n        }\\n        queue<int> q;\\n        q.push(head);\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            for(auto &child:g[node]){\\n                info[child]+=info[node];\\n                q.push(child);\\n            }\\n        }\\n        int res=0;\\n        for(auto &time:info) res=max(res,time);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822989,
                "title": "solution-swift-time-needed-to-inform-all-employees",
                "content": "```swift\\nclass Solution {\\n    func numOfMinutes(_ n: Int, _ headID: Int, _ manager: [Int], _ informTime: [Int]) -> Int {\\n        var tree: [Int:[Int]] = [:], maxTime = 0\\n        for i in 0..<n {\\n            let mgr = manager[i]\\n            if tree[mgr] == nil {\\n                tree[mgr] = [i]\\n            } else {\\n                tree[mgr]?.append(i)\\n            }\\n        }\\n        func dfs(_ m: Int, _ t: Int) {\\n            guard let ees = tree[m] else {\\n                maxTime = max(t, maxTime)\\n                return\\n            }\\n            for e in ees { dfs(e, (t + informTime[m])) }\\n        }\\n        dfs(headID, 0)\\n        return maxTime\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 2 tests, with 0 failures (0 unexpected) in 0.008 (0.010) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // The head of the company is the only employee in the company.\\n    func test0() {\\n        let value = solution.numOfMinutes(1, 0, [-1], [0])\\n        XCTAssertEqual(value, 0)\\n    }\\n    \\n    // The head of the company with id = 2 is the direct manager of all the employees\\n    // in the company and needs 1 minute to inform them all.\\n    // The tree structure of the employees in the company is shown.\\n    func test1() {\\n        let value = solution.numOfMinutes(6, 2, [2,2,-1,2,2,2], [0,0,1,0,0,0])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func numOfMinutes(_ n: Int, _ headID: Int, _ manager: [Int], _ informTime: [Int]) -> Int {\\n        var tree: [Int:[Int]] = [:], maxTime = 0\\n        for i in 0..<n {\\n            let mgr = manager[i]\\n            if tree[mgr] == nil {\\n                tree[mgr] = [i]\\n            } else {\\n                tree[mgr]?.append(i)\\n            }\\n        }\\n        func dfs(_ m: Int, _ t: Int) {\\n            guard let ees = tree[m] else {\\n                maxTime = max(t, maxTime)\\n                return\\n            }\\n            for e in ees { dfs(e, (t + informTime[m])) }\\n        }\\n        dfs(headID, 0)\\n        return maxTime\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    // The head of the company is the only employee in the company.\\n    func test0() {\\n        let value = solution.numOfMinutes(1, 0, [-1], [0])\\n        XCTAssertEqual(value, 0)\\n    }\\n    \\n    // The head of the company with id = 2 is the direct manager of all the employees\\n    // in the company and needs 1 minute to inform them all.\\n    // The tree structure of the employees in the company is shown.\\n    func test1() {\\n        let value = solution.numOfMinutes(6, 2, [2,2,-1,2,2,2], [0,0,1,0,0,0])\\n        XCTAssertEqual(value, 1)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1733097,
                "title": "c-solution-with-explanation",
                "content": "```\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        int res = 0;\\n        // let\\'s redefine the meaning of informTime, it means the time stamp all their subordination get the news\\n        // and if a employee i get the news, we will set manager[i] to -1, means they had been informed\\n        // in this way we will use DFS to get the result\\n        for (int i = 0; i < n; i++) {\\n            // check when their subordination will get the news for each employee\\n            res = max(res, employeeInformedTime(i, manager, informTime));\\n        }\\n        return res;\\n    }\\n    \\n    int employeeInformedTime(int index, vector<int>& manager, vector<int>& informTime) {\\n        // if they had been informed, return the time their subordination informed time\\n        if (manager[index] == -1) {\\n            return informTime[index];\\n        }\\n        // if they have not been informed, check when their manager will inform them\\n        // and their subordination will need more time to get the news\\n        informTime[index] += employeeInformedTime(manager[index], manager, informTime);\\n        // informed\\n        manager[index] = -1;\\n        return informTime[index];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        int res = 0;\\n        // let\\'s redefine the meaning of informTime, it means the time stamp all their subordination get the news\\n        // and if a employee i get the news, we will set manager[i] to -1, means they had been informed\\n        // in this way we will use DFS to get the result\\n        for (int i = 0; i < n; i++) {\\n            // check when their subordination will get the news for each employee\\n            res = max(res, employeeInformedTime(i, manager, informTime));\\n        }\\n        return res;\\n    }\\n    \\n    int employeeInformedTime(int index, vector<int>& manager, vector<int>& informTime) {\\n        // if they had been informed, return the time their subordination informed time\\n        if (manager[index] == -1) {\\n            return informTime[index];\\n        }\\n        // if they have not been informed, check when their manager will inform them\\n        // and their subordination will need more time to get the news\\n        informTime[index] += employeeInformedTime(manager[index], manager, informTime);\\n        // informed\\n        manager[index] = -1;\\n        return informTime[index];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1727639,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>>adj(n);\\n        for(int i=0; i<manager.size(); i++)\\n        {\\n            if(manager[i]!=-1)                \\n            adj[manager[i]].push_back(i);\\n        }\\n        \\n        vector<int>time(n,0);\\n        int head=headID;\\n        queue<int>q;\\n        q.push(head);\\n        \\n        while(!q.empty())\\n        {\\n            auto it=q.front();\\n            q.pop();\\n            \\n            for(auto i:adj[it])\\n            {\\n                time[i]=time[it]+informTime[it];\\n                q.push(i);\\n            }\\n        }\\n        \\n        int ans=0;\\n        for(int i=0; i<n; i++)\\n            ans=max(ans,time[i]);\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>>adj(n);\\n        for(int i=0; i<manager.size(); i++)\\n        {\\n            if(manager[i]!=-1)                \\n            adj[manager[i]].push_back(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1503995,
                "title": "c-bfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> graph(n,vector<int>());\\n        for(int i = 0;i < n;i++){\\n            if(manager[i] != -1)\\n                graph[manager[i]].push_back(i);\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({headID,0});\\n        int ans = 0;\\n        while(!q.empty()){\\n            pair<int,int> node = q.front();\\n            int cost = node.second;\\n            int curr = node.first;\\n            q.pop();\\n            ans = max(ans,cost);\\n            for(auto i:graph[curr]){\\n                q.push({i,cost+informTime[curr]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> graph(n,vector<int>());\\n        for(int i = 0;i < n;i++){\\n            if(manager[i] != -1)\\n                graph[manager[i]].push_back(i);\\n        }\\n        queue<pair<int,int>> q;\\n        q.push({headID,0});\\n        int ans = 0;\\n        while(!q.empty()){\\n            pair<int,int> node = q.front();\\n            int cost = node.second;\\n            int curr = node.first;\\n            q.pop();\\n            ans = max(ans,cost);\\n            for(auto i:graph[curr]){\\n                q.push({i,cost+informTime[curr]});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482566,
                "title": "java-easy-approach-with-explanation-dfs-hash-map",
                "content": "```\\nclass Solution\\n{\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) \\n    {\\n        if(informTime.length == 1 )//base case\\n            return informTime[0];\\n        \\n        HashMap<Integer, ArrayList<Integer>> map= new HashMap<>();//manager -- employees\\n        \\n        for(int i= 0; i< manager.length; i++)\\n        {\\n            map.putIfAbsent(manager[i], new ArrayList<Integer>());\\n            \\n            if(manager[i] == -1)\\n                continue;\\n            \\n            ArrayList<Integer> get= map.get(manager[i]);\\n            \\n            get.add(i);//adding employee w.r.t to manager\\n            \\n            map.put(manager[i], get);\\n        }\\n        return dfs(map, informTime, headID);\\n    }\\n    private int dfs(HashMap<Integer, ArrayList<Integer>> map, int[] informTime, int id)\\n    {//going in deapth, and calculating the time \\n\\t\\n        int max= 0;//to store the unique time at each level \\n        if(map.get(id) != null){\\n           for(int subID: map.get(id))\\n                  max= Math.max(max, dfs(map, informTime, subID)+informTime[id]);\\n        }\\n        return max;//time at each level \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) \\n    {\\n        if(informTime.length == 1 )//base case\\n            return informTime[0];\\n        \\n        HashMap<Integer, ArrayList<Integer>> map= new HashMap<>();//manager -- employees\\n        \\n        for(int i= 0; i< manager.length; i++)\\n        {\\n            map.putIfAbsent(manager[i], new ArrayList<Integer>());\\n            \\n            if(manager[i] == -1)\\n                continue;\\n            \\n            ArrayList<Integer> get= map.get(manager[i]);\\n            \\n            get.add(i);//adding employee w.r.t to manager\\n            \\n            map.put(manager[i], get);\\n        }\\n        return dfs(map, informTime, headID);\\n    }\\n    private int dfs(HashMap<Integer, ArrayList<Integer>> map, int[] informTime, int id)\\n    {//going in deapth, and calculating the time \\n\\t\\n        int max= 0;//to store the unique time at each level \\n        if(map.get(id) != null){\\n           for(int subID: map.get(id))\\n                  max= Math.max(max, dfs(map, informTime, subID)+informTime[id]);\\n        }\\n        return max;//time at each level \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389119,
                "title": "python-and-java-bfs-solution",
                "content": "**PYTHON:**\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        graph=defaultdict(list)\\n        for i in range(len(manager)):\\n            if manager[i]!=-1:\\n                graph[manager[i]].append((i,informTime[manager[i]]))\\n        maxTime=0\\n        queue=deque()\\n        queue.append((headID,0))\\n        while queue:\\n            employee,time=queue.popleft()\\n            maxTime=max(time,maxTime)\\n            for sub in graph[employee]:\\n                queue.append((sub[0],sub[1]+time))\\n        return maxTime\\n```\\n**JAVA:**\\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        HashMap<Integer, ArrayList<int[]>> graph = new HashMap<>();\\n        int maxTime = 0;\\n        for (int i = 0; i < manager.length; i++) {\\n            if (!graph.containsKey(manager[i])&& manager[i]!=-1) {\\n                ArrayList<int[]> x= new ArrayList<>();\\n                x.add(new int[] {i,informTime[manager[i]]});\\n                graph.put(manager[i],x);\\n            }\\n            else if(manager[i]!=-1){\\n               graph.get(manager[i]).add(new int[] {i,informTime[manager[i]]});\\n            }\\n                \\n        }\\n        LinkedList<int[]> queue=new LinkedList<>();\\n        queue.add(new int[] {headID,0});\\n        while(!queue.isEmpty()){\\n            int[] empArr=queue.poll();\\n            \\n            if( graph.containsKey(empArr[0]))\\n                for(int[] sub:graph.get(empArr[0]))\\n                    queue.add(new int[] {sub[0],sub[1]+empArr[1]});\\n            else\\n                maxTime=Math.max(maxTime,empArr[1]);\\n        }\\n        return maxTime;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        graph=defaultdict(list)\\n        for i in range(len(manager)):\\n            if manager[i]!=-1:\\n                graph[manager[i]].append((i,informTime[manager[i]]))\\n        maxTime=0\\n        queue=deque()\\n        queue.append((headID,0))\\n        while queue:\\n            employee,time=queue.popleft()\\n            maxTime=max(time,maxTime)\\n            for sub in graph[employee]:\\n                queue.append((sub[0],sub[1]+time))\\n        return maxTime\\n```\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        HashMap<Integer, ArrayList<int[]>> graph = new HashMap<>();\\n        int maxTime = 0;\\n        for (int i = 0; i < manager.length; i++) {\\n            if (!graph.containsKey(manager[i])&& manager[i]!=-1) {\\n                ArrayList<int[]> x= new ArrayList<>();\\n                x.add(new int[] {i,informTime[manager[i]]});\\n                graph.put(manager[i],x);\\n            }\\n            else if(manager[i]!=-1){\\n               graph.get(manager[i]).add(new int[] {i,informTime[manager[i]]});\\n            }\\n                \\n        }\\n        LinkedList<int[]> queue=new LinkedList<>();\\n        queue.add(new int[] {headID,0});\\n        while(!queue.isEmpty()){\\n            int[] empArr=queue.poll();\\n            \\n            if( graph.containsKey(empArr[0]))\\n                for(int[] sub:graph.get(empArr[0]))\\n                    queue.add(new int[] {sub[0],sub[1]+empArr[1]});\\n            else\\n                maxTime=Math.max(maxTime,empArr[1]);\\n        }\\n        return maxTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1381997,
                "title": "simple-java-solution-using-bfs",
                "content": "\\'\\'\\'\\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        // Initiate the graph :\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n\\t\\t// Create the graph : \\n        for(int i=0; i<n; i++){\\n            int mgr = manager[i];\\n            map.putIfAbsent(mgr, new ArrayList());\\n            map.get(mgr).add(i);\\n        }\\n\\t\\t// Start BFS\\n        Queue<Integer> q = new LinkedList();\\n        q.add(headID);\\n        int[] time = new int[n]; // Time array, the ith element of which is the time when the information reaches to the ith person\\n        time[headID] = 0; \\n        while(!q.isEmpty()){\\n            int v = q.poll();\\n            int infoTime = informTime[v];\\n            if(map.get(v) != null){\\n                for(int u : map.get(v)){\\n                    time[u] = time[v] + infoTime;\\n                    q.add(u);\\n                }\\n            }\\n        }\\n\\t\\t// Maximum value of the time array is the total taken time for the information to get reached to every single employee.\\n        int maxTime = 0;\\n        for(int t : time)\\n            maxTime = Math.max(t, maxTime);\\n        return maxTime;\\n    }\\n}\\n```\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        // Initiate the graph :\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n\\t\\t// Create the graph : \\n        for(int i=0; i<n; i++){\\n            int mgr = manager[i];\\n            map.putIfAbsent(mgr, new ArrayList());\\n            map.get(mgr).add(i);\\n        }\\n\\t\\t// Start BFS\\n        Queue<Integer> q = new LinkedList();\\n        q.add(headID);\\n        int[] time = new int[n]; // Time array, the ith element of which is the time when the information reaches to the ith person\\n        time[headID] = 0; \\n        while(!q.isEmpty()){\\n            int v = q.poll();\\n            int infoTime = informTime[v];\\n            if(map.get(v) != null){\\n                for(int u : map.get(v)){\\n                    time[u] = time[v] + infoTime;\\n                    q.add(u);\\n                }\\n            }\\n        }\\n\\t\\t// Maximum value of the time array is the total taken time for the information to get reached to every single employee.\\n        int maxTime = 0;\\n        for(int t : time)\\n            maxTime = Math.max(t, maxTime);\\n        return maxTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147419,
                "title": "intuitive-python-bfs-solution-with-explanation",
                "content": "A first thought one might have when trying to solve this problem is that some employee is going to require the most time until they become informed. The time taken for said employee to be informed is going to be our answer. So first we are going to build this tree stucture. We will do this with the use of a dictionary called `tree`, where `tree` is a mapping from `employee_id` -> list of `subordinates`. Now for the BFS approach we will maintain a queue which will contain tuples of an employees id and the time at which they have been informed. If an employee has subordinates then `employee_id` will be a key for the `tree` and we will add the employees subordinates and time needed to inform said subordinates to the queue. Because we process each and every employee we are guarenteed to find the time taken by the employee who requires the most time to be informed. This time is our answer and we return that.\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        tree = {}\\n        for employee_id, m in enumerate(manager):\\n            if m == -1:\\n                continue\\n            if m not in tree:\\n                tree[m] = [employee_id]\\n            else:\\n                tree[m] += [employee_id]\\n        ans = 0\\n        queue = [(headID, 0)]\\n        while queue:\\n            employee_id, time = queue.pop(0)\\n            ans = max(ans, time)\\n            if employee_id in tree:\\n                for subordinate in tree[employee_id]:\\n                    queue += [(subordinate, time+informTime[employee_id])]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        tree = {}\\n        for employee_id, m in enumerate(manager):\\n            if m == -1:\\n                continue\\n            if m not in tree:\\n                tree[m] = [employee_id]\\n            else:\\n                tree[m] += [employee_id]\\n        ans = 0\\n        queue = [(headID, 0)]\\n        while queue:\\n            employee_id, time = queue.pop(0)\\n            ans = max(ans, time)\\n            if employee_id in tree:\\n                for subordinate in tree[employee_id]:\\n                    queue += [(subordinate, time+informTime[employee_id])]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107349,
                "title": "c-dfs-with-explanation",
                "content": "//Hint - 1) - A manager can convey all it\\'s sub-ordinates in parallel.\\n//(Hint - 2) - Two or more managers can convey all it\\'s sub-ordinates in parallel. So simple summation of //all time will not work.\\n//(Hint - 3) - Think similar to find maximum root to leaf path sum.\\n//(HINT -4)  - since tree is a form of graph, create adjacency listof each node/vertex.\\n```\\n\\nclass Solution {\\nprivate:\\n \\n    vector <int> time;\\n    vector <vector <int> > g;\\n \\nint DFS(int vertex)\\n{\\n    if(g[vertex].size()==0) // leaf node\\n        return 0;\\n    \\n    int ans=0;\\n    \\n    for(auto i=g[vertex].begin();i!=g[vertex].end();i++) // iterate for adjacency list of each vertex\\n    {\\n        ans=max(ans,time[vertex]+DFS(*i));\\n    }\\n    \\n    return ans;\\n}\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) \\n    {\\n        g.resize(n);\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(manager[i]==-1)\\n            continue;\\n            \\n            g[manager[i]].push_back(i);\\n        }\\n        \\n        time=informTime;\\n        \\n        return DFS(headID);\\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\nprivate:\\n \\n    vector <int> time;\\n    vector <vector <int> > g;\\n \\nint DFS(int vertex)\\n{\\n    if(g[vertex].size()==0) // leaf node\\n        return 0;\\n    \\n    int ans=0;\\n    \\n    for(auto i=g[vertex].begin();i!=g[vertex].end();i++) // iterate for adjacency list of each vertex\\n    {\\n        ans=max(ans,time[vertex]+DFS(*i));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1044726,
                "title": "java-top-down-dfs-o-n",
                "content": "\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n\\n\\t\\tList<Integer>[] tree = new ArrayList[n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\ttree[i] = new ArrayList<Integer>();\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (manager[i] != -1)\\n\\t\\t\\t\\ttree[manager[i]].add(i);\\n\\t\\t}\\n\\n\\t\\treturn MinutesToInform(headID, informTime, tree);\\n\\t}\\n\\n\\tpublic int MinutesToInform(int curr, int[] informTime, List<Integer>[] tree) {\\n\\n\\t\\tList<Integer> emps = tree[curr];\\n\\t\\tint max = 0;\\n\\t\\tfor (int emp : emps)\\n\\t\\t\\tmax = Math.max(max, MinutesToInform(emp, informTime, tree));\\n\\t\\treturn max + informTime[curr];\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n\\n\\t\\tList<Integer>[] tree = new ArrayList[n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\ttree[i] = new ArrayList<Integer>();\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (manager[i] != -1)\\n\\t\\t\\t\\ttree[manager[i]].add(i);\\n\\t\\t}\\n\\n\\t\\treturn MinutesToInform(headID, informTime, tree);\\n\\t}\\n\\n\\tpublic int MinutesToInform(int curr, int[] informTime, List<Integer>[] tree) {\\n\\n\\t\\tList<Integer> emps = tree[curr];\\n\\t\\tint max = 0;\\n\\t\\tfor (int emp : emps)\\n\\t\\t\\tmax = Math.max(max, MinutesToInform(emp, informTime, tree));\\n\\t\\treturn max + informTime[curr];\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 963347,
                "title": "c-dfs-with-hints",
                "content": "**(Hint - 1)**  - A manager can convey all it\\'s sub-ordinates in parallel.\\n**(Hint - 2)**  - Two or more managers can convey all it\\'s sub-ordinates in parallel. So simple summation of all time will not work.\\n**(Hint - 3)**  - Think similar to find maximum root to leaf path sum.\\n\\n```\\nclass Solution {\\nprivate:\\n    vector<int> t;\\n    vector<vector<int>> g;\\n    \\n    int DFS(int vertex)\\n    {\\n        if(!g[vertex].size()) return 0;\\n        \\n        int ans = 0;\\n        for(int x : g[vertex]) {\\n            ans = max(ans, t[vertex] + DFS(x));\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) \\n    {\\n        g.resize(n);\\n        for(int i = 0 ; i < n ; ++i) {\\n            if(manager[i] == -1) continue;\\n            g[manager[i]].push_back(i);\\n        }\\n        t = informTime;\\n        return DFS(headID);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> t;\\n    vector<vector<int>> g;\\n    \\n    int DFS(int vertex)\\n    {\\n        if(!g[vertex].size()) return 0;\\n        \\n        int ans = 0;\\n        for(int x : g[vertex]) {\\n            ans = max(ans, t[vertex] + DFS(x));\\n        }\\n        return ans;\\n    }\\n    \\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) \\n    {\\n        g.resize(n);\\n        for(int i = 0 ; i < n ; ++i) {\\n            if(manager[i] == -1) continue;\\n            g[manager[i]].push_back(i);\\n        }\\n        t = informTime;\\n        return DFS(headID);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 872931,
                "title": "java-straightforward-dfs",
                "content": "```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < manager.length; i++) {\\n            int tmp = manager[i]; // manager\\n            if (tmp == -1) continue;\\n            if (!map.containsKey(tmp)) {\\n                map.put(tmp, new ArrayList<>());\\n            }\\n            map.get(tmp).add(i);\\n        }\\n        dfs(headID, informTime, 0, map);\\n        return max;\\n        \\n    }\\n    \\n    private void dfs(int id, int[] time, int sum, Map<Integer, List<Integer>> map) {// Here time is how long takes for id to be notified\\n    \\n        // if no subordinates\\n        if (!map.containsKey(id)) {\\n            max = Math.max(max, sum);\\n            return;\\n        }\\n        \\n        for (int employee : map.get(id)) {\\n            dfs(employee, time, sum + time[id], map);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = Integer.MIN_VALUE;\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < manager.length; i++) {\\n            int tmp = manager[i]; // manager\\n            if (tmp == -1) continue;\\n            if (!map.containsKey(tmp)) {\\n                map.put(tmp, new ArrayList<>());\\n            }\\n            map.get(tmp).add(i);\\n        }\\n        dfs(headID, informTime, 0, map);\\n        return max;\\n        \\n    }\\n    \\n    private void dfs(int id, int[] time, int sum, Map<Integer, List<Integer>> map) {// Here time is how long takes for id to be notified\\n    \\n        // if no subordinates\\n        if (!map.containsKey(id)) {\\n            max = Math.max(max, sum);\\n            return;\\n        }\\n        \\n        for (int employee : map.get(id)) {\\n            dfs(employee, time, sum + time[id], map);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 823699,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n     \\n        //Intuition BFS should provide the answer.\\n        \\n        //Create Graph \\n        vector<vector<int>> hmap(n, vector<int>());\\n        for(int i = 0; i < manager.size(); i++)\\n        {\\n            if(manager[i] != -1)\\n                hmap[manager[i]].push_back(i);\\n        }\\n            \\n    \\n        int total = 0;\\n        queue<int> q;\\n        q.push(headID);\\n        \\n        while(q.size())\\n        {\\n            int f = q.front();\\n            q.pop();\\n\\n            for(auto& e: hmap[f])\\n            {\\n                //Add managers time to child\\'s informTime.\\n                informTime[e] += informTime[f];\\n                q.push(e);\\n            }\\n        }\\n\\n        //Iterate through all employees and get the maximum informTime.\\n        //BTW. Max informTime should be found from the leaf nodes(non managers).\\n        for(auto& i: informTime)\\n            total = max(total,i);\\n        \\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n     \\n        //Intuition BFS should provide the answer.\\n        \\n        //Create Graph \\n        vector<vector<int>> hmap(n, vector<int>());\\n        for(int i = 0; i < manager.size(); i++)\\n        {\\n            if(manager[i] != -1)\\n                hmap[manager[i]].push_back(i);\\n        }\\n            \\n    \\n        int total = 0;\\n        queue<int> q;\\n        q.push(headID);\\n        \\n        while(q.size())\\n        {\\n            int f = q.front();\\n            q.pop();\\n\\n            for(auto& e: hmap[f])\\n            {\\n                //Add managers time to child\\'s informTime.\\n                informTime[e] += informTime[f];\\n                q.push(e);\\n            }\\n        }\\n\\n        //Iterate through all employees and get the maximum informTime.\\n        //BTW. Max informTime should be found from the leaf nodes(non managers).\\n        for(auto& i: informTime)\\n            total = max(total,i);\\n        \\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760247,
                "title": "java-dfs",
                "content": "DFS without using adjacency list [ Time limit exceeded]\\n```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        int max = 0;\\n        for(int i=0;i<n;i++){\\n            if(headID != manager[i]) continue;\\n            int temp = numOfMinutes(n,i,manager,informTime);\\n            if(max<temp) max = temp;\\n        }\\n        return max + informTime[headID];\\n    }\\n}\\n```\\n\\nDFS with adjacency list [Accepted] \\n```\\nclass Solution {\\n    List<List<Integer>> graph; // Note if we do not use adjacency list, then we need to traverse entire array for every dfs call which is very time inefficient\\n    int dfs(List<Integer> u, int[] informTime){\\n         int max = 0;\\n         for(int v : u){\\n            int temp = dfs(graph.get(v),informTime) + informTime[v];\\n            if(max<temp) max = temp;\\n        }\\n        return max;\\n    }\\n    \\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        graph = new ArrayList<>();\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());\\n        for(int i=0;i<n;i++){\\n            if(manager[i] == -1) continue;\\n            graph.get(manager[i]).add(i); // make connection from top to down in a tree structure\\n        }\\n        return dfs(graph.get(headID),informTime) + informTime[headID];\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        int max = 0;\\n        for(int i=0;i<n;i++){\\n            if(headID != manager[i]) continue;\\n            int temp = numOfMinutes(n,i,manager,informTime);\\n            if(max<temp) max = temp;\\n        }\\n        return max + informTime[headID];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    List<List<Integer>> graph; // Note if we do not use adjacency list, then we need to traverse entire array for every dfs call which is very time inefficient\\n    int dfs(List<Integer> u, int[] informTime){\\n         int max = 0;\\n         for(int v : u){\\n            int temp = dfs(graph.get(v),informTime) + informTime[v];\\n            if(max<temp) max = temp;\\n        }\\n        return max;\\n    }\\n    \\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        graph = new ArrayList<>();\\n        for(int i=0;i<n;i++) graph.add(new ArrayList<>());\\n        for(int i=0;i<n;i++){\\n            if(manager[i] == -1) continue;\\n            graph.get(manager[i]).add(i); // make connection from top to down in a tree structure\\n        }\\n        return dfs(graph.get(headID),informTime) + informTime[headID];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685155,
                "title": "yet-another-python-solution",
                "content": "Simple DFS\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        \\n        tree = defaultdict(list)\\n        for i, man in enumerate(manager):\\n            tree[man].append(i)\\n        \\n        \\n        res  = 0\\n        stack = [(headID,informTime[headID])]\\n        while stack:\\n            node,cost = stack.pop(0)\\n            res = max(res,cost)\\n            for nei in tree[node]:\\n                stack.append((nei,cost + informTime[nei]))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        \\n        tree = defaultdict(list)\\n        for i, man in enumerate(manager):\\n            tree[man].append(i)\\n        \\n        \\n        res  = 0\\n        stack = [(headID,informTime[headID])]\\n        while stack:\\n            node,cost = stack.pop(0)\\n            res = max(res,cost)\\n            for nei in tree[node]:\\n                stack.append((nei,cost + informTime[nei]))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673643,
                "title": "javascript-dfs-hashmap",
                "content": "```\\nvar numOfMinutes = function(n, headID, manager, informTime) {\\n  if (n <= 0) return 0;\\n  let map = new Map();\\n  manager.forEach((m, e) => {\\n    if(m > -1) map.set(m, [...(map.get(m) || []), e])\\n  })\\n \\n  \\n   function calTime(node){\\n    let time = 0;\\n     if(map.has(node)){\\n       const subs = map.get(node);\\n       for(let i = 0; i < subs.length; i++){\\n          time = Math.max(time, informTime[node] + calTime(subs[i]))\\n       }\\n     }\\n     return time;\\n    }\\n\\n   return calTime(headID)\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numOfMinutes = function(n, headID, manager, informTime) {\\n  if (n <= 0) return 0;\\n  let map = new Map();\\n  manager.forEach((m, e) => {\\n    if(m > -1) map.set(m, [...(map.get(m) || []), e])\\n  })\\n \\n  \\n   function calTime(node){\\n    let time = 0;\\n     if(map.has(node)){\\n       const subs = map.get(node);\\n       for(let i = 0; i < subs.length; i++){\\n          time = Math.max(time, informTime[node] + calTime(subs[i]))\\n       }\\n     }\\n     return time;\\n    }\\n\\n   return calTime(headID)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 628831,
                "title": "easy-to-understand-bfs-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        \\n        if(n==1) return 0;        \\n        \\n        //construct child graph\\n        vector<vector<int>> graph(n, vector<int>()); /// adjacency list\\n        \\n        for(int i=0; i<manager.size(); ++i){\\n            if(manager[i]!=-1)\\n                graph[manager[i]].push_back(i);\\n        }\\n        \\n        queue<pair<int, int>> q; // contains pair<node index, cost to inform this node>\\n        \\n        vector<int> cost(n, 0);\\n        \\n        q.push(make_pair(headID, 0));\\n        \\n        // start BFS\\n        while(!q.empty()){\\n            \\n            pair<int, int> value = q.front();\\n            q.pop();\\n            \\n            int parent_node = value.first;\\n            int cc = value.second;\\n            \\n            // iterate through children\\n            for(int i:graph[parent_node]){\\n                cost[i] = cc + informTime[parent_node];\\n                if(informTime[i]!=0)\\n                    q.push(make_pair(i, cost[i]));\\n            }\\n        }\\n        \\n        return *max_element(cost.begin(), cost.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        \\n        if(n==1) return 0;        \\n        \\n        //construct child graph\\n        vector<vector<int>> graph(n, vector<int>()); /// adjacency list\\n        \\n        for(int i=0; i<manager.size(); ++i){\\n            if(manager[i]!=-1)\\n                graph[manager[i]].push_back(i);\\n        }\\n        \\n        queue<pair<int, int>> q; // contains pair<node index, cost to inform this node>\\n        \\n        vector<int> cost(n, 0);\\n        \\n        q.push(make_pair(headID, 0));\\n        \\n        // start BFS\\n        while(!q.empty()){\\n            \\n            pair<int, int> value = q.front();\\n            q.pop();\\n            \\n            int parent_node = value.first;\\n            int cc = value.second;\\n            \\n            // iterate through children\\n            for(int i:graph[parent_node]){\\n                cost[i] = cc + informTime[parent_node];\\n                if(informTime[i]!=0)\\n                    q.push(make_pair(i, cost[i]));\\n            }\\n        }\\n        \\n        return *max_element(cost.begin(), cost.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 582892,
                "title": "classic-bfs-in-java",
                "content": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        for (int i = 0; i < manager.length; i++) {\\n            if (manager[i] == -1) {\\n                continue;\\n            }\\n            map.get(manager[i]).add(i);\\n        }\\n        int max = 0;\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{headID, informTime[headID]});\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] cur = queue.poll();\\n                max = Math.max(max, cur[1]);\\n                for (int next : map.get(cur[0])) {\\n                    queue.offer(new int[]{next, cur[1] + informTime[next]});\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        for (int i = 0; i < manager.length; i++) {\\n            if (manager[i] == -1) {\\n                continue;\\n            }\\n            map.get(manager[i]).add(i);\\n        }\\n        int max = 0;\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{headID, informTime[headID]});\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i = 0; i < size; i++) {\\n                int[] cur = queue.poll();\\n                max = Math.max(max, cur[1]);\\n                for (int next : map.get(cur[0])) {\\n                    queue.offer(new int[]{next, cur[1] + informTime[next]});\\n                }\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 543724,
                "title": "rust-24ms-dfs",
                "content": "```rust\\nimpl Solution {\\n  pub fn num_of_minutes(n: i32, head_id: i32, manager: Vec<i32>, inform_time: Vec<i32>) -> i32 {\\n    let mut m = manager;\\n    let mut t = inform_time;\\n    (0..n)\\n      .map(|i| Self::dfs(i as usize, &mut m, &mut t))\\n      .max()\\n      .unwrap()\\n  }\\n\\n  fn dfs(i: usize, m: &mut Vec<i32>, t: &mut Vec<i32>) -> i32 {\\n    if m[i] != -1 {\\n      t[i] += Self::dfs(m[i] as usize, m, t);\\n      m[i] = -1;\\n    }\\n    t[i]\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```rust\\nimpl Solution {\\n  pub fn num_of_minutes(n: i32, head_id: i32, manager: Vec<i32>, inform_time: Vec<i32>) -> i32 {\\n    let mut m = manager;\\n    let mut t = inform_time;\\n    (0..n)\\n      .map(|i| Self::dfs(i as usize, &mut m, &mut t))\\n      .max()\\n      .unwrap()\\n  }\\n\\n  fn dfs(i: usize, m: &mut Vec<i32>, t: &mut Vec<i32>) -> i32 {\\n    if m[i] != -1 {\\n      t[i] += Self::dfs(m[i] as usize, m, t);\\n      m[i] = -1;\\n    }\\n    t[i]\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 535786,
                "title": "python-3-o-n-time-o-1n-space-dfs-memo-1160ms",
                "content": "Idea:\\n1. Traverse from keyboard warriors (poor employees who get informed last of any emergency). \\n\\t\\tSo this means traversing from leaf node instead of from headID, because then we can utilize the subordinate->manager list instead of creating a manager->subordinate dictionary. \\n2. Returning from DFS, we modify informTime to store the time it takes to get to the main manager. This means informTime acts as a memo. We modify manager to indicate the next time we come back to this employee, we know that we need to use our memo.\\n\\nThis solution came about incrementally -- I started with creating an O(n) memo first and then got here.  So maybe you could start from there! Good luck!!\\nSolution 0:\\nO(n) time and space with explicit memo\\n```\\n        if n == 1:\\n            return 0\\n        memo = [-1] * n\\n        def dfs(leader):\\n            if memo[leader] != -1:\\n                return memo[leader]\\n            if leader == headID:\\n                return informTime[headID]\\n            time = dfs(manager[leader])\\n            memo[leader] = informTime[leader] + time\\n            return memo[leader]\\n                       \\n        employees = []\\n        for i in range(n):\\n            if not informTime[i]:\\n                employees.append(i)       \\n        \\n        maxx = 0\\n        for e in employees:\\n            maxx = max(dfs(e), maxx)\\n        return maxx\\n```\\n\\n\\nSolution 1:\\nO(n) time and space\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        def dfs(leader):\\n            if manager[leader] == -1:\\n                return informTime[leader]\\n            informTime[leader] += dfs(manager[leader])\\n            manager[leader] = -1\\n            return informTime[leader]\\n                       \\n        keyboardWarriors = []\\n        for i in range(n):\\n            if not informTime[i]:\\n                keyboardWarriors.append(i)       \\n        \\n        maxTime = 0\\n        for i in keyboardWarriors:\\n            maxTime = max(dfs(i), maxTime)\\n        return maxTime\\n        \\n    \\n```\\n\\nSolution 2:\\nO(n) time O(1) space (if ignoring call stack) \\nActually can we call this O(1)? I\\'m not sure, school me please.\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        def dfs(leader):\\n            if manager[leader] == -1:\\n                return informTime[leader]\\n            informTime[leader] += dfs(manager[leader])\\n            manager[leader] = -1\\n            return informTime[leader]\\n                         \\n        maxTime = 0\\n        for i in range(n):\\n            maxTime = max(dfs(i), maxTime)\\n        return maxTime\\n```\\n\\nSolution 3:\\nO(n) time O(n) space, by my brother. Faster than LRU cache solutions.\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        def dfs(leader):\\n            if manager[leader] < 0:\\n                return informTime[leader]\\n            informTime[leader] += dfs(manager[leader])\\n            manager[leader] = -2\\n            return informTime[leader]\\n                         \\n        maxTime = 0\\n        for i in range(n):\\n\\t\\t\\tif manager[manager[i]] > -2:\\n\\t\\t\\t\\tif not informTime[i]:\\n                    maxTime = max(dfs(i), maxTime)\\n        return maxTime\\n```",
                "solutionTags": [],
                "code": "```\\n        if n == 1:\\n            return 0\\n        memo = [-1] * n\\n        def dfs(leader):\\n            if memo[leader] != -1:\\n                return memo[leader]\\n            if leader == headID:\\n                return informTime[headID]\\n            time = dfs(manager[leader])\\n            memo[leader] = informTime[leader] + time\\n            return memo[leader]\\n                       \\n        employees = []\\n        for i in range(n):\\n            if not informTime[i]:\\n                employees.append(i)       \\n        \\n        maxx = 0\\n        for e in employees:\\n            maxx = max(dfs(e), maxx)\\n        return maxx\\n```\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        def dfs(leader):\\n            if manager[leader] == -1:\\n                return informTime[leader]\\n            informTime[leader] += dfs(manager[leader])\\n            manager[leader] = -1\\n            return informTime[leader]\\n                       \\n        keyboardWarriors = []\\n        for i in range(n):\\n            if not informTime[i]:\\n                keyboardWarriors.append(i)       \\n        \\n        maxTime = 0\\n        for i in keyboardWarriors:\\n            maxTime = max(dfs(i), maxTime)\\n        return maxTime\\n        \\n    \\n```\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        def dfs(leader):\\n            if manager[leader] == -1:\\n                return informTime[leader]\\n            informTime[leader] += dfs(manager[leader])\\n            manager[leader] = -1\\n            return informTime[leader]\\n                         \\n        maxTime = 0\\n        for i in range(n):\\n            maxTime = max(dfs(i), maxTime)\\n        return maxTime\\n```\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        def dfs(leader):\\n            if manager[leader] < 0:\\n                return informTime[leader]\\n            informTime[leader] += dfs(manager[leader])\\n            manager[leader] = -2\\n            return informTime[leader]\\n                         \\n        maxTime = 0\\n        for i in range(n):\\n\\t\\t\\tif manager[manager[i]] > -2:\\n\\t\\t\\t\\tif not informTime[i]:\\n                    maxTime = max(dfs(i), maxTime)\\n        return maxTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534572,
                "title": "python-bfs",
                "content": "```\\ndef numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        graph = collections.defaultdict(list)\\n        head = manager.index(-1)\\n        for emp,man in enumerate(manager):\\n            graph[man].append(emp)\\n        q = collections.deque()\\n        q.append((head,0))\\n        maxT=0\\n        while q:\\n            for i in range(len(q)):\\n                emp,t = q.popleft()\\n                maxT=max(maxT, t)\\n                for nei in graph[emp]:\\n                    neiT=informTime[emp]+t\\n                    q.append((nei,neiT))\\n        return maxT\\n```",
                "solutionTags": [],
                "code": "```\\ndef numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        graph = collections.defaultdict(list)\\n        head = manager.index(-1)\\n        for emp,man in enumerate(manager):\\n            graph[man].append(emp)\\n        q = collections.deque()\\n        q.append((head,0))\\n        maxT=0\\n        while q:\\n            for i in range(len(q)):\\n                emp,t = q.popleft()\\n                maxT=max(maxT, t)\\n                for nei in graph[emp]:\\n                    neiT=informTime[emp]+t\\n                    q.append((nei,neiT))\\n        return maxT\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 534379,
                "title": "a-few-solutions",
                "content": "Return the accumulated maximum `cost` of any root-to-leaf path, ie. we create an adjacency list `adj` of parent-to-child associations from the input child-to-parent associations `P` and return the maximum `cost` accumulated as the recursive stack unwinds.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun numOfMinutes(N: Int, root: Int, P: IntArray, cost: IntArray): Int {\\n        var adj = mutableMapOf<Int, MutableSet<Int>>()\\n        for ((i, x) in P.withIndex()) {\\n            if (!adj.contains(x))\\n                adj[x] = mutableSetOf<Int>()\\n            adj[x]!!.add(i)\\n        }\\n        fun go(i: Int = root): Int { return if (adj.contains(i)) cost[i] + adj[i]!!.map{ go(it) }.max()!! else 0 }\\n        return go()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet numOfMinutes = (N, root, P, cost) => {\\n    let adj = new Map(_.range(-1, N).map(i => [i, []]));\\n    for (let i = 0; i < P.length; ++i)\\n        adj.get(P[i]).push(i);\\n    let go = (i = root) => adj.get(i).length ? cost[i] + Math.max(...adj.get(i).map(j => go(j))) : 0;\\n    return go();\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution: \\n    def numOfMinutes(self, N: int, root: int, P: List[int], cost: List[int]) -> int:\\n        adj = defaultdict(set)\\n        for i, x in enumerate(P):\\n            adj[x].add(i)\\n        go = lambda i: cost[i] + max(go(j) for j in adj[i]) if len(adj[i]) else 0\\n        return go(root)\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nuse std::collections::{HashMap};\\ntype Map = HashMap::<i32, VI>;\\nimpl Solution {\\n    pub fn num_of_minutes(N: i32, root: i32, P: VI, cost: VI) -> i32 {\\n        let mut adj = HashMap::new();\\n        for (i, x) in P.into_iter().enumerate() {\\n            adj.entry(x).or_insert(vec![]).push(i as i32);\\n        }\\n        fn go(adj: &Map, i: i32, cost: &VI) -> i32 {\\n            if adj.contains_key(&i) { cost[i as usize] + adj.get(&i).unwrap().iter().map(|j| go(adj, *j, cost)).max().unwrap() } else { 0 }\\n        }\\n        go(&adj, root, &cost)\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Set = unordered_set<int>;\\n    using Map = unordered_map<int, Set>;\\n    int numOfMinutes(int N, int root, VI& P, VI& cost, Map adj = {}) {\\n        for (auto i{ 0 }; i < P.size(); ++i)\\n            adj[P[i]].insert(i);\\n        fun go = [&](auto i) {\\n            auto best = 0;\\n            for (auto j: adj[i])\\n                best = max(best, go(j));\\n            return adj[i].size() ? cost[i] + best : 0;\\n        };\\n        return go(root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun numOfMinutes(N: Int, root: Int, P: IntArray, cost: IntArray): Int {\\n        var adj = mutableMapOf<Int, MutableSet<Int>>()\\n        for ((i, x) in P.withIndex()) {\\n            if (!adj.contains(x))\\n                adj[x] = mutableSetOf<Int>()\\n            adj[x]!!.add(i)\\n        }\\n        fun go(i: Int = root): Int { return if (adj.contains(i)) cost[i] + adj[i]!!.map{ go(it) }.max()!! else 0 }\\n        return go()\\n    }\\n}\\n```\n```\\nlet numOfMinutes = (N, root, P, cost) => {\\n    let adj = new Map(_.range(-1, N).map(i => [i, []]));\\n    for (let i = 0; i < P.length; ++i)\\n        adj.get(P[i]).push(i);\\n    let go = (i = root) => adj.get(i).length ? cost[i] + Math.max(...adj.get(i).map(j => go(j))) : 0;\\n    return go();\\n};\\n```\n```\\nclass Solution: \\n    def numOfMinutes(self, N: int, root: int, P: List[int], cost: List[int]) -> int:\\n        adj = defaultdict(set)\\n        for i, x in enumerate(P):\\n            adj[x].add(i)\\n        go = lambda i: cost[i] + max(go(j) for j in adj[i]) if len(adj[i]) else 0\\n        return go(root)\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::collections::{HashMap};\\ntype Map = HashMap::<i32, VI>;\\nimpl Solution {\\n    pub fn num_of_minutes(N: i32, root: i32, P: VI, cost: VI) -> i32 {\\n        let mut adj = HashMap::new();\\n        for (i, x) in P.into_iter().enumerate() {\\n            adj.entry(x).or_insert(vec![]).push(i as i32);\\n        }\\n        fn go(adj: &Map, i: i32, cost: &VI) -> i32 {\\n            if adj.contains_key(&i) { cost[i as usize] + adj.get(&i).unwrap().iter().map(|j| go(adj, *j, cost)).max().unwrap() } else { 0 }\\n        }\\n        go(&adj, root, &cost)\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using fun = function<int(int)>;\\n    using Set = unordered_set<int>;\\n    using Map = unordered_map<int, Set>;\\n    int numOfMinutes(int N, int root, VI& P, VI& cost, Map adj = {}) {\\n        for (auto i{ 0 }; i < P.size(); ++i)\\n            adj[P[i]].insert(i);\\n        fun go = [&](auto i) {\\n            auto best = 0;\\n            for (auto j: adj[i])\\n                best = max(best, go(j));\\n            return adj[i].size() ? cost[i] + best : 0;\\n        };\\n        return go(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533230,
                "title": "dew-it-very-fast-only-primitives",
                "content": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int h, int[] manager, int[] times) {\\n        int[] count = new int[n];\\n        for(int x: manager) { if(x != -1) ++count[x]; }\\n        int[][] children = new int[n][];\\n        for(int i=0; i<n; ++i) {\\n            children[i] = new int[count[i]];\\n            count[i] = 0;\\n        }\\n        for(int i=0; i<n; ++i) {\\n            int m = manager[i];\\n            if(m != -1) children[m][count[m]++] = i;\\n        }\\n        return get(children, times, h);\\n    }\\n    \\n    private int get(int[][] children, int[] times, int t) {\\n        int ans = 0;\\n        if(children[t].length > 0) {\\n            for(int x: children[t]) ans = Math.max(ans, get(children, times, x));\\n            ans += times[t];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int h, int[] manager, int[] times) {\\n        int[] count = new int[n];\\n        for(int x: manager) { if(x != -1) ++count[x]; }\\n        int[][] children = new int[n][];\\n        for(int i=0; i<n; ++i) {\\n            children[i] = new int[count[i]];\\n            count[i] = 0;\\n        }\\n        for(int i=0; i<n; ++i) {\\n            int m = manager[i];\\n            if(m != -1) children[m][count[m]++] = i;\\n        }\\n        return get(children, times, h);\\n    }\\n    \\n    private int get(int[][] children, int[] times, int t) {\\n        int ans = 0;\\n        if(children[t].length > 0) {\\n            for(int x: children[t]) ans = Math.max(ans, get(children, times, x));\\n            ans += times[t];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533045,
                "title": "python-bottom-up-bfs-dp-no-need-to-reverse-edges",
                "content": "```python\\ndef numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        maxsub = [0] * n\\n        level = set(range(n)) - set(manager)\\n        head = { headID }\\n        \\n        while not level == head:   \\n\\t\\t# wrong:  while not head in level      \\n            nextlevel = set()\\n            for sub in level:\\n                leader = manager[sub]\\n                if leader == -1: continue\\n                nextlevel.add( leader )\\n                maxsub[leader] = max( maxsub[leader], informTime[sub] + maxsub[sub] )\\n                # Notice: when update bottom-up, a node can have branches with varied depth, it will be updated in multiple \"level\"\\n            level = nextlevel\\n            \\n        return informTime[headID] + maxsub[headID]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```python\\ndef numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        maxsub = [0] * n\\n        level = set(range(n)) - set(manager)\\n        head = { headID }\\n        \\n        while not level == head:   \\n\\t\\t# wrong:  while not head in level      \\n            nextlevel = set()\\n            for sub in level:\\n                leader = manager[sub]\\n                if leader == -1: continue\\n                nextlevel.add( leader )\\n                maxsub[leader] = max( maxsub[leader], informTime[sub] + maxsub[sub] )\\n                # Notice: when update bottom-up, a node can have branches with varied depth, it will be updated in multiple \"level\"\\n            level = nextlevel\\n            \\n        return informTime[headID] + maxsub[headID]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 532724,
                "title": "simple-dfs-with-comments-beats-100",
                "content": "The idea here is to do a simple DFS to find the longest time to reach the employees who does not have any reports. First build a manager to reports dictionary and store the manager to reports lists. Start at the head and follow all the paths. Complexity O(n).\\n\\n```\\npublic class Solution {\\n    int maxMinutes = 0;\\n    public int NumOfMinutes(int n, int headID, int[] manager, int[] informTime) \\n    {\\n        Dictionary<int, List<int>> mtoreports = new Dictionary<int, List<int>>();\\n        for(int i=0; i < manager.Length;i++)\\n        {\\n            if(!mtoreports.ContainsKey(manager[i]))\\n            {\\n                mtoreports[manager[i]] = new List<int>();    \\n            }\\n            mtoreports[manager[i]].Add(i);\\n        }\\n        \\n        DFS(mtoreports, headID, 0, informTime);\\n        return maxMinutes;\\n    }\\n    \\n    void DFS(Dictionary<int, List<int>> mtoreports, int mgr, int time, int[] informTime)\\n    {\\n        var mgrTime = informTime[mgr];\\n        if(mgrTime == 0)\\n        {\\n            maxMinutes = Math.Max(time, maxMinutes);\\n            return;\\n        }\\n        \\n        time+=mgrTime;\\n        foreach(var item in mtoreports[mgr])\\n        {\\n            DFS(mtoreports, item, time, informTime);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    int maxMinutes = 0;\\n    public int NumOfMinutes(int n, int headID, int[] manager, int[] informTime) \\n    {\\n        Dictionary<int, List<int>> mtoreports = new Dictionary<int, List<int>>();\\n        for(int i=0; i < manager.Length;i++)\\n        {\\n            if(!mtoreports.ContainsKey(manager[i]))\\n            {\\n                mtoreports[manager[i]] = new List<int>();    \\n            }\\n            mtoreports[manager[i]].Add(i);\\n        }\\n        \\n        DFS(mtoreports, headID, 0, informTime);\\n        return maxMinutes;\\n    }\\n    \\n    void DFS(Dictionary<int, List<int>> mtoreports, int mgr, int time, int[] informTime)\\n    {\\n        var mgrTime = informTime[mgr];\\n        if(mgrTime == 0)\\n        {\\n            maxMinutes = Math.Max(time, maxMinutes);\\n            return;\\n        }\\n        \\n        time+=mgrTime;\\n        foreach(var item in mtoreports[mgr])\\n        {\\n            DFS(mtoreports, item, time, informTime);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532680,
                "title": "python3-dfs-recursively-iteratively",
                "content": "Algorithm: \\nDFS traverse the tree and return the maximum time used from root to one leaf. \\n\\nRecursively implementation: \\n\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        subordinate = dict() #employee tree\\n        for i, m in enumerate(manager): subordinate.setdefault(m, []).append(i) \\n        \\n        def dfs(node): \\n            return informTime[node] + max((dfs(n) for n in subordinate.get(node, [])), default=0)\\n        \\n        return dfs(headID)\\n```\\n\\nIteratively implementation:\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        subordinate = dict() #employee tree\\n        for i, m in enumerate(manager): subordinate.setdefault(m, []).append(i) \\n        \\n        ans = 0\\n        stack = [(headID, 0)] #id-time\\n        while stack: #dfs \\n            i, t = stack.pop()\\n            ans = max(ans, t)\\n            for ii in subordinate.get(i, []): stack.append((ii, t + informTime[i]))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        subordinate = dict() #employee tree\\n        for i, m in enumerate(manager): subordinate.setdefault(m, []).append(i) \\n        \\n        def dfs(node): \\n            return informTime[node] + max((dfs(n) for n in subordinate.get(node, [])), default=0)\\n        \\n        return dfs(headID)\\n```\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        subordinate = dict() #employee tree\\n        for i, m in enumerate(manager): subordinate.setdefault(m, []).append(i) \\n        \\n        ans = 0\\n        stack = [(headID, 0)] #id-time\\n        while stack: #dfs \\n            i, t = stack.pop()\\n            ans = max(ans, t)\\n            for ii in subordinate.get(i, []): stack.append((ii, t + informTime[i]))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 532645,
                "title": "c-python3-dfs-to-find-longest-path",
                "content": "Given a weighted tree, calculate the longest path from root to leaves.\\n\\n# Explanation\\n\\nUse DFS or BFS and record the length of the path on the way.\\n\\n# C++ Solution\\n\\n```cpp\\nclass Solution {\\n    int maxTime = -1;\\n    vector<vector<pair<int, int>>> g; // employee, time\\n    \\n    void dfs(int u, int time) {\\n        maxTime = max(maxTime, time);\\n        for (int i = 0; i < g[u].size(); i++)\\n            dfs(g[u][i].first, time + g[u][i].second);\\n    }\\n    \\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        g = vector<vector<pair<int, int>>>(n, vector<pair<int, int>>());\\n        for (int i = 0; i < n; i++) {\\n            if (manager[i] != -1)\\n                g[manager[i]].emplace_back(i, informTime[manager[i]]);\\n        }\\n        \\n        dfs(headID, 0);\\n        return maxTime;\\n    }\\n};\\n```\\n\\n# Python3\\n\\n```python\\nclass Solution:\\n    \\n    def dfs(self, u: int, time: int):\\n        self.maxTime = max(self.maxTime, time)\\n        for v, e in self.g[u]:\\n            self.dfs(v, time + e)\\n    \\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        self.maxTime = -1\\n        self.g = [[] for _ in range(n)]\\n        for i in range(n):\\n            if manager[i] != -1:\\n                self.g[manager[i]].append((i, informTime[manager[i]]))\\n        self.dfs(headID, 0)\\n        return self.maxTime\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n    int maxTime = -1;\\n    vector<vector<pair<int, int>>> g; // employee, time\\n    \\n    void dfs(int u, int time) {\\n        maxTime = max(maxTime, time);\\n        for (int i = 0; i < g[u].size(); i++)\\n            dfs(g[u][i].first, time + g[u][i].second);\\n    }\\n    \\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        g = vector<vector<pair<int, int>>>(n, vector<pair<int, int>>());\\n        for (int i = 0; i < n; i++) {\\n            if (manager[i] != -1)\\n                g[manager[i]].emplace_back(i, informTime[manager[i]]);\\n        }\\n        \\n        dfs(headID, 0);\\n        return maxTime;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    \\n    def dfs(self, u: int, time: int):\\n        self.maxTime = max(self.maxTime, time)\\n        for v, e in self.g[u]:\\n            self.dfs(v, time + e)\\n    \\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        self.maxTime = -1\\n        self.g = [[] for _ in range(n)]\\n        for i in range(n):\\n            if manager[i] != -1:\\n                self.g[manager[i]].append((i, informTime[manager[i]]))\\n        self.dfs(headID, 0)\\n        return self.maxTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982826,
                "title": "c-fastest-solution-using-dfs-beats-100",
                "content": "#### Approach:\\n**path compression**: once a path from an employee to the head has been computed, the total informTime from leaf to root is passed down and the employeeId is replaced with the headId to hit base case on subsequent paths. \\n\\n```\\npublic class Solution {\\n    public int NumOfMinutes(int n, int headId, int[] manager, int[] informTime) {\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans = Math.Max(ans, Dfs(i));\\n        }\\n        return ans;\\n        \\n        int Dfs(int i) {\\n            if(manager[i] == -1) return informTime[i];\\n            informTime[i] += Dfs(manager[i]);\\n            manager[i] = -1;\\n            return informTime[i];\\n        }\\n    }\\n}\\n```\\n\\nBonus BFS Approach :)\\n```\\n    public int NumOfMinutes_Bfs(int n, int headId, int[] manager, int[] informTime) {\\n        var map = new Dictionary<int, List<int>>();\\n        // STEP 1: Build adjacency list (maps subordinate empID to manager)\\n        for (int i = 0; i < n; i++) {\\n            if (manager[i] is -1) continue;\\n            map.TryAdd(manager[i], new());\\n            map[manager[i]].Add(i);\\n        }\\n\\n        // STEP 2: Process managers starting from headID\\n        int sum = 0;\\n        Queue<(int empId, int time)> queue = new();\\n        queue.Enqueue(new(headId, 0));\\n        while (queue.Count > 0) {\\n            int count = queue.Count;\\n            while (count-- > 0) {\\n                (int empId, int time) = queue.Dequeue();\\n                sum = Math.Max(sum, time);\\n                if (!map.TryGetValue(empId, out var subIds)) continue;\\n                foreach (int subId in subIds)\\n                    queue.Enqueue((subId, time + informTime[empId]));\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\npublic class Solution {\\n    public int NumOfMinutes(int n, int headId, int[] manager, int[] informTime) {\\n        int ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            ans = Math.Max(ans, Dfs(i));\\n        }\\n        return ans;\\n        \\n        int Dfs(int i) {\\n            if(manager[i] == -1) return informTime[i];\\n            informTime[i] += Dfs(manager[i]);\\n            manager[i] = -1;\\n            return informTime[i];\\n        }\\n    }\\n}\\n```\n```\\n    public int NumOfMinutes_Bfs(int n, int headId, int[] manager, int[] informTime) {\\n        var map = new Dictionary<int, List<int>>();\\n        // STEP 1: Build adjacency list (maps subordinate empID to manager)\\n        for (int i = 0; i < n; i++) {\\n            if (manager[i] is -1) continue;\\n            map.TryAdd(manager[i], new());\\n            map[manager[i]].Add(i);\\n        }\\n\\n        // STEP 2: Process managers starting from headID\\n        int sum = 0;\\n        Queue<(int empId, int time)> queue = new();\\n        queue.Enqueue(new(headId, 0));\\n        while (queue.Count > 0) {\\n            int count = queue.Count;\\n            while (count-- > 0) {\\n                (int empId, int time) = queue.Dequeue();\\n                sum = Math.Max(sum, time);\\n                if (!map.TryGetValue(empId, out var subIds)) continue;\\n                foreach (int subId in subIds)\\n                    queue.Enqueue((subId, time + informTime[empId]));\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848956,
                "title": "c-bfs-dfs",
                "content": "# BFS\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n, vector<int>()); \\n\\n        for (int v = 0; v < manager.size(); v++) {\\n            if (v == headID)\\n                continue;\\n            int& u = manager[v];\\n            adj[u].emplace_back(v);\\n        }    \\n\\n        queue<pair<int, int>> Q;\\n        Q.emplace(headID, 0);\\n\\n        int result = 0;\\n\\n        while (!Q.empty()) {\\n            auto [node, time] = Q.front(); Q.pop();\\n            result = max(result, time);\\n            for (auto& adjNode : adj[node])\\n                Q.emplace(adjNode, time + informTime[node]);\\n        }\\n\\n        return result;\\n    }\\n};\\n```\\n\\n# DFS\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n, vector<int>()); \\n\\n        for (int v = 0; v < manager.size(); v++) {\\n            if (v == headID)\\n                continue;\\n            int& u = manager[v];\\n            adj[u].emplace_back(v);\\n        }    \\n\\n        return dfs(headID, adj, informTime);\\n    }\\n\\nprivate:\\n    int dfs(int node, vector<vector<int>>& adj, vector<int>& informTime) {\\n        int result = 0;\\n        for (auto& adjNode : adj[node]) {\\n            result = max(result, dfs(adjNode, adj, informTime));\\n        }\\n        return result + informTime[node];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n, vector<int>()); \\n\\n        for (int v = 0; v < manager.size(); v++) {\\n            if (v == headID)\\n                continue;\\n            int& u = manager[v];\\n            adj[u].emplace_back(v);\\n        }    \\n\\n        queue<pair<int, int>> Q;\\n        Q.emplace(headID, 0);\\n\\n        int result = 0;\\n\\n        while (!Q.empty()) {\\n            auto [node, time] = Q.front(); Q.pop();\\n            result = max(result, time);\\n            for (auto& adjNode : adj[node])\\n                Q.emplace(adjNode, time + informTime[node]);\\n        }\\n\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n, vector<int>()); \\n\\n        for (int v = 0; v < manager.size(); v++) {\\n            if (v == headID)\\n                continue;\\n            int& u = manager[v];\\n            adj[u].emplace_back(v);\\n        }    \\n\\n        return dfs(headID, adj, informTime);\\n    }\\n\\nprivate:\\n    int dfs(int node, vector<vector<int>>& adj, vector<int>& informTime) {\\n        int result = 0;\\n        for (auto& adjNode : adj[node]) {\\n            result = max(result, dfs(adjNode, adj, informTime));\\n        }\\n        return result + informTime[node];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3602412,
                "title": "simple-and-optimal-python3-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` python3 []\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        vs = defaultdict(list)\\n        for i, u in enumerate(manager):\\n            vs[u].append(i)\\n\\n        def recursive(u):\\n            result = 0\\n            for v in vs[u]:\\n                result = max(result, recursive(v))\\n            return result + informTime[u]\\n        \\n        return recursive(headID)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "``` python3 []\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        vs = defaultdict(list)\\n        for i, u in enumerate(manager):\\n            vs[u].append(i)\\n\\n        def recursive(u):\\n            result = 0\\n            for v in vs[u]:\\n                result = max(result, recursive(v))\\n            return result + informTime[u]\\n        \\n        return recursive(headID)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597451,
                "title": "c-bfs-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n#define arr array\\n\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int hid, vector<int>& m, vector<int>& time)\\n    {\\n        // build graph\\n        vector<vector<int>> G(n, vector<int>{});\\n        for(int i = 0; i < n; i++)\\n        {\\n            int p = m[i];\\n            // connect p -> i when p != -1\\n            if(p != -1)\\n                G[p].push_back(i);\\n        }\\n\\n        // bfs starts from hid -> find maximum w\\n        int ans = INT_MIN;\\n        queue<arr<int, 2>> q; // (node idx, total time)\\n        q.push({hid, time[hid]});\\n\\n        while(!q.empty())\\n        {\\n            auto [i, w] = q.front();\\n            q.pop();\\n            ans = max(ans, w);\\n\\n            for(int j : G[i])\\n                q.push({j, w+time[j]});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\n#define arr array\\n\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int hid, vector<int>& m, vector<int>& time)\\n    {\\n        // build graph\\n        vector<vector<int>> G(n, vector<int>{});\\n        for(int i = 0; i < n; i++)\\n        {\\n            int p = m[i];\\n            // connect p -> i when p != -1\\n            if(p != -1)\\n                G[p].push_back(i);\\n        }\\n\\n        // bfs starts from hid -> find maximum w\\n        int ans = INT_MIN;\\n        queue<arr<int, 2>> q; // (node idx, total time)\\n        q.push({hid, time[hid]});\\n\\n        while(!q.empty())\\n        {\\n            auto [i, w] = q.front();\\n            q.pop();\\n            ans = max(ans, w);\\n\\n            for(int j : G[i])\\n                q.push({j, w+time[j]});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596556,
                "title": "1376-time-needed-to-inform-all-employees-java",
                "content": "```\\nclass Solution {\\n    int ans=0,max=0;\\n    public void dfs(List<Integer>[] adj,int mngrID,int [] informTime)\\n    {\\n        max=Math.max(max,ans);\\n        for(var x:adj[mngrID])\\n        {\\n            ans+=informTime[mngrID];\\n            dfs(adj,x,informTime);\\n            ans-=informTime[mngrID];\\n\\n        }\\n\\n    }\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        List<Integer>[] adj= new ArrayList [n];\\n        for (var i=0; i<n; i++)\\n          adj[i] = new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(manager[i]!=-1)\\n                adj[manager[i]].add(i);\\n        }\\n        dfs(adj,headID,informTime);\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int ans=0,max=0;\\n    public void dfs(List<Integer>[] adj,int mngrID,int [] informTime)\\n    {\\n        max=Math.max(max,ans);\\n        for(var x:adj[mngrID])\\n        {\\n            ans+=informTime[mngrID];\\n            dfs(adj,x,informTime);\\n            ans-=informTime[mngrID];\\n\\n        }\\n\\n    }\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        List<Integer>[] adj= new ArrayList [n];\\n        for (var i=0; i<n; i++)\\n          adj[i] = new ArrayList<>();\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(manager[i]!=-1)\\n                adj[manager[i]].add(i);\\n        }\\n        dfs(adj,headID,informTime);\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595592,
                "title": "java-understandable-solution-graphs-bfs",
                "content": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer,List<Integer>> graph = new HashMap();\\n        int i = 0, len = manager.length;\\n        for(i = 0 ; i < len; i++){\\n            int m = manager[i];\\n            graph.putIfAbsent(m,new ArrayList());\\n            graph.get(m).add(i);\\n        }\\n        Queue<Pair<Integer,Integer>> q = new LinkedList();\\n        q.offer(new Pair(headID, 0));\\n        int ans = 0;\\n        while(q.size() > 0){\\n            int node = q.peek().getKey();\\n            int count = q.peek().getValue();\\n            q.remove();\\n            if(graph.get(node) == null)\\n                continue;\\n            for(i= 0; i < graph.get(node).size(); i++){\\n                int subordinate = graph.get(node).get(i);\\n                q.add(new Pair(subordinate, count+1));\\n            }\\n            ans = Math.max(ans, count+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n        Map<Integer,List<Integer>> graph = new HashMap();\\n        int i = 0, len = manager.length;\\n        for(i = 0 ; i < len; i++){\\n            int m = manager[i];\\n            graph.putIfAbsent(m,new ArrayList());\\n            graph.get(m).add(i);\\n        }\\n        Queue<Pair<Integer,Integer>> q = new LinkedList();\\n        q.offer(new Pair(headID, 0));\\n        int ans = 0;\\n        while(q.size() > 0){\\n            int node = q.peek().getKey();\\n            int count = q.peek().getValue();\\n            q.remove();\\n            if(graph.get(node) == null)\\n                continue;\\n            for(i= 0; i < graph.get(node).size(); i++){\\n                int subordinate = graph.get(node).get(i);\\n                q.add(new Pair(subordinate, count+1));\\n            }\\n            ans = Math.max(ans, count+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594596,
                "title": "easiest-solution-for-c",
                "content": "\\n# Approach\\nBFS easy approach\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& info) {\\n        if(n == 1) return 0;\\n   \\n     // queue for the BFS traversal\\n\\n\\n        queue<pair<int,int>> q; \\n\\n        vector<vector<int>> chl(n);\\n        for(int i=0;i<n;i++){\\n            if(manager[i] != -1){\\n                chl[manager[i]].push_back(i);\\n            }\\n        }\\n\\n        //  Tree do BFS \\n\\n\\n        int ans = 0;\\n        q.push({headID,info[headID]});\\n        while(!q.empty()){\\n            int s = q.size();\\n            for(int i=0;i<s;i++){\\n                auto pp = q.front();\\n                q.pop();\\n                ans = max(ans,pp.second);\\n\\n                // Add childs of this employee and their time .\\n\\n                for(auto ch : chl[pp.first]){\\n                    q.push({ch,info[ch]+pp.second});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& info) {\\n        if(n == 1) return 0;\\n   \\n     // queue for the BFS traversal\\n\\n\\n        queue<pair<int,int>> q; \\n\\n        vector<vector<int>> chl(n);\\n        for(int i=0;i<n;i++){\\n            if(manager[i] != -1){\\n                chl[manager[i]].push_back(i);\\n            }\\n        }\\n\\n        //  Tree do BFS \\n\\n\\n        int ans = 0;\\n        q.push({headID,info[headID]});\\n        while(!q.empty()){\\n            int s = q.size();\\n            for(int i=0;i<s;i++){\\n                auto pp = q.front();\\n                q.pop();\\n                ans = max(ans,pp.second);\\n\\n                // Add childs of this employee and their time .\\n\\n                for(auto ch : chl[pp.first]){\\n                    q.push({ch,info[ch]+pp.second});\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594541,
                "title": "rust-go-standard-bfs-dfs-problem",
                "content": "# Intuition\\nThis is a standard BFS, DFS problem.\\nIn Go I do DFS (for no particular reason). As the tree is given to us in a form where you see how to get to a parent, we can just do DFS from each node counting the total sum of time.\\n\\nIn Rust I do BFS. To do it we need to convert the the structure to point to the children and then maintain frontier of tuples `(node, time)`\\n\\n# Complexity\\n- Time complexity:\\n   - Vanilla DFS will be on average $O(n)$ but will deteriorate to $O(n^2)$ if the tree is a chain. You can still convert it to $O(n)$ saving the results of intermediary computations\\n   - BFS is $O(n)$ for all cases\\n\\n- Space complexity: $O(n)$\\n\\n# Code\\n```Go []\\nvar max int \\n\\nfunc dfs(G map[int][]int, time []int, node, curr int) {\\n  if _, ok := G[node]; !ok {\\n    if curr > max {\\n      max = curr\\n    }\\n    return\\n  }\\n  \\n  for _, node2 := range G[node] {\\n    dfs(G, time, node2, curr + time[node])\\n  }\\n}\\n\\nfunc numOfMinutes(n int, headID int, manager []int, informTime []int) int {\\n  G := map[int][]int{}\\n  for p, v := range manager {\\n    if v != -1 {\\n      G[v] = append(G[v], p)\\n    }\\n  }\\n  \\n  max = 0\\n  dfs(G, informTime, headID, 0)\\n  return max\\n}\\n```\\n```Rust []\\nimpl Solution {\\n\\n  fn build_graph(tree: &Vec<i32>) -> Vec<Vec<usize>> {\\n    let mut res = vec![vec![]; tree.len()];\\n    for i in 0 .. tree.len() {\\n      if tree[i] != -1 {\\n        res[tree[i] as usize].push(i);\\n      }\\n    }\\n    return res;\\n  }\\n\\n  pub fn num_of_minutes(n: i32, val: i32, tree: Vec<i32>, time: Vec<i32>) -> i32 {\\n    let mut frontier = vec![(val as usize, time[val as usize])];\\n    let mut res = time[val as usize];\\n    let g = Self::build_graph(&tree);\\n\\n    while !frontier.is_empty() {\\n      let mut new_frontier = Vec::new();\\n      for (val, t) in frontier {\\n        for v in &g[val] {\\n          res = res.max(t + time[*v]);\\n          new_frontier.push((*v, t + time[*v]));\\n        }\\n      }\\n      frontier = new_frontier;\\n    }\\n\\n    return res;\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Rust"
                ],
                "code": "```Go []\\nvar max int \\n\\nfunc dfs(G map[int][]int, time []int, node, curr int) {\\n  if _, ok := G[node]; !ok {\\n    if curr > max {\\n      max = curr\\n    }\\n    return\\n  }\\n  \\n  for _, node2 := range G[node] {\\n    dfs(G, time, node2, curr + time[node])\\n  }\\n}\\n\\nfunc numOfMinutes(n int, headID int, manager []int, informTime []int) int {\\n  G := map[int][]int{}\\n  for p, v := range manager {\\n    if v != -1 {\\n      G[v] = append(G[v], p)\\n    }\\n  }\\n  \\n  max = 0\\n  dfs(G, informTime, headID, 0)\\n  return max\\n}\\n```\n```Rust []\\nimpl Solution {\\n\\n  fn build_graph(tree: &Vec<i32>) -> Vec<Vec<usize>> {\\n    let mut res = vec![vec![]; tree.len()];\\n    for i in 0 .. tree.len() {\\n      if tree[i] != -1 {\\n        res[tree[i] as usize].push(i);\\n      }\\n    }\\n    return res;\\n  }\\n\\n  pub fn num_of_minutes(n: i32, val: i32, tree: Vec<i32>, time: Vec<i32>) -> i32 {\\n    let mut frontier = vec![(val as usize, time[val as usize])];\\n    let mut res = time[val as usize];\\n    let g = Self::build_graph(&tree);\\n\\n    while !frontier.is_empty() {\\n      let mut new_frontier = Vec::new();\\n      for (val, t) in frontier {\\n        for v in &g[val] {\\n          res = res.max(t + time[*v]);\\n          new_frontier.push((*v, t + time[*v]));\\n        }\\n      }\\n      frontier = new_frontier;\\n    }\\n\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594499,
                "title": "c-bfs-vs-dfs-100-time-123ms-96-space-90-7mb",
                "content": "This is a nice, simple problem of tree traversal with a cost for each node and we can solve it either with a BFS or a DFS approach.\\n\\nSince I already did the BFS [when I was more of a C++ n00b](https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/755436/c-bfs-solution-explained-80-time-50-space/), I wanted to start from there to see how much better I was able to do now.\\n\\nWe will start with a few support variables first:\\n* `res` will store our overall maximum time, initially set as the time needed to alert `headID`;\\n* `qLen` will be the length of our queue, initially set to `1` (we know we will always start by a single node);\\n* `currQ` and `nxtQ` are arrays we will use to try to optimise performance compared to using an actual queue for the BFS;\\n* `pos` is the pointer we will use to write on `nxtQ`;\\n* `currNode` and `currTime` will store the index of the current node and its overall time as we go traverse our tree;\\n* `subs` will store the subordinates for each node.\\n\\nWe will then set the first element of `currQ` to be `headID` and proceed to populate `subs`, going for each node from `0` to `n` (excluded) and:\\n* storing the manager of `i` (ie: `manager[i]`) in `man`;\\n* if `man` is not a valid index (as it is the case for the overall boss), we will `continue`;\\n* if not, we will push `i` as a subordinate of `man` in the proper cell (ie: `subs[man]`).\\n\\nTime for our BFS routine now! We will loop `while` we still have elements in the queue (ie: `qLen != 0`) and:\\n* reset `pos` to be `0`, ready to write more values from the first cell of `nxtQ`;\\n* loop `qLen` times and:\\n    * reduce `qLen` by `1`;\\n    * store the current node `currQ[qLen]` in `currNode`;\\n    * store the current time `times[currNode]` in `currTime`;\\n    * for each `sub` in `subs[currNode]`, we will:\\n        * update the time to reach `sub` (ie: `times[sub]`) by the time to reach the current node (ie: `currTime`);\\n        * update `res` to be the maximum between its current value and the one we just computed;\\n        * store `sub` in `nxtQ[pos]`;\\n        * advance `pos` by `1`;\\n* prepare for the next loop (if any) by:\\n    * resetting `qLen` to be `pos`;\\n    * `swap`ping `currQ` and `nxtQ`.\\n\\nFinally, we will `return` `res`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int> &manager, vector<int> &times) {\\n        // support variables\\n        int res = times[headID], qLen = 1, currQ[100000], nxtQ[100000], pos, currNode, currTime;\\n        vector<int> subs[n];\\n        // preparing currQ and subs\\n        currQ[0] = headID;\\n        for (int i = 0, man; i < n; i++) {\\n            man = manager[i];\\n            if (man < 0) continue;\\n            subs[man].push_back(i);\\n        }\\n        // BFS!\\n        while (qLen) {\\n            pos = 0;\\n            // level traversal\\n            while (qLen--) {\\n                currNode = currQ[qLen], currTime = times[currNode];\\n                for (int sub: subs[currNode]) {\\n                    // updating res and the sub overall time\\n                    res = max(res, times[sub] += currTime);\\n                    // adding sub to nxtQ\\n                    nxtQ[pos++] = sub;\\n                }\\n            }\\n            qLen = pos;\\n            swap(currQ, nxtQ);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBut the one above did not fare too well, way worse than my previous attempt; I guessed it was due to always declaring vastly oversized arrays for the queues and I was right, since this one works like 6X faster:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int> &manager, vector<int> &times) {\\n        // support variables\\n        int res = times[headID], qLen = 1, *currQ, *nxtQ, pos, currNode, currTime;\\n        vector<int> subs[n];\\n        // preparing currQ, nxtQ and subs\\n        currQ = new int[n];\\n        nxtQ = new int[n];\\n        currQ[0] = headID;\\n        for (int i = 0, man; i < n; i++) {\\n            man = manager[i];\\n            if (man < 0) continue;\\n            subs[man].push_back(i);\\n        }\\n        // BFS!\\n        while (qLen) {\\n            pos = 0;\\n            // level traversal\\n            while (qLen--) {\\n                currNode = currQ[qLen], currTime = times[currNode];\\n                for (int sub: subs[currNode]) {\\n                    // updating res and the sub overall time\\n                    res = max(res, times[sub] += currTime);\\n                    // adding sub to nxtQ\\n                    nxtQ[pos++] = sub;\\n                }\\n            }\\n            qLen = pos;\\n            swap(currQ, nxtQ);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nBetter, but not as good as running a rather similar logic as a DFS function.\\n\\nWe are keeping the same logic to prepare `subs`, but we will then compute the result by calling the helper function `dfs` that will take a specific `node` in our tree and:\\n* loop through each `sub` in `subs[node]` and:\\n    * increase the time to reach `sub` (ie: `times[sub]`) by the time to reach his ancestor (ie: `times[node]`);\\n    * update `res` to be the maximum between its current value and the one computed above;\\n    * call `dfs` on `sub`;\\n* `return` the final result of `res`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\n    int res;\\n    vector<int> *subs, times;\\n    int dfs(int node) {\\n        for (int sub: subs[node]) {\\n            // updating res and the time for sub\\n            res = max(res, times[sub] += times[node]);\\n            // exploring the branch from sub\\n            dfs(sub);\\n        }\\n        return res;\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int> &manager, vector<int> &tmpTimes) {\\n        // populating instance variables\\n        swap(times, tmpTimes);\\n        res = times[headID];\\n        subs = new vector<int>[n];\\n        for (int i = 0, man; i < n; i++) {\\n            man = manager[i];\\n            if (man < 0) continue;\\n            subs[man].push_back(i);\\n        }\\n        return dfs(headID);\\n    }\\n};\\n```\\n\\nBut, wait a moment: do we really have to traverse a tree every single time starting from the root?\\n\\nMaybe not in this case, so we can skip the costly part of organising `subs` and move directly to parse from each node, ideally each life, since we will keep track of the already `visited` nodes and just `return` the time to reach them in case, again storing the overall updated time to reach a given node in `times`.\\n\\nThe following version runs way faster (and, for comparison, about 11-12X faster than the initial BFS run), burning much less memory:\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$ (just for `visited`, otherwise it would be `d`, with `d` being the depth of the tree, used for the recursive stack)\\n\\n# Code\\n```cpp\\nclass Solution {\\n    int res = 0, head;\\n    vector<int> times, manager;\\n    bool *visited;\\n    int dfs(int node) {\\n        // base case: already been here\\n        if (visited[node]) return times[node];\\n        // general case\\n        visited[node] = true;\\n        return times[node] += (node != head ? dfs(manager[node]) : 0);\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int> &tmpManager, vector<int> &tmpTimes) {\\n        // populating instance variables\\n        head = headID;\\n        swap(times, tmpTimes);\\n        swap(manager, tmpManager);\\n        visited = new bool[n];\\n        memset(visited, 0, n * sizeof(bool));\\n        // navigating the tree from leafs\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i]) continue;\\n            res = max(res, dfs(i));\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nPratically the same logic, in iterative version:\\n\\n```cpp\\nclass Solution {\\n    int res = 0, head;\\n    vector<int> times, manager;\\n    bool *visited;\\n    int dfs(int node) {\\n        // base case: already been here\\n        if (visited[node]) return times[node];\\n        // general case\\n        visited[node] = true;\\n        return times[node] += (node != head ? dfs(manager[node]) : 0);\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int> &manager, vector<int> &times) {\\n        // support variables\\n        int res = times[headID], st[n], pos, man;\\n        bool visited[n];\\n        memset(visited, 0, n * sizeof(bool));\\n        visited[headID] = true;\\n        // navigating the tree from leafs\\n        for (int i = 0, node; i < n; i++) {\\n            if (visited[i]) continue;\\n            st[0] = node = i, pos = 1;\\n            while (pos) {\\n                man = manager[node];\\n                // end cases: man was visited before, so we parse the stack\\n                if (visited[man]) {\\n                    visited[node] = true;\\n                    pos--;\\n                    while (node >= 0) {\\n                        times[node] += times[man];\\n                        man = node, node = pos ? st[--pos] : -1;\\n                    }\\n                    break;\\n                }\\n                // general case, we go deeper\\n                visited[node] = true;\\n                st[pos++] = man, node = man;\\n            }\\n            res = max(res, times[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int> &manager, vector<int> &times) {\\n        // support variables\\n        int res = times[headID], qLen = 1, currQ[100000], nxtQ[100000], pos, currNode, currTime;\\n        vector<int> subs[n];\\n        // preparing currQ and subs\\n        currQ[0] = headID;\\n        for (int i = 0, man; i < n; i++) {\\n            man = manager[i];\\n            if (man < 0) continue;\\n            subs[man].push_back(i);\\n        }\\n        // BFS!\\n        while (qLen) {\\n            pos = 0;\\n            // level traversal\\n            while (qLen--) {\\n                currNode = currQ[qLen], currTime = times[currNode];\\n                for (int sub: subs[currNode]) {\\n                    // updating res and the sub overall time\\n                    res = max(res, times[sub] += currTime);\\n                    // adding sub to nxtQ\\n                    nxtQ[pos++] = sub;\\n                }\\n            }\\n            qLen = pos;\\n            swap(currQ, nxtQ);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int> &manager, vector<int> &times) {\\n        // support variables\\n        int res = times[headID], qLen = 1, *currQ, *nxtQ, pos, currNode, currTime;\\n        vector<int> subs[n];\\n        // preparing currQ, nxtQ and subs\\n        currQ = new int[n];\\n        nxtQ = new int[n];\\n        currQ[0] = headID;\\n        for (int i = 0, man; i < n; i++) {\\n            man = manager[i];\\n            if (man < 0) continue;\\n            subs[man].push_back(i);\\n        }\\n        // BFS!\\n        while (qLen) {\\n            pos = 0;\\n            // level traversal\\n            while (qLen--) {\\n                currNode = currQ[qLen], currTime = times[currNode];\\n                for (int sub: subs[currNode]) {\\n                    // updating res and the sub overall time\\n                    res = max(res, times[sub] += currTime);\\n                    // adding sub to nxtQ\\n                    nxtQ[pos++] = sub;\\n                }\\n            }\\n            qLen = pos;\\n            swap(currQ, nxtQ);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    int res;\\n    vector<int> *subs, times;\\n    int dfs(int node) {\\n        for (int sub: subs[node]) {\\n            // updating res and the time for sub\\n            res = max(res, times[sub] += times[node]);\\n            // exploring the branch from sub\\n            dfs(sub);\\n        }\\n        return res;\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int> &manager, vector<int> &tmpTimes) {\\n        // populating instance variables\\n        swap(times, tmpTimes);\\n        res = times[headID];\\n        subs = new vector<int>[n];\\n        for (int i = 0, man; i < n; i++) {\\n            man = manager[i];\\n            if (man < 0) continue;\\n            subs[man].push_back(i);\\n        }\\n        return dfs(headID);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    int res = 0, head;\\n    vector<int> times, manager;\\n    bool *visited;\\n    int dfs(int node) {\\n        // base case: already been here\\n        if (visited[node]) return times[node];\\n        // general case\\n        visited[node] = true;\\n        return times[node] += (node != head ? dfs(manager[node]) : 0);\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int> &tmpManager, vector<int> &tmpTimes) {\\n        // populating instance variables\\n        head = headID;\\n        swap(times, tmpTimes);\\n        swap(manager, tmpManager);\\n        visited = new bool[n];\\n        memset(visited, 0, n * sizeof(bool));\\n        // navigating the tree from leafs\\n        for (int i = 0; i < n; i++) {\\n            if (visited[i]) continue;\\n            res = max(res, dfs(i));\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    int res = 0, head;\\n    vector<int> times, manager;\\n    bool *visited;\\n    int dfs(int node) {\\n        // base case: already been here\\n        if (visited[node]) return times[node];\\n        // general case\\n        visited[node] = true;\\n        return times[node] += (node != head ? dfs(manager[node]) : 0);\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int> &manager, vector<int> &times) {\\n        // support variables\\n        int res = times[headID], st[n], pos, man;\\n        bool visited[n];\\n        memset(visited, 0, n * sizeof(bool));\\n        visited[headID] = true;\\n        // navigating the tree from leafs\\n        for (int i = 0, node; i < n; i++) {\\n            if (visited[i]) continue;\\n            st[0] = node = i, pos = 1;\\n            while (pos) {\\n                man = manager[node];\\n                // end cases: man was visited before, so we parse the stack\\n                if (visited[man]) {\\n                    visited[node] = true;\\n                    pos--;\\n                    while (node >= 0) {\\n                        times[node] += times[man];\\n                        man = node, node = pos ? st[--pos] : -1;\\n                    }\\n                    break;\\n                }\\n                // general case, we go deeper\\n                visited[node] = true;\\n                st[pos++] = man, node = man;\\n            }\\n            res = max(res, times[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594456,
                "title": "python3-simple-iterative-dfs-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse through relationship graph to find path with max total time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis problem could be solved by both DFS and BFS. By the way, they have almost identical code.\\n\\nDFS is more memory efficient in the case of balanced tree. BFS is more memory efficient in the case of extremely unbalanced tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nDepth-First Search approach:\\n$$O(n)$$[adj] + $$O(n)$$[stack] = $$O(n)$$\\n\\nBreadth-First Search approach:\\n$$O(n)$$[adj] + $$O(n)$$[queue] = $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nDepth-First Search approach:\\n$$O(n)$$[adj] + $$O(H)$$[stack] = $$O(n)$$\\n\\nBreadth-First Search approach:\\n$$O(n)$$[adj] + $$O(n)$$[queue] = $$O(n)$$\\n\\n# Code\\n```\\nfrom typing import List\\nfrom collections import deque\\n\\n\\nclass SolutionDFS:\\n    \"\"\"Depth-First Search approach.\"\"\"\\n    def numOfMinutes(\\n        self, n: int, headID: int, manager: List[int], informTime: List[int]\\n    ) -> int:\\n        \"\"\"\\n        time: O(n)[adj] + O(n)[dfs] = O(n)\\n        space: O(n)[adj] + O(H)[dfs] = O(n)\\n        \"\"\"\\n        adj_matrix = [[] for _ in range(n)]\\n        for node_subordinate, node_manager in enumerate(manager):\\n            if node_manager == -1:\\n                continue\\n            adj_matrix[node_manager].append(node_subordinate)\\n\\n        time = 0\\n        stack = [(headID, informTime[headID])]\\n        while(stack):\\n            node_manager, curr_time = stack.pop()\\n            for node_subordinate in adj_matrix[node_manager]:\\n                new_time = curr_time + informTime[node_subordinate]\\n                time = max(time, new_time)\\n                stack.append((node_subordinate, new_time))\\n        return time\\n\\n\\nclass SolutionBFS:\\n    \"\"\"Breadth-First Search approach.\"\"\"\\n    def numOfMinutes(\\n        self, n: int, headID: int, manager: List[int], informTime: List[int]\\n    ) -> int:\\n        \"\"\"\\n        time: O(n)[adj] + O(n)[bfs] = O(n)\\n        space: O(n)[adj] + O(n)[bfs] = O(n)\\n        \"\"\"\\n        adj_matrix = [[] for _ in range(n)]\\n        for node_subordinate, node_manager in enumerate(manager):\\n            if node_manager == -1:\\n                continue\\n            adj_matrix[node_manager].append(node_subordinate)\\n\\n        time = 0\\n        queue = deque([(headID, informTime[headID])])\\n        while(queue):\\n            node_manager, curr_time = queue.popleft()\\n            for node_subordinate in adj_matrix[node_manager]:\\n                new_time = curr_time + informTime[node_subordinate]\\n                time = max(time, new_time)\\n                queue.append((node_subordinate, new_time))\\n        return time\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom typing import List\\nfrom collections import deque\\n\\n\\nclass SolutionDFS:\\n    \"\"\"Depth-First Search approach.\"\"\"\\n    def numOfMinutes(\\n        self, n: int, headID: int, manager: List[int], informTime: List[int]\\n    ) -> int:\\n        \"\"\"\\n        time: O(n)[adj] + O(n)[dfs] = O(n)\\n        space: O(n)[adj] + O(H)[dfs] = O(n)\\n        \"\"\"\\n        adj_matrix = [[] for _ in range(n)]\\n        for node_subordinate, node_manager in enumerate(manager):\\n            if node_manager == -1:\\n                continue\\n            adj_matrix[node_manager].append(node_subordinate)\\n\\n        time = 0\\n        stack = [(headID, informTime[headID])]\\n        while(stack):\\n            node_manager, curr_time = stack.pop()\\n            for node_subordinate in adj_matrix[node_manager]:\\n                new_time = curr_time + informTime[node_subordinate]\\n                time = max(time, new_time)\\n                stack.append((node_subordinate, new_time))\\n        return time\\n\\n\\nclass SolutionBFS:\\n    \"\"\"Breadth-First Search approach.\"\"\"\\n    def numOfMinutes(\\n        self, n: int, headID: int, manager: List[int], informTime: List[int]\\n    ) -> int:\\n        \"\"\"\\n        time: O(n)[adj] + O(n)[bfs] = O(n)\\n        space: O(n)[adj] + O(n)[bfs] = O(n)\\n        \"\"\"\\n        adj_matrix = [[] for _ in range(n)]\\n        for node_subordinate, node_manager in enumerate(manager):\\n            if node_manager == -1:\\n                continue\\n            adj_matrix[node_manager].append(node_subordinate)\\n\\n        time = 0\\n        queue = deque([(headID, informTime[headID])])\\n        while(queue):\\n            node_manager, curr_time = queue.popleft()\\n            for node_subordinate in adj_matrix[node_manager]:\\n                new_time = curr_time + informTime[node_subordinate]\\n                time = max(time, new_time)\\n                queue.append((node_subordinate, new_time))\\n        return time\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594300,
                "title": "c-easy-to-understand-daily-challenge-dfs-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\nwhere n is the parameter in the problem\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int dfs(int curremp,vector<int> adj[],vector<int>& informTime){\\n        int time=0;\\n        for(auto it:adj[curremp]){\\n            time=max(time,dfs(it,adj,informTime));\\n        }\\n        return informTime[curremp]+time;\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++){\\n            if(i!=headID)\\n            adj[manager[i]].push_back(i);\\n        }\\n        return dfs(headID,adj,informTime);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int dfs(int curremp,vector<int> adj[],vector<int>& informTime){\\n        int time=0;\\n        for(auto it:adj[curremp]){\\n            time=max(time,dfs(it,adj,informTime));\\n        }\\n        return informTime[curremp]+time;\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<int> adj[n];\\n        for(int i=0;i<n;i++){\\n            if(i!=headID)\\n            adj[manager[i]].push_back(i);\\n        }\\n        return dfs(headID,adj,informTime);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594243,
                "title": "beating-97-72-python-easiest-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/7ae0bfaa-24e9-44cb-ab55-28780c881f1a_1685821649.10545.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:        \\n        def calculateTime(n: int) -> int:\\n            if manager[n] != -1:\\n                informTime[n] += calculateTime(manager[n])\\n                manager[n] = -1\\n            return informTime[n]\\n        for idx in range(len(manager)):\\n            calculateTime(idx)\\n        return max(informTime)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:        \\n        def calculateTime(n: int) -> int:\\n            if manager[n] != -1:\\n                informTime[n] += calculateTime(manager[n])\\n                manager[n] = -1\\n            return informTime[n]\\n        for idx in range(len(manager)):\\n            calculateTime(idx)\\n        return max(informTime)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593937,
                "title": "breadth-first-search-bfs-simple-easy-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI first observed that there was a tree structure in the question. So, I decided to use a breadth-first search (BFS) algorithm to solve the problem. The implementation of DFS is also simple, but I thought of using BFS for this problem .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI created a list to keep track of the connections between people in the tree (adjacency list ). Then, I used BFS to find out how long it would take for the message to reach each person.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n               ** O(n)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n                ** O(n)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        //   we need to do the dfs or bfs for this problem starting from the head \\n\\n        int src = headID;\\n        // make a adj list \\n\\n        vector<int> adj[n];\\n        for(int i = 0;i<n;i++){\\n            int temp = manager[i];\\n            if(temp != -1){\\n                adj[temp].push_back(i);\\n            }\\n        }\\n        vector<int> vis(n,0);\\n        queue<int> q;\\n        q.push(src);\\n        vis[src] = 1;\\n        int ans = 0;\\n        vector<int> tt(n,0);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i = 0;i<sz;i++){\\n                int temp = q.front();\\n                q.pop();\\n                \\n                for(auto it:adj[temp]){\\n                    if(vis[it] == 0){\\n                        q.push(it);\\n                        tt[it] = tt[temp] + informTime[temp];\\n                        ans = max(ans,tt[it]);\\n                        vis[it] = 1;\\n\\n                    }\\n                }                \\n            }\\n\\n        }\\n       \\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        //   we need to do the dfs or bfs for this problem starting from the head \\n\\n        int src = headID;\\n        // make a adj list \\n\\n        vector<int> adj[n];\\n        for(int i = 0;i<n;i++){\\n            int temp = manager[i];\\n            if(temp != -1){\\n                adj[temp].push_back(i);\\n            }\\n        }\\n        vector<int> vis(n,0);\\n        queue<int> q;\\n        q.push(src);\\n        vis[src] = 1;\\n        int ans = 0;\\n        vector<int> tt(n,0);\\n        while(!q.empty()){\\n            int sz = q.size();\\n            for(int i = 0;i<sz;i++){\\n                int temp = q.front();\\n                q.pop();\\n                \\n                for(auto it:adj[temp]){\\n                    if(vis[it] == 0){\\n                        q.push(it);\\n                        tt[it] = tt[temp] + informTime[temp];\\n                        ans = max(ans,tt[it]);\\n                        vis[it] = 1;\\n\\n                    }\\n                }                \\n            }\\n\\n        }\\n       \\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593902,
                "title": "c-super-easy-clean-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int DFS(vector<int> adj[], int root, int currTime, vector<int>& informTime){\\n        if(informTime[root] == 0) return currTime;\\n        int maxi = 0;\\n        for(int children : adj[root]){\\n            maxi = max(maxi,DFS(adj,children,currTime+informTime[root],informTime));\\n        }\\n        return maxi;\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        vector<int> adj[n];\\n\\n        for(int i=0; i<n; i++){\\n            if(manager[i] == -1) continue;\\n            int root = manager[i];\\n            int child = i;\\n            adj[root].push_back(child);\\n        }   \\n        return DFS(adj,headID,0,informTime);                  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int DFS(vector<int> adj[], int root, int currTime, vector<int>& informTime){\\n        if(informTime[root] == 0) return currTime;\\n        int maxi = 0;\\n        for(int children : adj[root]){\\n            maxi = max(maxi,DFS(adj,children,currTime+informTime[root],informTime));\\n        }\\n        return maxi;\\n    }\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(0);\\n        cout.tie(0);\\n        vector<int> adj[n];\\n\\n        for(int i=0; i<n; i++){\\n            if(manager[i] == -1) continue;\\n            int root = manager[i];\\n            int child = i;\\n            adj[root].push_back(child);\\n        }   \\n        return DFS(adj,headID,0,informTime);                  \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3593737,
                "title": "c-easy-and-clean-code",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        queue<int> q;\\n        vector<int> time(n, 0);\\n        vector<int> senior(n, 0);\\n\\n        for(auto i : manager){\\n            if(i == -1) continue;\\n            senior[i]++;\\n        }\\n\\n        for(int i=0; i<senior.size(); i++){\\n            if(senior[i] == 0) q.push(i);\\n        }\\n\\n        while(q.size()){\\n            int num = q.front();\\n            q.pop();\\n\\n            int leader = manager[num];\\n            if(leader == -1) break;\\n\\n            senior[leader]--;\\n            time[leader] = max(time[leader], informTime[num]);\\n\\n            if(senior[leader] == 0){\\n                q.push(leader);\\n                informTime[leader] += time[leader];\\n            }\\n        }\\n\\n        return informTime[headID];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        queue<int> q;\\n        vector<int> time(n, 0);\\n        vector<int> senior(n, 0);\\n\\n        for(auto i : manager){\\n            if(i == -1) continue;\\n            senior[i]++;\\n        }\\n\\n        for(int i=0; i<senior.size(); i++){\\n            if(senior[i] == 0) q.push(i);\\n        }\\n\\n        while(q.size()){\\n            int num = q.front();\\n            q.pop();\\n\\n            int leader = manager[num];\\n            if(leader == -1) break;\\n\\n            senior[leader]--;\\n            time[leader] = max(time[leader], informTime[num]);\\n\\n            if(senior[leader] == 0){\\n                q.push(leader);\\n                informTime[leader] += time[leader];\\n            }\\n        }\\n\\n        return informTime[headID];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593687,
                "title": "python-bfs-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBFS\\n\\n# Complexity\\n- Time complexity: O(V)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        if n == 1: return 0\\n\\n        adj = {i: [] for i in range(n)}\\n\\n        for i in range(n):\\n            if i != headID:\\n                adj[manager[i]].append(i)\\n        \\n        que = deque()\\n        que.append((headID, 0))\\n        vis = [0] * n\\n        vis[headID] = 1\\n        ans = 0\\n        while que:\\n            node, time = que.popleft()\\n            ans = max(ans, time)\\n            for nod in adj[node]:\\n                if vis[nod] == 0:\\n                    que.append((nod, time + informTime[node]))\\n                    vis[nod] = 1\\n        \\n        return ans\\n```\\n# UPVOTE Please!!",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def numOfMinutes(self, n: int, headID: int, manager: List[int], informTime: List[int]) -> int:\\n        if n == 1: return 0\\n\\n        adj = {i: [] for i in range(n)}\\n\\n        for i in range(n):\\n            if i != headID:\\n                adj[manager[i]].append(i)\\n        \\n        que = deque()\\n        que.append((headID, 0))\\n        vis = [0] * n\\n        vis[headID] = 1\\n        ans = 0\\n        while que:\\n            node, time = que.popleft()\\n            ans = max(ans, time)\\n            for nod in adj[node]:\\n                if vis[nod] == 0:\\n                    que.append((nod, time + informTime[node]))\\n                    vis[nod] = 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593589,
                "title": "o-n-dfs-readable-code-n-ary-recursive-tree-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe message propagation is triggered for all the N-Ary children of the root in **parallel**. So, for each root, the total time of msg propagation at each root equals the time taken by itself **plus** the time taken by the **slowest** child. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAdjacency List + DFS on the N-ary tree to find the max time (taken by the slowest child) in each subtree recursively\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int maxTimeNAryTree(int head, HashMap<Integer, ArrayList<Integer>> children, int []informTime) {\\n\\n        int selfPropTime = informTime[head];\\n        int maxNAryChildrenTime = 0;\\n\\n        ArrayList<Integer> nAryChildren = children.get(head);\\n\\n        if (nAryChildren == null)\\n            return selfPropTime;\\n\\n        for (int i = 0; i < nAryChildren.size(); i++) {\\n            int currChild = nAryChildren.get(i);\\n            int currTime = informTime[currChild];\\n\\n            maxNAryChildrenTime = Math.max(maxNAryChildrenTime, maxTimeNAryTree(currChild, children, informTime));\\n        }\\n        return selfPropTime + maxNAryChildrenTime;\\n    }\\n\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n\\n        HashMap<Integer, ArrayList<Integer>> children = new HashMap<>();\\n\\n        int head = -1;\\n\\n        for (int i = 0; i < manager.length; i++) {\\n\\n            if (manager[i] == -1)\\n                head = i;\\n            else\\n                {\\n                    int currManager = manager[i];\\n                    ArrayList<Integer> currChildren = children.get(currManager);\\n\\n                    if (currChildren == null) \\n                        currChildren = new ArrayList<>();\\n                    \\n                    currChildren.add(i);\\n\\n                    children.remove(currManager);\\n                    children.put(currManager, currChildren);\\n                }\\n        }\\n        return maxTimeNAryTree(head, children, informTime);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int maxTimeNAryTree(int head, HashMap<Integer, ArrayList<Integer>> children, int []informTime) {\\n\\n        int selfPropTime = informTime[head];\\n        int maxNAryChildrenTime = 0;\\n\\n        ArrayList<Integer> nAryChildren = children.get(head);\\n\\n        if (nAryChildren == null)\\n            return selfPropTime;\\n\\n        for (int i = 0; i < nAryChildren.size(); i++) {\\n            int currChild = nAryChildren.get(i);\\n            int currTime = informTime[currChild];\\n\\n            maxNAryChildrenTime = Math.max(maxNAryChildrenTime, maxTimeNAryTree(currChild, children, informTime));\\n        }\\n        return selfPropTime + maxNAryChildrenTime;\\n    }\\n\\n    public int numOfMinutes(int n, int headID, int[] manager, int[] informTime) {\\n\\n        HashMap<Integer, ArrayList<Integer>> children = new HashMap<>();\\n\\n        int head = -1;\\n\\n        for (int i = 0; i < manager.length; i++) {\\n\\n            if (manager[i] == -1)\\n                head = i;\\n            else\\n                {\\n                    int currManager = manager[i];\\n                    ArrayList<Integer> currChildren = children.get(currManager);\\n\\n                    if (currChildren == null) \\n                        currChildren = new ArrayList<>();\\n                    \\n                    currChildren.add(i);\\n\\n                    children.remove(currManager);\\n                    children.put(currManager, currChildren);\\n                }\\n        }\\n        return maxTimeNAryTree(head, children, informTime);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593580,
                "title": "c-bfs-traversal-easy-to-understand-potd",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConvert the problem into normal tree problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use the manager array to form the adjacent list taking headID as root.\\n2. Once the list is formed, simply do a BFS traversal, with taking pair of empid and time. \\n3. Choose the path with maximum time and cummulatively add it for next level\\n4. Print the result finally.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->  \\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        int res=0;\\n\\n        //Adjancy List\\n        for(int i=0;i<n;i++){\\n            if(manager[i]!=-1)\\n            adj[manager[i]].push_back(i);\\n        }\\n\\n        //DFS\\n        queue<pair<int,int>> q;\\n        q.push({headID,0});\\n\\n        while(!q.empty()){\\n            auto top=q.front();\\n            int id=top.first;\\n            int time=top.second;\\n            q.pop();\\n            res=max(res,time);\\n            for(auto emp:adj[id]){\\n                q.push({emp,time+informTime[id]});\\n            }\\n\\n        }    \\n\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        int res=0;\\n\\n        //Adjancy List\\n        for(int i=0;i<n;i++){\\n            if(manager[i]!=-1)\\n            adj[manager[i]].push_back(i);\\n        }\\n\\n        //DFS\\n        queue<pair<int,int>> q;\\n        q.push({headID,0});\\n\\n        while(!q.empty()){\\n            auto top=q.front();\\n            int id=top.first;\\n            int time=top.second;\\n            q.pop();\\n            res=max(res,time);\\n            for(auto emp:adj[id]){\\n                q.push({emp,time+informTime[id]});\\n            }\\n\\n        }    \\n\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593483,
                "title": "easy-c-dfs",
                "content": "# Approach\\n- create the graph then most longest branch or you can say max time needed to inform the most depth branch will be the answere. so I used dfs for that.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(v+e)//number of vertices + edges => O(n+n) => O(n) // becuase only upto n edges possible because there will not be any overlap with other node. all the nodes will be connected to direct node.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n) // to create the graph + O(n) // for recursion (callstack size)=> O(n) approximate.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int dfs(int headID, vector<vector<int>>&graph, vector<int>&informTime){\\n        int totalTime = 0;\\n        for(int negi:graph[headID]){\\n            totalTime = max(totalTime, dfs(negi, graph, informTime));\\n        }\\n        return totalTime + informTime[headID];\\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        \\n        vector<vector<int>>graph(n);\\n        unordered_set<int>parent;\\n        for(int i = 0; i<n; i++){\\n            int parent = manager[i];\\n            if(parent != -1) graph[parent].push_back(i);\\n        }\\n        return dfs(headID, graph, informTime);\\n    }\\n};\\n```\\n\\n# Please upvote and comment.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int dfs(int headID, vector<vector<int>>&graph, vector<int>&informTime){\\n        int totalTime = 0;\\n        for(int negi:graph[headID]){\\n            totalTime = max(totalTime, dfs(negi, graph, informTime));\\n        }\\n        return totalTime + informTime[headID];\\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        \\n        vector<vector<int>>graph(n);\\n        unordered_set<int>parent;\\n        for(int i = 0; i<n; i++){\\n            int parent = manager[i];\\n            if(parent != -1) graph[parent].push_back(i);\\n        }\\n        return dfs(headID, graph, informTime);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593481,
                "title": "just-traversal-dfs-clean-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nConvert the problem into the tree/graph problem, then perform a traversal.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe employee with headID will be the root of the tree/graph.\\n\\nwe can build the tree/digraph using the given manager-subordinate relationships,\\nduring the traversal we can recored the time that the cur node\\'s subordinates when his received the urgent news.\\n\\nreturn the maximum time recorded in the array. \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(V+E)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> graph(n);\\n        vector<int> visitedTime(n, 0);\\n        \\n        for (int i = 0 ; i < manager.size() ; ++i ) {\\n            if (manager[i] == -1) continue;\\n            graph[manager[i]].emplace_back(i);\\n        }\\n\\n        function<void(int)> dfs = [&] (int node) {\\n            for (auto to : graph[node]) {\\n                visitedTime[to] = visitedTime[node] + informTime[node];\\n                dfs(to);\\n            }\\n        };\\n        \\n        dfs(headID);\\n\\n        return *max_element(visitedTime.begin(), visitedTime.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> graph(n);\\n        vector<int> visitedTime(n, 0);\\n        \\n        for (int i = 0 ; i < manager.size() ; ++i ) {\\n            if (manager[i] == -1) continue;\\n            graph[manager[i]].emplace_back(i);\\n        }\\n\\n        function<void(int)> dfs = [&] (int node) {\\n            for (auto to : graph[node]) {\\n                visitedTime[to] = visitedTime[node] + informTime[node];\\n                dfs(to);\\n            }\\n        };\\n        \\n        dfs(headID);\\n\\n        return *max_element(visitedTime.begin(), visitedTime.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1877475,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1914753,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1914725,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1860641,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1914714,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1892152,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1725589,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1914969,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1914937,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1915008,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1877475,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1914753,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1914725,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1860641,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1914714,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1892152,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1725589,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1914969,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1914937,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1915008,
                "content": [
                    {
                        "username": "dev-null0",
                        "content": "Easy question, but those examples are bad"
                    },
                    {
                        "username": "Prajju22",
                        "content": "i agree they could provide better tc.."
                    },
                    {
                        "username": "atxiai",
                        "content": "agree"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Agreed me from a month ago"
                    },
                    {
                        "username": "thinkabouttzuyu",
                        "content": "For those who are confused wiith this baddddddddd description, the manager list [2,2,-1,2,2,2] actually means \\n[position 2 is my manager, position 2 is my manager, I am the head, position 2 is my manager, position 2 is my manager, position 2 is my manager] \\nand therefore the time is informTime[2]\\nthe following testcase might give a better perspective:\\nn = 22, headID = 7, \\nmanager = [12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\\ninformTime = [0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\\n\\nin this case, manager[7] have subordinates manager[1] and manager[1] has subordinates manager[18], manager[17]\\nthe expected answer of the testcase should be 9132"
                    },
                    {
                        "username": "Umesh2202",
                        "content": "Thanks for the test case!"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "Hello detective Anya Forger ! "
                    },
                    {
                        "username": "tungbuivn",
                        "content": "im having same result :D"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This problem has really limited example. first example doesn\\'t give any proper direction on understanding and even 2nd example does not elaborate on calculating time or height of tree. More time need to focus on reading problem twice to get it understand. "
                    },
                    {
                        "username": "diwanshib",
                        "content": "Hi all, Can anyone please explain me the correct output of the following testcase:\\nn =15, headID =0\\nmanager = [-1,0,0,1,1,2,2,3,3,4,4,5,5,6,6]\\ninformTime = [1,1,1,1,1,1,1,0,0,0,0,0,0,0,0]\\n\\nThe platform suggests the o/p to be 3 whereas however I calculate it turns out to be 7."
                    },
                    {
                        "username": "Anirudh_Purohit",
                        "content": "did you get the answer ??? cause i have the same problem!!\\n"
                    },
                    {
                        "username": "twinshu",
                        "content": "[@WallaWonka](/WallaWonka) Thanks for explaining!"
                    },
                    {
                        "username": "_SID_",
                        "content": "hey I got the same output as you\\n"
                    },
                    {
                        "username": "WallaWonka",
                        "content": "The catch here is that managers propagate the information as soon as the informTime of their direct managers passes by, which means, manager 0 uses 1 minute to inform both managers 1 and 2, then, those two managers inform theirs subordinates in parallel. If you draw the tree this manager array represent, you will notice the depth of 3 minutes to inform all the employees."
                    },
                    {
                        "username": "anwendeng",
                        "content": "This problem is easier than the one on yesterday. It is sufficient to use DFS starting from headID!\nCoding this problem is much easier than understanding the description for the problem!\nFor test case \n```\n22\n7\n[12,7,18,11,13,21,12,-1,6,5,14,13,14,9,20,13,11,1,1,2,3,19]\n[0,540,347,586,0,748,824,486,0,777,0,202,653,713,454,0,0,0,574,735,721,772]\n```\nTrace the computations for every path:\n```\n[7->1:486][1->17:1026] pathTime=1026\n[1->18:1026][18->2:1600][2->19:1947][19->21:2682][21->5:3454][5->9:4202][9->13:4979][13->4:5692] pathTime=5692\n[13->11:5692][11->3:5894][3->20:6480][20->14:7201][14->10:7655] pathTime=7655\n[14->12:7655][12->0:8308] pathTime=8308\n[12->6:8308][6->8:9132] pathTime=9132\n[11->16:5894] pathTime=5894\n[13->15:5692] pathTime=5692\n\ntimeNeed=9132\n```\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "kuan-po",
                        "content": "[@anwendeng](/anwendeng) Thank you for the explanation. :)"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@kuan-po](/kuan-po) unordered_map  may be in a linear time in the worst case."
                    },
                    {
                        "username": "kuan-po",
                        "content": "I solved the problem with unordered_map but the performance is bad."
                    },
                    {
                        "username": "kuan-po",
                        "content": "Indeed, the description is confusing. Thank for introducing the problem on YouTube."
                    },
                    {
                        "username": "anwendeng",
                        "content": "https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591057/easy-c-dfs-solutionwith-video-explanation-tracing-all-paths/\n![tree.png](https://assets.leetcode.com/users/images/f8a0fe53-afde-497d-8f93-7490ad252f0e_1685774344.9906483.png)"
                    },
                    {
                        "username": "psionl0",
                        "content": "I had been scratching my head over how to build a tree out of the info until I saw the magic letters \"DFS\". Of course! Use an adjacency list!"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "maximum root to leaf path sum :)"
                    },
                    {
                        "username": "vishalpoddar2468",
                        "content": "We need to find the Maximum Possible Path sum from root node to leaf node i.e. the head to the the employees that don\\'t have subordinates."
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Now that\\'s interesting because now question becomes simpler. Perform DFS and compare all.we get solution."
                    },
                    {
                        "username": "charonme",
                        "content": "hmm many people criticize the wording and examples, but I\\'ve seen much much MUCH worse ones here on leetcode, this one isn\\'t all THAT bad (although it could use some improvement)"
                    },
                    {
                        "username": "yash_khanna",
                        "content": "my streak is not updating even after submitting the code, is anyone else facing the same issue\\n"
                    },
                    {
                        "username": "shreyaggarwal",
                        "content": "yeah\\n"
                    },
                    {
                        "username": "toravipatel",
                        "content": "few more examples should have been given."
                    }
                ]
            },
            {
                "id": 1914940,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "solution accepted but streak not increase "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It\\'s a word puzzle."
                    },
                    {
                        "username": "yabyer1",
                        "content": "For Testcase\\n\\nn= 11\\nheadId = 4\\nmanager = [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime = [0,213,0,253,686,170,975,0,261,309,337]\\n\\nMy code outputs 2016, whereas the answer expected is 2560, although I am not sure how 2560 is reached bc from my understanding we are trying to find the max depth, and in that case 2016 should be the maxdepth sum\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[4->10:686][10->3:1023][3->9:1276][9->1:1585][1->7:1798] pathTime=1798\\n[9->6:1585][6->2:2560] pathTime=2560\\n[9->8:1585][8->5:1846][5->0:2016] pathTime=2016\\n\\nans=2560"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This is right test case to be added in description.\nI do face similar challenge when i tried to calculate maxDepth = Maxtime required for each children. And adding back to result.\nWhereas, you probably has to calculate depth including its manager's informTime and find which child has maxReporting time.\n\ne.g. x (root) = 30, \ny (child of x) =50,  w (child of x)  =100\nz (child of y) = 40,\n\nthen max time would be Max (30+50+40, 30+100)\nI hope this can help you to find root cause on your solution."
                    },
                    {
                        "username": "nikhilsharma7860598916",
                        "content": "I solved this question few minutes ago and it got accepted, but still my it\\'s not showing in my streak.  It\\'s saying \"Solve today\\'s Daily Challenge to refresh your streak!\" .. \\nI refreshed multiple times and submitted different solutions still its not updating.                                     \\nAny suggestions . What should I do? "
                    },
                    {
                        "username": "charonme",
                        "content": "mine too\n[edit] ah it finally updated now"
                    },
                    {
                        "username": "khe1154",
                        "content": "these examples are very bad which makes this question unnecessarily difficult"
                    },
                    {
                        "username": "coutdiv",
                        "content": "Examples are so bad in this problem, both the given test cases are almost useless"
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "another shitty explanation from leetcode"
                    },
                    {
                        "username": "jsparrow0404",
                        "content": "using `find` technique from `union-find algorithm` solve this problem."
                    },
                    {
                        "username": "Paulie_FromSopranos",
                        "content": "This is not a hard problem, however, both the wording and examples don\\'t really help."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": " `Probably the Head wants to Inform the news of RECESSION`"
                    }
                ]
            },
            {
                "id": 1914843,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "solution accepted but streak not increase "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It\\'s a word puzzle."
                    },
                    {
                        "username": "yabyer1",
                        "content": "For Testcase\\n\\nn= 11\\nheadId = 4\\nmanager = [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime = [0,213,0,253,686,170,975,0,261,309,337]\\n\\nMy code outputs 2016, whereas the answer expected is 2560, although I am not sure how 2560 is reached bc from my understanding we are trying to find the max depth, and in that case 2016 should be the maxdepth sum\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[4->10:686][10->3:1023][3->9:1276][9->1:1585][1->7:1798] pathTime=1798\\n[9->6:1585][6->2:2560] pathTime=2560\\n[9->8:1585][8->5:1846][5->0:2016] pathTime=2016\\n\\nans=2560"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This is right test case to be added in description.\nI do face similar challenge when i tried to calculate maxDepth = Maxtime required for each children. And adding back to result.\nWhereas, you probably has to calculate depth including its manager's informTime and find which child has maxReporting time.\n\ne.g. x (root) = 30, \ny (child of x) =50,  w (child of x)  =100\nz (child of y) = 40,\n\nthen max time would be Max (30+50+40, 30+100)\nI hope this can help you to find root cause on your solution."
                    },
                    {
                        "username": "nikhilsharma7860598916",
                        "content": "I solved this question few minutes ago and it got accepted, but still my it\\'s not showing in my streak.  It\\'s saying \"Solve today\\'s Daily Challenge to refresh your streak!\" .. \\nI refreshed multiple times and submitted different solutions still its not updating.                                     \\nAny suggestions . What should I do? "
                    },
                    {
                        "username": "charonme",
                        "content": "mine too\n[edit] ah it finally updated now"
                    },
                    {
                        "username": "khe1154",
                        "content": "these examples are very bad which makes this question unnecessarily difficult"
                    },
                    {
                        "username": "coutdiv",
                        "content": "Examples are so bad in this problem, both the given test cases are almost useless"
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "another shitty explanation from leetcode"
                    },
                    {
                        "username": "jsparrow0404",
                        "content": "using `find` technique from `union-find algorithm` solve this problem."
                    },
                    {
                        "username": "Paulie_FromSopranos",
                        "content": "This is not a hard problem, however, both the wording and examples don\\'t really help."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": " `Probably the Head wants to Inform the news of RECESSION`"
                    }
                ]
            },
            {
                "id": 1914742,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "solution accepted but streak not increase "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It\\'s a word puzzle."
                    },
                    {
                        "username": "yabyer1",
                        "content": "For Testcase\\n\\nn= 11\\nheadId = 4\\nmanager = [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime = [0,213,0,253,686,170,975,0,261,309,337]\\n\\nMy code outputs 2016, whereas the answer expected is 2560, although I am not sure how 2560 is reached bc from my understanding we are trying to find the max depth, and in that case 2016 should be the maxdepth sum\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[4->10:686][10->3:1023][3->9:1276][9->1:1585][1->7:1798] pathTime=1798\\n[9->6:1585][6->2:2560] pathTime=2560\\n[9->8:1585][8->5:1846][5->0:2016] pathTime=2016\\n\\nans=2560"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This is right test case to be added in description.\nI do face similar challenge when i tried to calculate maxDepth = Maxtime required for each children. And adding back to result.\nWhereas, you probably has to calculate depth including its manager's informTime and find which child has maxReporting time.\n\ne.g. x (root) = 30, \ny (child of x) =50,  w (child of x)  =100\nz (child of y) = 40,\n\nthen max time would be Max (30+50+40, 30+100)\nI hope this can help you to find root cause on your solution."
                    },
                    {
                        "username": "nikhilsharma7860598916",
                        "content": "I solved this question few minutes ago and it got accepted, but still my it\\'s not showing in my streak.  It\\'s saying \"Solve today\\'s Daily Challenge to refresh your streak!\" .. \\nI refreshed multiple times and submitted different solutions still its not updating.                                     \\nAny suggestions . What should I do? "
                    },
                    {
                        "username": "charonme",
                        "content": "mine too\n[edit] ah it finally updated now"
                    },
                    {
                        "username": "khe1154",
                        "content": "these examples are very bad which makes this question unnecessarily difficult"
                    },
                    {
                        "username": "coutdiv",
                        "content": "Examples are so bad in this problem, both the given test cases are almost useless"
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "another shitty explanation from leetcode"
                    },
                    {
                        "username": "jsparrow0404",
                        "content": "using `find` technique from `union-find algorithm` solve this problem."
                    },
                    {
                        "username": "Paulie_FromSopranos",
                        "content": "This is not a hard problem, however, both the wording and examples don\\'t really help."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": " `Probably the Head wants to Inform the news of RECESSION`"
                    }
                ]
            },
            {
                "id": 1914939,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "solution accepted but streak not increase "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It\\'s a word puzzle."
                    },
                    {
                        "username": "yabyer1",
                        "content": "For Testcase\\n\\nn= 11\\nheadId = 4\\nmanager = [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime = [0,213,0,253,686,170,975,0,261,309,337]\\n\\nMy code outputs 2016, whereas the answer expected is 2560, although I am not sure how 2560 is reached bc from my understanding we are trying to find the max depth, and in that case 2016 should be the maxdepth sum\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[4->10:686][10->3:1023][3->9:1276][9->1:1585][1->7:1798] pathTime=1798\\n[9->6:1585][6->2:2560] pathTime=2560\\n[9->8:1585][8->5:1846][5->0:2016] pathTime=2016\\n\\nans=2560"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This is right test case to be added in description.\nI do face similar challenge when i tried to calculate maxDepth = Maxtime required for each children. And adding back to result.\nWhereas, you probably has to calculate depth including its manager's informTime and find which child has maxReporting time.\n\ne.g. x (root) = 30, \ny (child of x) =50,  w (child of x)  =100\nz (child of y) = 40,\n\nthen max time would be Max (30+50+40, 30+100)\nI hope this can help you to find root cause on your solution."
                    },
                    {
                        "username": "nikhilsharma7860598916",
                        "content": "I solved this question few minutes ago and it got accepted, but still my it\\'s not showing in my streak.  It\\'s saying \"Solve today\\'s Daily Challenge to refresh your streak!\" .. \\nI refreshed multiple times and submitted different solutions still its not updating.                                     \\nAny suggestions . What should I do? "
                    },
                    {
                        "username": "charonme",
                        "content": "mine too\n[edit] ah it finally updated now"
                    },
                    {
                        "username": "khe1154",
                        "content": "these examples are very bad which makes this question unnecessarily difficult"
                    },
                    {
                        "username": "coutdiv",
                        "content": "Examples are so bad in this problem, both the given test cases are almost useless"
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "another shitty explanation from leetcode"
                    },
                    {
                        "username": "jsparrow0404",
                        "content": "using `find` technique from `union-find algorithm` solve this problem."
                    },
                    {
                        "username": "Paulie_FromSopranos",
                        "content": "This is not a hard problem, however, both the wording and examples don\\'t really help."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": " `Probably the Head wants to Inform the news of RECESSION`"
                    }
                ]
            },
            {
                "id": 1914687,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "solution accepted but streak not increase "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It\\'s a word puzzle."
                    },
                    {
                        "username": "yabyer1",
                        "content": "For Testcase\\n\\nn= 11\\nheadId = 4\\nmanager = [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime = [0,213,0,253,686,170,975,0,261,309,337]\\n\\nMy code outputs 2016, whereas the answer expected is 2560, although I am not sure how 2560 is reached bc from my understanding we are trying to find the max depth, and in that case 2016 should be the maxdepth sum\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[4->10:686][10->3:1023][3->9:1276][9->1:1585][1->7:1798] pathTime=1798\\n[9->6:1585][6->2:2560] pathTime=2560\\n[9->8:1585][8->5:1846][5->0:2016] pathTime=2016\\n\\nans=2560"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This is right test case to be added in description.\nI do face similar challenge when i tried to calculate maxDepth = Maxtime required for each children. And adding back to result.\nWhereas, you probably has to calculate depth including its manager's informTime and find which child has maxReporting time.\n\ne.g. x (root) = 30, \ny (child of x) =50,  w (child of x)  =100\nz (child of y) = 40,\n\nthen max time would be Max (30+50+40, 30+100)\nI hope this can help you to find root cause on your solution."
                    },
                    {
                        "username": "nikhilsharma7860598916",
                        "content": "I solved this question few minutes ago and it got accepted, but still my it\\'s not showing in my streak.  It\\'s saying \"Solve today\\'s Daily Challenge to refresh your streak!\" .. \\nI refreshed multiple times and submitted different solutions still its not updating.                                     \\nAny suggestions . What should I do? "
                    },
                    {
                        "username": "charonme",
                        "content": "mine too\n[edit] ah it finally updated now"
                    },
                    {
                        "username": "khe1154",
                        "content": "these examples are very bad which makes this question unnecessarily difficult"
                    },
                    {
                        "username": "coutdiv",
                        "content": "Examples are so bad in this problem, both the given test cases are almost useless"
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "another shitty explanation from leetcode"
                    },
                    {
                        "username": "jsparrow0404",
                        "content": "using `find` technique from `union-find algorithm` solve this problem."
                    },
                    {
                        "username": "Paulie_FromSopranos",
                        "content": "This is not a hard problem, however, both the wording and examples don\\'t really help."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": " `Probably the Head wants to Inform the news of RECESSION`"
                    }
                ]
            },
            {
                "id": 1901230,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "solution accepted but streak not increase "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It\\'s a word puzzle."
                    },
                    {
                        "username": "yabyer1",
                        "content": "For Testcase\\n\\nn= 11\\nheadId = 4\\nmanager = [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime = [0,213,0,253,686,170,975,0,261,309,337]\\n\\nMy code outputs 2016, whereas the answer expected is 2560, although I am not sure how 2560 is reached bc from my understanding we are trying to find the max depth, and in that case 2016 should be the maxdepth sum\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[4->10:686][10->3:1023][3->9:1276][9->1:1585][1->7:1798] pathTime=1798\\n[9->6:1585][6->2:2560] pathTime=2560\\n[9->8:1585][8->5:1846][5->0:2016] pathTime=2016\\n\\nans=2560"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This is right test case to be added in description.\nI do face similar challenge when i tried to calculate maxDepth = Maxtime required for each children. And adding back to result.\nWhereas, you probably has to calculate depth including its manager's informTime and find which child has maxReporting time.\n\ne.g. x (root) = 30, \ny (child of x) =50,  w (child of x)  =100\nz (child of y) = 40,\n\nthen max time would be Max (30+50+40, 30+100)\nI hope this can help you to find root cause on your solution."
                    },
                    {
                        "username": "nikhilsharma7860598916",
                        "content": "I solved this question few minutes ago and it got accepted, but still my it\\'s not showing in my streak.  It\\'s saying \"Solve today\\'s Daily Challenge to refresh your streak!\" .. \\nI refreshed multiple times and submitted different solutions still its not updating.                                     \\nAny suggestions . What should I do? "
                    },
                    {
                        "username": "charonme",
                        "content": "mine too\n[edit] ah it finally updated now"
                    },
                    {
                        "username": "khe1154",
                        "content": "these examples are very bad which makes this question unnecessarily difficult"
                    },
                    {
                        "username": "coutdiv",
                        "content": "Examples are so bad in this problem, both the given test cases are almost useless"
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "another shitty explanation from leetcode"
                    },
                    {
                        "username": "jsparrow0404",
                        "content": "using `find` technique from `union-find algorithm` solve this problem."
                    },
                    {
                        "username": "Paulie_FromSopranos",
                        "content": "This is not a hard problem, however, both the wording and examples don\\'t really help."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": " `Probably the Head wants to Inform the news of RECESSION`"
                    }
                ]
            },
            {
                "id": 1914957,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "solution accepted but streak not increase "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It\\'s a word puzzle."
                    },
                    {
                        "username": "yabyer1",
                        "content": "For Testcase\\n\\nn= 11\\nheadId = 4\\nmanager = [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime = [0,213,0,253,686,170,975,0,261,309,337]\\n\\nMy code outputs 2016, whereas the answer expected is 2560, although I am not sure how 2560 is reached bc from my understanding we are trying to find the max depth, and in that case 2016 should be the maxdepth sum\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[4->10:686][10->3:1023][3->9:1276][9->1:1585][1->7:1798] pathTime=1798\\n[9->6:1585][6->2:2560] pathTime=2560\\n[9->8:1585][8->5:1846][5->0:2016] pathTime=2016\\n\\nans=2560"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This is right test case to be added in description.\nI do face similar challenge when i tried to calculate maxDepth = Maxtime required for each children. And adding back to result.\nWhereas, you probably has to calculate depth including its manager's informTime and find which child has maxReporting time.\n\ne.g. x (root) = 30, \ny (child of x) =50,  w (child of x)  =100\nz (child of y) = 40,\n\nthen max time would be Max (30+50+40, 30+100)\nI hope this can help you to find root cause on your solution."
                    },
                    {
                        "username": "nikhilsharma7860598916",
                        "content": "I solved this question few minutes ago and it got accepted, but still my it\\'s not showing in my streak.  It\\'s saying \"Solve today\\'s Daily Challenge to refresh your streak!\" .. \\nI refreshed multiple times and submitted different solutions still its not updating.                                     \\nAny suggestions . What should I do? "
                    },
                    {
                        "username": "charonme",
                        "content": "mine too\n[edit] ah it finally updated now"
                    },
                    {
                        "username": "khe1154",
                        "content": "these examples are very bad which makes this question unnecessarily difficult"
                    },
                    {
                        "username": "coutdiv",
                        "content": "Examples are so bad in this problem, both the given test cases are almost useless"
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "another shitty explanation from leetcode"
                    },
                    {
                        "username": "jsparrow0404",
                        "content": "using `find` technique from `union-find algorithm` solve this problem."
                    },
                    {
                        "username": "Paulie_FromSopranos",
                        "content": "This is not a hard problem, however, both the wording and examples don\\'t really help."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": " `Probably the Head wants to Inform the news of RECESSION`"
                    }
                ]
            },
            {
                "id": 1915336,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "solution accepted but streak not increase "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It\\'s a word puzzle."
                    },
                    {
                        "username": "yabyer1",
                        "content": "For Testcase\\n\\nn= 11\\nheadId = 4\\nmanager = [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime = [0,213,0,253,686,170,975,0,261,309,337]\\n\\nMy code outputs 2016, whereas the answer expected is 2560, although I am not sure how 2560 is reached bc from my understanding we are trying to find the max depth, and in that case 2016 should be the maxdepth sum\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[4->10:686][10->3:1023][3->9:1276][9->1:1585][1->7:1798] pathTime=1798\\n[9->6:1585][6->2:2560] pathTime=2560\\n[9->8:1585][8->5:1846][5->0:2016] pathTime=2016\\n\\nans=2560"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This is right test case to be added in description.\nI do face similar challenge when i tried to calculate maxDepth = Maxtime required for each children. And adding back to result.\nWhereas, you probably has to calculate depth including its manager's informTime and find which child has maxReporting time.\n\ne.g. x (root) = 30, \ny (child of x) =50,  w (child of x)  =100\nz (child of y) = 40,\n\nthen max time would be Max (30+50+40, 30+100)\nI hope this can help you to find root cause on your solution."
                    },
                    {
                        "username": "nikhilsharma7860598916",
                        "content": "I solved this question few minutes ago and it got accepted, but still my it\\'s not showing in my streak.  It\\'s saying \"Solve today\\'s Daily Challenge to refresh your streak!\" .. \\nI refreshed multiple times and submitted different solutions still its not updating.                                     \\nAny suggestions . What should I do? "
                    },
                    {
                        "username": "charonme",
                        "content": "mine too\n[edit] ah it finally updated now"
                    },
                    {
                        "username": "khe1154",
                        "content": "these examples are very bad which makes this question unnecessarily difficult"
                    },
                    {
                        "username": "coutdiv",
                        "content": "Examples are so bad in this problem, both the given test cases are almost useless"
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "another shitty explanation from leetcode"
                    },
                    {
                        "username": "jsparrow0404",
                        "content": "using `find` technique from `union-find algorithm` solve this problem."
                    },
                    {
                        "username": "Paulie_FromSopranos",
                        "content": "This is not a hard problem, however, both the wording and examples don\\'t really help."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": " `Probably the Head wants to Inform the news of RECESSION`"
                    }
                ]
            },
            {
                "id": 1915267,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "solution accepted but streak not increase "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It\\'s a word puzzle."
                    },
                    {
                        "username": "yabyer1",
                        "content": "For Testcase\\n\\nn= 11\\nheadId = 4\\nmanager = [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime = [0,213,0,253,686,170,975,0,261,309,337]\\n\\nMy code outputs 2016, whereas the answer expected is 2560, although I am not sure how 2560 is reached bc from my understanding we are trying to find the max depth, and in that case 2016 should be the maxdepth sum\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[4->10:686][10->3:1023][3->9:1276][9->1:1585][1->7:1798] pathTime=1798\\n[9->6:1585][6->2:2560] pathTime=2560\\n[9->8:1585][8->5:1846][5->0:2016] pathTime=2016\\n\\nans=2560"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This is right test case to be added in description.\nI do face similar challenge when i tried to calculate maxDepth = Maxtime required for each children. And adding back to result.\nWhereas, you probably has to calculate depth including its manager's informTime and find which child has maxReporting time.\n\ne.g. x (root) = 30, \ny (child of x) =50,  w (child of x)  =100\nz (child of y) = 40,\n\nthen max time would be Max (30+50+40, 30+100)\nI hope this can help you to find root cause on your solution."
                    },
                    {
                        "username": "nikhilsharma7860598916",
                        "content": "I solved this question few minutes ago and it got accepted, but still my it\\'s not showing in my streak.  It\\'s saying \"Solve today\\'s Daily Challenge to refresh your streak!\" .. \\nI refreshed multiple times and submitted different solutions still its not updating.                                     \\nAny suggestions . What should I do? "
                    },
                    {
                        "username": "charonme",
                        "content": "mine too\n[edit] ah it finally updated now"
                    },
                    {
                        "username": "khe1154",
                        "content": "these examples are very bad which makes this question unnecessarily difficult"
                    },
                    {
                        "username": "coutdiv",
                        "content": "Examples are so bad in this problem, both the given test cases are almost useless"
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "another shitty explanation from leetcode"
                    },
                    {
                        "username": "jsparrow0404",
                        "content": "using `find` technique from `union-find algorithm` solve this problem."
                    },
                    {
                        "username": "Paulie_FromSopranos",
                        "content": "This is not a hard problem, however, both the wording and examples don\\'t really help."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": " `Probably the Head wants to Inform the news of RECESSION`"
                    }
                ]
            },
            {
                "id": 1915059,
                "content": [
                    {
                        "username": "mandliyarajendra11",
                        "content": "solution accepted but streak not increase "
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "It\\'s a word puzzle."
                    },
                    {
                        "username": "yabyer1",
                        "content": "For Testcase\\n\\nn= 11\\nheadId = 4\\nmanager = [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime = [0,213,0,253,686,170,975,0,261,309,337]\\n\\nMy code outputs 2016, whereas the answer expected is 2560, although I am not sure how 2560 is reached bc from my understanding we are trying to find the max depth, and in that case 2016 should be the maxdepth sum\\n"
                    },
                    {
                        "username": "anwendeng",
                        "content": "[4->10:686][10->3:1023][3->9:1276][9->1:1585][1->7:1798] pathTime=1798\\n[9->6:1585][6->2:2560] pathTime=2560\\n[9->8:1585][8->5:1846][5->0:2016] pathTime=2016\\n\\nans=2560"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "This is right test case to be added in description.\nI do face similar challenge when i tried to calculate maxDepth = Maxtime required for each children. And adding back to result.\nWhereas, you probably has to calculate depth including its manager's informTime and find which child has maxReporting time.\n\ne.g. x (root) = 30, \ny (child of x) =50,  w (child of x)  =100\nz (child of y) = 40,\n\nthen max time would be Max (30+50+40, 30+100)\nI hope this can help you to find root cause on your solution."
                    },
                    {
                        "username": "nikhilsharma7860598916",
                        "content": "I solved this question few minutes ago and it got accepted, but still my it\\'s not showing in my streak.  It\\'s saying \"Solve today\\'s Daily Challenge to refresh your streak!\" .. \\nI refreshed multiple times and submitted different solutions still its not updating.                                     \\nAny suggestions . What should I do? "
                    },
                    {
                        "username": "charonme",
                        "content": "mine too\n[edit] ah it finally updated now"
                    },
                    {
                        "username": "khe1154",
                        "content": "these examples are very bad which makes this question unnecessarily difficult"
                    },
                    {
                        "username": "coutdiv",
                        "content": "Examples are so bad in this problem, both the given test cases are almost useless"
                    },
                    {
                        "username": "goyalshreyansh21",
                        "content": "another shitty explanation from leetcode"
                    },
                    {
                        "username": "jsparrow0404",
                        "content": "using `find` technique from `union-find algorithm` solve this problem."
                    },
                    {
                        "username": "Paulie_FromSopranos",
                        "content": "This is not a hard problem, however, both the wording and examples don\\'t really help."
                    },
                    {
                        "username": "psycho_pirate",
                        "content": " `Probably the Head wants to Inform the news of RECESSION`"
                    }
                ]
            },
            {
                "id": 1914700,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "why even include examples when they are worthless? this is more a test of reading comprehension than coding skills "
                    },
                    {
                        "username": "user2418Bg",
                        "content": "Remember that there are N employees and that each manager in `manager` is the manager of the Nth employee. With that information, a graph can be built where we map managers to direct reports. Using the 2nd example provided, a graph would look something like `{2: [0, 1, 3, 4, 5], -1: [2]}`.  The values in the graph represent indices in `informTime`. For example, `manager` with id `2`  and employee ID of `0` from our map **{2: [0,** ...], } requires 0 minutes of inform time from `informTime` because `informTime[0]` = 0. Similarly, {2: [0, 1, 3, 4, 5], **-1: [2]**} from our map, means that `informTime[2]` represents how long it will take employee with ID of `2` to inform their directs (from the 2nd example, this means that employee with ID of `2` will take 1 to inform their directs because `informTime[2] = 1`). Using that information, you can traverse the graph to get the number of minutes to inform all employees. \n\n**TLDR** \n\n1) Make a graph of `managers` to employees (`N`) - something like `{2: [0, 1, 3, 4, 5], -1: [2]}`\n2) Traverse the graph and get the number of minutes it will take to inform direct reports from `informTime` \n\n"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Solution in C# takes 74 lines of code with all null checks, type casts and exception handling. Same thing in JS is just 31 lines and no casts or checks required. Are some languages at a disadvantage as opposed to others? Is pseudocode on the whiteboard enough in a real interview setting? Any thoughts appreciated. "
                    },
                    {
                        "username": "psionl0",
                        "content": "My C solution takes 39 lines - all coded from scratch since I don\\'t have access to any special Graph libraries. \\nhttps://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/962725627/"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Pinnacle of bad examples!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Can someone Suggest me more questions where the input format is this kind only ?\\nIt would be really helpful \\nThanks"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can somebody  help me please ?, My code for \"Time needed to inform All Employees\" fails on  TEST CASE 15, It says \\'Out Put is 5 expected 3\\' but on my visual studio compiler, with the same test case the output is 3. Please check my code and test it. Thank you!"
                    },
                    {
                        "username": "manavmehta",
                        "content": "I want to understand why my solution, begin iterative and handling duplicate traversals, is slower than a recursive solution. The recursive solution must have overheads and should be rather slower. How much? recursive is 117 ms and mine is 738ms. And these are consistent performance results. My solution ranges in +- 10% of the range and so does the recursive. Where am I missing out?\n\nmy solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591970/c-concise-and-intuitive-dfs/\n\nrecursive solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/964379669/ \nPlease ignore these lines as they did not make any difference.\n```\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\n```"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "shouldnt dfs work as well , since all possibilities/nodes are anyways visited?... "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "I dont know, what a fool am I . My initial idea was to get maxTime of each level in a BFS and add them up. Then I realized that max of each level doesnt play role but each depth play a big role so ended up solving this by dfs and passing maxTime in post order. God help me...why do I take so much time in these problems "
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Could any one see where is the mistake iam getting TLE error for some  Test Cases\\n\\nclass Solution {\\npublic:\\n    void dfs (int head , map < int,vector<int>> mp,vector <int> informtime,int & path_length,int & time){\\n\\n        if (mp.find(head)== mp.end()){\\n            time = max(time,path_length);\\n            return;\\n        }\\n        \\n        path_length+=informtime[head];\\n        \\n        for (auto x : mp[head]){\\n            dfs(x,mp,informtime,path_length,time);   \\n        }\\n        path_length -= informtime[head];\\n        return ;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        map <int,vector<int>> mp;\\n        int numOfminutes = 0;\\n        int path_length = 0 ;\\n        if (n ==1)return numOfminutes;\\n\\n        for (int i = 0 ; i < n;i++){\\n            if (manager[i]!=-1)mp[manager[i]].push_back(i);\\n        }\\n        \\n        dfs(headID,mp,informTime,path_length,numOfminutes);\\n\\n        return numOfminutes;\\n\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1842364,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "why even include examples when they are worthless? this is more a test of reading comprehension than coding skills "
                    },
                    {
                        "username": "user2418Bg",
                        "content": "Remember that there are N employees and that each manager in `manager` is the manager of the Nth employee. With that information, a graph can be built where we map managers to direct reports. Using the 2nd example provided, a graph would look something like `{2: [0, 1, 3, 4, 5], -1: [2]}`.  The values in the graph represent indices in `informTime`. For example, `manager` with id `2`  and employee ID of `0` from our map **{2: [0,** ...], } requires 0 minutes of inform time from `informTime` because `informTime[0]` = 0. Similarly, {2: [0, 1, 3, 4, 5], **-1: [2]**} from our map, means that `informTime[2]` represents how long it will take employee with ID of `2` to inform their directs (from the 2nd example, this means that employee with ID of `2` will take 1 to inform their directs because `informTime[2] = 1`). Using that information, you can traverse the graph to get the number of minutes to inform all employees. \n\n**TLDR** \n\n1) Make a graph of `managers` to employees (`N`) - something like `{2: [0, 1, 3, 4, 5], -1: [2]}`\n2) Traverse the graph and get the number of minutes it will take to inform direct reports from `informTime` \n\n"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Solution in C# takes 74 lines of code with all null checks, type casts and exception handling. Same thing in JS is just 31 lines and no casts or checks required. Are some languages at a disadvantage as opposed to others? Is pseudocode on the whiteboard enough in a real interview setting? Any thoughts appreciated. "
                    },
                    {
                        "username": "psionl0",
                        "content": "My C solution takes 39 lines - all coded from scratch since I don\\'t have access to any special Graph libraries. \\nhttps://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/962725627/"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Pinnacle of bad examples!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Can someone Suggest me more questions where the input format is this kind only ?\\nIt would be really helpful \\nThanks"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can somebody  help me please ?, My code for \"Time needed to inform All Employees\" fails on  TEST CASE 15, It says \\'Out Put is 5 expected 3\\' but on my visual studio compiler, with the same test case the output is 3. Please check my code and test it. Thank you!"
                    },
                    {
                        "username": "manavmehta",
                        "content": "I want to understand why my solution, begin iterative and handling duplicate traversals, is slower than a recursive solution. The recursive solution must have overheads and should be rather slower. How much? recursive is 117 ms and mine is 738ms. And these are consistent performance results. My solution ranges in +- 10% of the range and so does the recursive. Where am I missing out?\n\nmy solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591970/c-concise-and-intuitive-dfs/\n\nrecursive solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/964379669/ \nPlease ignore these lines as they did not make any difference.\n```\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\n```"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "shouldnt dfs work as well , since all possibilities/nodes are anyways visited?... "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "I dont know, what a fool am I . My initial idea was to get maxTime of each level in a BFS and add them up. Then I realized that max of each level doesnt play role but each depth play a big role so ended up solving this by dfs and passing maxTime in post order. God help me...why do I take so much time in these problems "
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Could any one see where is the mistake iam getting TLE error for some  Test Cases\\n\\nclass Solution {\\npublic:\\n    void dfs (int head , map < int,vector<int>> mp,vector <int> informtime,int & path_length,int & time){\\n\\n        if (mp.find(head)== mp.end()){\\n            time = max(time,path_length);\\n            return;\\n        }\\n        \\n        path_length+=informtime[head];\\n        \\n        for (auto x : mp[head]){\\n            dfs(x,mp,informtime,path_length,time);   \\n        }\\n        path_length -= informtime[head];\\n        return ;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        map <int,vector<int>> mp;\\n        int numOfminutes = 0;\\n        int path_length = 0 ;\\n        if (n ==1)return numOfminutes;\\n\\n        for (int i = 0 ; i < n;i++){\\n            if (manager[i]!=-1)mp[manager[i]].push_back(i);\\n        }\\n        \\n        dfs(headID,mp,informTime,path_length,numOfminutes);\\n\\n        return numOfminutes;\\n\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1701020,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "why even include examples when they are worthless? this is more a test of reading comprehension than coding skills "
                    },
                    {
                        "username": "user2418Bg",
                        "content": "Remember that there are N employees and that each manager in `manager` is the manager of the Nth employee. With that information, a graph can be built where we map managers to direct reports. Using the 2nd example provided, a graph would look something like `{2: [0, 1, 3, 4, 5], -1: [2]}`.  The values in the graph represent indices in `informTime`. For example, `manager` with id `2`  and employee ID of `0` from our map **{2: [0,** ...], } requires 0 minutes of inform time from `informTime` because `informTime[0]` = 0. Similarly, {2: [0, 1, 3, 4, 5], **-1: [2]**} from our map, means that `informTime[2]` represents how long it will take employee with ID of `2` to inform their directs (from the 2nd example, this means that employee with ID of `2` will take 1 to inform their directs because `informTime[2] = 1`). Using that information, you can traverse the graph to get the number of minutes to inform all employees. \n\n**TLDR** \n\n1) Make a graph of `managers` to employees (`N`) - something like `{2: [0, 1, 3, 4, 5], -1: [2]}`\n2) Traverse the graph and get the number of minutes it will take to inform direct reports from `informTime` \n\n"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Solution in C# takes 74 lines of code with all null checks, type casts and exception handling. Same thing in JS is just 31 lines and no casts or checks required. Are some languages at a disadvantage as opposed to others? Is pseudocode on the whiteboard enough in a real interview setting? Any thoughts appreciated. "
                    },
                    {
                        "username": "psionl0",
                        "content": "My C solution takes 39 lines - all coded from scratch since I don\\'t have access to any special Graph libraries. \\nhttps://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/962725627/"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Pinnacle of bad examples!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Can someone Suggest me more questions where the input format is this kind only ?\\nIt would be really helpful \\nThanks"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can somebody  help me please ?, My code for \"Time needed to inform All Employees\" fails on  TEST CASE 15, It says \\'Out Put is 5 expected 3\\' but on my visual studio compiler, with the same test case the output is 3. Please check my code and test it. Thank you!"
                    },
                    {
                        "username": "manavmehta",
                        "content": "I want to understand why my solution, begin iterative and handling duplicate traversals, is slower than a recursive solution. The recursive solution must have overheads and should be rather slower. How much? recursive is 117 ms and mine is 738ms. And these are consistent performance results. My solution ranges in +- 10% of the range and so does the recursive. Where am I missing out?\n\nmy solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591970/c-concise-and-intuitive-dfs/\n\nrecursive solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/964379669/ \nPlease ignore these lines as they did not make any difference.\n```\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\n```"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "shouldnt dfs work as well , since all possibilities/nodes are anyways visited?... "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "I dont know, what a fool am I . My initial idea was to get maxTime of each level in a BFS and add them up. Then I realized that max of each level doesnt play role but each depth play a big role so ended up solving this by dfs and passing maxTime in post order. God help me...why do I take so much time in these problems "
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Could any one see where is the mistake iam getting TLE error for some  Test Cases\\n\\nclass Solution {\\npublic:\\n    void dfs (int head , map < int,vector<int>> mp,vector <int> informtime,int & path_length,int & time){\\n\\n        if (mp.find(head)== mp.end()){\\n            time = max(time,path_length);\\n            return;\\n        }\\n        \\n        path_length+=informtime[head];\\n        \\n        for (auto x : mp[head]){\\n            dfs(x,mp,informtime,path_length,time);   \\n        }\\n        path_length -= informtime[head];\\n        return ;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        map <int,vector<int>> mp;\\n        int numOfminutes = 0;\\n        int path_length = 0 ;\\n        if (n ==1)return numOfminutes;\\n\\n        for (int i = 0 ; i < n;i++){\\n            if (manager[i]!=-1)mp[manager[i]].push_back(i);\\n        }\\n        \\n        dfs(headID,mp,informTime,path_length,numOfminutes);\\n\\n        return numOfminutes;\\n\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1914733,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "why even include examples when they are worthless? this is more a test of reading comprehension than coding skills "
                    },
                    {
                        "username": "user2418Bg",
                        "content": "Remember that there are N employees and that each manager in `manager` is the manager of the Nth employee. With that information, a graph can be built where we map managers to direct reports. Using the 2nd example provided, a graph would look something like `{2: [0, 1, 3, 4, 5], -1: [2]}`.  The values in the graph represent indices in `informTime`. For example, `manager` with id `2`  and employee ID of `0` from our map **{2: [0,** ...], } requires 0 minutes of inform time from `informTime` because `informTime[0]` = 0. Similarly, {2: [0, 1, 3, 4, 5], **-1: [2]**} from our map, means that `informTime[2]` represents how long it will take employee with ID of `2` to inform their directs (from the 2nd example, this means that employee with ID of `2` will take 1 to inform their directs because `informTime[2] = 1`). Using that information, you can traverse the graph to get the number of minutes to inform all employees. \n\n**TLDR** \n\n1) Make a graph of `managers` to employees (`N`) - something like `{2: [0, 1, 3, 4, 5], -1: [2]}`\n2) Traverse the graph and get the number of minutes it will take to inform direct reports from `informTime` \n\n"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Solution in C# takes 74 lines of code with all null checks, type casts and exception handling. Same thing in JS is just 31 lines and no casts or checks required. Are some languages at a disadvantage as opposed to others? Is pseudocode on the whiteboard enough in a real interview setting? Any thoughts appreciated. "
                    },
                    {
                        "username": "psionl0",
                        "content": "My C solution takes 39 lines - all coded from scratch since I don\\'t have access to any special Graph libraries. \\nhttps://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/962725627/"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Pinnacle of bad examples!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Can someone Suggest me more questions where the input format is this kind only ?\\nIt would be really helpful \\nThanks"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can somebody  help me please ?, My code for \"Time needed to inform All Employees\" fails on  TEST CASE 15, It says \\'Out Put is 5 expected 3\\' but on my visual studio compiler, with the same test case the output is 3. Please check my code and test it. Thank you!"
                    },
                    {
                        "username": "manavmehta",
                        "content": "I want to understand why my solution, begin iterative and handling duplicate traversals, is slower than a recursive solution. The recursive solution must have overheads and should be rather slower. How much? recursive is 117 ms and mine is 738ms. And these are consistent performance results. My solution ranges in +- 10% of the range and so does the recursive. Where am I missing out?\n\nmy solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591970/c-concise-and-intuitive-dfs/\n\nrecursive solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/964379669/ \nPlease ignore these lines as they did not make any difference.\n```\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\n```"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "shouldnt dfs work as well , since all possibilities/nodes are anyways visited?... "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "I dont know, what a fool am I . My initial idea was to get maxTime of each level in a BFS and add them up. Then I realized that max of each level doesnt play role but each depth play a big role so ended up solving this by dfs and passing maxTime in post order. God help me...why do I take so much time in these problems "
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Could any one see where is the mistake iam getting TLE error for some  Test Cases\\n\\nclass Solution {\\npublic:\\n    void dfs (int head , map < int,vector<int>> mp,vector <int> informtime,int & path_length,int & time){\\n\\n        if (mp.find(head)== mp.end()){\\n            time = max(time,path_length);\\n            return;\\n        }\\n        \\n        path_length+=informtime[head];\\n        \\n        for (auto x : mp[head]){\\n            dfs(x,mp,informtime,path_length,time);   \\n        }\\n        path_length -= informtime[head];\\n        return ;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        map <int,vector<int>> mp;\\n        int numOfminutes = 0;\\n        int path_length = 0 ;\\n        if (n ==1)return numOfminutes;\\n\\n        for (int i = 0 ; i < n;i++){\\n            if (manager[i]!=-1)mp[manager[i]].push_back(i);\\n        }\\n        \\n        dfs(headID,mp,informTime,path_length,numOfminutes);\\n\\n        return numOfminutes;\\n\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1999182,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "why even include examples when they are worthless? this is more a test of reading comprehension than coding skills "
                    },
                    {
                        "username": "user2418Bg",
                        "content": "Remember that there are N employees and that each manager in `manager` is the manager of the Nth employee. With that information, a graph can be built where we map managers to direct reports. Using the 2nd example provided, a graph would look something like `{2: [0, 1, 3, 4, 5], -1: [2]}`.  The values in the graph represent indices in `informTime`. For example, `manager` with id `2`  and employee ID of `0` from our map **{2: [0,** ...], } requires 0 minutes of inform time from `informTime` because `informTime[0]` = 0. Similarly, {2: [0, 1, 3, 4, 5], **-1: [2]**} from our map, means that `informTime[2]` represents how long it will take employee with ID of `2` to inform their directs (from the 2nd example, this means that employee with ID of `2` will take 1 to inform their directs because `informTime[2] = 1`). Using that information, you can traverse the graph to get the number of minutes to inform all employees. \n\n**TLDR** \n\n1) Make a graph of `managers` to employees (`N`) - something like `{2: [0, 1, 3, 4, 5], -1: [2]}`\n2) Traverse the graph and get the number of minutes it will take to inform direct reports from `informTime` \n\n"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Solution in C# takes 74 lines of code with all null checks, type casts and exception handling. Same thing in JS is just 31 lines and no casts or checks required. Are some languages at a disadvantage as opposed to others? Is pseudocode on the whiteboard enough in a real interview setting? Any thoughts appreciated. "
                    },
                    {
                        "username": "psionl0",
                        "content": "My C solution takes 39 lines - all coded from scratch since I don\\'t have access to any special Graph libraries. \\nhttps://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/962725627/"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Pinnacle of bad examples!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Can someone Suggest me more questions where the input format is this kind only ?\\nIt would be really helpful \\nThanks"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can somebody  help me please ?, My code for \"Time needed to inform All Employees\" fails on  TEST CASE 15, It says \\'Out Put is 5 expected 3\\' but on my visual studio compiler, with the same test case the output is 3. Please check my code and test it. Thank you!"
                    },
                    {
                        "username": "manavmehta",
                        "content": "I want to understand why my solution, begin iterative and handling duplicate traversals, is slower than a recursive solution. The recursive solution must have overheads and should be rather slower. How much? recursive is 117 ms and mine is 738ms. And these are consistent performance results. My solution ranges in +- 10% of the range and so does the recursive. Where am I missing out?\n\nmy solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591970/c-concise-and-intuitive-dfs/\n\nrecursive solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/964379669/ \nPlease ignore these lines as they did not make any difference.\n```\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\n```"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "shouldnt dfs work as well , since all possibilities/nodes are anyways visited?... "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "I dont know, what a fool am I . My initial idea was to get maxTime of each level in a BFS and add them up. Then I realized that max of each level doesnt play role but each depth play a big role so ended up solving this by dfs and passing maxTime in post order. God help me...why do I take so much time in these problems "
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Could any one see where is the mistake iam getting TLE error for some  Test Cases\\n\\nclass Solution {\\npublic:\\n    void dfs (int head , map < int,vector<int>> mp,vector <int> informtime,int & path_length,int & time){\\n\\n        if (mp.find(head)== mp.end()){\\n            time = max(time,path_length);\\n            return;\\n        }\\n        \\n        path_length+=informtime[head];\\n        \\n        for (auto x : mp[head]){\\n            dfs(x,mp,informtime,path_length,time);   \\n        }\\n        path_length -= informtime[head];\\n        return ;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        map <int,vector<int>> mp;\\n        int numOfminutes = 0;\\n        int path_length = 0 ;\\n        if (n ==1)return numOfminutes;\\n\\n        for (int i = 0 ; i < n;i++){\\n            if (manager[i]!=-1)mp[manager[i]].push_back(i);\\n        }\\n        \\n        dfs(headID,mp,informTime,path_length,numOfminutes);\\n\\n        return numOfminutes;\\n\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1939668,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "why even include examples when they are worthless? this is more a test of reading comprehension than coding skills "
                    },
                    {
                        "username": "user2418Bg",
                        "content": "Remember that there are N employees and that each manager in `manager` is the manager of the Nth employee. With that information, a graph can be built where we map managers to direct reports. Using the 2nd example provided, a graph would look something like `{2: [0, 1, 3, 4, 5], -1: [2]}`.  The values in the graph represent indices in `informTime`. For example, `manager` with id `2`  and employee ID of `0` from our map **{2: [0,** ...], } requires 0 minutes of inform time from `informTime` because `informTime[0]` = 0. Similarly, {2: [0, 1, 3, 4, 5], **-1: [2]**} from our map, means that `informTime[2]` represents how long it will take employee with ID of `2` to inform their directs (from the 2nd example, this means that employee with ID of `2` will take 1 to inform their directs because `informTime[2] = 1`). Using that information, you can traverse the graph to get the number of minutes to inform all employees. \n\n**TLDR** \n\n1) Make a graph of `managers` to employees (`N`) - something like `{2: [0, 1, 3, 4, 5], -1: [2]}`\n2) Traverse the graph and get the number of minutes it will take to inform direct reports from `informTime` \n\n"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Solution in C# takes 74 lines of code with all null checks, type casts and exception handling. Same thing in JS is just 31 lines and no casts or checks required. Are some languages at a disadvantage as opposed to others? Is pseudocode on the whiteboard enough in a real interview setting? Any thoughts appreciated. "
                    },
                    {
                        "username": "psionl0",
                        "content": "My C solution takes 39 lines - all coded from scratch since I don\\'t have access to any special Graph libraries. \\nhttps://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/962725627/"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Pinnacle of bad examples!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Can someone Suggest me more questions where the input format is this kind only ?\\nIt would be really helpful \\nThanks"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can somebody  help me please ?, My code for \"Time needed to inform All Employees\" fails on  TEST CASE 15, It says \\'Out Put is 5 expected 3\\' but on my visual studio compiler, with the same test case the output is 3. Please check my code and test it. Thank you!"
                    },
                    {
                        "username": "manavmehta",
                        "content": "I want to understand why my solution, begin iterative and handling duplicate traversals, is slower than a recursive solution. The recursive solution must have overheads and should be rather slower. How much? recursive is 117 ms and mine is 738ms. And these are consistent performance results. My solution ranges in +- 10% of the range and so does the recursive. Where am I missing out?\n\nmy solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591970/c-concise-and-intuitive-dfs/\n\nrecursive solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/964379669/ \nPlease ignore these lines as they did not make any difference.\n```\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\n```"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "shouldnt dfs work as well , since all possibilities/nodes are anyways visited?... "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "I dont know, what a fool am I . My initial idea was to get maxTime of each level in a BFS and add them up. Then I realized that max of each level doesnt play role but each depth play a big role so ended up solving this by dfs and passing maxTime in post order. God help me...why do I take so much time in these problems "
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Could any one see where is the mistake iam getting TLE error for some  Test Cases\\n\\nclass Solution {\\npublic:\\n    void dfs (int head , map < int,vector<int>> mp,vector <int> informtime,int & path_length,int & time){\\n\\n        if (mp.find(head)== mp.end()){\\n            time = max(time,path_length);\\n            return;\\n        }\\n        \\n        path_length+=informtime[head];\\n        \\n        for (auto x : mp[head]){\\n            dfs(x,mp,informtime,path_length,time);   \\n        }\\n        path_length -= informtime[head];\\n        return ;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        map <int,vector<int>> mp;\\n        int numOfminutes = 0;\\n        int path_length = 0 ;\\n        if (n ==1)return numOfminutes;\\n\\n        for (int i = 0 ; i < n;i++){\\n            if (manager[i]!=-1)mp[manager[i]].push_back(i);\\n        }\\n        \\n        dfs(headID,mp,informTime,path_length,numOfminutes);\\n\\n        return numOfminutes;\\n\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1917936,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "why even include examples when they are worthless? this is more a test of reading comprehension than coding skills "
                    },
                    {
                        "username": "user2418Bg",
                        "content": "Remember that there are N employees and that each manager in `manager` is the manager of the Nth employee. With that information, a graph can be built where we map managers to direct reports. Using the 2nd example provided, a graph would look something like `{2: [0, 1, 3, 4, 5], -1: [2]}`.  The values in the graph represent indices in `informTime`. For example, `manager` with id `2`  and employee ID of `0` from our map **{2: [0,** ...], } requires 0 minutes of inform time from `informTime` because `informTime[0]` = 0. Similarly, {2: [0, 1, 3, 4, 5], **-1: [2]**} from our map, means that `informTime[2]` represents how long it will take employee with ID of `2` to inform their directs (from the 2nd example, this means that employee with ID of `2` will take 1 to inform their directs because `informTime[2] = 1`). Using that information, you can traverse the graph to get the number of minutes to inform all employees. \n\n**TLDR** \n\n1) Make a graph of `managers` to employees (`N`) - something like `{2: [0, 1, 3, 4, 5], -1: [2]}`\n2) Traverse the graph and get the number of minutes it will take to inform direct reports from `informTime` \n\n"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Solution in C# takes 74 lines of code with all null checks, type casts and exception handling. Same thing in JS is just 31 lines and no casts or checks required. Are some languages at a disadvantage as opposed to others? Is pseudocode on the whiteboard enough in a real interview setting? Any thoughts appreciated. "
                    },
                    {
                        "username": "psionl0",
                        "content": "My C solution takes 39 lines - all coded from scratch since I don\\'t have access to any special Graph libraries. \\nhttps://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/962725627/"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Pinnacle of bad examples!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Can someone Suggest me more questions where the input format is this kind only ?\\nIt would be really helpful \\nThanks"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can somebody  help me please ?, My code for \"Time needed to inform All Employees\" fails on  TEST CASE 15, It says \\'Out Put is 5 expected 3\\' but on my visual studio compiler, with the same test case the output is 3. Please check my code and test it. Thank you!"
                    },
                    {
                        "username": "manavmehta",
                        "content": "I want to understand why my solution, begin iterative and handling duplicate traversals, is slower than a recursive solution. The recursive solution must have overheads and should be rather slower. How much? recursive is 117 ms and mine is 738ms. And these are consistent performance results. My solution ranges in +- 10% of the range and so does the recursive. Where am I missing out?\n\nmy solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591970/c-concise-and-intuitive-dfs/\n\nrecursive solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/964379669/ \nPlease ignore these lines as they did not make any difference.\n```\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\n```"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "shouldnt dfs work as well , since all possibilities/nodes are anyways visited?... "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "I dont know, what a fool am I . My initial idea was to get maxTime of each level in a BFS and add them up. Then I realized that max of each level doesnt play role but each depth play a big role so ended up solving this by dfs and passing maxTime in post order. God help me...why do I take so much time in these problems "
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Could any one see where is the mistake iam getting TLE error for some  Test Cases\\n\\nclass Solution {\\npublic:\\n    void dfs (int head , map < int,vector<int>> mp,vector <int> informtime,int & path_length,int & time){\\n\\n        if (mp.find(head)== mp.end()){\\n            time = max(time,path_length);\\n            return;\\n        }\\n        \\n        path_length+=informtime[head];\\n        \\n        for (auto x : mp[head]){\\n            dfs(x,mp,informtime,path_length,time);   \\n        }\\n        path_length -= informtime[head];\\n        return ;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        map <int,vector<int>> mp;\\n        int numOfminutes = 0;\\n        int path_length = 0 ;\\n        if (n ==1)return numOfminutes;\\n\\n        for (int i = 0 ; i < n;i++){\\n            if (manager[i]!=-1)mp[manager[i]].push_back(i);\\n        }\\n        \\n        dfs(headID,mp,informTime,path_length,numOfminutes);\\n\\n        return numOfminutes;\\n\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1917837,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "why even include examples when they are worthless? this is more a test of reading comprehension than coding skills "
                    },
                    {
                        "username": "user2418Bg",
                        "content": "Remember that there are N employees and that each manager in `manager` is the manager of the Nth employee. With that information, a graph can be built where we map managers to direct reports. Using the 2nd example provided, a graph would look something like `{2: [0, 1, 3, 4, 5], -1: [2]}`.  The values in the graph represent indices in `informTime`. For example, `manager` with id `2`  and employee ID of `0` from our map **{2: [0,** ...], } requires 0 minutes of inform time from `informTime` because `informTime[0]` = 0. Similarly, {2: [0, 1, 3, 4, 5], **-1: [2]**} from our map, means that `informTime[2]` represents how long it will take employee with ID of `2` to inform their directs (from the 2nd example, this means that employee with ID of `2` will take 1 to inform their directs because `informTime[2] = 1`). Using that information, you can traverse the graph to get the number of minutes to inform all employees. \n\n**TLDR** \n\n1) Make a graph of `managers` to employees (`N`) - something like `{2: [0, 1, 3, 4, 5], -1: [2]}`\n2) Traverse the graph and get the number of minutes it will take to inform direct reports from `informTime` \n\n"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Solution in C# takes 74 lines of code with all null checks, type casts and exception handling. Same thing in JS is just 31 lines and no casts or checks required. Are some languages at a disadvantage as opposed to others? Is pseudocode on the whiteboard enough in a real interview setting? Any thoughts appreciated. "
                    },
                    {
                        "username": "psionl0",
                        "content": "My C solution takes 39 lines - all coded from scratch since I don\\'t have access to any special Graph libraries. \\nhttps://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/962725627/"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Pinnacle of bad examples!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Can someone Suggest me more questions where the input format is this kind only ?\\nIt would be really helpful \\nThanks"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can somebody  help me please ?, My code for \"Time needed to inform All Employees\" fails on  TEST CASE 15, It says \\'Out Put is 5 expected 3\\' but on my visual studio compiler, with the same test case the output is 3. Please check my code and test it. Thank you!"
                    },
                    {
                        "username": "manavmehta",
                        "content": "I want to understand why my solution, begin iterative and handling duplicate traversals, is slower than a recursive solution. The recursive solution must have overheads and should be rather slower. How much? recursive is 117 ms and mine is 738ms. And these are consistent performance results. My solution ranges in +- 10% of the range and so does the recursive. Where am I missing out?\n\nmy solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591970/c-concise-and-intuitive-dfs/\n\nrecursive solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/964379669/ \nPlease ignore these lines as they did not make any difference.\n```\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\n```"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "shouldnt dfs work as well , since all possibilities/nodes are anyways visited?... "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "I dont know, what a fool am I . My initial idea was to get maxTime of each level in a BFS and add them up. Then I realized that max of each level doesnt play role but each depth play a big role so ended up solving this by dfs and passing maxTime in post order. God help me...why do I take so much time in these problems "
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Could any one see where is the mistake iam getting TLE error for some  Test Cases\\n\\nclass Solution {\\npublic:\\n    void dfs (int head , map < int,vector<int>> mp,vector <int> informtime,int & path_length,int & time){\\n\\n        if (mp.find(head)== mp.end()){\\n            time = max(time,path_length);\\n            return;\\n        }\\n        \\n        path_length+=informtime[head];\\n        \\n        for (auto x : mp[head]){\\n            dfs(x,mp,informtime,path_length,time);   \\n        }\\n        path_length -= informtime[head];\\n        return ;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        map <int,vector<int>> mp;\\n        int numOfminutes = 0;\\n        int path_length = 0 ;\\n        if (n ==1)return numOfminutes;\\n\\n        for (int i = 0 ; i < n;i++){\\n            if (manager[i]!=-1)mp[manager[i]].push_back(i);\\n        }\\n        \\n        dfs(headID,mp,informTime,path_length,numOfminutes);\\n\\n        return numOfminutes;\\n\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1917176,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "why even include examples when they are worthless? this is more a test of reading comprehension than coding skills "
                    },
                    {
                        "username": "user2418Bg",
                        "content": "Remember that there are N employees and that each manager in `manager` is the manager of the Nth employee. With that information, a graph can be built where we map managers to direct reports. Using the 2nd example provided, a graph would look something like `{2: [0, 1, 3, 4, 5], -1: [2]}`.  The values in the graph represent indices in `informTime`. For example, `manager` with id `2`  and employee ID of `0` from our map **{2: [0,** ...], } requires 0 minutes of inform time from `informTime` because `informTime[0]` = 0. Similarly, {2: [0, 1, 3, 4, 5], **-1: [2]**} from our map, means that `informTime[2]` represents how long it will take employee with ID of `2` to inform their directs (from the 2nd example, this means that employee with ID of `2` will take 1 to inform their directs because `informTime[2] = 1`). Using that information, you can traverse the graph to get the number of minutes to inform all employees. \n\n**TLDR** \n\n1) Make a graph of `managers` to employees (`N`) - something like `{2: [0, 1, 3, 4, 5], -1: [2]}`\n2) Traverse the graph and get the number of minutes it will take to inform direct reports from `informTime` \n\n"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Solution in C# takes 74 lines of code with all null checks, type casts and exception handling. Same thing in JS is just 31 lines and no casts or checks required. Are some languages at a disadvantage as opposed to others? Is pseudocode on the whiteboard enough in a real interview setting? Any thoughts appreciated. "
                    },
                    {
                        "username": "psionl0",
                        "content": "My C solution takes 39 lines - all coded from scratch since I don\\'t have access to any special Graph libraries. \\nhttps://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/962725627/"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Pinnacle of bad examples!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Can someone Suggest me more questions where the input format is this kind only ?\\nIt would be really helpful \\nThanks"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can somebody  help me please ?, My code for \"Time needed to inform All Employees\" fails on  TEST CASE 15, It says \\'Out Put is 5 expected 3\\' but on my visual studio compiler, with the same test case the output is 3. Please check my code and test it. Thank you!"
                    },
                    {
                        "username": "manavmehta",
                        "content": "I want to understand why my solution, begin iterative and handling duplicate traversals, is slower than a recursive solution. The recursive solution must have overheads and should be rather slower. How much? recursive is 117 ms and mine is 738ms. And these are consistent performance results. My solution ranges in +- 10% of the range and so does the recursive. Where am I missing out?\n\nmy solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591970/c-concise-and-intuitive-dfs/\n\nrecursive solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/964379669/ \nPlease ignore these lines as they did not make any difference.\n```\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\n```"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "shouldnt dfs work as well , since all possibilities/nodes are anyways visited?... "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "I dont know, what a fool am I . My initial idea was to get maxTime of each level in a BFS and add them up. Then I realized that max of each level doesnt play role but each depth play a big role so ended up solving this by dfs and passing maxTime in post order. God help me...why do I take so much time in these problems "
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Could any one see where is the mistake iam getting TLE error for some  Test Cases\\n\\nclass Solution {\\npublic:\\n    void dfs (int head , map < int,vector<int>> mp,vector <int> informtime,int & path_length,int & time){\\n\\n        if (mp.find(head)== mp.end()){\\n            time = max(time,path_length);\\n            return;\\n        }\\n        \\n        path_length+=informtime[head];\\n        \\n        for (auto x : mp[head]){\\n            dfs(x,mp,informtime,path_length,time);   \\n        }\\n        path_length -= informtime[head];\\n        return ;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        map <int,vector<int>> mp;\\n        int numOfminutes = 0;\\n        int path_length = 0 ;\\n        if (n ==1)return numOfminutes;\\n\\n        for (int i = 0 ; i < n;i++){\\n            if (manager[i]!=-1)mp[manager[i]].push_back(i);\\n        }\\n        \\n        dfs(headID,mp,informTime,path_length,numOfminutes);\\n\\n        return numOfminutes;\\n\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1917112,
                "content": [
                    {
                        "username": "gmk92lc",
                        "content": "why even include examples when they are worthless? this is more a test of reading comprehension than coding skills "
                    },
                    {
                        "username": "user2418Bg",
                        "content": "Remember that there are N employees and that each manager in `manager` is the manager of the Nth employee. With that information, a graph can be built where we map managers to direct reports. Using the 2nd example provided, a graph would look something like `{2: [0, 1, 3, 4, 5], -1: [2]}`.  The values in the graph represent indices in `informTime`. For example, `manager` with id `2`  and employee ID of `0` from our map **{2: [0,** ...], } requires 0 minutes of inform time from `informTime` because `informTime[0]` = 0. Similarly, {2: [0, 1, 3, 4, 5], **-1: [2]**} from our map, means that `informTime[2]` represents how long it will take employee with ID of `2` to inform their directs (from the 2nd example, this means that employee with ID of `2` will take 1 to inform their directs because `informTime[2] = 1`). Using that information, you can traverse the graph to get the number of minutes to inform all employees. \n\n**TLDR** \n\n1) Make a graph of `managers` to employees (`N`) - something like `{2: [0, 1, 3, 4, 5], -1: [2]}`\n2) Traverse the graph and get the number of minutes it will take to inform direct reports from `informTime` \n\n"
                    },
                    {
                        "username": "Aadityakiran_S",
                        "content": "Solution in C# takes 74 lines of code with all null checks, type casts and exception handling. Same thing in JS is just 31 lines and no casts or checks required. Are some languages at a disadvantage as opposed to others? Is pseudocode on the whiteboard enough in a real interview setting? Any thoughts appreciated. "
                    },
                    {
                        "username": "psionl0",
                        "content": "My C solution takes 39 lines - all coded from scratch since I don\\'t have access to any special Graph libraries. \\nhttps://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/962725627/"
                    },
                    {
                        "username": "harshdonga99",
                        "content": "Pinnacle of bad examples!"
                    },
                    {
                        "username": "Shivang_101",
                        "content": "Can someone Suggest me more questions where the input format is this kind only ?\\nIt would be really helpful \\nThanks"
                    },
                    {
                        "username": "AddIsuM",
                        "content": "Can somebody  help me please ?, My code for \"Time needed to inform All Employees\" fails on  TEST CASE 15, It says \\'Out Put is 5 expected 3\\' but on my visual studio compiler, with the same test case the output is 3. Please check my code and test it. Thank you!"
                    },
                    {
                        "username": "manavmehta",
                        "content": "I want to understand why my solution, begin iterative and handling duplicate traversals, is slower than a recursive solution. The recursive solution must have overheads and should be rather slower. How much? recursive is 117 ms and mine is 738ms. And these are consistent performance results. My solution ranges in +- 10% of the range and so does the recursive. Where am I missing out?\n\nmy solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/solutions/3591970/c-concise-and-intuitive-dfs/\n\nrecursive solution - https://leetcode.com/problems/time-needed-to-inform-all-employees/submissions/964379669/ \nPlease ignore these lines as they did not make any difference.\n```\nios_base::sync_with_stdio(false);\ncin.tie(0);\ncout.tie(0);\n```"
                    },
                    {
                        "username": "vezha_ds",
                        "content": "shouldnt dfs work as well , since all possibilities/nodes are anyways visited?... "
                    },
                    {
                        "username": "erwin_smith22",
                        "content": "I dont know, what a fool am I . My initial idea was to get maxTime of each level in a BFS and add them up. Then I realized that max of each level doesnt play role but each depth play a big role so ended up solving this by dfs and passing maxTime in post order. God help me...why do I take so much time in these problems "
                    },
                    {
                        "username": "StrawhatLuffy2502",
                        "content": "Could any one see where is the mistake iam getting TLE error for some  Test Cases\\n\\nclass Solution {\\npublic:\\n    void dfs (int head , map < int,vector<int>> mp,vector <int> informtime,int & path_length,int & time){\\n\\n        if (mp.find(head)== mp.end()){\\n            time = max(time,path_length);\\n            return;\\n        }\\n        \\n        path_length+=informtime[head];\\n        \\n        for (auto x : mp[head]){\\n            dfs(x,mp,informtime,path_length,time);   \\n        }\\n        path_length -= informtime[head];\\n        return ;\\n        \\n    }\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        map <int,vector<int>> mp;\\n        int numOfminutes = 0;\\n        int path_length = 0 ;\\n        if (n ==1)return numOfminutes;\\n\\n        for (int i = 0 ; i < n;i++){\\n            if (manager[i]!=-1)mp[manager[i]].push_back(i);\\n        }\\n        \\n        dfs(headID,mp,informTime,path_length,numOfminutes);\\n\\n        return numOfminutes;\\n\\n    }\\n};`"
                    }
                ]
            },
            {
                "id": 1915654,
                "content": [
                    {
                        "username": "jacobj2",
                        "content": "I don\\'t really understand the description of the problem. Can someone explain it better?"
                    },
                    {
                        "username": "kuan-po",
                        "content": "you need to traverse n-nary tree to find the path with longest sum in brief."
                    },
                    {
                        "username": "hewy96",
                        "content": "This discussion is going to make me switch from leetcode honestly. It mentions nothing about simultaneously passing the information down. Bad test cases provided too. Shame the hint was the only clear thing in this question."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "Can Anyone Explain why my DFS is less effective as it gives TLE, I don't know what I am doing wrong. TY in advance\n\n```class Solution {\npublic:\n    int solve(int n,int s,vector<int>manager,vector<int>inform){\n        if(manager[n]==-1)\n            return s;\n        return solve(manager[n],s+inform[n],manager,inform);\n    }\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\n        int k,ans=INT_MIN;\n        for(int i=0;i<manager.size();i++)\n        {   if(manager[i]==-1)\n                {\n                    k=informTime[i];\n                    continue;\n                }\n            ans=max(ans,solve(i,0,manager,informTime));\n        }\n        if(ans==INT_MIN)\n            return k;\n        return ans+k;\n    }\n};"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Examples and description could be better."
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "This problem is exactly how tech layoffs are designed."
                    },
                    {
                        "username": "vnk01",
                        "content": "they can just put everyone in the Zoom call"
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "what are these news? layoffs? "
                    },
                    {
                        "username": "pl2kn",
                        "content": "It seems to have some redundant input arguments, doesn't it?"
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "Hint: Subordinates can simultaneously pass the message."
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "What is wrong with this code. I am finding the maximum time of each level and adding to the final time. \\n `\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<manager.size();i++){\\n            if(i!=headID){\\n            adj[manager[i]].push_back(i);\\n            }\\n        }\\n        int ans=0;\\n        queue<pair<int,int>> q;\\n        q.push({headID,informTime[headID]});\\n        \\n        while(!q.empty()){\\n            int temp=0;\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto node=q.front();\\n                q.pop();\\n                int time=node.second;\\n                int parent=node.first;\\n                temp=max(temp,time);\\n                for(auto it:adj[parent]){\\n                    q.push({it,informTime[it]});\\n                }\\n            }\\n            ans+=temp;\\n\\n        }\\n        return ans;\\n       \\n    }\\n};\\n`"
                    },
                    {
                        "username": "kuan-po",
                        "content": "the problem is to find the largest sum among all paths."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I do the dame thing but is not the better aproach because it could happend that the time to take a manager in current level to get he's emmployies could be hier than the time to take another manager anda he's emmployies to pass the info. In that case, the time of the second manager and he's emmployies dons't mather. What do You thing??"
                    },
                    {
                        "username": "wowonline",
                        "content": "Seems like there's something wrong with 39 test. My code doesn't pass it without ``ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);``"
                    }
                ]
            },
            {
                "id": 1915642,
                "content": [
                    {
                        "username": "jacobj2",
                        "content": "I don\\'t really understand the description of the problem. Can someone explain it better?"
                    },
                    {
                        "username": "kuan-po",
                        "content": "you need to traverse n-nary tree to find the path with longest sum in brief."
                    },
                    {
                        "username": "hewy96",
                        "content": "This discussion is going to make me switch from leetcode honestly. It mentions nothing about simultaneously passing the information down. Bad test cases provided too. Shame the hint was the only clear thing in this question."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "Can Anyone Explain why my DFS is less effective as it gives TLE, I don't know what I am doing wrong. TY in advance\n\n```class Solution {\npublic:\n    int solve(int n,int s,vector<int>manager,vector<int>inform){\n        if(manager[n]==-1)\n            return s;\n        return solve(manager[n],s+inform[n],manager,inform);\n    }\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\n        int k,ans=INT_MIN;\n        for(int i=0;i<manager.size();i++)\n        {   if(manager[i]==-1)\n                {\n                    k=informTime[i];\n                    continue;\n                }\n            ans=max(ans,solve(i,0,manager,informTime));\n        }\n        if(ans==INT_MIN)\n            return k;\n        return ans+k;\n    }\n};"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Examples and description could be better."
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "This problem is exactly how tech layoffs are designed."
                    },
                    {
                        "username": "vnk01",
                        "content": "they can just put everyone in the Zoom call"
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "what are these news? layoffs? "
                    },
                    {
                        "username": "pl2kn",
                        "content": "It seems to have some redundant input arguments, doesn't it?"
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "Hint: Subordinates can simultaneously pass the message."
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "What is wrong with this code. I am finding the maximum time of each level and adding to the final time. \\n `\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<manager.size();i++){\\n            if(i!=headID){\\n            adj[manager[i]].push_back(i);\\n            }\\n        }\\n        int ans=0;\\n        queue<pair<int,int>> q;\\n        q.push({headID,informTime[headID]});\\n        \\n        while(!q.empty()){\\n            int temp=0;\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto node=q.front();\\n                q.pop();\\n                int time=node.second;\\n                int parent=node.first;\\n                temp=max(temp,time);\\n                for(auto it:adj[parent]){\\n                    q.push({it,informTime[it]});\\n                }\\n            }\\n            ans+=temp;\\n\\n        }\\n        return ans;\\n       \\n    }\\n};\\n`"
                    },
                    {
                        "username": "kuan-po",
                        "content": "the problem is to find the largest sum among all paths."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I do the dame thing but is not the better aproach because it could happend that the time to take a manager in current level to get he's emmployies could be hier than the time to take another manager anda he's emmployies to pass the info. In that case, the time of the second manager and he's emmployies dons't mather. What do You thing??"
                    },
                    {
                        "username": "wowonline",
                        "content": "Seems like there's something wrong with 39 test. My code doesn't pass it without ``ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);``"
                    }
                ]
            },
            {
                "id": 1915614,
                "content": [
                    {
                        "username": "jacobj2",
                        "content": "I don\\'t really understand the description of the problem. Can someone explain it better?"
                    },
                    {
                        "username": "kuan-po",
                        "content": "you need to traverse n-nary tree to find the path with longest sum in brief."
                    },
                    {
                        "username": "hewy96",
                        "content": "This discussion is going to make me switch from leetcode honestly. It mentions nothing about simultaneously passing the information down. Bad test cases provided too. Shame the hint was the only clear thing in this question."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "Can Anyone Explain why my DFS is less effective as it gives TLE, I don't know what I am doing wrong. TY in advance\n\n```class Solution {\npublic:\n    int solve(int n,int s,vector<int>manager,vector<int>inform){\n        if(manager[n]==-1)\n            return s;\n        return solve(manager[n],s+inform[n],manager,inform);\n    }\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\n        int k,ans=INT_MIN;\n        for(int i=0;i<manager.size();i++)\n        {   if(manager[i]==-1)\n                {\n                    k=informTime[i];\n                    continue;\n                }\n            ans=max(ans,solve(i,0,manager,informTime));\n        }\n        if(ans==INT_MIN)\n            return k;\n        return ans+k;\n    }\n};"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Examples and description could be better."
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "This problem is exactly how tech layoffs are designed."
                    },
                    {
                        "username": "vnk01",
                        "content": "they can just put everyone in the Zoom call"
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "what are these news? layoffs? "
                    },
                    {
                        "username": "pl2kn",
                        "content": "It seems to have some redundant input arguments, doesn't it?"
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "Hint: Subordinates can simultaneously pass the message."
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "What is wrong with this code. I am finding the maximum time of each level and adding to the final time. \\n `\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<manager.size();i++){\\n            if(i!=headID){\\n            adj[manager[i]].push_back(i);\\n            }\\n        }\\n        int ans=0;\\n        queue<pair<int,int>> q;\\n        q.push({headID,informTime[headID]});\\n        \\n        while(!q.empty()){\\n            int temp=0;\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto node=q.front();\\n                q.pop();\\n                int time=node.second;\\n                int parent=node.first;\\n                temp=max(temp,time);\\n                for(auto it:adj[parent]){\\n                    q.push({it,informTime[it]});\\n                }\\n            }\\n            ans+=temp;\\n\\n        }\\n        return ans;\\n       \\n    }\\n};\\n`"
                    },
                    {
                        "username": "kuan-po",
                        "content": "the problem is to find the largest sum among all paths."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I do the dame thing but is not the better aproach because it could happend that the time to take a manager in current level to get he's emmployies could be hier than the time to take another manager anda he's emmployies to pass the info. In that case, the time of the second manager and he's emmployies dons't mather. What do You thing??"
                    },
                    {
                        "username": "wowonline",
                        "content": "Seems like there's something wrong with 39 test. My code doesn't pass it without ``ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);``"
                    }
                ]
            },
            {
                "id": 1915609,
                "content": [
                    {
                        "username": "jacobj2",
                        "content": "I don\\'t really understand the description of the problem. Can someone explain it better?"
                    },
                    {
                        "username": "kuan-po",
                        "content": "you need to traverse n-nary tree to find the path with longest sum in brief."
                    },
                    {
                        "username": "hewy96",
                        "content": "This discussion is going to make me switch from leetcode honestly. It mentions nothing about simultaneously passing the information down. Bad test cases provided too. Shame the hint was the only clear thing in this question."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "Can Anyone Explain why my DFS is less effective as it gives TLE, I don't know what I am doing wrong. TY in advance\n\n```class Solution {\npublic:\n    int solve(int n,int s,vector<int>manager,vector<int>inform){\n        if(manager[n]==-1)\n            return s;\n        return solve(manager[n],s+inform[n],manager,inform);\n    }\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\n        int k,ans=INT_MIN;\n        for(int i=0;i<manager.size();i++)\n        {   if(manager[i]==-1)\n                {\n                    k=informTime[i];\n                    continue;\n                }\n            ans=max(ans,solve(i,0,manager,informTime));\n        }\n        if(ans==INT_MIN)\n            return k;\n        return ans+k;\n    }\n};"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Examples and description could be better."
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "This problem is exactly how tech layoffs are designed."
                    },
                    {
                        "username": "vnk01",
                        "content": "they can just put everyone in the Zoom call"
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "what are these news? layoffs? "
                    },
                    {
                        "username": "pl2kn",
                        "content": "It seems to have some redundant input arguments, doesn't it?"
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "Hint: Subordinates can simultaneously pass the message."
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "What is wrong with this code. I am finding the maximum time of each level and adding to the final time. \\n `\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<manager.size();i++){\\n            if(i!=headID){\\n            adj[manager[i]].push_back(i);\\n            }\\n        }\\n        int ans=0;\\n        queue<pair<int,int>> q;\\n        q.push({headID,informTime[headID]});\\n        \\n        while(!q.empty()){\\n            int temp=0;\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto node=q.front();\\n                q.pop();\\n                int time=node.second;\\n                int parent=node.first;\\n                temp=max(temp,time);\\n                for(auto it:adj[parent]){\\n                    q.push({it,informTime[it]});\\n                }\\n            }\\n            ans+=temp;\\n\\n        }\\n        return ans;\\n       \\n    }\\n};\\n`"
                    },
                    {
                        "username": "kuan-po",
                        "content": "the problem is to find the largest sum among all paths."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I do the dame thing but is not the better aproach because it could happend that the time to take a manager in current level to get he's emmployies could be hier than the time to take another manager anda he's emmployies to pass the info. In that case, the time of the second manager and he's emmployies dons't mather. What do You thing??"
                    },
                    {
                        "username": "wowonline",
                        "content": "Seems like there's something wrong with 39 test. My code doesn't pass it without ``ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);``"
                    }
                ]
            },
            {
                "id": 1915544,
                "content": [
                    {
                        "username": "jacobj2",
                        "content": "I don\\'t really understand the description of the problem. Can someone explain it better?"
                    },
                    {
                        "username": "kuan-po",
                        "content": "you need to traverse n-nary tree to find the path with longest sum in brief."
                    },
                    {
                        "username": "hewy96",
                        "content": "This discussion is going to make me switch from leetcode honestly. It mentions nothing about simultaneously passing the information down. Bad test cases provided too. Shame the hint was the only clear thing in this question."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "Can Anyone Explain why my DFS is less effective as it gives TLE, I don't know what I am doing wrong. TY in advance\n\n```class Solution {\npublic:\n    int solve(int n,int s,vector<int>manager,vector<int>inform){\n        if(manager[n]==-1)\n            return s;\n        return solve(manager[n],s+inform[n],manager,inform);\n    }\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\n        int k,ans=INT_MIN;\n        for(int i=0;i<manager.size();i++)\n        {   if(manager[i]==-1)\n                {\n                    k=informTime[i];\n                    continue;\n                }\n            ans=max(ans,solve(i,0,manager,informTime));\n        }\n        if(ans==INT_MIN)\n            return k;\n        return ans+k;\n    }\n};"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Examples and description could be better."
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "This problem is exactly how tech layoffs are designed."
                    },
                    {
                        "username": "vnk01",
                        "content": "they can just put everyone in the Zoom call"
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "what are these news? layoffs? "
                    },
                    {
                        "username": "pl2kn",
                        "content": "It seems to have some redundant input arguments, doesn't it?"
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "Hint: Subordinates can simultaneously pass the message."
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "What is wrong with this code. I am finding the maximum time of each level and adding to the final time. \\n `\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<manager.size();i++){\\n            if(i!=headID){\\n            adj[manager[i]].push_back(i);\\n            }\\n        }\\n        int ans=0;\\n        queue<pair<int,int>> q;\\n        q.push({headID,informTime[headID]});\\n        \\n        while(!q.empty()){\\n            int temp=0;\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto node=q.front();\\n                q.pop();\\n                int time=node.second;\\n                int parent=node.first;\\n                temp=max(temp,time);\\n                for(auto it:adj[parent]){\\n                    q.push({it,informTime[it]});\\n                }\\n            }\\n            ans+=temp;\\n\\n        }\\n        return ans;\\n       \\n    }\\n};\\n`"
                    },
                    {
                        "username": "kuan-po",
                        "content": "the problem is to find the largest sum among all paths."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I do the dame thing but is not the better aproach because it could happend that the time to take a manager in current level to get he's emmployies could be hier than the time to take another manager anda he's emmployies to pass the info. In that case, the time of the second manager and he's emmployies dons't mather. What do You thing??"
                    },
                    {
                        "username": "wowonline",
                        "content": "Seems like there's something wrong with 39 test. My code doesn't pass it without ``ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);``"
                    }
                ]
            },
            {
                "id": 1915536,
                "content": [
                    {
                        "username": "jacobj2",
                        "content": "I don\\'t really understand the description of the problem. Can someone explain it better?"
                    },
                    {
                        "username": "kuan-po",
                        "content": "you need to traverse n-nary tree to find the path with longest sum in brief."
                    },
                    {
                        "username": "hewy96",
                        "content": "This discussion is going to make me switch from leetcode honestly. It mentions nothing about simultaneously passing the information down. Bad test cases provided too. Shame the hint was the only clear thing in this question."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "Can Anyone Explain why my DFS is less effective as it gives TLE, I don't know what I am doing wrong. TY in advance\n\n```class Solution {\npublic:\n    int solve(int n,int s,vector<int>manager,vector<int>inform){\n        if(manager[n]==-1)\n            return s;\n        return solve(manager[n],s+inform[n],manager,inform);\n    }\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\n        int k,ans=INT_MIN;\n        for(int i=0;i<manager.size();i++)\n        {   if(manager[i]==-1)\n                {\n                    k=informTime[i];\n                    continue;\n                }\n            ans=max(ans,solve(i,0,manager,informTime));\n        }\n        if(ans==INT_MIN)\n            return k;\n        return ans+k;\n    }\n};"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Examples and description could be better."
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "This problem is exactly how tech layoffs are designed."
                    },
                    {
                        "username": "vnk01",
                        "content": "they can just put everyone in the Zoom call"
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "what are these news? layoffs? "
                    },
                    {
                        "username": "pl2kn",
                        "content": "It seems to have some redundant input arguments, doesn't it?"
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "Hint: Subordinates can simultaneously pass the message."
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "What is wrong with this code. I am finding the maximum time of each level and adding to the final time. \\n `\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<manager.size();i++){\\n            if(i!=headID){\\n            adj[manager[i]].push_back(i);\\n            }\\n        }\\n        int ans=0;\\n        queue<pair<int,int>> q;\\n        q.push({headID,informTime[headID]});\\n        \\n        while(!q.empty()){\\n            int temp=0;\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto node=q.front();\\n                q.pop();\\n                int time=node.second;\\n                int parent=node.first;\\n                temp=max(temp,time);\\n                for(auto it:adj[parent]){\\n                    q.push({it,informTime[it]});\\n                }\\n            }\\n            ans+=temp;\\n\\n        }\\n        return ans;\\n       \\n    }\\n};\\n`"
                    },
                    {
                        "username": "kuan-po",
                        "content": "the problem is to find the largest sum among all paths."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I do the dame thing but is not the better aproach because it could happend that the time to take a manager in current level to get he's emmployies could be hier than the time to take another manager anda he's emmployies to pass the info. In that case, the time of the second manager and he's emmployies dons't mather. What do You thing??"
                    },
                    {
                        "username": "wowonline",
                        "content": "Seems like there's something wrong with 39 test. My code doesn't pass it without ``ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);``"
                    }
                ]
            },
            {
                "id": 1915500,
                "content": [
                    {
                        "username": "jacobj2",
                        "content": "I don\\'t really understand the description of the problem. Can someone explain it better?"
                    },
                    {
                        "username": "kuan-po",
                        "content": "you need to traverse n-nary tree to find the path with longest sum in brief."
                    },
                    {
                        "username": "hewy96",
                        "content": "This discussion is going to make me switch from leetcode honestly. It mentions nothing about simultaneously passing the information down. Bad test cases provided too. Shame the hint was the only clear thing in this question."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "Can Anyone Explain why my DFS is less effective as it gives TLE, I don't know what I am doing wrong. TY in advance\n\n```class Solution {\npublic:\n    int solve(int n,int s,vector<int>manager,vector<int>inform){\n        if(manager[n]==-1)\n            return s;\n        return solve(manager[n],s+inform[n],manager,inform);\n    }\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\n        int k,ans=INT_MIN;\n        for(int i=0;i<manager.size();i++)\n        {   if(manager[i]==-1)\n                {\n                    k=informTime[i];\n                    continue;\n                }\n            ans=max(ans,solve(i,0,manager,informTime));\n        }\n        if(ans==INT_MIN)\n            return k;\n        return ans+k;\n    }\n};"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Examples and description could be better."
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "This problem is exactly how tech layoffs are designed."
                    },
                    {
                        "username": "vnk01",
                        "content": "they can just put everyone in the Zoom call"
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "what are these news? layoffs? "
                    },
                    {
                        "username": "pl2kn",
                        "content": "It seems to have some redundant input arguments, doesn't it?"
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "Hint: Subordinates can simultaneously pass the message."
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "What is wrong with this code. I am finding the maximum time of each level and adding to the final time. \\n `\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<manager.size();i++){\\n            if(i!=headID){\\n            adj[manager[i]].push_back(i);\\n            }\\n        }\\n        int ans=0;\\n        queue<pair<int,int>> q;\\n        q.push({headID,informTime[headID]});\\n        \\n        while(!q.empty()){\\n            int temp=0;\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto node=q.front();\\n                q.pop();\\n                int time=node.second;\\n                int parent=node.first;\\n                temp=max(temp,time);\\n                for(auto it:adj[parent]){\\n                    q.push({it,informTime[it]});\\n                }\\n            }\\n            ans+=temp;\\n\\n        }\\n        return ans;\\n       \\n    }\\n};\\n`"
                    },
                    {
                        "username": "kuan-po",
                        "content": "the problem is to find the largest sum among all paths."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I do the dame thing but is not the better aproach because it could happend that the time to take a manager in current level to get he's emmployies could be hier than the time to take another manager anda he's emmployies to pass the info. In that case, the time of the second manager and he's emmployies dons't mather. What do You thing??"
                    },
                    {
                        "username": "wowonline",
                        "content": "Seems like there's something wrong with 39 test. My code doesn't pass it without ``ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);``"
                    }
                ]
            },
            {
                "id": 1915473,
                "content": [
                    {
                        "username": "jacobj2",
                        "content": "I don\\'t really understand the description of the problem. Can someone explain it better?"
                    },
                    {
                        "username": "kuan-po",
                        "content": "you need to traverse n-nary tree to find the path with longest sum in brief."
                    },
                    {
                        "username": "hewy96",
                        "content": "This discussion is going to make me switch from leetcode honestly. It mentions nothing about simultaneously passing the information down. Bad test cases provided too. Shame the hint was the only clear thing in this question."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "Can Anyone Explain why my DFS is less effective as it gives TLE, I don't know what I am doing wrong. TY in advance\n\n```class Solution {\npublic:\n    int solve(int n,int s,vector<int>manager,vector<int>inform){\n        if(manager[n]==-1)\n            return s;\n        return solve(manager[n],s+inform[n],manager,inform);\n    }\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\n        int k,ans=INT_MIN;\n        for(int i=0;i<manager.size();i++)\n        {   if(manager[i]==-1)\n                {\n                    k=informTime[i];\n                    continue;\n                }\n            ans=max(ans,solve(i,0,manager,informTime));\n        }\n        if(ans==INT_MIN)\n            return k;\n        return ans+k;\n    }\n};"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Examples and description could be better."
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "This problem is exactly how tech layoffs are designed."
                    },
                    {
                        "username": "vnk01",
                        "content": "they can just put everyone in the Zoom call"
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "what are these news? layoffs? "
                    },
                    {
                        "username": "pl2kn",
                        "content": "It seems to have some redundant input arguments, doesn't it?"
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "Hint: Subordinates can simultaneously pass the message."
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "What is wrong with this code. I am finding the maximum time of each level and adding to the final time. \\n `\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<manager.size();i++){\\n            if(i!=headID){\\n            adj[manager[i]].push_back(i);\\n            }\\n        }\\n        int ans=0;\\n        queue<pair<int,int>> q;\\n        q.push({headID,informTime[headID]});\\n        \\n        while(!q.empty()){\\n            int temp=0;\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto node=q.front();\\n                q.pop();\\n                int time=node.second;\\n                int parent=node.first;\\n                temp=max(temp,time);\\n                for(auto it:adj[parent]){\\n                    q.push({it,informTime[it]});\\n                }\\n            }\\n            ans+=temp;\\n\\n        }\\n        return ans;\\n       \\n    }\\n};\\n`"
                    },
                    {
                        "username": "kuan-po",
                        "content": "the problem is to find the largest sum among all paths."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I do the dame thing but is not the better aproach because it could happend that the time to take a manager in current level to get he's emmployies could be hier than the time to take another manager anda he's emmployies to pass the info. In that case, the time of the second manager and he's emmployies dons't mather. What do You thing??"
                    },
                    {
                        "username": "wowonline",
                        "content": "Seems like there's something wrong with 39 test. My code doesn't pass it without ``ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);``"
                    }
                ]
            },
            {
                "id": 1915451,
                "content": [
                    {
                        "username": "jacobj2",
                        "content": "I don\\'t really understand the description of the problem. Can someone explain it better?"
                    },
                    {
                        "username": "kuan-po",
                        "content": "you need to traverse n-nary tree to find the path with longest sum in brief."
                    },
                    {
                        "username": "hewy96",
                        "content": "This discussion is going to make me switch from leetcode honestly. It mentions nothing about simultaneously passing the information down. Bad test cases provided too. Shame the hint was the only clear thing in this question."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "Can Anyone Explain why my DFS is less effective as it gives TLE, I don't know what I am doing wrong. TY in advance\n\n```class Solution {\npublic:\n    int solve(int n,int s,vector<int>manager,vector<int>inform){\n        if(manager[n]==-1)\n            return s;\n        return solve(manager[n],s+inform[n],manager,inform);\n    }\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\n        int k,ans=INT_MIN;\n        for(int i=0;i<manager.size();i++)\n        {   if(manager[i]==-1)\n                {\n                    k=informTime[i];\n                    continue;\n                }\n            ans=max(ans,solve(i,0,manager,informTime));\n        }\n        if(ans==INT_MIN)\n            return k;\n        return ans+k;\n    }\n};"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Examples and description could be better."
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "This problem is exactly how tech layoffs are designed."
                    },
                    {
                        "username": "vnk01",
                        "content": "they can just put everyone in the Zoom call"
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "what are these news? layoffs? "
                    },
                    {
                        "username": "pl2kn",
                        "content": "It seems to have some redundant input arguments, doesn't it?"
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "Hint: Subordinates can simultaneously pass the message."
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "What is wrong with this code. I am finding the maximum time of each level and adding to the final time. \\n `\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<manager.size();i++){\\n            if(i!=headID){\\n            adj[manager[i]].push_back(i);\\n            }\\n        }\\n        int ans=0;\\n        queue<pair<int,int>> q;\\n        q.push({headID,informTime[headID]});\\n        \\n        while(!q.empty()){\\n            int temp=0;\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto node=q.front();\\n                q.pop();\\n                int time=node.second;\\n                int parent=node.first;\\n                temp=max(temp,time);\\n                for(auto it:adj[parent]){\\n                    q.push({it,informTime[it]});\\n                }\\n            }\\n            ans+=temp;\\n\\n        }\\n        return ans;\\n       \\n    }\\n};\\n`"
                    },
                    {
                        "username": "kuan-po",
                        "content": "the problem is to find the largest sum among all paths."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I do the dame thing but is not the better aproach because it could happend that the time to take a manager in current level to get he's emmployies could be hier than the time to take another manager anda he's emmployies to pass the info. In that case, the time of the second manager and he's emmployies dons't mather. What do You thing??"
                    },
                    {
                        "username": "wowonline",
                        "content": "Seems like there's something wrong with 39 test. My code doesn't pass it without ``ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);``"
                    }
                ]
            },
            {
                "id": 1915412,
                "content": [
                    {
                        "username": "jacobj2",
                        "content": "I don\\'t really understand the description of the problem. Can someone explain it better?"
                    },
                    {
                        "username": "kuan-po",
                        "content": "you need to traverse n-nary tree to find the path with longest sum in brief."
                    },
                    {
                        "username": "hewy96",
                        "content": "This discussion is going to make me switch from leetcode honestly. It mentions nothing about simultaneously passing the information down. Bad test cases provided too. Shame the hint was the only clear thing in this question."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "Can Anyone Explain why my DFS is less effective as it gives TLE, I don't know what I am doing wrong. TY in advance\n\n```class Solution {\npublic:\n    int solve(int n,int s,vector<int>manager,vector<int>inform){\n        if(manager[n]==-1)\n            return s;\n        return solve(manager[n],s+inform[n],manager,inform);\n    }\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\n        int k,ans=INT_MIN;\n        for(int i=0;i<manager.size();i++)\n        {   if(manager[i]==-1)\n                {\n                    k=informTime[i];\n                    continue;\n                }\n            ans=max(ans,solve(i,0,manager,informTime));\n        }\n        if(ans==INT_MIN)\n            return k;\n        return ans+k;\n    }\n};"
                    },
                    {
                        "username": "OweMillionNeedFANG",
                        "content": "Examples and description could be better."
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "This problem is exactly how tech layoffs are designed."
                    },
                    {
                        "username": "vnk01",
                        "content": "they can just put everyone in the Zoom call"
                    },
                    {
                        "username": "vmihaylenko",
                        "content": "what are these news? layoffs? "
                    },
                    {
                        "username": "pl2kn",
                        "content": "It seems to have some redundant input arguments, doesn't it?"
                    },
                    {
                        "username": "stupidly_logical",
                        "content": "Hint: Subordinates can simultaneously pass the message."
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "What is wrong with this code. I am finding the maximum time of each level and adding to the final time. \\n `\\nclass Solution {\\npublic:\\n    int numOfMinutes(int n, int headID, vector<int>& manager, vector<int>& informTime) {\\n        vector<vector<int>> adj(n);\\n        for(int i=0;i<manager.size();i++){\\n            if(i!=headID){\\n            adj[manager[i]].push_back(i);\\n            }\\n        }\\n        int ans=0;\\n        queue<pair<int,int>> q;\\n        q.push({headID,informTime[headID]});\\n        \\n        while(!q.empty()){\\n            int temp=0;\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto node=q.front();\\n                q.pop();\\n                int time=node.second;\\n                int parent=node.first;\\n                temp=max(temp,time);\\n                for(auto it:adj[parent]){\\n                    q.push({it,informTime[it]});\\n                }\\n            }\\n            ans+=temp;\\n\\n        }\\n        return ans;\\n       \\n    }\\n};\\n`"
                    },
                    {
                        "username": "kuan-po",
                        "content": "the problem is to find the largest sum among all paths."
                    },
                    {
                        "username": "rayrogar",
                        "content": "I do the dame thing but is not the better aproach because it could happend that the time to take a manager in current level to get he's emmployies could be hier than the time to take another manager anda he's emmployies to pass the info. In that case, the time of the second manager and he's emmployies dons't mather. What do You thing??"
                    },
                    {
                        "username": "wowonline",
                        "content": "Seems like there's something wrong with 39 test. My code doesn't pass it without ``ios_base::sync_with_stdio(false);\n        cin.tie(0);\n        cout.tie(0);``"
                    }
                ]
            },
            {
                "id": 1915314,
                "content": [
                    {
                        "username": "hiroland2011",
                        "content": "I wonder why 0 is taking order from 2."
                    },
                    {
                        "username": "Swaraj_Kotapati",
                        "content": "Discussion >>> Description"
                    },
                    {
                        "username": "omniaosman4",
                        "content": "I think the problem need more examples "
                    },
                    {
                        "username": "najwer23",
                        "content": "Life would be simpler if we didn\\'t have managers in the company"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "DFS Traversal.\\nMake the adjacency list efficiently to make the tree where each child node will contain their id and time needed to get information from their parent \"[ i, informTime[manager[i]] ] \"and find maximum sum among all path from root (headID) to leaf in the tree. This can be done using simple dfs traversal."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Variable n seems redundant"
                    },
                    {
                        "username": "timiking5",
                        "content": "In this problem it is obvious that we use some sort of graph search, but yeasterday it was really unclear to me"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Please help me. Why this give me wrong answer!!!!\\nn: 11\\nheadID: 4\\nmanager= [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime= [0,213,0,253,686,170,975,0,261,309,337]\\nOutput: 2730\\nExpected: 2560\\n\\nHere my tree:\\n 4(686) => 10 (t=686)\\n10((+337)=> 3 (t=1023)\\n3(+253) => 9 (t=1276)\\n9(+309) => 1(213), 6(975), 8(261) (t=1585)\\n8(+975) => 5(t = 2560)\\n5(+170) => 0 (t=2730) Why this movement don\\'t count???\\n                \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@EricRaw](/EricRaw) Yes 6 alert 2 but if I finish here, 5 it\\'s never get notice, I put 8(+975) because 8 alert 5 first than 6 alert 2 so overall time it\\'s 975. Now I think that is because 8(261)+5(170) it\\'s less than 6(975) Then that path finish before 6. So don\\'t count. Now I\\'m goint to work, later I Will check the answer of friend @jayamrutkar"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I can explain with below example.\\n\\n[0, 1,  2, 3,  4,  5,  6,  7, 8,  9,  10]\\n[5, 9,  6, 10, -1, 8,  9,  1, 9,  3,  4]\\n[0, 213,0, 253,686,170,975,0, 261,309,337]\\n\\n```\\n                                    (4,686)\\n                                    (10,(686+337))\\n                                    (3,(686+337+253))\\n                                    (9,(686+337+253+309))\\n    (1,(686+337+253+309+213))      (6,(686+337+253+309+975))         (8,(686+337+253+309+261))\\n    (7,(686+337+253+309+213+0))    (2,(686+337+253+309+975+0))       (5,(686+337+253+309+261+170))\\n                                                                     (0,(686+337+253+309+261+170+0))\\n```"
                    },
                    {
                        "username": "EricRaw",
                        "content": "```\n8(+975) => 5(t = 2560)\n```\nit's 6(+975) => 2(t = 2560)"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "DFS and BFS both TLE...Why..."
                    },
                    {
                        "username": "EricRaw",
                        "content": "if you are using for loop (with n length) inside a for loop (with n length) it will guaranteed TLE O(n^2)"
                    },
                    {
                        "username": "marcus121",
                        "content": "No need to use tree search, dynamic programming is straightforward and works very fast (but uses a lot of space)"
                    }
                ]
            },
            {
                "id": 1915306,
                "content": [
                    {
                        "username": "hiroland2011",
                        "content": "I wonder why 0 is taking order from 2."
                    },
                    {
                        "username": "Swaraj_Kotapati",
                        "content": "Discussion >>> Description"
                    },
                    {
                        "username": "omniaosman4",
                        "content": "I think the problem need more examples "
                    },
                    {
                        "username": "najwer23",
                        "content": "Life would be simpler if we didn\\'t have managers in the company"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "DFS Traversal.\\nMake the adjacency list efficiently to make the tree where each child node will contain their id and time needed to get information from their parent \"[ i, informTime[manager[i]] ] \"and find maximum sum among all path from root (headID) to leaf in the tree. This can be done using simple dfs traversal."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Variable n seems redundant"
                    },
                    {
                        "username": "timiking5",
                        "content": "In this problem it is obvious that we use some sort of graph search, but yeasterday it was really unclear to me"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Please help me. Why this give me wrong answer!!!!\\nn: 11\\nheadID: 4\\nmanager= [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime= [0,213,0,253,686,170,975,0,261,309,337]\\nOutput: 2730\\nExpected: 2560\\n\\nHere my tree:\\n 4(686) => 10 (t=686)\\n10((+337)=> 3 (t=1023)\\n3(+253) => 9 (t=1276)\\n9(+309) => 1(213), 6(975), 8(261) (t=1585)\\n8(+975) => 5(t = 2560)\\n5(+170) => 0 (t=2730) Why this movement don\\'t count???\\n                \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@EricRaw](/EricRaw) Yes 6 alert 2 but if I finish here, 5 it\\'s never get notice, I put 8(+975) because 8 alert 5 first than 6 alert 2 so overall time it\\'s 975. Now I think that is because 8(261)+5(170) it\\'s less than 6(975) Then that path finish before 6. So don\\'t count. Now I\\'m goint to work, later I Will check the answer of friend @jayamrutkar"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I can explain with below example.\\n\\n[0, 1,  2, 3,  4,  5,  6,  7, 8,  9,  10]\\n[5, 9,  6, 10, -1, 8,  9,  1, 9,  3,  4]\\n[0, 213,0, 253,686,170,975,0, 261,309,337]\\n\\n```\\n                                    (4,686)\\n                                    (10,(686+337))\\n                                    (3,(686+337+253))\\n                                    (9,(686+337+253+309))\\n    (1,(686+337+253+309+213))      (6,(686+337+253+309+975))         (8,(686+337+253+309+261))\\n    (7,(686+337+253+309+213+0))    (2,(686+337+253+309+975+0))       (5,(686+337+253+309+261+170))\\n                                                                     (0,(686+337+253+309+261+170+0))\\n```"
                    },
                    {
                        "username": "EricRaw",
                        "content": "```\n8(+975) => 5(t = 2560)\n```\nit's 6(+975) => 2(t = 2560)"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "DFS and BFS both TLE...Why..."
                    },
                    {
                        "username": "EricRaw",
                        "content": "if you are using for loop (with n length) inside a for loop (with n length) it will guaranteed TLE O(n^2)"
                    },
                    {
                        "username": "marcus121",
                        "content": "No need to use tree search, dynamic programming is straightforward and works very fast (but uses a lot of space)"
                    }
                ]
            },
            {
                "id": 1915187,
                "content": [
                    {
                        "username": "hiroland2011",
                        "content": "I wonder why 0 is taking order from 2."
                    },
                    {
                        "username": "Swaraj_Kotapati",
                        "content": "Discussion >>> Description"
                    },
                    {
                        "username": "omniaosman4",
                        "content": "I think the problem need more examples "
                    },
                    {
                        "username": "najwer23",
                        "content": "Life would be simpler if we didn\\'t have managers in the company"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "DFS Traversal.\\nMake the adjacency list efficiently to make the tree where each child node will contain their id and time needed to get information from their parent \"[ i, informTime[manager[i]] ] \"and find maximum sum among all path from root (headID) to leaf in the tree. This can be done using simple dfs traversal."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Variable n seems redundant"
                    },
                    {
                        "username": "timiking5",
                        "content": "In this problem it is obvious that we use some sort of graph search, but yeasterday it was really unclear to me"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Please help me. Why this give me wrong answer!!!!\\nn: 11\\nheadID: 4\\nmanager= [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime= [0,213,0,253,686,170,975,0,261,309,337]\\nOutput: 2730\\nExpected: 2560\\n\\nHere my tree:\\n 4(686) => 10 (t=686)\\n10((+337)=> 3 (t=1023)\\n3(+253) => 9 (t=1276)\\n9(+309) => 1(213), 6(975), 8(261) (t=1585)\\n8(+975) => 5(t = 2560)\\n5(+170) => 0 (t=2730) Why this movement don\\'t count???\\n                \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@EricRaw](/EricRaw) Yes 6 alert 2 but if I finish here, 5 it\\'s never get notice, I put 8(+975) because 8 alert 5 first than 6 alert 2 so overall time it\\'s 975. Now I think that is because 8(261)+5(170) it\\'s less than 6(975) Then that path finish before 6. So don\\'t count. Now I\\'m goint to work, later I Will check the answer of friend @jayamrutkar"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I can explain with below example.\\n\\n[0, 1,  2, 3,  4,  5,  6,  7, 8,  9,  10]\\n[5, 9,  6, 10, -1, 8,  9,  1, 9,  3,  4]\\n[0, 213,0, 253,686,170,975,0, 261,309,337]\\n\\n```\\n                                    (4,686)\\n                                    (10,(686+337))\\n                                    (3,(686+337+253))\\n                                    (9,(686+337+253+309))\\n    (1,(686+337+253+309+213))      (6,(686+337+253+309+975))         (8,(686+337+253+309+261))\\n    (7,(686+337+253+309+213+0))    (2,(686+337+253+309+975+0))       (5,(686+337+253+309+261+170))\\n                                                                     (0,(686+337+253+309+261+170+0))\\n```"
                    },
                    {
                        "username": "EricRaw",
                        "content": "```\n8(+975) => 5(t = 2560)\n```\nit's 6(+975) => 2(t = 2560)"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "DFS and BFS both TLE...Why..."
                    },
                    {
                        "username": "EricRaw",
                        "content": "if you are using for loop (with n length) inside a for loop (with n length) it will guaranteed TLE O(n^2)"
                    },
                    {
                        "username": "marcus121",
                        "content": "No need to use tree search, dynamic programming is straightforward and works very fast (but uses a lot of space)"
                    }
                ]
            },
            {
                "id": 1915159,
                "content": [
                    {
                        "username": "hiroland2011",
                        "content": "I wonder why 0 is taking order from 2."
                    },
                    {
                        "username": "Swaraj_Kotapati",
                        "content": "Discussion >>> Description"
                    },
                    {
                        "username": "omniaosman4",
                        "content": "I think the problem need more examples "
                    },
                    {
                        "username": "najwer23",
                        "content": "Life would be simpler if we didn\\'t have managers in the company"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "DFS Traversal.\\nMake the adjacency list efficiently to make the tree where each child node will contain their id and time needed to get information from their parent \"[ i, informTime[manager[i]] ] \"and find maximum sum among all path from root (headID) to leaf in the tree. This can be done using simple dfs traversal."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Variable n seems redundant"
                    },
                    {
                        "username": "timiking5",
                        "content": "In this problem it is obvious that we use some sort of graph search, but yeasterday it was really unclear to me"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Please help me. Why this give me wrong answer!!!!\\nn: 11\\nheadID: 4\\nmanager= [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime= [0,213,0,253,686,170,975,0,261,309,337]\\nOutput: 2730\\nExpected: 2560\\n\\nHere my tree:\\n 4(686) => 10 (t=686)\\n10((+337)=> 3 (t=1023)\\n3(+253) => 9 (t=1276)\\n9(+309) => 1(213), 6(975), 8(261) (t=1585)\\n8(+975) => 5(t = 2560)\\n5(+170) => 0 (t=2730) Why this movement don\\'t count???\\n                \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@EricRaw](/EricRaw) Yes 6 alert 2 but if I finish here, 5 it\\'s never get notice, I put 8(+975) because 8 alert 5 first than 6 alert 2 so overall time it\\'s 975. Now I think that is because 8(261)+5(170) it\\'s less than 6(975) Then that path finish before 6. So don\\'t count. Now I\\'m goint to work, later I Will check the answer of friend @jayamrutkar"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I can explain with below example.\\n\\n[0, 1,  2, 3,  4,  5,  6,  7, 8,  9,  10]\\n[5, 9,  6, 10, -1, 8,  9,  1, 9,  3,  4]\\n[0, 213,0, 253,686,170,975,0, 261,309,337]\\n\\n```\\n                                    (4,686)\\n                                    (10,(686+337))\\n                                    (3,(686+337+253))\\n                                    (9,(686+337+253+309))\\n    (1,(686+337+253+309+213))      (6,(686+337+253+309+975))         (8,(686+337+253+309+261))\\n    (7,(686+337+253+309+213+0))    (2,(686+337+253+309+975+0))       (5,(686+337+253+309+261+170))\\n                                                                     (0,(686+337+253+309+261+170+0))\\n```"
                    },
                    {
                        "username": "EricRaw",
                        "content": "```\n8(+975) => 5(t = 2560)\n```\nit's 6(+975) => 2(t = 2560)"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "DFS and BFS both TLE...Why..."
                    },
                    {
                        "username": "EricRaw",
                        "content": "if you are using for loop (with n length) inside a for loop (with n length) it will guaranteed TLE O(n^2)"
                    },
                    {
                        "username": "marcus121",
                        "content": "No need to use tree search, dynamic programming is straightforward and works very fast (but uses a lot of space)"
                    }
                ]
            },
            {
                "id": 1915144,
                "content": [
                    {
                        "username": "hiroland2011",
                        "content": "I wonder why 0 is taking order from 2."
                    },
                    {
                        "username": "Swaraj_Kotapati",
                        "content": "Discussion >>> Description"
                    },
                    {
                        "username": "omniaosman4",
                        "content": "I think the problem need more examples "
                    },
                    {
                        "username": "najwer23",
                        "content": "Life would be simpler if we didn\\'t have managers in the company"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "DFS Traversal.\\nMake the adjacency list efficiently to make the tree where each child node will contain their id and time needed to get information from their parent \"[ i, informTime[manager[i]] ] \"and find maximum sum among all path from root (headID) to leaf in the tree. This can be done using simple dfs traversal."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Variable n seems redundant"
                    },
                    {
                        "username": "timiking5",
                        "content": "In this problem it is obvious that we use some sort of graph search, but yeasterday it was really unclear to me"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Please help me. Why this give me wrong answer!!!!\\nn: 11\\nheadID: 4\\nmanager= [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime= [0,213,0,253,686,170,975,0,261,309,337]\\nOutput: 2730\\nExpected: 2560\\n\\nHere my tree:\\n 4(686) => 10 (t=686)\\n10((+337)=> 3 (t=1023)\\n3(+253) => 9 (t=1276)\\n9(+309) => 1(213), 6(975), 8(261) (t=1585)\\n8(+975) => 5(t = 2560)\\n5(+170) => 0 (t=2730) Why this movement don\\'t count???\\n                \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@EricRaw](/EricRaw) Yes 6 alert 2 but if I finish here, 5 it\\'s never get notice, I put 8(+975) because 8 alert 5 first than 6 alert 2 so overall time it\\'s 975. Now I think that is because 8(261)+5(170) it\\'s less than 6(975) Then that path finish before 6. So don\\'t count. Now I\\'m goint to work, later I Will check the answer of friend @jayamrutkar"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I can explain with below example.\\n\\n[0, 1,  2, 3,  4,  5,  6,  7, 8,  9,  10]\\n[5, 9,  6, 10, -1, 8,  9,  1, 9,  3,  4]\\n[0, 213,0, 253,686,170,975,0, 261,309,337]\\n\\n```\\n                                    (4,686)\\n                                    (10,(686+337))\\n                                    (3,(686+337+253))\\n                                    (9,(686+337+253+309))\\n    (1,(686+337+253+309+213))      (6,(686+337+253+309+975))         (8,(686+337+253+309+261))\\n    (7,(686+337+253+309+213+0))    (2,(686+337+253+309+975+0))       (5,(686+337+253+309+261+170))\\n                                                                     (0,(686+337+253+309+261+170+0))\\n```"
                    },
                    {
                        "username": "EricRaw",
                        "content": "```\n8(+975) => 5(t = 2560)\n```\nit's 6(+975) => 2(t = 2560)"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "DFS and BFS both TLE...Why..."
                    },
                    {
                        "username": "EricRaw",
                        "content": "if you are using for loop (with n length) inside a for loop (with n length) it will guaranteed TLE O(n^2)"
                    },
                    {
                        "username": "marcus121",
                        "content": "No need to use tree search, dynamic programming is straightforward and works very fast (but uses a lot of space)"
                    }
                ]
            },
            {
                "id": 1915130,
                "content": [
                    {
                        "username": "hiroland2011",
                        "content": "I wonder why 0 is taking order from 2."
                    },
                    {
                        "username": "Swaraj_Kotapati",
                        "content": "Discussion >>> Description"
                    },
                    {
                        "username": "omniaosman4",
                        "content": "I think the problem need more examples "
                    },
                    {
                        "username": "najwer23",
                        "content": "Life would be simpler if we didn\\'t have managers in the company"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "DFS Traversal.\\nMake the adjacency list efficiently to make the tree where each child node will contain their id and time needed to get information from their parent \"[ i, informTime[manager[i]] ] \"and find maximum sum among all path from root (headID) to leaf in the tree. This can be done using simple dfs traversal."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Variable n seems redundant"
                    },
                    {
                        "username": "timiking5",
                        "content": "In this problem it is obvious that we use some sort of graph search, but yeasterday it was really unclear to me"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Please help me. Why this give me wrong answer!!!!\\nn: 11\\nheadID: 4\\nmanager= [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime= [0,213,0,253,686,170,975,0,261,309,337]\\nOutput: 2730\\nExpected: 2560\\n\\nHere my tree:\\n 4(686) => 10 (t=686)\\n10((+337)=> 3 (t=1023)\\n3(+253) => 9 (t=1276)\\n9(+309) => 1(213), 6(975), 8(261) (t=1585)\\n8(+975) => 5(t = 2560)\\n5(+170) => 0 (t=2730) Why this movement don\\'t count???\\n                \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@EricRaw](/EricRaw) Yes 6 alert 2 but if I finish here, 5 it\\'s never get notice, I put 8(+975) because 8 alert 5 first than 6 alert 2 so overall time it\\'s 975. Now I think that is because 8(261)+5(170) it\\'s less than 6(975) Then that path finish before 6. So don\\'t count. Now I\\'m goint to work, later I Will check the answer of friend @jayamrutkar"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I can explain with below example.\\n\\n[0, 1,  2, 3,  4,  5,  6,  7, 8,  9,  10]\\n[5, 9,  6, 10, -1, 8,  9,  1, 9,  3,  4]\\n[0, 213,0, 253,686,170,975,0, 261,309,337]\\n\\n```\\n                                    (4,686)\\n                                    (10,(686+337))\\n                                    (3,(686+337+253))\\n                                    (9,(686+337+253+309))\\n    (1,(686+337+253+309+213))      (6,(686+337+253+309+975))         (8,(686+337+253+309+261))\\n    (7,(686+337+253+309+213+0))    (2,(686+337+253+309+975+0))       (5,(686+337+253+309+261+170))\\n                                                                     (0,(686+337+253+309+261+170+0))\\n```"
                    },
                    {
                        "username": "EricRaw",
                        "content": "```\n8(+975) => 5(t = 2560)\n```\nit's 6(+975) => 2(t = 2560)"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "DFS and BFS both TLE...Why..."
                    },
                    {
                        "username": "EricRaw",
                        "content": "if you are using for loop (with n length) inside a for loop (with n length) it will guaranteed TLE O(n^2)"
                    },
                    {
                        "username": "marcus121",
                        "content": "No need to use tree search, dynamic programming is straightforward and works very fast (but uses a lot of space)"
                    }
                ]
            },
            {
                "id": 1915126,
                "content": [
                    {
                        "username": "hiroland2011",
                        "content": "I wonder why 0 is taking order from 2."
                    },
                    {
                        "username": "Swaraj_Kotapati",
                        "content": "Discussion >>> Description"
                    },
                    {
                        "username": "omniaosman4",
                        "content": "I think the problem need more examples "
                    },
                    {
                        "username": "najwer23",
                        "content": "Life would be simpler if we didn\\'t have managers in the company"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "DFS Traversal.\\nMake the adjacency list efficiently to make the tree where each child node will contain their id and time needed to get information from their parent \"[ i, informTime[manager[i]] ] \"and find maximum sum among all path from root (headID) to leaf in the tree. This can be done using simple dfs traversal."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Variable n seems redundant"
                    },
                    {
                        "username": "timiking5",
                        "content": "In this problem it is obvious that we use some sort of graph search, but yeasterday it was really unclear to me"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Please help me. Why this give me wrong answer!!!!\\nn: 11\\nheadID: 4\\nmanager= [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime= [0,213,0,253,686,170,975,0,261,309,337]\\nOutput: 2730\\nExpected: 2560\\n\\nHere my tree:\\n 4(686) => 10 (t=686)\\n10((+337)=> 3 (t=1023)\\n3(+253) => 9 (t=1276)\\n9(+309) => 1(213), 6(975), 8(261) (t=1585)\\n8(+975) => 5(t = 2560)\\n5(+170) => 0 (t=2730) Why this movement don\\'t count???\\n                \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@EricRaw](/EricRaw) Yes 6 alert 2 but if I finish here, 5 it\\'s never get notice, I put 8(+975) because 8 alert 5 first than 6 alert 2 so overall time it\\'s 975. Now I think that is because 8(261)+5(170) it\\'s less than 6(975) Then that path finish before 6. So don\\'t count. Now I\\'m goint to work, later I Will check the answer of friend @jayamrutkar"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I can explain with below example.\\n\\n[0, 1,  2, 3,  4,  5,  6,  7, 8,  9,  10]\\n[5, 9,  6, 10, -1, 8,  9,  1, 9,  3,  4]\\n[0, 213,0, 253,686,170,975,0, 261,309,337]\\n\\n```\\n                                    (4,686)\\n                                    (10,(686+337))\\n                                    (3,(686+337+253))\\n                                    (9,(686+337+253+309))\\n    (1,(686+337+253+309+213))      (6,(686+337+253+309+975))         (8,(686+337+253+309+261))\\n    (7,(686+337+253+309+213+0))    (2,(686+337+253+309+975+0))       (5,(686+337+253+309+261+170))\\n                                                                     (0,(686+337+253+309+261+170+0))\\n```"
                    },
                    {
                        "username": "EricRaw",
                        "content": "```\n8(+975) => 5(t = 2560)\n```\nit's 6(+975) => 2(t = 2560)"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "DFS and BFS both TLE...Why..."
                    },
                    {
                        "username": "EricRaw",
                        "content": "if you are using for loop (with n length) inside a for loop (with n length) it will guaranteed TLE O(n^2)"
                    },
                    {
                        "username": "marcus121",
                        "content": "No need to use tree search, dynamic programming is straightforward and works very fast (but uses a lot of space)"
                    }
                ]
            },
            {
                "id": 1915103,
                "content": [
                    {
                        "username": "hiroland2011",
                        "content": "I wonder why 0 is taking order from 2."
                    },
                    {
                        "username": "Swaraj_Kotapati",
                        "content": "Discussion >>> Description"
                    },
                    {
                        "username": "omniaosman4",
                        "content": "I think the problem need more examples "
                    },
                    {
                        "username": "najwer23",
                        "content": "Life would be simpler if we didn\\'t have managers in the company"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "DFS Traversal.\\nMake the adjacency list efficiently to make the tree where each child node will contain their id and time needed to get information from their parent \"[ i, informTime[manager[i]] ] \"and find maximum sum among all path from root (headID) to leaf in the tree. This can be done using simple dfs traversal."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Variable n seems redundant"
                    },
                    {
                        "username": "timiking5",
                        "content": "In this problem it is obvious that we use some sort of graph search, but yeasterday it was really unclear to me"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Please help me. Why this give me wrong answer!!!!\\nn: 11\\nheadID: 4\\nmanager= [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime= [0,213,0,253,686,170,975,0,261,309,337]\\nOutput: 2730\\nExpected: 2560\\n\\nHere my tree:\\n 4(686) => 10 (t=686)\\n10((+337)=> 3 (t=1023)\\n3(+253) => 9 (t=1276)\\n9(+309) => 1(213), 6(975), 8(261) (t=1585)\\n8(+975) => 5(t = 2560)\\n5(+170) => 0 (t=2730) Why this movement don\\'t count???\\n                \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@EricRaw](/EricRaw) Yes 6 alert 2 but if I finish here, 5 it\\'s never get notice, I put 8(+975) because 8 alert 5 first than 6 alert 2 so overall time it\\'s 975. Now I think that is because 8(261)+5(170) it\\'s less than 6(975) Then that path finish before 6. So don\\'t count. Now I\\'m goint to work, later I Will check the answer of friend @jayamrutkar"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I can explain with below example.\\n\\n[0, 1,  2, 3,  4,  5,  6,  7, 8,  9,  10]\\n[5, 9,  6, 10, -1, 8,  9,  1, 9,  3,  4]\\n[0, 213,0, 253,686,170,975,0, 261,309,337]\\n\\n```\\n                                    (4,686)\\n                                    (10,(686+337))\\n                                    (3,(686+337+253))\\n                                    (9,(686+337+253+309))\\n    (1,(686+337+253+309+213))      (6,(686+337+253+309+975))         (8,(686+337+253+309+261))\\n    (7,(686+337+253+309+213+0))    (2,(686+337+253+309+975+0))       (5,(686+337+253+309+261+170))\\n                                                                     (0,(686+337+253+309+261+170+0))\\n```"
                    },
                    {
                        "username": "EricRaw",
                        "content": "```\n8(+975) => 5(t = 2560)\n```\nit's 6(+975) => 2(t = 2560)"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "DFS and BFS both TLE...Why..."
                    },
                    {
                        "username": "EricRaw",
                        "content": "if you are using for loop (with n length) inside a for loop (with n length) it will guaranteed TLE O(n^2)"
                    },
                    {
                        "username": "marcus121",
                        "content": "No need to use tree search, dynamic programming is straightforward and works very fast (but uses a lot of space)"
                    }
                ]
            },
            {
                "id": 1915026,
                "content": [
                    {
                        "username": "hiroland2011",
                        "content": "I wonder why 0 is taking order from 2."
                    },
                    {
                        "username": "Swaraj_Kotapati",
                        "content": "Discussion >>> Description"
                    },
                    {
                        "username": "omniaosman4",
                        "content": "I think the problem need more examples "
                    },
                    {
                        "username": "najwer23",
                        "content": "Life would be simpler if we didn\\'t have managers in the company"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "DFS Traversal.\\nMake the adjacency list efficiently to make the tree where each child node will contain their id and time needed to get information from their parent \"[ i, informTime[manager[i]] ] \"and find maximum sum among all path from root (headID) to leaf in the tree. This can be done using simple dfs traversal."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Variable n seems redundant"
                    },
                    {
                        "username": "timiking5",
                        "content": "In this problem it is obvious that we use some sort of graph search, but yeasterday it was really unclear to me"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Please help me. Why this give me wrong answer!!!!\\nn: 11\\nheadID: 4\\nmanager= [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime= [0,213,0,253,686,170,975,0,261,309,337]\\nOutput: 2730\\nExpected: 2560\\n\\nHere my tree:\\n 4(686) => 10 (t=686)\\n10((+337)=> 3 (t=1023)\\n3(+253) => 9 (t=1276)\\n9(+309) => 1(213), 6(975), 8(261) (t=1585)\\n8(+975) => 5(t = 2560)\\n5(+170) => 0 (t=2730) Why this movement don\\'t count???\\n                \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@EricRaw](/EricRaw) Yes 6 alert 2 but if I finish here, 5 it\\'s never get notice, I put 8(+975) because 8 alert 5 first than 6 alert 2 so overall time it\\'s 975. Now I think that is because 8(261)+5(170) it\\'s less than 6(975) Then that path finish before 6. So don\\'t count. Now I\\'m goint to work, later I Will check the answer of friend @jayamrutkar"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I can explain with below example.\\n\\n[0, 1,  2, 3,  4,  5,  6,  7, 8,  9,  10]\\n[5, 9,  6, 10, -1, 8,  9,  1, 9,  3,  4]\\n[0, 213,0, 253,686,170,975,0, 261,309,337]\\n\\n```\\n                                    (4,686)\\n                                    (10,(686+337))\\n                                    (3,(686+337+253))\\n                                    (9,(686+337+253+309))\\n    (1,(686+337+253+309+213))      (6,(686+337+253+309+975))         (8,(686+337+253+309+261))\\n    (7,(686+337+253+309+213+0))    (2,(686+337+253+309+975+0))       (5,(686+337+253+309+261+170))\\n                                                                     (0,(686+337+253+309+261+170+0))\\n```"
                    },
                    {
                        "username": "EricRaw",
                        "content": "```\n8(+975) => 5(t = 2560)\n```\nit's 6(+975) => 2(t = 2560)"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "DFS and BFS both TLE...Why..."
                    },
                    {
                        "username": "EricRaw",
                        "content": "if you are using for loop (with n length) inside a for loop (with n length) it will guaranteed TLE O(n^2)"
                    },
                    {
                        "username": "marcus121",
                        "content": "No need to use tree search, dynamic programming is straightforward and works very fast (but uses a lot of space)"
                    }
                ]
            },
            {
                "id": 1915015,
                "content": [
                    {
                        "username": "hiroland2011",
                        "content": "I wonder why 0 is taking order from 2."
                    },
                    {
                        "username": "Swaraj_Kotapati",
                        "content": "Discussion >>> Description"
                    },
                    {
                        "username": "omniaosman4",
                        "content": "I think the problem need more examples "
                    },
                    {
                        "username": "najwer23",
                        "content": "Life would be simpler if we didn\\'t have managers in the company"
                    },
                    {
                        "username": "suraj_chaudhary2021",
                        "content": "DFS Traversal.\\nMake the adjacency list efficiently to make the tree where each child node will contain their id and time needed to get information from their parent \"[ i, informTime[manager[i]] ] \"and find maximum sum among all path from root (headID) to leaf in the tree. This can be done using simple dfs traversal."
                    },
                    {
                        "username": "Charlemagne5t",
                        "content": "Variable n seems redundant"
                    },
                    {
                        "username": "timiking5",
                        "content": "In this problem it is obvious that we use some sort of graph search, but yeasterday it was really unclear to me"
                    },
                    {
                        "username": "rayrogar",
                        "content": "Please help me. Why this give me wrong answer!!!!\\nn: 11\\nheadID: 4\\nmanager= [5,9,6,10,-1,8,9,1,9,3,4]\\ninformTime= [0,213,0,253,686,170,975,0,261,309,337]\\nOutput: 2730\\nExpected: 2560\\n\\nHere my tree:\\n 4(686) => 10 (t=686)\\n10((+337)=> 3 (t=1023)\\n3(+253) => 9 (t=1276)\\n9(+309) => 1(213), 6(975), 8(261) (t=1585)\\n8(+975) => 5(t = 2560)\\n5(+170) => 0 (t=2730) Why this movement don\\'t count???\\n                \\n"
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@EricRaw](/EricRaw) Yes 6 alert 2 but if I finish here, 5 it\\'s never get notice, I put 8(+975) because 8 alert 5 first than 6 alert 2 so overall time it\\'s 975. Now I think that is because 8(261)+5(170) it\\'s less than 6(975) Then that path finish before 6. So don\\'t count. Now I\\'m goint to work, later I Will check the answer of friend @jayamrutkar"
                    },
                    {
                        "username": "jayamrutkar",
                        "content": "I can explain with below example.\\n\\n[0, 1,  2, 3,  4,  5,  6,  7, 8,  9,  10]\\n[5, 9,  6, 10, -1, 8,  9,  1, 9,  3,  4]\\n[0, 213,0, 253,686,170,975,0, 261,309,337]\\n\\n```\\n                                    (4,686)\\n                                    (10,(686+337))\\n                                    (3,(686+337+253))\\n                                    (9,(686+337+253+309))\\n    (1,(686+337+253+309+213))      (6,(686+337+253+309+975))         (8,(686+337+253+309+261))\\n    (7,(686+337+253+309+213+0))    (2,(686+337+253+309+975+0))       (5,(686+337+253+309+261+170))\\n                                                                     (0,(686+337+253+309+261+170+0))\\n```"
                    },
                    {
                        "username": "EricRaw",
                        "content": "```\n8(+975) => 5(t = 2560)\n```\nit's 6(+975) => 2(t = 2560)"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "DFS and BFS both TLE...Why..."
                    },
                    {
                        "username": "EricRaw",
                        "content": "if you are using for loop (with n length) inside a for loop (with n length) it will guaranteed TLE O(n^2)"
                    },
                    {
                        "username": "marcus121",
                        "content": "No need to use tree search, dynamic programming is straightforward and works very fast (but uses a lot of space)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Frog Position After T Seconds",
        "question_content": "<p>Given an undirected tree consisting of <code>n</code> vertices numbered from <code>1</code> to <code>n</code>. A frog starts jumping from <strong>vertex 1</strong>. In one second, the frog jumps from its current vertex to another <strong>unvisited</strong> vertex if they are directly connected. The frog can not jump back to a visited vertex. In case the frog can jump to several vertices, it jumps randomly to one of them with the same probability. Otherwise, when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.</p>\n\n<p>The edges of the undirected tree are given in the array <code>edges</code>, where <code>edges[i] = [a<sub>i</sub>, b<sub>i</sub>]</code> means that exists an edge connecting the vertices <code>a<sub>i</sub></code> and <code>b<sub>i</sub></code>.</p>\n\n<p><em>Return the probability that after <code>t</code> seconds the frog is on the vertex <code>target</code>. </em>Answers within <code>10<sup>-5</sup></code> of the actual answer will be accepted.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/frog1.jpg\" style=\"width: 338px; height: 304px;\" />\n<pre>\n<strong>Input:</strong> n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 2, target = 4\n<strong>Output:</strong> 0.16666666666666666 \n<strong>Explanation:</strong> The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 probability to the vertex 2 after <strong>second 1</strong> and then jumping with 1/2 probability to vertex 4 after <strong>second 2</strong>. Thus the probability for the frog is on the vertex 4 after 2 seconds is 1/3 * 1/2 = 1/6 = 0.16666666666666666. \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/21/frog2.jpg\" style=\"width: 304px; height: 304px;\" /></strong>\n\n<pre>\n<strong>Input:</strong> n = 7, edges = [[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]], t = 1, target = 7\n<strong>Output:</strong> 0.3333333333333333\n<strong>Explanation: </strong>The figure above shows the given graph. The frog starts at vertex 1, jumping with 1/3 = 0.3333333333333333 probability to the vertex 7 after <strong>second 1</strong>. \n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>edges.length == n - 1</code></li>\n\t<li><code>edges[i].length == 2</code></li>\n\t<li><code>1 &lt;= a<sub>i</sub>, b<sub>i</sub> &lt;= n</code></li>\n\t<li><code>1 &lt;= t &lt;= 50</code></li>\n\t<li><code>1 &lt;= target &lt;= n</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 532505,
                "title": "java-straightforward-bfs-clean-code-o-n",
                "content": "```java\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] e : edges) {\\n            graph[e[0] - 1].add(e[1] - 1);\\n            graph[e[1] - 1].add(e[0] - 1);\\n        }\\n        boolean[] visited = new boolean[n]; visited[0] = true;\\n        double[] prob = new double[n]; prob[0] = 1f;\\n        Queue<Integer> q = new LinkedList<>(); q.offer(0);\\n        while (!q.isEmpty() && t-- > 0) {\\n            for (int size = q.size(); size > 0; size--) {\\n                int u = q.poll(), nextVerticesCount = 0;\\n                for (int v : graph[u]) if (!visited[v]) nextVerticesCount++;\\n                for (int v : graph[u]) {\\n                    if (!visited[v]) {\\n                        visited[v] = true;\\n                        q.offer(v);\\n                        prob[v] = prob[u] / nextVerticesCount;\\n                    }\\n                }\\n                if (nextVerticesCount > 0) prob[u] = 0; // frog don\\'t stay vertex u, he keeps going to the next vertex\\n            }\\n        }\\n        return prob[target - 1];\\n    }\\n}\\n```\\n**Complexity:**\\n- Time: `O(n)`\\n- Space: `O(n)`",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        List<Integer>[] graph = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int[] e : edges) {\\n            graph[e[0] - 1].add(e[1] - 1);\\n            graph[e[1] - 1].add(e[0] - 1);\\n        }\\n        boolean[] visited = new boolean[n]; visited[0] = true;\\n        double[] prob = new double[n]; prob[0] = 1f;\\n        Queue<Integer> q = new LinkedList<>(); q.offer(0);\\n        while (!q.isEmpty() && t-- > 0) {\\n            for (int size = q.size(); size > 0; size--) {\\n                int u = q.poll(), nextVerticesCount = 0;\\n                for (int v : graph[u]) if (!visited[v]) nextVerticesCount++;\\n                for (int v : graph[u]) {\\n                    if (!visited[v]) {\\n                        visited[v] = true;\\n                        q.offer(v);\\n                        prob[v] = prob[u] / nextVerticesCount;\\n                    }\\n                }\\n                if (nextVerticesCount > 0) prob[u] = 0; // frog don\\'t stay vertex u, he keeps going to the next vertex\\n            }\\n        }\\n        return prob[target - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532571,
                "title": "java-c-python-dfs",
                "content": "**Java**\\nby @feelspecial21\\n```java\\nclass Solution {\\n    LinkedList<Integer> adjListArray[];\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        if (n == 1) return 1.0;\\n        adjListArray = new LinkedList[n + 1];\\n        for(int i = 0; i <= n ; i++) adjListArray[i] = new LinkedList<>();\\n        for (int[] edge : edges) {\\n            adjListArray[edge[0]].add(edge[1]);\\n            adjListArray[edge[1]].add(edge[0]);\\n        }\\n\\n        return dfs(1, t, target, new boolean[n + 1]);\\n    }\\n\\n    private double dfs(int node, int t, int target, boolean[] visited) {\\n        if (node != 1 && adjListArray[node].size() == 1 || t == 0) {\\n            if (node == target)\\n                return 1;\\n            else return 0;\\n        }\\n        visited[node] = true;\\n        double res = 0.0;\\n        for (int child : adjListArray[node]) {\\n            if (visited[child]) continue; // skip visited children\\n            res += dfs(child, t - 1, target, visited);\\n        }\\n        if (node != 1)\\n            return res * 1.0 / (adjListArray[node].size() - 1);\\n        else\\n            return res * 1.0 / (adjListArray[node].size());\\n    }\\n}\\n```\\n**C++**\\nby @SuperWhw\\n```cpp\\n    vector<vector<int> > G;\\n    vector<bool> seen;\\n    int target;\\n\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        if (n == 1) return 1.0;\\n        this->target = target;\\n        G = vector<vector<int> >(n + 1);\\n        for (auto e : edges) {\\n            G[e[0]].push_back(e[1]);\\n            G[e[1]].push_back(e[0]);\\n        }\\n        seen = vector<bool>(n + 1, false);\\n\\n        return dfs(1, t);\\n    }\\n\\n    double dfs(int i, int t) {\\n        if (i != 1 && G[i].size() == 1 || t == 0) {\\n            return i == target;\\n        }\\n        seen[i] = true;\\n        double res = 0;\\n        for (auto j : G[i]) {\\n            if (! seen[j]) {\\n                res += dfs(j, t - 1);\\n            }\\n        }\\n        return res / (G[i].size() - (i != 1));\\n    }\\n```\\n**Python:**\\n```py\\n    def frogPosition(self, n, edges, t, target):\\n        if n == 1: return 1.0\\n        G = [[] for i in xrange(n + 1)]\\n        for i, j in edges:\\n            G[i].append(j)\\n            G[j].append(i)\\n        seen = [0] * (n + 1)\\n\\n        def dfs(i, t):\\n            if i != 1 and len(G[i]) == 1 or t == 0:\\n                return i == target\\n            seen[i] = 1\\n            res = sum(dfs(j, t - 1) for j in G[i] if not seen[j])\\n            return res * 1.0 / (len(G[i]) - (i != 1))\\n        return dfs(1, t)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    LinkedList<Integer> adjListArray[];\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        if (n == 1) return 1.0;\\n        adjListArray = new LinkedList[n + 1];\\n        for(int i = 0; i <= n ; i++) adjListArray[i] = new LinkedList<>();\\n        for (int[] edge : edges) {\\n            adjListArray[edge[0]].add(edge[1]);\\n            adjListArray[edge[1]].add(edge[0]);\\n        }\\n\\n        return dfs(1, t, target, new boolean[n + 1]);\\n    }\\n\\n    private double dfs(int node, int t, int target, boolean[] visited) {\\n        if (node != 1 && adjListArray[node].size() == 1 || t == 0) {\\n            if (node == target)\\n                return 1;\\n            else return 0;\\n        }\\n        visited[node] = true;\\n        double res = 0.0;\\n        for (int child : adjListArray[node]) {\\n            if (visited[child]) continue; // skip visited children\\n            res += dfs(child, t - 1, target, visited);\\n        }\\n        if (node != 1)\\n            return res * 1.0 / (adjListArray[node].size() - 1);\\n        else\\n            return res * 1.0 / (adjListArray[node].size());\\n    }\\n}\\n```\n```cpp\\n    vector<vector<int> > G;\\n    vector<bool> seen;\\n    int target;\\n\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        if (n == 1) return 1.0;\\n        this->target = target;\\n        G = vector<vector<int> >(n + 1);\\n        for (auto e : edges) {\\n            G[e[0]].push_back(e[1]);\\n            G[e[1]].push_back(e[0]);\\n        }\\n        seen = vector<bool>(n + 1, false);\\n\\n        return dfs(1, t);\\n    }\\n\\n    double dfs(int i, int t) {\\n        if (i != 1 && G[i].size() == 1 || t == 0) {\\n            return i == target;\\n        }\\n        seen[i] = true;\\n        double res = 0;\\n        for (auto j : G[i]) {\\n            if (! seen[j]) {\\n                res += dfs(j, t - 1);\\n            }\\n        }\\n        return res / (G[i].size() - (i != 1));\\n    }\\n```\n```py\\n    def frogPosition(self, n, edges, t, target):\\n        if n == 1: return 1.0\\n        G = [[] for i in xrange(n + 1)]\\n        for i, j in edges:\\n            G[i].append(j)\\n            G[j].append(i)\\n        seen = [0] * (n + 1)\\n\\n        def dfs(i, t):\\n            if i != 1 and len(G[i]) == 1 or t == 0:\\n                return i == target\\n            seen[i] = 1\\n            res = sum(dfs(j, t - 1) for j in G[i] if not seen[j])\\n            return res * 1.0 / (len(G[i]) - (i != 1))\\n        return dfs(1, t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532495,
                "title": "c-simple-dfs",
                "content": "**Observation**\\nThe answer lies in the examples.\\nWe can use a simple DFS to reach the target node while storing the probablity of reaching that node at `t` by multiplying by the number of children that node has.\\nOnce we reach that target and depth required in the problem we can return that probablity.\\nEdge cases:\\n1. When when either the node is somewhere in the middle and we reach that node but not in target time, we simply return 0.\\n1. When it\\'s a leaf node but the time is less than the required one, it\\'ll simply jump until the goal time, thus we can return the same probablity.\\n\\n**Solution**\\n```c++\\nclass Solution {\\npublic:\\n    long double prob=0;\\n    int target;\\n    vector<vector<int>> adjList;\\n    vector<bool> visited;\\n    bool dfs(int node,int depth,long double prob)\\n    {\\n        if(depth<0)              //We don\\'t need to check for depth greater than time.\\n            return false;\\n        visited[node]=true;\\n        if(node==target)\\n        {\\n            if(depth==0||adjList[node].size()==(node!=1))\\t\\t//depth=time or it\\'s a leaf node.\\n                this->prob=prob;\\n            return true;\\t\\t//Early exit.\\n        }\\n        for(int &n:adjList[node])\\n            if(!visited[n]&&dfs(n,depth-1,prob*(long double)1/(adjList[node].size()-(node!=1))))\\t\\t//DFS to each children with carrying the probablity to reach them. (Early exit if found)\\n                return true;\\n        return false;                \\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) \\n    {\\n        adjList.resize(n+1);\\n        visited.resize(n+1,false);\\n        this->target=target;\\n        for(vector<int> &v:edges)\\t\\t//Create adjacency list.\\n            adjList[v[0]].push_back(v[1]),adjList[v[1]].push_back(v[0]);\\n        dfs(1,t,1);\\n        return prob;\\n    }\\n};\\n```\\n**Complexity**\\nSpace: `O(n)`.\\nTime: `O(n)`.",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long double prob=0;\\n    int target;\\n    vector<vector<int>> adjList;\\n    vector<bool> visited;\\n    bool dfs(int node,int depth,long double prob)\\n    {\\n        if(depth<0)              //We don\\'t need to check for depth greater than time.\\n            return false;\\n        visited[node]=true;\\n        if(node==target)\\n        {\\n            if(depth==0||adjList[node].size()==(node!=1))\\t\\t//depth=time or it\\'s a leaf node.\\n                this->prob=prob;\\n            return true;\\t\\t//Early exit.\\n        }\\n        for(int &n:adjList[node])\\n            if(!visited[n]&&dfs(n,depth-1,prob*(long double)1/(adjList[node].size()-(node!=1))))\\t\\t//DFS to each children with carrying the probablity to reach them. (Early exit if found)\\n                return true;\\n        return false;                \\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) \\n    {\\n        adjList.resize(n+1);\\n        visited.resize(n+1,false);\\n        this->target=target;\\n        for(vector<int> &v:edges)\\t\\t//Create adjacency list.\\n            adjList[v[0]].push_back(v[1]),adjList[v[1]].push_back(v[0]);\\n        dfs(1,t,1);\\n        return prob;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532475,
                "title": "python-easy-dfs-bfs-with-explanation",
                "content": "**Idea**\\nFirst we build an adjacency list using `edges`.\\nWe then DFS through all the nodes. Do note that we can only visited a node once in an undirected graph. There are basically 2 solutions.\\n1. Construct a undirected graph and transform it into a directed tree first **(method 1)**\\n2. Use set to record all the visited nodes along the way **(method 2)**\\n\\n**Complexity**\\nTime: `O(N)`\\nSpace: `O(N)`\\n\\n**Python 3, DFS with recursion, method 2**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        visited, res = set(), 0.\\n        def dfs(leaf_id, p, time):\\n            nonlocal res\\n            if time >= t:\\n                if leaf_id == target: res = p\\n                return\\n            visited.add(leaf_id)\\n            neighbors = nei[leaf_id] - visited\\n            for n in neighbors or [leaf_id]:\\n                dfs(n, p / (len(neighbors) or 1), time + 1)\\n        dfs(1, 1, 0)\\n        return res\\n```\\n\\n**Python 3, BFS without recursion, method 2**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        dp = collections.deque([(1, 1, 0)]) # state: leaf_id, possibility, timestamp\\n        visited = set()\\n        \\n        while dp:\\n            leaf, p, curr = dp.popleft()\\n            visited.add(leaf)\\n            \\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            \\n            neighbors = nei[leaf] - visited\\n            for n in neighbors or [leaf]:\\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\\n        return 0.\\n```\\n\\n**Python 3, DFS without recursion, method 2**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        dp = [(1, 1, 0)] # state: leaf_id, possibility, timestamp\\n        visited = set()\\n        \\n        while dp:\\n            leaf, p, curr = dp.pop()\\n            visited.add(leaf)\\n            \\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            \\n            neighbors = nei[leaf] - visited\\n            for n in neighbors or [leaf]:\\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\\n        return 0.\\n```\\n\\n**Python 3, DFS on tree without recursion, method 1**\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n                    \\n        dp = collections.deque([1])\\n        while dp:\\n            leaf = dp.popleft()\\n            for n_ in nei[leaf]:\\n                nei[n_].remove(leaf)\\n                dp += n_,\\n                \\n        dp = [(1, 1, 0)]\\n        while dp:\\n            leaf, p, curr = dp.pop()\\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            for n in nei[leaf] or [leaf]:\\n                dp += (n, p / (len(nei[leaf]) or 1), curr+1),\\n        return 0.0\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        visited, res = set(), 0.\\n        def dfs(leaf_id, p, time):\\n            nonlocal res\\n            if time >= t:\\n                if leaf_id == target: res = p\\n                return\\n            visited.add(leaf_id)\\n            neighbors = nei[leaf_id] - visited\\n            for n in neighbors or [leaf_id]:\\n                dfs(n, p / (len(neighbors) or 1), time + 1)\\n        dfs(1, 1, 0)\\n        return res\\n```\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        dp = collections.deque([(1, 1, 0)]) # state: leaf_id, possibility, timestamp\\n        visited = set()\\n        \\n        while dp:\\n            leaf, p, curr = dp.popleft()\\n            visited.add(leaf)\\n            \\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            \\n            neighbors = nei[leaf] - visited\\n            for n in neighbors or [leaf]:\\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\\n        return 0.\\n```\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n            \\n        dp = [(1, 1, 0)] # state: leaf_id, possibility, timestamp\\n        visited = set()\\n        \\n        while dp:\\n            leaf, p, curr = dp.pop()\\n            visited.add(leaf)\\n            \\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            \\n            neighbors = nei[leaf] - visited\\n            for n in neighbors or [leaf]:\\n                dp += (n, p / (len(neighbors) or 1), curr + 1),\\n        return 0.\\n```\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nei = collections.defaultdict(set)\\n        for a, b in edges:\\n            nei[a].add(b)\\n            nei[b].add(a)\\n                    \\n        dp = collections.deque([1])\\n        while dp:\\n            leaf = dp.popleft()\\n            for n_ in nei[leaf]:\\n                nei[n_].remove(leaf)\\n                dp += n_,\\n                \\n        dp = [(1, 1, 0)]\\n        while dp:\\n            leaf, p, curr = dp.pop()\\n            if curr >= t:\\n                if leaf == target: return p\\n                continue\\n            for n in nei[leaf] or [leaf]:\\n                dp += (n, p / (len(nei[leaf]) or 1), curr+1),\\n        return 0.0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344094,
                "title": "c-straightforward-bfs-nothing-complicated",
                "content": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> graph(n+1);\\n        for(auto e : edges){\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        vector<double> prob(n+1 , 0);\\n        queue<int> q;\\n        q.push(1);\\n        vector<bool> visited(n+1, 0);\\n        visited[1] = 1;\\n        prob[1] = 1.0;\\n        while(!q.empty() && t--) {\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                int node = q.front();\\n                q.pop();\\n                int edge_count = 0; //count of unvisited nodes from the current node. \\n                for(auto v : graph[node]){\\n                    if(!visited[v]) \\n                        edge_count++;\\n                }\\n                for(auto v : graph[node]) {\\n                    if(!visited[v]) {\\n                        q.push(v);\\n                        visited[v] = true;        \\n                        prob[v] =  prob[node] / edge_count;                        \\n                    }\\n                } \\n\\t\\t\\t\\t//the only tricky part\\n                //A frog cannot stay at a fixed postion until there\\'s no more vertex to jump\\n                if(edge_count>0)\\n                    prob[node] = 0;\\n            }\\n        }\\n        return prob[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> graph(n+1);\\n        for(auto e : edges){\\n            graph[e[0]].push_back(e[1]);\\n            graph[e[1]].push_back(e[0]);\\n        }\\n        vector<double> prob(n+1 , 0);\\n        queue<int> q;\\n        q.push(1);\\n        vector<bool> visited(n+1, 0);\\n        visited[1] = 1;\\n        prob[1] = 1.0;\\n        while(!q.empty() && t--) {\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                int node = q.front();\\n                q.pop();\\n                int edge_count = 0; //count of unvisited nodes from the current node. \\n                for(auto v : graph[node]){\\n                    if(!visited[v]) \\n                        edge_count++;\\n                }\\n                for(auto v : graph[node]) {\\n                    if(!visited[v]) {\\n                        q.push(v);\\n                        visited[v] = true;        \\n                        prob[v] =  prob[node] / edge_count;                        \\n                    }\\n                } \\n\\t\\t\\t\\t//the only tricky part\\n                //A frog cannot stay at a fixed postion until there\\'s no more vertex to jump\\n                if(edge_count>0)\\n                    prob[node] = 0;\\n            }\\n        }\\n        return prob[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385959,
                "title": "c-dfs",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double ans=0;\\n    int c_t;\\n    void dfs(vector<int>ad[],int i,int time,int targ,vector<int>&vis,double prob){\\n        vis[i]=1;\\n        if(targ==i){\\n            if(time==c_t)ans=prob;\\n            else {\\n                if(time<c_t)\\n                if(i!=1 && ad[i].size()<=1)ans=prob;\\n            }\\n            return;\\n        }\\n        for(auto x : ad[i]){\\n            double sz=ad[i].size();\\n            if(i!=1)sz--;\\n            double p=1.0/sz;\\n            if(!vis[x])\\n             dfs(ad,x,time+1,targ,vis,prob*p);\\n        }\\n        \\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int time, int x) {\\n        vector<int>ad[n+1];\\n        c_t=time;\\n        for(auto x:edges){\\n            ad[x[0]].push_back(x[1]);\\n            ad[x[1]].push_back(x[0]);\\n        }\\n        vector<int>vis(n+1,0);\\n        dfs(ad,1,0,x,vis,1);\\n        if(ad[1].size()==0 && x==1)return 1.0;\\n       return ans;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/a8f9eab1-cedb-4a5a-8a26-977968ca0b22_1680773671.7848744.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double ans=0;\\n    int c_t;\\n    void dfs(vector<int>ad[],int i,int time,int targ,vector<int>&vis,double prob){\\n        vis[i]=1;\\n        if(targ==i){\\n            if(time==c_t)ans=prob;\\n            else {\\n                if(time<c_t)\\n                if(i!=1 && ad[i].size()<=1)ans=prob;\\n            }\\n            return;\\n        }\\n        for(auto x : ad[i]){\\n            double sz=ad[i].size();\\n            if(i!=1)sz--;\\n            double p=1.0/sz;\\n            if(!vis[x])\\n             dfs(ad,x,time+1,targ,vis,prob*p);\\n        }\\n        \\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int time, int x) {\\n        vector<int>ad[n+1];\\n        c_t=time;\\n        for(auto x:edges){\\n            ad[x[0]].push_back(x[1]);\\n            ad[x[1]].push_back(x[0]);\\n        }\\n        vector<int>vis(n+1,0);\\n        dfs(ad,1,0,x,vis,1);\\n        if(ad[1].size()==0 && x==1)return 1.0;\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532506,
                "title": "c-simple-dfs",
                "content": "Approach : Try to write a recursive solution.\\nStart from vertex 1 and proceed to all unvisited neigbors (use a visited boolean array)\\n\\nWhen from a vertex `u` there are `p` vertices which can be visited, so the probability of choosing a vertex is `1/p`, followed by the product with the sum of probabilities of every neighbor.\\n\\n`subans` variable calculates the probability from the neighboring nodes and `1/count` is the multiplied to calculate the probability of choosing a particular vertex.\\n\\n**Base cases** :\\n\\n\\t1. When time reduces 0, i.e. we can\\'t jump further, so we are at target then 1.0 probability otherwise 0.\\n\\t2. When we can\\'t jump to any unvisited vertex, then we will jump on it continously, to avoid redundant calls, check if this node is target or not. If yes then 1.0 is the probability, otherwise 0.\\n\\n```\\nclass Solution {\\npublic:\\n    double dfs(int s, vector<vector<int>> &adj, vector<bool>&vis, int time, int target)\\n    {\\n        vis[s] = 1;\\n        if(time == 0)\\n        {\\n            return s == target ? 1.0 : 0.0;\\n        }\\n        int count = 0;\\n        double ans;\\n        double subans = 0.0;\\n        for(int i = 0; i < adj[s].size(); i++)\\n        {\\n            int v = adj[s][i];\\n            if(vis[v] == 0)\\n            {\\n                count++;\\n                subans += dfs(v, adj, vis, time - 1, target);\\n            }\\n        }\\n        if(count > 0)\\n        {\\n            ans = 1.0/(count*1.0);\\n            ans = ans*subans;\\n        }\\n        else\\n        {\\n            ans = (s == target) ? 1.0 : 0.0;\\n        }\\n        return ans;\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> adj(n + 1);\\n        \\n        for(int i = 0; i < edges.size(); i++)\\n        {\\n            int f = edges[i][0], to = edges[i][1];\\n\\t\\t\\t// build undirected graph\\n            adj[f].push_back(to);\\n            adj[to].push_back(f);\\n        }\\n        vector<bool> vis(n + 1);\\n        return dfs(1, adj, vis, t, target);\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double dfs(int s, vector<vector<int>> &adj, vector<bool>&vis, int time, int target)\\n    {\\n        vis[s] = 1;\\n        if(time == 0)\\n        {\\n            return s == target ? 1.0 : 0.0;\\n        }\\n        int count = 0;\\n        double ans;\\n        double subans = 0.0;\\n        for(int i = 0; i < adj[s].size(); i++)\\n        {\\n            int v = adj[s][i];\\n            if(vis[v] == 0)\\n            {\\n                count++;\\n                subans += dfs(v, adj, vis, time - 1, target);\\n            }\\n        }\\n        if(count > 0)\\n        {\\n            ans = 1.0/(count*1.0);\\n            ans = ans*subans;\\n        }\\n        else\\n        {\\n            ans = (s == target) ? 1.0 : 0.0;\\n        }\\n        return ans;\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> adj(n + 1);\\n        \\n        for(int i = 0; i < edges.size(); i++)\\n        {\\n            int f = edges[i][0], to = edges[i][1];\\n\\t\\t\\t// build undirected graph\\n            adj[f].push_back(to);\\n            adj[to].push_back(f);\\n        }\\n        vector<bool> vis(n + 1);\\n        return dfs(1, adj, vis, t, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602053,
                "title": "c-dfs-diagram",
                "content": "![image](https://assets.leetcode.com/users/images/fbfce5c3-3c32-46ca-83b1-bfd9f3cddfd4_1663692417.955603.png)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int> > G;\\n    vector<bool> seen;\\n    int target;\\n\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        if (n == 1) return 1.0;\\n        this->target = target;\\n        G.resize(n + 1, vector<int>());\\n        for (auto e : edges) {\\n            int u = e[0], v = e[1];\\n            G[u].push_back(v);\\n            G[v].push_back(u);\\n        }\\n        seen = vector<bool>(n + 1, false);\\n\\n        return dfs(1, t);\\n    }\\n\\n    double dfs(int i, int t) {\\n        // When time finishes or adjacent list is of size 1.\\n        if (i != 1 && G[i].size() == 1 || t == 0) {\\n            return i == target;\\n        }\\n        seen[i] = true;\\n        double res = 0;\\n        for (auto j : G[i]) {\\n            if (! seen[j]) {\\n                res += dfs(j, t - 1);\\n            }\\n        }\\n        return res / (G[i].size() - (i != 1));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int> > G;\\n    vector<bool> seen;\\n    int target;\\n\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        if (n == 1) return 1.0;\\n        this->target = target;\\n        G.resize(n + 1, vector<int>());\\n        for (auto e : edges) {\\n            int u = e[0], v = e[1];\\n            G[u].push_back(v);\\n            G[v].push_back(u);\\n        }\\n        seen = vector<bool>(n + 1, false);\\n\\n        return dfs(1, t);\\n    }\\n\\n    double dfs(int i, int t) {\\n        // When time finishes or adjacent list is of size 1.\\n        if (i != 1 && G[i].size() == 1 || t == 0) {\\n            return i == target;\\n        }\\n        seen[i] = true;\\n        double res = 0;\\n        for (auto j : G[i]) {\\n            if (! seen[j]) {\\n                res += dfs(j, t - 1);\\n            }\\n        }\\n        return res / (G[i].size() - (i != 1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326702,
                "title": "dfs-2ms",
                "content": "```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n       \\n        ArrayList<ArrayList<Integer>> graph=new ArrayList<>();\\n        for(int i=0;i<=n;i++)\\n            graph.add(new ArrayList<>());\\n        \\n        for(int ar[]:edges){\\n          int u=ar[0];\\n          int v=ar[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        ans=0;\\n        dfs(1,t,target,graph,1,new boolean[n+1]);\\n        return ans;\\n    }\\n    double ans;\\n    \\n    public void dfs(int i,int t,int tar,ArrayList<ArrayList<Integer>> graph,double prob,boolean vis[]){\\n\\t// size for node 1 will be no of children but for other it will be 1 less bcz we have visisted its parent(only one)\\n        int size=graph.get(i).size()-(i==1?0:1);\\n        vis[i]=true;\\n        if(i==tar){\\n            if(t==0)ans=prob;               //  on target on given time\\n            else if(t>0 && size==0)ans=prob;  // on target not on given time but its leaf(we can\\'t can\\'t go anywhere now )\\n          return;\\n        }\\n        if(t>0)\\n        for(int x:graph.get(i)){\\n            if(!vis[x])\\n            dfs(x,t-1,tar,graph,prob/size,vis); // prob will be divided by no of its children\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n       \\n        ArrayList<ArrayList<Integer>> graph=new ArrayList<>();\\n        for(int i=0;i<=n;i++)\\n            graph.add(new ArrayList<>());\\n        \\n        for(int ar[]:edges){\\n          int u=ar[0];\\n          int v=ar[1];\\n            graph.get(u).add(v);\\n            graph.get(v).add(u);\\n        }\\n        ans=0;\\n        dfs(1,t,target,graph,1,new boolean[n+1]);\\n        return ans;\\n    }\\n    double ans;\\n    \\n    public void dfs(int i,int t,int tar,ArrayList<ArrayList<Integer>> graph,double prob,boolean vis[]){\\n\\t// size for node 1 will be no of children but for other it will be 1 less bcz we have visisted its parent(only one)\\n        int size=graph.get(i).size()-(i==1?0:1);\\n        vis[i]=true;\\n        if(i==tar){\\n            if(t==0)ans=prob;               //  on target on given time\\n            else if(t>0 && size==0)ans=prob;  // on target not on given time but its leaf(we can\\'t can\\'t go anywhere now )\\n          return;\\n        }\\n        if(t>0)\\n        for(int x:graph.get(i)){\\n            if(!vis[x])\\n            dfs(x,t-1,tar,graph,prob/size,vis); // prob will be divided by no of its children\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532666,
                "title": "java-dfs-o-n",
                "content": "```\\nLinkedList<Integer> adjListArray[];\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        adjListArray = new LinkedList[n + 1];\\n        for(int i = 0; i <= n ; i++) adjListArray[i] = new LinkedList<>(); \\n        for (int[] edge : edges) {\\n            adjListArray[edge[0]].add(edge[1]);\\n            adjListArray[edge[1]].add(edge[0]);\\n        }\\n\\n        return Math.max(0, dfs(1, 0, t, target, new boolean[n + 1]));\\n    }\\n\\n    private double dfs(int node, int currTime, int t, int target, boolean[] visited) {\\n        if (currTime > t) return -1; // time is out\\n        if (node == target && currTime == t) return 1; // reached the target on time\\n        visited[node] = true;\\n        int childrenCount = 0; // count of children that still were not visited\\n        for (int child : adjListArray[node]) {\\n            if (visited[child]) continue;\\n            childrenCount++;\\n        }\\n        if (node == target && childrenCount == 0) return 1; // reached the target and there are no more moves\\n        for (int child : adjListArray[node]) {\\n            if (visited[child]) continue; // skip visited children\\n            double res = dfs(child, currTime + 1, t, target, visited);\\n            if (res == -1) continue;\\n            return res * 1.0 / childrenCount; // probability calculation\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nLinkedList<Integer> adjListArray[];\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        adjListArray = new LinkedList[n + 1];\\n        for(int i = 0; i <= n ; i++) adjListArray[i] = new LinkedList<>(); \\n        for (int[] edge : edges) {\\n            adjListArray[edge[0]].add(edge[1]);\\n            adjListArray[edge[1]].add(edge[0]);\\n        }\\n\\n        return Math.max(0, dfs(1, 0, t, target, new boolean[n + 1]));\\n    }\\n\\n    private double dfs(int node, int currTime, int t, int target, boolean[] visited) {\\n        if (currTime > t) return -1; // time is out\\n        if (node == target && currTime == t) return 1; // reached the target on time\\n        visited[node] = true;\\n        int childrenCount = 0; // count of children that still were not visited\\n        for (int child : adjListArray[node]) {\\n            if (visited[child]) continue;\\n            childrenCount++;\\n        }\\n        if (node == target && childrenCount == 0) return 1; // reached the target and there are no more moves\\n        for (int child : adjListArray[node]) {\\n            if (visited[child]) continue; // skip visited children\\n            double res = dfs(child, currTime + 1, t, target, visited);\\n            if (res == -1) continue;\\n            return res * 1.0 / childrenCount; // probability calculation\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532486,
                "title": "python-dfs-in-a-tree",
                "content": "We can use DFS to search the entire Tree and aggregately update the probability. We pass down time we left and aggregated probability. So dfs is like `dfs(x, t, p)`\\n\\n\\n4 cases when we visit a node `x`:\\n1. Time is up and we didn\\'t reach our target, return `0`\\n2. Current node is our target, time is just up or can\\'t jump to any unvisitied node, return aggregate probability `p`\\n3. Current node is our target, time is not up and there are unvisitied nodes to jump to, return `0`\\n4. Current node is not our target and time is not up, let `q` to be the list of unvisitied nodes we can jump to, then return `sum(dfs(y, t - 1, p * 1 / len(q)) for y in q)`\\n\\n`T` is a tree so no cycle, only revisit case is revisiting node\\'s parent (due to undirected edge). So we pass down parent as well. Let `y` is current visit node, `x` is `y`\\'s parent, `z` is `y`\\'s child, `z` can\\'t be `x`. So our `q` will be `[z for z in T[y] if z != x]`\\n\\n```\\ndef frogPosition(n, edges, time, target):\\n    T = collections.defaultdict(set)\\n    for u, v in edges:\\n        T[u].add(v)\\n        T[v].add(u)\\n\\n    def dfs(x, y, t, p):\\n        if t < 0:\\n            return 0\\n        zs = [z for z in T[y] if z != x]\\n        if y == target:\\n            return 0 if (t and zs) else p\\n        q = 1 / len(zs)\\n        return sum(dfs(y, z, t-1, p*q) for z in zs)\\n\\n    return dfs(-1, 1, time, 1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef frogPosition(n, edges, time, target):\\n    T = collections.defaultdict(set)\\n    for u, v in edges:\\n        T[u].add(v)\\n        T[v].add(u)\\n\\n    def dfs(x, y, t, p):\\n        if t < 0:\\n            return 0\\n        zs = [z for z in T[y] if z != x]\\n        if y == target:\\n            return 0 if (t and zs) else p\\n        q = 1 / len(zs)\\n        return sum(dfs(y, z, t-1, p*q) for z in zs)\\n\\n    return dfs(-1, 1, time, 1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1324265,
                "title": "java-bfs-t-c-o-n-s-c-o-n",
                "content": "\\n    class Pair {\\n\\n\\t\\tint curr;\\n\\t\\tint time;\\n\\t\\tdouble prob;\\n\\n\\t\\tpublic Pair(int curr, int time, double prob) {\\n\\t\\t\\tthis.curr = curr;\\n\\t\\t\\tthis.time = time;\\n\\t\\t\\tthis.prob = prob;\\n\\t\\t}\\n\\t}\\n\\n\\t// BFS\\n\\t// O(n) O(n)\\n\\tpublic double frogPosition(int n, int[][] edges, int t, int target) {\\n\\n\\t\\tList<Integer>[] tree = new ArrayList[n + 1];\\n\\t\\tfor (int i = 0; i <= n; i++)\\n\\t\\t\\ttree[i] = new ArrayList<>();\\n\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\ttree[edge[0]].add(edge[1]);\\n\\t\\t\\ttree[edge[1]].add(edge[0]);\\n\\t\\t}\\n\\n\\t\\tboolean[] visited = new boolean[n + 1];\\n\\t\\tvisited[0] = true;\\n\\t\\tvisited[1] = true;\\n\\t\\ttree[1].add(0);\\n\\n\\t\\tQueue<Pair> queue = new LinkedList<>();\\n\\t\\tqueue.offer(new Pair(1, 0, 1d));\\n\\n\\t\\twhile (!queue.isEmpty()) {\\n\\n\\t\\t\\tPair temp = queue.remove();\\n\\t\\t\\tint curr = temp.curr, time = temp.time;\\n\\t\\t\\tdouble prob = temp.prob;\\n\\n\\t\\t\\tif (curr == target) {\\n\\n\\t\\t\\t\\tif (time == t)\\n\\t\\t\\t\\t\\treturn prob;\\n\\t\\t\\t\\telse if (time > t)\\n\\t\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t\\tList<Integer> nbrs = tree[curr];\\n\\t\\t\\t\\tboolean flag = false;\\n\\t\\t\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\t\\t\\tif (!visited[nbr])\\n\\t\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn (flag) ? 0 : prob;\\n\\t\\t\\t}\\n\\n\\t\\t\\tList<Integer> nbrs = tree[curr];\\n\\t\\t\\tdouble size = nbrs.size() - 1;\\n\\t\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\t\\tif (!visited[nbr]) {\\n\\t\\t\\t\\t\\tvisited[nbr] = true;\\n\\t\\t\\t\\t\\tqueue.offer(new Pair(nbr, time + 1, prob * (1 / size)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "solutionTags": [],
                "code": "\\n    class Pair {\\n\\n\\t\\tint curr;\\n\\t\\tint time;\\n\\t\\tdouble prob;\\n\\n\\t\\tpublic Pair(int curr, int time, double prob) {\\n\\t\\t\\tthis.curr = curr;\\n\\t\\t\\tthis.time = time;\\n\\t\\t\\tthis.prob = prob;\\n\\t\\t}\\n\\t}\\n\\n\\t// BFS\\n\\t// O(n) O(n)\\n\\tpublic double frogPosition(int n, int[][] edges, int t, int target) {\\n\\n\\t\\tList<Integer>[] tree = new ArrayList[n + 1];\\n\\t\\tfor (int i = 0; i <= n; i++)\\n\\t\\t\\ttree[i] = new ArrayList<>();\\n\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\ttree[edge[0]].add(edge[1]);\\n\\t\\t\\ttree[edge[1]].add(edge[0]);\\n\\t\\t}\\n\\n\\t\\tboolean[] visited = new boolean[n + 1];\\n\\t\\tvisited[0] = true;\\n\\t\\tvisited[1] = true;\\n\\t\\ttree[1].add(0);\\n\\n\\t\\tQueue<Pair> queue = new LinkedList<>();\\n\\t\\tqueue.offer(new Pair(1, 0, 1d));\\n\\n\\t\\twhile (!queue.isEmpty()) {\\n\\n\\t\\t\\tPair temp = queue.remove();\\n\\t\\t\\tint curr = temp.curr, time = temp.time;\\n\\t\\t\\tdouble prob = temp.prob;\\n\\n\\t\\t\\tif (curr == target) {\\n\\n\\t\\t\\t\\tif (time == t)\\n\\t\\t\\t\\t\\treturn prob;\\n\\t\\t\\t\\telse if (time > t)\\n\\t\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\t\\tList<Integer> nbrs = tree[curr];\\n\\t\\t\\t\\tboolean flag = false;\\n\\t\\t\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\t\\t\\tif (!visited[nbr])\\n\\t\\t\\t\\t\\t\\tflag = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn (flag) ? 0 : prob;\\n\\t\\t\\t}\\n\\n\\t\\t\\tList<Integer> nbrs = tree[curr];\\n\\t\\t\\tdouble size = nbrs.size() - 1;\\n\\t\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\t\\tif (!visited[nbr]) {\\n\\t\\t\\t\\t\\tvisited[nbr] = true;\\n\\t\\t\\t\\t\\tqueue.offer(new Pair(nbr, time + 1, prob * (1 / size)));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn -1;\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 610570,
                "title": "clean-java-dfs",
                "content": "```\\npublic double frogPosition(int n, int[][] edges, int t, int target) {\\n\\n        // If no edges present\\n        if(edges==null || edges.length==0) {\\n            return 1.0;\\n        }\\n\\n        // If target is one and time>0 then the frog has to jump.\\n        if(target==1) {\\n            return t==0?1.0:0.0;\\n        }\\n        // Storing neighbours\\n        Set<Integer>[] arr = new Set[n+1];\\n        for (int i=0;i<=n;i++) {\\n            arr[i] = new HashSet<>();\\n        }\\n        for (int[] edge : edges) {\\n            arr[edge[0]].add(edge[1]);\\n            arr[edge[1]].add(edge[0]);\\n        }\\n        //visited array.\\n        boolean[] visited = new boolean[n+1];\\n        return util(arr,t,target,visited,1,1);\\n\\n    }\\n\\n    private double util(Set<Integer>[] arr,int time,int target,boolean[] visited,int start,int fraction) {\\n\\n        visited[start]=true;\\n        // If time is less than zero than we can\\'t reach.\\n        if(time<=0) {\\n            return 0.0;\\n        }\\n\\n        int childCount = countUnvisitedNeighbours(visited,start,arr); // Unvisited children of the start value.\\n        if(arr[start].contains(target)) { // Check if the current parent contains child\\n            int targetNeighbours = countUnvisitedNeighbours(visited,target,arr);\\n            // If  Neighbours of target value are yet to be visited \\n\\t\\t\\t// and time>1 then the frog will have to jump, hence can\\'t be at target at time \"t\".\\n            if(targetNeighbours>=1 && time>1) {\\n                return 0.0;\\n            }\\n            int x = childCount*fraction;\\n            return (double)1/(double)x;\\n        }\\n        double val = 0.0;\\n        for (int child : arr[start]) {\\n            if(!visited[child]) {\\n                val = util(arr,time-1,target,visited,child,childCount*fraction); // Multiply fraction every time.\\n                if(val>0) {\\n                    return val;\\n                }\\n            }\\n        }\\n        return val;\\n    }\\n\\n    // Counts unvisited children for any given node.\\n    private int countUnvisitedNeighbours(boolean[] visited,int start,Set<Integer>[] arr) {\\n        int count = arr[start].size();\\n        for (int child : arr[start]) {\\n            if(visited[child]) {\\n                count--;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic double frogPosition(int n, int[][] edges, int t, int target) {\\n\\n        // If no edges present\\n        if(edges==null || edges.length==0) {\\n            return 1.0;\\n        }\\n\\n        // If target is one and time>0 then the frog has to jump.\\n        if(target==1) {\\n            return t==0?1.0:0.0;\\n        }\\n        // Storing neighbours\\n        Set<Integer>[] arr = new Set[n+1];\\n        for (int i=0;i<=n;i++) {\\n            arr[i] = new HashSet<>();\\n        }\\n        for (int[] edge : edges) {\\n            arr[edge[0]].add(edge[1]);\\n            arr[edge[1]].add(edge[0]);\\n        }\\n        //visited array.\\n        boolean[] visited = new boolean[n+1];\\n        return util(arr,t,target,visited,1,1);\\n\\n    }\\n\\n    private double util(Set<Integer>[] arr,int time,int target,boolean[] visited,int start,int fraction) {\\n\\n        visited[start]=true;\\n        // If time is less than zero than we can\\'t reach.\\n        if(time<=0) {\\n            return 0.0;\\n        }\\n\\n        int childCount = countUnvisitedNeighbours(visited,start,arr); // Unvisited children of the start value.\\n        if(arr[start].contains(target)) { // Check if the current parent contains child\\n            int targetNeighbours = countUnvisitedNeighbours(visited,target,arr);\\n            // If  Neighbours of target value are yet to be visited \\n\\t\\t\\t// and time>1 then the frog will have to jump, hence can\\'t be at target at time \"t\".\\n            if(targetNeighbours>=1 && time>1) {\\n                return 0.0;\\n            }\\n            int x = childCount*fraction;\\n            return (double)1/(double)x;\\n        }\\n        double val = 0.0;\\n        for (int child : arr[start]) {\\n            if(!visited[child]) {\\n                val = util(arr,time-1,target,visited,child,childCount*fraction); // Multiply fraction every time.\\n                if(val>0) {\\n                    return val;\\n                }\\n            }\\n        }\\n        return val;\\n    }\\n\\n    // Counts unvisited children for any given node.\\n    private int countUnvisitedNeighbours(boolean[] visited,int start,Set<Integer>[] arr) {\\n        int count = arr[start].size();\\n        for (int child : arr[start]) {\\n            if(visited[child]) {\\n                count--;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532650,
                "title": "c-python3-traverse-the-tree-to-calculate-prob",
                "content": "A frog is jumping on a tree. It starts from vertex 1 and jumps to a child of its current vertex with equal probability each second. If the vertex has no more children, then the frog stays on the vertex. What is the probablity that after `t` seconds, the frog is on vertex `target`?\\n\\n# Explanation\\n\\nJust use BFS or DFS to calculate the time and probablity.\\n\\n# C++ Solution\\n\\n```cpp\\nclass Solution {\\n    int t, target;\\n    double ans;\\n    vector<vector<int>> g;\\n    \\n    void dfs(int u, int fa, int time, int invert) {\\n        int childSize = 0;\\n        for (int v: g[u])\\n            if (v != fa)\\n                childSize++;\\n        \\n        if (u == target) {\\n            if (time == t || time < t && childSize == 0)\\n                ans = 1.0 / invert;\\n            else\\n                ans = 0.0;\\n            return;\\n        }\\n        \\n        for (int v: g[u])\\n            if (v != fa)\\n                dfs(v, u, time + 1, invert * childSize);\\n    }\\n    \\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        this->t = t;\\n        this->target = target;\\n        g = vector<vector<int>>(n+1, vector<int>());\\n        for (int i = 0; i < edges.size(); i++) {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        dfs(1, -1, 0, 1);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Python3 Solution\\n\\n```python\\nclass Solution:\\n    def dfs(self, u: int, fa: int, time: int, invert: int):\\n        childSize = 0\\n        for v in self.g[u]:\\n            if v != fa:\\n                childSize += 1\\n        if u == self.target:\\n            if time == self.t or time < self.t and childSize == 0:\\n                self.ans = 1 / invert\\n            else:\\n                self.ans = 0.0\\n            return\\n        for v in self.g[u]:\\n            if v != fa:\\n                self.dfs(v, u, time + 1, invert * childSize)\\n    \\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        self.t = t\\n        self.target = target\\n        self.g = [[] for i in range(n + 1)]\\n        for e in edges:\\n            self.g[e[0]].append(e[1])\\n            self.g[e[1]].append(e[0])\\n        self.dfs(1, -1, 0, 1)\\n        return self.ans\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\n    int t, target;\\n    double ans;\\n    vector<vector<int>> g;\\n    \\n    void dfs(int u, int fa, int time, int invert) {\\n        int childSize = 0;\\n        for (int v: g[u])\\n            if (v != fa)\\n                childSize++;\\n        \\n        if (u == target) {\\n            if (time == t || time < t && childSize == 0)\\n                ans = 1.0 / invert;\\n            else\\n                ans = 0.0;\\n            return;\\n        }\\n        \\n        for (int v: g[u])\\n            if (v != fa)\\n                dfs(v, u, time + 1, invert * childSize);\\n    }\\n    \\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        this->t = t;\\n        this->target = target;\\n        g = vector<vector<int>>(n+1, vector<int>());\\n        for (int i = 0; i < edges.size(); i++) {\\n            g[edges[i][0]].push_back(edges[i][1]);\\n            g[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        dfs(1, -1, 0, 1);\\n        return ans;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def dfs(self, u: int, fa: int, time: int, invert: int):\\n        childSize = 0\\n        for v in self.g[u]:\\n            if v != fa:\\n                childSize += 1\\n        if u == self.target:\\n            if time == self.t or time < self.t and childSize == 0:\\n                self.ans = 1 / invert\\n            else:\\n                self.ans = 0.0\\n            return\\n        for v in self.g[u]:\\n            if v != fa:\\n                self.dfs(v, u, time + 1, invert * childSize)\\n    \\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        self.t = t\\n        self.target = target\\n        self.g = [[] for i in range(n + 1)]\\n        for e in edges:\\n            self.g[e[0]].append(e[1])\\n            self.g[e[1]].append(e[0])\\n        self.dfs(1, -1, 0, 1)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3675735,
                "title": "simple-python-solution-using-bfs",
                "content": "\\n# Code\\n```\\nfrom queue import Queue\\n\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if edges == []:\\n            if target == 1:return 1\\n            return 0\\n\\n        d = {}\\n        for i in edges:\\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\\n        \\n        visit = [0]*(n+1)\\n\\n        q = Queue()     \\n        q.put([1 , 1])\\n\\n        for dur in range(t):\\n            \\n            l = q.qsize()\\n            for i in range(l):\\n                temp = q.get()\\n\\n                # Count no.of non-visited nodes\\n                count = 0\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: count += 1\\n            \\n                if temp[0] == target and count == 0:     \\n                    # If the target is reached and if its the end node\\n                    return temp[1]\\n                \\n                if visit[temp[0]] != 0:    # if already visited\\n                    continue\\n                \\n                visit[temp[0]] = 1\\n\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\\n                \\n        \\n        l = q.qsize()\\n        for i in range(l):\\n            temp = q.get()\\n            if temp[0] == target:\\n                return temp[1]\\n\\n        return 0\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nfrom queue import Queue\\n\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if edges == []:\\n            if target == 1:return 1\\n            return 0\\n\\n        d = {}\\n        for i in edges:\\n            d[i[0]] = d.get(i[0] , []) + [i[1]]\\n            d[i[1]] = d.get(i[1] , []) + [i[0]]\\n        \\n        visit = [0]*(n+1)\\n\\n        q = Queue()     \\n        q.put([1 , 1])\\n\\n        for dur in range(t):\\n            \\n            l = q.qsize()\\n            for i in range(l):\\n                temp = q.get()\\n\\n                # Count no.of non-visited nodes\\n                count = 0\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: count += 1\\n            \\n                if temp[0] == target and count == 0:     \\n                    # If the target is reached and if its the end node\\n                    return temp[1]\\n                \\n                if visit[temp[0]] != 0:    # if already visited\\n                    continue\\n                \\n                visit[temp[0]] = 1\\n\\n                for ele in d[temp[0]]:\\n                    if visit[ele] == 0: q.put([ele , temp[1]*(1/count)])\\n                \\n        \\n        l = q.qsize()\\n        for i in range(l):\\n            temp = q.get()\\n            if temp[0] == target:\\n                return temp[1]\\n\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060626,
                "title": "i-made-it-complicated",
                "content": "\\n    class pair{\\n    int node;\\n    double prob;\\n    pair(int node1,double prob1){\\n        node=node1;\\n        prob=prob1;\\n    }\\n}\\n\\n    class Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        if(edges.length==0)return 1.0; //edge case\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<=n;i++){\\n            adj.add(new ArrayList<>());\\n        }\\n        // checking whether leaf node or not\\n        int leaf[]=new int[n+1];\\n        for(int p[]:edges){\\n            int u=p[0];\\n            int v=p[1];\\n            // as there is undirected edge\\n            adj.get(u).add(v);\\n            adj.get(v).add(u);\\n           \\n            leaf[u]++;\\n            leaf[v]++;\\n            \\n        }\\n        //whether the node is visited or not as frog will not go visited node again\\n        boolean vis[]=new boolean[n+1]; \\n        Queue<pair> q=new LinkedList<>();\\n       \\n        // initially prob is 1\\n        q.add(new pair(1,1.0));\\n        \\n        if(target==1 && t>1 && n>1)return 0.0;// as the frog will not wait and 1 is not leaf node\\n        \\n        vis[1]=true;\\n        int lvl=-1;\\n        while(!q.isEmpty()){\\n            lvl++;\\n            int size=q.size();\\n            Map<Integer,Double> m=new HashMap<>();\\n            while(size-->0){\\n                pair it=q.poll();\\n                int node=it.node;\\n                double prob=it.prob;\\n               \\n                // if target is found\\n                if(node==target){\\n                    // if given lvl is greater than current then if it is leaf ans will be the prob else 0\\n                    if(lvl<t){\\n                        if(leaf[node]==1)return prob;\\n                        else return 0.0;\\n                    }\\n                    else return prob;\\n                }\\n                // if lvl is eqaul given level then putting all node and prob in a map to check \\n                //whether node is equal target\\n               else if(lvl==t){\\n                   m.put(node,prob);\\n               }\\n                \\n                \\n                int y=0;\\n                // counting the not visited node for prob calc\\n                for(int it1:adj.get(node)){\\n                    if(!vis[it1])y++;\\n                }\\n                \\n                for(int it1:adj.get(node)){\\n                    if(!vis[it1]){\\n                        q.add(new pair(it1,prob/y));\\n                        vis[it1]=true;\\n                    }\\n                }\\n            }\\n            // checking whether node is equal target\\n            if(!m.isEmpty()){\\n            if(m.containsKey(target))return m.get(target);\\n            else return 0.0;\\n            }\\n        }\\n        return 1.0;\\n    }\\n}",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "class Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        if(edges.length==0)return 1.0; //edge case\\n        List<List<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<=n;i++){\\n            adj.add(new ArrayList<>());\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1853833,
                "title": "simple-dfs-c",
                "content": "Note that probability is 0 if after reaching the target there are options available to move ans time is still remaining. \\n```c++\\nclass Solution {\\npublic:\\n    int tmax, tgt;\\n    double prob;\\n    vector<vector<int>> adj; // for adj list\\n    void dfs(int s, int k, int anc, double p){\\n        if(s == tgt && (k == tmax || adj[s].size() == 1)) {\\n            prob = p;\\n            return;\\n        }\\n        if(k == tmax) return;\\n        int nmbr = adj[s].size() - 1;\\n        for(auto &&i: adj[s]){\\n            if(i != anc) dfs(i, k+1, s, p/nmbr);\\n        }\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        adj.resize(n+1);\\n        tmax = t;\\n        tgt = target;\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        adj[1].push_back(0);\\n        dfs(1, 0, 0, (double)1);\\n        return prob;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int tmax, tgt;\\n    double prob;\\n    vector<vector<int>> adj; // for adj list\\n    void dfs(int s, int k, int anc, double p){\\n        if(s == tgt && (k == tmax || adj[s].size() == 1)) {\\n            prob = p;\\n            return;\\n        }\\n        if(k == tmax) return;\\n        int nmbr = adj[s].size() - 1;\\n        for(auto &&i: adj[s]){\\n            if(i != anc) dfs(i, k+1, s, p/nmbr);\\n        }\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        adj.resize(n+1);\\n        tmax = t;\\n        tgt = target;\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        adj[1].push_back(0);\\n        dfs(1, 0, 0, (double)1);\\n        return prob;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753365,
                "title": "c-simple-dfs",
                "content": "```\\n    vector<vector<int>> g;\\n    vector<int> vis;\\n    double dfs(int i,int t,int target){\\n        if(i!=1 && t>=0 && target==i && g[i].size()==1) return 1;    \\n        if(t==0&&target==i) return 1;                                       //base cases\\n        if(t<=0) return 0;\\n        \\n        vis[i]=1;\\n        int n=g[i].size();\\n        if(i==1) n++;       //only for root node\\n        for(auto nbr:g[i]){\\n            if(vis[nbr]==0){\\n                double ans=dfs(nbr,t-1,target);                  //post-order\\n                if(ans!=0.0){\\n                    return (double(1)/double(n-1))*ans;\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n         if(edges.size()==0) return 1.0;\\n        g=vector<vector<int>>(n+1);\\n        vis=vector<int>(n+1);\\n        for(auto i:edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        double ans = dfs(1,t,target);\\n         \\n        if(ans!=0.0) return ans;\\n        return 0.0;\\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n    vector<vector<int>> g;\\n    vector<int> vis;\\n    double dfs(int i,int t,int target){\\n        if(i!=1 && t>=0 && target==i && g[i].size()==1) return 1;    \\n        if(t==0&&target==i) return 1;                                       //base cases\\n        if(t<=0) return 0;\\n        \\n        vis[i]=1;\\n        int n=g[i].size();\\n        if(i==1) n++;       //only for root node\\n        for(auto nbr:g[i]){\\n            if(vis[nbr]==0){\\n                double ans=dfs(nbr,t-1,target);                  //post-order\\n                if(ans!=0.0){\\n                    return (double(1)/double(n-1))*ans;\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n         if(edges.size()==0) return 1.0;\\n        g=vector<vector<int>>(n+1);\\n        vis=vector<int>(n+1);\\n        for(auto i:edges){\\n            g[i[0]].push_back(i[1]);\\n            g[i[1]].push_back(i[0]);\\n        }\\n        double ans = dfs(1,t,target);\\n         \\n        if(ans!=0.0) return ans;\\n        return 0.0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1380976,
                "title": "python3-straightforward-bfs-using-dictionary-and-set",
                "content": "class Solution:\\n\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        graph=defaultdict(list)\\n        visited=set()\\n        \\n        for edge in edges:\\n            source,destination=edge[0],edge[1]\\n            graph[source].append(destination)\\n            graph[destination].append(source)\\n   \\n        queue=[[1,0,1.0]] #[node,time,probability]\\n        \\n        while len(queue)>0:\\n            current=queue.pop(0)\\n            node,time,p=current\\n            visited.add(node)\\n                   \\n            count=0   #counting number of unvisited nodes in graph[node] \\n            for nodes in graph[node]:\\n                if nodes not in visited:\\n                    count+=1\\n\\n            if node==target:\\n                if time==t or (time<t and count==0):\\n                    return p\\n                return 0\\n            \\n            if count>0:\\n                Time=time+1\\n                P=p/count\\n                for nodes in graph[node]:\\n                    if nodes not in visited:\\n                        queue.append([nodes,Time,P])\\n                        \\n        return 0",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        graph=defaultdict(list)\\n        visited=set()\\n        \\n        for edge in edges:\\n            source,destination=edge[0],edge[1]\\n            graph[source].append(destination)\\n            graph[destination].append(source)\\n   \\n        queue=[[1,0,1.0]] #[node,time,probability]\\n        \\n        while len(queue)>0:\\n            current=queue.pop(0)\\n            node,time,p=current\\n            visited.add(node)\\n                   \\n            count=0   #counting number of unvisited nodes in graph[node] \\n            for nodes in graph[node]:\\n                if nodes not in visited:\\n                    count+=1\\n\\n            if node==target:\\n                if time==t or (time<t and count==0):\\n                    return p\\n                return 0\\n            \\n            if count>0:\\n                Time=time+1\\n                P=p/count\\n                for nodes in graph[node]:\\n                    if nodes not in visited:\\n                        queue.append([nodes,Time,P])\\n                        \\n        return 0",
                "codeTag": "Java"
            },
            {
                "id": 1324202,
                "title": "java-dfs-2ms-beats-98-25-t-c-o-n-s-c-o-n",
                "content": "\\n    // DFS\\n\\t// O(n) O(n)\\n\\tpublic static double frogPosition(int n, int[][] edges, int t, int target) {\\n\\n\\t\\tList<Integer>[] tree = new ArrayList[n + 1];\\n\\t\\tfor (int i = 0; i <= n; i++)\\n\\t\\t\\ttree[i] = new ArrayList<>();\\n\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\ttree[edge[0]].add(edge[1]);\\n\\t\\t\\ttree[edge[1]].add(edge[0]);\\n\\t\\t}\\n\\n\\t\\tboolean[] visited = new boolean[n + 1];\\n\\t\\tvisited[0] = true;\\n\\t\\ttree[1].add(0);\\n\\t\\treturn frogPositionHelper(1, tree, t, target, 1.0, 0, visited);\\n\\t}\\n\\n\\t// DFS\\n\\t// O(n) O(n)\\n\\tpublic static double frogPositionHelper(int curr, List<Integer>[] tree, int t, int target, double prob, int time,\\n\\t\\t\\tboolean[] visited) {\\n\\n\\t\\tvisited[curr] = true;\\n\\n\\t\\tif (curr == target) {\\n\\n\\t\\t\\tif (time == t)\\n\\t\\t\\t\\treturn prob;\\n\\t\\t\\tif (time > t)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tList<Integer> nbrs = tree[curr];\\n\\t\\t\\tboolean flag = false;\\n\\t\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\t\\tif (!visited[nbr]){\\n\\t\\t\\t\\t\\tflag = true;\\n                    break;\\n                }\\n\\t\\t\\t}\\n\\t\\t\\treturn (flag) ? 0 : prob;\\n\\t\\t}\\n\\n\\t\\tList<Integer> nbrs = tree[curr];\\n\\t\\tdouble ans = Double.MAX_VALUE, size = nbrs.size() - 1;\\n\\n\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\tif (!visited[nbr]) {\\n\\t\\t\\t\\tdouble temp = frogPositionHelper(nbr, tree, t, target, prob * (1 / size), time + 1, visited);\\n\\t\\t\\t\\tif (temp < ans)\\n\\t\\t\\t\\t\\tans = temp;\\n                if(ans != Double.MAX_VALUE)\\n                    return ans;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    // DFS\\n\\t// O(n) O(n)\\n\\tpublic static double frogPosition(int n, int[][] edges, int t, int target) {\\n\\n\\t\\tList<Integer>[] tree = new ArrayList[n + 1];\\n\\t\\tfor (int i = 0; i <= n; i++)\\n\\t\\t\\ttree[i] = new ArrayList<>();\\n\\n\\t\\tfor (int[] edge : edges) {\\n\\t\\t\\ttree[edge[0]].add(edge[1]);\\n\\t\\t\\ttree[edge[1]].add(edge[0]);\\n\\t\\t}\\n\\n\\t\\tboolean[] visited = new boolean[n + 1];\\n\\t\\tvisited[0] = true;\\n\\t\\ttree[1].add(0);\\n\\t\\treturn frogPositionHelper(1, tree, t, target, 1.0, 0, visited);\\n\\t}\\n\\n\\t// DFS\\n\\t// O(n) O(n)\\n\\tpublic static double frogPositionHelper(int curr, List<Integer>[] tree, int t, int target, double prob, int time,\\n\\t\\t\\tboolean[] visited) {\\n\\n\\t\\tvisited[curr] = true;\\n\\n\\t\\tif (curr == target) {\\n\\n\\t\\t\\tif (time == t)\\n\\t\\t\\t\\treturn prob;\\n\\t\\t\\tif (time > t)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tList<Integer> nbrs = tree[curr];\\n\\t\\t\\tboolean flag = false;\\n\\t\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\t\\tif (!visited[nbr]){\\n\\t\\t\\t\\t\\tflag = true;\\n                    break;\\n                }\\n\\t\\t\\t}\\n\\t\\t\\treturn (flag) ? 0 : prob;\\n\\t\\t}\\n\\n\\t\\tList<Integer> nbrs = tree[curr];\\n\\t\\tdouble ans = Double.MAX_VALUE, size = nbrs.size() - 1;\\n\\n\\t\\tfor (int nbr : nbrs) {\\n\\t\\t\\tif (!visited[nbr]) {\\n\\t\\t\\t\\tdouble temp = frogPositionHelper(nbr, tree, t, target, prob * (1 / size), time + 1, visited);\\n\\t\\t\\t\\tif (temp < ans)\\n\\t\\t\\t\\t\\tans = temp;\\n                if(ans != Double.MAX_VALUE)\\n                    return ans;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1234031,
                "title": "c-simple-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) \\n    {\\n        vector<vector<int>>mat(n+1);\\n        for(auto e:edges)\\n        {\\n            mat[e[0]].push_back(e[1]);\\n            mat[e[1]].push_back(e[0]);\\n        }\\n        int time=0;\\n        vector<bool>vis(n+1,false);\\n        vis[1]=true;\\n        queue<pair<int,double>>q;q.push({1,1.0});\\n        while(!q.empty() && time<=t)\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int i=q.front().first;\\n                double p=q.front().second;q.pop();\\n                if(time==t && i==target)\\n                {\\n                    return p;\\n                }\\n                double unvisited=0.0;\\n                for(auto e:mat[i])\\n                    if(!vis[e])\\n                        unvisited+=1.0;\\n                if(time<t && i==target)\\n                {\\n                    if(unvisited==0.0)\\n                        return p;\\n                    return 0.0;\\n                }\\n                for(auto e:mat[i])\\n                {\\n                    if(!vis[e])\\n                    {\\n                        vis[e]=true;\\n                        q.push({e,p/unvisited});\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return 0.0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) \\n    {\\n        vector<vector<int>>mat(n+1);\\n        for(auto e:edges)\\n        {\\n            mat[e[0]].push_back(e[1]);\\n            mat[e[1]].push_back(e[0]);\\n        }\\n        int time=0;\\n        vector<bool>vis(n+1,false);\\n        vis[1]=true;\\n        queue<pair<int,double>>q;q.push({1,1.0});\\n        while(!q.empty() && time<=t)\\n        {\\n            int size=q.size();\\n            while(size--)\\n            {\\n                int i=q.front().first;\\n                double p=q.front().second;q.pop();\\n                if(time==t && i==target)\\n                {\\n                    return p;\\n                }\\n                double unvisited=0.0;\\n                for(auto e:mat[i])\\n                    if(!vis[e])\\n                        unvisited+=1.0;\\n                if(time<t && i==target)\\n                {\\n                    if(unvisited==0.0)\\n                        return p;\\n                    return 0.0;\\n                }\\n                for(auto e:mat[i])\\n                {\\n                    if(!vis[e])\\n                    {\\n                        vis[e]=true;\\n                        q.push({e,p/unvisited});\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return 0.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788811,
                "title": "python-frog-clones-with-notes",
                "content": "```python\\ndef frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n\\n\\t# 1. Start frog at the vertex at time t=0\\n\\t#\\n\\t# 2. Progress the frog along the tree\\n\\t#\\n\\t#    i.  At any split, clone the frog to explore all children nodes\\n\\t#    ii. When the frog is split pass on the frog probability as\\n\\t#        an atribute of the frog\\n\\t#\\n\\t#           two way split: 1 -> 0.5 and 0.5\\n\\t#           three way split 0.5 -> 0.166, 0.166, 0.166\\n\\t#\\n\\t# 3. At time t, if a frog is on the target, return the probability\\n\\t#    of that frog.  If - somehow - multiple frogs are on the target\\n\\t#    sum up their probabilites.  (this never happens, there are no cycles)\\n\\t#\\n\\t#    And of course, if no frog is on the target, return 0.  Since there\\n\\t#    are no cycles, you can return 0 as soon as a frog passes the target.\\n\\n\\n\\tg = {-1 : [1], 1 : [-1]} #initialize map with dummy node -1 so all nodes have a parent (this helps when calculating probabilites)\\n\\tfor a,b in edges:\\n\\t\\tg[a] = g.get(a, []) + [b]\\n\\t\\tg[b] = g.get(b, []) + [a]\\n\\n\\n\\tdef helper(node, parent, time):\\n\\t\\tnonlocal frog_army, g, t, target, probability\\n\\n\\t\\tif probability: return None\\n\\n\\t\\tif (g[node] == [parent]) or (time == t):\\n\\t\\t\\tif node == target:\\n\\t\\t\\t\\tprobability = frog_army[node]\\n\\t\\t\\treturn None\\n\\n\\t\\tp = frog_army[node]\\n\\t\\tfor child in g[node]:\\n\\t\\t\\tif child != parent:\\n\\t\\t\\t\\tfrog_army[child] = p/(len(g[node])-1) # minus 1 because moving to parent node is not an option\\n\\t\\t\\t\\thelper(child, node, time+1)\\n\\n\\tprobability = 0\\n\\tfrog_army = {1 : 1} # frog is at node 1 : probability 100%\\n\\thelper(1, -1, 0)\\n\\n\\treturn probability\\n```\\n<img src=\"https://assets.leetcode.com/users/images/2fcee6d3-b66a-4915-b2a1-3b7946a41de4_1597290383.850585.png\" width=\"50%\">\\n",
                "solutionTags": [],
                "code": "```python\\ndef frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n\\n\\t# 1. Start frog at the vertex at time t=0\\n\\t#\\n\\t# 2. Progress the frog along the tree\\n\\t#\\n\\t#    i.  At any split, clone the frog to explore all children nodes\\n\\t#    ii. When the frog is split pass on the frog probability as\\n\\t#        an atribute of the frog\\n\\t#\\n\\t#           two way split: 1 -> 0.5 and 0.5\\n\\t#           three way split 0.5 -> 0.166, 0.166, 0.166\\n\\t#\\n\\t# 3. At time t, if a frog is on the target, return the probability\\n\\t#    of that frog.  If - somehow - multiple frogs are on the target\\n\\t#    sum up their probabilites.  (this never happens, there are no cycles)\\n\\t#\\n\\t#    And of course, if no frog is on the target, return 0.  Since there\\n\\t#    are no cycles, you can return 0 as soon as a frog passes the target.\\n\\n\\n\\tg = {-1 : [1], 1 : [-1]} #initialize map with dummy node -1 so all nodes have a parent (this helps when calculating probabilites)\\n\\tfor a,b in edges:\\n\\t\\tg[a] = g.get(a, []) + [b]\\n\\t\\tg[b] = g.get(b, []) + [a]\\n\\n\\n\\tdef helper(node, parent, time):\\n\\t\\tnonlocal frog_army, g, t, target, probability\\n\\n\\t\\tif probability: return None\\n\\n\\t\\tif (g[node] == [parent]) or (time == t):\\n\\t\\t\\tif node == target:\\n\\t\\t\\t\\tprobability = frog_army[node]\\n\\t\\t\\treturn None\\n\\n\\t\\tp = frog_army[node]\\n\\t\\tfor child in g[node]:\\n\\t\\t\\tif child != parent:\\n\\t\\t\\t\\tfrog_army[child] = p/(len(g[node])-1) # minus 1 because moving to parent node is not an option\\n\\t\\t\\t\\thelper(child, node, time+1)\\n\\n\\tprobability = 0\\n\\tfrog_army = {1 : 1} # frog is at node 1 : probability 100%\\n\\thelper(1, -1, 0)\\n\\n\\treturn probability\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 533944,
                "title": "c-faster-than-99-32-people-easy-to-understand",
                "content": "Since we are working on a tree, we can only go from a node at a higher level(lower index) to a node at a lower level(higher index), that is why the swapping of the from and to index is done while forming the  adjacency list setup for our tree.\\nOnce the graph is constructed, we make a queue for storing the state that is being executed. The current state includes the current vertex, the time taken for reaching this vertex and the probability of reaching this vertex. First of all, we push the root vertex in the queue and iterate till either the queue becomes empty or we reach the target vertex.\\nWhile iterating, if we reach the target vertex, we check the condition for time and return the probability depending on time and the number of children of the target vertex. This is done because if we reach the target vertex and it has children with some time remaining, it would jump onto the next node and since this is a tree, there is no coming back and hence the probability of reaching back to the target would be 0.\\nHowever, if we haven\\'t yet reached the target, we iterate over all the child nodes and push them into the stack along with the updated time and probabilty.\\n\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<int>g[n+1];\\n        for(int i=0; i<edges.size(); ++i){\\n            int from = edges[i][0];\\n            int to = edges[i][1];\\n            if(from>to) swap(from,to);\\n            g[from].push_back(to);\\n        }\\n        \\n        queue<pair<int,pair<int,double>>>q;//<vertex,<time,probability>>\\n        q.push({1,{0,1.0}});\\n        while(!q.empty()){\\n            int v = q.front().first;\\n            int time = q.front().second.first;\\n            double p = q.front().second.second;\\n            q.pop();\\n            \\n            if(v == target){\\n                if(time==t || (time<t&&g[v].size()==0))\\n                    return p;\\n                return 0;\\n            }\\n            \\n            for(int i=0; i<g[v].size(); ++i){\\n                q.push({g[v][i],{time+1, 1.0*p/g[v].size()}});\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<int>g[n+1];\\n        for(int i=0; i<edges.size(); ++i){\\n            int from = edges[i][0];\\n            int to = edges[i][1];\\n            if(from>to) swap(from,to);\\n            g[from].push_back(to);\\n        }\\n        \\n        queue<pair<int,pair<int,double>>>q;//<vertex,<time,probability>>\\n        q.push({1,{0,1.0}});\\n        while(!q.empty()){\\n            int v = q.front().first;\\n            int time = q.front().second.first;\\n            double p = q.front().second.second;\\n            q.pop();\\n            \\n            if(v == target){\\n                if(time==t || (time<t&&g[v].size()==0))\\n                    return p;\\n                return 0;\\n            }\\n            \\n            for(int i=0; i<g[v].size(); ++i){\\n                q.push({g[v][i],{time+1, 1.0*p/g[v].size()}});\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532862,
                "title": "cpp-bfs-16ms",
                "content": "```\\nstruct Jump {\\n    int time;\\n    int index;\\n    double pro; // probability\\n    Jump(int i, int t, double p) : index(i), time(t), pro(p){}\\n};\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> tree(n + 1);\\n        vector pos(n + 1, -1);\\n        for (auto edge : edges) {\\n            tree[edge[0]].push_back(edge[1]);\\n            tree[edge[1]].push_back(edge[0]);\\n        }\\n        if (target == 1 && (t == 0 || n <= 2))\\n            return 1.0;\\n        \\n        queue<Jump> que;\\n        que.push(Jump(1, 0, 1));\\n        unordered_set<int> visited;\\n        while(!que.empty()) {\\n            auto cur = que.front();\\n            que.pop();\\n            if (t <= cur.time) {\\n                if (cur.index == target)\\n                    return cur.pro;\\n                continue;\\n            }\\n            visited.insert(cur.index);\\n            int size = tree[cur.index].size();\\n            if (cur.index != 1 && size > 1) // just decrease incoming edge(parent)\\n                size--;\\n            \\n            for (int i : tree[cur.index]) {\\n                if (visited.count(i) || t <= cur.time)) continue;\\n                \\n                double prob = cur.pro * 1 / (double) size;\\n                que.push(Jump(i, cur.time + 1, prob));\\n                if (tree[i].size() == 1 && i == target) { // if it has only has 1 edge [leaf]\\n                    return prob;\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nstruct Jump {\\n    int time;\\n    int index;\\n    double pro; // probability\\n    Jump(int i, int t, double p) : index(i), time(t), pro(p){}\\n};\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> tree(n + 1);\\n        vector pos(n + 1, -1);\\n        for (auto edge : edges) {\\n            tree[edge[0]].push_back(edge[1]);\\n            tree[edge[1]].push_back(edge[0]);\\n        }\\n        if (target == 1 && (t == 0 || n <= 2))\\n            return 1.0;\\n        \\n        queue<Jump> que;\\n        que.push(Jump(1, 0, 1));\\n        unordered_set<int> visited;\\n        while(!que.empty()) {\\n            auto cur = que.front();\\n            que.pop();\\n            if (t <= cur.time) {\\n                if (cur.index == target)\\n                    return cur.pro;\\n                continue;\\n            }\\n            visited.insert(cur.index);\\n            int size = tree[cur.index].size();\\n            if (cur.index != 1 && size > 1) // just decrease incoming edge(parent)\\n                size--;\\n            \\n            for (int i : tree[cur.index]) {\\n                if (visited.count(i) || t <= cur.time)) continue;\\n                \\n                double prob = cur.pro * 1 / (double) size;\\n                que.push(Jump(i, cur.time + 1, prob));\\n                if (tree[i].size() == 1 && i == target) { // if it has only has 1 edge [leaf]\\n                    return prob;\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532509,
                "title": "c-dfs",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> relations(n);\\n        \\n        for (const vector<int>& edge: edges) {\\n            relations[edge[0] - 1].push_back(edge[1] - 1);\\n            relations[edge[1] - 1].push_back(edge[0] - 1);\\n        }\\n        \\n        vector<int> visited(n);\\n        double ans(0.0);\\n        bool f(false);\\n\\n        function<void(int, int, double, bool&)> dfs = [&](int i, int time, double p, bool& found) {\\n            if (found) return;\\n            visited[i] = 1;\\n            \\n            if (time == t) {\\n                // case 1: we reach the target in time\\n                if (i == target - 1) {\\n                    found = true;\\n                    ans = p;\\n                }\\n                return;\\n            }\\n            // -1 except for the start position since we do not jump back\\n            double d(i ? relations[i].size() - 1 : relations[i].size());\\n            bool canJump(false);\\n            \\n            for (const int& nxt: relations[i]) {\\n                if (visited[nxt]) continue;\\n                canJump = true;\\n                dfs(nxt, time + 1, p / d, found);\\n                if (found) break;\\n            }\\n            // case 2: we cannot jump further and the end point is target\\n            if (!canJump && i == target - 1)\\n                ans = p;\\n        };\\n        \\n        dfs(0, 0, 1.0, f);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> relations(n);\\n        \\n        for (const vector<int>& edge: edges) {\\n            relations[edge[0] - 1].push_back(edge[1] - 1);\\n            relations[edge[1] - 1].push_back(edge[0] - 1);\\n        }\\n        \\n        vector<int> visited(n);\\n        double ans(0.0);\\n        bool f(false);\\n\\n        function<void(int, int, double, bool&)> dfs = [&](int i, int time, double p, bool& found) {\\n            if (found) return;\\n            visited[i] = 1;\\n            \\n            if (time == t) {\\n                // case 1: we reach the target in time\\n                if (i == target - 1) {\\n                    found = true;\\n                    ans = p;\\n                }\\n                return;\\n            }\\n            // -1 except for the start position since we do not jump back\\n            double d(i ? relations[i].size() - 1 : relations[i].size());\\n            bool canJump(false);\\n            \\n            for (const int& nxt: relations[i]) {\\n                if (visited[nxt]) continue;\\n                canJump = true;\\n                dfs(nxt, time + 1, p / d, found);\\n                if (found) break;\\n            }\\n            // case 2: we cannot jump further and the end point is target\\n            if (!canJump && i == target - 1)\\n                ans = p;\\n        };\\n        \\n        dfs(0, 0, 1.0, f);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532508,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public static double func(HashSet<Integer> visited, int curr, int[][] g, int target, int time, int t) {\\n        if(time == t) return curr == target ? 1 : 0;\\n        visited.add(curr);\\n        double prob = 0;\\n        boolean flag = false;\\n        int c = 0;\\n        for(int i = 1; i < g.length; i++) if(g[curr][i] == 1 && !visited.contains(i)) c++;\\n        for(int i = 1; i < g.length; i++) {\\n            if(g[curr][i] == 1 && !visited.contains(i)) {\\n                flag = true;\\n                prob += (func(visited, i, g, target, time + 1, t) / c);\\n            }\\n        }\\n        if(!flag) return curr == target ? 1 : 0;\\n        visited.remove(curr);\\n        return prob;\\n    }\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        int[][] g = new int[n + 1][n + 1];\\n        for(int i = 0; i < edges.length; i++) {\\n            int sv = edges[i][0], ev = edges[i][1];\\n            g[sv][ev] = 1;\\n            g[ev][sv] = 1;\\n        }\\n        return func(new HashSet<>(), 1, g, target, 0, t);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public static double func(HashSet<Integer> visited, int curr, int[][] g, int target, int time, int t) {\\n        if(time == t) return curr == target ? 1 : 0;\\n        visited.add(curr);\\n        double prob = 0;\\n        boolean flag = false;\\n        int c = 0;\\n        for(int i = 1; i < g.length; i++) if(g[curr][i] == 1 && !visited.contains(i)) c++;\\n        for(int i = 1; i < g.length; i++) {\\n            if(g[curr][i] == 1 && !visited.contains(i)) {\\n                flag = true;\\n                prob += (func(visited, i, g, target, time + 1, t) / c);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 532494,
                "title": "python-bfs",
                "content": "```\\nclass Solution(object):\\n    def frogPosition(self, n, edges, t, target):\\n        conn = collections.defaultdict(set)\\n        for u,v in edges:\\n            conn[u].add(v)\\n            conn[v].add(u)\\n        cur = {1:[[0,1]]}\\n        res = 0\\n        for _ in range(t):\\n            tmp = collections.defaultdict(list)\\n            for node in cur:\\n                for his,p in cur[node]:\\n                    flag = False\\n                    for nei in conn[node]:\\n                        if nei != his:\\n                            flag = True\\n                            new_his = node\\n                            new_p = 1/(len(conn[node])-1) * p\\n                            tmp[nei] += [[new_his,new_p]]\\n                    if not flag and node == target: return p\\n            cur = tmp\\n        for his,p in cur[target]: res += p\\n        return res\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def frogPosition(self, n, edges, t, target):\\n        conn = collections.defaultdict(set)\\n        for u,v in edges:\\n            conn[u].add(v)\\n            conn[v].add(u)\\n        cur = {1:[[0,1]]}\\n        res = 0\\n        for _ in range(t):\\n            tmp = collections.defaultdict(list)\\n            for node in cur:\\n                for his,p in cur[node]:\\n                    flag = False\\n                    for nei in conn[node]:\\n                        if nei != his:\\n                            flag = True\\n                            new_his = node\\n                            new_p = 1/(len(conn[node])-1) * p\\n                            tmp[nei] += [[new_his,new_p]]\\n                    if not flag and node == target: return p\\n            cur = tmp\\n        for his,p in cur[target]: res += p\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978060,
                "title": "c-tree-in-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(AdjencyList Size + 3n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<double> dp;\\n    vector<vector<int>> adj;\\n    vector<int> leaf,depth;\\n    int n,T,Tar;\\n\\n    void helper(int node,int time,int par,int dpt){\\n        if(time>T) return;\\n        if(dp[node] != -1.0) return;\\n        \\n        if(par==0){\\n            dp[node]=1;\\n        }\\n        else{\\n            if(adj[par].size()>1)\\n              dp[node]= (dp[par])/(double)(adj[par].size()-1);\\n            else\\n              dp[node]= dp[par];\\n        }\\n        depth[node]=dpt;\\n        for(auto ch : adj[node]){\\n            if(ch == par) continue;\\n                helper(ch,time +1,node,dpt+1);\\n        }\\n        if(adj[node].size()==1) leaf[node]=1;\\n    }\\n    double frogPosition(int N, vector<vector<int>>& edges, int t, int target) {\\n        n = N;\\n        T = t;\\n        Tar = target;\\n        adj.resize(n+1);\\n\\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        adj[1].push_back(0);\\n        dp.resize(n+1,-1.0);\\n        leaf.resize(n+1,0);\\n        depth.resize(n+1,0);\\n        helper(1,0,0,0);\\n        \\n        if(leaf[target]){\\n            if(t>=depth[target]){\\n                return dp[target];\\n            }\\n            else return 0.0;\\n        }\\n        else{\\n            if(t==depth[target]) return dp[target];\\n        }\\n\\n\\n        return 0.0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<double> dp;\\n    vector<vector<int>> adj;\\n    vector<int> leaf,depth;\\n    int n,T,Tar;\\n\\n    void helper(int node,int time,int par,int dpt){\\n        if(time>T) return;\\n        if(dp[node] != -1.0) return;\\n        \\n        if(par==0){\\n            dp[node]=1;\\n        }\\n        else{\\n            if(adj[par].size()>1)\\n              dp[node]= (dp[par])/(double)(adj[par].size()-1);\\n            else\\n              dp[node]= dp[par];\\n        }\\n        depth[node]=dpt;\\n        for(auto ch : adj[node]){\\n            if(ch == par) continue;\\n                helper(ch,time +1,node,dpt+1);\\n        }\\n        if(adj[node].size()==1) leaf[node]=1;\\n    }\\n    double frogPosition(int N, vector<vector<int>>& edges, int t, int target) {\\n        n = N;\\n        T = t;\\n        Tar = target;\\n        adj.resize(n+1);\\n\\n        for(auto e:edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        adj[1].push_back(0);\\n        dp.resize(n+1,-1.0);\\n        leaf.resize(n+1,0);\\n        depth.resize(n+1,0);\\n        helper(1,0,0,0);\\n        \\n        if(leaf[target]){\\n            if(t>=depth[target]){\\n                return dp[target];\\n            }\\n            else return 0.0;\\n        }\\n        else{\\n            if(t==depth[target]) return dp[target];\\n        }\\n\\n\\n        return 0.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565281,
                "title": "using-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int T, int target) {\\n        unordered_map<int,vector<int>>adj;\\n        for(auto e:edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n\\n        }\\n        vector<int>vis(n+1,0);\\n        queue<pair<double,int>>q;\\n        vis[1]++;\\n        q.push({1.00,1});\\n        int t=0;\\n        unordered_map<int,pair<double,int>>m;\\n        unordered_map<int,int>children;\\n        while(!q.empty())\\n        {\\n           int s=q.size();\\n           while(s>0)\\n           {\\n               int p=q.front().second;\\n               double prob=q.front().first;\\n               q.pop();\\n               s--;\\n              double c=0;\\n               unordered_map<int,int>x;\\n               for(auto e:adj[p])\\n               {\\n                   if(vis[e]==0)\\n                   {\\n                       c++;\\n                       x[e]++;\\n                       vis[e]++;\\n                   }\\n               }\\n               children[p]=c;\\n               m[p]={prob,t};\\n               if(c!=0)\\n               {\\n                   for(auto e:x)\\n                   {\\n                       \\n                       q.push({prob/c,e.first});\\n                   }\\n               }\\n            \\n           }\\n           t++;\\n        }\\n        if(m.count(target)>0)\\n        {\\n              if(m[target].second==T ||m[target].second<T  && children[target]==0)\\n              {\\n                  return(m[target].first);\\n              }\\n        }\\n        return(0);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int T, int target) {\\n        unordered_map<int,vector<int>>adj;\\n        for(auto e:edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n\\n        }\\n        vector<int>vis(n+1,0);\\n        queue<pair<double,int>>q;\\n        vis[1]++;\\n        q.push({1.00,1});\\n        int t=0;\\n        unordered_map<int,pair<double,int>>m;\\n        unordered_map<int,int>children;\\n        while(!q.empty())\\n        {\\n           int s=q.size();\\n           while(s>0)\\n           {\\n               int p=q.front().second;\\n               double prob=q.front().first;\\n               q.pop();\\n               s--;\\n              double c=0;\\n               unordered_map<int,int>x;\\n               for(auto e:adj[p])\\n               {\\n                   if(vis[e]==0)\\n                   {\\n                       c++;\\n                       x[e]++;\\n                       vis[e]++;\\n                   }\\n               }\\n               children[p]=c;\\n               m[p]={prob,t};\\n               if(c!=0)\\n               {\\n                   for(auto e:x)\\n                   {\\n                       \\n                       q.push({prob/c,e.first});\\n                   }\\n               }\\n            \\n           }\\n           t++;\\n        }\\n        if(m.count(target)>0)\\n        {\\n              if(m[target].second==T ||m[target].second<T  && children[target]==0)\\n              {\\n                  return(m[target].first);\\n              }\\n        }\\n        return(0);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137947,
                "title": "python-dfs-add-a-dummy-vertex-for-convenience",
                "content": "# Intuition & Approach\\nThe idea is the same with other people\\'s DFS solutions. If the frog doesn\\'t have enough time or cannot jump to any unvisited vertex, we can return `1` or `0` depending on the frog\\'s location. \\n\\n# Trick\\nThe frog starts jumping from vertex `1`. Some implementations need to take good care of some cases related to vertex `1`, since it is slightly different from other vertices. Like the dummy node trick we used in linked-list problems, we could append a dummy virtual node `0` to it, and then the number of choices we could make for each vertex `u` will always be `choices = (the size of neighbors of u) - 1`. \\n![frog.png](https://assets.leetcode.com/users/images/7645dfe2-e8f2-41d2-8929-ae853e532310_1675455291.4581974.png)\\n\\nAnd for each level of searching, we will **divide** the probability return from the \"future\" by the number of choices we could make.\\n\\n# Code\\n```python\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        g = defaultdict(list)\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        g[1].append(0) # Add a virtual node 0, the frog still\\n        g[0].append(1) # starts jumping from vertex 1\\n        vis = set([1, 0])\\n        def dfs(u, remaining):\\n            choices = len(g[u]) - 1 \\n            if remaining == 0 or choices == 0:\\n                return 1 if u == target else 0\\n            ans = 0\\n            for v in g[u]:\\n                if v not in vis:\\n                    vis.add(v)\\n                    ans = max(ans, dfs(v, remaining - 1)) \\n            return ans / choices\\n        return dfs(1, t)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        g = defaultdict(list)\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n        g[1].append(0) # Add a virtual node 0, the frog still\\n        g[0].append(1) # starts jumping from vertex 1\\n        vis = set([1, 0])\\n        def dfs(u, remaining):\\n            choices = len(g[u]) - 1 \\n            if remaining == 0 or choices == 0:\\n                return 1 if u == target else 0\\n            ans = 0\\n            for v in g[u]:\\n                if v not in vis:\\n                    vis.add(v)\\n                    ans = max(ans, dfs(v, remaining - 1)) \\n            return ans / choices\\n        return dfs(1, t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097531,
                "title": "dfs-clean-code-o-n",
                "content": "# Code\\n```\\nvoid dfs(vector<int>&path,vector<vector<int>>&tree,int src,int par,int target){\\n    if(src==target){\\n        path.push_back(target);\\n        return;\\n    }\\n    for(auto x:tree[src]){\\n        if(x!=par)\\n            dfs(path,tree,x,src,target);\\n            if(!path.empty()){\\n                path.push_back(src);\\n                return;\\n            }\\n    } \\n}\\n\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        if(n==1) return 1;\\n        double res=1.0;\\n        vector<vector<int>>tree(n+1);\\n        vector<int>path;\\n        for(auto&x:edges){\\n            tree[x[0]].push_back(x[1]);\\n            tree[x[1]].push_back(x[0]);\\n        }\\n        dfs(path,tree,1,-1,target);\\n        int req=path.size()-1;\\n        cout<<req<<\"\\\\n\";\\n        if(t<req) return 0;\\n        if(t>req && ((target==1 && tree[target].size()) || (target!=1 && tree[target].size()!=1))) return 0;\\n        for(int i=1;i<path.size();i++){\\n            double x=tree[path[i]].size()-(path[i]!=1);\\n            res=res*(1.0/x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid dfs(vector<int>&path,vector<vector<int>>&tree,int src,int par,int target){\\n    if(src==target){\\n        path.push_back(target);\\n        return;\\n    }\\n    for(auto x:tree[src]){\\n        if(x!=par)\\n            dfs(path,tree,x,src,target);\\n            if(!path.empty()){\\n                path.push_back(src);\\n                return;\\n            }\\n    } \\n}\\n\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        if(n==1) return 1;\\n        double res=1.0;\\n        vector<vector<int>>tree(n+1);\\n        vector<int>path;\\n        for(auto&x:edges){\\n            tree[x[0]].push_back(x[1]);\\n            tree[x[1]].push_back(x[0]);\\n        }\\n        dfs(path,tree,1,-1,target);\\n        int req=path.size()-1;\\n        cout<<req<<\"\\\\n\";\\n        if(t<req) return 0;\\n        if(t>req && ((target==1 && tree[target].size()) || (target!=1 && tree[target].size()!=1))) return 0;\\n        for(int i=1;i<path.size();i++){\\n            double x=tree[path[i]].size()-(path[i]!=1);\\n            res=res*(1.0/x);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2702465,
                "title": "c-dfs-simple-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n double ans=0.0;\\n  void solve(int node,int par,vector<vector<int>>& adj,int t,int target,double prob)\\n {\\n   if(node==target && (t==0 || adj[node].size()==1))\\n   {\\n       ans=prob;\\n       return;\\n   }\\n   if(t==0)\\n   return;\\n   int x=adj[node].size()-1;\\n   for(auto &it:adj[node])\\n   {\\n       if(it!=par)\\n       solve(it,node,adj,t-1,target,prob/x);\\n   }\\n }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n         vector<vector<int>> adj(n + 1);\\n        \\n        for(int i = 0; i < edges.size(); i++)\\n        {\\n            int f = edges[i][0], to = edges[i][1];\\n\\t\\t\\t\\n            adj[f].push_back(to);\\n            adj[to].push_back(f);\\n        }\\n        adj[1].push_back(0);\\n        \\n         solve(1,0,adj,t,target,double(1));\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n double ans=0.0;\\n  void solve(int node,int par,vector<vector<int>>& adj,int t,int target,double prob)\\n {\\n   if(node==target && (t==0 || adj[node].size()==1))\\n   {\\n       ans=prob;\\n       return;\\n   }\\n   if(t==0)\\n   return;\\n   int x=adj[node].size()-1;\\n   for(auto &it:adj[node])\\n   {\\n       if(it!=par)\\n       solve(it,node,adj,t-1,target,prob/x);\\n   }\\n }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n         vector<vector<int>> adj(n + 1);\\n        \\n        for(int i = 0; i < edges.size(); i++)\\n        {\\n            int f = edges[i][0], to = edges[i][1];\\n\\t\\t\\t\\n            adj[f].push_back(to);\\n            adj[to].push_back(f);\\n        }\\n        adj[1].push_back(0);\\n        \\n         solve(1,0,adj,t,target,double(1));\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504031,
                "title": "python-simple-bfs-faster-than-95",
                "content": "```\\n#Baraa\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        \"\"\"\\n        Algorithm:\\n        1- We do BFS\\n        2- We start from vertex 1\\n        3- frog can\\'t jump to visited vertex\\n        4- We return probability if current vertex is our target and seconds == t\\n            or if there is no more verticies to jump on and we are currently on target\\n        \"\"\"\\n        \\n        q = collections.deque()\\n        graph = collections.defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        seen = set()\\n        seen.add(1)\\n        q.append([1, 1, 0])\\n        while q:\\n            vertex, prob, sec = q.popleft()\\n            if sec > t:\\n                continue\\n            tot = 0\\n            for child in graph[vertex]:\\n                if child not in seen:\\n                    tot += 1\\n            \\n            if (tot == 0 and vertex == target) or (t == sec and vertex == target):\\n                return prob\\n            \\n            for child in graph[vertex]:\\n                if child not in seen:\\n                    q.append([child, prob * (1 / tot), sec + 1])\\n                    seen.add(child)\\n        return 0\\n",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n#Baraa\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        \"\"\"\\n        Algorithm:\\n        1- We do BFS\\n        2- We start from vertex 1\\n        3- frog can\\'t jump to visited vertex\\n        4- We return probability if current vertex is our target and seconds == t\\n            or if there is no more verticies to jump on and we are currently on target\\n        \"\"\"\\n        \\n        q = collections.deque()\\n        graph = collections.defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        seen = set()\\n        seen.add(1)\\n        q.append([1, 1, 0])\\n        while q:\\n            vertex, prob, sec = q.popleft()\\n            if sec > t:\\n                continue\\n            tot = 0\\n            for child in graph[vertex]:\\n                if child not in seen:\\n                    tot += 1\\n            \\n            if (tot == 0 and vertex == target) or (t == sec and vertex == target):\\n                return prob\\n            \\n            for child in graph[vertex]:\\n                if child not in seen:\\n                    q.append([child, prob * (1 / tot), sec + 1])\\n                    seen.add(child)\\n        return 0\\n",
                "codeTag": "Java"
            },
            {
                "id": 2219593,
                "title": "c-simple-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> A;\\n    double result = 0;\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        A.resize(n + 1);\\n        for(auto& a: edges){\\n            A[a[0]].push_back(a[1]);\\n            A[a[1]].push_back(a[0]);\\n        }\\n        vector<bool> vis(n + 1);\\n        queue<pair<int, double>> q;\\n        q.push({1, 1.0});\\n        vis[1] = true;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                auto [root, prob] = q.front(); q.pop();\\n                if(!t){\\n                    result += root == target ? prob : 0;\\n                    continue;\\n                }\\n                int uv = 0;\\n                for(auto& next: A[root])\\n                    uv += !vis[next];\\n                if(!uv)\\n                    result += root == target ? prob : 0;\\n                for(auto& next: A[root])\\n                    if(!vis[next]){\\n                        vis[next] = true;\\n                        q.push({next, prob / uv});\\n                    }\\n            }\\n            t--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> A;\\n    double result = 0;\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        A.resize(n + 1);\\n        for(auto& a: edges){\\n            A[a[0]].push_back(a[1]);\\n            A[a[1]].push_back(a[0]);\\n        }\\n        vector<bool> vis(n + 1);\\n        queue<pair<int, double>> q;\\n        q.push({1, 1.0});\\n        vis[1] = true;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                auto [root, prob] = q.front(); q.pop();\\n                if(!t){\\n                    result += root == target ? prob : 0;\\n                    continue;\\n                }\\n                int uv = 0;\\n                for(auto& next: A[root])\\n                    uv += !vis[next];\\n                if(!uv)\\n                    result += root == target ? prob : 0;\\n                for(auto& next: A[root])\\n                    if(!vis[next]){\\n                        vis[next] = true;\\n                        q.push({next, prob / uv});\\n                    }\\n            }\\n            t--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2027236,
                "title": "python-simple-bfs",
                "content": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        P = [1] * n\\n        jumps_to = [0] * n\\n        G = defaultdict(list)\\n        for e in edges:\\n            G[e[0]].append(e[1])\\n            G[e[1]].append(e[0])\\n        \\n        queue = [1]\\n        while queue:\\n            v = queue.pop(0)\\n            for child in G[v]:\\n                G[child].remove(v)\\n                P[child-1] = P[v-1] / len(G[v])\\n                jumps_to[child-1] = jumps_to[v-1]+1\\n                queue.append(child)\\n        \\n        return P[target-1] if ((G[target] and t == jumps_to[target-1]) or \\n                               (not G[target] and t >= jumps_to[target-1])) else 0\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        P = [1] * n\\n        jumps_to = [0] * n\\n        G = defaultdict(list)\\n        for e in edges:\\n            G[e[0]].append(e[1])\\n            G[e[1]].append(e[0])\\n        \\n        queue = [1]\\n        while queue:\\n            v = queue.pop(0)\\n            for child in G[v]:\\n                G[child].remove(v)\\n                P[child-1] = P[v-1] / len(G[v])\\n                jumps_to[child-1] = jumps_to[v-1]+1\\n                queue.append(child)\\n        \\n        return P[target-1] if ((G[target] and t == jumps_to[target-1]) or \\n                               (not G[target] and t >= jumps_to[target-1])) else 0\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879900,
                "title": "java-o-n-simple-bfs-solution-clean-code",
                "content": "```\\nclass Solution {\\n    public double frogPosition(int n1, int[][] edges, int t, int target) {\\n        HashMap<Integer, List<Integer>> adj= new HashMap<>();\\n        for(int[] edge:edges){\\n            int src=edge[0];\\n            int dest=edge[1];\\n            adj.putIfAbsent(src, new ArrayList<Integer>());\\n            adj.putIfAbsent(dest, new ArrayList<Integer>());\\n            adj.get(src).add(dest);\\n            adj.get(dest).add(src);\\n        }\\n        Queue<Node> q= new LinkedList<>();\\n        Node root= new Node(1,1.0);\\n        boolean[] vis= new boolean[n1+1];\\n        vis[1]=true;\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            boolean found=false;\\n            if(t<0)return 0.0;\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                Node node=q.poll();\\n                int child=0;\\n                if(adj.containsKey(node.val)){\\n                    for(int ch:adj.get(node.val)){\\n                        if(!vis[ch]){\\n                            child++;\\n                        }\\n                    }\\n                    double proToReachChild=node.pro/child;\\n                    for(int ch:adj.get(node.val)){\\n                        if(!vis[ch]){\\n                            q.offer(new Node(ch,proToReachChild ));\\n                            vis[ch]=true;\\n                        }\\n                    }\\n                }\\n                if(node.val==target){\\n                        if(t==0 || child==0)\\n                            return node.pro;\\n                    else return 0.0;\\n                }\\n            }\\n            t--;\\n        }\\n        return 0.0;\\n    }\\n    \\n    class Node{\\n        int val;\\n        double pro;\\n        Node(int val, double pro){\\n            this.val=val;\\n            this.pro=pro;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public double frogPosition(int n1, int[][] edges, int t, int target) {\\n        HashMap<Integer, List<Integer>> adj= new HashMap<>();\\n        for(int[] edge:edges){\\n            int src=edge[0];\\n            int dest=edge[1];\\n            adj.putIfAbsent(src, new ArrayList<Integer>());\\n            adj.putIfAbsent(dest, new ArrayList<Integer>());\\n            adj.get(src).add(dest);\\n            adj.get(dest).add(src);\\n        }\\n        Queue<Node> q= new LinkedList<>();\\n        Node root= new Node(1,1.0);\\n        boolean[] vis= new boolean[n1+1];\\n        vis[1]=true;\\n        q.offer(root);\\n        while(!q.isEmpty()){\\n            boolean found=false;\\n            if(t<0)return 0.0;\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                Node node=q.poll();\\n                int child=0;\\n                if(adj.containsKey(node.val)){\\n                    for(int ch:adj.get(node.val)){\\n                        if(!vis[ch]){\\n                            child++;\\n                        }\\n                    }\\n                    double proToReachChild=node.pro/child;\\n                    for(int ch:adj.get(node.val)){\\n                        if(!vis[ch]){\\n                            q.offer(new Node(ch,proToReachChild ));\\n                            vis[ch]=true;\\n                        }\\n                    }\\n                }\\n                if(node.val==target){\\n                        if(t==0 || child==0)\\n                            return node.pro;\\n                    else return 0.0;\\n                }\\n            }\\n            t--;\\n        }\\n        return 0.0;\\n    }\\n    \\n    class Node{\\n        int val;\\n        double pro;\\n        Node(int val, double pro){\\n            this.val=val;\\n            this.pro=pro;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813442,
                "title": "c-simple-dfs-solution-99",
                "content": "```\\n\\ttypedef vector<vector<int>>vvi;\\n    typedef vector<bool>vb;\\n    double dfs(vvi &graph,int src,int &tar,int t,vb &vis){\\n        if(t<0) return 0;\\n        if(src==tar){\\n            if(t==0) return 1;\\n            else if(t>0){\\n                if(tar!=1 && graph[src].size()==1) return 1;\\n                else if(tar==1 && graph[1].size()==0)  return 1;\\n                else return 0;\\n            }\\n            return 0;\\n        }\\n        double res=0;\\n        double sz=1.0/double(graph[src].size()-1);\\n        if(src==1) sz=1.0/double(graph[src].size());\\n        for(int x:graph[src]){\\n            if(vis[x]==false){\\n                vis[x]=true;\\n                res=dfs(graph,x,tar,t-1,vis);\\n                vis[x]=false;\\n                if(res>0) return res*sz;\\n            } \\n        }\\n        return res;\\n        \\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int tar) {\\n        vvi graph(n+1);\\n        for(auto x:edges){\\n            int u=x[0];\\n            int v=x[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        vb vis(n+1,false);\\n        vis[1]=true;\\n        return dfs(graph,1,tar,t,vis);\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n\\ttypedef vector<vector<int>>vvi;\\n    typedef vector<bool>vb;\\n    double dfs(vvi &graph,int src,int &tar,int t,vb &vis){\\n        if(t<0) return 0;\\n        if(src==tar){\\n            if(t==0) return 1;\\n            else if(t>0){\\n                if(tar!=1 && graph[src].size()==1) return 1;\\n                else if(tar==1 && graph[1].size()==0)  return 1;\\n                else return 0;\\n            }\\n            return 0;\\n        }\\n        double res=0;\\n        double sz=1.0/double(graph[src].size()-1);\\n        if(src==1) sz=1.0/double(graph[src].size());\\n        for(int x:graph[src]){\\n            if(vis[x]==false){\\n                vis[x]=true;\\n                res=dfs(graph,x,tar,t-1,vis);\\n                vis[x]=false;\\n                if(res>0) return res*sz;\\n            } \\n        }\\n        return res;\\n        \\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int tar) {\\n        vvi graph(n+1);\\n        for(auto x:edges){\\n            int u=x[0];\\n            int v=x[1];\\n            graph[u].push_back(v);\\n            graph[v].push_back(u);\\n        }\\n        \\n        vb vis(n+1,false);\\n        vis[1]=true;\\n        return dfs(graph,1,tar,t,vis);\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1798400,
                "title": "c-simple-bfs-solution",
                "content": "In case of tree cycle not possible, so we don\\'t needed visited array we just don\\'t go back to parent.\\n\\nSo did a bfs with objects in queue by maintaining parent and probabily as well.\\nWhen you add children of a node, add all expect its parent. so don\\'t consider parent in probability as well.\\n\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        // creating adjaceny list for graph.\\n        vector<vector<int>> graph(n+1, vector<int>{});\\n        for (auto edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        typedef struct cell {\\n            int first;\\n            double second;\\n            int parent;\\n        } cell;\\n        graph[1].push_back(1);\\n        queue<cell> qu;\\n        qu.push(cell{1, 1.0, 1});\\n        \\n        for (int j = 0; j < t && !qu.empty(); j++) {\\n            int cursize = qu.size();\\n            for (int i = 0; i < cursize; i++) {\\n                cell curtop = qu.front();\\n                qu.pop();\\n                \\n                if (graph[curtop.first].size() == 1) {\\n                    qu.push(curtop);\\n                    continue;\\n                }\\n                \\n                for (auto neighbour : graph[curtop.first]) {\\n                    if (neighbour != curtop.parent) {\\n                        qu.push(cell{neighbour, curtop.second *(1.0/(graph[curtop.first].size()-1)), curtop.first});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // after level look at queue for answer.\\n        while (!qu.empty()) {\\n            cell curtop = qu.front();\\n            qu.pop();\\n            if (curtop.first == target) return curtop.second;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        // creating adjaceny list for graph.\\n        vector<vector<int>> graph(n+1, vector<int>{});\\n        for (auto edge : edges) {\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        \\n        typedef struct cell {\\n            int first;\\n            double second;\\n            int parent;\\n        } cell;\\n        graph[1].push_back(1);\\n        queue<cell> qu;\\n        qu.push(cell{1, 1.0, 1});\\n        \\n        for (int j = 0; j < t && !qu.empty(); j++) {\\n            int cursize = qu.size();\\n            for (int i = 0; i < cursize; i++) {\\n                cell curtop = qu.front();\\n                qu.pop();\\n                \\n                if (graph[curtop.first].size() == 1) {\\n                    qu.push(curtop);\\n                    continue;\\n                }\\n                \\n                for (auto neighbour : graph[curtop.first]) {\\n                    if (neighbour != curtop.parent) {\\n                        qu.push(cell{neighbour, curtop.second *(1.0/(graph[curtop.first].size()-1)), curtop.first});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // after level look at queue for answer.\\n        while (!qu.empty()) {\\n            cell curtop = qu.front();\\n            qu.pop();\\n            if (curtop.first == target) return curtop.second;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753336,
                "title": "node-to-root-path-dfs-intuitive",
                "content": "By node to root path \\n```\\nclass Solution {\\npublic:\\n    vector<int> r2n;\\n    vector<bool> vis;\\n    bool dfs(int src,int des,vector<vector<int>> &g){\\n       vis[src] = true;\\n       if(src == des){\\n           r2n.push_back(src);\\n           return true;\\n       }\\n        for(auto nbr : g[src]){\\n            if(vis[nbr] == false){\\n                bool tmp = dfs(nbr,des,g);\\n                \\n                if(tmp){\\n                    r2n.push_back(src);\\n                    return true;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n    double frogPosition(int n, vector<vector<int>>& e, int t, int tar) {\\n        \\n        vector<vector<int>> g(n+1);\\n        if(e.size() == 0) return 1.0;\\n        vis = vector<bool> (n+1,false);\\n        for(int i=0;i<e.size();i++){\\n            int u = e[i][0];\\n            int v = e[i][1];\\n            g[u].push_back(v);\\n            g[v].push_back(u);\\n        }\\n        \\n        bool tt = dfs(1,tar,g);\\n        \\n        if(t < r2n.size()-1)\\n        {\\n            return 0.0;\\n        }\\n        reverse(r2n.begin(),r2n.end());\\n        if(t > r2n.size()-1 and g[tar].size() > 1) return 0.0;\\n        if(tar == 1 and t > r2n.size()-1) return 0.0;\\n//         for(int i=0;i<r2n.size();i++) cout<<r2n[i]<<\" \";\\n//         cout<<endl;\\n        \\n        double ans = 1.0;\\n        for(int i=0;i<r2n.size();i++){\\n            double xx;\\n            if(i==0){\\n                xx = 1.0/(1.0*g[r2n[i]].size());\\n            }else{\\n                if(g[r2n[i]].size() == 1) continue;\\n                xx = 1.0/(1.0*g[r2n[i]].size() - 1);    \\n            }\\n            \\n            ans*=xx;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> r2n;\\n    vector<bool> vis;\\n    bool dfs(int src,int des,vector<vector<int>> &g){\\n       vis[src] = true;\\n       if(src == des){\\n           r2n.push_back(src);\\n           return true;\\n       }",
                "codeTag": "Java"
            },
            {
                "id": 1743067,
                "title": "python-easy-dfs-solution",
                "content": "```\\nclass Solution:\\n    def frogPosition(self, n: int, ee: List[List[int]], t: int, tt: int) -> float:\\n        tr=[[] for i in range(n+1)];\\n        u=[False]*(n+1);\\n        for i in range(len(ee)):\\n            if ee[i][0]>ee[i][1]:\\n                if u[ee[i][0]]:tr[ee[i][0]].append(ee[i][1]);\\n                else:tr[ee[i][1]].append(ee[i][0]);\\n            else:tr[ee[i][0]].append(ee[i][1]);\\n            u[ee[i][0]]=True;\\n            u[ee[i][1]]=True;\\n        def dfs(cv,ot):\\n            if cv==tt and(ot==0 or len(tr[cv])==0):return 1;\\n            if cv==tt and ot!=0 and len(tr[cv])!=0:return 0;\\n            if ot==0 and cv!=tt:return 0;\\n            for nx in tr[cv]:\\n                a=dfs(nx,ot-1);\\n                if a:return a*(1/len(tr[cv]));\\n            return 0;\\n        return dfs(1,t);\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def frogPosition(self, n: int, ee: List[List[int]], t: int, tt: int) -> float:\\n        tr=[[] for i in range(n+1)];\\n        u=[False]*(n+1);\\n        for i in range(len(ee)):\\n            if ee[i][0]>ee[i][1]:\\n                if u[ee[i][0]]:tr[ee[i][0]].append(ee[i][1]);\\n                else:tr[ee[i][1]].append(ee[i][0]);\\n            else:tr[ee[i][0]].append(ee[i][1]);\\n            u[ee[i][0]]=True;\\n            u[ee[i][1]]=True;\\n        def dfs(cv,ot):\\n            if cv==tt and(ot==0 or len(tr[cv])==0):return 1;\\n            if cv==tt and ot!=0 and len(tr[cv])!=0:return 0;\\n            if ot==0 and cv!=tt:return 0;\\n            for nx in tr[cv]:\\n                a=dfs(nx,ot-1);\\n                if a:return a*(1/len(tr[cv]));\\n            return 0;\\n        return dfs(1,t);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1720641,
                "title": "easy-dfs-solution",
                "content": "```\\nclass Solution {\\n    private static List<Integer> graph[];  // graph array to store tree\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        graph = new ArrayList[n+1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            graph[i] = new ArrayList<>();\\n        }\\n        child = new int [n+1];\\n        parent = new int[n+1];\\n        for(int [] a: edges)\\n        {\\n            graph[a[0]].add(a[1]);\\n            graph[a[1]].add(a[0]);\\n        }\\n        parent[1] = -1;\\n        dfs(1,-1);\\n       \\n        double ans =1;\\n        int pq = 0;\\n        boolean isLeaf = false;\\n        if(child[target]==0)\\n        {\\n            isLeaf = true;\\n        }\\n        for(int start = parent[target];start!= -1;start = parent[start])   // just from the target node go till the root node and get child of each node for finding probability\\n        {\\n            ans *=((double)(1.0/child[start]));\\n            pq++;\\n        }\\n        if(pq==t || (pq<t && isLeaf)) return ans;           // one edge condition if target node is leaf frog can jump infinitely on that node \\n        return 0;                                      // if frog ends up anywhere other than the target node return 0\\n        \\n    }\\n    private static int child[];\\n    private static int parent[];\\n    private static void dfs(int start,int par)    // simple dfs to get the number of child nodes and parent of node\\n    {\\n        int count  =0;\\n        for(int i: graph[start])\\n        {\\n            if(i!= par)\\n            {\\n                parent[i] = start;\\n                count++;\\n                dfs(i,start);\\n            }\\n        }\\n        child[start] = count;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    private static List<Integer> graph[];  // graph array to store tree\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        graph = new ArrayList[n+1];\\n        for(int i=1;i<=n;i++)\\n        {\\n            graph[i] = new ArrayList<>();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1642074,
                "title": "c-solution-bfs",
                "content": "```\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        queue<tuple<int, double, int>> bfsQ; //<node no, probability, time> \\n        unordered_map<int,vector<int>> graph;\\n        vector<bool> isVisited(n+1, false);\\n        \\n        for(auto edge: edges){\\n            int a=edge[0];\\n            int b=edge[1];    \\n            graph[a].push_back(b);\\n            graph[b].push_back(a);\\n        }\\n        \\n        for(auto i: graph){\\n            cout<<i.first<<\"->\";\\n            for(auto j: i.second)\\n                cout<<j<<\" \";\\n            cout<<endl;\\n        }\\n        \\n        bfsQ.push({1, 1.0, 0});\\n        \\n        while(!bfsQ.empty()){\\n            auto node = bfsQ.front();\\n            int nodeNo = get<0>(node);\\n            double prob = get<1>(node);\\n            int time = get<2>(node);\\n            //cout<<\" no: \"<<nodeNo<<\" prob: \"<<prob<<\" t= \"<<time<<endl;\\n            bfsQ.pop();\\n            \\n            if(time>t || isVisited[nodeNo])\\n                continue;\\n            \\n            int childNo = graph[nodeNo].size();\\n            if( nodeNo != 1 )\\n                childNo -= 1;\\n            \\n            if(nodeNo == target){\\n                if(childNo==0&&time<=t || childNo!=0 && time==t)\\n                    return prob;\\n            }\\n                \\n            isVisited[nodeNo] = true;\\n            \\n            for(auto child: graph[nodeNo])\\n                if(!isVisited[child])\\n                    bfsQ.push({child, prob/childNo, time+1});\\n        }\\n        return 0;\\n            \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        queue<tuple<int, double, int>> bfsQ; //<node no, probability, time> \\n        unordered_map<int,vector<int>> graph;\\n        vector<bool> isVisited(n+1, false);\\n        \\n        for(auto edge: edges){\\n            int a=edge[0];\\n            int b=edge[1];    \\n            graph[a].push_back(b);\\n            graph[b].push_back(a);\\n        }\\n        \\n        for(auto i: graph){\\n            cout<<i.first<<\"->\";\\n            for(auto j: i.second)\\n                cout<<j<<\" \";\\n            cout<<endl;\\n        }\\n        \\n        bfsQ.push({1, 1.0, 0});\\n        \\n        while(!bfsQ.empty()){\\n            auto node = bfsQ.front();\\n            int nodeNo = get<0>(node);\\n            double prob = get<1>(node);\\n            int time = get<2>(node);\\n            //cout<<\" no: \"<<nodeNo<<\" prob: \"<<prob<<\" t= \"<<time<<endl;\\n            bfsQ.pop();\\n            \\n            if(time>t || isVisited[nodeNo])\\n                continue;\\n            \\n            int childNo = graph[nodeNo].size();\\n            if( nodeNo != 1 )\\n                childNo -= 1;\\n            \\n            if(nodeNo == target){\\n                if(childNo==0&&time<=t || childNo!=0 && time==t)\\n                    return prob;\\n            }\\n                \\n            isVisited[nodeNo] = true;\\n            \\n            for(auto child: graph[nodeNo])\\n                if(!isVisited[child])\\n                    bfsQ.push({child, prob/childNo, time+1});\\n        }\\n        return 0;\\n            \\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1594075,
                "title": "python-concise-dfs-o-n-solution",
                "content": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if n == 1: return 1.0\\n        G = [[] for i in range(n + 1)]\\n        for i, j in edges:\\n            G[i].append(j)\\n            G[j].append(i)\\n\\n        def dfs(i, t, prev):\\n            # Check if leaf node or ran out of time (i.e stuck at this node now)\\n            isRootNode = i == 1\\n            if (not isRootNode and len(G[i])) == 1 or t == 0:\\n                return i == target\\n            res = sum(dfs(j, t - 1, i) for j in G[i] if j != prev)\\n            return res  / (len(G[i]) - (not isRootNode))\\n        \\n        return dfs(1, t, None)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if n == 1: return 1.0\\n        G = [[] for i in range(n + 1)]\\n        for i, j in edges:\\n            G[i].append(j)\\n            G[j].append(i)\\n\\n        def dfs(i, t, prev):\\n            # Check if leaf node or ran out of time (i.e stuck at this node now)\\n            isRootNode = i == 1\\n            if (not isRootNode and len(G[i])) == 1 or t == 0:\\n                return i == target\\n            res = sum(dfs(j, t - 1, i) for j in G[i] if j != prev)\\n            return res  / (len(G[i]) - (not isRootNode))\\n        \\n        return dfs(1, t, None)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545312,
                "title": "c-solution-using-simple-bfs-solution-with-important-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<int> adj[n];\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int a=edges[i][0], b=edges[i][1];\\n            adj[a-1].push_back(b-1);\\n            adj[b-1].push_back(a-1);\\n        }\\n        \\n        vector<double> prob(n,1);\\n        vector<bool> vis(n,false);\\n        vector<int> time(n,0);\\n        \\n        prob[0]=1.0;\\n        queue<int> q; q.push(0);\\n        \\n        while(!q.empty())\\n        {\\n            int a=q.front(); q.pop();\\n            if(vis[a]) continue;\\n            vis[a]=true;\\n            if(a==target-1)\\n            {\\n                // there are 3 possibilities, once you reach your target\\n                // 1. the time to reach it is more than provided so, return 0\\n                // 2. the time to reach it is equal to the time given so return the prob\\n                // 3. the time to reach is less than given, so now, incase you don\\'t have\\n                // any neighbour to visit, you can hop at the same place till the time gets over and as such return the prob, however, if this node has unvisited neighbour, it can\\'t stay here and it has to hop to the neighbours and in that case, once again you can\\'t be present at the target after t-time and thus, you need to return 0;\\n                \\n                \\n                if(time[a]>t) return 0;\\n                if(time[a]==t) return prob[a];\\n                \\n                for(auto x: adj[a])\\n                {\\n                    if(!vis[x]) return 0;\\n                }\\n                return prob[a];\\n            }\\n            int n=0;\\n            for(auto x: adj[a])\\n            {\\n                if(vis[x]) continue;\\n                n++;\\n                time[x]=time[a]+1;\\n                q.push(x);\\n            }\\n                    \\n            for(auto x: adj[a])\\n            {\\n                if(vis[x]) continue;\\n                prob[x]=prob[a]*(1.0/(n+0.0));\\n            }\\n           \\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<int> adj[n];\\n        \\n        for(int i=0;i<edges.size();i++)\\n        {\\n            int a=edges[i][0], b=edges[i][1];\\n            adj[a-1].push_back(b-1);\\n            adj[b-1].push_back(a-1);\\n        }\\n        \\n        vector<double> prob(n,1);\\n        vector<bool> vis(n,false);\\n        vector<int> time(n,0);\\n        \\n        prob[0]=1.0;\\n        queue<int> q; q.push(0);\\n        \\n        while(!q.empty())\\n        {\\n            int a=q.front(); q.pop();\\n            if(vis[a]) continue;\\n            vis[a]=true;\\n            if(a==target-1)\\n            {\\n                // there are 3 possibilities, once you reach your target\\n                // 1. the time to reach it is more than provided so, return 0\\n                // 2. the time to reach it is equal to the time given so return the prob\\n                // 3. the time to reach is less than given, so now, incase you don\\'t have\\n                // any neighbour to visit, you can hop at the same place till the time gets over and as such return the prob, however, if this node has unvisited neighbour, it can\\'t stay here and it has to hop to the neighbours and in that case, once again you can\\'t be present at the target after t-time and thus, you need to return 0;\\n                \\n                \\n                if(time[a]>t) return 0;\\n                if(time[a]==t) return prob[a];\\n                \\n                for(auto x: adj[a])\\n                {\\n                    if(!vis[x]) return 0;\\n                }\\n                return prob[a];\\n            }\\n            int n=0;\\n            for(auto x: adj[a])\\n            {\\n                if(vis[x]) continue;\\n                n++;\\n                time[x]=time[a]+1;\\n                q.push(x);\\n            }\\n                    \\n            for(auto x: adj[a])\\n            {\\n                if(vis[x]) continue;\\n                prob[x]=prob[a]*(1.0/(n+0.0));\\n            }\\n           \\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529258,
                "title": "java-bfs-based-solution-with-explanation-and-well-readable-code",
                "content": "**Explanation**\\n1. Frog is starting form the first node, at time 0, probabilty of being at node 1 will 1.0D say it\\'s Probability of being at Current node\\n2. Once Frog will make a jump from this current node to next ndoes. Then new probabilty will be `Current node Probability * (1.00D / number of neighbours)`\\n3. Once frog jumps from this current node to neighbour then it can\\'t come back so this edge should not count in next probablity calculations. For that we can remove the edge from graph for current node and neighbour it\\'s jumping\\n4. Also, when you are jumping from the current node then Frog\\'s probablity of being at current node will 0.00D after making the jump\\n5. We can model this BFS and maintain `result` , where `result[i]` will store the probablity at at any given point of time of being at node `i ( 1-based indexing)`\\n```\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        final Graph graph = new Graph();\\n        for (final int[] edge : edges) {\\n            graph.addEdge(edge[0], edge[1]);\\n        }\\n        double[] result = new double[n + 1];\\n        Arrays.fill(result, 0.0D);\\n        // at time 0 frog is at position 1 with Probability 1.0D\\n        // now in next step it can go all neighbours with with equal Probability\\n        final Queue<Tuple> q = new ArrayDeque<>();\\n        q.offer(new Tuple(1, 0, 1.0D));\\n        while (!q.isEmpty()) {\\n            final Tuple curr = q.poll();\\n            // update the Probability is time is under limit \\n            if (curr.time <= t) {\\n                result[curr.node] = curr.p;\\n            }\\n            // if time is over for that node then we can\\'t jump any more\\n            if (curr.time + 1 > t) {\\n                continue;\\n            }\\n            final int outDegree = graph.getOutDegree(curr.node);\\n            // there is no neighbours to jump\\n            if (outDegree <= 0) {\\n                continue;\\n            }\\n            // jumped from this node so make this Probability 0.0D \\n            result[curr.node] = 0.0D;\\n            // calculate new Probability\\n            final double p = (1.0D / outDegree) * curr.p;\\n            final Set<Integer> neighbours = new HashSet<>(graph.getNeighbours(curr.node));\\n            for (final int neighbour : neighbours) {\\n                // remove the visited edge so that next time Probability calculations will be accurate\\n                graph.removeEdge(curr.node, neighbour);\\n                q.offer(new Tuple(neighbour, curr.time + 1, p));\\n\\n            }\\n        }\\n        return result[target];\\n    }\\n\\n    private static final class Tuple {\\n        private final int node;\\n        private final int time;\\n        private final double p;\\n\\n        private Tuple(int node, int time, double p) {\\n            this.node = node;\\n            this.time = time;\\n            this.p = p;\\n        }\\n\\n        public String toString() {\\n            return \"(\" + node + \",\" + time + \",\" + p + \")\";\\n        }\\n    }\\n\\n    private static final class Graph {\\n        private final Map<Integer, Set<Integer>> adjList = new HashMap<>();\\n        private final Map<Integer, Integer> outDegrees = new HashMap<>();\\n\\n        private void addEdge(final int src, final int dst) {\\n            this.adjList.computeIfAbsent(src, k -> new HashSet<>()).add(dst);\\n            this.adjList.computeIfAbsent(dst, k -> new HashSet<>()).add(src);\\n\\n            incOutDegrees(src);\\n            incOutDegrees(dst);\\n        }\\n\\n        private void removeEdge(final int src, final int dst) {\\n            this.adjList.computeIfAbsent(src, k -> new HashSet<>()).remove(dst);\\n            this.adjList.computeIfAbsent(dst, k -> new HashSet<>()).remove(src);\\n            decOutDegrees(src);\\n            decOutDegrees(dst);\\n        }\\n\\n        private Set<Integer> getNeighbours(final int node) {\\n            return this.adjList.getOrDefault(node, new HashSet<>());\\n        }\\n\\n        private int getOutDegree(final int node) {\\n            return this.outDegrees.getOrDefault(node, 0);\\n        }\\n\\n        private void decOutDegrees(final int node) {\\n            this.outDegrees.put(node, outDegrees.getOrDefault(node, 0) - 1);\\n        }\\n\\n        private void incOutDegrees(final int node) {\\n            this.outDegrees.compute(node, (k, v) -> {\\n                return v == null ? 1 : v + 1;\\n            });\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        final Graph graph = new Graph();\\n        for (final int[] edge : edges) {\\n            graph.addEdge(edge[0], edge[1]);\\n        }\\n        double[] result = new double[n + 1];\\n        Arrays.fill(result, 0.0D);\\n        // at time 0 frog is at position 1 with Probability 1.0D\\n        // now in next step it can go all neighbours with with equal Probability\\n        final Queue<Tuple> q = new ArrayDeque<>();\\n        q.offer(new Tuple(1, 0, 1.0D));\\n        while (!q.isEmpty()) {\\n            final Tuple curr = q.poll();\\n            // update the Probability is time is under limit \\n            if (curr.time <= t) {\\n                result[curr.node] = curr.p;\\n            }\\n            // if time is over for that node then we can\\'t jump any more\\n            if (curr.time + 1 > t) {\\n                continue;\\n            }\\n            final int outDegree = graph.getOutDegree(curr.node);\\n            // there is no neighbours to jump\\n            if (outDegree <= 0) {\\n                continue;\\n            }\\n            // jumped from this node so make this Probability 0.0D \\n            result[curr.node] = 0.0D;\\n            // calculate new Probability\\n            final double p = (1.0D / outDegree) * curr.p;\\n            final Set<Integer> neighbours = new HashSet<>(graph.getNeighbours(curr.node));\\n            for (final int neighbour : neighbours) {\\n                // remove the visited edge so that next time Probability calculations will be accurate\\n                graph.removeEdge(curr.node, neighbour);\\n                q.offer(new Tuple(neighbour, curr.time + 1, p));\\n\\n            }\\n        }\\n        return result[target];\\n    }\\n\\n    private static final class Tuple {\\n        private final int node;\\n        private final int time;\\n        private final double p;\\n\\n        private Tuple(int node, int time, double p) {\\n            this.node = node;\\n            this.time = time;\\n            this.p = p;\\n        }\\n\\n        public String toString() {\\n            return \"(\" + node + \",\" + time + \",\" + p + \")\";\\n        }\\n    }\\n\\n    private static final class Graph {\\n        private final Map<Integer, Set<Integer>> adjList = new HashMap<>();\\n        private final Map<Integer, Integer> outDegrees = new HashMap<>();\\n\\n        private void addEdge(final int src, final int dst) {\\n            this.adjList.computeIfAbsent(src, k -> new HashSet<>()).add(dst);\\n            this.adjList.computeIfAbsent(dst, k -> new HashSet<>()).add(src);\\n\\n            incOutDegrees(src);\\n            incOutDegrees(dst);\\n        }\\n\\n        private void removeEdge(final int src, final int dst) {\\n            this.adjList.computeIfAbsent(src, k -> new HashSet<>()).remove(dst);\\n            this.adjList.computeIfAbsent(dst, k -> new HashSet<>()).remove(src);\\n            decOutDegrees(src);\\n            decOutDegrees(dst);\\n        }\\n\\n        private Set<Integer> getNeighbours(final int node) {\\n            return this.adjList.getOrDefault(node, new HashSet<>());\\n        }\\n\\n        private int getOutDegree(final int node) {\\n            return this.outDegrees.getOrDefault(node, 0);\\n        }\\n\\n        private void decOutDegrees(final int node) {\\n            this.outDegrees.put(node, outDegrees.getOrDefault(node, 0) - 1);\\n        }\\n\\n        private void incOutDegrees(final int node) {\\n            this.outDegrees.compute(node, (k, v) -> {\\n                return v == null ? 1 : v + 1;\\n            });\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1386736,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    int target;\\n   List<Integer>[] graph;\\n    \\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        List<Integer>[] graph = new List[n+1];\\n        for(int i=0; i<=n; i++) graph[i] = new ArrayList<>();\\n        \\n        for(int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        graph[1].add(0); graph[0].add(1);\\n        \\n        this.target = target;   this.graph = graph;\\n        double[]  ans = util(0, 0, 1, 1);\\n        \\n        if(ans[2] == 1) return t >= ans[0] ? ans[1] : 0;\\n        else return t == ans[0] ? ans[1] : 0;   \\n    }\\n    \\n    \\n    private double[] util(int depth, int parent, int curr, double prob){\\n        if(curr == target){\\n             return new double[]{depth, prob, graph[curr].size()==1 ? 1 : 0 };\\n        }  //returns {depth, prob, isLeaf}\\n\\n        prob /= graph[curr].size() - ( graph[curr].size()==1 ? 0 : 1 );\\n        \\n        for(int next : graph[curr]){\\n            if(next != parent){\\n                double[] ans = util(depth+1, curr, next, prob);\\n                if(ans != null) return ans;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int target;\\n   List<Integer>[] graph;\\n    \\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        List<Integer>[] graph = new List[n+1];\\n        for(int i=0; i<=n; i++) graph[i] = new ArrayList<>();\\n        \\n        for(int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n        graph[1].add(0); graph[0].add(1);\\n        \\n        this.target = target;   this.graph = graph;\\n        double[]  ans = util(0, 0, 1, 1);\\n        \\n        if(ans[2] == 1) return t >= ans[0] ? ans[1] : 0;\\n        else return t == ans[0] ? ans[1] : 0;   \\n    }\\n    \\n    \\n    private double[] util(int depth, int parent, int curr, double prob){\\n        if(curr == target){\\n             return new double[]{depth, prob, graph[curr].size()==1 ? 1 : 0 };\\n        }  //returns {depth, prob, isLeaf}\\n\\n        prob /= graph[curr].size() - ( graph[curr].size()==1 ? 0 : 1 );\\n        \\n        for(int next : graph[curr]){\\n            if(next != parent){\\n                double[] ans = util(depth+1, curr, next, prob);\\n                if(ans != null) return ans;\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297059,
                "title": "c-none-dfs-approach-with-comments",
                "content": "Beats somewhat around 95% of C++ submissions.\\n\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        \\n        // base propability\\n        double prob = 1.0;\\n        \\n        // parse edges into path to target\\n        vector<int> path;\\n        vector<double> numout(n, 0.0); //count all outputs of each node\\n        \\n        for (auto v : edges) {\\n            numout[v[0]-1] += 1.0; //undirected graph, count both directions\\n            numout[v[1]-1] += 1.0;   \\n        }\\n        \\n        for (int i = 1; i < numout.size(); i++)\\n            numout[i]--; // since we counted both directions, all but the first node will have one connection too much\\n        \\n        // initate our path\\n        path.push_back(target);\\n        \\n        // find the node before the target node (there can only be one)\\n        int pre = 0;\\n        for (int i = 0; i < edges.size(); i++) {\\n            auto v = edges[i];\\n            if (v[0] == target) {\\n                pre = v[1];\\n                //erase the node, we don\\'t need to check it again - got all the info we need in path and numout\\n                edges.erase(edges.begin() + i, edges.begin() + i); \\n                break;\\n            }\\n            if (v[1] == target) {\\n                pre = v[0];\\n                edges.erase(edges.begin() + i, edges.begin() + i);\\n                break;\\n            }\\n        }\\n        \\n        // couldn\\'t find a connected node -> we can\\'t reach it except when we are allready on the target node or we don\\'t move\\n        if (pre == 0)\\n            return (target == 1 && (n == 1 || t == 0));\\n        \\n        // iterate though the remaining nodes (there can only be 100) to build the path\\n        path.push_back(pre);\\n        while (pre != 1) {\\n            for (int i = 0; i < edges.size(); i++) {\\n                auto v = edges[i];\\n                if (v[1] == pre) {\\n                    pre = v[0];\\n                    edges.erase(edges.begin() + i, edges.begin() + i);\\n                    break;\\n                }\\n                if (v[0] == pre) {\\n                    pre = v[1];\\n                    edges.erase(edges.begin() + i, edges.begin() + i);\\n                    break;\\n                }\\n            }\\n            path.push_back(pre);\\n        }\\n        \\n        // not enough time to reach the target\\n        if (t < path.size() - 1) {\\n            return 0.0;\\n        }\\n        \\n        // for convenience, reverse it such that path[0] is the start\\n        reverse(path.begin(), path.end());\\n        \\n        int len = path.size();\\n        // step through the path and accumulate propability        \\n        for (int i = 0; i < t; i++) {\\n            if (i < len-1) {\\n                prob *= (1.0 / numout[path[i]-1]);\\n            }\\n            if (i == len-1) {\\n                if (numout[path.back()-1] == 0.0) {\\n                    // on the target node and nowhere to go\\n                    return prob;\\n                }\\n                else \\n                {\\n                    // moving away from the target node\\n                    return 0.0;\\n                }\\n            }\\n        }        \\n                       \\n        return prob;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        \\n        // base propability\\n        double prob = 1.0;\\n        \\n        // parse edges into path to target\\n        vector<int> path;\\n        vector<double> numout(n, 0.0); //count all outputs of each node\\n        \\n        for (auto v : edges) {\\n            numout[v[0]-1] += 1.0; //undirected graph, count both directions\\n            numout[v[1]-1] += 1.0;   \\n        }\\n        \\n        for (int i = 1; i < numout.size(); i++)\\n            numout[i]--; // since we counted both directions, all but the first node will have one connection too much\\n        \\n        // initate our path\\n        path.push_back(target);\\n        \\n        // find the node before the target node (there can only be one)\\n        int pre = 0;\\n        for (int i = 0; i < edges.size(); i++) {\\n            auto v = edges[i];\\n            if (v[0] == target) {\\n                pre = v[1];\\n                //erase the node, we don\\'t need to check it again - got all the info we need in path and numout\\n                edges.erase(edges.begin() + i, edges.begin() + i); \\n                break;\\n            }\\n            if (v[1] == target) {\\n                pre = v[0];\\n                edges.erase(edges.begin() + i, edges.begin() + i);\\n                break;\\n            }\\n        }\\n        \\n        // couldn\\'t find a connected node -> we can\\'t reach it except when we are allready on the target node or we don\\'t move\\n        if (pre == 0)\\n            return (target == 1 && (n == 1 || t == 0));\\n        \\n        // iterate though the remaining nodes (there can only be 100) to build the path\\n        path.push_back(pre);\\n        while (pre != 1) {\\n            for (int i = 0; i < edges.size(); i++) {\\n                auto v = edges[i];\\n                if (v[1] == pre) {\\n                    pre = v[0];\\n                    edges.erase(edges.begin() + i, edges.begin() + i);\\n                    break;\\n                }\\n                if (v[0] == pre) {\\n                    pre = v[1];\\n                    edges.erase(edges.begin() + i, edges.begin() + i);\\n                    break;\\n                }\\n            }\\n            path.push_back(pre);\\n        }\\n        \\n        // not enough time to reach the target\\n        if (t < path.size() - 1) {\\n            return 0.0;\\n        }\\n        \\n        // for convenience, reverse it such that path[0] is the start\\n        reverse(path.begin(), path.end());\\n        \\n        int len = path.size();\\n        // step through the path and accumulate propability        \\n        for (int i = 0; i < t; i++) {\\n            if (i < len-1) {\\n                prob *= (1.0 / numout[path[i]-1]);\\n            }\\n            if (i == len-1) {\\n                if (numout[path.back()-1] == 0.0) {\\n                    // on the target node and nowhere to go\\n                    return prob;\\n                }\\n                else \\n                {\\n                    // moving away from the target node\\n                    return 0.0;\\n                }\\n            }\\n        }        \\n                       \\n        return prob;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1139255,
                "title": "javascript-bfs-easy-to-understand",
                "content": "```js\\nvar frogPosition = function(n, edges, t, target) {\\n  // build graph\\n  const graph = new Map();\\n  for (const [u, v] of edges) {\\n    addToGraph(u, v);\\n    addToGraph(v, u);\\n  }\\n  \\n  // follow the graph to bfs to the target\\n  const visited = new Set();\\n  const q = [[1, 1]];\\n  while (q.length && t >= 0) {\\n    const L = q.length;\\n    for (let i = 0; i < L; i += 1) {\\n      const [vertex, prob] = q.shift();\\n      visited.add(vertex);\\n      const children = getChildren(vertex);\\n      const numOfChildren = children.length;\\n      if (vertex == target) { // if reach target \\n        // return current prob if time is up or no vertex to jump\\n        if (t == 0 || numOfChildren == 0) return prob;\\n        // return 0 if jump further \\n        if (numOfChildren) return 0;\\n      }\\n      if (numOfChildren > 0) {\\n        for (const child of children) {\\n          q.push([child, prob / numOfChildren]);\\n        }\\n      }\\n    }\\n    t -= 1;\\n  }\\n  \\n  function addToGraph (u, v) {\\n    if (!graph.has(u)) {\\n      graph.set(u, [v]);\\n    } else {\\n      graph.get(u).push(v);\\n    }\\n  }\\n  \\n  function getChildren (u) {\\n    if (!graph.has(u)) return [];\\n    return graph.get(u).filter(node => !visited.has(node));\\n  }\\n  \\n  return 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```js\\nvar frogPosition = function(n, edges, t, target) {\\n  // build graph\\n  const graph = new Map();\\n  for (const [u, v] of edges) {\\n    addToGraph(u, v);\\n    addToGraph(v, u);\\n  }\\n  \\n  // follow the graph to bfs to the target\\n  const visited = new Set();\\n  const q = [[1, 1]];\\n  while (q.length && t >= 0) {\\n    const L = q.length;\\n    for (let i = 0; i < L; i += 1) {\\n      const [vertex, prob] = q.shift();\\n      visited.add(vertex);\\n      const children = getChildren(vertex);\\n      const numOfChildren = children.length;\\n      if (vertex == target) { // if reach target \\n        // return current prob if time is up or no vertex to jump\\n        if (t == 0 || numOfChildren == 0) return prob;\\n        // return 0 if jump further \\n        if (numOfChildren) return 0;\\n      }\\n      if (numOfChildren > 0) {\\n        for (const child of children) {\\n          q.push([child, prob / numOfChildren]);\\n        }\\n      }\\n    }\\n    t -= 1;\\n  }\\n  \\n  function addToGraph (u, v) {\\n    if (!graph.has(u)) {\\n      graph.set(u, [v]);\\n    } else {\\n      graph.get(u).push(v);\\n    }\\n  }\\n  \\n  function getChildren (u) {\\n    if (!graph.has(u)) return [];\\n    return graph.get(u).filter(node => !visited.has(node));\\n  }\\n  \\n  return 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1092590,
                "title": "python-basic-dfs-from-a-new-grad",
                "content": "\"\"\"\\nSince the frog always starts on node 1 and the visited nodes cannot be revisited, the tree can also be considered to be a directed tree with outgoing edges. This saves space for holding the \\'visited\\' structure. The same logic is used below!\\n\"\"\"\\n\\n\\n\\tclass Solution:\\n\\n\\t\\tdef frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n\\t\\t\\tif target==1:\\n\\t\\t\\t\\tif t>=1 and len(edges)>=1:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\tadj = collections.defaultdict(list)\\n\\t\\t\\tfor i in edges:\\n\\t\\t\\t\\tadj[min(i[0],i[1])].append(max(i[1],i[0]))\\n\\n\\t\\t\\tdef traversal(curr, target,t):\\n\\t\\t\\t\\tif curr==target:\\n\\t\\t\\t\\t\\tif t==0 or len(adj[curr])==0:\\n\\t\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif t==0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tfor child in adj[curr]:\\n\\t\\t\\t\\t\\tprob = traversal(child, target, t-1)/len(adj[curr])\\n\\t\\t\\t\\t\\tif prob>0: \\n\\t\\t\\t\\t\\t\\treturn prob\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\treturn traversal(1,target,t)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "\"\"\"\\nSince the frog always starts on node 1 and the visited nodes cannot be revisited, the tree can also be considered to be a directed tree with outgoing edges. This saves space for holding the \\'visited\\' structure. The same logic is used below!\\n\"\"\"\\n\\n\\n\\tclass Solution:\\n\\n\\t\\tdef frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n\\t\\t\\tif target==1:\\n\\t\\t\\t\\tif t>=1 and len(edges)>=1:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\tadj = collections.defaultdict(list)\\n\\t\\t\\tfor i in edges:\\n\\t\\t\\t\\tadj[min(i[0],i[1])].append(max(i[1],i[0]))\\n\\n\\t\\t\\tdef traversal(curr, target,t):\\n\\t\\t\\t\\tif curr==target:\\n\\t\\t\\t\\t\\tif t==0 or len(adj[curr])==0:\\n\\t\\t\\t\\t\\t\\treturn 1\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tif t==0:\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\tfor child in adj[curr]:\\n\\t\\t\\t\\t\\tprob = traversal(child, target, t-1)/len(adj[curr])\\n\\t\\t\\t\\t\\tif prob>0: \\n\\t\\t\\t\\t\\t\\treturn prob\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\treturn traversal(1,target,t)",
                "codeTag": "Java"
            },
            {
                "id": 1012579,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        this->target = target;\\n        this->t = t;\\n        vector<vector<int>> g(n+1);\\n        for(auto& e:edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        g[1].push_back(-1); //fake parent\\n        dfs(g, 1, 0, -1, 1.0);\\n        return p;\\n    }\\n    \\n    void dfs(const vector<vector<int>>& g, int i, int depth, int parent, double prob){\\n        int numChild = g[i].size() - 1;\\n        if(i == target){\\n            if(depth == t || (depth < t && numChild == 0)) p = prob;\\n        }  \\n        for(auto child : g[i]){\\n            if(child == parent) continue;\\n            dfs(g, child, depth+1, i, prob/numChild);\\n        }\\n    }\\n    \\n    double p=0;\\n    int t = 0;\\n    int target = 0;\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        this->target = target;\\n        this->t = t;\\n        vector<vector<int>> g(n+1);\\n        for(auto& e:edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1005012,
                "title": "python-short-and-easy-to-understand-bfs-solution",
                "content": "Time/space: o(n)\\n\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        \\n        tree = defaultdict(set)\\n        for edge in edges:\\n            tree[edge[0]].add(edge[1])\\n            tree[edge[1]].add(edge[0])\\n        \\n        q = deque()\\n        q.append((1,1,0))\\n        \\n        \\n        while q:\\n            node, prob, time = q.popleft()\\n      \\n            if node == target:\\n                if time == t or (time < t and len(tree[node]) == 0):\\n                    return prob\\n                return 0.0\\n            \\n            child_prob = 1 / len(tree[node]) if len(tree[node]) > 0 else 0\\n            for neigh in tree[node]:\\n                tree[neigh].remove(node)\\n                q.append((neigh, child_prob * prob, time + 1))\\n        \\n        return -1\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        \\n        tree = defaultdict(set)\\n        for edge in edges:\\n            tree[edge[0]].add(edge[1])\\n            tree[edge[1]].add(edge[0])\\n        \\n        q = deque()\\n        q.append((1,1,0))\\n        \\n        \\n        while q:\\n            node, prob, time = q.popleft()\\n      \\n            if node == target:\\n                if time == t or (time < t and len(tree[node]) == 0):\\n                    return prob\\n                return 0.0\\n            \\n            child_prob = 1 / len(tree[node]) if len(tree[node]) > 0 else 0\\n            for neigh in tree[node]:\\n                tree[neigh].remove(node)\\n                q.append((neigh, child_prob * prob, time + 1))\\n        \\n        return -1\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 738823,
                "title": "easy-c-bfs",
                "content": "Applying bfs on the tree and in bfs we are calculating the distance of a node from the starting node to check if the target node is actually reachable from the starting node in the given time and also if the disance of target node is less than the given time `t` then check that the target node is leaf or not.\\nIn the bfs I am also storing the product of `(out[u]-1)*pro[u]` where `u` is the node from which frog have moved to the current node and `out[u]` is the out degree of u. `out[u]-1` is done because of not including the edge between parent of `u` and `u`.Now, `pro[u]` is the product of (out degree of parent of u)-1 with the probability of parent of u and so on.\\nNow, the inverse of `pro[target]` is actual probability of reaching the target node.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>v;\\n    vector<int>out,dist;\\n    vector<int>pro;\\n    vector<bool>vis;\\n    void bfs(int s){\\n        queue<int>q;\\n        q.push(s);\\n        pro[s]=1;\\n        vis[s]=true;\\n        while(!q.empty()){\\n            int u = q.front();\\n            q.pop();\\n            vis[u]=true;\\n            for(auto it:v[u]){\\n                if(!vis[it]){\\n                    dist[it]=dist[u]+1;// storing distance of the node from the starting node\\n                    pro[it]=pro[u]*(out[u]-1);//storing the reverse of the probability to reach the node\\n                    q.push(it);\\n                }\\n            }\\n        }\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        std::cout << std::fixed;\\n        std::cout << std::setprecision(20);\\n        v=vector<vector<int>>(n+1);\\n        pro = out = dist = vector<int>(n+1,0);\\n        vis = vector<bool>(n+1);\\n        out[1]=1;\\n        for(auto x:edges){\\n            v[x[0]].push_back(x[1]);\\n            v[x[1]].push_back(x[0]);\\n            out[x[1]]++;\\n            out[x[0]]++;\\n        }\\n        bfs(1);\\n        // cout<<dist[target]<<endl;\\n        // for(auto x:pro)\\n        //     cout<<x<<\" \";\\n        // cout<<endl;\\n        if(dist[target]>t||(dist[target]<t&&out[target]>1))\\n            return 0;\\n        double ans = 1.0/pro[target];\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>v;\\n    vector<int>out,dist;\\n    vector<int>pro;\\n    vector<bool>vis;\\n    void bfs(int s){\\n        queue<int>q;\\n        q.push(s);\\n        pro[s]=1;\\n        vis[s]=true;\\n        while(!q.empty()){\\n            int u = q.front();\\n            q.pop();\\n            vis[u]=true;\\n            for(auto it:v[u]){\\n                if(!vis[it]){\\n                    dist[it]=dist[u]+1;// storing distance of the node from the starting node\\n                    pro[it]=pro[u]*(out[u]-1);//storing the reverse of the probability to reach the node\\n                    q.push(it);\\n                }\\n            }\\n        }\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        std::cout << std::fixed;\\n        std::cout << std::setprecision(20);\\n        v=vector<vector<int>>(n+1);\\n        pro = out = dist = vector<int>(n+1,0);\\n        vis = vector<bool>(n+1);\\n        out[1]=1;\\n        for(auto x:edges){\\n            v[x[0]].push_back(x[1]);\\n            v[x[1]].push_back(x[0]);\\n            out[x[1]]++;\\n            out[x[0]]++;\\n        }\\n        bfs(1);\\n        // cout<<dist[target]<<endl;\\n        // for(auto x:pro)\\n        //     cout<<x<<\" \";\\n        // cout<<endl;\\n        if(dist[target]>t||(dist[target]<t&&out[target]>1))\\n            return 0;\\n        double ans = 1.0/pro[target];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 737850,
                "title": "readable-python-solution-without-recursion-beats-100-time-memory",
                "content": "```python\\ndef frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if not edges:\\n            return 1\\n\\n        # a list of lists is a tad more efficient than defaultdict\\n        graph = [[] for _ in range(n + 1)]\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        # prev[] will point to the parent of each node. \\n        queue = deque([1])\\n        prev = {1: 1}\\n        while queue:\\n            elem = queue.pop()\\n            for nxt in graph[elem]:\\n                if nxt not in prev:\\n                    prev[nxt] = elem\\n                    queue.append(nxt)\\n        del prev[1]\\n        \\n\\t\\t# mass[] tells how many vertices are under a given vertex in the graph\\n        mass = Counter(prev.values())\\n        is_leaf = (target not in mass)\\n        \\n\\t\\t# the only way to end up in vertex 1 is to not jumping at all\\n        if target == 1:\\n            return 1.0 if is_leaf else 0.0\\n\\n        # Now all we need to do is jump t times up the tree from the target vertex\\n\\t\\t# and multiply masses of all vertices we see on the way.\\n\\t\\t# If we hit root on the last jump (or we start from the leaf and hit it earlier),\\n\\t\\t# then target is reachable and we have the answer. Otherwise the answer is 0.\\n        denominator = 1\\n        for jump in range(t):\\n            target = prev[target]\\n            denominator *= mass[target]\\n            if target == 1:\\n                if is_leaf or jump == t - 1:\\n                    return 1.0 / denominator\\n                break\\n\\n        return 0.0\\n```\\n\\nRuns 76 ms / 13.6 MB.",
                "solutionTags": [],
                "code": "```python\\ndef frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if not edges:\\n            return 1\\n\\n        # a list of lists is a tad more efficient than defaultdict\\n        graph = [[] for _ in range(n + 1)]\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n\\n        # prev[] will point to the parent of each node. \\n        queue = deque([1])\\n        prev = {1: 1}\\n        while queue:\\n            elem = queue.pop()\\n            for nxt in graph[elem]:\\n                if nxt not in prev:\\n                    prev[nxt] = elem\\n                    queue.append(nxt)\\n        del prev[1]\\n        \\n\\t\\t# mass[] tells how many vertices are under a given vertex in the graph\\n        mass = Counter(prev.values())\\n        is_leaf = (target not in mass)\\n        \\n\\t\\t# the only way to end up in vertex 1 is to not jumping at all\\n        if target == 1:\\n            return 1.0 if is_leaf else 0.0\\n\\n        # Now all we need to do is jump t times up the tree from the target vertex\\n\\t\\t# and multiply masses of all vertices we see on the way.\\n\\t\\t# If we hit root on the last jump (or we start from the leaf and hit it earlier),\\n\\t\\t# then target is reachable and we have the answer. Otherwise the answer is 0.\\n        denominator = 1\\n        for jump in range(t):\\n            target = prev[target]\\n            denominator *= mass[target]\\n            if target == 1:\\n                if is_leaf or jump == t - 1:\\n                    return 1.0 / denominator\\n                break\\n\\n        return 0.0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 681420,
                "title": "java-simp-bfs-what-is-after",
                "content": "1, I am confused by \"AFTER\" k seconds\\n2, use prob hashMap to mark visited\\n3, after k is actually at time k, not timer >= k;\\n\\n```\\nclass Solution {\\n    Map<Integer, Set<Integer>> g = new HashMap<>();\\n    Map<Integer, Double> prob = new HashMap<>();\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        if (edges == null || edges.length == 0) return 1.0;\\n        for (int[] e : edges) {\\n            add(e[0], e[1]);\\n            add(e[1], e[0]);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(1);\\n        prob.put(1, 1.0);\\n        while (!q.isEmpty() && --t >= 0) {\\n            int l = q.size();\\n            for (int i = 0; i < l; i++) {\\n                int curr = q.poll();\\n                Set<Integer> next = g.getOrDefault(curr, new HashSet<>());\\n                if (curr != 1 && next.size() < 2) continue;\\n                double p = prob.get(curr) / (next.size() - (curr == 1 ? 0 : 1));\\n                for (int c : next) {\\n                    if (prob.containsKey(c)) continue;\\n                    prob.put(c, p);\\n                    q.offer(c);\\n                    if (c == target) return (t == 0 || g.getOrDefault(c, new HashSet<>()).size() == 1) ? p : 0;\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n    \\n    private void add(int i, int j) {\\n        g.computeIfAbsent(i, k -> new HashSet<>());\\n        g.get(i).add(j);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Set<Integer>> g = new HashMap<>();\\n    Map<Integer, Double> prob = new HashMap<>();\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        if (edges == null || edges.length == 0) return 1.0;\\n        for (int[] e : edges) {\\n            add(e[0], e[1]);\\n            add(e[1], e[0]);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(1);\\n        prob.put(1, 1.0);\\n        while (!q.isEmpty() && --t >= 0) {\\n            int l = q.size();\\n            for (int i = 0; i < l; i++) {\\n                int curr = q.poll();\\n                Set<Integer> next = g.getOrDefault(curr, new HashSet<>());\\n                if (curr != 1 && next.size() < 2) continue;\\n                double p = prob.get(curr) / (next.size() - (curr == 1 ? 0 : 1));\\n                for (int c : next) {\\n                    if (prob.containsKey(c)) continue;\\n                    prob.put(c, p);\\n                    q.offer(c);\\n                    if (c == target) return (t == 0 || g.getOrDefault(c, new HashSet<>()).size() == 1) ? p : 0;\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n    \\n    private void add(int i, int j) {\\n        g.computeIfAbsent(i, k -> new HashSet<>());\\n        g.get(i).add(j);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 657238,
                "title": "c-bfs-o-n",
                "content": "```\\ndouble frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n\\t// Build adjacency matrix\\n\\tunordered_map<int, vector<int>> adjList;\\n\\tfor( auto edge : edges ) {\\n\\t\\tadjList[edge[0]].push_back( edge[1] );\\n\\t\\tadjList[edge[1]].push_back( edge[0] );\\n\\t}\\n\\n\\t// do BFS starting from node 1\\n\\tqueue<int> q;\\n\\tset<int> visited;\\n\\tvector<float> prob( n+1, 0 );\\n\\n\\tq.push( 1 );\\n\\tvisited.insert( 1 );\\n\\tprob[1] = 1;\\n\\n\\twhile( !q.empty() && t-- > 0 ) {\\n\\t\\tint size = q.size();\\n\\t\\tfor( int i=0; i < size; i++ ) {\\n\\t\\t\\tvector<int> child;\\n\\t\\t\\tint curr = q.front(); q.pop();\\n\\t\\t\\tfor( auto nbr : adjList[ curr ] ) {\\n\\t\\t\\t\\tif( visited.count( nbr ) == 0 ) {\\n\\t\\t\\t\\t\\tvisited.insert( nbr );\\n\\t\\t\\t\\t\\tchild.push_back( nbr );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// transfer parent probability to children at t+1 time \\n\\t\\t\\tfor( int i = 0; i < child.size(); i++ ) {\\n\\t\\t\\t\\tprob[ child[i] ] = prob[curr] / child.size();\\n\\t\\t\\t\\tq.push( child[i] );\\n\\t\\t\\t}\\n\\t\\t\\t// frogs moves to children at t+1 so probability of parent becomes zero.\\n\\t\\t\\tif( child.size() != 0 )  prob[curr] = 0;\\n\\t\\t\\tchild.clear();\\n\\t\\t}\\n\\t}\\n\\treturn prob[target];\\n\\t}\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndouble frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n\\t// Build adjacency matrix\\n\\tunordered_map<int, vector<int>> adjList;\\n\\tfor( auto edge : edges ) {\\n\\t\\tadjList[edge[0]].push_back( edge[1] );\\n\\t\\tadjList[edge[1]].push_back( edge[0] );\\n\\t}\\n\\n\\t// do BFS starting from node 1\\n\\tqueue<int> q;\\n\\tset<int> visited;\\n\\tvector<float> prob( n+1, 0 );\\n\\n\\tq.push( 1 );\\n\\tvisited.insert( 1 );\\n\\tprob[1] = 1;\\n\\n\\twhile( !q.empty() && t-- > 0 ) {\\n\\t\\tint size = q.size();\\n\\t\\tfor( int i=0; i < size; i++ ) {\\n\\t\\t\\tvector<int> child;\\n\\t\\t\\tint curr = q.front(); q.pop();\\n\\t\\t\\tfor( auto nbr : adjList[ curr ] ) {\\n\\t\\t\\t\\tif( visited.count( nbr ) == 0 ) {\\n\\t\\t\\t\\t\\tvisited.insert( nbr );\\n\\t\\t\\t\\t\\tchild.push_back( nbr );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// transfer parent probability to children at t+1 time \\n\\t\\t\\tfor( int i = 0; i < child.size(); i++ ) {\\n\\t\\t\\t\\tprob[ child[i] ] = prob[curr] / child.size();\\n\\t\\t\\t\\tq.push( child[i] );\\n\\t\\t\\t}\\n\\t\\t\\t// frogs moves to children at t+1 so probability of parent becomes zero.\\n\\t\\t\\tif( child.size() != 0 )  prob[curr] = 0;\\n\\t\\t\\tchild.clear();\\n\\t\\t}\\n\\t}\\n\\treturn prob[target];\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 539327,
                "title": "finally-dfs-java-accepted-solution-corner-cases-tortured-me-a-lot",
                "content": "```\\nclass Solution {\\n    int start_pos = 0;\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n            if(n==1){\\n                return 1;\\n            }\\n\\n            Map<Integer, Set<Integer>> map = new HashMap<>();\\n            for(int[] ele: edges){\\n                if(map.containsKey(ele[0])==false){\\n                    map.put(ele[0], new HashSet<>());\\n                }\\n                if(map.containsKey(ele[1])==false){\\n                    map.put(ele[1],  new HashSet<>());\\n                }\\n                \\n                map.get(ele[0]).add(ele[1]);\\n                map.get(ele[1]).add(ele[0]);\\n            }\\n            \\n            List<Integer> path = new ArrayList<>();\\n            boolean check = dfs(1, 1, -1, target, t, map, path);\\n            if(check==false){\\n                return 0;\\n            }\\n\\n\\n            double prob = 1;\\n            for(int ele: path){\\n                prob *= 1.0/ele;\\n            }\\n        \\n            return prob;\\n    }\\n    \\n    \\n    public boolean dfs(int start_pos, int cur, int parent, int target, int t, Map<Integer,Set<Integer>> map, List<Integer> res){\\n        if(res.size()>t){\\n            return false;\\n        }\\n        if(cur==target){\\n            if(res.size()==t){\\n                return true;\\n            }\\n            return map.get(cur).size()==1 && res.size()!=0;\\n        }\\n\\n        \\n        int size = cur==start_pos? map.get(cur).size():map.get(cur).size()-1;\\n        res.add(size);\\n        for(int next: map.get(cur)){\\n\\n            \\n            if(next!=parent && dfs(start_pos, next, cur, target, t, map, res)){\\n                return true;\\n            }\\n        }\\n        \\n        res.remove(res.size()-1);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int start_pos = 0;\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n            if(n==1){\\n                return 1;\\n            }\\n\\n            Map<Integer, Set<Integer>> map = new HashMap<>();\\n            for(int[] ele: edges){\\n                if(map.containsKey(ele[0])==false){\\n                    map.put(ele[0], new HashSet<>());\\n                }\\n                if(map.containsKey(ele[1])==false){\\n                    map.put(ele[1],  new HashSet<>());\\n                }\\n                \\n                map.get(ele[0]).add(ele[1]);\\n                map.get(ele[1]).add(ele[0]);\\n            }\\n            \\n            List<Integer> path = new ArrayList<>();\\n            boolean check = dfs(1, 1, -1, target, t, map, path);\\n            if(check==false){\\n                return 0;\\n            }\\n\\n\\n            double prob = 1;\\n            for(int ele: path){\\n                prob *= 1.0/ele;\\n            }\\n        \\n            return prob;\\n    }\\n    \\n    \\n    public boolean dfs(int start_pos, int cur, int parent, int target, int t, Map<Integer,Set<Integer>> map, List<Integer> res){\\n        if(res.size()>t){\\n            return false;\\n        }\\n        if(cur==target){\\n            if(res.size()==t){\\n                return true;\\n            }\\n            return map.get(cur).size()==1 && res.size()!=0;\\n        }\\n\\n        \\n        int size = cur==start_pos? map.get(cur).size():map.get(cur).size()-1;\\n        res.add(size);\\n        for(int next: map.get(cur)){\\n\\n            \\n            if(next!=parent && dfs(start_pos, next, cur, target, t, map, res)){\\n                return true;\\n            }\\n        }\\n        \\n        res.remove(res.size()-1);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536355,
                "title": "simple-c-bfs-solution-for-1377",
                "content": "We create an adjacency list assuming a directed acyclic graph. No visited array required. Explained with comments. 16 ms.\\n\\n```\\nclass Solution {\\npublic:\\n    struct x { int v; double p; int t; };\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> adj(n+1); queue<struct x> q; struct x y; \\n        for (auto e : edges) { if (e[0] < e[1]) adj[e[0]].push_back(e[1]); else adj[e[1]].push_back(e[0]); } /* adjacency list for \"directed\" graph */\\n        q.push({ 1, 1, 0 });    /* start from root and ... */\\n        while (!q.empty()) {    /* ... get frog to target while recording time it took and probability up to that node; no visited array required */\\n            y = q.front(); q.pop(); if (y.v == target) break;\\n            for (auto e : adj[y.v]) q.push({e, y.p / adj[y.v].size(), y.t + 1});\\n        }\\n        if (y.v == target) {\\n            if (y.t == t) return y.p;                       /* if frog reached target on time */\\n            if (y.t < t && !adj[target].size()) return y.p; /* if frog still has time but is confined to node i.e no children */\\n        }   \\n        return 0;   /* frog is lost */\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct x { int v; double p; int t; };\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> adj(n+1); queue<struct x> q; struct x y; \\n        for (auto e : edges) { if (e[0] < e[1]) adj[e[0]].push_back(e[1]); else adj[e[1]].push_back(e[0]); } /* adjacency list for \"directed\" graph */\\n        q.push({ 1, 1, 0 });    /* start from root and ... */\\n        while (!q.empty()) {    /* ... get frog to target while recording time it took and probability up to that node; no visited array required */\\n            y = q.front(); q.pop(); if (y.v == target) break;\\n            for (auto e : adj[y.v]) q.push({e, y.p / adj[y.v].size(), y.t + 1});\\n        }\\n        if (y.v == target) {\\n            if (y.t == t) return y.p;                       /* if frog reached target on time */\\n            if (y.t < t && !adj[target].size()) return y.p; /* if frog still has time but is confined to node i.e no children */\\n        }   \\n        return 0;   /* frog is lost */\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535047,
                "title": "java-dfs-2-sec-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        LinkedList<Integer>[] adj = new LinkedList[n+1];\\n        boolean[] visited = new boolean[n+1];\\n        for(int i=0;i<adj.length;i++) {\\n            adj[i] = new LinkedList<>();\\n            visited[i] = false;\\n        }\\n        for(int i=0;i<edges.length;i++) {\\n            adj[edges[i][0]].add(edges[i][1]);\\n            adj[edges[i][1]].add(edges[i][0]);\\n        }\\n        return dfs(1,t,adj,target,visited);\\n    }\\n    \\n    public double dfs(int vertex, int t, List<Integer>[] adj,int target, boolean[] visited) {\\n        visited[vertex] = true;\\n        if(t<0)\\n            return 0;\\n        if(vertex == target && t==0)\\n            return 1.0;\\n        double temp=0;\\n        \\n        for(int i=0;i<adj[vertex].size();i++) {\\n            if(!visited[adj[vertex].get(i)]) {\\n                temp = dfs(adj[vertex].get(i),t-1,adj,target,visited);\\n                if(temp>0)\\n                    break;\\n            }\\n            else {\\n                adj[vertex].remove(adj[vertex].get(i));\\n                i--;\\n            }\\n        }\\n        if(vertex == target && t>=0 && adj[vertex].size() == 0)\\n            return 1;\\n        if(adj[vertex].size() == 0)\\n            return 0;\\n        return temp*((double)1/(adj[vertex].size()));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        LinkedList<Integer>[] adj = new LinkedList[n+1];\\n        boolean[] visited = new boolean[n+1];\\n        for(int i=0;i<adj.length;i++) {\\n            adj[i] = new LinkedList<>();\\n            visited[i] = false;\\n        }\\n        for(int i=0;i<edges.length;i++) {\\n            adj[edges[i][0]].add(edges[i][1]);\\n            adj[edges[i][1]].add(edges[i][0]);\\n        }\\n        return dfs(1,t,adj,target,visited);\\n    }\\n    \\n    public double dfs(int vertex, int t, List<Integer>[] adj,int target, boolean[] visited) {\\n        visited[vertex] = true;\\n        if(t<0)\\n            return 0;\\n        if(vertex == target && t==0)\\n            return 1.0;\\n        double temp=0;\\n        \\n        for(int i=0;i<adj[vertex].size();i++) {\\n            if(!visited[adj[vertex].get(i)]) {\\n                temp = dfs(adj[vertex].get(i),t-1,adj,target,visited);\\n                if(temp>0)\\n                    break;\\n            }\\n            else {\\n                adj[vertex].remove(adj[vertex].get(i));\\n                i--;\\n            }\\n        }\\n        if(vertex == target && t>=0 && adj[vertex].size() == 0)\\n            return 1;\\n        if(adj[vertex].size() == 0)\\n            return 0;\\n        return temp*((double)1/(adj[vertex].size()));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533933,
                "title": "python-easy-to-understand-dfs-with-explanation-and-notes",
                "content": "The most important thing for this problem is to fully understand the question.\\n\\n**Note**:\\n1. Frog won\\'t necessisarily stop after it reached target.\\n2. Visited nodes won\\'t affect probability.\\n3. This is an undirected graph.\\n4. The starting point 1 isn\\'t necessarily the root node.\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        g = {}\\n        for fromNode, toNode in edges:\\n            g[fromNode] = g.get(fromNode, []) + [toNode]\\n            g[toNode] = g.get(toNode, []) + [fromNode]\\n        visited = [False] * (n + 1)\\n        visited[1] = True\\n        return self.dfs(g, 1, visited, t, target)\\n        \\n    def dfs(self, g, cur, visited, secondsLeft, target):\\n        if secondsLeft == 0:\\n            return 1 if cur == target else 0\\n        else:\\n            chances = 0\\n            options = 0\\n            if cur in g:\\n                for neighbor in g[cur]:\\n                    if not visited[neighbor]:\\n                        options += 1\\n                        visited[neighbor] = True\\n                        chances += self.dfs(g, neighbor, visited, secondsLeft - 1, target)\\n            return chances / options if options else (1 if cur == target else 0)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        g = {}\\n        for fromNode, toNode in edges:\\n            g[fromNode] = g.get(fromNode, []) + [toNode]\\n            g[toNode] = g.get(toNode, []) + [fromNode]\\n        visited = [False] * (n + 1)\\n        visited[1] = True\\n        return self.dfs(g, 1, visited, t, target)\\n        \\n    def dfs(self, g, cur, visited, secondsLeft, target):\\n        if secondsLeft == 0:\\n            return 1 if cur == target else 0\\n        else:\\n            chances = 0\\n            options = 0\\n            if cur in g:\\n                for neighbor in g[cur]:\\n                    if not visited[neighbor]:\\n                        options += 1\\n                        visited[neighbor] = True\\n                        chances += self.dfs(g, neighbor, visited, secondsLeft - 1, target)\\n            return chances / options if options else (1 if cur == target else 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533018,
                "title": "c-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<int> g[n+1];\\n        vector<double> prob(n+1,0);\\n        vector<bool> vis(n+1,false);\\n        for(auto e:edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        queue<int> q({1});\\n        vis[1] = true;\\n        prob[1] = 1.00;\\n        while(!q.empty() && t-- > 0) {\\n            int n = q.size();\\n            for(int i=0;i<n;i++) {\\n                int u = q.front(); q.pop();\\n                int cnt = 0;\\n                for(int v:g[u]) if(!vis[v]) cnt++; \\n                for(int v:g[u]) {\\n                    if(!vis[v]) {\\n                        q.push(v);\\n                        prob[v] = prob[u]*1.0/cnt;\\n                        vis[v] = true;\\n                    }\\n                } \\n                if(cnt) prob[u] = 0;\\n            }\\n        }\\n        return prob[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<int> g[n+1];\\n        vector<double> prob(n+1,0);\\n        vector<bool> vis(n+1,false);\\n        for(auto e:edges) {\\n            g[e[0]].push_back(e[1]);\\n            g[e[1]].push_back(e[0]);\\n        }\\n        queue<int> q({1});\\n        vis[1] = true;\\n        prob[1] = 1.00;\\n        while(!q.empty() && t-- > 0) {\\n            int n = q.size();\\n            for(int i=0;i<n;i++) {\\n                int u = q.front(); q.pop();\\n                int cnt = 0;\\n                for(int v:g[u]) if(!vis[v]) cnt++; \\n                for(int v:g[u]) {\\n                    if(!vis[v]) {\\n                        q.push(v);\\n                        prob[v] = prob[u]*1.0/cnt;\\n                        vis[v] = true;\\n                    }\\n                } \\n                if(cnt) prob[u] = 0;\\n            }\\n        }\\n        return prob[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532855,
                "title": "c-build-tree-get-path-get-result",
                "content": "See more in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\nBuild the tree then try to generate the path from `1` to `target`.\\n\\n* If `t` is not enough for reaching `target`, i.e. `t + 1 < path.size()`, then return `0`\\n* If `t` is too long that the frog jumps further than the `target`, i.e. `t + 1 > path.size() && tree[path.back()].size()`, then return `0`.\\n* Otherwise, the answer is `1.0 / k` where `k` is the product of all the count of branches from the root to the parent of `target`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/frog-position-after-t-seconds/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\n    unordered_map<int, vector<int>> g, nei;\\n    bool dfs(int start, int target, vector<int>&path) {\\n        path.push_back(start);\\n        if (start == target) return true;\\n        for (int n : g[start]) {\\n            if (dfs(n, target, path)) return true;\\n        }\\n        path.pop_back();\\n        return false;\\n    }\\n    void buildTree(int start, int p) {\\n        for (int n : nei[start]) {\\n            if (n == p) continue;\\n            g[start].push_back(n);\\n            buildTree(n, start);\\n        }\\n    }\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        for (auto & e : edges) {\\n            nei[e[0]].push_back(e[1]);\\n            nei[e[1]].push_back(e[0]);\\n        }\\n        buildTree(1, -1);\\n        vector<int> path;\\n        dfs(1, target, path);\\n        if (t + 1 < path.size() || (t + 1 > path.size() && g[path.back()].size())) return 0;\\n        int cnt = 1;\\n        for (int i = 0; i < path.size() - 1; ++i) cnt *= g[path[i]].size();\\n        return 1. / cnt;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/frog-position-after-t-seconds/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(N)\\nclass Solution {\\n    unordered_map<int, vector<int>> g, nei;\\n    bool dfs(int start, int target, vector<int>&path) {\\n        path.push_back(start);\\n        if (start == target) return true;\\n        for (int n : g[start]) {\\n            if (dfs(n, target, path)) return true;\\n        }\\n        path.pop_back();\\n        return false;\\n    }\\n    void buildTree(int start, int p) {\\n        for (int n : nei[start]) {\\n            if (n == p) continue;\\n            g[start].push_back(n);\\n            buildTree(n, start);\\n        }\\n    }\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        for (auto & e : edges) {\\n            nei[e[0]].push_back(e[1]);\\n            nei[e[1]].push_back(e[0]);\\n        }\\n        buildTree(1, -1);\\n        vector<int> path;\\n        dfs(1, target, path);\\n        if (t + 1 < path.size() || (t + 1 > path.size() && g[path.back()].size())) return 0;\\n        int cnt = 1;\\n        for (int i = 0; i < path.size() - 1; ++i) cnt *= g[path[i]].size();\\n        return 1. / cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532811,
                "title": "java-treat-like-dag-20-lines-don-t-know-how-it-would-work-but-it-works",
                "content": "Not sure how treating it like DAG works, it looks so simple without any extra memory like visited array etc.\\n```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        Map<Integer, List<Integer>> tree = new HashMap<>();\\n        for (int[] e : edges) {\\n            // treat it like directed graph\\n            int from = Math.min(e[0], e[1]), to = Math.max(e[0], e[1]);\\n            tree.putIfAbsent(from, new ArrayList<>());\\n            tree.get(from).add(to);\\n        }\\n        return dfs(1, 1d, 0, tree, target, t);\\n    }\\n    \\n    private double dfs(int pos, double probablity, int depth, Map<Integer, List<Integer>> tree, int target, int t) {\\n        List<Integer> nexts = tree.getOrDefault(pos, new ArrayList<>());\\n        if ((t == depth && target == pos) || (nexts.size() == 0 && target == pos && depth < t)) {\\n            return probablity;\\n        }\\n        for (int n: nexts) {\\n            double p = dfs(n, probablity / nexts.size(), depth + 1, tree, target, t);\\n            if (p > 0) {\\n                return p;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        Map<Integer, List<Integer>> tree = new HashMap<>();\\n        for (int[] e : edges) {\\n            // treat it like directed graph\\n            int from = Math.min(e[0], e[1]), to = Math.max(e[0], e[1]);\\n            tree.putIfAbsent(from, new ArrayList<>());\\n            tree.get(from).add(to);\\n        }\\n        return dfs(1, 1d, 0, tree, target, t);\\n    }\\n    \\n    private double dfs(int pos, double probablity, int depth, Map<Integer, List<Integer>> tree, int target, int t) {\\n        List<Integer> nexts = tree.getOrDefault(pos, new ArrayList<>());\\n        if ((t == depth && target == pos) || (nexts.size() == 0 && target == pos && depth < t)) {\\n            return probablity;\\n        }\\n        for (int n: nexts) {\\n            double p = dfs(n, probablity / nexts.size(), depth + 1, tree, target, t);\\n            if (p > 0) {\\n                return p;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532744,
                "title": "java-bfs",
                "content": "```\\nclass Solution {\\n    List<List<Integer>>adjecentlist=new ArrayList<>();\\n    double ans=0.0;\\n    boolean visit[];\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        visit=new boolean[n+1];\\n        for(int i=0;i<=n;i++){\\n            List<Integer>list=new ArrayList<>();\\n            adjecentlist.add(list);\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            int v1=edges[i][0];int v2=edges[i][1];\\n            adjecentlist.get(v1).add(v2);adjecentlist.get(v2).add(v1);\\n        }\\n        Queue<double[]>q=new LinkedList<>();\\n        double start[]=new double[3];\\n        start[0]=1;start[1]=0;start[2]=1.0;\\n        visit[1]=true;\\n        q.add(start);\\n        while(q.size()!=0){\\n            double parent[]=q.poll();\\n            int id=(int)parent[0];\\n            int level=(int)parent[1];\\n            double pro=parent[2];\\n            if(level>t)break;\\n            List<Integer>childs=adjecentlist.get(id);\\n            int size=0;\\n            for(int child:childs){\\n                if(!visit[child])size++;\\n            }\\n            if(id==target){\\n                if(size==0){\\n                    return pro;\\n                } \\n                if(level==t)return pro;\\n            }\\n            for(int child:childs){\\n                if(!visit[child]){\\n                    visit[child]=true;\\n                    double next[]=new double[3];\\n                    next[0]=child;next[1]=level+1;\\n                    next[2]=pro*(1.0/size);\\n                    q.add(next);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    List<List<Integer>>adjecentlist=new ArrayList<>();\\n    double ans=0.0;\\n    boolean visit[];\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        visit=new boolean[n+1];\\n        for(int i=0;i<=n;i++){\\n            List<Integer>list=new ArrayList<>();\\n            adjecentlist.add(list);\\n        }\\n        for(int i=0;i<edges.length;i++){\\n            int v1=edges[i][0];int v2=edges[i][1];\\n            adjecentlist.get(v1).add(v2);adjecentlist.get(v2).add(v1);\\n        }\\n        Queue<double[]>q=new LinkedList<>();\\n        double start[]=new double[3];\\n        start[0]=1;start[1]=0;start[2]=1.0;\\n        visit[1]=true;\\n        q.add(start);\\n        while(q.size()!=0){\\n            double parent[]=q.poll();\\n            int id=(int)parent[0];\\n            int level=(int)parent[1];\\n            double pro=parent[2];\\n            if(level>t)break;\\n            List<Integer>childs=adjecentlist.get(id);\\n            int size=0;\\n            for(int child:childs){\\n                if(!visit[child])size++;\\n            }\\n            if(id==target){\\n                if(size==0){\\n                    return pro;\\n                } \\n                if(level==t)return pro;\\n            }\\n            for(int child:childs){\\n                if(!visit[child]){\\n                    visit[child]=true;\\n                    double next[]=new double[3];\\n                    next[0]=child;next[1]=level+1;\\n                    next[2]=pro*(1.0/size);\\n                    q.add(next);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532713,
                "title": "python3-bfs-tree-traversal",
                "content": "Algorithm:\\nConvert `edges` to a `tree` from smaller node to larger node. Then, level-order traverse the tree starting from node 1. \\n\\nImplementation (76ms, 100%): \\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        tree = dict()\\n        for i, j in edges: \\n            if i > j: i, j = j, i\\n            tree.setdefault(i-1, []).append(j-1)\\n        \\n        queue, time = [(0, 1)], 0 #node-prob\\n        while queue and time <= t: #bfs \\n            tmp = []\\n            for node, prob in queue: \\n                if node == target-1: return 0 if time < t and node in tree else prob\\n                for n in tree.get(node, []): tmp.append((n, prob/len(tree[node])))\\n            queue, time = tmp, time+1\\n        return 0 \\n```\\n\\nAnalysis:\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        tree = dict()\\n        for i, j in edges: \\n            if i > j: i, j = j, i\\n            tree.setdefault(i-1, []).append(j-1)\\n        \\n        queue, time = [(0, 1)], 0 #node-prob\\n        while queue and time <= t: #bfs \\n            tmp = []\\n            for node, prob in queue: \\n                if node == target-1: return 0 if time < t and node in tree else prob\\n                for n in tree.get(node, []): tmp.append((n, prob/len(tree[node])))\\n            queue, time = tmp, time+1\\n        return 0 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 532705,
                "title": "javascript-simple-bfs",
                "content": "```\\n// BFS\\nvar frogPosition = function(n, conns, t, target) {\\n    \\n    //adjacency Matrix\\n    let edges=[...Array(n+1)].map(d=>Array(n+1).fill(Infinity))\\n    for (const [source,to] of conns) {\\n        edges[source][to]=true\\n        edges[to][source]=true\\n    }\\n\\n\\n    let start=new Set()\\n    start.add(1)\\n\\n    let q=[ [start,1,1] ] // [Set of visited nodes,currnode,currProbability]\\n\\n\\n    let time=0\\n    while(time<t){\\n        let temp=[]\\n        \\n        for (const [set,currnode,probability] of q) {\\n\\n\\n            //count how many available children my currnode has\\n            let prob=0\\n            for (let i = 0; i < edges[currnode].length; i++) {\\n                if(edges[currnode][i]!==Infinity && !set.has(i)){\\n                   prob++\\n                }                \\n            }\\n\\n            //I want to maintain the triplet of my target if no other children are available\\n            if(currnode==target&&prob==0){\\n                temp.push([set,currnode,probability])\\n                continue\\n            }\\n\\n            //push the children nodes to my q\\n            for (let i = 0; i < edges[currnode].length; i++) {\\n                if(edges[currnode][i]!==Infinity && !set.has(i)){\\n                    let cloned=new Set(set)\\n                    cloned.add(i)\\n                    temp.push( [cloned,i,probability*1/prob])\\n                }                \\n            }\\n        }\\n\\n        q=temp\\n        time++\\n    }\\n\\n    //check my end queue for all the potential target nodes\\n    let result=0\\n    for (const [set,currnode,probability] of q) {\\n        if(currnode==target){\\n            if(result==0)result=probability\\n            else result*=probability}\\n    }\\n\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\n// BFS\\nvar frogPosition = function(n, conns, t, target) {\\n    \\n    //adjacency Matrix\\n    let edges=[...Array(n+1)].map(d=>Array(n+1).fill(Infinity))\\n    for (const [source,to] of conns) {\\n        edges[source][to]=true\\n        edges[to][source]=true\\n    }\\n\\n\\n    let start=new Set()\\n    start.add(1)\\n\\n    let q=[ [start,1,1] ] // [Set of visited nodes,currnode,currProbability]\\n\\n\\n    let time=0\\n    while(time<t){\\n        let temp=[]\\n        \\n        for (const [set,currnode,probability] of q) {\\n\\n\\n            //count how many available children my currnode has\\n            let prob=0\\n            for (let i = 0; i < edges[currnode].length; i++) {\\n                if(edges[currnode][i]!==Infinity && !set.has(i)){\\n                   prob++\\n                }                \\n            }\\n\\n            //I want to maintain the triplet of my target if no other children are available\\n            if(currnode==target&&prob==0){\\n                temp.push([set,currnode,probability])\\n                continue\\n            }\\n\\n            //push the children nodes to my q\\n            for (let i = 0; i < edges[currnode].length; i++) {\\n                if(edges[currnode][i]!==Infinity && !set.has(i)){\\n                    let cloned=new Set(set)\\n                    cloned.add(i)\\n                    temp.push( [cloned,i,probability*1/prob])\\n                }                \\n            }\\n        }\\n\\n        q=temp\\n        time++\\n    }\\n\\n    //check my end queue for all the potential target nodes\\n    let result=0\\n    for (const [set,currnode,probability] of q) {\\n        if(currnode==target){\\n            if(result==0)result=probability\\n            else result*=probability}\\n    }\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532684,
                "title": "java-bfs",
                "content": "BFS \\n```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        List<Integer>[] map = new ArrayList[n + 1];\\n        for (int i = 1; i <= n; i ++) {\\n            map[i] = new ArrayList<>();\\n        }\\n        for (int[] edge: edges) {\\n            map[edge[0]].add(edge[1]);\\n            map[edge[1]].add(edge[0]);\\n        }\\n        HashSet<Integer> visited = new HashSet<>();\\n        Queue<s> nums = new LinkedList<>();\\n        nums.add(new s(1, 1.0));\\n        visited.add(1);\\n        for (int i = 0; i < t && !nums.isEmpty(); i ++) {\\n            int size = nums.size();\\n            // System.out.println(size);\\n            for (int j = 0; j < size; j ++) {\\n                s cur = nums.poll();\\n                int count = 0;\\n                for (int next: map[cur.id]) {\\n                    if (!visited.contains(next))\\n                        count ++;\\n                }\\n                if (count == 0) {\\n                    nums.add(cur);\\n                } else {\\n                    for (int next: map[cur.id]) {\\n                        if (!visited.contains(next)) {\\n                            nums.add(new s(next, cur.p / count));\\n                            visited.add(next);\\n                        }\\n                    }\\n                }\\n            }\\n        } \\n        // System.out.println(nums.size());\\n        for (s s1: nums) {\\n            if (s1.id == target) {\\n                return s1.p;\\n            }\\n        }\\n        return 0;\\n    }\\n    class s {\\n        int id;\\n        double p;\\n        s(int id, double p) {\\n            this.id = id;\\n            this.p = p;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        List<Integer>[] map = new ArrayList[n + 1];\\n        for (int i = 1; i <= n; i ++) {\\n            map[i] = new ArrayList<>();\\n        }\\n        for (int[] edge: edges) {\\n            map[edge[0]].add(edge[1]);\\n            map[edge[1]].add(edge[0]);\\n        }\\n        HashSet<Integer> visited = new HashSet<>();\\n        Queue<s> nums = new LinkedList<>();\\n        nums.add(new s(1, 1.0));\\n        visited.add(1);\\n        for (int i = 0; i < t && !nums.isEmpty(); i ++) {\\n            int size = nums.size();\\n            // System.out.println(size);\\n            for (int j = 0; j < size; j ++) {\\n                s cur = nums.poll();\\n                int count = 0;\\n                for (int next: map[cur.id]) {\\n                    if (!visited.contains(next))\\n                        count ++;\\n                }\\n                if (count == 0) {\\n                    nums.add(cur);\\n                } else {\\n                    for (int next: map[cur.id]) {\\n                        if (!visited.contains(next)) {\\n                            nums.add(new s(next, cur.p / count));\\n                            visited.add(next);\\n                        }\\n                    }\\n                }\\n            }\\n        } \\n        // System.out.println(nums.size());\\n        for (s s1: nums) {\\n            if (s1.id == target) {\\n                return s1.p;\\n            }\\n        }\\n        return 0;\\n    }\\n    class s {\\n        int id;\\n        double p;\\n        s(int id, double p) {\\n            this.id = id;\\n            this.p = p;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532646,
                "title": "java-dfs-bfs-clean",
                "content": "I use map to create graph, which takes a lot of time.\\nOh, I find one way to initialize graph, updated\\n\\n```\\nclass Solution {\\n    Map<Integer, List<Integer>> map;\\n    double[] p;\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        map = new HashMap<>();\\n        p = new double[n + 1];\\n        for (int i = 0; i <= n; i++) map.putIfAbsent(i, new ArrayList<>());\\n        for (int[] edge : edges) {\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n        }\\n        dfs(-1, 1, 1, t);\\n        return p[target];\\n    }\\n    \\n    private void dfs(int parent, int node, double pos, int step) {\\n        if (step < 0) return;\\n        List<Integer> nexts = map.getOrDefault(node, new ArrayList<>());\\n        int diff = nexts.size() - (parent == -1 ? 0 : 1);\\n        for (int next : nexts)\\n            if (next != parent)\\n                dfs(node, next, pos / diff, step - 1);\\n        if (diff == 0 || step == 0) p[node] = pos;\\n    }\\n}\\n\\n```\\n\\n\\nadd BFS version\\n```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i <= n; i++) map.putIfAbsent(i, new ArrayList<>());\\n        Set<Integer> visited = new HashSet<>();\\n        for (int[] edge : edges) {\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n        }\\n        Queue<Frog> q = new LinkedList<>();\\n        q.offer(new Frog(1, 1.0));\\n        while (!q.isEmpty() && t >= 0) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Frog frog = q.poll();\\n                visited.add(frog.id);\\n                List<Integer> nexts = map.getOrDefault(frog.id, new ArrayList<>());\\n                int count = 0;\\n                for (int next : nexts)\\n                    if (!visited.contains(next)) count++;\\n                if ((count == 0 || t == 0) && frog.id == target) return frog.p;\\n                for (int next : nexts)\\n                    if (!visited.contains(next)) q.offer(new Frog(next, frog.p / count));\\n            }\\n            t--;\\n        }\\n        return 0.0;\\n    }\\n    class Frog {\\n        int id;\\n        double p;\\n        public Frog(int id, double p) {\\n            this.id = id;\\n            this.p = p;\\n        }\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, List<Integer>> map;\\n    double[] p;\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        map = new HashMap<>();\\n        p = new double[n + 1];\\n        for (int i = 0; i <= n; i++) map.putIfAbsent(i, new ArrayList<>());\\n        for (int[] edge : edges) {\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n        }\\n        dfs(-1, 1, 1, t);\\n        return p[target];\\n    }\\n    \\n    private void dfs(int parent, int node, double pos, int step) {\\n        if (step < 0) return;\\n        List<Integer> nexts = map.getOrDefault(node, new ArrayList<>());\\n        int diff = nexts.size() - (parent == -1 ? 0 : 1);\\n        for (int next : nexts)\\n            if (next != parent)\\n                dfs(node, next, pos / diff, step - 1);\\n        if (diff == 0 || step == 0) p[node] = pos;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        for (int i = 0; i <= n; i++) map.putIfAbsent(i, new ArrayList<>());\\n        Set<Integer> visited = new HashSet<>();\\n        for (int[] edge : edges) {\\n            map.get(edge[0]).add(edge[1]);\\n            map.get(edge[1]).add(edge[0]);\\n        }\\n        Queue<Frog> q = new LinkedList<>();\\n        q.offer(new Frog(1, 1.0));\\n        while (!q.isEmpty() && t >= 0) {\\n            int size = q.size();\\n            for (int i = 0; i < size; i++) {\\n                Frog frog = q.poll();\\n                visited.add(frog.id);\\n                List<Integer> nexts = map.getOrDefault(frog.id, new ArrayList<>());\\n                int count = 0;\\n                for (int next : nexts)\\n                    if (!visited.contains(next)) count++;\\n                if ((count == 0 || t == 0) && frog.id == target) return frog.p;\\n                for (int next : nexts)\\n                    if (!visited.contains(next)) q.offer(new Frog(next, frog.p / count));\\n            }\\n            t--;\\n        }\\n        return 0.0;\\n    }\\n    class Frog {\\n        int id;\\n        double p;\\n        public Frog(int id, double p) {\\n            this.id = id;\\n            this.p = p;\\n        }\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532625,
                "title": "java-bfs-solution-with-corner-case-explanation-in-video",
                "content": "- Generate list of neighbours\\n- Perform BFS\\n- Handle corner case of cannot stop or certain node when still have time and available path\\n- Handle corner case of target node too far\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/57ogVrj9zBY\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "solutionTags": [],
                "code": "- Generate list of neighbours\\n- Perform BFS\\n- Handle corner case of cannot stop or certain node when still have time and available path\\n- Handle corner case of target node too far\\n\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/57ogVrj9zBY\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 532611,
                "title": "c-bfs",
                "content": "```\\ndouble frogPosition(int n, vector<vector<int>>& edges, int time, int target)\\n{\\n\\tvector<vector<int>> graph(n + 1, vector<int>());\\n\\tfor (int i = 0; i < edges.size(); i++)\\n\\t{\\n\\t\\tgraph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n\\t}\\n        \\n    graph[1].push_back(0);\\n\\t\\t\\n\\tvector<double> prob(n + 1);\\n\\tprob[1] = 1;\\n\\n\\tqueue<pair<int, int>> q;\\n    vector<int> visited(n + 1);\\n    int layer = 0;\\n\\tq.push({ 1, layer });\\n\\n\\twhile (!q.empty())\\n\\t{\\n        layer = q.front().second;\\n        if (layer == time)\\n\\t\\t\\tbreak;\\n        \\n\\t\\twhile (!q.empty() && layer == q.front().second)\\n\\t\\t{\\n\\t\\t\\tfor (int i = 0; i < graph[q.front().first].size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint next = graph[q.front().first][i];\\n                if(!visited[next])\\n                {\\n                    q.push({ next, layer + 1 });\\n\\t\\t\\t\\t    prob[next] = prob[q.front().first] * (1 / (double)(graph[q.front().first].size() - 1));\\n                    visited[next] = 1;\\n                }\\n\\t\\t\\t}\\n            if(graph[q.front().first].size() > 1)\\n                prob[q.front().first] = 0;\\n\\t\\t\\tq.pop();\\n\\t\\t}\\t\\t\\n\\t}\\n\\n\\treturn prob[target];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ndouble frogPosition(int n, vector<vector<int>>& edges, int time, int target)\\n{\\n\\tvector<vector<int>> graph(n + 1, vector<int>());\\n\\tfor (int i = 0; i < edges.size(); i++)\\n\\t{\\n\\t\\tgraph[edges[i][0]].push_back(edges[i][1]);\\n        graph[edges[i][1]].push_back(edges[i][0]);\\n\\t}\\n        \\n    graph[1].push_back(0);\\n\\t\\t\\n\\tvector<double> prob(n + 1);\\n\\tprob[1] = 1;\\n\\n\\tqueue<pair<int, int>> q;\\n    vector<int> visited(n + 1);\\n    int layer = 0;\\n\\tq.push({ 1, layer });\\n\\n\\twhile (!q.empty())\\n\\t{\\n        layer = q.front().second;\\n        if (layer == time)\\n\\t\\t\\tbreak;\\n        \\n\\t\\twhile (!q.empty() && layer == q.front().second)\\n\\t\\t{\\n\\t\\t\\tfor (int i = 0; i < graph[q.front().first].size(); i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tint next = graph[q.front().first][i];\\n                if(!visited[next])\\n                {\\n                    q.push({ next, layer + 1 });\\n\\t\\t\\t\\t    prob[next] = prob[q.front().first] * (1 / (double)(graph[q.front().first].size() - 1));\\n                    visited[next] = 1;\\n                }\\n\\t\\t\\t}\\n            if(graph[q.front().first].size() > 1)\\n                prob[q.front().first] = 0;\\n\\t\\t\\tq.pop();\\n\\t\\t}\\t\\t\\n\\t}\\n\\n\\treturn prob[target];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532564,
                "title": "simple-bfs",
                "content": "```csharp\\npublic double FrogPosition(int n, int[][] edges, int t, int target)\\n{\\n\\ttarget--;\\n\\tDictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tgraph.Add(i, new List<int>());\\n\\t}\\n\\n\\tforeach (var edge in edges)\\n\\t{\\n\\t\\tgraph[edge[0] - 1].Add(edge[1] - 1);\\n\\t\\tgraph[edge[1] - 1].Add(edge[0] - 1);\\n\\t}\\n\\n\\tQueue<(int, double)> queue = new Queue<(int, double)>();\\n\\tqueue.Enqueue((0, 1d));\\n\\n\\tbool[] visited = new bool[n];\\n\\tvisited[0] = true;\\n\\n\\tint level = 0;\\n\\n\\twhile (queue.Count > 0 && level <= t)\\n\\t{\\n\\t\\tint count = queue.Count;\\n\\t\\tfor (int i = 0; i < count; i++)\\n\\t\\t{\\n\\t\\t\\t(int node, double prob) = queue.Dequeue();\\n\\t\\t\\tif (level == t && node == target)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn prob;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint unvisited = 0;\\n\\t\\t\\tforeach (var neighbour in graph[node])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!visited[neighbour])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tunvisited++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (level < t && node == target && unvisited == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn prob;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (unvisited > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tforeach (var neighbour in graph[node])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (!visited[neighbour])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvisited[neighbour] = true;\\n\\t\\t\\t\\t\\t\\tqueue.Enqueue((neighbour, prob / unvisited));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlevel++;\\n\\t}\\n\\n\\treturn 0d;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic double FrogPosition(int n, int[][] edges, int t, int target)\\n{\\n\\ttarget--;\\n\\tDictionary<int, List<int>> graph = new Dictionary<int, List<int>>();\\n\\tfor (int i = 0; i < n; i++)\\n\\t{\\n\\t\\tgraph.Add(i, new List<int>());\\n\\t}\\n\\n\\tforeach (var edge in edges)\\n\\t{\\n\\t\\tgraph[edge[0] - 1].Add(edge[1] - 1);\\n\\t\\tgraph[edge[1] - 1].Add(edge[0] - 1);\\n\\t}\\n\\n\\tQueue<(int, double)> queue = new Queue<(int, double)>();\\n\\tqueue.Enqueue((0, 1d));\\n\\n\\tbool[] visited = new bool[n];\\n\\tvisited[0] = true;\\n\\n\\tint level = 0;\\n\\n\\twhile (queue.Count > 0 && level <= t)\\n\\t{\\n\\t\\tint count = queue.Count;\\n\\t\\tfor (int i = 0; i < count; i++)\\n\\t\\t{\\n\\t\\t\\t(int node, double prob) = queue.Dequeue();\\n\\t\\t\\tif (level == t && node == target)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn prob;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint unvisited = 0;\\n\\t\\t\\tforeach (var neighbour in graph[node])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (!visited[neighbour])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tunvisited++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (level < t && node == target && unvisited == 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn prob;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (unvisited > 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tforeach (var neighbour in graph[node])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif (!visited[neighbour])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tvisited[neighbour] = true;\\n\\t\\t\\t\\t\\t\\tqueue.Enqueue((neighbour, prob / unvisited));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlevel++;\\n\\t}\\n\\n\\treturn 0d;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532510,
                "title": "c-my-dfs-solution-commented",
                "content": "**Idea**\\nkey is that because this is a tree, once we\\'ve found our target node, we have our result (return true)\\nand use dfs to walk around, and compute the `prob` along the way (based on how many unvisited children current node has)\\n\\n**The Code**\\n```c++\\nclass Solution {\\n private:\\n  double res;\\n  int target;\\n  bool dfs(vector<vector<int>>& G, int cur, double prob, int t,\\n           vector<bool>& visited) {\\n    int remain = 0;  // remain child to visite\\n    for (int child : G[cur]) {\\n      if (visited[child] == false) ++remain;\\n    }\\n    if (t == 0 || remain == 0) {  // can\\'t walk anymore, no remain steps or no\\n                                  // remain unvisited child\\n      if (cur == target) {\\n        res = prob;\\n        return true;\\n      }\\n      return false;\\n    }\\n    prob /= remain;  // choose one child\\n    --t;             // remain step - 1\\n    for (int child : G[cur]) {\\n      if (visited[child]) continue;\\n      visited[child] = true;\\n      if (dfs(G, child, prob, t, visited))\\n        return true;  // this is a tree, only one path to the target node, so\\n                      // once found, return true\\n      visited[child] = false;\\n    }\\n    return false;\\n  }\\n\\n public:\\n  double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n    res = 0;\\n    this->target = target - 1;  // index start from zero\\n    vector<vector<int>> G(n, vector<int>());\\n    // build the undirected graph (assume that each edge only appear once in\\n    // edges)\\n    for (auto& edge : edges) {\\n      // -1: index start from zero\\n      G[edge[0] - 1].push_back(edge[1] - 1);\\n      G[edge[1] - 1].push_back(edge[0] - 1);\\n    }\\n\\n    vector<bool> visited(n);\\n    visited[0] = true;\\n    dfs(G, 0, 1, t, visited);  // prob starts as 100%\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```c++\\nclass Solution {\\n private:\\n  double res;\\n  int target;\\n  bool dfs(vector<vector<int>>& G, int cur, double prob, int t,\\n           vector<bool>& visited) {\\n    int remain = 0;  // remain child to visite\\n    for (int child : G[cur]) {\\n      if (visited[child] == false) ++remain;\\n    }\\n    if (t == 0 || remain == 0) {  // can\\'t walk anymore, no remain steps or no\\n                                  // remain unvisited child\\n      if (cur == target) {\\n        res = prob;\\n        return true;\\n      }\\n      return false;\\n    }\\n    prob /= remain;  // choose one child\\n    --t;             // remain step - 1\\n    for (int child : G[cur]) {\\n      if (visited[child]) continue;\\n      visited[child] = true;\\n      if (dfs(G, child, prob, t, visited))\\n        return true;  // this is a tree, only one path to the target node, so\\n                      // once found, return true\\n      visited[child] = false;\\n    }\\n    return false;\\n  }\\n\\n public:\\n  double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n    res = 0;\\n    this->target = target - 1;  // index start from zero\\n    vector<vector<int>> G(n, vector<int>());\\n    // build the undirected graph (assume that each edge only appear once in\\n    // edges)\\n    for (auto& edge : edges) {\\n      // -1: index start from zero\\n      G[edge[0] - 1].push_back(edge[1] - 1);\\n      G[edge[1] - 1].push_back(edge[0] - 1);\\n    }\\n\\n    vector<bool> visited(n);\\n    visited[0] = true;\\n    dfs(G, 0, 1, t, visited);  // prob starts as 100%\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 532501,
                "title": "c-build-the-path-then-move-from-1-to-target",
                "content": "\\n```\\ndouble frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<unordered_set<int>> graph(n+1);\\n        for(vector<int>& e: edges) {\\n            graph[e[0]].insert(e[1]);\\n            graph[e[1]].insert(e[0]);\\n        }\\n        \\n        //generate the path in reverse order\\n        vector<int> path;\\n        path.push_back(target);\\n\\n        //our goal is to find 1 \\n         while(path.back() != 1) {\\n             for(int i = 1; i < n+1; ++i) {\\n                 if(graph[i].count(path.back())) {\\n                     path.push_back(i);\\n                     break;\\n                 }\\n             }\\n         }\\n\\n        //we don\\'t have enough step to go to target\\n        if(path.size() - 1 > t) {\\n            return 0;\\n        }\\n        \\n        //make it start from 1\\n        reverse(path.begin(), path.end());\\n\\n        double res = 1.0;\\n        for(int i = 0; i < path.size() - 1; ++i) {\\n            int ct = graph[path[i]].size();\\n            res /= ct;\\n            //we jump from last pos, remove it from the neighbors of next position\\n            graph[path[i+1]].erase(path[i]);\\n        }\\n        \\n        //if target still has some place to jump to and we have more moves left, we will not stay at target\\n        if(graph[target].size() > 0 && t+1 > path.size()) {\\n            return 0;\\n        }\\n            \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\ndouble frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<unordered_set<int>> graph(n+1);\\n        for(vector<int>& e: edges) {\\n            graph[e[0]].insert(e[1]);\\n            graph[e[1]].insert(e[0]);\\n        }\\n        \\n        //generate the path in reverse order\\n        vector<int> path;\\n        path.push_back(target);\\n\\n        //our goal is to find 1 \\n         while(path.back() != 1) {\\n             for(int i = 1; i < n+1; ++i) {\\n                 if(graph[i].count(path.back())) {\\n                     path.push_back(i);\\n                     break;\\n                 }\\n             }\\n         }\\n\\n        //we don\\'t have enough step to go to target\\n        if(path.size() - 1 > t) {\\n            return 0;\\n        }\\n        \\n        //make it start from 1\\n        reverse(path.begin(), path.end());\\n\\n        double res = 1.0;\\n        for(int i = 0; i < path.size() - 1; ++i) {\\n            int ct = graph[path[i]].size();\\n            res /= ct;\\n            //we jump from last pos, remove it from the neighbors of next position\\n            graph[path[i+1]].erase(path[i]);\\n        }\\n        \\n        //if target still has some place to jump to and we have more moves left, we will not stay at target\\n        if(graph[target].size() > 0 && t+1 > path.size()) {\\n            return 0;\\n        }\\n            \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532500,
                "title": "javascript-dfs",
                "content": "```javascript\\nvar frogPosition = function(n, edges, t, target) {\\n    // create an undirected adjacency list\\n    const graph = { 1: new Set() };\\n    for (let [from, to] of edges) {\\n        if (graph[from]) graph[from].add(to);\\n        else graph[from] = new Set([to]);\\n        if (graph[to]) graph[to].add(from)\\n        else graph[to] = new Set([from]);\\n    }\\n\\n    // dfs through the graph storing the vetices you\\'ve visited, number of jumps, and current vertice\\n    const dfs = (from, numJumps, visited) => {\\n\\t    // if the count equals t then return 1 if the vertice is the target\\n        if (numJumps === t) return from === target ? 1 : 0;\\n\\t\\t\\n\\t\\t// average out all the next results\\n        let numEdgesCanJump = 0;\\n        let total = 0;\\n        for (let to of graph[from]) {\\n            if (visited.has(to)) continue;\\n            visited.add(to);\\n            total += dfs(to, numJumps + 1, visited);\\n            visited.delete(to);\\n            numEdgesCanJump++;\\n        }\\n\\t\\t\\n\\t\\t// if we can jump, average all the next results\\n\\t\\t// otherwise we can\\'t jump anywhere and return 1 if we are at the target\\n\\t\\t// if we are not at the target return 0\\n        if (numEdgesCanJump > 0) {\\n            return total / numEdgesCanJump;\\n        }\\n        return from === target ? 1 : 0;\\n    }\\n    return dfs(1, 0, new Set([1]));\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```javascript\\nvar frogPosition = function(n, edges, t, target) {\\n    // create an undirected adjacency list\\n    const graph = { 1: new Set() };\\n    for (let [from, to] of edges) {\\n        if (graph[from]) graph[from].add(to);\\n        else graph[from] = new Set([to]);\\n        if (graph[to]) graph[to].add(from)\\n        else graph[to] = new Set([from]);\\n    }\\n\\n    // dfs through the graph storing the vetices you\\'ve visited, number of jumps, and current vertice\\n    const dfs = (from, numJumps, visited) => {\\n\\t    // if the count equals t then return 1 if the vertice is the target\\n        if (numJumps === t) return from === target ? 1 : 0;\\n\\t\\t\\n\\t\\t// average out all the next results\\n        let numEdgesCanJump = 0;\\n        let total = 0;\\n        for (let to of graph[from]) {\\n            if (visited.has(to)) continue;\\n            visited.add(to);\\n            total += dfs(to, numJumps + 1, visited);\\n            visited.delete(to);\\n            numEdgesCanJump++;\\n        }\\n\\t\\t\\n\\t\\t// if we can jump, average all the next results\\n\\t\\t// otherwise we can\\'t jump anywhere and return 1 if we are at the target\\n\\t\\t// if we are not at the target return 0\\n        if (numEdgesCanJump > 0) {\\n            return total / numEdgesCanJump;\\n        }\\n        return from === target ? 1 : 0;\\n    }\\n    return dfs(1, 0, new Set([1]));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080944,
                "title": "simple-bfs-solution-c-beats-100",
                "content": "# Approach\\nBFS\\n\\n# Complexity\\n- Time complexity:\\nO(V+E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> graph(n+1);\\n        for(int i = 0; i < edges.size(); i++)\\n        {\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        if(graph[1].size() == 0)\\n        {\\n            return 1;\\n        }\\n\\n        vector<bool> visited(n+1,false);\\n        queue<pair<int,pair<double,int>>> nodeQueue;\\n        nodeQueue.push({1,{1,0}});\\n        visited[1] = true;\\n\\n        while(nodeQueue.size())\\n        {\\n            auto poppedEle = nodeQueue.front();\\n            nodeQueue.pop();\\n\\n            int node = poppedEle.first;\\n            double currProb = poppedEle.second.first;\\n            int currTime = poppedEle.second.second;\\n            double nextProb;\\n\\n            if(currTime > t)\\n            {\\n                return 0;\\n            }\\n\\n            if(node == target && currTime == t)\\n            {\\n                return currProb;\\n            }\\n            else if(node == target && currTime != 0 && graph[node].size() == 1)\\n            {\\n                return currProb;\\n            }\\n\\n            if(node == 1)\\n            {\\n                nextProb = currProb * (1.0/graph[node].size());\\n            }\\n            else if(graph[node].size() > 1)\\n            {\\n                nextProb = currProb * (1.0/(graph[node].size()-1)); \\n            }\\n\\n            for(int neighbour: graph[node])\\n            {\\n                if(!visited[neighbour])\\n                {   \\n                    nodeQueue.push({neighbour,{nextProb,currTime+1}});\\n                    visited[neighbour] = true;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> graph(n+1);\\n        for(int i = 0; i < edges.size(); i++)\\n        {\\n            graph[edges[i][0]].push_back(edges[i][1]);\\n            graph[edges[i][1]].push_back(edges[i][0]);\\n        }\\n\\n        if(graph[1].size() == 0)\\n        {\\n            return 1;\\n        }\\n\\n        vector<bool> visited(n+1,false);\\n        queue<pair<int,pair<double,int>>> nodeQueue;\\n        nodeQueue.push({1,{1,0}});\\n        visited[1] = true;\\n\\n        while(nodeQueue.size())\\n        {\\n            auto poppedEle = nodeQueue.front();\\n            nodeQueue.pop();\\n\\n            int node = poppedEle.first;\\n            double currProb = poppedEle.second.first;\\n            int currTime = poppedEle.second.second;\\n            double nextProb;\\n\\n            if(currTime > t)\\n            {\\n                return 0;\\n            }\\n\\n            if(node == target && currTime == t)\\n            {\\n                return currProb;\\n            }\\n            else if(node == target && currTime != 0 && graph[node].size() == 1)\\n            {\\n                return currProb;\\n            }\\n\\n            if(node == 1)\\n            {\\n                nextProb = currProb * (1.0/graph[node].size());\\n            }\\n            else if(graph[node].size() > 1)\\n            {\\n                nextProb = currProb * (1.0/(graph[node].size()-1)); \\n            }\\n\\n            for(int neighbour: graph[node])\\n            {\\n                if(!visited[neighbour])\\n                {   \\n                    nodeQueue.push({neighbour,{nextProb,currTime+1}});\\n                    visited[neighbour] = true;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4071396,
                "title": "c-17-style-dfs-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> adj(n+1);\\n\\n        // construct graph\\n        for (auto &v : edges) {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n\\n        // isLeaf, special check on node 1\\n        auto isLeaf = [&](int val) {\\n            if (val == 1) return size(adj[val]) == 0;\\n            return size(adj[val]) <= 1;\\n        };\\n\\n        // dfs function\\n        function<double(int,int,double,int)> jump = [&] (int root, int step, double prob, int parent) -> double {\\n            if (step < 0) return -1;\\n\\n            // if we find the value but step remains\\n            if (root == target and !isLeaf(root) and step > 0) return -1;\\n            // if we find the value, either a leaf or right on step\\n            if (root == target and (isLeaf(root) || step == 0)) return prob;\\n\\n            double res = -1;\\n            // dfs function to visit all children\\n            auto num_child = adj[root].size() - (root != parent);\\n            for (auto c : adj[root]) {\\n                if (c != parent) {\\n                    res = max(res, jump(c, step - 1, prob / num_child, root));\\n                }\\n            }\\n\\n            return res;\\n            \\n        };\\n\\n        double pb = jump(1, t, 1, 1);\\n        return pb == -1 ? 0 : pb;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> adj(n+1);\\n\\n        // construct graph\\n        for (auto &v : edges) {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n\\n        // isLeaf, special check on node 1\\n        auto isLeaf = [&](int val) {\\n            if (val == 1) return size(adj[val]) == 0;\\n            return size(adj[val]) <= 1;\\n        };\\n\\n        // dfs function\\n        function<double(int,int,double,int)> jump = [&] (int root, int step, double prob, int parent) -> double {\\n            if (step < 0) return -1;\\n\\n            // if we find the value but step remains\\n            if (root == target and !isLeaf(root) and step > 0) return -1;\\n            // if we find the value, either a leaf or right on step\\n            if (root == target and (isLeaf(root) || step == 0)) return prob;\\n\\n            double res = -1;\\n            // dfs function to visit all children\\n            auto num_child = adj[root].size() - (root != parent);\\n            for (auto c : adj[root]) {\\n                if (c != parent) {\\n                    res = max(res, jump(c, step - 1, prob / num_child, root));\\n                }\\n            }\\n\\n            return res;\\n            \\n        };\\n\\n        double pb = jump(1, t, 1, 1);\\n        return pb == -1 ? 0 : pb;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042652,
                "title": "java-short-clean-recursion",
                "content": "# Code\\n```\\nclass Solution {\\n    int T;\\n    List<Integer>[] graph;\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        T = target;\\n        graph = new ArrayList[n+1];\\n        for (int i = 1; i <= n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        return probability(1, 0, 1, t);\\n    }\\n\\n    public double probability(int u, int prev, double prob, int time) {\\n        if (time < 0) {\\n            return 0;\\n        }\\n\\n        int children = graph[u].size();\\n        children -= (prev == 0) ? 0 : 1;\\n\\n        if (u == T) {\\n            return (time == 0 || children == 0) ? prob : 0;\\n        }\\n\\n        double res = 0;\\n        for (int v : graph[u]) {\\n            if (v == prev) {\\n                continue;\\n            }\\n            res += probability(v, u, prob/children, time-1);\\n        }\\n        return res;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int T;\\n    List<Integer>[] graph;\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        T = target;\\n        graph = new ArrayList[n+1];\\n        for (int i = 1; i <= n; i++) {\\n            graph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(e[1]);\\n            graph[e[1]].add(e[0]);\\n        }\\n        return probability(1, 0, 1, t);\\n    }\\n\\n    public double probability(int u, int prev, double prob, int time) {\\n        if (time < 0) {\\n            return 0;\\n        }\\n\\n        int children = graph[u].size();\\n        children -= (prev == 0) ? 0 : 1;\\n\\n        if (u == T) {\\n            return (time == 0 || children == 0) ? prob : 0;\\n        }\\n\\n        double res = 0;\\n        for (int v : graph[u]) {\\n            if (v == prev) {\\n                continue;\\n            }\\n            res += probability(v, u, prob/children, time-1);\\n        }\\n        return res;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038115,
                "title": "c-simple-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    vector<int> vis;\\n    double dfs(int u, int t, int target){\\n        vis[u] = 1;\\n        if(t==0){\\n            if(u==target) return 1;\\n            return 0;\\n        }\\n        \\n        double den = 0, num=0;\\n        for(auto &v : adj[u]){\\n            if(vis[v]) continue;\\n            den++;\\n            num = max(num, dfs(v, t-1, target));\\n        }\\n        if(den==0){\\n            if(u==target) return 1;\\n            return 0;\\n        }\\n        return num/den;\\n    }\\n    \\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        adj.clear();\\n        adj.resize(n+1);\\n        vis.clear();\\n        vis.resize(n+1, 0);\\n        \\n        for(auto &e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        return dfs(1,t,target);\\n    }\\n};\\n```\\nplease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> adj;\\n    vector<int> vis;\\n    double dfs(int u, int t, int target){\\n        vis[u] = 1;\\n        if(t==0){\\n            if(u==target) return 1;\\n            return 0;\\n        }\\n        \\n        double den = 0, num=0;\\n        for(auto &v : adj[u]){\\n            if(vis[v]) continue;\\n            den++;\\n            num = max(num, dfs(v, t-1, target));\\n        }\\n        if(den==0){\\n            if(u==target) return 1;\\n            return 0;\\n        }\\n        return num/den;\\n    }\\n    \\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        adj.clear();\\n        adj.resize(n+1);\\n        vis.clear();\\n        vis.resize(n+1, 0);\\n        \\n        for(auto &e : edges){\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        return dfs(1,t,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991221,
                "title": "c-optimized-bfs-conditional-probability-beats-96-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int tar) {\\n        vector<int> adj[n+1];\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> vis(n+1,0);\\n        queue<pair<int,pair<int,double>>> q;\\n        q.push({0,{1,1.0}});\\n        vis[1]=1;\\n        while(q.size()>0)\\n        {\\n            int time=q.front().first,node=q.front().second.first;\\n            double prob=q.front().second.second;\\n            q.pop();\\n            if(time>t) break;\\n            if(time==t&&node==tar) return prob;\\n            int ct=0;\\n            for(auto it:adj[node])\\n            {\\n                if(vis[it]==0)\\n                ct++;\\n            }\\n            double pb=(double)1.0/(double)ct;\\n            for(auto it:adj[node])\\n            {\\n                if(vis[it]==0)\\n                {\\n                    vis[it]=1;\\n                    q.push({time+1,{it,pb*prob}});\\n                }\\n            }\\n            if(time<t&&node==tar)\\n            {\\n                if(ct==0)\\n                return prob;\\n                else \\n                return 0.0;\\n            }\\n        }\\n        return 0.0;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int tar) {\\n        vector<int> adj[n+1];\\n        for(auto it:edges)\\n        {\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> vis(n+1,0);\\n        queue<pair<int,pair<int,double>>> q;\\n        q.push({0,{1,1.0}});\\n        vis[1]=1;\\n        while(q.size()>0)\\n        {\\n            int time=q.front().first,node=q.front().second.first;\\n            double prob=q.front().second.second;\\n            q.pop();\\n            if(time>t) break;\\n            if(time==t&&node==tar) return prob;\\n            int ct=0;\\n            for(auto it:adj[node])\\n            {\\n                if(vis[it]==0)\\n                ct++;\\n            }\\n            double pb=(double)1.0/(double)ct;\\n            for(auto it:adj[node])\\n            {\\n                if(vis[it]==0)\\n                {\\n                    vis[it]=1;\\n                    q.push({time+1,{it,pb*prob}});\\n                }\\n            }\\n            if(time<t&&node==tar)\\n            {\\n                if(ct==0)\\n                return prob;\\n                else \\n                return 0.0;\\n            }\\n        }\\n        return 0.0;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988553,
                "title": "bfs-traversal-beats-96-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<int>adj[n+1];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>vis(n+1,0);\\n        queue<pair<int,double>>q;\\n        q.push({1,1.00});\\n        \\n        while(!q.empty()&& t>=0){\\n            int length= q.size();\\n            while(length--){\\n                int node = q.front().first;\\n                double val = q.front().second;\\n                q.pop();\\n                vis[node]=1;\\n                double size =0;\\n                for(auto hue:adj[node])if(!vis[hue])size++;\\n                if(node==target && (t==0 || size==0)) return val;\\n                for(auto it:adj[node]){\\n                    if(!vis[it]){\\n                        vis[it]=1;\\n                        q.push({it,val/size});\\n                    }\\n                }\\n            }\\n            t--;\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<int>adj[n+1];\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int>vis(n+1,0);\\n        queue<pair<int,double>>q;\\n        q.push({1,1.00});\\n        \\n        while(!q.empty()&& t>=0){\\n            int length= q.size();\\n            while(length--){\\n                int node = q.front().first;\\n                double val = q.front().second;\\n                q.pop();\\n                vis[node]=1;\\n                double size =0;\\n                for(auto hue:adj[node])if(!vis[hue])size++;\\n                if(node==target && (t==0 || size==0)) return val;\\n                for(auto it:adj[node]){\\n                    if(!vis[it]){\\n                        vis[it]=1;\\n                        q.push({it,val/size});\\n                    }\\n                }\\n            }\\n            t--;\\n        }\\n\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981252,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void findpar(int node,vector<vector<int>>&adj,map<int,int>&par,int p)\\n   {\\n           par[node]=p;\\n           for (auto it:adj[node])\\n           {\\n             if (it!=p)\\n             {\\n                 findpar(it,adj,par,node);\\n             }\\n           }\\n       \\n   }\\n\\n\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) \\n    {\\n      \\n      vector<vector<int>>adj(n+1);\\n      for (auto it: edges)\\n      {\\n          \\n          adj[it[0]].push_back(it[1]);\\n          adj[it[1]].push_back(it[0]);\\n         \\n      } \\n        if (target==1)\\n        {\\n          if (adj[1].size()==0 || t==0) return 1;\\n          return 0;\\n        }\\n      map<int,int>par;\\n      findpar(1,adj,par,-1);\\n      double ans=1;\\n      queue<int>q;\\n      q.push(target);\\n      int temp=target;\\n      int cnt=0;\\n      int p=par[target];\\n      while(p!=-1)\\n      {\\n        if (p==1)\\n        ans*=1/(double)(adj[p].size());\\n        else\\n        ans*=1/(double)(adj[p].size()-1);\\n       // cout<<ans<<\" \"<<adj[p].size()<<endl;\\n        target=p;\\n        p=par[target];\\n         cnt++;\\n      }\\n     \\n      if (cnt==t ||(p==-1 && cnt<t && (adj[temp].size()==1 || adj[temp].size()==0) )) return ans;\\n      return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void findpar(int node,vector<vector<int>>&adj,map<int,int>&par,int p)\\n   {\\n           par[node]=p;\\n           for (auto it:adj[node])\\n           {\\n             if (it!=p)\\n             {\\n                 findpar(it,adj,par,node);\\n             }\\n           }\\n       \\n   }\\n\\n\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) \\n    {\\n      \\n      vector<vector<int>>adj(n+1);\\n      for (auto it: edges)\\n      {\\n          \\n          adj[it[0]].push_back(it[1]);\\n          adj[it[1]].push_back(it[0]);\\n         \\n      } \\n        if (target==1)\\n        {\\n          if (adj[1].size()==0 || t==0) return 1;\\n          return 0;\\n        }\\n      map<int,int>par;\\n      findpar(1,adj,par,-1);\\n      double ans=1;\\n      queue<int>q;\\n      q.push(target);\\n      int temp=target;\\n      int cnt=0;\\n      int p=par[target];\\n      while(p!=-1)\\n      {\\n        if (p==1)\\n        ans*=1/(double)(adj[p].size());\\n        else\\n        ans*=1/(double)(adj[p].size()-1);\\n       // cout<<ans<<\" \"<<adj[p].size()<<endl;\\n        target=p;\\n        p=par[target];\\n         cnt++;\\n      }\\n     \\n      if (cnt==t ||(p==-1 && cnt<t && (adj[temp].size()==1 || adj[temp].size()==0) )) return ans;\\n      return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3970577,
                "title": "clean-code-java-bfs-use-a-node",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n`Consider the following conditions:`\\n1. Frog is jumping in a single direction.\\n2. Frog can jump even after reaching the target node if time permits.\\n3. Frog cant jump further if the vertex standing does not have any childs(unvisited vertices as per problem).\\n\\n`### The main point is does frog visited target or not.`\\n#### You can visualize my code, where I created a node class which tells every time the frog is in a path, it carries the required params like parent, curr-node, prob, visited the targetor not.\\n# Complexity\\n- Time complexity:O(n) visited every node only once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        List<Integer>[] adj=new ArrayList[n];// adj list{\\n        for(int i=0;i<n;i++){\\n            adj[i]=new ArrayList<>();\\n        }\\n        for(int[] edge:edges){\\n            int u=edge[0],v=edge[1];\\n            --u;--v;\\n            adj[u].add(v);\\n            adj[v].add(u);\\n        }                                       //}             \\n        Queue<Node> q=new LinkedList<>();\\n        q.offer(new Node(0,-1,0,1.0,false));\\n        while(!q.isEmpty()){\\n            Node curr=q.poll();   // take the curr node where the frog is.\\n            if(curr.time==t){    // if it ran out of time\\n                if(curr.node==target-1 || curr.visited)return curr.prob; //if it visited the target or it on the target\\n                continue;  // No need to visite futher nodes.\\n            }\\n            int childs=adj[curr.node].size(); // number of children the node.\\n            if(curr.node!=0)childs--; //exclude the parent node from where it is coming\\n            if(childs==0){ // If the node does not have any unvisited childs\\n                if(curr.node==target-1 || curr.visited)return curr.prob;\\n                continue;\\n            }\\n            for(int i:adj[curr.node]){ // visit it\\'s childs with equal probs.\\n                if(i==curr.par)continue;// exclude visiting parent\\n                q.offer(new Node(i,curr.node,curr.time+1,curr.prob*(1.0/childs),curr.node==target-1));\\n            }\\n        }\\n        return 0; // no answer is found\\n\\n    }\\n}\\nclass Node{\\n    double prob;\\n    int node;\\n    int time;\\n    int par;\\n    boolean visited;\\n    Node(int node,int par,int time,double prob,boolean visited){\\n        this.node=node;\\n        this.par=par;\\n        this.time=time;\\n        this.prob=prob;\\n        this.visited=false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        List<Integer>[] adj=new ArrayList[n];// adj list{\\n        for(int i=0;i<n;i++){\\n            adj[i]=new ArrayList<>();\\n        }\\n        for(int[] edge:edges){\\n            int u=edge[0],v=edge[1];\\n            --u;--v;\\n            adj[u].add(v);\\n            adj[v].add(u);\\n        }                                       //}             \\n        Queue<Node> q=new LinkedList<>();\\n        q.offer(new Node(0,-1,0,1.0,false));\\n        while(!q.isEmpty()){\\n            Node curr=q.poll();   // take the curr node where the frog is.\\n            if(curr.time==t){    // if it ran out of time\\n                if(curr.node==target-1 || curr.visited)return curr.prob; //if it visited the target or it on the target\\n                continue;  // No need to visite futher nodes.\\n            }\\n            int childs=adj[curr.node].size(); // number of children the node.\\n            if(curr.node!=0)childs--; //exclude the parent node from where it is coming\\n            if(childs==0){ // If the node does not have any unvisited childs\\n                if(curr.node==target-1 || curr.visited)return curr.prob;\\n                continue;\\n            }\\n            for(int i:adj[curr.node]){ // visit it\\'s childs with equal probs.\\n                if(i==curr.par)continue;// exclude visiting parent\\n                q.offer(new Node(i,curr.node,curr.time+1,curr.prob*(1.0/childs),curr.node==target-1));\\n            }\\n        }\\n        return 0; // no answer is found\\n\\n    }\\n}\\nclass Node{\\n    double prob;\\n    int node;\\n    int time;\\n    int par;\\n    boolean visited;\\n    Node(int node,int par,int time,double prob,boolean visited){\\n        this.node=node;\\n        this.par=par;\\n        this.time=time;\\n        this.prob=prob;\\n        this.visited=false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908481,
                "title": "dfs-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph;\\n    vector<long long> dp, dist;\\n    void dfs(int src, int par){\\n        if(src == 1) dp[src] = 1, dist[src] = 0;\\n        else if(par == 1) dp[src] = (1ll*dp[par]*(long long)graph[par].size()), dist[src] = dist[par] + 1;\\n        else dp[src] = (1ll * dp[par] * ((long long)graph[par].size()-1)), dist[src] = dist[par] + 1;\\n        for(auto neigh : graph[src]){\\n            if(neigh != par){\\n                dfs(neigh, src);\\n            }\\n        }\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edge, int t, int tar) {\\n        graph = vector<vector<int>> (n+1);\\n        dp = dist = vector<long long> (n+1);\\n        for(int i=0;i<n-1;i++){\\n            int x = edge[i][0], y = edge[i][1];\\n            graph[x].push_back(y);\\n            graph[y].push_back(x);\\n        }\\n        vector<bool> leaf(n+1);\\n        for(int i=2;i<=n;i++){\\n            if((int)graph[i].size() <= 1){\\n                leaf[i] = true;\\n            }\\n        }\\n        if(n == 1) return 1;\\n        dfs(1, 0);\\n        if(dist[tar] > t) return 0;\\n        else{\\n            if(dist[tar] == t){\\n                long double ans = ((long double)1/dp[tar]);\\n                return ans;\\n            }\\n            else{\\n                if(!leaf[tar]){\\n                    return 0;\\n                }\\n                else{\\n                    long double ans = ((long double)1/dp[tar]);\\n                    return ans;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> graph;\\n    vector<long long> dp, dist;\\n    void dfs(int src, int par){\\n        if(src == 1) dp[src] = 1, dist[src] = 0;\\n        else if(par == 1) dp[src] = (1ll*dp[par]*(long long)graph[par].size()), dist[src] = dist[par] + 1;\\n        else dp[src] = (1ll * dp[par] * ((long long)graph[par].size()-1)), dist[src] = dist[par] + 1;\\n        for(auto neigh : graph[src]){\\n            if(neigh != par){\\n                dfs(neigh, src);\\n            }\\n        }\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edge, int t, int tar) {\\n        graph = vector<vector<int>> (n+1);\\n        dp = dist = vector<long long> (n+1);\\n        for(int i=0;i<n-1;i++){\\n            int x = edge[i][0], y = edge[i][1];\\n            graph[x].push_back(y);\\n            graph[y].push_back(x);\\n        }\\n        vector<bool> leaf(n+1);\\n        for(int i=2;i<=n;i++){\\n            if((int)graph[i].size() <= 1){\\n                leaf[i] = true;\\n            }\\n        }\\n        if(n == 1) return 1;\\n        dfs(1, 0);\\n        if(dist[tar] > t) return 0;\\n        else{\\n            if(dist[tar] == t){\\n                long double ans = ((long double)1/dp[tar]);\\n                return ans;\\n            }\\n            else{\\n                if(!leaf[tar]){\\n                    return 0;\\n                }\\n                else{\\n                    long double ans = ((long double)1/dp[tar]);\\n                    return ans;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886966,
                "title": "kotlin-solution-using-dfs-beats-100",
                "content": "# Intuition\\nWe will use Depth-First Search (DFS) to solve this problem. \\n\\n# Approach\\nConvert the edges into an adjacency list to represent the tree.\\nInitialize a probability array with 1 at the starting vertex.\\nPerform DFS to calculate the probability for each vertex at each time step up to t.\\nReturn the probability for the target vertex after t seconds.\\n\\n# Complexity\\n- Time complexity:\\nO(n+t), where  n is the number of vertices and  t is the given time.\\n\\n- Space complexity:\\nO(n), for storing the adjacency list and probabilities.\\n\\n# Code\\n```\\nclass Solution {\\n    fun frogPosition(n: Int, edges: Array<IntArray>, t: Int, target: Int): Double {\\n        val adjList = Array<MutableList<Int>>(n) { mutableListOf() }\\n        for (edge in edges) {\\n            adjList[edge[0] - 1].add(edge[1] - 1)\\n            adjList[edge[1] - 1].add(edge[0] - 1)\\n        }\\n\\n        val prob = DoubleArray(n)\\n        prob[0] = 1.0\\n\\n        fun dfs(node: Int, parent: Int, time: Int) {\\n            if (time == t || adjList[node].size == 1 && node != 0) {\\n                return\\n            }\\n            val totalNeighbors = if (node == 0) adjList[node].size else adjList[node].size - 1\\n            val nextProb = prob[node] / totalNeighbors\\n            for (neighbor in adjList[node]) {\\n                if (neighbor == parent) continue\\n                prob[neighbor] = nextProb\\n                dfs(neighbor, node, time + 1)\\n                prob[node] -= nextProb\\n            }\\n        }\\n\\n        dfs(0, -1, 0)\\n        return prob[target - 1]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun frogPosition(n: Int, edges: Array<IntArray>, t: Int, target: Int): Double {\\n        val adjList = Array<MutableList<Int>>(n) { mutableListOf() }\\n        for (edge in edges) {\\n            adjList[edge[0] - 1].add(edge[1] - 1)\\n            adjList[edge[1] - 1].add(edge[0] - 1)\\n        }\\n\\n        val prob = DoubleArray(n)\\n        prob[0] = 1.0\\n\\n        fun dfs(node: Int, parent: Int, time: Int) {\\n            if (time == t || adjList[node].size == 1 && node != 0) {\\n                return\\n            }\\n            val totalNeighbors = if (node == 0) adjList[node].size else adjList[node].size - 1\\n            val nextProb = prob[node] / totalNeighbors\\n            for (neighbor in adjList[node]) {\\n                if (neighbor == parent) continue\\n                prob[neighbor] = nextProb\\n                dfs(neighbor, node, time + 1)\\n                prob[node] -= nextProb\\n            }\\n        }\\n\\n        dfs(0, -1, 0)\\n        return prob[target - 1]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853249,
                "title": "very-very-very-very-easy-to-understand",
                "content": "# Intuition\\nAs the constraints are low so we should think about dp\\n\\n# Approach\\nsee all possiblitiy and store the ans in dp\\n\\n# Complexity\\n- Time complexity:\\nO(n*n*t)\\n\\n- Space complexity:\\nsc is and as tc\\n\\n# Code\\n```\\n#define ll long double\\nclass Solution {\\n    vector<int>adj[101];\\n    ll dp[101][101][51];\\n    int m_t,target;\\n\\n    ll dfs(int src,int par,int t){\\n        if(t==m_t){\\n            return (src==target);\\n        }\\n        if(t>m_t) return 0;\\n        if(dp[src][par][t]!=-1) return dp[src][par][t];\\n        ll ans=0;\\n        ll cnt=0;\\n        for(auto ne:adj[src]){\\n            if(ne==par) continue;\\n            ans+=dfs(ne,src,t+1);\\n            cnt++;\\n        }\\n        if(src==target and cnt==0) return dp[src][par][t]=1;\\n        if(cnt>0) ans/=cnt;\\n        return dp[src][par][t]=ans;\\n    }\\n\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        memset(dp,-1,sizeof dp);\\n        m_t=t;\\n        this->target=target;\\n        for(int i=0;i<101;i++)\\n            for(int j=0;j<101;j++)\\n                for(int k=0;k<51;k++)\\n                    dp[i][j][k]=-1;\\n        for(int i=0;i<101;i++) adj[i].clear();\\n        for(auto t:edges){\\n            int u=t[0],v=t[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        ll ans=dfs(1,1,0);\\n        return ans;\\n    }           \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long double\\nclass Solution {\\n    vector<int>adj[101];\\n    ll dp[101][101][51];\\n    int m_t,target;\\n\\n    ll dfs(int src,int par,int t){\\n        if(t==m_t){\\n            return (src==target);\\n        }\\n        if(t>m_t) return 0;\\n        if(dp[src][par][t]!=-1) return dp[src][par][t];\\n        ll ans=0;\\n        ll cnt=0;\\n        for(auto ne:adj[src]){\\n            if(ne==par) continue;\\n            ans+=dfs(ne,src,t+1);\\n            cnt++;\\n        }\\n        if(src==target and cnt==0) return dp[src][par][t]=1;\\n        if(cnt>0) ans/=cnt;\\n        return dp[src][par][t]=ans;\\n    }\\n\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        memset(dp,-1,sizeof dp);\\n        m_t=t;\\n        this->target=target;\\n        for(int i=0;i<101;i++)\\n            for(int j=0;j<101;j++)\\n                for(int k=0;k<51;k++)\\n                    dp[i][j][k]=-1;\\n        for(int i=0;i<101;i++) adj[i].clear();\\n        for(auto t:edges){\\n            int u=t[0],v=t[1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        ll ans=dfs(1,1,0);\\n        return ans;\\n    }           \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848324,
                "title": "c-easy",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        double ans=0.0;\\n        vector<vector<int>> graph(n+1);\\n        for(auto edge:edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        vector<bool> visited(n+1,false);\\n        queue<pair<int,double>> q;\\n        q.push({1,1.0});\\n        while(t--){\\n            int s=q.size();\\n            while(s--){\\n            auto [node,result]=q.front();\\n            q.pop();\\n            visited[node]=true;\\n            double size;\\n            if(node==1)size=graph[node].size();\\n            else size=graph[node].size()-1;\\n            for(auto it:graph[node]){\\n                if(!visited[it]){\\n                    double val=(1.0/size)*result;\\n                    if(it==target && t==0)return val;\\n                    if(it==target && graph[it].size()==1)ans=val;\\n                    q.push({it,val});\\n                }\\n            }\\n            }\\n        }\\n        if(n==1)return 1.0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        double ans=0.0;\\n        vector<vector<int>> graph(n+1);\\n        for(auto edge:edges){\\n            graph[edge[0]].push_back(edge[1]);\\n            graph[edge[1]].push_back(edge[0]);\\n        }\\n        vector<bool> visited(n+1,false);\\n        queue<pair<int,double>> q;\\n        q.push({1,1.0});\\n        while(t--){\\n            int s=q.size();\\n            while(s--){\\n            auto [node,result]=q.front();\\n            q.pop();\\n            visited[node]=true;\\n            double size;\\n            if(node==1)size=graph[node].size();\\n            else size=graph[node].size()-1;\\n            for(auto it:graph[node]){\\n                if(!visited[it]){\\n                    double val=(1.0/size)*result;\\n                    if(it==target && t==0)return val;\\n                    if(it==target && graph[it].size()==1)ans=val;\\n                    q.push({it,val});\\n                }\\n            }\\n            }\\n        }\\n        if(n==1)return 1.0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828041,
                "title": "bfs-based-appraoch-that-beats-95-of-all-the-entries-pyhton-3-solution",
                "content": "# Intuition\\nLooking at the question the first thing that strikes is a level order traversal of the graph and based on this the answer will be calculated\\n# Approach\\nDoing a Normal BFS wont work here\\n\\nOne of the most important lines is this questions is that whenever our frog reachs to target node and if there is more time buffer left then along with this node being a leaf then we can stay at the same place till the time elapses\\n\\nAlso is this is not the case then we go ahead with the normal BFS related works\\n# Complexity\\n- Time complexity:\\nHere The Time Complexity is O(N) as each node is being visited only once\\n\\n- Space complexity:\\nSpace Complexity is also O(2*N) as only a visitedArray and a queue is being used\\n# Code\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        \\n\\n        graphDict = {}\\n        for i in range(1,n+1):\\n            graphDict[i] = []\\n\\n        for ele in edges:\\n            graphDict[ele[0]].append(ele[1])\\n            graphDict[ele[1]].append(ele[0])\\n\\n        queueArray = []\\n        queueArray.append([1,1,0])\\n        visitedArray = [False for i in range(n+1)]\\n\\n        while queueArray:\\n\\n            topNode = queueArray.pop(0)\\n            topNodeValue , topNodeProb , time = topNode\\n            visitedArray[topNodeValue] = True\\n\\n            if topNodeValue==target and time==t:\\n                return topNodeProb\\n            if topNodeValue==target and time<=t:\\n                totalChildren = 0\\n                for adjNode in graphDict[topNodeValue]:\\n                    if visitedArray[adjNode] is False:\\n                        totalChildren+=1\\n                if totalChildren==0:\\n                    return topNodeProb\\n\\n            totalChildren = 0\\n            for adjNode in graphDict[topNodeValue]:\\n                if visitedArray[adjNode] is False:\\n                    totalChildren+=1\\n            if totalChildren==0:\\n                newProb = 0\\n            else:\\n                newProb = topNodeProb/totalChildren\\n\\n            for adjNode in graphDict[topNodeValue]:\\n                if visitedArray[adjNode] is False:\\n                    queueArray.append([adjNode,newProb,time+1])\\n\\n        return 0\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        \\n\\n        graphDict = {}\\n        for i in range(1,n+1):\\n            graphDict[i] = []\\n\\n        for ele in edges:\\n            graphDict[ele[0]].append(ele[1])\\n            graphDict[ele[1]].append(ele[0])\\n\\n        queueArray = []\\n        queueArray.append([1,1,0])\\n        visitedArray = [False for i in range(n+1)]\\n\\n        while queueArray:\\n\\n            topNode = queueArray.pop(0)\\n            topNodeValue , topNodeProb , time = topNode\\n            visitedArray[topNodeValue] = True\\n\\n            if topNodeValue==target and time==t:\\n                return topNodeProb\\n            if topNodeValue==target and time<=t:\\n                totalChildren = 0\\n                for adjNode in graphDict[topNodeValue]:\\n                    if visitedArray[adjNode] is False:\\n                        totalChildren+=1\\n                if totalChildren==0:\\n                    return topNodeProb\\n\\n            totalChildren = 0\\n            for adjNode in graphDict[topNodeValue]:\\n                if visitedArray[adjNode] is False:\\n                    totalChildren+=1\\n            if totalChildren==0:\\n                newProb = 0\\n            else:\\n                newProb = topNodeProb/totalChildren\\n\\n            for adjNode in graphDict[topNodeValue]:\\n                if visitedArray[adjNode] is False:\\n                    queueArray.append([adjNode,newProb,time+1])\\n\\n        return 0\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825678,
                "title": "c-simple-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int> edges[103];\\n    double prob[103];\\n    int depth[103];\\n    void dfs(int s, int p) {\\n        if(p != -1) {\\n            int nChilds = edges[p].size();\\n            if(p != 1) nChilds--;\\n            prob[s] = prob[p] * (1.0 / nChilds);\\n        }\\n        for(auto v: edges[s]) {\\n            if(v == p) continue;\\n            depth[v] = depth[s] + 1;\\n            dfs(v, s);\\n        }\\n    }\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edge, int t, int target) {\\n        for(int i = 0; i < n - 1; i++) {\\n            edges[edge[i][0]].push_back(edge[i][1]);\\n            edges[edge[i][1]].push_back(edge[i][0]);\\n        }\\n        prob[1] = 1;\\n        depth[1] = 0;\\n        dfs(1, -1);\\n        if(depth[target] < t) {\\n            if((target == 1 && edges[target].size() == 0) || (target != 1 && edges[target].size() == 1)) {\\n                return prob[target];\\n            } else {\\n                return 0;\\n            }\\n        }\\n        \\n        return depth[target] > t ? 0 : prob[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int> edges[103];\\n    double prob[103];\\n    int depth[103];\\n    void dfs(int s, int p) {\\n        if(p != -1) {\\n            int nChilds = edges[p].size();\\n            if(p != 1) nChilds--;\\n            prob[s] = prob[p] * (1.0 / nChilds);\\n        }\\n        for(auto v: edges[s]) {\\n            if(v == p) continue;\\n            depth[v] = depth[s] + 1;\\n            dfs(v, s);\\n        }\\n    }\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edge, int t, int target) {\\n        for(int i = 0; i < n - 1; i++) {\\n            edges[edge[i][0]].push_back(edge[i][1]);\\n            edges[edge[i][1]].push_back(edge[i][0]);\\n        }\\n        prob[1] = 1;\\n        depth[1] = 0;\\n        dfs(1, -1);\\n        if(depth[target] < t) {\\n            if((target == 1 && edges[target].size() == 0) || (target != 1 && edges[target].size() == 1)) {\\n                return prob[target];\\n            } else {\\n                return 0;\\n            }\\n        }\\n        \\n        return depth[target] > t ? 0 : prob[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3792820,
                "title": "simple-bfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<int>deg(n+1,-1);\\n        deg[1]=0;\\n        vector<int>adj[n+1];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            deg[edges[i][0]]++;\\n            deg[edges[i][1]]++;\\n        }\\n        queue<pair<double,pair<int,int>>>q;\\n        q.push({1,{1,0}});\\n        vector<int>vis(n+1,0);\\n        while(!q.empty())\\n        {\\n           int node=q.front().second.first;\\n           double prod=q.front().first;\\n           int time=q.front().second.second;\\n           q.pop();\\n           if(time>t)\\n           continue;\\n           if(node==target)\\n           {   if(time==t)\\n               return prod;\\n               else \\n               {\\n                   if(deg[target])\\n                   return 0;\\n                   else\\n                   return prod;\\n               }\\n           }\\n           vis[node]=1;\\n           for(auto it:adj[node])\\n           {\\n               if(!vis[it])\\n               {\\n                   q.push({(prod*1)/deg[node],{it,time+1}});\\n               }\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<int>deg(n+1,-1);\\n        deg[1]=0;\\n        vector<int>adj[n+1];\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n            deg[edges[i][0]]++;\\n            deg[edges[i][1]]++;\\n        }\\n        queue<pair<double,pair<int,int>>>q;\\n        q.push({1,{1,0}});\\n        vector<int>vis(n+1,0);\\n        while(!q.empty())\\n        {\\n           int node=q.front().second.first;\\n           double prod=q.front().first;\\n           int time=q.front().second.second;\\n           q.pop();\\n           if(time>t)\\n           continue;\\n           if(node==target)\\n           {   if(time==t)\\n               return prod;\\n               else \\n               {\\n                   if(deg[target])\\n                   return 0;\\n                   else\\n                   return prod;\\n               }\\n           }\\n           vis[node]=1;\\n           for(auto it:adj[node])\\n           {\\n               if(!vis[it])\\n               {\\n                   q.push({(prod*1)/deg[node],{it,time+1}});\\n               }\\n           }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752685,
                "title": "c-striver-sde-sheet-bfs-easy",
                "content": "# Intuition\\nKeep in mind .. If we are at target node we have to check whether we can move further to other direct connected unvisited nodes , if yes then prob will be zero and if No then return prod . one more condition if we are at target and we can move further but we dont have time stamp we will return ans.\\n\\n# Approach\\nSimple BFS with some modification\\n\\n# Complexity\\n- Time complexity:\\nO(n+e)\\n\\n- Space complexity:\\nO(2n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n       priority_queue<pair<int,pair<int,double>>,vector<pair<int,pair<int,double>>>,greater<pair<int,pair<int,double>>>> pq;\\n\\n       vector<vector<int>> adj(n+1);\\n      \\n       vector<bool> visited(n+1,0);\\n       for(auto it : edges)\\n       {\\n           int u=it[0];\\n           int v=it[1];\\n\\n           adj[u].push_back(v);\\n           adj[v].push_back(u);\\n\\n          \\n       }\\n\\n       pq.push({0,{1,1.0}});\\n       visited[1]=1;\\n\\n       while(!pq.empty())\\n       {\\n           auto front=pq.top();\\n           pq.pop();\\n           int time=front.first;\\n           int node=front.second.first;\\n           double prob=front.second.second;\\n\\n           //it will calculate child\\n double child=0;\\nfor(auto neg : adj[node])\\n{\\n    if(!visited[neg])\\n               {\\n                   child++;\\n               } \\n}\\n           if(node==target && time<=t && child==0){\\n               \\n               return prob;\\n           }\\n           if(node==target && time==t && child!=0)\\n           return prob;\\n          \\n\\n           if(time >=t)\\n           continue;\\n        \\n           for(auto neg : adj[node])\\n           {\\n               \\n               if(!visited[neg])\\n               {\\n                   int newtime=time+1;\\n                   \\n                  \\n                   \\n                   pq.push({newtime,{neg,prob*1/child}});\\n                   visited[neg]=1;\\n               }\\n           }\\n       }\\nreturn 0.0000;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n       priority_queue<pair<int,pair<int,double>>,vector<pair<int,pair<int,double>>>,greater<pair<int,pair<int,double>>>> pq;\\n\\n       vector<vector<int>> adj(n+1);\\n      \\n       vector<bool> visited(n+1,0);\\n       for(auto it : edges)\\n       {\\n           int u=it[0];\\n           int v=it[1];\\n\\n           adj[u].push_back(v);\\n           adj[v].push_back(u);\\n\\n          \\n       }\\n\\n       pq.push({0,{1,1.0}});\\n       visited[1]=1;\\n\\n       while(!pq.empty())\\n       {\\n           auto front=pq.top();\\n           pq.pop();\\n           int time=front.first;\\n           int node=front.second.first;\\n           double prob=front.second.second;\\n\\n           //it will calculate child\\n double child=0;\\nfor(auto neg : adj[node])\\n{\\n    if(!visited[neg])\\n               {\\n                   child++;\\n               } \\n}\\n           if(node==target && time<=t && child==0){\\n               \\n               return prob;\\n           }\\n           if(node==target && time==t && child!=0)\\n           return prob;\\n          \\n\\n           if(time >=t)\\n           continue;\\n        \\n           for(auto neg : adj[node])\\n           {\\n               \\n               if(!visited[neg])\\n               {\\n                   int newtime=time+1;\\n                   \\n                  \\n                   \\n                   pq.push({newtime,{neg,prob*1/child}});\\n                   visited[neg]=1;\\n               }\\n           }\\n       }\\nreturn 0.0000;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749403,
                "title": "readable-code-dfs-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLet\\'s Use DFS and find the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse through all the nodes and also calculating time taken and probability at each position, once target is found return answer.\\nSee the code you will understand.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n`V -> Vertices` `E -> Edges`\\n\\n    O(V + E) + O(E)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(V + E)\\n\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int node, int target, vector<int> & vis, vector<int> adj[], double & prob, double & ans, int & time, int t){\\n        vis[node] = 1;\\n        double count = 0; // to calculate probability\\n        for(auto it: adj[node]){\\n            if(!vis[it]) count++;\\n        }\\n        if(count == 0) return;\\n        prob *= (1/count);\\n        time++;\\n        for(auto it: adj[node]){\\n            if(!vis[it]) {\\n                if(it == target && time == t){\\n                    ans = prob;\\n                    return;\\n                }\\n                else if (it == target && time < t){\\n                    if(adj[it].size() == 1){ // Last Node with only parent\\n                        ans = prob;\\n                        return;\\n                    }\\n                }\\n                dfs(it, target, vis, adj, prob, ans, time, t);\\n            }\\n        }\\n        time--; // while backtracking / returning.\\n        prob /= (1/count); // while backtracking\\n    }\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        if(n==1) return 1;\\n        double prob = 1, ans;\\n        int time = 0;\\n        vector<int> adj[n+1];\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> vis(n+1, 0);\\n        dfs(1, target, vis, adj, prob, ans, time, t);\\n        if(time == 0) return 0; // if target is not found\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(int node, int target, vector<int> & vis, vector<int> adj[], double & prob, double & ans, int & time, int t){\\n        vis[node] = 1;\\n        double count = 0; // to calculate probability\\n        for(auto it: adj[node]){\\n            if(!vis[it]) count++;\\n        }\\n        if(count == 0) return;\\n        prob *= (1/count);\\n        time++;\\n        for(auto it: adj[node]){\\n            if(!vis[it]) {\\n                if(it == target && time == t){\\n                    ans = prob;\\n                    return;\\n                }\\n                else if (it == target && time < t){\\n                    if(adj[it].size() == 1){ // Last Node with only parent\\n                        ans = prob;\\n                        return;\\n                    }\\n                }\\n                dfs(it, target, vis, adj, prob, ans, time, t);\\n            }\\n        }\\n        time--; // while backtracking / returning.\\n        prob /= (1/count); // while backtracking\\n    }\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        if(n==1) return 1;\\n        double prob = 1, ans;\\n        int time = 0;\\n        vector<int> adj[n+1];\\n        for(auto it : edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        vector<int> vis(n+1, 0);\\n        dfs(1, target, vis, adj, prob, ans, time, t);\\n        if(time == 0) return 0; // if target is not found\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3717932,
                "title": "simple-bfs-with-modifications",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n     unordered_map<int,unordered_set<int>> adj;\\n        \\n        for(auto i:edges){\\n            adj[i[0]].insert(i[1]);\\n            adj[i[1]].insert(i[0]);\\n        }\\n        \\n        queue<pair<int,double>> q;\\n        \\n        q.push({1,1.00});\\n        \\n        int steps=0;\\n        \\n        while(!q.empty()){\\n            int size=q.size();\\n            \\n            if(steps>t)\\n                break;\\n            \\n            while(size--){\\n                int node =q.front().first;\\n                double prob=q.front().second;\\n                q.pop();\\n                \\n                if(node==target&&steps==t)\\n                    return prob;\\n                \\n                int s=adj[node].size();\\n                \\n        //        cout<<s;\\n             \\n                if(s==0)\\n                    q.push({node,prob});\\n                else{\\n                   \\n                   while(!adj[node].empty()){\\n                       int i=*(adj[node].begin());\\n                       q.push({i,prob*(1.0/s)});\\n                    \\n                       \\n                       adj[node].erase(i);\\n                       adj[i].erase(node);\\n                   }\\n                }\\n                \\n                \\n            }\\n            steps++;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n     unordered_map<int,unordered_set<int>> adj;\\n        \\n        for(auto i:edges){\\n            adj[i[0]].insert(i[1]);\\n            adj[i[1]].insert(i[0]);\\n        }\\n        \\n        queue<pair<int,double>> q;\\n        \\n        q.push({1,1.00});\\n        \\n        int steps=0;\\n        \\n        while(!q.empty()){\\n            int size=q.size();\\n            \\n            if(steps>t)\\n                break;\\n            \\n            while(size--){\\n                int node =q.front().first;\\n                double prob=q.front().second;\\n                q.pop();\\n                \\n                if(node==target&&steps==t)\\n                    return prob;\\n                \\n                int s=adj[node].size();\\n                \\n        //        cout<<s;\\n             \\n                if(s==0)\\n                    q.push({node,prob});\\n                else{\\n                   \\n                   while(!adj[node].empty()){\\n                       int i=*(adj[node].begin());\\n                       q.push({i,prob*(1.0/s)});\\n                    \\n                       \\n                       adj[node].erase(i);\\n                       adj[i].erase(node);\\n                   }\\n                }\\n                \\n                \\n            }\\n            steps++;\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3703824,
                "title": "c-one-pass-commented",
                "content": "```\\n#define pii pair<double,pair<int,int>>\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target)\\n    {\\n        vector<vector<int>>adj(n+1);\\n        for(auto &e:edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        // add a dummy node for easier calculation\\n        adj[0].push_back(1);\\n        adj[1].push_back(0);\\n        \\n        queue<pii>q;\\n        q.push({1.0,{1,0}}); // prob node parent\\n        int currTime=0;   \\n        \\n        while(!q.empty())\\n        {\\n            int k=q.size();\\n            while(k--)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                \\n                // there is prob probablity of being on currNode at time currTime\\n                // we have to answer probablity of being on currNode at time t\\n                \\n                double prob=p.first;\\n                int node=p.second.first;\\n                int parent=p.second.second;\\n                \\n                if(node==target)\\n                {\\n                    if(currTime>t)\\n                    return 0.0; // we can reach the node as early as currTime but time alloted is less than that\\n                    \\n                    if(currTime==t)\\n                        return prob;\\n                    if(currTime<t)\\n                        return adj[node].size()==1?prob:0.0; // we may be stuck here if adj is empty \\n                }\\n                double sz=(double)adj[node].size()-1.0; //( will not include parent)\\n                for(auto v:adj[node])\\n                {\\n                    if(v!=parent)\\n                    {\\n                        q.push({prob/sz,{v,node}});\\n                    }\\n                }\\n            }\\n            \\n            currTime++;\\n        }\\n        \\n        return 0.0; \\n    }\\n\\t```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n#define pii pair<double,pair<int,int>>\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target)\\n    {\\n        vector<vector<int>>adj(n+1);\\n        for(auto &e:edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        // add a dummy node for easier calculation\\n        adj[0].push_back(1);\\n        adj[1].push_back(0);\\n        \\n        queue<pii>q;\\n        q.push({1.0,{1,0}}); // prob node parent\\n        int currTime=0;   \\n        \\n        while(!q.empty())\\n        {\\n            int k=q.size();\\n            while(k--)\\n            {\\n                auto p=q.front();\\n                q.pop();\\n                \\n                // there is prob probablity of being on currNode at time currTime\\n                // we have to answer probablity of being on currNode at time t\\n                \\n                double prob=p.first;\\n                int node=p.second.first;\\n                int parent=p.second.second;\\n                \\n                if(node==target)\\n                {\\n                    if(currTime>t)\\n                    return 0.0; // we can reach the node as early as currTime but time alloted is less than that\\n                    \\n                    if(currTime==t)\\n                        return prob;\\n                    if(currTime<t)\\n                        return adj[node].size()==1?prob:0.0; // we may be stuck here if adj is empty \\n                }\\n                double sz=(double)adj[node].size()-1.0; //( will not include parent)\\n                for(auto v:adj[node])\\n                {\\n                    if(v!=parent)\\n                    {\\n                        q.push({prob/sz,{v,node}});\\n                    }\\n                }\\n            }\\n            \\n            currTime++;\\n        }\\n        \\n        return 0.0; \\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3701129,
                "title": "c-easy-bfs-solution-code",
                "content": "# C++ easy BFS solution\\u2714\\u2714`code` \\n\\n---\\n\\nEasy C++ BFS approach\\uD83D\\uDE4F with explaination.\\n\\n---\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Step by step explaination\\uD83D\\uDE4F\\n- First create a graph of the given tree(create a adj list of the given tree).\\n- Use BFS approach to traverse .\\n- Decrement time at each level so that in case ,if it is not able to reach at destination in limited period of time then the prob of getting reach will be zero at destination.\\n- Use a mapping  where you to have to tick when you reached so that u will not again move back at that position.\\n- On doing these all process you will fail in a case- i.e When time is grater than needed and there is further next after a target then at that case frog will jump next to it . Therefor we must need to make our prob zero after jumping from a posititon because after t time frog cann\\'t stand on target. frog will jump next to it.**\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        unordered_map<int,double>prob;\\n        unordered_map<int,vector<int>>adj;\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        prob[1]=1;\\n       queue<int>q;\\n       q.push(1);\\n       unordered_map<int,bool>seen;\\n       seen[1]=true;\\n       while(!q.empty() and t-->0){\\n           int l=q.size();\\n           for(int i=0;i<l;i++){\\n            int curr=q.front();\\n            q.pop();\\n            auto v=adj[curr];\\n            double count=0.0;\\n            double currProb=prob[curr];\\n            for(auto it:v){\\n                if(!seen[it])count+=1.0;\\n            }\\n          for(auto it:v){\\n              if(!seen[it]){\\n              if(count)\\n              prob[it]=(1/count)*currProb*1.0;\\n              q.push(it);\\n              seen[it]=true;}\\n          }\\n          if(count>0)prob[curr]=0;\\n          }\\n        }\\n        return prob[target];\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        unordered_map<int,double>prob;\\n        unordered_map<int,vector<int>>adj;\\n        for(auto it:edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3693401,
                "title": "easy-to-understand-well-commented",
                "content": "# Code\\n```\\n/*\\n    TC : O(V+E+log(V))  ~  O(V+E)\\n    SC : O(V)\\n*/\\n\\nclass Solution {\\npublic:\\n    void dfs(int node,int p,vector<vector<int>> &g,vector<int> &par,vector<bool> &vis) {\\n        \\n        par[node] = p;\\n        vis[node] = true;\\n\\n        for(auto &it : g[node]) {\\n            if(!vis[it])\\n                dfs(it,node,g,par,vis);\\n        }\\n    }\\n\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n\\n        if(n == 1) return 1.0;\\n        if(target == 1) return 0.0;\\n\\n        vector<vector<int>> g(n+1);\\n        for(auto &it : edges) {\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n\\n        vector<int> par(n+1);\\n        vector<bool> vis(n+1,0);\\n        dfs(1,-1,g,par,vis);         // find the parent of each node\\n\\n        if(!vis[target]) return 0.0;      // target not reachable\\n\\n        // start traversing the path from target to node and find the probability at each level,\\n        // using the formula p = r/n (here r is 1 always)\\n        int curr = par[target];\\n        double ans = 1.0;\\n        while(1) {\\n            t--;\\n            if(curr == 1) {\\n                double N = g[1].size();        // 1 is root, it doesn\\'t have any parent\\n                ans *= 1.0/N;\\n                break;\\n            } else {\\n                double N = g[curr].size()-1;     // include only child & exclude the parent of curr\\n                ans *= 1.0/N;\\n            }\\n            curr = par[curr];\\n        }\\n        \\n        // either the at the target node time should equal the zero or it it\\'s greater than 0\\n        // then the target node must be the leaf node so that frog would get freezed\\n        return ((t == 0 || (t > 0 && g[target].size() == 1)) ? ans : 0.0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n/*\\n    TC : O(V+E+log(V))  ~  O(V+E)\\n    SC : O(V)\\n*/\\n\\nclass Solution {\\npublic:\\n    void dfs(int node,int p,vector<vector<int>> &g,vector<int> &par,vector<bool> &vis) {\\n        \\n        par[node] = p;\\n        vis[node] = true;\\n\\n        for(auto &it : g[node]) {\\n            if(!vis[it])\\n                dfs(it,node,g,par,vis);\\n        }\\n    }\\n\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n\\n        if(n == 1) return 1.0;\\n        if(target == 1) return 0.0;\\n\\n        vector<vector<int>> g(n+1);\\n        for(auto &it : edges) {\\n            g[it[0]].push_back(it[1]);\\n            g[it[1]].push_back(it[0]);\\n        }\\n\\n        vector<int> par(n+1);\\n        vector<bool> vis(n+1,0);\\n        dfs(1,-1,g,par,vis);         // find the parent of each node\\n\\n        if(!vis[target]) return 0.0;      // target not reachable\\n\\n        // start traversing the path from target to node and find the probability at each level,\\n        // using the formula p = r/n (here r is 1 always)\\n        int curr = par[target];\\n        double ans = 1.0;\\n        while(1) {\\n            t--;\\n            if(curr == 1) {\\n                double N = g[1].size();        // 1 is root, it doesn\\'t have any parent\\n                ans *= 1.0/N;\\n                break;\\n            } else {\\n                double N = g[curr].size()-1;     // include only child & exclude the parent of curr\\n                ans *= 1.0/N;\\n            }\\n            curr = par[curr];\\n        }\\n        \\n        // either the at the target node time should equal the zero or it it\\'s greater than 0\\n        // then the target node must be the leaf node so that frog would get freezed\\n        return ((t == 0 || (t > 0 && g[target].size() == 1)) ? ans : 0.0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3689764,
                "title": "bfs",
                "content": "``` \\nclass Pair{\\n    int a,t;\\n    double b;\\n    Pair(int a,double b,int t)\\n    {\\n        this.a=a;\\n        this.b=b;\\n        this.t=t;\\n    }\\n}\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        double ans=0.0;\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<=n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int[] vis=new int[n+1];\\n        Arrays.fill(vis,-1);\\n        Queue<Pair> q=new LinkedList<>();\\n        q.offer(new Pair(1,1.0,t));\\n        while(!q.isEmpty())\\n        {\\n            Pair node=q.poll();\\n            vis[node.a]=1;\\n            \\n            if(node.a==target && node.t>0)\\n            {\\n                boolean checkVisited=true;\\n                for(int i=0;i<adj.get(node.a).size();i++)\\n                {\\n                    if(vis[adj.get(node.a).get(i)]==-1)\\n                    {\\n                        //System.out.println(vis[adj.get(node.a).get(i)]);\\n                        checkVisited=false;\\n                        break;\\n                    }\\n                }\\n                //System.out.println(Arrays.toString(vis));\\n                if(checkVisited)\\n                {\\n                    return node.b;\\n                }\\n                else\\n                {\\n                    return 0.0;\\n                }\\n            }\\n            else if(node.a==target && node.t==0)\\n            {\\n                return node.b;\\n            }\\n            else if(node.a==target)\\n            {\\n                return 0.0;\\n            }\\n             //System.out.println(node.b);\\n            double curPro=node.b;\\n            int count=0;\\n            for(int i=0;i<adj.get(node.a).size();i++)\\n            {\\n                if(vis[adj.get(node.a).get(i)]==-1)\\n                {\\n                    count++;\\n                }\\n            }\\n            for(int i=0;i<adj.get(node.a).size();i++)\\n            {\\n                if(vis[adj.get(node.a).get(i)]!=-1)\\n                {\\n                    continue;\\n                }\\n                q.offer(new Pair(adj.get(node.a).get(i),curPro*((double)1.0/(double)count),node.t-1));\\n\\n            }\\n            \\n        }\\n        return 0.0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "``` \\nclass Pair{\\n    int a,t;\\n    double b;\\n    Pair(int a,double b,int t)\\n    {\\n        this.a=a;\\n        this.b=b;\\n        this.t=t;\\n    }\\n}\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        double ans=0.0;\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<=n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n        }\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]).add(edges[i][1]);\\n            adj.get(edges[i][1]).add(edges[i][0]);\\n        }\\n        int[] vis=new int[n+1];\\n        Arrays.fill(vis,-1);\\n        Queue<Pair> q=new LinkedList<>();\\n        q.offer(new Pair(1,1.0,t));\\n        while(!q.isEmpty())\\n        {\\n            Pair node=q.poll();\\n            vis[node.a]=1;\\n            \\n            if(node.a==target && node.t>0)\\n            {\\n                boolean checkVisited=true;\\n                for(int i=0;i<adj.get(node.a).size();i++)\\n                {\\n                    if(vis[adj.get(node.a).get(i)]==-1)\\n                    {\\n                        //System.out.println(vis[adj.get(node.a).get(i)]);\\n                        checkVisited=false;\\n                        break;\\n                    }\\n                }\\n                //System.out.println(Arrays.toString(vis));\\n                if(checkVisited)\\n                {\\n                    return node.b;\\n                }\\n                else\\n                {\\n                    return 0.0;\\n                }\\n            }\\n            else if(node.a==target && node.t==0)\\n            {\\n                return node.b;\\n            }\\n            else if(node.a==target)\\n            {\\n                return 0.0;\\n            }\\n             //System.out.println(node.b);\\n            double curPro=node.b;\\n            int count=0;\\n            for(int i=0;i<adj.get(node.a).size();i++)\\n            {\\n                if(vis[adj.get(node.a).get(i)]==-1)\\n                {\\n                    count++;\\n                }\\n            }\\n            for(int i=0;i<adj.get(node.a).size();i++)\\n            {\\n                if(vis[adj.get(node.a).get(i)]!=-1)\\n                {\\n                    continue;\\n                }\\n                q.offer(new Pair(adj.get(node.a).get(i),curPro*((double)1.0/(double)count),node.t-1));\\n\\n            }\\n            \\n        }\\n        return 0.0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3668493,
                "title": "clean-code-simple-bfs-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. Initially starting with node as 1.\\n2. Now parallel move to its children nodes and calculating probability {**currProbabilty * (1/currChildCnt Which are not visited)**} and increasing time also.\\n3. If at any point **node == target** , so we just check whether currTime > target time so return 0;\\n4. Else currTime == target time  or (currTime < TargetTime && childCnt == 0) , means you reached the node at exact time or reached earlier but no further children left to move.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N + E ) ~ O(N) as E = n-1\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Container{\\n\\npublic:\\n    int nodeVal;\\n    double p;\\n    int time;\\n\\n    Container(int x , double y , int z){\\n        nodeVal = x;\\n        p = y;\\n        time = z;\\n    }\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        \\n        // First create an adjacency list\\n\\n        vector <int> adj[n+1];\\n\\n        vector <int> visited(n+1,0); //. mark intitaly all as unvisited\\n\\n        for(auto &vec : edges){\\n\\n            int u = vec[0];\\n            int v = vec[1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n\\n        }\\n\\n        \\n        queue < Container* > q;\\n\\n        Node * temp = new Container(1 , 1.00 , 0);\\n        q.push(temp);\\n        visited[1] = 1; // marked the 1 as visited\\n\\n        while(!q.empty()){\\n\\n            auto front = q.front();\\n\\n            int node = front->nodeVal;\\n            double p = front->p;\\n            int time = front->time;\\n\\n            // cout << node << \" \" << (double)p << \" \" << time << endl;\\n\\n            q.pop();\\n\\n            // Now find the no of unvisited children of this given node\\n            double cnt = 0;\\n\\n            for(auto &it : adj[node]){\\n\\n                if(!visited[it]){\\n                    cnt++;\\n                }\\n\\n            }\\n\\n            // First of all check the node is target node or not\\n            if(node == target){\\n\\n                if(time == t) return p;\\n\\n                // reached before and no children or neighbour exsits to move on\\n                else if(time < t and cnt == 0){\\n                    return p;\\n                }\\n\\n                else{\\n                    return 0;\\n                }\\n\\n            }\\n\\n\\n            // Now find the probability to the nodes and increase the time\\n\\n            for(auto &it : adj[node]){\\n\\n                // moving to unvisited node \\n                if(!visited[it]){\\n                    \\n                    visited[it] = 1;\\n\\n                    double newP = (double)p * (1.0/cnt);\\n\\n                    int newT = time+1;\\n\\n                    Node * newContainer = new Container(it , newP , newT);\\n\\n                    q.push(newNode);\\n                }\\n\\n            }\\n\\n\\n\\n        }\\n\\n        return 0;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Container{\\n\\npublic:\\n    int nodeVal;\\n    double p;\\n    int time;\\n\\n    Container(int x , double y , int z){\\n        nodeVal = x;\\n        p = y;\\n        time = z;\\n    }\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        \\n        // First create an adjacency list\\n\\n        vector <int> adj[n+1];\\n\\n        vector <int> visited(n+1,0); //. mark intitaly all as unvisited\\n\\n        for(auto &vec : edges){\\n\\n            int u = vec[0];\\n            int v = vec[1];\\n\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n\\n        }\\n\\n        \\n        queue < Container* > q;\\n\\n        Node * temp = new Container(1 , 1.00 , 0);\\n        q.push(temp);\\n        visited[1] = 1; // marked the 1 as visited\\n\\n        while(!q.empty()){\\n\\n            auto front = q.front();\\n\\n            int node = front->nodeVal;\\n            double p = front->p;\\n            int time = front->time;\\n\\n            // cout << node << \" \" << (double)p << \" \" << time << endl;\\n\\n            q.pop();\\n\\n            // Now find the no of unvisited children of this given node\\n            double cnt = 0;\\n\\n            for(auto &it : adj[node]){\\n\\n                if(!visited[it]){\\n                    cnt++;\\n                }\\n\\n            }\\n\\n            // First of all check the node is target node or not\\n            if(node == target){\\n\\n                if(time == t) return p;\\n\\n                // reached before and no children or neighbour exsits to move on\\n                else if(time < t and cnt == 0){\\n                    return p;\\n                }\\n\\n                else{\\n                    return 0;\\n                }\\n\\n            }\\n\\n\\n            // Now find the probability to the nodes and increase the time\\n\\n            for(auto &it : adj[node]){\\n\\n                // moving to unvisited node \\n                if(!visited[it]){\\n                    \\n                    visited[it] = 1;\\n\\n                    double newP = (double)p * (1.0/cnt);\\n\\n                    int newT = time+1;\\n\\n                    Node * newContainer = new Container(it , newP , newT);\\n\\n                    q.push(newNode);\\n                }\\n\\n            }\\n\\n\\n\\n        }\\n\\n        return 0;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3647524,
                "title": "dfs-solution-with-easy-explanation",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n+edges.size())$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n+edges.size())+O(n)+O(n)+O(n)+O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int target,int h,int node,vector<int>adj[],vector<int>&dfs_vis,int &height){\\n        dfs_vis[node]=1;\\n        if(node==target){\\n            height=h;\\n            return;\\n        }\\n        for(int i=0;i<adj[node].size();i++){\\n            if(dfs_vis[adj[node][i]]==0){\\n                dfs(target,h+1,adj[node][i],adj,dfs_vis,height);\\n            }\\n        }\\n    }\\n    void prob_dfs(int node,int parent,vector<int>adj[],vector<int>&vis,vector<double>&dp,map<int,int>&m){\\n        vis[node]=1;\\n        if(parent==-1){\\n            dp[node]=double(1);\\n        }\\n        else{\\n            dp[node]=dp[parent]*(1/double(m[parent]));\\n        }\\n        for(int i=0;i<adj[node].size();i++){\\n            if(vis[adj[node][i]]==0){\\n                prob_dfs(adj[node][i],node,adj,vis,dp,m);\\n            }\\n        }\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        //store the edges in form of a undirected graph\\n        vector<int>adj[n+1];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        //find the height of target node\\n        vector<int>dfs_vis(n+1,0);\\n        int height;\\n        dfs(target,0,1,adj,dfs_vis,height);\\n        //if height>t then we can never reach the target node in time\\n        if(height>t) return 0.0;\\n        //now we will check if there are more nodes down to target node in graph\\n        bool more_node=false;\\n        for(int i=0;i<adj[target].size();i++){\\n            if(dfs_vis[adj[target][i]]==0){\\n                more_node=true;\\n                break;\\n            }\\n        }\\n        // if there are more nodes down to the target node and the time is greater then height of the target, then we will be forced to move down and we will never be able to move back as it is not allowed therefore we will never be able to reach it in time \"t\" as we have moved down.\\n        if(more_node && t>height) return 0.0;\\n        //now we will find the probability to move to each node in the graph starting from node 1\\n        map<int,int>m;\\n        //number of node to which we can travel from node 1\\n        m[1]=adj[1].size();\\n        for(int i=2;i<=n;i++){\\n            // we have reduced 1 as we can not move to node from which we have come according to question\\n            m[i]=adj[i].size()-1;\\n        }\\n        //now we will store the result in dp\\n        vector<double>dp(n+1,0);\\n        vector<int>vis(n+1,0);\\n        prob_dfs(1,-1,adj,vis,dp,m);\\n        for(int i=1;i<=n;i++){\\n            cout<<dp[i]<<\" \";\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int target,int h,int node,vector<int>adj[],vector<int>&dfs_vis,int &height){\\n        dfs_vis[node]=1;\\n        if(node==target){\\n            height=h;\\n            return;\\n        }\\n        for(int i=0;i<adj[node].size();i++){\\n            if(dfs_vis[adj[node][i]]==0){\\n                dfs(target,h+1,adj[node][i],adj,dfs_vis,height);\\n            }\\n        }\\n    }\\n    void prob_dfs(int node,int parent,vector<int>adj[],vector<int>&vis,vector<double>&dp,map<int,int>&m){\\n        vis[node]=1;\\n        if(parent==-1){\\n            dp[node]=double(1);\\n        }\\n        else{\\n            dp[node]=dp[parent]*(1/double(m[parent]));\\n        }\\n        for(int i=0;i<adj[node].size();i++){\\n            if(vis[adj[node][i]]==0){\\n                prob_dfs(adj[node][i],node,adj,vis,dp,m);\\n            }\\n        }\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        //store the edges in form of a undirected graph\\n        vector<int>adj[n+1];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        //find the height of target node\\n        vector<int>dfs_vis(n+1,0);\\n        int height;\\n        dfs(target,0,1,adj,dfs_vis,height);\\n        //if height>t then we can never reach the target node in time\\n        if(height>t) return 0.0;\\n        //now we will check if there are more nodes down to target node in graph\\n        bool more_node=false;\\n        for(int i=0;i<adj[target].size();i++){\\n            if(dfs_vis[adj[target][i]]==0){\\n                more_node=true;\\n                break;\\n            }\\n        }\\n        // if there are more nodes down to the target node and the time is greater then height of the target, then we will be forced to move down and we will never be able to move back as it is not allowed therefore we will never be able to reach it in time \"t\" as we have moved down.\\n        if(more_node && t>height) return 0.0;\\n        //now we will find the probability to move to each node in the graph starting from node 1\\n        map<int,int>m;\\n        //number of node to which we can travel from node 1\\n        m[1]=adj[1].size();\\n        for(int i=2;i<=n;i++){\\n            // we have reduced 1 as we can not move to node from which we have come according to question\\n            m[i]=adj[i].size()-1;\\n        }\\n        //now we will store the result in dp\\n        vector<double>dp(n+1,0);\\n        vector<int>vis(n+1,0);\\n        prob_dfs(1,-1,adj,vis,dp,m);\\n        for(int i=1;i<=n;i++){\\n            cout<<dp[i]<<\" \";\\n        }\\n        return dp[target];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3621231,
                "title": "c-solution-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<int>adj[n+1];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        if(n==1) return 1;\\n        if(target==1){\\n            if(t==0) return 1;\\n            else return 0;\\n        }\\n        queue<pair<int,pair<int,double>>>q;\\n        q.push({1,{t,1}});\\n        vector<int> vis(n+1,0);\\n        vis[1]=1;\\n        int f;\\n        while(!q.empty()){\\n            pair<int,double> temp=q.front().second;\\n            int s=q.front().first;\\n            int a=temp.first;\\n            q.pop();\\n            if(s==target){\\n                if(temp.first==0 || (temp.first>0 && adj[s].size()==1)) return temp.second;\\n                else{\\n                    return 0;\\n                }\\n            }\\n            a-=1;\\n            for(auto it:adj[s]){\\n                if(vis[it]==0){\\n                    int k=adj[s].size();\\n                    if(s!=1) k-=1;\\n                    double p=temp.second*(1.0/k);\\n                    vis[it]=1;    \\n                    q.push({it,{a,p}});\\n                }\\n            }\\n        }   \\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<int>adj[n+1];\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        if(n==1) return 1;\\n        if(target==1){\\n            if(t==0) return 1;\\n            else return 0;\\n        }\\n        queue<pair<int,pair<int,double>>>q;\\n        q.push({1,{t,1}});\\n        vector<int> vis(n+1,0);\\n        vis[1]=1;\\n        int f;\\n        while(!q.empty()){\\n            pair<int,double> temp=q.front().second;\\n            int s=q.front().first;\\n            int a=temp.first;\\n            q.pop();\\n            if(s==target){\\n                if(temp.first==0 || (temp.first>0 && adj[s].size()==1)) return temp.second;\\n                else{\\n                    return 0;\\n                }\\n            }\\n            a-=1;\\n            for(auto it:adj[s]){\\n                if(vis[it]==0){\\n                    int k=adj[s].size();\\n                    if(s!=1) k-=1;\\n                    double p=temp.second*(1.0/k);\\n                    vis[it]=1;    \\n                    q.push({it,{a,p}});\\n                }\\n            }\\n        }   \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3616778,
                "title": "straightforward-dfs-solution",
                "content": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        g=defaultdict(list)\\n        for [x,y] in edges:\\n            g[x].append(y)\\n            g[y].append(x)\\n            \\n        def dfs(node,par,timer)->float:\\n            if(timer==t):  # we have reached the target time \\'t\\' so check if we have reached target node\\n                if(node==target):\\n                    return 1.0\\n                return 0.0\\n            \\n            cnt=0\\n            if(node==target):  # keep jumping on same vertex till u have time\\n                for to in g[node]:\\n                    if(to!=par):\\n                        cnt+=1\\n                if(cnt==0):\\n                    return 1.0\\n                else:\\n                    return 0.0\\n\\n            cnt=0\\n            ans=0.0\\n            \\n            for to in g[node]:\\n                if(to!=par):\\n                    cnt+=1\\n            \\n            for to in g[node]:\\n                if(to!=par):\\n                    res=dfs(to,node,timer+1)\\n                    if(res>0):   # since it is tree, we only have one path to target node, so we return from here\\n                        return res/cnt\\n            return 0.0\\n            \\n        return dfs(1,0,0)\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        g=defaultdict(list)\\n        for [x,y] in edges:\\n            g[x].append(y)\\n            g[y].append(x)\\n            \\n        def dfs(node,par,timer)->float:\\n            if(timer==t):  # we have reached the target time \\'t\\' so check if we have reached target node\\n                if(node==target):\\n                    return 1.0\\n                return 0.0\\n            \\n            cnt=0\\n            if(node==target):  # keep jumping on same vertex till u have time\\n                for to in g[node]:\\n                    if(to!=par):\\n                        cnt+=1\\n                if(cnt==0):\\n                    return 1.0\\n                else:\\n                    return 0.0\\n\\n            cnt=0\\n            ans=0.0\\n            \\n            for to in g[node]:\\n                if(to!=par):\\n                    cnt+=1\\n            \\n            for to in g[node]:\\n                if(to!=par):\\n                    res=dfs(to,node,timer+1)\\n                    if(res>0):   # since it is tree, we only have one path to target node, so we return from here\\n                        return res/cnt\\n            return 0.0\\n            \\n        return dfs(1,0,0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594431,
                "title": "swift-compact-solution",
                "content": "The basic idea behind this solution is to carry out `t` steps of a breadth-first search, at each step calculating the set of nodes where the frog could be and the probabilty that it is at each of those nodes. \\n\\nTo allow easy retrieval of the target node, a dictionary rather than a set is used to hold the `currentNodes`. \\n\\n# Code\\n```\\nclass Solution {\\n    func frogPosition(_ n: Int, _ edges: [[Int]], _ t: Int, _ target: Int) -> Double {\\n        // Put the edges into more useful data structure.\\n        // graph[id] contains an array of all the nodes reachable from node `id`\\n        var graph = edges.reduce(into: [[Int]](repeating: [], count: n + 1)) {\\n            $0[$1[0]].append($1[1])\\n            $0[$1[1]].append($1[0])\\n        }\\n        // An array of nodes where the frog could be at the current time step.\\n        // At t = 0 the frog is at node 1 with a probability of 1.0.\\n        var currentNodes = [1:1.0]\\n        // Set of nodes visited so far; frog is not allow visit a node more than once.\\n        var visited = Set<Int>()\\n        for _ in 1...t {\\n            currentNodes = currentNodes.reduce(into: [Int:Double]()) {\\n                visited.insert($1.key) \\n                let possibles = graph[$1.key].filter { !visited.contains($0) }\\n                let count = possibles.count\\n                if count == 0 {\\n                    // Frog stuck on current node\\n                    $0[$1.key] = $1.value\\n                    return\\n                }\\n                // Frog jumps to one of the possible nodes with equal probability\\n                let probability = $1.value / Double(count)\\n                for possible in possibles {\\n                    $0[possible] = probability\\n                }\\n            }\\n        }\\n        return  currentNodes[target] ?? 0.0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func frogPosition(_ n: Int, _ edges: [[Int]], _ t: Int, _ target: Int) -> Double {\\n        // Put the edges into more useful data structure.\\n        // graph[id] contains an array of all the nodes reachable from node `id`\\n        var graph = edges.reduce(into: [[Int]](repeating: [], count: n + 1)) {\\n            $0[$1[0]].append($1[1])\\n            $0[$1[1]].append($1[0])\\n        }\\n        // An array of nodes where the frog could be at the current time step.\\n        // At t = 0 the frog is at node 1 with a probability of 1.0.\\n        var currentNodes = [1:1.0]\\n        // Set of nodes visited so far; frog is not allow visit a node more than once.\\n        var visited = Set<Int>()\\n        for _ in 1...t {\\n            currentNodes = currentNodes.reduce(into: [Int:Double]()) {\\n                visited.insert($1.key) \\n                let possibles = graph[$1.key].filter { !visited.contains($0) }\\n                let count = possibles.count\\n                if count == 0 {\\n                    // Frog stuck on current node\\n                    $0[$1.key] = $1.value\\n                    return\\n                }\\n                // Frog jumps to one of the possible nodes with equal probability\\n                let probability = $1.value / Double(count)\\n                for possible in possibles {\\n                    $0[possible] = probability\\n                }\\n            }\\n        }\\n        return  currentNodes[target] ?? 0.0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3589667,
                "title": "bfs-approach-java-solution-clean-code",
                "content": "# Code\\n```java\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        if(n == 1) return 1.0;\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0;i < n;i++) adj.add(new ArrayList<>());\\n        for(var e:edges){\\n            adj.get(e[0] - 1).add(e[1] - 1);\\n            adj.get(e[1] - 1).add(e[0] - 1);\\n        }\\n        boolean visit[] = new boolean[n];\\n        Queue<double[]> q = new LinkedList<>();\\n        q.add(new double[]{0,1});\\n        visit[0] = true;\\n        double ans = 0.0;\\n        outer: for(;!q.isEmpty() && t >= 0;--t){\\n            int s = q.size();\\n            for(;s > 0;--s){\\n                var a = q.poll();\\n                if((int)a[0] + 1 == target){\\n                    ans = a[1];\\n                    break outer;\\n                }\\n                double l = adj.get((int)a[0]).size() - ((int)a[0] == 0 ? 0 : 1);\\n                for(var c:adj.get((int)a[0])){\\n                    if(!visit[c]){\\n                        visit[c] = true;\\n                        q.add(new double[]{c,a[1] / l});\\n                    }\\n                }\\n            }\\n        }\\n        if(t <= 0) return ans;\\n        if(target == 1) return 0.0;\\n        if(adj.get(target - 1).size() == 1) return ans; // leaf node case (frog can jump on it forever)\\n        return 0.0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        if(n == 1) return 1.0;\\n        List<List<Integer>> adj = new ArrayList<>();\\n        for(int i = 0;i < n;i++) adj.add(new ArrayList<>());\\n        for(var e:edges){\\n            adj.get(e[0] - 1).add(e[1] - 1);\\n            adj.get(e[1] - 1).add(e[0] - 1);\\n        }\\n        boolean visit[] = new boolean[n];\\n        Queue<double[]> q = new LinkedList<>();\\n        q.add(new double[]{0,1});\\n        visit[0] = true;\\n        double ans = 0.0;\\n        outer: for(;!q.isEmpty() && t >= 0;--t){\\n            int s = q.size();\\n            for(;s > 0;--s){\\n                var a = q.poll();\\n                if((int)a[0] + 1 == target){\\n                    ans = a[1];\\n                    break outer;\\n                }\\n                double l = adj.get((int)a[0]).size() - ((int)a[0] == 0 ? 0 : 1);\\n                for(var c:adj.get((int)a[0])){\\n                    if(!visit[c]){\\n                        visit[c] = true;\\n                        q.add(new double[]{c,a[1] / l});\\n                    }\\n                }\\n            }\\n        }\\n        if(t <= 0) return ans;\\n        if(target == 1) return 0.0;\\n        if(adj.get(target - 1).size() == 1) return ans; // leaf node case (frog can jump on it forever)\\n        return 0.0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582292,
                "title": "c-single-dfs-pass-beats-87",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N+edges.length)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> graph[1009];\\n    bool vis[1009];\\n    \\n    double dfs(int vertex,int t,int target)\\n    {\\n        if(t == 0) {\\n            if(vertex == target) return 1;\\n            return 0;\\n        }\\n        if(graph[vertex].size() == 1 and vertex != 1) {\\n            return dfs(vertex,t-1,target);\\n        }\\n        vis[vertex] = 1;\\n        double ans = 0;\\n        for(int child : graph[vertex]){\\n            if(vis[child]) continue;\\n            ans += dfs(child,t-1,target);\\n        }\\n        int siz = graph[vertex].size();\\n        if(vertex == 1 or graph[vertex].size() == 1) return ans/siz;\\n        return ans/(siz-1);\\n    }\\n    \\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        if(n == 1) return 1;\\n        for(int w=0;w<edges.size();w++){\\n            graph[edges[w][0]].push_back(edges[w][1]);\\n            graph[edges[w][1]].push_back(edges[w][0]);\\n        }\\n        return dfs(1,t,target);\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> graph[1009];\\n    bool vis[1009];\\n    \\n    double dfs(int vertex,int t,int target)\\n    {\\n        if(t == 0) {\\n            if(vertex == target) return 1;\\n            return 0;\\n        }\\n        if(graph[vertex].size() == 1 and vertex != 1) {\\n            return dfs(vertex,t-1,target);\\n        }\\n        vis[vertex] = 1;\\n        double ans = 0;\\n        for(int child : graph[vertex]){\\n            if(vis[child]) continue;\\n            ans += dfs(child,t-1,target);\\n        }\\n        int siz = graph[vertex].size();\\n        if(vertex == 1 or graph[vertex].size() == 1) return ans/siz;\\n        return ans/(siz-1);\\n    }\\n    \\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        if(n == 1) return 1;\\n        for(int w=0;w<edges.size();w++){\\n            graph[edges[w][0]].push_back(edges[w][1]);\\n            graph[edges[w][1]].push_back(edges[w][0]);\\n        }\\n        return dfs(1,t,target);\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580546,
                "title": "simple-c-answer",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\ndouble go(vector<vector<int>> &link,int i,int t,int &target,int pre){\\n    if(target==i && t==0)return 1;\\n    if(t==0)return 0;\\n    int count=0;\\n    double prop=0;\\n    for(auto x:link[i]){\\n        if(x==pre)continue;\\n        count++;\\n        prop=max(prop,go(link,x,t-1,target,i));\\n    }\\n    if(count>0){return double(prop)/double(count);}\\n    else if(i==target)return 1;\\n    else return 0;\\n}\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> link(n+1);\\n        for(auto x:edges){\\n            link[x[0]].push_back(x[1]);\\n            link[x[1]].push_back(x[0]);\\n        }\\n        //------------------------------------\\n        return go(link,1,t,target,-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ndouble go(vector<vector<int>> &link,int i,int t,int &target,int pre){\\n    if(target==i && t==0)return 1;\\n    if(t==0)return 0;\\n    int count=0;\\n    double prop=0;\\n    for(auto x:link[i]){\\n        if(x==pre)continue;\\n        count++;\\n        prop=max(prop,go(link,x,t-1,target,i));\\n    }\\n    if(count>0){return double(prop)/double(count);}\\n    else if(i==target)return 1;\\n    else return 0;\\n}\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> link(n+1);\\n        for(auto x:edges){\\n            link[x[0]].push_back(x[1]);\\n            link[x[1]].push_back(x[0]);\\n        }\\n        //------------------------------------\\n        return go(link,1,t,target,-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3573411,
                "title": "dfs",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        graph = defaultdict(list)\\n\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        def dfs(node, t):\\n            count = len(graph[node]) - 1 # remove pointer to current node\\n            if node == 1:\\n                # the root is a exception\\n                count += 1\\n\\n            # while no more choice or timeout\\n            if t == 0 or count == 0:\\n                return 1 if target == node else 0\\n\\n            # check probability from children (neighbors)\\n            for nei in graph[node]:\\n                if nei in seen:\\n                    continue\\n                seen.add(nei)\\n                res = dfs(nei, t - 1)\\n                if res != 0:\\n                    # return the probability if the way we choose is correct\\n                    return res / count\\n\\n            return 0\\n\\n        seen = set([1])\\n        ans = dfs(1, t)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        graph = defaultdict(list)\\n\\n        for u, v in edges:\\n            graph[u].append(v)\\n            graph[v].append(u)\\n\\n        def dfs(node, t):\\n            count = len(graph[node]) - 1 # remove pointer to current node\\n            if node == 1:\\n                # the root is a exception\\n                count += 1\\n\\n            # while no more choice or timeout\\n            if t == 0 or count == 0:\\n                return 1 if target == node else 0\\n\\n            # check probability from children (neighbors)\\n            for nei in graph[node]:\\n                if nei in seen:\\n                    continue\\n                seen.add(nei)\\n                res = dfs(nei, t - 1)\\n                if res != 0:\\n                    # return the probability if the way we choose is correct\\n                    return res / count\\n\\n            return 0\\n\\n        seen = set([1])\\n        ans = dfs(1, t)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572608,
                "title": "c-solution-using-bfs-easy-to-understand",
                "content": "\\n```\\npublic class Solution {\\n    public double FrogPosition(int n, int[][] edges, int t, int target) {\\n        List<int>[] child = new List<int>[n + 1];\\n        bool[] visit = new bool[n + 1];\\n        visit[1] = true;\\n        for(int i = 0; i < child.Length;i++) child[i] = new List<int>();\\n        for(int i = 0; i < edges.Length;i++){\\n            int v1 = edges[i][0], v2 = edges[i][1];\\n            child[v1].Add(v2);\\n            child[v2].Add(v1);\\n        }\\n        Queue<Tuple<int,double>> q = new Queue<Tuple<int,double>>();\\n        q.Enqueue(Tuple.Create(1,1.0));\\n        while(q.Count > 0 && t-- > 0){\\n            int count = q.Count;\\n            for(int i = 0; i < count;i++){\\n                var pair = q.Dequeue();          \\n                int childCount = 0;\\n                foreach(var v in child[pair.Item1])\\n                    if(!visit[v]) childCount++;\\n                if(pair.Item1 == target && childCount == 0) return pair.Item2;\\n                else if(pair.Item1 == target) return 0.0;\\n                foreach(var v in child[pair.Item1]){\\n                    if(visit[v]) continue;\\n                    visit[v] = true;\\n                    q.Enqueue(Tuple.Create(v,pair.Item2 / childCount));\\n                }\\n            }\\n        }\\n        while(q.Count > 0){\\n            var pair = q.Dequeue();\\n            if(pair.Item1 == target) return pair.Item2;\\n        }\\n        return 0.0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public double FrogPosition(int n, int[][] edges, int t, int target) {\\n        List<int>[] child = new List<int>[n + 1];\\n        bool[] visit = new bool[n + 1];\\n        visit[1] = true;\\n        for(int i = 0; i < child.Length;i++) child[i] = new List<int>();\\n        for(int i = 0; i < edges.Length;i++){\\n            int v1 = edges[i][0], v2 = edges[i][1];\\n            child[v1].Add(v2);\\n            child[v2].Add(v1);\\n        }\\n        Queue<Tuple<int,double>> q = new Queue<Tuple<int,double>>();\\n        q.Enqueue(Tuple.Create(1,1.0));\\n        while(q.Count > 0 && t-- > 0){\\n            int count = q.Count;\\n            for(int i = 0; i < count;i++){\\n                var pair = q.Dequeue();          \\n                int childCount = 0;\\n                foreach(var v in child[pair.Item1])\\n                    if(!visit[v]) childCount++;\\n                if(pair.Item1 == target && childCount == 0) return pair.Item2;\\n                else if(pair.Item1 == target) return 0.0;\\n                foreach(var v in child[pair.Item1]){\\n                    if(visit[v]) continue;\\n                    visit[v] = true;\\n                    q.Enqueue(Tuple.Create(v,pair.Item2 / childCount));\\n                }\\n            }\\n        }\\n        while(q.Count > 0){\\n            var pair = q.Dequeue();\\n            if(pair.Item1 == target) return pair.Item2;\\n        }\\n        return 0.0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562828,
                "title": "c-dfs",
                "content": "class Solution {\\npublic:\\n    \\n    double dfs(int curr, int t, vector<int>& vis, vector<vector<int>>& g, int target) {\\n        \\n        //base case\\n        if(curr != 1 && t >= 0 && target == curr && g[curr].size() == 1)\\n            return 1;\\n        if(t == 0 && target == curr)\\n            return 1;\\n        if(t <= 0) \\n            return 0;\\n        \\n        vis[curr] = 1;\\n        int n = g[curr].size();\\n        \\n        //only root node\\n        if(curr == 1)\\n            n++;\\n        \\n        //next steps\\n        for(auto neighbour: g[curr]) {\\n            if(vis[neighbour] == 0) {\\n                double ans = dfs(neighbour, t-1, vis, g, target);\\n                \\n                if(ans != 0.0) {\\n                    return (double(1)/double(n-1))*ans;\\n                }\\n            }\\n        }\\n        return 0.0;\\n    }\\n\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        \\n        if(edges.size() == 0)\\n            return 1.0;\\n        \\n        vector<vector<int>> g(n+1);\\n        vector<int> vis(n+1);\\n        \\n        for(auto edge: edges) {\\n            \\n            g[edge[1]].push_back(edge[0]);\\n            g[edge[0]].push_back(edge[1]);\\n        }\\n        \\n        double ans = dfs(1, t, vis, g, target);\\n        if(ans != 0.0) {\\n            return ans;\\n        }\\n        return 0.0;\\n         \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    double dfs(int curr, int t, vector<int>& vis, vector<vector<int>>& g, int target) {\\n        \\n        //base case\\n        if(curr != 1 && t >= 0 && target == curr && g[curr].size() == 1)\\n            return 1;\\n        if(t == 0 && target == curr)\\n            return 1;\\n        if(t <= 0) \\n            return 0;\\n        \\n        vis[curr] = 1;\\n        int n = g[curr].size();\\n        \\n        //only root node\\n        if(curr == 1)\\n            n++;\\n        \\n        //next steps\\n        for(auto neighbour: g[curr]) {\\n            if(vis[neighbour] == 0) {\\n                double ans = dfs(neighbour, t-1, vis, g, target);\\n                \\n                if(ans != 0.0) {\\n                    return (double(1)/double(n-1))*ans;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3496202,
                "title": "c-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int , double>> bfs(int source , int n , vector<vector<int>>&adjList){\\n        vector<pair<int , double>>dis_prob(n , {-1 , -1}) ;\\n        dis_prob[0] = {0, 1};\\n        queue<int>q; q.push(source);\\n        while(!q.empty()){\\n            int curr = q.front(); q.pop();\\n            int size = adjList[curr].size();  if(curr != 0)size -= 1 ;\\n            for(auto it : adjList[curr]){\\n                if(dis_prob[it].first == -1){\\n                    dis_prob[it].first = dis_prob[curr].first + 1 ; \\n                    int first = dis_prob[it].first;\\n                    double second = dis_prob[curr].second/size ;\\n                    q.push(it); dis_prob[it] = {first , second};\\n                }\\n            }\\n        }\\n        return dis_prob ;\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>>adjList(n); --target ;\\n        for(auto it : edges){\\n            adjList[it[0]-1].push_back(it[1]-1);\\n            adjList[it[1]-1].push_back(it[0]-1);\\n        }\\n        vector<pair<int , double>>dis_prob = bfs(0 , n , adjList);\\n        if(dis_prob[target].first > t)return 0 ;\\n        if(target== 0 && dis_prob[target].first < t &&  adjList[target].size())return 0 ;\\n        if(target && dis_prob[target].first < t && adjList[target].size() >= 2)return 0 ;\\n\\n        return dis_prob[target].second ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int , double>> bfs(int source , int n , vector<vector<int>>&adjList){\\n        vector<pair<int , double>>dis_prob(n , {-1 , -1}) ;\\n        dis_prob[0] = {0, 1};\\n        queue<int>q; q.push(source);\\n        while(!q.empty()){\\n            int curr = q.front(); q.pop();\\n            int size = adjList[curr].size();  if(curr != 0)size -= 1 ;\\n            for(auto it : adjList[curr]){\\n                if(dis_prob[it].first == -1){\\n                    dis_prob[it].first = dis_prob[curr].first + 1 ; \\n                    int first = dis_prob[it].first;\\n                    double second = dis_prob[curr].second/size ;\\n                    q.push(it); dis_prob[it] = {first , second};\\n                }\\n            }\\n        }\\n        return dis_prob ;\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>>adjList(n); --target ;\\n        for(auto it : edges){\\n            adjList[it[0]-1].push_back(it[1]-1);\\n            adjList[it[1]-1].push_back(it[0]-1);\\n        }\\n        vector<pair<int , double>>dis_prob = bfs(0 , n , adjList);\\n        if(dis_prob[target].first > t)return 0 ;\\n        if(target== 0 && dis_prob[target].first < t &&  adjList[target].size())return 0 ;\\n        if(target && dis_prob[target].first < t && adjList[target].size() >= 2)return 0 ;\\n\\n        return dis_prob[target].second ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457831,
                "title": "java-solution-using-dfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    double prob;\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        ArrayList<ArrayList<Integer>>l=new ArrayList<>();\\n        for(int i=0;i<n;i++)l.add(new ArrayList<>());\\n        for(int r[]:edges)\\n        {\\n            l.get(r[0]-1).add(r[1]-1);\\n            l.get(r[1]-1).add(r[0]-1);\\n        }\\n        int v[]=new int[n];\\n        Arrays.fill(v,-1);\\n        dfs(0,v,l,t,target-1,1.0);\\n        return prob;\\n    }\\n    public void dfs(int node,int v[],ArrayList<ArrayList<Integer>>l,int t,int target,double p)\\n    {\\n        int len=0;\\n        if(node==0)len=l.get(node).size();\\n        else len=l.get(node).size()-1;\\n        v[node]=1;\\n        if(node==target)\\n        {\\n            if(t==0)prob=p;\\n            else if(t>0 && len==0)prob=p;\\n        }\\n        if(t>0)\\n        {\\n            for(Integer it:l.get(node))\\n            {\\n                if(v[it]==-1)\\n                    dfs(it,v,l,t-1,target,p/len);\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    double prob;\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        ArrayList<ArrayList<Integer>>l=new ArrayList<>();\\n        for(int i=0;i<n;i++)l.add(new ArrayList<>());\\n        for(int r[]:edges)\\n        {\\n            l.get(r[0]-1).add(r[1]-1);\\n            l.get(r[1]-1).add(r[0]-1);\\n        }\\n        int v[]=new int[n];\\n        Arrays.fill(v,-1);\\n        dfs(0,v,l,t,target-1,1.0);\\n        return prob;\\n    }\\n    public void dfs(int node,int v[],ArrayList<ArrayList<Integer>>l,int t,int target,double p)\\n    {\\n        int len=0;\\n        if(node==0)len=l.get(node).size();\\n        else len=l.get(node).size()-1;\\n        v[node]=1;\\n        if(node==target)\\n        {\\n            if(t==0)prob=p;\\n            else if(t>0 && len==0)prob=p;\\n        }\\n        if(t>0)\\n        {\\n            for(Integer it:l.get(node))\\n            {\\n                if(v[it]==-1)\\n                    dfs(it,v,l,t-1,target,p/len);\\n            }\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3440567,
                "title": "python-dfs-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\ntraverse the tree,\\n\\tif check if all of the node which we traverse at `second` == target or not\\n\\tand check if all of leaf node == target or not\\ntc is O(n), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if n == 1: return 1\\n        g = self.buildGraph(edges)\\n        def dfs(cur, prev, second):\\n            if second == t or (cur != 1 and len(g[cur]) == 1):\\n                return cur == target\\n            p = 1 / (len(g[cur]) - (1 if cur != 1 else 0))\\n            for ch in g[cur]:\\n                if ch != prev:\\n                    tmp = dfs(ch, cur, second+1)\\n                    if tmp != 0: return tmp * p\\n            return 0.\\n        return dfs(1, 0, 0)\\n\\n    def buildGraph(self, edges):\\n        g = collections.defaultdict(list)\\n        for n1, n2 in edges:\\n            g[n1].append(n2)\\n            g[n2].append(n1)\\n        return g\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```python\\n\\'\\'\\'\\ntraverse the tree,\\n\\tif check if all of the node which we traverse at `second` == target or not\\n\\tand check if all of leaf node == target or not\\ntc is O(n), sc is O(n)\\n\\'\\'\\'\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        if n == 1: return 1\\n        g = self.buildGraph(edges)\\n        def dfs(cur, prev, second):\\n            if second == t or (cur != 1 and len(g[cur]) == 1):\\n                return cur == target\\n            p = 1 / (len(g[cur]) - (1 if cur != 1 else 0))\\n            for ch in g[cur]:\\n                if ch != prev:\\n                    tmp = dfs(ch, cur, second+1)\\n                    if tmp != 0: return tmp * p\\n            return 0.\\n        return dfs(1, 0, 0)\\n\\n    def buildGraph(self, edges):\\n        g = collections.defaultdict(list)\\n        for n1, n2 in edges:\\n            g[n1].append(n2)\\n            g[n2].append(n1)\\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439722,
                "title": "easy-dfs-approach",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    Dictionary<int, List<int>> adjList;\\n\\n    public double FrogPosition(int n, int[][] edges, int t, int target)\\n    {\\n        adjList = PrepareAdjList(n, edges);\\n        if (n == 1)\\n            return 1;\\n\\n        double ans = FindProbability(1, -1, t, target);\\n        return ans;\\n    }\\n\\n    private double FindProbability(int node, int parent, int time, int target)\\n    {\\n        List<int> adjNodes = adjList[node];\\n        if (time == 0 || adjNodes.Count-1 == 0)\\n        {\\n            if (node == target)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n\\n        double prob = 0;\\n        double count = adjNodes.Count - 1;\\n        foreach (int nd in adjNodes)\\n        {\\n            if (nd == parent)\\n                continue;\\n\\n            double p = (1.0 / count) * FindProbability(nd, node, time - 1, target);\\n            prob += p;\\n        }\\n\\n        return prob;\\n    }\\n\\n    private Dictionary<int, List<int>> PrepareAdjList(int n, int[][] edges)\\n    {\\n        Dictionary<int, List<int>> adjObj = new();\\n        for (int i = 1; i <= n; i++)\\n            adjObj.Add(i, new());\\n\\n        foreach (int[] edge in edges)\\n        {\\n            adjObj[edge[0]].Add(edge[1]);\\n            adjObj[edge[1]].Add(edge[0]);\\n        }\\n\\n        adjObj[1].Add(-1);\\n\\n        return adjObj;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\npublic class Solution\\n{\\n    Dictionary<int, List<int>> adjList;\\n\\n    public double FrogPosition(int n, int[][] edges, int t, int target)\\n    {\\n        adjList = PrepareAdjList(n, edges);\\n        if (n == 1)\\n            return 1;\\n\\n        double ans = FindProbability(1, -1, t, target);\\n        return ans;\\n    }\\n\\n    private double FindProbability(int node, int parent, int time, int target)\\n    {\\n        List<int> adjNodes = adjList[node];\\n        if (time == 0 || adjNodes.Count-1 == 0)\\n        {\\n            if (node == target)\\n                return 1;\\n            else\\n                return 0;\\n        }\\n\\n        double prob = 0;\\n        double count = adjNodes.Count - 1;\\n        foreach (int nd in adjNodes)\\n        {\\n            if (nd == parent)\\n                continue;\\n\\n            double p = (1.0 / count) * FindProbability(nd, node, time - 1, target);\\n            prob += p;\\n        }\\n\\n        return prob;\\n    }\\n\\n    private Dictionary<int, List<int>> PrepareAdjList(int n, int[][] edges)\\n    {\\n        Dictionary<int, List<int>> adjObj = new();\\n        for (int i = 1; i <= n; i++)\\n            adjObj.Add(i, new());\\n\\n        foreach (int[] edge in edges)\\n        {\\n            adjObj[edge[0]].Add(edge[1]);\\n            adjObj[edge[1]].Add(edge[0]);\\n        }\\n\\n        adjObj[1].Add(-1);\\n\\n        return adjObj;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432799,
                "title": "c-dfs-o-e-v",
                "content": "```\\nclass Solution {\\npublic:\\nbool helper(int start,int end,unordered_map<int,vector<int>>&ourmap,unordered_map<int,bool>&visited,unordered_map<int,int>&outdegree,int time,double&ans,int t){\\n        \\n    visited[start]=true;\\n    if(start==end && outdegree[start]==0){\\n        return true;\\n    }\\n    if(time==t){\\n        if(start==end){\\n            return true;\\n        }\\n        time--;\\n        return false;\\n    }\\n    vector<int> temp=ourmap[start];\\n    for(int i=0;i<temp.size();i++){\\n        if(visited[temp[i]]!=true){\\n            double num=outdegree[start];\\n            ans=ans/num;\\n            cout<<ans<<endl;\\n            bool smallans=helper(temp[i],end,ourmap,visited,outdegree,time+1,ans,t);\\n            if(smallans==true){\\n                return true;\\n            }\\n            else{\\n                ans=ans*num;\\n            }\\n            cout<<ans<<endl;\\n        }\\n    }\\n    time--;\\n    return false;\\n    }\\n    void getoutdegree(int start,unordered_map<int,vector<int>>&ourmap,unordered_map<int,bool>&visited,unordered_map<int,int>&outdegree){\\n        \\n        visited[start]=true;\\n        vector<int> temp=ourmap[start];\\n        for(int i=0;i<temp.size();i++){\\n            if(visited[temp[i]]!=true){\\n                outdegree[start]++;\\n                getoutdegree(temp[i],ourmap,visited,outdegree);\\n            }\\n        }\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        \\n        unordered_map<int,vector<int>> ourmap;\\n        unordered_map<int,int> outdegree(0);\\n        for(int i=0;i<edges.size();i++){\\n            int a=edges[i][0];\\n            int b=edges[i][1];\\n            ourmap[a].push_back(b);\\n            ourmap[b].push_back(a);\\n        }\\n        unordered_map<int,bool> visited(false);\\n        getoutdegree(1,ourmap,visited,outdegree);\\n        double ans=1;\\n        visited.clear();\\n        bool a=helper(1,target,ourmap,visited,outdegree,0,ans,t);\\n        return (a==false)? 0:ans;\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\nbool helper(int start,int end,unordered_map<int,vector<int>>&ourmap,unordered_map<int,bool>&visited,unordered_map<int,int>&outdegree,int time,double&ans,int t){\\n        \\n    visited[start]=true;\\n    if(start==end && outdegree[start]==0){\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3407912,
                "title": "just-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<int>adj[n+1];\\n        vector<int>vis(n+1,0);\\n        for(auto v:edges) \\n        {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        queue<pair<vector<int>,double>>q;\\n        q.push({{1,t},1});\\n        vis[1]=1;\\n        while(!q.empty())\\n        {\\n            auto v=q.front(); q.pop();\\n            int node=v.first[0],tm=v.first[1];\\n            double prob=v.second;\\n            cout<<prob<<endl;\\n            if(node==target ) \\n            {\\n                if(tm==0) return prob;\\n                for(int i:adj[node])\\n                {\\n                    if(!vis[i]) return 0;\\n                }\\n                return prob;\\n            }\\n            if(tm==0) continue;\\n            int sz=adj[node].size();\\n            if(node!=1) sz--;\\n            if(sz==0) continue;\\n            for(int i:adj[node])\\n            {\\n                if(!vis[i])\\n                {\\n                    q.push({{i,tm-1},prob/sz});\\n                    vis[i]=1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<int>adj[n+1];\\n        vector<int>vis(n+1,0);\\n        for(auto v:edges) \\n        {\\n            adj[v[0]].push_back(v[1]);\\n            adj[v[1]].push_back(v[0]);\\n        }\\n        queue<pair<vector<int>,double>>q;\\n        q.push({{1,t},1});\\n        vis[1]=1;\\n        while(!q.empty())\\n        {\\n            auto v=q.front(); q.pop();\\n            int node=v.first[0],tm=v.first[1];\\n            double prob=v.second;\\n            cout<<prob<<endl;\\n            if(node==target ) \\n            {\\n                if(tm==0) return prob;\\n                for(int i:adj[node])\\n                {\\n                    if(!vis[i]) return 0;\\n                }\\n                return prob;\\n            }\\n            if(tm==0) continue;\\n            int sz=adj[node].size();\\n            if(node!=1) sz--;\\n            if(sz==0) continue;\\n            for(int i:adj[node])\\n            {\\n                if(!vis[i])\\n                {\\n                    q.push({{i,tm-1},prob/sz});\\n                    vis[i]=1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3387130,
                "title": "simple-bfs-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nsimple apply BFS(Level Order Traversal) to find the Target Node.\\nfor every Node, count the number of unvisited Adjacent nodes, and for every adjacent probability will be = 1/number of the unvisited node.\\n\\nKeep in mind That if we got Target Node, and still time>0, and Target node that has an Adjacent Node that is not visited then ans will be 0.0;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    double  BFS(vector<int> adj[],int n,int t,int dest)\\n    {\\n          vector<int> vis(n+1,0);\\n          queue<int> q;\\n          vector<double> prob(n+1,0.0);\\n          q.push(1);\\n          prob[1] = 1.0;\\n          vis[1] =  1;\\n          while(t--)\\n          {\\n              int z = q.size();\\n\\n              for(int i = 0;i<z;i++)\\n              {\\n                  int node = q.front();\\n                  q.pop();\\n                  double cnt = 0;\\n                  for(auto x : adj[node])\\n                  {\\n                     if(!vis[x])\\n                     cnt++;\\n                  }\\n                  double p = 1.0/cnt;\\n                  p = p*prob[node];\\n\\n                  for(auto x : adj[node])\\n                  {\\n\\n                      if(!vis[x])\\n                      {\\n                          q.push(x);\\n                          prob[x] = p;\\n                          vis[x] = 1;\\n                      } \\n                  }\\n                 \\n                 if(node==dest)\\n                 {\\n                    if(cnt>0)\\n                    return 0.0;\\n                 }\\n              }\\n\\n          }\\n\\n          return prob[dest];\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int dest) {\\n\\n        vector<int> adj[n+1];\\n        for(int i = 0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        return BFS(adj,n,t,dest);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    double  BFS(vector<int> adj[],int n,int t,int dest)\\n    {\\n          vector<int> vis(n+1,0);\\n          queue<int> q;\\n          vector<double> prob(n+1,0.0);\\n          q.push(1);\\n          prob[1] = 1.0;\\n          vis[1] =  1;\\n          while(t--)\\n          {\\n              int z = q.size();\\n\\n              for(int i = 0;i<z;i++)\\n              {\\n                  int node = q.front();\\n                  q.pop();\\n                  double cnt = 0;\\n                  for(auto x : adj[node])\\n                  {\\n                     if(!vis[x])\\n                     cnt++;\\n                  }\\n                  double p = 1.0/cnt;\\n                  p = p*prob[node];\\n\\n                  for(auto x : adj[node])\\n                  {\\n\\n                      if(!vis[x])\\n                      {\\n                          q.push(x);\\n                          prob[x] = p;\\n                          vis[x] = 1;\\n                      } \\n                  }\\n                 \\n                 if(node==dest)\\n                 {\\n                    if(cnt>0)\\n                    return 0.0;\\n                 }\\n              }\\n\\n          }\\n\\n          return prob[dest];\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int dest) {\\n\\n        vector<int> adj[n+1];\\n        for(int i = 0;i<edges.size();i++)\\n        {\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        \\n        return BFS(adj,n,t,dest);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362434,
                "title": "python-100-tc-simple-dfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        adj = [[] for i in range(n)]\\n        for u,v in edges:\\n            adj[u-1].append(v-1)\\n            adj[v-1].append(u-1)\\n        def f(u,p,tt):\\n            if(u==target-1): return tt==0 or len(adj[u])==(p>=0)\\n            if(tt==0): return 0\\n            res = 0\\n            for v in adj[u]:\\n                if(p==v): continue\\n                res = max(res,(1/(len(adj[u])-(p!=-1)))*f(v,u,tt-1))\\n            return res\\n        return f(0,-1,t)\\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        adj = [[] for i in range(n)]\\n        for u,v in edges:\\n            adj[u-1].append(v-1)\\n            adj[v-1].append(u-1)\\n        def f(u,p,tt):\\n            if(u==target-1): return tt==0 or len(adj[u])==(p>=0)\\n            if(tt==0): return 0\\n            res = 0\\n            for v in adj[u]:\\n                if(p==v): continue\\n                res = max(res,(1/(len(adj[u])-(p!=-1)))*f(v,u,tt-1))\\n            return res\\n        return f(0,-1,t)\\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335216,
                "title": "bfs-solution",
                "content": "# Code\\n```\\nclass Node {\\n    int node;\\n    int time;\\n    double probablity;\\n\\n    Node(int node,int time,double probablity) {\\n        this.time = time;\\n        this.node = node;\\n        this.probablity = probablity;\\n    }\\n}\\n\\nclass Edge {\\n    int src;\\n    int nbr;\\n    Edge (int src, int nbr) {\\n        this.src = src;\\n        this.nbr = nbr;\\n    }\\n}\\n\\nclass Graph {\\n    int nodes;\\n    HashMap<Integer, List<Edge>> graph = new HashMap<>();\\n\\n    Graph(int nodes, List<Edge> edges) {\\n        this.nodes = nodes;\\n        for (Edge edge: edges) {\\n            List<Edge> nodeEdgesSrc = new ArrayList<>();\\n            List<Edge> nodeEdgesNbr = new ArrayList<>();\\n            if (graph.containsKey(edge.src)) \\n            nodeEdgesSrc = graph.get(edge.src);\\n            nodeEdgesSrc.add(new Edge(edge.src,edge.nbr));\\n            graph.put(edge.src,nodeEdgesSrc);\\n            if (graph.containsKey(edge.nbr)) \\n            nodeEdgesNbr = graph.get(edge.nbr);\\n            nodeEdgesNbr.add(new Edge(edge.nbr,edge.src));\\n            graph.put(edge.nbr,nodeEdgesNbr);\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        List<Edge> edgesList = new ArrayList<>();\\n        for (int i=0;i<edges.length;i++) {\\n            Edge edge = new Edge(edges[i][0],edges[i][1]);\\n            edgesList.add(edge);\\n        }\\n\\n        double answer = 0;\\n        int timeRequired = 0;\\n        Graph g = new Graph(n,edgesList);\\n        boolean[] visited = new boolean[n+1];\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(new Node(1,0,1));\\n\\n        while (!queue.isEmpty()) {\\n            Node queueNode = queue.remove();\\n            visited[queueNode.node] = true;\\n            List<Edge> nodeEdges = g.graph.containsKey(queueNode.node) ? g.graph.get(queueNode.node) : new ArrayList<Edge>();\\n            nodeEdges = nodeEdges.stream().filter(edge -> !visited[edge.nbr]).collect(Collectors.toList());\\n            int totalAdjacent = nodeEdges.size();\\n            if (queueNode.node == target) {\\n                if (queueNode.time < t) \\n                answer = (totalAdjacent > 0) ? 0 : queueNode.probablity;\\n                else if (queueNode.time == t) answer = queueNode.probablity;\\n            }\\n            double newProbablity = (totalAdjacent == 0) ? queueNode.probablity : queueNode.probablity * ( 1.0 / totalAdjacent);\\n            for (Edge e: nodeEdges) queue.add(new Node(e.nbr,queueNode.time+1,newProbablity)); \\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Node {\\n    int node;\\n    int time;\\n    double probablity;\\n\\n    Node(int node,int time,double probablity) {\\n        this.time = time;\\n        this.node = node;\\n        this.probablity = probablity;\\n    }\\n}\\n\\nclass Edge {\\n    int src;\\n    int nbr;\\n    Edge (int src, int nbr) {\\n        this.src = src;\\n        this.nbr = nbr;\\n    }\\n}\\n\\nclass Graph {\\n    int nodes;\\n    HashMap<Integer, List<Edge>> graph = new HashMap<>();\\n\\n    Graph(int nodes, List<Edge> edges) {\\n        this.nodes = nodes;\\n        for (Edge edge: edges) {\\n            List<Edge> nodeEdgesSrc = new ArrayList<>();\\n            List<Edge> nodeEdgesNbr = new ArrayList<>();\\n            if (graph.containsKey(edge.src)) \\n            nodeEdgesSrc = graph.get(edge.src);\\n            nodeEdgesSrc.add(new Edge(edge.src,edge.nbr));\\n            graph.put(edge.src,nodeEdgesSrc);\\n            if (graph.containsKey(edge.nbr)) \\n            nodeEdgesNbr = graph.get(edge.nbr);\\n            nodeEdgesNbr.add(new Edge(edge.nbr,edge.src));\\n            graph.put(edge.nbr,nodeEdgesNbr);\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        List<Edge> edgesList = new ArrayList<>();\\n        for (int i=0;i<edges.length;i++) {\\n            Edge edge = new Edge(edges[i][0],edges[i][1]);\\n            edgesList.add(edge);\\n        }\\n\\n        double answer = 0;\\n        int timeRequired = 0;\\n        Graph g = new Graph(n,edgesList);\\n        boolean[] visited = new boolean[n+1];\\n        Queue<Node> queue = new LinkedList<>();\\n        queue.add(new Node(1,0,1));\\n\\n        while (!queue.isEmpty()) {\\n            Node queueNode = queue.remove();\\n            visited[queueNode.node] = true;\\n            List<Edge> nodeEdges = g.graph.containsKey(queueNode.node) ? g.graph.get(queueNode.node) : new ArrayList<Edge>();\\n            nodeEdges = nodeEdges.stream().filter(edge -> !visited[edge.nbr]).collect(Collectors.toList());\\n            int totalAdjacent = nodeEdges.size();\\n            if (queueNode.node == target) {\\n                if (queueNode.time < t) \\n                answer = (totalAdjacent > 0) ? 0 : queueNode.probablity;\\n                else if (queueNode.time == t) answer = queueNode.probablity;\\n            }\\n            double newProbablity = (totalAdjacent == 0) ? queueNode.probablity : queueNode.probablity * ( 1.0 / totalAdjacent);\\n            for (Edge e: nodeEdges) queue.add(new Node(e.nbr,queueNode.time+1,newProbablity)); \\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329017,
                "title": "python-dfs-o-n-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to start from vertex 1 and visit every node. Ok, this means either BFS or DFS. Simply traverse the tree and return the probability when conditions are met.\\n \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        #creating adjacency list from edges\\n        adj=collections.defaultdict(list)\\n        for a,b in edges:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n\\n        # initially stack will have vertex 1, with probability 1 and at time=0\\n        stack=[(1,1,0)]\\n        visited=set([1])\\n        while stack:\\n            currVertex,probability,time=stack.pop()\\n            # if popped vertex is target and time is reached, we return probability\\n            if currVertex==target and time==t:\\n                return probability\\n            if time<t:\\n                # to check if there are any new vertex we can visit\\n                nonVisited=0\\n                # calculate the total options to visit from the current vertex\\n                if currVertex==1:\\n                    parentLength=len(adj[currVertex])\\n                else:\\n                    parentLength=len(adj[currVertex])-1\\n\\n                # for all vertices connected to current vertex, append the ones that are yet to be visited\\n                for nextVertex in adj[currVertex]:\\n                    if nextVertex not in visited:\\n                        nonVisited+=1\\n                        visited.add(nextVertex)\\n                        stack.append((nextVertex,probability*(1/parentLength),time+1))\\n                # if there are no new vertices left and current vertex is target, return probability\\n                if nonVisited==0 and currVertex==target:\\n                    return probability\\n        # return 0 when target cannot be reached at t in any way\\n        return 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        #creating adjacency list from edges\\n        adj=collections.defaultdict(list)\\n        for a,b in edges:\\n            adj[a].append(b)\\n            adj[b].append(a)\\n\\n        # initially stack will have vertex 1, with probability 1 and at time=0\\n        stack=[(1,1,0)]\\n        visited=set([1])\\n        while stack:\\n            currVertex,probability,time=stack.pop()\\n            # if popped vertex is target and time is reached, we return probability\\n            if currVertex==target and time==t:\\n                return probability\\n            if time<t:\\n                # to check if there are any new vertex we can visit\\n                nonVisited=0\\n                # calculate the total options to visit from the current vertex\\n                if currVertex==1:\\n                    parentLength=len(adj[currVertex])\\n                else:\\n                    parentLength=len(adj[currVertex])-1\\n\\n                # for all vertices connected to current vertex, append the ones that are yet to be visited\\n                for nextVertex in adj[currVertex]:\\n                    if nextVertex not in visited:\\n                        nonVisited+=1\\n                        visited.add(nextVertex)\\n                        stack.append((nextVertex,probability*(1/parentLength),time+1))\\n                # if there are no new vertices left and current vertex is target, return probability\\n                if nonVisited==0 and currVertex==target:\\n                    return probability\\n        # return 0 when target cannot be reached at t in any way\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262726,
                "title": "c-dfs-solution",
                "content": "# Intuition\n<!-- Describe your first thoughts on how to solve this problem. -->\nExamples are really helpful basically just some graph traversal algorithm with some added stuff\n\n# Approach\n<!-- Describe your approach to solving the problem. -->\nuse dfs and accumulate the probability and time, if we reach the target node we have two cases either its a leaf node or an internal node for the former case we can have t >= 0 for the later we need t = 0.\n\n# Complexity\n- Time complexity:\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\nO(V + E)\n\n- Space complexity:\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\nidk\n# Code\n```\nclass Solution {\npublic:\n    vector<int> adj[101];\n\n    void dfs(int v, int prev, double prob, int t, int target, double &ans) { \n        double cnt = 0;\n        for (auto u : adj[v]) { if (u != prev) { ++cnt; } }\n        if (v == target && cnt == 0 && t >= 0) { ans = prob; }\n        if (v == target && cnt > 0 && t == 0) { ans = prob; }\n        for (auto u : adj[v]) {\n            if (u == prev) { continue; }\n            dfs(u, v, prob * 1 / cnt, t - 1, target, ans);\n        }\n    }\n\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\n        for (auto e : edges) { \n            adj[e[0]].push_back(e[1]);\n            adj[e[1]].push_back(e[0]);\n        }\n        double ans = 0;\n        dfs(1, -1, 1, t, target, ans);\n        return ans;\n    }\n};\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\nclass Solution {\npublic:\n    vector<int> adj[101];\n\n    void dfs(int v, int prev, double prob, int t, int target, double &ans) { \n        double cnt = 0;\n        for (auto u : adj[v]) { if (u != prev) { ++cnt; } }\n        if (v == target && cnt == 0 && t >= 0) { ans = prob; }\n        if (v == target && cnt > 0 && t == 0) { ans = prob; }\n        for (auto u : adj[v]) {\n            if (u == prev) { continue; }\n            dfs(u, v, prob * 1 / cnt, t - 1, target, ans);\n        }\n    }\n\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\n        for (auto e : edges) { \n            adj[e[0]].push_back(e[1]);\n            adj[e[1]].push_back(e[0]);\n        }\n        double ans = 0;\n        dfs(1, -1, 1, t, target, ans);\n        return ans;\n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239744,
                "title": "1377-frog-position-after-t-seconds-salutation-using-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        List<Integer>[] graph = (List<Integer>[]) new ArrayList[n+1];\\n        for(int i=1; i<=n; i++){\\n            graph[i] = new ArrayList<>();\\n\\n        }\\n        for(int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n\\n        boolean[] visited = new boolean[n+1];\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{1,1});\\n        visited[1] = true;\\n        int step =0 ;\\n\\n        //BFS start\\n        while(!queue.isEmpty() && step <=t){\\n            int size = queue.size();\\n            for(int i=0; i<size; i++){\\n                int[] current = queue.poll();\\n                int b=0;\\n\\n                for(int w : graph[current[0]]){\\n                    if(!visited[w]){\\n                        b++;\\n                    }\\n                }\\n                if(current[0] == target && (b==0 || step == t)){\\n                    return 1.0/current[1];\\n                }\\n                for(int w : graph[current[0]]){\\n                    if(!visited[w]){\\n                        visited[w] = true;\\n                        int temp = current[1] * b;\\n                        queue.offer(new int[] {w,temp});\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return 0.0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        List<Integer>[] graph = (List<Integer>[]) new ArrayList[n+1];\\n        for(int i=1; i<=n; i++){\\n            graph[i] = new ArrayList<>();\\n\\n        }\\n        for(int[] edge: edges){\\n            graph[edge[0]].add(edge[1]);\\n            graph[edge[1]].add(edge[0]);\\n        }\\n\\n        boolean[] visited = new boolean[n+1];\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[]{1,1});\\n        visited[1] = true;\\n        int step =0 ;\\n\\n        //BFS start\\n        while(!queue.isEmpty() && step <=t){\\n            int size = queue.size();\\n            for(int i=0; i<size; i++){\\n                int[] current = queue.poll();\\n                int b=0;\\n\\n                for(int w : graph[current[0]]){\\n                    if(!visited[w]){\\n                        b++;\\n                    }\\n                }\\n                if(current[0] == target && (b==0 || step == t)){\\n                    return 1.0/current[1];\\n                }\\n                for(int w : graph[current[0]]){\\n                    if(!visited[w]){\\n                        visited[w] = true;\\n                        int temp = current[1] * b;\\n                        queue.offer(new int[] {w,temp});\\n                    }\\n                }\\n            }\\n            step++;\\n        }\\n        return 0.0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3231531,
                "title": "simple-bfs-and-dfs-solution",
                "content": "\\n\\n# DFS\\n```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n\\n        if (n == 1) {\\n            return 1.0;\\n        }\\n        Map<Integer, List<Integer>> adjacency = new HashMap<>();\\n\\n        for (int[] edge : edges) {\\n            int point1 = edge[0];\\n            int point2 = edge[1];\\n            List<Integer> adj = adjacency.getOrDefault(point1, new ArrayList<>());\\n            adj.add(point2);\\n            adjacency.put(point1, adj);\\n            adj = adjacency.getOrDefault(point2, new ArrayList<>());\\n            adj.add(point1);\\n            adjacency.put(point2, adj);\\n        }\\n        Set<Integer> v = new HashSet<>();\\n        v.add(1);\\n        return recur(adjacency, v, 1, 1.0, target, t);\\n    }\\n\\n    private double recur( Map<Integer, List<Integer>> adjacency, Set<Integer> v, int node, double probability, int target, int seconds) {\\n        List<Integer> adj = adjacency.getOrDefault(node, new ArrayList<>());\\n\\n        if ((node != 1 && adj.size() == 1) || seconds == 0) {\\n\\n            if (node == target) {\\n                return probability;\\n            }\\n            return 0;\\n        }\\n        int size = adj.size();\\n\\n        for (int nextNode : adj) {\\n\\n            if (v.contains(nextNode)) {\\n                size--;\\n            }\\n        }\\n        double ans = 0;\\n\\n        for (int nextNode : adj) {\\n            \\n            if (!v.contains(nextNode)) {\\n                v.add(nextNode);\\n                ans = recur(adjacency, v, nextNode, (double)probability / size, target, seconds - 1);\\n\\n                if (ans != 0) {\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# BFS\\n```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n\\n        if (n == 1) {\\n            return 1.0;\\n        }\\n        Map<Integer, List<Integer>> adjacency = new HashMap<>();\\n\\n        for (int[] edge : edges) {\\n            int point1 = edge[0];\\n            int point2 = edge[1];\\n            List<Integer> adj = adjacency.getOrDefault(point1, new ArrayList<>());\\n            adj.add(point2);\\n            adjacency.put(point1, adj);\\n            adj = adjacency.getOrDefault(point2, new ArrayList<>());\\n            adj.add(point1);\\n            adjacency.put(point2, adj);\\n        }\\n        Set<Integer> v = new HashSet<>();\\n        v.add(1);\\n        Deque<Integer> q = new LinkedList<>();\\n        q.offer(1);\\n        double[] prob = new double[n + 1];\\n        prob[1] = 1.0;\\n\\n        while (!q.isEmpty() && t-- > 0) {\\n            int iter = q.size();\\n\\n            while (iter-- > 0) {\\n                int node = q.poll();\\n                List<Integer> adj = adjacency.getOrDefault(node, new ArrayList<>());\\n                int size = adj.size();\\n                \\n                for (int nextNode : adj) {\\n\\n                    if (v.contains(nextNode)) {\\n                        size--;\\n                    }\\n                }\\n\\n                for (int nextNode : adj) {\\n                    \\n                    if (!v.contains(nextNode)) {\\n                        v.add(nextNode);\\n                        prob[nextNode] =  prob[node] / size;\\n                        q.offer(nextNode);\\n                    }\\n                }\\n\\n                // If it cannot stop here then the probability to be here after t seconds is zero\\n                if (size > 0) {\\n                    prob[node] = 0;\\n                }\\n            }\\n            \\n        }\\n        return prob[target];\\n    }\\n}\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n\\n        if (n == 1) {\\n            return 1.0;\\n        }\\n        Map<Integer, List<Integer>> adjacency = new HashMap<>();\\n\\n        for (int[] edge : edges) {\\n            int point1 = edge[0];\\n            int point2 = edge[1];\\n            List<Integer> adj = adjacency.getOrDefault(point1, new ArrayList<>());\\n            adj.add(point2);\\n            adjacency.put(point1, adj);\\n            adj = adjacency.getOrDefault(point2, new ArrayList<>());\\n            adj.add(point1);\\n            adjacency.put(point2, adj);\\n        }\\n        Set<Integer> v = new HashSet<>();\\n        v.add(1);\\n        return recur(adjacency, v, 1, 1.0, target, t);\\n    }\\n\\n    private double recur( Map<Integer, List<Integer>> adjacency, Set<Integer> v, int node, double probability, int target, int seconds) {\\n        List<Integer> adj = adjacency.getOrDefault(node, new ArrayList<>());\\n\\n        if ((node != 1 && adj.size() == 1) || seconds == 0) {\\n\\n            if (node == target) {\\n                return probability;\\n            }\\n            return 0;\\n        }\\n        int size = adj.size();\\n\\n        for (int nextNode : adj) {\\n\\n            if (v.contains(nextNode)) {\\n                size--;\\n            }\\n        }\\n        double ans = 0;\\n\\n        for (int nextNode : adj) {\\n            \\n            if (!v.contains(nextNode)) {\\n                v.add(nextNode);\\n                ans = recur(adjacency, v, nextNode, (double)probability / size, target, seconds - 1);\\n\\n                if (ans != 0) {\\n                    return ans;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n\\n        if (n == 1) {\\n            return 1.0;\\n        }\\n        Map<Integer, List<Integer>> adjacency = new HashMap<>();\\n\\n        for (int[] edge : edges) {\\n            int point1 = edge[0];\\n            int point2 = edge[1];\\n            List<Integer> adj = adjacency.getOrDefault(point1, new ArrayList<>());\\n            adj.add(point2);\\n            adjacency.put(point1, adj);\\n            adj = adjacency.getOrDefault(point2, new ArrayList<>());\\n            adj.add(point1);\\n            adjacency.put(point2, adj);\\n        }\\n        Set<Integer> v = new HashSet<>();\\n        v.add(1);\\n        Deque<Integer> q = new LinkedList<>();\\n        q.offer(1);\\n        double[] prob = new double[n + 1];\\n        prob[1] = 1.0;\\n\\n        while (!q.isEmpty() && t-- > 0) {\\n            int iter = q.size();\\n\\n            while (iter-- > 0) {\\n                int node = q.poll();\\n                List<Integer> adj = adjacency.getOrDefault(node, new ArrayList<>());\\n                int size = adj.size();\\n                \\n                for (int nextNode : adj) {\\n\\n                    if (v.contains(nextNode)) {\\n                        size--;\\n                    }\\n                }\\n\\n                for (int nextNode : adj) {\\n                    \\n                    if (!v.contains(nextNode)) {\\n                        v.add(nextNode);\\n                        prob[nextNode] =  prob[node] / size;\\n                        q.offer(nextNode);\\n                    }\\n                }\\n\\n                // If it cannot stop here then the probability to be here after t seconds is zero\\n                if (size > 0) {\\n                    prob[node] = 0;\\n                }\\n            }\\n            \\n        }\\n        return prob[target];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189907,
                "title": "c-easy-bfs-beats-98-41",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply BFS\\n\\n# Complexity\\n- Time complexity:O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V) + O(V) + O(E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/92b0b9ea-b6b6-412e-96a0-bcf27811459e_1676477731.870351.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>>adj(n+1);\\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        // q ~ {{node,timer},probability}\\n        queue<pair<pair<int, int>,double>>q;\\n        vector<int> visited(n+1,0);\\n        q.push({{1,t},1.0});\\n        visited[1]=1;\\n        while(!q.empty()){\\n            int frontNode = q.front().first.first;\\n            int timer = q.front().first.second;\\n            double probability = q.front().second;\\n            int countUnvisited=0;\\n            for(auto neighbour : adj[frontNode])if(!visited[neighbour])countUnvisited++;\\n            if(frontNode==target){\\n                if(countUnvisited==0 || timer==0)return probability;\\n                else return 0;\\n            }\\n            q.pop();\\n            if(timer>0){\\n                for(auto neighbour : adj[frontNode]){\\n                    if(!visited[neighbour]){\\n                        visited[neighbour]=1;\\n                        if(countUnvisited!=0){\\n                            q.push({{neighbour,timer-1},probability/countUnvisited});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>>adj(n+1);\\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        // q ~ {{node,timer},probability}\\n        queue<pair<pair<int, int>,double>>q;\\n        vector<int> visited(n+1,0);\\n        q.push({{1,t},1.0});\\n        visited[1]=1;\\n        while(!q.empty()){\\n            int frontNode = q.front().first.first;\\n            int timer = q.front().first.second;\\n            double probability = q.front().second;\\n            int countUnvisited=0;\\n            for(auto neighbour : adj[frontNode])if(!visited[neighbour])countUnvisited++;\\n            if(frontNode==target){\\n                if(countUnvisited==0 || timer==0)return probability;\\n                else return 0;\\n            }\\n            q.pop();\\n            if(timer>0){\\n                for(auto neighbour : adj[frontNode]){\\n                    if(!visited[neighbour]){\\n                        visited[neighbour]=1;\\n                        if(countUnvisited!=0){\\n                            q.push({{neighbour,timer-1},probability/countUnvisited});\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3179272,
                "title": "python-o-n-bfs-know-when-to-stop-at-the-target-node",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Normal bfs. Record probability and time in each node. \\n2. Return the probability when it\\'s valid to stop at the target node. \\n3. If the target node is unreachable, return 0.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Build the adjacent list and do bfs. Each node in bfs process is `(current_node, parent_node, probability, time)`. Use `parent_node` to only walk to unvisited nodes. Use `probability` and `time` to record the probability to reach current node and how much time passed.\\n2. When reaching to a new node, find how many valid nodes `valid_children` left, and check if it\\'s ok to return:\\n   - Return when `valid_children == 0` and `current_node == target`: the frog has nowhere to go.\\n   - Return when `time == t` and `current_node == target`: time up and the frog is at the target node. The frog has to stop here even if there\\'s more valid nodes for hopping.\\n3. If the return conditions are not satisfied and there\\'re more valid nodes to go and there\\'s still time left, update the probability and time to a new node.\\n4. Return 0 if the target is unreachable.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        q = deque([(1, 0, 1, 0)])  # node, parent, probability, time\\n\\n        while q:\\n            node, parent, P, time = q.popleft()\\n            valid_children = len(graph[node]) if parent == 0 else len(graph[node]) - 1\\n            if (time == t or valid_children == 0) and node == target:\\n                return P\\n            for child in graph[node]:\\n                if child == parent:\\n                    continue\\n                if time + 1 <= t:\\n                    q.append((child, node, P / valid_children, time + 1))\\n\\n        return 0  # impossible\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        graph = defaultdict(list)\\n        for a, b in edges:\\n            graph[a].append(b)\\n            graph[b].append(a)\\n        q = deque([(1, 0, 1, 0)])  # node, parent, probability, time\\n\\n        while q:\\n            node, parent, P, time = q.popleft()\\n            valid_children = len(graph[node]) if parent == 0 else len(graph[node]) - 1\\n            if (time == t or valid_children == 0) and node == target:\\n                return P\\n            for child in graph[node]:\\n                if child == parent:\\n                    continue\\n                if time + 1 <= t:\\n                    q.append((child, node, P / valid_children, time + 1))\\n\\n        return 0  # impossible\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178565,
                "title": "very-simple-python-solution-dfs-finds-all-probabilities",
                "content": "# Intuition\\nWe assume every neighbor has equal chances of being visited.\\nWe pass down the probability of getting to each node and once we have $t$ moves, add the probability to chances array.\\n\\n# Approach\\nDPS starting on node 1, dividing probability by $(len - 1)$ of amount of children on each node since we can\\'t visit the parent.\\nWe don\\'t need a visited array since it\\'s a tree and the only visited neighbor is the parent.\\nWe return early if there\\'s no more children to visit.\\n\\n\\n# Complexity\\n- Time complexity: \\n$$O(n + e) = O(n)$$ since it\\'s a tree\\n\\n- Space complexity:\\n$$O(n)$$ to build neighbor matrix and chances matrix.\\nDFS recursion stack also cannot grow higher than $n$\\n\\n# Code\\n```python\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nbrs = [[] for _ in range(n + 1)] # build neighbor matrix\\n        for a, b in edges:\\n            nbrs[a].append(b)\\n            nbrs[b].append(a)\\n        \\n        chances = [0] * (n + 1) # probability tracker, can also only track target\\n        leng = len(nbrs[1])\\n        if not leng:  # return early if no children\\n            return 1\\n    \\n        def dfs(t: int, start: int, parent: int, chance):\\n            if t == 0 or len(nbrs[start]) == 1:  # traveled t times OR can\\'t travel anymore\\n                chances[start] += chance\\n                return\\n            \\n            leng = len(nbrs[start])\\n            for nbr in nbrs[start]:  # split chances evenly among children\\n                if nbr != parent:\\n                    dfs(t - 1, nbr, start, chance / (leng - 1))\\n        \\n        for nbr in nbrs[1]:\\n            dfs(t - 1, nbr, 1, chance = 1/leng)\\n        return chances[target]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        nbrs = [[] for _ in range(n + 1)] # build neighbor matrix\\n        for a, b in edges:\\n            nbrs[a].append(b)\\n            nbrs[b].append(a)\\n        \\n        chances = [0] * (n + 1) # probability tracker, can also only track target\\n        leng = len(nbrs[1])\\n        if not leng:  # return early if no children\\n            return 1\\n    \\n        def dfs(t: int, start: int, parent: int, chance):\\n            if t == 0 or len(nbrs[start]) == 1:  # traveled t times OR can\\'t travel anymore\\n                chances[start] += chance\\n                return\\n            \\n            leng = len(nbrs[start])\\n            for nbr in nbrs[start]:  # split chances evenly among children\\n                if nbr != parent:\\n                    dfs(t - 1, nbr, start, chance / (leng - 1))\\n        \\n        for nbr in nbrs[1]:\\n            dfs(t - 1, nbr, 1, chance = 1/leng)\\n        return chances[target]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147611,
                "title": "simple-dfs-solution-approach-python",
                "content": "# Intuition and Approach\\n* we will do dfs with following condition:\\n* we have to do 1/x so we will calculate x first.\\n* in recusion if we meet target:\\n* * check if time==0 else it do not have any child return 1\\n* otherwise return 0\\n* if returning value is >0 then return ans*no. of child of node.\\n* at the end return 1/x\\n# Complexity\\n- Time complexity:O(min(n,time))\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def check(self,n,t,target,arr,p,i):\\n        print(i)\\n        if(target-1==i and (t==0 or (len(arr[i])==1 and p!=-1) or(len(arr[i])==0 and p==-1))):\\n            return 1\\n        if(t==0):\\n            return 0\\n        for j in arr[i]:\\n            if(p==j):\\n                continue\\n            ans=self.check(n,t-1,target,arr,i,j)\\n            if(ans and p!=-1):\\n                return ans*(len(arr[i])-1)\\n            elif(ans):\\n                return ans*(len(arr[i]))\\n        return 0\\n\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        arr=[[] for i in range(n)]\\n        for i in range(len(edges)):\\n            arr[edges[i][0]-1].append(edges[i][1]-1)\\n            arr[edges[i][1]-1].append(edges[i][0]-1)\\n        \\n        ans=self.check(n,t,target,arr,-1,0)\\n        if(ans==0):\\n            return ans\\n        print(ans)\\n        return 1/ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n\\n    def check(self,n,t,target,arr,p,i):\\n        print(i)\\n        if(target-1==i and (t==0 or (len(arr[i])==1 and p!=-1) or(len(arr[i])==0 and p==-1))):\\n            return 1\\n        if(t==0):\\n            return 0\\n        for j in arr[i]:\\n            if(p==j):\\n                continue\\n            ans=self.check(n,t-1,target,arr,i,j)\\n            if(ans and p!=-1):\\n                return ans*(len(arr[i])-1)\\n            elif(ans):\\n                return ans*(len(arr[i]))\\n        return 0\\n\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        arr=[[] for i in range(n)]\\n        for i in range(len(edges)):\\n            arr[edges[i][0]-1].append(edges[i][1]-1)\\n            arr[edges[i][1]-1].append(edges[i][0]-1)\\n        \\n        ans=self.check(n,t,target,arr,-1,0)\\n        if(ans==0):\\n            return ans\\n        print(ans)\\n        return 1/ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119886,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    double ans = 0;\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        Map<Integer,Set<Integer>> graph = buildGraph(edges);\\n        if(n==1){\\n            return 1;\\n        }\\n            helper(graph,1,target,1,t,new boolean[n+1]);\\n            \\n        return ans;\\n    }\\n    \\n    public void helper(Map<Integer,Set<Integer>> graph,int currNode,int destNode,double probability,int time,boolean[] seen){\\n        //one for node 1 it will be 1/size for other it will be 1/(size -1) we are diducting 1 as parent node is also there \\n        int size = graph.get(currNode).size() - ((currNode ==1 )?0 :1);\\n        if(currNode == destNode){\\n            if(time == 0){\\n               ans = probability;\\n            }else if(time > 0 && size == 0){\\n                ans = probability;\\n            }\\n            return;\\n        }\\n           \\n        \\n        seen[currNode] = true;\\n        if(time>0)\\n        for(int childNode : graph.get(currNode)){\\n            if(seen[childNode]) continue;\\n            double prob = probability*(1/(double)size);\\n            helper(graph,childNode,destNode,prob,time - 1,seen);\\n        }\\n    } \\n    \\n    public Map<Integer,Set<Integer>> buildGraph(int[][] edges){\\n        \\n        Map<Integer,Set<Integer>> graph = new HashMap<>();\\n        \\n        for(int[] edge : edges){\\n            if(!graph.containsKey(edge[0])){\\n                graph.put(edge[0],new HashSet<>());\\n            }\\n            if(!graph.containsKey(edge[1])){\\n                graph.put(edge[1],new HashSet<>());\\n            }\\n\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        return graph;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    double ans = 0;\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        Map<Integer,Set<Integer>> graph = buildGraph(edges);\\n        if(n==1){\\n            return 1;\\n        }\\n            helper(graph,1,target,1,t,new boolean[n+1]);\\n            \\n        return ans;\\n    }\\n    \\n    public void helper(Map<Integer,Set<Integer>> graph,int currNode,int destNode,double probability,int time,boolean[] seen){\\n        //one for node 1 it will be 1/size for other it will be 1/(size -1) we are diducting 1 as parent node is also there \\n        int size = graph.get(currNode).size() - ((currNode ==1 )?0 :1);\\n        if(currNode == destNode){\\n            if(time == 0){\\n               ans = probability;\\n            }else if(time > 0 && size == 0){\\n                ans = probability;\\n            }\\n            return;\\n        }\\n           \\n        \\n        seen[currNode] = true;\\n        if(time>0)\\n        for(int childNode : graph.get(currNode)){\\n            if(seen[childNode]) continue;\\n            double prob = probability*(1/(double)size);\\n            helper(graph,childNode,destNode,prob,time - 1,seen);\\n        }\\n    } \\n    \\n    public Map<Integer,Set<Integer>> buildGraph(int[][] edges){\\n        \\n        Map<Integer,Set<Integer>> graph = new HashMap<>();\\n        \\n        for(int[] edge : edges){\\n            if(!graph.containsKey(edge[0])){\\n                graph.put(edge[0],new HashSet<>());\\n            }\\n            if(!graph.containsKey(edge[1])){\\n                graph.put(edge[1],new HashSet<>());\\n            }\\n\\n            graph.get(edge[0]).add(edge[1]);\\n            graph.get(edge[1]).add(edge[0]);\\n        }\\n        \\n        return graph;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104649,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn frog_position(n: i32, edges: Vec<Vec<i32>>, t: i32, target: i32) -> f64 {\\n        if n == 1 {\\n            return 1.0;\\n        }\\n        let mut g = vec![vec![]; n as usize + 1];\\n        for e in edges {\\n            let u = e[0] as usize;\\n            let v = e[1] as usize;\\n            g[u].push(v);\\n            g[v].push(u);\\n        }\\n        let mut seen = vec![false; n as usize + 1];\\n\\n        fn dfs(g: &Vec<Vec<usize>>, target: usize, seen: &mut Vec<bool>, i: usize, t: i32) -> f64 {\\n            if i != 1 && g[i].len() == 1 || t == 0 {\\n                return if i == target { 1.0 } else { 0.0 };\\n            }\\n            seen[i] = true;\\n            let mut res = 0.0;\\n            for j in &g[i] {\\n                if !seen[*j] {\\n                    res += dfs(g, target, seen, *j, t - 1);\\n                }\\n            }\\n            res / (g[i].len() - usize::from(i != 1)) as f64\\n        }\\n\\n        dfs(&g, target as usize, &mut seen, 1, t)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn frog_position(n: i32, edges: Vec<Vec<i32>>, t: i32, target: i32) -> f64 {\\n        if n == 1 {\\n            return 1.0;\\n        }\\n        let mut g = vec![vec![]; n as usize + 1];\\n        for e in edges {\\n            let u = e[0] as usize;\\n            let v = e[1] as usize;\\n            g[u].push(v);\\n            g[v].push(u);\\n        }\\n        let mut seen = vec![false; n as usize + 1];\\n\\n        fn dfs(g: &Vec<Vec<usize>>, target: usize, seen: &mut Vec<bool>, i: usize, t: i32) -> f64 {\\n            if i != 1 && g[i].len() == 1 || t == 0 {\\n                return if i == target { 1.0 } else { 0.0 };\\n            }\\n            seen[i] = true;\\n            let mut res = 0.0;\\n            for j in &g[i] {\\n                if !seen[*j] {\\n                    res += dfs(g, target, seen, *j, t - 1);\\n                }\\n            }\\n            res / (g[i].len() - usize::from(i != 1)) as f64\\n        }\\n\\n        dfs(&g, target as usize, &mut seen, 1, t)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3081363,
                "title": "c-dfs-not-that-much-hard-p",
                "content": "```\\nclass Solution {\\npublic:\\n    double fun(int v,  vector<vector<int>>&g,int t,int &target,vector<bool>&vis)\\n    {\\n        \\n        if(t==0 && target==v)\\n            return 1.0;\\n        else if(t==0 && target!=v)\\n            return 0;\\n        else if(t!=0 &&target==v&&v!=1)\\n        {\\n            if(g[v].size()==1)\\n                return 1;\\n        }\\n        else if(g[v].size()==1&&v!=1)\\n          return 0;\\n            \\n        \\n        vis[v]=true;\\n        \\n        double l=0;\\n        double ans=0;\\n        for(auto child :g[v])\\n        {\\n            if(vis[child])continue;\\n            \\n            l++;\\n            double z=fun(child,g,t-1,target,vis); \\n            \\n            if(ans<z)\\n                ans=z;\\n        }\\n        \\n       return ans*(1.0/l); \\n    }\\n    double frogPosition(int n, vector<vector<int>>& e, int t, int target) {\\n        vector<vector<int>>g(n+1,vector<int>());\\n        \\n        if(target==1 && e.size()==0)\\n            return 1;\\n    \\n        \\n        \\n        \\n        for(int i=0;i<e.size();i++)\\n        {\\n            g[e[i][0]].push_back(e[i][1]);\\n            g[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<bool>vis(n+1,false);\\n        return fun(1,g,t,target,vis);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    double fun(int v,  vector<vector<int>>&g,int t,int &target,vector<bool>&vis)\\n    {\\n        \\n        if(t==0 && target==v)\\n            return 1.0;\\n        else if(t==0 && target!=v)\\n            return 0;\\n        else if(t!=0 &&target==v&&v!=1)\\n        {\\n            if(g[v].size()==1)\\n                return 1;\\n        }\\n        else if(g[v].size()==1&&v!=1)\\n          return 0;\\n            \\n        \\n        vis[v]=true;\\n        \\n        double l=0;\\n        double ans=0;\\n        for(auto child :g[v])\\n        {\\n            if(vis[child])continue;\\n            \\n            l++;\\n            double z=fun(child,g,t-1,target,vis); \\n            \\n            if(ans<z)\\n                ans=z;\\n        }\\n        \\n       return ans*(1.0/l); \\n    }\\n    double frogPosition(int n, vector<vector<int>>& e, int t, int target) {\\n        vector<vector<int>>g(n+1,vector<int>());\\n        \\n        if(target==1 && e.size()==0)\\n            return 1;\\n    \\n        \\n        \\n        \\n        for(int i=0;i<e.size();i++)\\n        {\\n            g[e[i][0]].push_back(e[i][1]);\\n            g[e[i][1]].push_back(e[i][0]);\\n        }\\n        vector<bool>vis(n+1,false);\\n        return fun(1,g,t,target,vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3073579,
                "title": "simple-dfs-beats-91-construct-directed-map-by-removing-parent",
                "content": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        edge_map = {i: set() for i in range(1, n+1)}\\n        leaves = set()\\n        for edge in edges:\\n            edge_map[edge[0]].add(edge[1])\\n            edge_map[edge[1]].add(edge[0])\\n        \\n        def dfs(node, parent):\\n            if parent in edge_map[node]:\\n                edge_map[node].remove(parent)\\n            if not len(edge_map[node]):\\n                leaves.add(node)\\n            for child in edge_map[node]:\\n                dfs(child, node)\\n        dfs(1, None)\\n\\n        self.found = False\\n        self.prob_so_far = 1\\n        def dfs2(node, prob_so_far, time):\\n            if self.found:\\n                return\\n                \\n            if node == target:\\n                self.found = True\\n                if time == t or node in leaves and time < t:\\n                    self.prob_so_far = prob_so_far\\n                elif time > t or time < t:\\n                    self.prob_so_far = 0\\n                return\\n\\n            for child in edge_map[node]:\\n                dfs2(child, prob_so_far/len(edge_map[node]), time+1)\\n                \\n        dfs2(1, 1, 0)\\n        return self.prob_so_far\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        edge_map = {i: set() for i in range(1, n+1)}\\n        leaves = set()\\n        for edge in edges:\\n            edge_map[edge[0]].add(edge[1])\\n            edge_map[edge[1]].add(edge[0])\\n        \\n        def dfs(node, parent):\\n            if parent in edge_map[node]:\\n                edge_map[node].remove(parent)\\n            if not len(edge_map[node]):\\n                leaves.add(node)\\n            for child in edge_map[node]:\\n                dfs(child, node)\\n        dfs(1, None)\\n\\n        self.found = False\\n        self.prob_so_far = 1\\n        def dfs2(node, prob_so_far, time):\\n            if self.found:\\n                return\\n                \\n            if node == target:\\n                self.found = True\\n                if time == t or node in leaves and time < t:\\n                    self.prob_so_far = prob_so_far\\n                elif time > t or time < t:\\n                    self.prob_so_far = 0\\n                return\\n\\n            for child in edge_map[node]:\\n                dfs2(child, prob_so_far/len(edge_map[node]), time+1)\\n                \\n        dfs2(1, 1, 0)\\n        return self.prob_so_far\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992012,
                "title": "jump-to-child",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        adj = defaultdict(lambda : set())\\n        for one, two in edges : \\n            adj[one].add(two)\\n            adj[two].add(one)\\n        # print(adj)\\n        dp = [0 for _ in range(n + 1)]\\n        dp[1] = 1\\n        seen = set()\\n        at = [1]\\n        for _ in range(t) : \\n            newAt = []\\n            while at : \\n                node = at.pop()\\n                k = len(adj[node])\\n                if k == 0 : continue\\n                for child in adj[node] : \\n                    adj[child].remove(node)\\n                    dp[child] = dp[node] * (1 / k)\\n                    newAt.append(child)\\n                dp[node] = 0 \\n            at = newAt\\n        return dp[target]\\n\\n\\n\\n\\n\\n\\n\\n        \\n        # root = 1\\n        # self.dis = 0\\n        # self.found = False\\n        # seen = set()\\n        # def dfs(root, dis = 0) :\\n        #     if self.found : return \\n        #     if root in seen : return \\n        #     if root == target :  \\n        #         self.dis = target\\n        #         self.found = True\\n        #         return \\n        #     seen.add(root)\\n        #     for child in adj[root] : dfs(child)\\n        # dfs(root)\\n        # if not self.found or dis > t : return 0\\n        \\n\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        adj = defaultdict(lambda : set())\\n        for one, two in edges : \\n            adj[one].add(two)\\n            adj[two].add(one)\\n        # print(adj)\\n        dp = [0 for _ in range(n + 1)]\\n        dp[1] = 1\\n        seen = set()\\n        at = [1]\\n        for _ in range(t) : \\n            newAt = []\\n            while at : \\n                node = at.pop()\\n                k = len(adj[node])\\n                if k == 0 : continue\\n                for child in adj[node] : \\n                    adj[child].remove(node)\\n                    dp[child] = dp[node] * (1 / k)\\n                    newAt.append(child)\\n                dp[node] = 0 \\n            at = newAt\\n        return dp[target]\\n\\n\\n\\n\\n\\n\\n\\n        \\n        # root = 1\\n        # self.dis = 0\\n        # self.found = False\\n        # seen = set()\\n        # def dfs(root, dis = 0) :\\n        #     if self.found : return \\n        #     if root in seen : return \\n        #     if root == target :  \\n        #         self.dis = target\\n        #         self.found = True\\n        #         return \\n        #     seen.add(root)\\n        #     for child in adj[root] : dfs(child)\\n        # dfs(root)\\n        # if not self.found or dis > t : return 0\\n        \\n\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981184,
                "title": "c-easy-bfs-approach-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBFS approach described with comments\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        unordered_map<int,list<int>>adj;\\n        for(int i=0;i<edges.size();i++){\\n            int u= edges[i][0];\\n            int v= edges[i][1];\\n            // Careful given that the graph is undirected\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        // queue for BFS\\n        queue<int>q;\\n        vector<double>probability(n+1,0);\\n        vector<int>visited(n+1,0);\\n        probability[1]=1.0;\\n        q.push(1);\\n        visited[1]=1;\\n        // see that the condition for while loop has t-- so that we keep a track whether time runs out or remaining\\n        while(!q.empty() && t--){\\n            // Similar to level order traversal in Binary tree\\n            int qSize= q.size();\\n            // traverse through childNode level\\n            for(int i=0;i<qSize;i++){\\n                int frontNode= q.front();\\n                q.pop();\\n                int countUnvisited=0;\\n                // count number of unvisited nodes since frog can jump only to unvisited neighbours of a given node\\n                for(auto neighbour:adj[frontNode]){\\n                    if(!visited[neighbour]){\\n                        countUnvisited++;\\n                    }\\n                }\\n                // find probability of each neighbour-node of that node. \\n                // P(node)= probability(parent)/ number of nodes that parent can visit incl. the node itself.\\n                for(auto neighbour:adj[frontNode]){\\n                    if(!visited[neighbour]){\\n                        visited[neighbour]=1;\\n                        q.push(neighbour);\\n                        probability[neighbour]= probability[frontNode]/countUnvisited;\\n                    }   \\n                }\\n                if(countUnvisited>0){\\n                    // and since t>0 it means the frog can\\'t stay at this position and shall jump.\\n                    probability[frontNode]=0;\\n                }\\n            }\\n        }\\n        return probability[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        unordered_map<int,list<int>>adj;\\n        for(int i=0;i<edges.size();i++){\\n            int u= edges[i][0];\\n            int v= edges[i][1];\\n            // Careful given that the graph is undirected\\n            adj[u].push_back(v);\\n            adj[v].push_back(u);\\n        }\\n        // queue for BFS\\n        queue<int>q;\\n        vector<double>probability(n+1,0);\\n        vector<int>visited(n+1,0);\\n        probability[1]=1.0;\\n        q.push(1);\\n        visited[1]=1;\\n        // see that the condition for while loop has t-- so that we keep a track whether time runs out or remaining\\n        while(!q.empty() && t--){\\n            // Similar to level order traversal in Binary tree\\n            int qSize= q.size();\\n            // traverse through childNode level\\n            for(int i=0;i<qSize;i++){\\n                int frontNode= q.front();\\n                q.pop();\\n                int countUnvisited=0;\\n                // count number of unvisited nodes since frog can jump only to unvisited neighbours of a given node\\n                for(auto neighbour:adj[frontNode]){\\n                    if(!visited[neighbour]){\\n                        countUnvisited++;\\n                    }\\n                }\\n                // find probability of each neighbour-node of that node. \\n                // P(node)= probability(parent)/ number of nodes that parent can visit incl. the node itself.\\n                for(auto neighbour:adj[frontNode]){\\n                    if(!visited[neighbour]){\\n                        visited[neighbour]=1;\\n                        q.push(neighbour);\\n                        probability[neighbour]= probability[frontNode]/countUnvisited;\\n                    }   \\n                }\\n                if(countUnvisited>0){\\n                    // and since t>0 it means the frog can\\'t stay at this position and shall jump.\\n                    probability[frontNode]=0;\\n                }\\n            }\\n        }\\n        return probability[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980302,
                "title": "c-faster-than-99-25-dfs-backtracking",
                "content": "# 1377. Frog Position After T Seconds\\nHard question with basic idea, step-by-step solution:\\n![Screenshot 2023-01-01 195419.jpg](https://assets.leetcode.com/users/images/63072107-1982-4893-9b28-0e3166e42015_1672583149.6966336.jpeg)\\n\\n\\n\\n## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition came naturally as the question\\'s language is that of a generic graph-based question. Because the sum of probabilities is asked, we need to go with dfs.\\n\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\nParams: \\n- index: the current value\\n- adj: the adjacency matrix\\n- vis: the visited array\\n- curr: the probability in the current cycle\\n- currt: the current time (in secs)\\nThe basic idea is to sum all the probabilities wherein we achieve our target. in each cycle, we need to multiply the probability of this step with the current probability.\\nWe need to backtrack from each visited index once the cycle ahead of this index is completed. \\n*Note: I have commented the code at each important step so its easier to understand*\\n\\n## Complexity\\n- Time complexity: *O(exp)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    double dfs(int index, vector<vector<int>>& adj, unordered_map<int,int>&vis, double curr, int target,int currt, int t){\\n        if(currt==t){\\n            if(index==target){\\n                return curr; //if we are at the target index at t seconds, we need to add this probability.\\n            }\\n            return 0;\\n        }\\n        vis[index]++;\\n        int count=0;\\n        for(auto&i:adj[index]){\\n            if(vis[i]==0){\\n                count++; //getting the number of total available cases to calculate probability.\\n            }\\n        }\\n        if(count==0){ //the case where frog jumps at one place forever\\n            vis[index]--;\\n            if(index==target){\\n                return curr;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(index==target){ //we already reached target in this cycle, hence won\\'t be there again in the future.\\n            vis[index]--;\\n            return 0;\\n        }\\n        double sum = 0;\\n        for(auto&i:adj[index]){\\n            if(vis[i]==0){\\n                sum+=dfs(i,adj,vis,curr*((double)1/count),target,currt+1,t); //adding all the possible cases\\'s individual probabilities.\\n            }\\n        }\\n        return sum;\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> adj(n+1);\\n        unordered_map<int,int> vis;\\n        for(auto&i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]); //since the graph is unidirected\\n        }\\n        double curr = 1.000000; // since we are multiplying it at each step. think of it like this: the further away the target node, the lesser is the probability of getting there since other cases rise.\\n        vis[1]++; //we do this since we dont want to backtract from the starting index i.e. everyother index may get repeated in multiple cases but the index \\'1\\' should always be marked as visited\\n        return dfs(1,adj,vis,curr,target,0,t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double dfs(int index, vector<vector<int>>& adj, unordered_map<int,int>&vis, double curr, int target,int currt, int t){\\n        if(currt==t){\\n            if(index==target){\\n                return curr; //if we are at the target index at t seconds, we need to add this probability.\\n            }\\n            return 0;\\n        }\\n        vis[index]++;\\n        int count=0;\\n        for(auto&i:adj[index]){\\n            if(vis[i]==0){\\n                count++; //getting the number of total available cases to calculate probability.\\n            }\\n        }\\n        if(count==0){ //the case where frog jumps at one place forever\\n            vis[index]--;\\n            if(index==target){\\n                return curr;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(index==target){ //we already reached target in this cycle, hence won\\'t be there again in the future.\\n            vis[index]--;\\n            return 0;\\n        }\\n        double sum = 0;\\n        for(auto&i:adj[index]){\\n            if(vis[i]==0){\\n                sum+=dfs(i,adj,vis,curr*((double)1/count),target,currt+1,t); //adding all the possible cases\\'s individual probabilities.\\n            }\\n        }\\n        return sum;\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> adj(n+1);\\n        unordered_map<int,int> vis;\\n        for(auto&i:edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]); //since the graph is unidirected\\n        }\\n        double curr = 1.000000; // since we are multiplying it at each step. think of it like this: the further away the target node, the lesser is the probability of getting there since other cases rise.\\n        vis[1]++; //we do this since we dont want to backtract from the starting index i.e. everyother index may get repeated in multiple cases but the index \\'1\\' should always be marked as visited\\n        return dfs(1,adj,vis,curr,target,0,t);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976640,
                "title": "easy-c-solution-dfs-memoization-dp",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nRecursion and Memoization\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int vis[105];\\n    float rec(int node, int t, int target, vector<vector<int>>& adj, vector<vector<float>>& dp){\\n      if(t<0) return 0;\\n      float cnt = 0;\\n      for(auto it: adj[node]){\\n         if(!vis[it]) cnt++;\\n      }\\n      if((target == node && t >= 0 && cnt == 0) || (target == node && t == 0)) return 1;\\n      if(dp[node][t+1] != -1) return dp[node][t+1];\\n      vis[node] = 1;\\n      float prob = 0;\\n      if(cnt == 0) return dp[node][t+1] = 0;\\n      for(auto it: adj[node]){\\n         if(!vis[it]){\\n           prob += (1/cnt) * rec(it, t-1, target, adj, dp);\\n         }\\n      }\\n      return dp[node][t+1] = prob;\\n    }\\n    \\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n       vector<vector<int>> adj(n+1);\\n       for(int i=0;i<edges.size();i++){\\n         adj[edges[i][0]].push_back(edges[i][1]);\\n         adj[edges[i][1]].push_back(edges[i][0]); \\n       }\\n       memset(vis,0,sizeof(vis));\\n       vector<vector<float>> dp(n+1,vector<float>(t+2, -1));\\n       return rec(1, t, target, adj, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int vis[105];\\n    float rec(int node, int t, int target, vector<vector<int>>& adj, vector<vector<float>>& dp){\\n      if(t<0) return 0;\\n      float cnt = 0;\\n      for(auto it: adj[node]){\\n         if(!vis[it]) cnt++;\\n      }\\n      if((target == node && t >= 0 && cnt == 0) || (target == node && t == 0)) return 1;\\n      if(dp[node][t+1] != -1) return dp[node][t+1];\\n      vis[node] = 1;\\n      float prob = 0;\\n      if(cnt == 0) return dp[node][t+1] = 0;\\n      for(auto it: adj[node]){\\n         if(!vis[it]){\\n           prob += (1/cnt) * rec(it, t-1, target, adj, dp);\\n         }\\n      }\\n      return dp[node][t+1] = prob;\\n    }\\n    \\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n       vector<vector<int>> adj(n+1);\\n       for(int i=0;i<edges.size();i++){\\n         adj[edges[i][0]].push_back(edges[i][1]);\\n         adj[edges[i][1]].push_back(edges[i][0]); \\n       }\\n       memset(vis,0,sizeof(vis));\\n       vector<vector<float>> dp(n+1,vector<float>(t+2, -1));\\n       return rec(1, t, target, adj, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2974845,
                "title": "python-simple-bfs-solution-faster-than-96",
                "content": "# Code\\n```python []\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        graph, probabilities = defaultdict(list), [0] * (n + 1)\\n        for start, end in edges:\\n            graph[start].append(end)\\n            graph[end].append(start)\\n        visited, queue, probabilities[1] = set([1]), deque([1]), 1.0\\n        while queue and t:\\n            size = len(queue)\\n            for _ in range(size):\\n                curNode, edgeCount = queue.popleft(), 0\\n                for neighbor in graph[curNode]:\\n                    if neighbor not in visited: edgeCount += 1\\n                for neighbor in graph[curNode]:\\n                    if neighbor not in visited:\\n                        visited.add(neighbor)\\n                        queue.append(neighbor)\\n                        probabilities[neighbor] = probabilities[curNode] / edgeCount\\n                if edgeCount > 0:\\n                    probabilities[curNode] = 0\\n            t -= 1\\n        return probabilities[target]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```python []\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        graph, probabilities = defaultdict(list), [0] * (n + 1)\\n        for start, end in edges:\\n            graph[start].append(end)\\n            graph[end].append(start)\\n        visited, queue, probabilities[1] = set([1]), deque([1]), 1.0\\n        while queue and t:\\n            size = len(queue)\\n            for _ in range(size):\\n                curNode, edgeCount = queue.popleft(), 0\\n                for neighbor in graph[curNode]:\\n                    if neighbor not in visited: edgeCount += 1\\n                for neighbor in graph[curNode]:\\n                    if neighbor not in visited:\\n                        visited.add(neighbor)\\n                        queue.append(neighbor)\\n                        probabilities[neighbor] = probabilities[curNode] / edgeCount\\n                if edgeCount > 0:\\n                    probabilities[curNode] = 0\\n            t -= 1\\n        return probabilities[target]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2946634,
                "title": "simple-java-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public double dfs(int src,ArrayList<ArrayList<Integer>> adj,int dest,int t,boolean vis[],boolean flag)\\n    {\\n        if(src==dest && (t==0 || (t>0 && (adj.get(src).size()==1 && !flag))))\\n        return 1;\\n        if(t<0)\\n        return 0;\\n        double x=0.0;\\n        if(flag)\\n        x=(double)1/(adj.get(src).size());\\n        else\\n        {\\n        if(adj.get(src).size()!=1)\\n        x=(double)1/(adj.get(src).size()-1);\\n        else\\n        return x;\\n        }\\n        double b=0.0;\\n        vis[src]=true;\\n        for(int a:adj.get(src))\\n        {\\n            if(!vis[a])\\n            {\\n                double f=x*dfs(a,adj,dest,t-1,vis,false);\\n                if(f!=0)\\n                b=f;\\n            }    \\n        }\\n        return b;\\n    }\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        if(n==1)\\n        return (double)1;\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        adj.add(new ArrayList<>());\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]-1).add(edges[i][1]-1);\\n            adj.get(edges[i][1]-1).add(edges[i][0]-1);\\n        }\\n        boolean vis[]=new boolean[n];\\n        return dfs(0,adj,target-1,t,vis,true);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public double dfs(int src,ArrayList<ArrayList<Integer>> adj,int dest,int t,boolean vis[],boolean flag)\\n    {\\n        if(src==dest && (t==0 || (t>0 && (adj.get(src).size()==1 && !flag))))\\n        return 1;\\n        if(t<0)\\n        return 0;\\n        double x=0.0;\\n        if(flag)\\n        x=(double)1/(adj.get(src).size());\\n        else\\n        {\\n        if(adj.get(src).size()!=1)\\n        x=(double)1/(adj.get(src).size()-1);\\n        else\\n        return x;\\n        }\\n        double b=0.0;\\n        vis[src]=true;\\n        for(int a:adj.get(src))\\n        {\\n            if(!vis[a])\\n            {\\n                double f=x*dfs(a,adj,dest,t-1,vis,false);\\n                if(f!=0)\\n                b=f;\\n            }    \\n        }\\n        return b;\\n    }\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        if(n==1)\\n        return (double)1;\\n        ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n        for(int i=0;i<n;i++)\\n        adj.add(new ArrayList<>());\\n        for(int i=0;i<edges.length;i++)\\n        {\\n            adj.get(edges[i][0]-1).add(edges[i][1]-1);\\n            adj.get(edges[i][1]-1).add(edges[i][0]-1);\\n        }\\n        boolean vis[]=new boolean[n];\\n        return dfs(0,adj,target-1,t,vis,true);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939486,
                "title": "c-solution-using-dfs-99-2-faster",
                "content": "Space complexity: O(n^2)\\n\\n# Code\\n```\\nclass Solution {\\n    \\n     \\npublic:\\n    int target;\\n    long long int m=1;\\n    bool riched= false;\\n    \\n    bool dfs(int num,vector<int>&vis,vector<vector<int>>&edges,int t){\\n        int n = edges[num].size();\\n        if( (num==target and t==0) or (num==target and t>0 and n==1)){\\n            m=1;\\n            return riched = true;\\n        }\\n        else if(num==target and t>0 and n>1 ){\\n            m=0;\\n            return true;\\n        }\\n        else if(t<=0)\\n            return 0;\\n       \\n        for(int i=0;i<n;i++){\\n            if(vis[edges[num][i]]==1)\\n                continue;\\n            vis[edges[num][i]]=1;\\n            if(dfs(edges[num][i],vis,edges,t-1)==true){\\n                if(num==1) n++;\\n                m*=(n-1);\\n                return true;\\n            }\\n            vis[edges[num][i]]=1;\\n        }\\n        return false;\\n    }\\n\\n    double frogPosition(int n, vector<vector<int>>& graph, int t, int goal) {\\n        if (n==1)\\n            return 1.00000;\\n        vector<vector<int>>edges(n+1,vector<int>());\\n        vector<int>vis(n+1,0);\\n        target = goal;\\n        for(int i=0;i<graph.size();i++){\\n            edges[graph[i][0]].push_back(graph[i][1]);\\n            edges[graph[i][1]].push_back(graph[i][0]);\\n        }\\n        if(target == 1 and edges[1].size()!=0)\\n            return 0.00000;\\n        else if(target == 1 and edges[1].size()!=0)\\n            return 1.00000;\\n        vis[1]=1;\\n        dfs(1,vis,edges,t);\\n        double ans=0.00000;\\n        ans = m;\\n        if(riched==false)\\n            return 0.00000;\\n        return (double)(1)/(double)(ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    \\n     \\npublic:\\n    int target;\\n    long long int m=1;\\n    bool riched= false;\\n    \\n    bool dfs(int num,vector<int>&vis,vector<vector<int>>&edges,int t){\\n        int n = edges[num].size();\\n        if( (num==target and t==0) or (num==target and t>0 and n==1)){\\n            m=1;\\n            return riched = true;\\n        }\\n        else if(num==target and t>0 and n>1 ){\\n            m=0;\\n            return true;\\n        }\\n        else if(t<=0)\\n            return 0;\\n       \\n        for(int i=0;i<n;i++){\\n            if(vis[edges[num][i]]==1)\\n                continue;\\n            vis[edges[num][i]]=1;\\n            if(dfs(edges[num][i],vis,edges,t-1)==true){\\n                if(num==1) n++;\\n                m*=(n-1);\\n                return true;\\n            }\\n            vis[edges[num][i]]=1;\\n        }\\n        return false;\\n    }\\n\\n    double frogPosition(int n, vector<vector<int>>& graph, int t, int goal) {\\n        if (n==1)\\n            return 1.00000;\\n        vector<vector<int>>edges(n+1,vector<int>());\\n        vector<int>vis(n+1,0);\\n        target = goal;\\n        for(int i=0;i<graph.size();i++){\\n            edges[graph[i][0]].push_back(graph[i][1]);\\n            edges[graph[i][1]].push_back(graph[i][0]);\\n        }\\n        if(target == 1 and edges[1].size()!=0)\\n            return 0.00000;\\n        else if(target == 1 and edges[1].size()!=0)\\n            return 1.00000;\\n        vis[1]=1;\\n        dfs(1,vis,edges,t);\\n        double ans=0.00000;\\n        ans = m;\\n        if(riched==false)\\n            return 0.00000;\\n        return (double)(1)/(double)(ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937072,
                "title": "python-3-fast-95-easy-to-understand-with-comments",
                "content": "![image.png](https://assets.leetcode.com/users/images/57858912-8763-47a6-af94-c1256207289e_1671661325.4842625.png)\\n\\n\\n# Approach\\n\\n---\\nprob. of **cur node**  = **root\\'s prob.** * (1 / **nmb. of childrens** of root)\\n\\n---\\n\\n###  let\\'s start with example # 1\\n\\n1. calculate probabilities for nodes\\n```\\n          tree from example:\\n\\n                1 (1)\\n             /    |     \\\\\\n      2 (1/3)   7 (1/3)  3 (1/3) \\n     /       \\\\              |\\n 4 (1/6)    6 (1/6)      5 (1/3)\\n\\n\\n1 level (node 1):        probability = 1\\n   we can reach node 1 in all cases\\n\\n2 level (node 2, 7, 3):  probability = 1 * 1/3\\n   there are 3 nodes on cur. level, \\n   so multiply root\\'s probability by 1/3\\n\\n3 level (node 4, 6):     probability = 1 * 1/3 * 1/2\\n   node 2 has 2 nodes, \\n   so multiply root\\'s probability by 1/2\\n\\n3 level (node 5):        probability = 1 * 1/3 * 1\\n   node 3 has only 1 node, \\n   so multiply root\\'s probability by 1\\n\\ncheck:\\n   total probaility       = node 4 (1/6)\\n   (sum of leaf\\'s prob.)  + node 6 (1/6) \\n                          + node 7 (1/3)\\n                          + node 5 (1/3)\\n   total probaility = 1  \\n```\\n2. return target node\\'s probability in certain cases:\\n    - target node is leaf (doesn\\'t have childrens)\\n    - reached target node at time `t`\\n      *in other cases: return `0`\\n\\n# Code\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n\\n        if not edges:   return 1\\n\\n        queue   = deque()\\n        visited = set()\\n\\n        # create dictionary {node : adjacent_node_1, adjacent_node_2, ..}\\n        dct_frm = defaultdict(list)\\n        for nd_1, nd_2 in edges:\\n            dct_frm[nd_1].append(nd_2)\\n            dct_frm[nd_2].append(nd_1)\\n\\n        # create dictionary {node : number of adjacent nodes - 1}\\n        #    -1 - for root node\\n        # node 1 doesn\\'t have a root node, so:\\n        #    dct_cnt[1] = nmb. of. adj. nodes\\n        # for leaf nodes:\\n        #    dct_cnt[leaf] = 1 (in order to avoid division by zero)\\n        dct_cnt    = {k : max(len(v) - 1, 1)   for k, v in dct_frm.items()}\\n        dct_cnt[1] = len(dct_frm[1])\\n\\n        queue.append((1, 1))   # start from node 1, with probability 100%\\n        for time in range(t + 1):   # iterate t levels\\n            for _ in range(len(queue)):   # FIFO method:   first in, first out\\n                (nd, prb) = queue.popleft()\\n                \\n                if nd in visited:   continue\\n                visited.add(nd)\\n\\n                # prob for adj. node = prob for root node \\n                #                    * (1 / number of adjacent nodes w/o root)\\n                prb_adj = prb / dct_cnt[nd] \\n                \\n                if nd == target:  # reached target node                     \\n                    leaf_ind = len(set(dct_frm[nd]) - visited) == 0\\n                    if leaf_ind:    return prb_adj # target node is leaf\\n                    if time == t:   return prb_adj # reached at time t\\n                    else:           return 0       # other cases\\n\\n                for nd_adj in dct_frm[nd]:   # add adjacent nodes to queue\\n                    queue.append((nd_adj, prb_adj))\\n        \\n        return 0\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n          tree from example:\\n\\n                1 (1)\\n             /    |     \\\\\\n      2 (1/3)   7 (1/3)  3 (1/3) \\n     /       \\\\              |\\n 4 (1/6)    6 (1/6)      5 (1/3)\\n\\n\\n1 level (node 1):        probability = 1\\n   we can reach node 1 in all cases\\n\\n2 level (node 2, 7, 3):  probability = 1 * 1/3\\n   there are 3 nodes on cur. level, \\n   so multiply root\\'s probability by 1/3\\n\\n3 level (node 4, 6):     probability = 1 * 1/3 * 1/2\\n   node 2 has 2 nodes, \\n   so multiply root\\'s probability by 1/2\\n\\n3 level (node 5):        probability = 1 * 1/3 * 1\\n   node 3 has only 1 node, \\n   so multiply root\\'s probability by 1\\n\\ncheck:\\n   total probaility       = node 4 (1/6)\\n   (sum of leaf\\'s prob.)  + node 6 (1/6) \\n                          + node 7 (1/3)\\n                          + node 5 (1/3)\\n   total probaility = 1  \\n```\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n\\n        if not edges:   return 1\\n\\n        queue   = deque()\\n        visited = set()\\n\\n        # create dictionary {node : adjacent_node_1, adjacent_node_2, ..}\\n        dct_frm = defaultdict(list)\\n        for nd_1, nd_2 in edges:\\n            dct_frm[nd_1].append(nd_2)\\n            dct_frm[nd_2].append(nd_1)\\n\\n        # create dictionary {node : number of adjacent nodes - 1}\\n        #    -1 - for root node\\n        # node 1 doesn\\'t have a root node, so:\\n        #    dct_cnt[1] = nmb. of. adj. nodes\\n        # for leaf nodes:\\n        #    dct_cnt[leaf] = 1 (in order to avoid division by zero)\\n        dct_cnt    = {k : max(len(v) - 1, 1)   for k, v in dct_frm.items()}\\n        dct_cnt[1] = len(dct_frm[1])\\n\\n        queue.append((1, 1))   # start from node 1, with probability 100%\\n        for time in range(t + 1):   # iterate t levels\\n            for _ in range(len(queue)):   # FIFO method:   first in, first out\\n                (nd, prb) = queue.popleft()\\n                \\n                if nd in visited:   continue\\n                visited.add(nd)\\n\\n                # prob for adj. node = prob for root node \\n                #                    * (1 / number of adjacent nodes w/o root)\\n                prb_adj = prb / dct_cnt[nd] \\n                \\n                if nd == target:  # reached target node                     \\n                    leaf_ind = len(set(dct_frm[nd]) - visited) == 0\\n                    if leaf_ind:    return prb_adj # target node is leaf\\n                    if time == t:   return prb_adj # reached at time t\\n                    else:           return 0       # other cases\\n\\n                for nd_adj in dct_frm[nd]:   # add adjacent nodes to queue\\n                    queue.append((nd_adj, prb_adj))\\n        \\n        return 0\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2933844,
                "title": "c-o-n-bfs-explained-in-detail",
                "content": "# Approach\\nFirst of all decrement all node numbers by 1 so that numeration starts from `0`. Run BFS from `0` and for each visited node `v`, calculate it\\'s distance `d[v]` and probability `p[v]` as the probability of the parent divided by the number of potential children of that parent. Then we have the following cases:\\n- if target `trg == 0` and if there is only one node in the tree (which means `edges.size()==0`), the answer is always `1` because the frog will stay there.\\n- if target `trg == 0` and there is more than one node in the tree, the answer is always `0` because frog will jump away with the first move.\\n- if `t == d[trg]`, the answer is `p[trg]`.\\n- if `t > d[trg] and g[trg].size()<=1`, that means the frog will reach the target leaf and stay there, so the answer is still `p[trg]`.\\n- in all other situations, the answer is `0`. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int trg) {\\n        trg--;\\n        if (trg==0) {\\n            if (edges.size()==0) return 1;\\n            return 0; \\n        }\\n        vector<double> p(n);\\n        vector<vector<int>> g(n);\\n        for (vector <int> &ed : edges) {\\n            g[ed[0]-1].push_back(ed[1]-1);\\n            g[ed[1]-1].push_back(ed[0]-1); \\n        }\\n        deque <int> q(1,0);\\n        vector <int> d(n,-1); \\n        d[0] = 0;\\n        p[0] = 1; \\n        while(!q.empty()) {\\n            for (int u : g[q[0]]) {\\n                if (d[u]==-1) {\\n                    d[u] = d[q[0]]+1; \\n                    q.push_back(u);\\n                    p[u] = p[q[0]]/((double)g[q[0]].size()-(double)(q[0]!=0)); \\n                    //the number of children is decremented by one \\n                    //in case if q[0] is not the starting node, because \\n                    //we will not return to the parent of the parent \\n                }\\n            }\\n            q.pop_front();\\n        }\\n        if (t == d[trg]) return p[trg]; \\n        else if (t > d[trg] and g[trg].size()<=1) return p[trg];\\n        return 0; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int trg) {\\n        trg--;\\n        if (trg==0) {\\n            if (edges.size()==0) return 1;\\n            return 0; \\n        }\\n        vector<double> p(n);\\n        vector<vector<int>> g(n);\\n        for (vector <int> &ed : edges) {\\n            g[ed[0]-1].push_back(ed[1]-1);\\n            g[ed[1]-1].push_back(ed[0]-1); \\n        }\\n        deque <int> q(1,0);\\n        vector <int> d(n,-1); \\n        d[0] = 0;\\n        p[0] = 1; \\n        while(!q.empty()) {\\n            for (int u : g[q[0]]) {\\n                if (d[u]==-1) {\\n                    d[u] = d[q[0]]+1; \\n                    q.push_back(u);\\n                    p[u] = p[q[0]]/((double)g[q[0]].size()-(double)(q[0]!=0)); \\n                    //the number of children is decremented by one \\n                    //in case if q[0] is not the starting node, because \\n                    //we will not return to the parent of the parent \\n                }\\n            }\\n            q.pop_front();\\n        }\\n        if (t == d[trg]) return p[trg]; \\n        else if (t > d[trg] and g[trg].size()<=1) return p[trg];\\n        return 0; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930733,
                "title": "java-dfs-easy-understand",
                "content": "Build graph then do dfs find target\\n```\\nclass Solution {\\n    class Node {\\n        int prob, val, level;\\n        public Node (int val, int prob, int level) {\\n            this.val = val;\\n            this.prob = prob; // record denominator 1 / prob\\n            this.level = level; // depth of the node (time)\\n        }\\n    }\\n    private Node des;\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        HashSet<Integer> seen = new HashSet<>();\\n        List<Integer>[] graph = new List[n + 1];\\n        this.des = null;\\n        for (int i = 1; i <= n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n        for (int[] edge : edges) {\\n            int n1 = edge[0];\\n            int n2 = edge[1];\\n            graph[n1].add(n2);\\n            graph[n2].add(n1);\\n        }\\n        Node start = new Node(1, 1, 0);\\n        seen.add(1);\\n        findNode(graph, seen, start, t, target); // dfs\\n        if (des == null) {\\n            return (double)0;\\n        }\\n        return (double)1 / (double)des.prob;\\n    }\\n    public void findNode(List<Integer>[] graph, HashSet<Integer> seen, Node curr, int t, int target) {\\n        int curr_val = curr.val;\\n        List<Integer> next_level = graph[curr_val];\\n        int next_prob = curr_val == 1 ? curr.prob * next_level.size() : curr.prob * (next_level.size() - 1); // except the node 1 , other node need minus their parent node;\\n        if (curr_val == target) {\\n            if (curr.level == t) { // option1 : find the target when time just use out\\n                des = curr;\\n            }\\n            if (curr.level < t && next_prob == 0) { // still have time but the target node is the leaf of the tree\\n                des = curr;\\n            }\\n        }\\n        for(int next : next_level) {\\n            if (!seen.contains(next)) {\\n                Node child = new Node(next, next_prob, curr.level + 1);\\n                seen.add(next);\\n                findNode(graph, seen, child, t, target);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    class Node {\\n        int prob, val, level;\\n        public Node (int val, int prob, int level) {\\n            this.val = val;\\n            this.prob = prob; // record denominator 1 / prob\\n            this.level = level; // depth of the node (time)\\n        }\\n    }\\n    private Node des;\\n    public double frogPosition(int n, int[][] edges, int t, int target) {\\n        HashSet<Integer> seen = new HashSet<>();\\n        List<Integer>[] graph = new List[n + 1];\\n        this.des = null;\\n        for (int i = 1; i <= n; i++) {\\n            graph[i] = new ArrayList<Integer>();\\n        }\\n        for (int[] edge : edges) {\\n            int n1 = edge[0];\\n            int n2 = edge[1];\\n            graph[n1].add(n2);\\n            graph[n2].add(n1);\\n        }\\n        Node start = new Node(1, 1, 0);\\n        seen.add(1);\\n        findNode(graph, seen, start, t, target); // dfs\\n        if (des == null) {\\n            return (double)0;\\n        }\\n        return (double)1 / (double)des.prob;\\n    }\\n    public void findNode(List<Integer>[] graph, HashSet<Integer> seen, Node curr, int t, int target) {\\n        int curr_val = curr.val;\\n        List<Integer> next_level = graph[curr_val];\\n        int next_prob = curr_val == 1 ? curr.prob * next_level.size() : curr.prob * (next_level.size() - 1); // except the node 1 , other node need minus their parent node;\\n        if (curr_val == target) {\\n            if (curr.level == t) { // option1 : find the target when time just use out\\n                des = curr;\\n            }\\n            if (curr.level < t && next_prob == 0) { // still have time but the target node is the leaf of the tree\\n                des = curr;\\n            }\\n        }\\n        for(int next : next_level) {\\n            if (!seen.contains(next)) {\\n                Node child = new Node(next, next_prob, curr.level + 1);\\n                seen.add(next);\\n                findNode(graph, seen, child, t, target);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929802,
                "title": "video-walkthrough-python-six-line-solution",
                "content": "[Click Here For Video Walkthrough]( https://youtu.be/VjANiq3LPOE)\\n```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        G = [[] for _ in range(n+1)]\\n        for u,v in edges: G[u].append(v), G[v].append(u) \\n        def dfs(u,t,p=None,prob=1):\\n            if t == 0 or len(G[u]) - int(p != None)  < 1: return prob * int(u == target)\\n            return max([dfs(v,t-1,u, prob * 1/(len(G[u]) - int(p!=None))) for v in G[u] if v != p])\\n        return dfs(1,t)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        G = [[] for _ in range(n+1)]\\n        for u,v in edges: G[u].append(v), G[v].append(u) \\n        def dfs(u,t,p=None,prob=1):\\n            if t == 0 or len(G[u]) - int(p != None)  < 1: return prob * int(u == target)\\n            return max([dfs(v,t-1,u, prob * 1/(len(G[u]) - int(p!=None))) for v in G[u] if v != p])\\n        return dfs(1,t)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924895,
                "title": "simple-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBasic Breadth First Search\\n***Beats 99.9% Submissions***\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse each vertice mark it as visited and update the probability with each function call, update the ans probability with current probability if target found and then for all neighbours repeat the same process using BFS traversal.\\n\\n\\n# Complexity\\n- Time complexity: O(V+E)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(V+E)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   public: \\n   void func(int k, vector < vector < int >> & adj, vector < bool > & vis, int t, int target, double & p, double temp_p) {\\n      if ((t == 0 and k != target) or (t != 0 and k == target and adj[k].size() != 1)) return;\\n      if (k == target) { p += temp_p; return; }\\n      double n = temp_p / ((k == 1) ? (double) adj[k].size() : (double) adj[k].size() - 1);\\n      vis[k] = true;\\n      for (auto x: adj[k]) if (!vis[x]) func(x, adj, vis, t - 1, target, p, n);\\n      vis[k] = false;\\n      return;\\n   }\\n   double frogPosition(int n, vector < vector < int >> & edges, int t, int target) {\\n      if (n == 1 and target == 1) return 1;\\n      if (n > 1 and target == 1 and t != 0) return 0;\\n      vector < vector < int >> adj(n + 1);\\n      vector < bool > vis(n + 1, false);\\n      double p = 0.0;\\n      for (int i(0); i < edges.size(); ++i) {\\n         adj[edges[i][0]].push_back(edges[i][1]);\\n         adj[edges[i][1]].push_back(edges[i][0]);\\n      }\\n      func(1, adj, vis, t, target, p, 1);\\n      return p;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n   public: \\n   void func(int k, vector < vector < int >> & adj, vector < bool > & vis, int t, int target, double & p, double temp_p) {\\n      if ((t == 0 and k != target) or (t != 0 and k == target and adj[k].size() != 1)) return;\\n      if (k == target) { p += temp_p; return; }\\n      double n = temp_p / ((k == 1) ? (double) adj[k].size() : (double) adj[k].size() - 1);\\n      vis[k] = true;\\n      for (auto x: adj[k]) if (!vis[x]) func(x, adj, vis, t - 1, target, p, n);\\n      vis[k] = false;\\n      return;\\n   }\\n   double frogPosition(int n, vector < vector < int >> & edges, int t, int target) {\\n      if (n == 1 and target == 1) return 1;\\n      if (n > 1 and target == 1 and t != 0) return 0;\\n      vector < vector < int >> adj(n + 1);\\n      vector < bool > vis(n + 1, false);\\n      double p = 0.0;\\n      for (int i(0); i < edges.size(); ++i) {\\n         adj[edges[i][0]].push_back(edges[i][1]);\\n         adj[edges[i][1]].push_back(edges[i][0]);\\n      }\\n      func(1, adj, vis, t, target, p, 1);\\n      return p;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2920838,
                "title": "c-bfs",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>>adj(n+1);\\n        // Undirected graph\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<bool>vis(n+1,false);\\n        vector<float>pro(n+1,0.00);\\n        // Use level order traversal --> BFS --> Queue\\n        queue<int>q;\\n        q.push(1);\\n        pro[1]=1;\\n        vis[1]=true;\\n        while(!q.empty() && t){\\n            int size=q.size();\\n            while(size--){\\n                int tmp=q.front();\\n                q.pop();    \\n                int kid=0;\\n\\n                // Since this is an undirectde graph, \\n                // not all adjacent nodes will be kid, \\n                for(int i=0;i<adj[tmp].size();i++){\\n                    if(!vis[adj[tmp][i]])\\n                        kid++;\\n                }\\n                // Find the probability\\n                for(int i=0;i<adj[tmp].size();i++){\\n                    if(!vis[adj[tmp][i]]){\\n                        vis[adj[tmp][i]]=true;\\n                        q.push(adj[tmp][i]);\\n                        pro[adj[tmp][i]]=pro[tmp]/kid;\\n                    }\\n                }\\n                \\n                // Quite Ambiguous:\\n                // A node which has child nodes, will have probability 0\\n                // If it has child node, it jumps on them with same probability\\n                if(kid>0)\\n                    pro[tmp]=0;\\n            }\\n            t--;\\n        }\\n        return pro[target];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>>adj(n+1);\\n        // Undirected graph\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        vector<bool>vis(n+1,false);\\n        vector<float>pro(n+1,0.00);\\n        // Use level order traversal --> BFS --> Queue\\n        queue<int>q;\\n        q.push(1);\\n        pro[1]=1;\\n        vis[1]=true;\\n        while(!q.empty() && t){\\n            int size=q.size();\\n            while(size--){\\n                int tmp=q.front();\\n                q.pop();    \\n                int kid=0;\\n\\n                // Since this is an undirectde graph, \\n                // not all adjacent nodes will be kid, \\n                for(int i=0;i<adj[tmp].size();i++){\\n                    if(!vis[adj[tmp][i]])\\n                        kid++;\\n                }\\n                // Find the probability\\n                for(int i=0;i<adj[tmp].size();i++){\\n                    if(!vis[adj[tmp][i]]){\\n                        vis[adj[tmp][i]]=true;\\n                        q.push(adj[tmp][i]);\\n                        pro[adj[tmp][i]]=pro[tmp]/kid;\\n                    }\\n                }\\n                \\n                // Quite Ambiguous:\\n                // A node which has child nodes, will have probability 0\\n                // If it has child node, it jumps on them with same probability\\n                if(kid>0)\\n                    pro[tmp]=0;\\n            }\\n            t--;\\n        }\\n        return pro[target];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869657,
                "title": "c-dfs-solution-with-explanation-very-easy-to-understand",
                "content": "Hey there, I would discuss the c++ solution in this post.\\n**Do upvote it if you like it!!**\\n\\n#### Understanding the problem statement and role of time t\\nProblem statement is quite simply. We are simply provided with a starting vertex and need to find the probability of reaching a target vertex at t seconds. \\nHere the role of time t is to see if we can reach that node at t seconds.\\nLet\\'s say you reach target node but you still have time left and also it is not a leaf node(Will explain later why the leaf node condition also have to be checked), then in the further time frog is gonna jump on to the further levels and not gonna stay at target node. Hence the probability will be zero in this case.\\nThe concept of leaf node also plays an important role here, Since the question clearly states that frog can keep jumping on to to the leaf node, So if we reach target node under t seconds, doesn\\'t matter if time is still remaining frog can keep jumping on that node and will be on it at time = t. Hence we will return the probability.\\n\\n#### Algorithm:\\n- We are gonna create more params, One for probability and another for time and visited array.\\n- As soon as we come to a node, we mark it visited as generally done in the dfs. Then we check if we have reached the target node. If we have then we check further conditions as explained above.\\n- If the curr node is a leaf node or time == t then we return the probability else 0 indicating that it;s not possible to be at target node at t seconds.\\n- If curr != target, then we compute the new probability, New probability is very easily calculated as each edge is equiprobable, Hence we simply multiply the old probability with 1/(total edges or paths we can take now)\\n\\n#### Code:\\n```\\ntypedef vector<vector<int>> vtt;\\ntypedef vector<int> vt;\\ntypedef vector<bool> vb;\\nclass Solution\\n{\\npublic:\\n    double frogPositionHelper(vtt &adj, int time, int target, int curr, double probability, vb &visited)\\n    {\\n\\n        if (time < 0)\\n            return 0;\\n\\n        visited[curr] = true;\\n\\n        if (curr == target)\\n        {\\n            if (curr == 1)\\n            {\\n                // If it is a leaf node or time has become 0 then the probability is 1 since we started from there only, else\\n                // we need to go on further levels and we will not be able to stay on 1, Hence prob will become 0\\n                if (adj[curr].size() == 0 || time == 0)\\n                    return 1;\\n                return 0;\\n            }\\n            if (adj[curr].size() == 1 || time == 0)\\n                return probability;\\n            return 0;\\n        }\\n\\n        int neighbors = curr == 1 ? adj[curr].size() : adj[curr].size() - 1;\\n        double new_probability = probability * (1.0 / neighbors);\\n        double ans = 0;\\n        for (auto vertex : adj[curr])\\n        {\\n            if (!visited[vertex])\\n                ans = max(ans, frogPositionHelper(adj, time - 1, target, vertex, new_probability, visited));\\n        }\\n        return ans;\\n    }\\n    double frogPosition(int n, vector<vector<int>> &edges, int t, int target)\\n    {\\n\\n        // Forming the adjacency list\\n        vtt adj(n + 1, vector<int>());\\n        vb visited(n + 1, false);\\n\\n        for (auto edge : edges)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return frogPositionHelper(adj, t, target, 1, 1, visited);\\n    }\\n};\\n```\\n\\nHope you liked it!! \\n**Please let me know in case there are any questions/clarifications/corrections in the comments below.**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\ntypedef vector<vector<int>> vtt;\\ntypedef vector<int> vt;\\ntypedef vector<bool> vb;\\nclass Solution\\n{\\npublic:\\n    double frogPositionHelper(vtt &adj, int time, int target, int curr, double probability, vb &visited)\\n    {\\n\\n        if (time < 0)\\n            return 0;\\n\\n        visited[curr] = true;\\n\\n        if (curr == target)\\n        {\\n            if (curr == 1)\\n            {\\n                // If it is a leaf node or time has become 0 then the probability is 1 since we started from there only, else\\n                // we need to go on further levels and we will not be able to stay on 1, Hence prob will become 0\\n                if (adj[curr].size() == 0 || time == 0)\\n                    return 1;\\n                return 0;\\n            }\\n            if (adj[curr].size() == 1 || time == 0)\\n                return probability;\\n            return 0;\\n        }\\n\\n        int neighbors = curr == 1 ? adj[curr].size() : adj[curr].size() - 1;\\n        double new_probability = probability * (1.0 / neighbors);\\n        double ans = 0;\\n        for (auto vertex : adj[curr])\\n        {\\n            if (!visited[vertex])\\n                ans = max(ans, frogPositionHelper(adj, time - 1, target, vertex, new_probability, visited));\\n        }\\n        return ans;\\n    }\\n    double frogPosition(int n, vector<vector<int>> &edges, int t, int target)\\n    {\\n\\n        // Forming the adjacency list\\n        vtt adj(n + 1, vector<int>());\\n        vb visited(n + 1, false);\\n\\n        for (auto edge : edges)\\n        {\\n            adj[edge[0]].push_back(edge[1]);\\n            adj[edge[1]].push_back(edge[0]);\\n        }\\n\\n        return frogPositionHelper(adj, t, target, 1, 1, visited);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829904,
                "title": "python-dfs-solution",
                "content": "```\\nfrom collections import deque\\nfrom math import prod\\n\\n\\nclass Solution:\\n    def frogPosition(self, n: int, edges: list[list[int]], t: int, target: int) -> float:\\n        g = self.create_graph(n, edges)\\n        g[1].append(0)  # to make 1 a non-root node. It helps reduce if-else conditions\\n\\n        path = self.path_to_target(g, target)\\n\\n        if t + 1 < len(path):  # not able to reach to \"target\" in given time\\n            return 0\\n        elif t + 1 > len(path) and len(g[target]) > 1:\\n            # there frog can not stay at target some unvisited location which can be\\n            # visited in given time by frog\\n            return 0\\n\\n        path.pop()  # popping \"target\"\\n\\n        # subtracting 1 to avoid counting parent (Note that parent of 1 is made to be 0 to\\n        # make subtracting 1 consistent)\\n        return 1 / prod((len(g[u]) - 1 for u in path), start=1)\\n\\n    @staticmethod\\n    def create_graph(n: int, edges: list[list[int]]) -> list[list[int]]:\\n        g = [[] for _ in range(n + 1)]\\n\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n\\n        return g\\n\\n    @staticmethod\\n    def path_to_target(g, target):\\n        path, visited = deque([0]), [False] * len(g)  # adding \"0\" to avoid checking if path is empty or not in \"dfs\"\\n\\n        def dfs(u: int):\\n            if path[-1] != target:\\n                path.append(u)\\n                visited[u] = True\\n\\n                for v in g[u]:\\n                    if not visited[v]:\\n                        dfs(v)\\n\\n                if path[-1] != target:\\n                    path.pop()\\n\\n        dfs(1)\\n\\n        path.popleft()  # removing 0\\n\\n        return path\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom collections import deque\\nfrom math import prod\\n\\n\\nclass Solution:\\n    def frogPosition(self, n: int, edges: list[list[int]], t: int, target: int) -> float:\\n        g = self.create_graph(n, edges)\\n        g[1].append(0)  # to make 1 a non-root node. It helps reduce if-else conditions\\n\\n        path = self.path_to_target(g, target)\\n\\n        if t + 1 < len(path):  # not able to reach to \"target\" in given time\\n            return 0\\n        elif t + 1 > len(path) and len(g[target]) > 1:\\n            # there frog can not stay at target some unvisited location which can be\\n            # visited in given time by frog\\n            return 0\\n\\n        path.pop()  # popping \"target\"\\n\\n        # subtracting 1 to avoid counting parent (Note that parent of 1 is made to be 0 to\\n        # make subtracting 1 consistent)\\n        return 1 / prod((len(g[u]) - 1 for u in path), start=1)\\n\\n    @staticmethod\\n    def create_graph(n: int, edges: list[list[int]]) -> list[list[int]]:\\n        g = [[] for _ in range(n + 1)]\\n\\n        for u, v in edges:\\n            g[u].append(v)\\n            g[v].append(u)\\n\\n        return g\\n\\n    @staticmethod\\n    def path_to_target(g, target):\\n        path, visited = deque([0]), [False] * len(g)  # adding \"0\" to avoid checking if path is empty or not in \"dfs\"\\n\\n        def dfs(u: int):\\n            if path[-1] != target:\\n                path.append(u)\\n                visited[u] = True\\n\\n                for v in g[u]:\\n                    if not visited[v]:\\n                        dfs(v)\\n\\n                if path[-1] != target:\\n                    path.pop()\\n\\n        dfs(1)\\n\\n        path.popleft()  # removing 0\\n\\n        return path\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821600,
                "title": "bfs-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> adj(n+1);\\n        vector<int> visited(n+1,0);\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        queue<pair<int,pair<float,int>>> q;\\n        q.push({1,{1,0}});\\n        visited[1] = 1;\\n        \\n        while(!q.empty()){\\n            auto it=  q.front(); q.pop();\\n            int currNode= it.first;\\n            float currValue = it.second.first;\\n            int currTime = it.second.second;\\n            \\n            if(currNode == target){\\n                if(currTime == t) return currValue;\\n                else if(currTime < t){\\n                    for(auto neighbour: adj[currNode]){\\n                        if(visited[neighbour] == 1) continue;\\n                        if(visited[neighbour] == 0){\\n                            return 0;\\n                        }\\n                    }\\n                    return currValue; \\n                }\\n            }\\n            \\n            float prob; float totalPossibleWays;\\n            float size =  adj[currNode].size();\\n            if(adj[currNode].size() -1 != 0 && currNode != 1){\\n                totalPossibleWays = size -1;\\n                prob = 1/totalPossibleWays;\\n            }\\n            else if( currNode == 1){\\n                totalPossibleWays = size;\\n                prob = 1/totalPossibleWays;\\n            }\\n            \\n            \\n            for(auto it: adj[currNode]){\\n                int adjNode = it;\\n                if(visited[adjNode] == 0){\\n                    q.push({adjNode,{ currValue*prob, currTime+1}});\\n                    visited[adjNode] = 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        vector<vector<int>> adj(n+1);\\n        vector<int> visited(n+1,0);\\n        for(auto it: edges){\\n            adj[it[0]].push_back(it[1]);\\n            adj[it[1]].push_back(it[0]);\\n        }\\n        \\n        queue<pair<int,pair<float,int>>> q;\\n        q.push({1,{1,0}});\\n        visited[1] = 1;\\n        \\n        while(!q.empty()){\\n            auto it=  q.front(); q.pop();\\n            int currNode= it.first;\\n            float currValue = it.second.first;\\n            int currTime = it.second.second;\\n            \\n            if(currNode == target){\\n                if(currTime == t) return currValue;\\n                else if(currTime < t){\\n                    for(auto neighbour: adj[currNode]){\\n                        if(visited[neighbour] == 1) continue;\\n                        if(visited[neighbour] == 0){\\n                            return 0;\\n                        }\\n                    }\\n                    return currValue; \\n                }\\n            }\\n            \\n            float prob; float totalPossibleWays;\\n            float size =  adj[currNode].size();\\n            if(adj[currNode].size() -1 != 0 && currNode != 1){\\n                totalPossibleWays = size -1;\\n                prob = 1/totalPossibleWays;\\n            }\\n            else if( currNode == 1){\\n                totalPossibleWays = size;\\n                prob = 1/totalPossibleWays;\\n            }\\n            \\n            \\n            for(auto it: adj[currNode]){\\n                int adjNode = it;\\n                if(visited[adjNode] == 0){\\n                    q.push({adjNode,{ currValue*prob, currTime+1}});\\n                    visited[adjNode] = 1;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771454,
                "title": "c-dfs-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int tmax, tgt;\\n    double prob;\\n    vector<vector<int>> adj; // for adj list\\n    \\n    void dfs(int s, int k, int anc, double p){\\n        //if we have reached target and either time == given time or no further traversal is \\n        //possible\\n        if(s == tgt && (k == tmax || adj[s].size() == 1)) {\\n            prob = p;\\n            return;\\n        }\\n        //if target is not reached and time increases beyond given time\\n        if(k == tmax) return;\\n        \\n        //-1 as the edge is bidirectional so one edge is used for coming to the next node\\n        //so -1 for it\\n        int nmbr = adj[s].size() - 1;\\n        \\n        for(auto &i: adj[s]){\\n            //checking for cycle\\n            if(i != anc) \\n                dfs(i, k+1, s, p/nmbr);\\n        }\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        adj.resize(n+1);\\n        tmax = t;\\n        tgt = target;\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        adj[1].push_back(0);\\n        dfs(1, 0, 0, (double)1);\\n        return prob;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int tmax, tgt;\\n    double prob;\\n    vector<vector<int>> adj; // for adj list\\n    \\n    void dfs(int s, int k, int anc, double p){\\n        //if we have reached target and either time == given time or no further traversal is \\n        //possible\\n        if(s == tgt && (k == tmax || adj[s].size() == 1)) {\\n            prob = p;\\n            return;\\n        }\\n        //if target is not reached and time increases beyond given time\\n        if(k == tmax) return;\\n        \\n        //-1 as the edge is bidirectional so one edge is used for coming to the next node\\n        //so -1 for it\\n        int nmbr = adj[s].size() - 1;\\n        \\n        for(auto &i: adj[s]){\\n            //checking for cycle\\n            if(i != anc) \\n                dfs(i, k+1, s, p/nmbr);\\n        }\\n    }\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        adj.resize(n+1);\\n        tmax = t;\\n        tgt = target;\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back(edges[i][1]);\\n            adj[edges[i][1]].push_back(edges[i][0]);\\n        }\\n        adj[1].push_back(0);\\n        dfs(1, 0, 0, (double)1);\\n        return prob;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741106,
                "title": "c-simple-bfs-solution-detailed-explanation",
                "content": "```\\nclass Solution {\\npublic:    \\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n\\t\\t// Create graph with given edges\\n        vector<vector<int>> graph(n+1);\\n        for(auto it: edges){\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<bool> visited(n+1, false);\\n\\t\\tqueue<pair<pair<int,int>,double>> q; // {{src, time}, prob}\\n        \\n\\t\\t// Start from vertex 1, with time = 0 and probability = 1.0\\n        q.push({{1, 0}, 1.0});\\n        visited[1] = true;\\n        \\n        while(!q.empty()){\\n            int src = q.front().first.first;\\n            int time = q.front().first.second;\\n            double val = q.front().second;\\n            q.pop();\\n            \\n\\t\\t\\t// Reached target at time t\\n            if(src == target && time == t){\\n                return val;\\n            }\\n            \\n\\t\\t\\t// Time completed\\n            if(time >= t){\\n                continue;\\n            }\\n            \\n\\t\\t\\t// Count no.of unvisited adjcent vertices\\n            int n = 0;\\n            for(auto adj: graph[src]){\\n                if(!visited[adj]){\\n                    n++;\\n                }\\n            }\\n            \\n            double prob = (1.0/n);\\n            bool flag = false;\\n            for(auto adj: graph[src]){\\n                if(!visited[adj]){\\n                    q.push({{adj, time+1}, val*prob});\\n                    visited[adj] = true;\\n                    flag = true;\\n                }\\n            }\\n            \\n\\t\\t\\t// No other unvisited adj vertices --> jump in the same vertex\\n            if(!flag){\\n                q.push({{src, time+1}, val});\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n\\t\\t// Create graph with given edges\\n        vector<vector<int>> graph(n+1);\\n        for(auto it: edges){\\n            graph[it[0]].push_back(it[1]);\\n            graph[it[1]].push_back(it[0]);\\n        }\\n        \\n        vector<bool> visited(n+1, false);\\n\\t\\tqueue<pair<pair<int,int>,double>> q; // {{src, time}, prob}\\n        \\n\\t\\t// Start from vertex 1, with time = 0 and probability = 1.0\\n        q.push({{1, 0}, 1.0});\\n        visited[1] = true;\\n        \\n        while(!q.empty()){\\n            int src = q.front().first.first;\\n            int time = q.front().first.second;\\n            double val = q.front().second;\\n            q.pop();\\n            \\n\\t\\t\\t// Reached target at time t\\n            if(src == target && time == t){\\n                return val;\\n            }\\n            \\n\\t\\t\\t// Time completed\\n            if(time >= t){\\n                continue;\\n            }\\n            \\n\\t\\t\\t// Count no.of unvisited adjcent vertices\\n            int n = 0;\\n            for(auto adj: graph[src]){\\n                if(!visited[adj]){\\n                    n++;\\n                }\\n            }\\n            \\n            double prob = (1.0/n);\\n            bool flag = false;\\n            for(auto adj: graph[src]){\\n                if(!visited[adj]){\\n                    q.push({{adj, time+1}, val*prob});\\n                    visited[adj] = true;\\n                    flag = true;\\n                }\\n            }\\n            \\n\\t\\t\\t// No other unvisited adj vertices --> jump in the same vertex\\n            if(!flag){\\n                q.push({{src, time+1}, val});\\n            }\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2714110,
                "title": "c-easy-bfs-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        unordered_map<int,vector<int>> mpp;\\n        for(vector<int> ed:edges){\\n            if(ed[1]==1){\\n                mpp.clear();\\n                break;\\n            }\\n            mpp[ed[0]].push_back(ed[1]);\\n        }\\n        if(mpp.empty()) for(vector<int> ed:edges) mpp[ed[1]].push_back(ed[0]);\\n        queue<pair<pair<int,int>,double>> q;\\n        q.push({{1,0},1.0});\\n        int node, curr_t, len;\\n        double prob, curr_prob;\\n        while(!q.empty()){\\n            node = q.front().first.first;\\n            len = mpp[node].size();\\n            curr_t = q.front().first.second;\\n            prob = q.front().second;\\n            if((node==target && curr_t<=t) && (curr_t==t || mpp[node].size()==0)) return prob;\\n            else if(node==target) return 0.0;\\n            else if(curr_t>t) return 0.0;\\n            curr_prob = (1.0/len);\\n            for(int child:mpp[node]) q.push({{child,curr_t+1},prob*curr_prob});\\n            q.pop();\\n        }\\n        return 0.0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        unordered_map<int,vector<int>> mpp;\\n        for(vector<int> ed:edges){\\n            if(ed[1]==1){\\n                mpp.clear();\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2708585,
                "title": "c-dfs-variation-explained-0-n-time",
                "content": "```\\nclass Solution {    \\npublic:\\n   \\n    bool DFS(vector<vector<int>> &adj, vector<bool> &visited, int t, \\n             int src, int dest, double &prob)\\n    {\\n        /* we may be able to reach destination even before the time ends.\\n         * it can be a leaf node, if its a leaf node , its adjacancy has size of 1 (i.e., the                \\n         *  parent), rest is normal DFS (if path exists to destination).\\n        */        \\n         \\n        if( src != 1 && adj[src].size() == 1 || t==0)\\n            return (src==dest);\\n        \\n        visited[src] = true;\\n              \\n        for(auto neigh:adj[src])\\n        {\\n            if(visited[neigh] ==  false && DFS(adj,visited,t-1,neigh,dest,prob))\\n            {\\n               prob = prob* (1.0/((src!=1)? adj[src].size() -1 :adj[src].size()));\\n               return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        \\n        if(n==1) return 1.0;\\n        \\n        vector<vector<int>> adj(n+1);\\n        vector<bool> visited(n+1,false);\\n        double prob=1;\\n        for(auto e:edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        if(DFS(adj,visited,t,1,target,prob))\\n             return prob;\\n       \\n        return 0.0;\\n    }\\n};\\n```\\nTC : O(N)\\nSC : O(N)\\n\\n**please upvote if its useful..correct me if iam wrong.**",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {    \\npublic:\\n   \\n    bool DFS(vector<vector<int>> &adj, vector<bool> &visited, int t, \\n             int src, int dest, double &prob)\\n    {\\n        /* we may be able to reach destination even before the time ends.\\n         * it can be a leaf node, if its a leaf node , its adjacancy has size of 1 (i.e., the                \\n         *  parent), rest is normal DFS (if path exists to destination).\\n        */        \\n         \\n        if( src != 1 && adj[src].size() == 1 || t==0)\\n            return (src==dest);\\n        \\n        visited[src] = true;\\n              \\n        for(auto neigh:adj[src])\\n        {\\n            if(visited[neigh] ==  false && DFS(adj,visited,t-1,neigh,dest,prob))\\n            {\\n               prob = prob* (1.0/((src!=1)? adj[src].size() -1 :adj[src].size()));\\n               return true;\\n            }\\n        }\\n        return false;\\n    }\\n    \\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        \\n        if(n==1) return 1.0;\\n        \\n        vector<vector<int>> adj(n+1);\\n        vector<bool> visited(n+1,false);\\n        double prob=1;\\n        for(auto e:edges)\\n        {\\n            adj[e[0]].push_back(e[1]);\\n            adj[e[1]].push_back(e[0]);\\n        }\\n        \\n        if(DFS(adj,visited,t,1,target,prob))\\n             return prob;\\n       \\n        return 0.0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705973,
                "title": "c-dfs-easy-approach-beast-98-68",
                "content": "```\\nclass Solution {\\npublic:\\n    double ans = 0;\\n    \\n    void dfs(int src, vector<int> adj[], vector<int> &vis, double prob, int time, int des){\\n        \\n        vis[src] = 1;\\n        int child = 0;\\n        for(auto i: adj[src]){\\n            if(!vis[i]){\\n                child++;\\n            }\\n        }\\n\\n        // cout<<prob<<\" \"<<src<<\" \"<<child<<\" \"<<time<<endl;\\n        if(src == des and (time == 0 || child == 0)){\\n            ans = prob;\\n            return;\\n        }\\n        if(time == 0){\\n            return;\\n        }\\n        prob = prob/child;\\n        // cout<<prob<<\" \";\\n        // cout<<time<<\" \"<<src<<endl;\\n        \\n        for(auto i: adj[src]){\\n            if(!vis[i]){\\n                dfs(i, adj, vis, prob, time-1, des);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        \\n        vector<int> adj[n+1];\\n        for(auto i: edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        \\n        vector<int> vis(n+1, 0);\\n        double prob = 1;\\n        int time = t;\\n        \\n        dfs(1, adj, vis, prob, time, target);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    double ans = 0;\\n    \\n    void dfs(int src, vector<int> adj[], vector<int> &vis, double prob, int time, int des){\\n        \\n        vis[src] = 1;\\n        int child = 0;\\n        for(auto i: adj[src]){\\n            if(!vis[i]){\\n                child++;\\n            }\\n        }\\n\\n        // cout<<prob<<\" \"<<src<<\" \"<<child<<\" \"<<time<<endl;\\n        if(src == des and (time == 0 || child == 0)){\\n            ans = prob;\\n            return;\\n        }\\n        if(time == 0){\\n            return;\\n        }\\n        prob = prob/child;\\n        // cout<<prob<<\" \";\\n        // cout<<time<<\" \"<<src<<endl;\\n        \\n        for(auto i: adj[src]){\\n            if(!vis[i]){\\n                dfs(i, adj, vis, prob, time-1, des);\\n            }\\n        }\\n        return;\\n    }\\n    \\n    double frogPosition(int n, vector<vector<int>>& edges, int t, int target) {\\n        \\n        vector<int> adj[n+1];\\n        for(auto i: edges){\\n            adj[i[0]].push_back(i[1]);\\n            adj[i[1]].push_back(i[0]);\\n        }\\n        \\n        vector<int> vis(n+1, 0);\\n        double prob = 1;\\n        int time = t;\\n        \\n        dfs(1, adj, vis, prob, time, target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2696691,
                "title": "python-solution-easy-bfs",
                "content": "```\\nclass Solution:\\n    # BFS problem\\n    # When we do BFS, we can calculate the probability on the fly\\n    # Specifically, we look at how many viable next step are there, so that the probability is previous probability / # of next viable steps\\n    \\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        graph = [set() for i in range(n)]\\n        for x, y in edges:\\n            graph[x-1].add(y-1)\\n            graph[y-1].add(x-1)\\n        \\n        dq, visited, step = deque(), [False]*n, 0\\n        dq.append([0,1])\\n        visited[0] = True\\n        while dq and step <= t:\\n            for i in range(len(dq)):\\n                node, prob = dq.popleft()\\n                if node == target - 1 and step == t:\\n                    return prob\\n                count = 0\\n                for nxt in graph[node]:\\n                    if not visited[nxt]:\\n                        count += 1\\n                if count == 0:\\n                    dq.append([node, prob])\\n                else:\\n                    new_prob = prob / count\\n                    for nxt in graph[node]:\\n                        if not visited[nxt]:\\n                            visited[nxt] = True\\n                            dq.append([nxt, new_prob])\\n            step += 1\\n        return 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # BFS problem\\n    # When we do BFS, we can calculate the probability on the fly\\n    # Specifically, we look at how many viable next step are there, so that the probability is previous probability / # of next viable steps\\n    \\n    def frogPosition(self, n: int, edges: List[List[int]], t: int, target: int) -> float:\\n        graph = [set() for i in range(n)]\\n        for x, y in edges:\\n            graph[x-1].add(y-1)\\n            graph[y-1].add(x-1)\\n        \\n        dq, visited, step = deque(), [False]*n, 0\\n        dq.append([0,1])\\n        visited[0] = True\\n        while dq and step <= t:\\n            for i in range(len(dq)):\\n                node, prob = dq.popleft()\\n                if node == target - 1 and step == t:\\n                    return prob\\n                count = 0\\n                for nxt in graph[node]:\\n                    if not visited[nxt]:\\n                        count += 1\\n                if count == 0:\\n                    dq.append([node, prob])\\n                else:\\n                    new_prob = prob / count\\n                    for nxt in graph[node]:\\n                        if not visited[nxt]:\\n                            visited[nxt] = True\\n                            dq.append([nxt, new_prob])\\n            step += 1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680766,
                "title": "python-simple-dfs",
                "content": "\\n    def frogPosition(self, n, edges, t, target):\\n        dict1, visited, stack = defaultdict(list), set(), [(1,1.0,0)]\\n        \\n        for i,j in edges:\\n            dict1[i].append(j)\\n            dict1[j].append(i)\\n            \\n            \\n        while stack:\\n            node, prob, time = stack.pop(0)\\n            visited.add(node)\\n            count = 0\\n            \\n            for neighbor in dict1[node]:\\n                if neighbor not in visited:\\n                    count += 1\\n                    \\n            if node == target:\\n                if time == t or (time < t and count == 0):\\n                    return prob\\n                return 0\\n            \\n            for neighbor in dict1[node]:\\n                if neighbor not in visited:\\n                    stack.append([neighbor,prob/count,time+1])",
                "solutionTags": [],
                "code": "\\n    def frogPosition(self, n, edges, t, target):\\n        dict1, visited, stack = defaultdict(list), set(), [(1,1.0,0)]\\n        \\n        for i,j in edges:\\n            dict1[i].append(j)\\n            dict1[j].append(i)\\n            \\n            \\n        while stack:\\n            node, prob, time = stack.pop(0)\\n            visited.add(node)\\n            count = 0\\n            \\n            for neighbor in dict1[node]:\\n                if neighbor not in visited:\\n                    count += 1\\n                    \\n            if node == target:\\n                if time == t or (time < t and count == 0):\\n                    return prob\\n                return 0\\n            \\n            for neighbor in dict1[node]:\\n                if neighbor not in visited:\\n                    stack.append([neighbor,prob/count,time+1])",
                "codeTag": "Python3"
            }
        ],
        "discussions": [
            {
                "id": 1565405,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1566169,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1566924,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1565264,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1570271,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1566987,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1573527,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1573504,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1575310,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1844518,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1565405,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1566169,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1566924,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1565264,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1570271,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1566987,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1573527,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1573504,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1575310,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            },
            {
                "id": 1844518,
                "content": [
                    {
                        "username": "HeadingWest",
                        "content": "# Case One\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nAnswer 0\\n\\n# Caes Two\\n3\\n[[2,1],[3,2]]\\n1\\n2\\n\\nAnswer 1.0\\n\\n# Question\\n\\nif you can jump between edge[i][0] and edge[i][1]. then case one should be 0.25, otherwise if you can only jump from edge[i][0] to edge[i][1] then case two should be 0.  Did i get something wrong???"
                    },
                    {
                        "username": "raebel-christo",
                        "content": "Yep, the thing is, note that in that example, you will get 0 as expected if you go to 2,4, or 7. This is because they are not the end nodes and the frog will continue jumping to the next node until it cannot jump to any unvisited node and until the time runs out. So basically, unless t=1, your probability to land on 7, 2 or 4 will be 0. Its the perfect test case to actually verify the understanding of the question."
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "You can\\'t jump up in the tree, you can only go down and down untill you can not"
                    },
                    {
                        "username": "monstercoder",
                        "content": "Considering some of the others, medium seems appropriate."
                    },
                    {
                        "username": "stefan1096",
                        "content": "After seeing n<=100 and difficulty level,I thought I was missing something"
                    },
                    {
                        "username": "NeaI_Wu",
                        "content": "\\n8 \\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]] \\n7 \\n7\\n\\nDoesn\\'t [7,1] mean that you can go from 1 to 7?"
                    },
                    {
                        "username": "yanrucheng",
                        "content": "Testing is fine, submission is killing me."
                    },
                    {
                        "username": "CharlesFly",
                        "content": "The correct description should be \"Return the probability that at the t-th second the frog is on the vertex target.\"\\nIt is not \"after t seconds\"."
                    },
                    {
                        "username": "abmiitd",
                        "content": "8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nExpected is 0\\nbut it is undirected graph and hence expected should be 0.25"
                    },
                    {
                        "username": "milklluu",
                        "content": "Input:8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\nOutput:0.25000\\nExpected:0.0\\nThis tree is as following graph and seems the answer is obvious. but the right answer was not 1/4\\n\\n ![image](https://assets.leetcode.com/users/milklluu/image_1584669015.png)\\n"
                    },
                    {
                        "username": "user1906Bt",
                        "content": "I\\'m trying to work out BFS, but for the test 103\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\nOutput: 0\\nMine: 0.25\\n\\nWhy? Frog can get to node 7 with a probabilty 0.25. Node 1 has 4 childs. What don\\'t I get here? Thanks for sharing thoughts."
                    },
                    {
                        "username": "raebel-christo",
                        "content": "It can go to 7, yes, that\\'s true. But there\\'s still 6 more seconds left after this jump and the frog HAS to jump to a different unvisited vertex, 8 in this case. It will thereafter jump on 8 forever. When the time crosses 7 seconds, the frog is still at 8 and can never go back to 7 since it was vistied early. Hence probability is 0."
                    },
                    {
                        "username": "coder31",
                        "content": "case 1:\\n8\\n[[2,1],[3,2],[4,1],[5,1],[6,4],[7,1],[8,7]]\\n7\\n7\\n\\ncase 2:\\n7\\n[[1,2],[1,3],[1,7],[2,4],[2,6],[3,5]]\\n20\\n6\\n\\n\\nwhy case 1 has output zero but case 2 has output 0.1666, which i see as contridictory as in both cases t > number of levels?\\n"
                    },
                    {
                        "username": "nandini_s18",
                        "content": "the catch in thisproblem is in line \"when the frog can not jump to any unvisited vertex, it jumps forever on the same vertex.\" \\nmeans from will stop jumping to other vertex only if the current vertex is leaf node"
                    }
                ]
            }
        ]
    },
    {
        "title": "Replace Employee ID With The Unique Identifier",
        "question_content": "<p>Table: <code>Employees</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| name          | varchar |\n+---------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains the id and the name of an employee in a company.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Table: <code>EmployeeUNI</code></p>\n\n<pre>\n+---------------+---------+\n| Column Name   | Type    |\n+---------------+---------+\n| id            | int     |\n| unique_id     | int     |\n+---------------+---------+\n(id, unique_id) is the primary key (combination of columns with unique values) for this table.\nEach row of this table contains the id and the corresponding unique id of an employee in the company.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to show the <strong>unique ID </strong>of each user, If a user does not have a unique ID replace just show <code>null</code>.</p>\n\n<p>Return the result table in <strong>any</strong> order.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nEmployees table:\n+----+----------+\n| id | name     |\n+----+----------+\n| 1  | Alice    |\n| 7  | Bob      |\n| 11 | Meir     |\n| 90 | Winston  |\n| 3  | Jonathan |\n+----+----------+\nEmployeeUNI table:\n+----+-----------+\n| id | unique_id |\n+----+-----------+\n| 3  | 1         |\n| 11 | 2         |\n| 90 | 3         |\n+----+-----------+\n<strong>Output:</strong> \n+-----------+----------+\n| unique_id | name     |\n+-----------+----------+\n| null      | Alice    |\n| null      | Bob      |\n| 2         | Meir     |\n| 3         | Winston  |\n| 1         | Jonathan |\n+-----------+----------+\n<strong>Explanation:</strong> \nAlice and Bob do not have a unique ID, We will show null instead.\nThe unique ID of Meir is 2.\nThe unique ID of Winston is 3.\nThe unique ID of Jonathan is 1.\n</pre>\n",
        "solutions": [
            {
                "id": 3549131,
                "title": "sql-left-join-easy-solution",
                "content": "# Intuition\\n***The second table was simply joined to the first table***\\n\\n\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/26e0d290-2307-44c7-9aac-3bb5fb65ad4d_1684683655.5701103.png)\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect \\neu.unique_id as unique_id, e.name as name\\nfrom Employees e left join EmployeeUNI eu on e.id = eu.id\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\neu.unique_id as unique_id, e.name as name\\nfrom Employees e left join EmployeeUNI eu on e.id = eu.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3623218,
                "title": "simple-easy-approach-ii-left-join-using-sql",
                "content": "# Proceed only if u want the best and easy solution :) \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Select the attributes from the column which are needed \\n2. Joining the tables via `LEFT JOIN`.\\n3. Menitoning the joining attribute. i.e. `id` which is common in both the tables.\\n> Do post your doubts in the comment section. \\n# Code\\n```SQL []\\nSELECT eu.unique_id , e.name FROM \\nEmployees e  LEFT JOIN EmployeeUNI eu \\nUSING(id)\\n\\n```\\n\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/0b7115cb-7a3f-47ca-8b3e-6d72d887e84c_1686427694.0278566.jpeg)\\n",
                "solutionTags": [
                    "MySQL",
                    "Math",
                    "Database",
                    "Data Stream",
                    "Counting Sort"
                ],
                "code": "```SQL []\\nSELECT eu.unique_id , e.name FROM \\nEmployees e  LEFT JOIN EmployeeUNI eu \\nUSING(id)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3782400,
                "title": "best-optimum-solution-with-explanation-using-joins",
                "content": "\\n\\n# Intuition\\nThe problem asks us to replace the employee ID with the unique identifier for each employee. We need to retrieve the unique identifier and the name for each employee from the respective tables.\\n\\n# Approach\\n1. Imagine we have two tables: one for the employees and one for their unique identifiers.\\n1. We want to combine the information from both tables to get the unique identifier and the name for each employee.\\n1. To do this, we use a left join, which means we take all the employees from the first table (Employees) and match them with their unique identifiers from the second table (EmployeeUNI) based on their IDs.\\n1. By performing this left join, we make sure that all the employees from the first table are included in the result, even if they don\\'t have a matching unique identifier in the second table.\\n1. The result of our query will be a combination of the unique identifier and the name for each employee.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the query depends on the number of rows in the Employees table and the EmployeeUNI table, as well as the efficiency of the join operation. Assuming the join operation has been appropriately indexed, the time complexity is generally $$O(n+m)$$, where n is the number of rows in the Employees table and m is the number of rows in the EmployeeUNI table.\\n\\n- Space complexity:\\nThe space complexity depends on the result set produced by the query. The space required to store the result set will depend on the number of matching rows between the Employees table and the EmployeeUNI table. If the result set is significantly smaller than the original tables, the space complexity can be considered relatively low.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT eu.unique_id AS unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu USING(id)\\n\\n```\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT eu.unique_id AS unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu USING(id)\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3946968,
                "title": "pandas-simple-2-steps-code-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    # Merge the two tables on the \\'id\\' column using a left join\\n    merged = employees.merge(employee_uni, on=\\'id\\', how=\\'left\\')\\n    \\n    # Return the result table with the \\'unique_id\\' column\\n    result = merged[[\\'unique_id\\',\\'name\\']]\\n    \\n    return result\\n\\n```\\n\\n![upvote img.jpg](https://assets.leetcode.com/users/images/8596af58-ba62-43e2-95ba-526fcb9ffe2b_1692728271.3586912.jpeg)\\n",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    # Merge the two tables on the \\'id\\' column using a left join\\n    merged = employees.merge(employee_uni, on=\\'id\\', how=\\'left\\')\\n    \\n    # Return the result table with the \\'unique_id\\' column\\n    result = merged[[\\'unique_id\\',\\'name\\']]\\n    \\n    return result\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3361912,
                "title": "the-given-sql-query-selects-the-unique-id-and-name-of-employees-from-two-different-tables",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given SQL query selects the unique ID and name of employees from two different tables, Employees and EmployeeUNI, using a left join. The left join ensures that all the records from the Employees table are selected, along with matching records from the EmployeeUNI table, if any. If there are no matching records in the EmployeeUNI table, the result will still include the record from the Employees table, with null values for the EmployeeUNI columns.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo retrieve the required data, the SQL query uses a left join to match the ID columns from both the Employees and EmployeeUNI tables. The \"ON\" clause specifies that the ID column in the Employees table should match the ID column in the EmployeeUNI table. This will join the two tables based on the matching IDs, allowing the query to retrieve the required data from both tables.\\n\\nThe \"SELECT\" statement specifies that the unique_id and name columns should be retrieved from the resulting table. This will produce a table with two columns, one containing the unique ID and the other containing the name of the employee.\\n# Complexity\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe complexity of this SQL query depends on the size of the two tables being joined, as well as the number of records that match in both tables. The left join operation can be computationally expensive for large tables, especially if there are no matching records in the EmployeeUNI table. However, in this case, the query is only selecting two columns, which can reduce the computational complexity. Overall, the complexity of this query is likely to be moderate, assuming that the tables are not excessively large and that there are a reasonable number of matching records.\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect unique_id, name from Employees as e\\nleft join EmployeeUNI as c\\non e.id = c.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect unique_id, name from Employees as e\\nleft join EmployeeUNI as c\\non e.id = c.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 553238,
                "title": "mysql-simple-solution",
                "content": "```\\nSELECT eu.unique_id,\\n        e.name\\nFROM Employees as e\\nLEFT JOIN EmployeeUNI as eu\\nON e.id = eu.id;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT eu.unique_id,\\n        e.name\\nFROM Employees as e\\nLEFT JOIN EmployeeUNI as eu\\nON e.id = eu.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3699750,
                "title": "easily-understandable-solution",
                "content": "# Code\\n```\\nSELECT eu.unique_id , e.name     \\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu\\nON e.id = eu.id\\n\\n```PLEASE UPVOTE TO MOTIVATE ME WRITE MORE SOLUTION\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT eu.unique_id , e.name     \\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu\\nON e.id = eu.id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1203553,
                "title": "let-s-give-some-love-to-right-join",
                "content": "```\\nselect eu.unique_id, e.name\\nfrom employeeuni eu\\nright join employees e on eu.id= e.id;\\n```",
                "solutionTags": [],
                "code": "```\\nselect eu.unique_id, e.name\\nfrom employeeuni eu\\nright join employees e on eu.id= e.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872822,
                "title": "pandas-vs-sql-elegant-short-all-30-days-of-pandas-solutions",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```Python []\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    return pd.merge(\\n        employees, employee_uni, how=\\'left\\', on=\\'id\\'\\n    )[[\\'unique_id\\', \\'name\\']]\\n```\\n```SQL []\\nSELECT eu.unique_id,\\n       e.name\\n  FROM Employees e\\n      LEFT JOIN EmployeeUNI eu\\n          ON e.id = eu.id;\\n```\\n\\n# Important!\\n###### If you like the solution or find it useful, feel free to **upvote** for it, it will support me in creating high quality solutions)\\n\\n# 30 Days of Pandas solutions\\n\\n### Data Filtering \\u2705\\n- [Big Countries](https://leetcode.com/problems/big-countries/solutions/3848474/pandas-elegant-short-1-line/)\\n- [Recyclable and Low Fat Products](https://leetcode.com/problems/recyclable-and-low-fat-products/solutions/3848500/pandas-elegant-short-1-line/)\\n- [Customers Who Never Order](https://leetcode.com/problems/customers-who-never-order/solutions/3848527/pandas-elegant-short-1-line/)\\n- [Article Views I](https://leetcode.com/problems/article-views-i/solutions/3867192/pandas-elegant-short-1-line/)\\n\\n\\n### String Methods \\u2705\\n- [Invalid Tweets](https://leetcode.com/problems/invalid-tweets/solutions/3849121/pandas-elegant-short-1-line/)\\n- [Calculate Special Bonus](https://leetcode.com/problems/calculate-special-bonus/solutions/3867209/pandas-elegant-short-1-line/)\\n- [Fix Names in a Table](https://leetcode.com/problems/fix-names-in-a-table/solutions/3849167/pandas-elegant-short-1-line/)\\n- [Find Users With Valid E-Mails](https://leetcode.com/problems/find-users-with-valid-e-mails/solutions/3849177/pandas-elegant-short-1-line/)\\n- [Patients With a Condition](https://leetcode.com/problems/patients-with-a-condition/solutions/3849196/pandas-elegant-short-1-line-regex/)\\n\\n\\n### Data Manipulation \\u2705\\n- [Nth Highest Salary](https://leetcode.com/problems/nth-highest-salary/solutions/3867257/pandas-elegant-short-1-line/)\\n- [Second Highest Salary](https://leetcode.com/problems/second-highest-salary/solutions/3867278/pandas-elegant-short/)\\n- [Department Highest Salary](https://leetcode.com/problems/department-highest-salary/solutions/3867312/pandas-elegant-short-1-line/)\\n- [Rank Scores](https://leetcode.com/problems/rank-scores/solutions/3872817/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Delete Duplicate Emails](https://leetcode.com/problems/delete-duplicate-emails/solutions/3849211/pandas-elegant-short/)\\n- [Rearrange Products Table](https://leetcode.com/problems/rearrange-products-table/solutions/3849226/pandas-elegant-short-1-line/)\\n\\n\\n### Statistics \\u2705\\n- [The Number of Rich Customers](https://leetcode.com/problems/the-number-of-rich-customers/solutions/3849251/pandas-elegant-short-1-line/)\\n- [Immediate Food Delivery I](https://leetcode.com/problems/immediate-food-delivery-i/solutions/3872719/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Count Salary Categories](https://leetcode.com/problems/count-salary-categories/solutions/3872801/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Find Total Time Spent by Each Employee](https://leetcode.com/problems/find-total-time-spent-by-each-employee/solutions/3872715/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Game Play Analysis I](https://leetcode.com/problems/game-play-analysis-i/solutions/3863223/pandas-elegant-short-1-line/)\\n- [Number of Unique Subjects Taught by Each Teacher](https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/solutions/3863239/pandas-elegant-short-1-line/)\\n- [Classes More Than 5 Students](https://leetcode.com/problems/classes-more-than-5-students/solutions/3863249/pandas-elegant-short/)\\n- [Customer Placing the Largest Number of Orders](https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/solutions/3863257/pandas-elegant-short-1-line/)\\n- [Group Sold Products By The Date](https://leetcode.com/problems/group-sold-products-by-the-date/solutions/3863267/pandas-elegant-short-1-line/)\\n- [Daily Leads and Partners](https://leetcode.com/problems/daily-leads-and-partners/solutions/3863279/pandas-elegant-short-1-line/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Actors and Directors Who Cooperated At Least Three Times](https://leetcode.com/problems/actors-and-directors-who-cooperated-at-least-three-times/solutions/3863309/pandas-elegant-short/)\\n- [Replace Employee ID With The Unique Identifier](https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/solutions/3872822/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Students and Examinations](https://leetcode.com/problems/students-and-examinations/solutions/3872699/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Managers with at Least 5 Direct Reports](https://leetcode.com/problems/managers-with-at-least-5-direct-reports/solutions/3872861/pandas-elegant-short/)\\n- [Sales Person](https://leetcode.com/problems/sales-person/solutions/3872712/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "MySQL",
                    "Pandas"
                ],
                "code": "```Python []\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    return pd.merge(\\n        employees, employee_uni, how=\\'left\\', on=\\'id\\'\\n    )[[\\'unique_id\\', \\'name\\']]\\n```\n```SQL []\\nSELECT eu.unique_id,\\n       e.name\\n  FROM Employees e\\n      LEFT JOIN EmployeeUNI eu\\n          ON e.id = eu.id;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3584620,
                "title": "explanation-of-how-to-use-join-correctly-mysql-pandas-beats-100",
                "content": "# Intuition\\n- To show the unique_id of **each user**, we perform **LEFT JOIN with Employees on the Left Side**. \\n- This is because the **Employees table has every employee** in the table whereas EmployeeUNI does not include all employees since not all employees have unique_id (Read this again to understand why Left Join is used here). \\n- You can solve this using Right Join as well with Employees on the Right Side.  \\n- When we perform LEFT JOIN with Employees on the left side, it tells the database to include all the rows of Employee (table on left side) and only the intersecting or common rows from EmployeeUNI (i.e. table on right side). \\n\\n# Approach\\n1. In the SELECT statement, we retrieve the unique_id from EmployeeUni and names from Employees tables respectively.\\n2. In the FROM statement, we perform LEFT JOIN with Employee on the left side. The tables are renamed for ease of access and the query can also be written without renaming the tables.\\n\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT EU.unique_id, E.name\\nFROM Employees as E LEFT OUTER JOIN EmployeeUNI as EU \\nON E.id=EU.id \\n```\\n```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    # Merge the DataFrames using the \\'id\\' column and keep only necessary columns\\n    merged_df = pd.merge(employees, employee_uni, how=\\'left\\', on=\\'id\\')\\n    \\n    # Select the columns \\'unique_id\\' and \\'name\\' from the merged DataFrame\\n    result_df = merged_df[[\\'unique_id\\', \\'name\\']]\\n    \\n    return result_df\\n```\\n\\n### Please upvote if you find my solution helpful.",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT EU.unique_id, E.name\\nFROM Employees as E LEFT OUTER JOIN EmployeeUNI as EU \\nON E.id=EU.id \\n```\n```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    # Merge the DataFrames using the \\'id\\' column and keep only necessary columns\\n    merged_df = pd.merge(employees, employee_uni, how=\\'left\\', on=\\'id\\')\\n    \\n    # Select the columns \\'unique_id\\' and \\'name\\' from the merged DataFrame\\n    result_df = merged_df[[\\'unique_id\\', \\'name\\']]\\n    \\n    return result_df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3862024,
                "title": "100-easy-fast-clean-2-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE !\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT  unique_id, name FROM  Employees LEFT OUTER JOIN EmployeeUNI \\n\\nUSING (id)\\n```\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/f64fef5f-bb21-46d2-a35a-a33f00adacaa_1691214535.4260023.jpeg)\\n",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT  unique_id, name FROM  Employees LEFT OUTER JOIN EmployeeUNI \\n\\nUSING (id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 959752,
                "title": "the-best-way",
                "content": "```sql\\n# Write your MySQL query statement below\\nSELECT unique_id, name\\nFROM Employees\\nLEFT JOIN  EmployeeUNI\\nUSING (id)\\n",
                "solutionTags": [],
                "code": "```sql\\n# Write your MySQL query statement below\\nSELECT unique_id, name\\nFROM Employees\\nLEFT JOIN  EmployeeUNI\\nUSING (id)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3998379,
                "title": "i-feel-fantastic-having-achieved-this-solution",
                "content": "# Intuition\\nMy intuition suggests that employing a \"join\" operation is essential to reach the solution. Initially, I considered using an \"INNER JOIN\" along with \"NULLIF,\" but upon closer analysis, I believe that a \"LEFT JOIN\" would be a more suitable choice.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT unique_id, name \\nFROM Employees\\nLEFT JOIN EmployeeUNI \\nON Employees.id = EmployeeUNI.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT unique_id, name \\nFROM Employees\\nLEFT JOIN EmployeeUNI \\nON Employees.id = EmployeeUNI.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587783,
                "title": "mysql-solution-for-replace-employee-id-with-the-unique-identifier-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe solution involves performing a left join between the Employees and EmployeeUNI tables to retrieve the unique ID of each employee. If an employee doesn\\'t have a unique ID, the query will return NULL for the unique_id column. The result is a list of employees with their corresponding unique IDs or NULL values.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Perform a left join between the Employees and EmployeeUNI tables based on the id column.\\n1. Retrieve the unique_id column from the EmployeeUNI table and the name column from the Employees table.\\n1. For each employee, the query will match their id in both tables and return their unique ID or NULL if no match is found.\\n1. Return the result table containing the unique_id and name columns.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution depends on the number of rows in the Employees table, denoted as N, and the number of rows in the EmployeeUNI table, denoted as M. The time complexity of the left join operation is O(N + M). Since there is no additional filtering or sorting, the overall time complexity remains O(N + M).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution depends on the number of rows returned in the result table. In the worst case, if all employees have a unique ID, the result will contain N rows. Therefore, the space complexity is O(N) to store the result table.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT EmployeeUNI.unique_id, Employees.name\\nFROM Employees\\nLEFT JOIN EmployeeUNI ON Employees.id = EmployeeUNI.id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT EmployeeUNI.unique_id, Employees.name\\nFROM Employees\\nLEFT JOIN EmployeeUNI ON Employees.id = EmployeeUNI.id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521818,
                "title": "check-easy-solution-with-the-right-join-also",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe are just selecting column we want from EmployeeUNI and then right join to the Employee table while merging ids of both table.\\nunique id will be NULL if no id is present on the Employee table.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT unique_id, name FROM EmployeeUNI as e1 \\nRIGHT JOIN Employees as e \\nON e.id = e1.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT unique_id, name FROM EmployeeUNI as e1 \\nRIGHT JOIN Employees as e \\nON e.id = e1.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976799,
                "title": "pandas-simple-1-line-solution-for-beginners",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    \\n    result = pd.merge(employees, employee_uni, on=\\'id\\', how=\\'left\\')\\n    \\n    return result[[\\'unique_id\\', \\'name\\']]\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    \\n    result = pd.merge(employees, employee_uni, on=\\'id\\', how=\\'left\\')\\n    \\n    return result[[\\'unique_id\\', \\'name\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3898088,
                "title": "sql-joins-pandas",
                "content": "# My SQL\\nIt\\'s clearly a task of left join. Despite the **unique_id** being **null**, we need to show the **Employee** name. That\\'s why you should use `LEFT JOIN` in this case.\\n\\n![image.png](https://assets.leetcode.com/users/images/57069ef8-706f-4327-8d2b-bf540cbefe54_1691824952.855059.png)\\n\\n``` SQL []\\n# Write your MySQL query statement below\\nSELECT euni.unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI euni ON e.id=euni.id\\n```\\n\\n# Pandas\\n\\nIf you understand the SQL query, you can easily write it in Pandas.\\n\\n``` python3 []\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n  emps_merged = pd.merge(\\n                        employees, \\n                        employee_uni, \\n                        on=\\'id\\', \\n                        how=\\'left\\'\\n                    )\\n  return emps_merged[[\\'unique_id\\', \\'name\\']]\\n```",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "``` SQL []\\n# Write your MySQL query statement below\\nSELECT euni.unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI euni ON e.id=euni.id\\n```\n``` python3 []\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n  emps_merged = pd.merge(\\n                        employees, \\n                        employee_uni, \\n                        on=\\'id\\', \\n                        how=\\'left\\'\\n                    )\\n  return emps_merged[[\\'unique_id\\', \\'name\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3787072,
                "title": "usign-left-join",
                "content": "Using Simple Join will only give the id\\'s which have values not the null ones so use `LEFT JOIN` on EmployeeUNI table . This will include all the names from the table .\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect EmployeeUNI.unique_id,Employees.name FROM Employees LEFT JOIN EmployeeUNI\\non Employees.id=EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect EmployeeUNI.unique_id,Employees.name FROM Employees LEFT JOIN EmployeeUNI\\non Employees.id=EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3578349,
                "title": "mysql-simple-and-clean-beats-88",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n# Intuition\\nThe problem asks us to show the unique ID of each user. If a user does not have a unique ID, we should show null. Our first thought is to use an SQL query to join the Employees and EmployeeUNI tables and select the unique_id and name columns.\\n\\n# Approach\\n1. Select the unique_id column from the EmployeeUNI table and the name column from the Employees table.\\n2. Use a LEFT JOIN to join the Employees table with the EmployeeUNI table on the id column.\\n3. The final query should look like this:\\n\\n```\\nSELECT u.unique_id, e.name from Employees e\\nLEFT JOIN EmployeeUNI u\\nON u.id = e.id;\\n```\\n# Complexity\\n- Time complexity: The time complexity of this query depends on the size of the Employees and EmployeeUNI tables and the efficiency of the database management system.\\n- Space complexity: The space complexity of this query is constant as it only returns two columns with the unique IDs and names of employees.\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT u.unique_id, e.name from Employees e\\nLEFT JOIN EmployeeUNI u\\nON u.id = e.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888539,
                "title": "left-join-on-pandas-simple",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMerging the DF\\'s through the common key by left and return it\\n\\n# Complexity\\n- Time complexity:  O(n)\\n\\n- Space complexity:  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    return employees.merge(employee_uni,how=\\'left\\',on=\\'id\\')[[\\'unique_id\\',\\'name\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    return employees.merge(employee_uni,how=\\'left\\',on=\\'id\\')[[\\'unique_id\\',\\'name\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3791447,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSelect empuni.unique_id as unique_id, emp.name as name \\nfrom Employees emp left join EmployeeUNI empuni\\non emp.id = empuni.id;\\n```\\n![image.png](https://assets.leetcode.com/users/images/322ed0a5-d976-4447-a1ba-bb0d096bdd5f_1689841666.049566.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect empuni.unique_id as unique_id, emp.name as name \\nfrom Employees emp left join EmployeeUNI empuni\\non emp.id = empuni.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3787224,
                "title": "easy-mysql-solution",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect  u.unique_id ,e.name from Employees AS e left JOIN EmployeeUNI  as u ON e.id = u.id;  \\n\\n# Write your MySQL query statement below\\n# select eu.unique_id , e.name from Employees as e left join EmployeeUNI  as eu on e.id = eu.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect  u.unique_id ,e.name from Employees AS e left JOIN EmployeeUNI  as u ON e.id = u.id;  \\n\\n# Write your MySQL query statement below\\n# select eu.unique_id , e.name from Employees as e left join EmployeeUNI  as eu on e.id = eu.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721972,
                "title": "simplest-sql-solution-left-join-easy-to-understand",
                "content": "**Intuition**\\n\\nUsing the **LEFT JOIN** keyword will return all records from the left table (Employees), and the matching records from the right table (EmployeeUNI).\\n\\n**Code**\\n```\\nSELECT Employees.name, EmployeeUNI.unique_id FROM Employees\\nLEFT JOIN EmployeeUNI\\nON Employees.id = EmployeeUNI.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Employees.name, EmployeeUNI.unique_id FROM Employees\\nLEFT JOIN EmployeeUNI\\nON Employees.id = EmployeeUNI.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3702938,
                "title": "beats-100-easy-to-read",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect\\n    unique_id , name \\nfrom \\n    Employees e left join EmployeeUNI u\\non \\n    e.id = u.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect\\n    unique_id , name \\nfrom \\n    Employees e left join EmployeeUNI u\\non \\n    e.id = u.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3634674,
                "title": "ehh-simple-solution",
                "content": "\\n# Code\\n```\\nselect unique_id, name from Employees left join EmployeeUNI using (id)\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect unique_id, name from Employees left join EmployeeUNI using (id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3554946,
                "title": "simple-solution",
                "content": "# Code\\n```\\nSelect eu.unique_id, e.name \\nfrom Employees e left join EmployeeUNI eu\\non e.id = eu.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSelect eu.unique_id, e.name \\nfrom Employees e left join EmployeeUNI eu\\non e.id = eu.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3550741,
                "title": "easy-sql-code-left-join-concept-used",
                "content": "# Intuition\\n`LEFT JOIN` Employees table with EmployeeUNI table.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below (e1->Employees , e2->EmployeeUNI)\\nSELECT e2.unique_id,e1.name FROM Employees AS e1 LEFT JOIN EMployeeUNI AS e2 ON e1.id=e2.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below (e1->Employees , e2->EmployeeUNI)\\nSELECT e2.unique_id,e1.name FROM Employees AS e1 LEFT JOIN EMployeeUNI AS e2 ON e1.id=e2.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3542709,
                "title": "full-optimized-and-easy-query",
                "content": "# Code\\n```\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n  EmployeeUNI.unique_id,\\n  Employees.name\\nFROM\\n  Employees\\nLEFT JOIN\\n  EmployeeUNI ON Employees.id = EmployeeUNI.id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\n\\nSELECT\\n  EmployeeUNI.unique_id,\\n  Employees.name\\nFROM\\n  Employees\\nLEFT JOIN\\n  EmployeeUNI ON Employees.id = EmployeeUNI.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2242116,
                "title": "sql-solution",
                "content": "```\\nselect t2.unique_id, t1.name from Employees as t1 \\nleft join EmployeeUNI as t2 \\non t1.id = t2.id ; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect t2.unique_id, t1.name from Employees as t1 \\nleft join EmployeeUNI as t2 \\non t1.id = t2.id ; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1449721,
                "title": "mysql-mssql-right-join",
                "content": "SELECT unique_id,name\\nFROM EmployeeUNI\\nRIGHT JOIN Employees\\nON EmployeeUNI.id=Employees.id",
                "solutionTags": [],
                "code": "SELECT unique_id,name\\nFROM EmployeeUNI\\nRIGHT JOIN Employees\\nON EmployeeUNI.id=Employees.id",
                "codeTag": "Unknown"
            },
            {
                "id": 845401,
                "title": "extremely-easy-solution",
                "content": "SELECT unique_id,name\\nFROM Employees e1 Left JOIN EmployeeUNI e2\\nON e1.id = e2.id\\n",
                "solutionTags": [],
                "code": "SELECT unique_id,name\\nFROM Employees e1 Left JOIN EmployeeUNI e2\\nON e1.id = e2.id\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4066321,
                "title": "pandas-easy-replace-employee-id-with-the-unique-identifier",
                "content": "[see the successfully Accepted Submission](https://leetcode.com/submissions/detail/1054005094/)\\n\\n```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    \\n    merge_df = pd.merge(employees, employee_uni, how=\\'left\\', left_on=\\'id\\', right_on=\\'id\\')\\n\\n    result_df = merge_df[[\\'unique_id\\', \\'name\\']]\\n    \\n    return result_df\\n```\\n\\n**Intuition Explained**\\nFirst we merge the provided employees, employee_uni DataFrames resulting from the left join of \\'employees\\' and \\'employee_uni\\' based on the \\'id\\' column. As a result we will have a new DataFrame which contains all columns from both DataFrames with matching rows, and NaN values where there are no matches in the \\'employee_uni\\' DataFrame.\\n```\\n    merge_df = pd.merge(employees, employee_uni, how=\\'left\\', left_on=\\'id\\', right_on=\\'id\\')\\n```\\n\\nThen, by selecting \\'unique_id\\', \\'name\\' columns we create a new DataFrame containing only the \\'unique_id\\' and \\'name\\' columns from the merged DataFrame on the above.\\n```\\n    result_df = merge_df[[\\'unique_id\\', \\'name\\']]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/5c6ba1ce-5f00-4089-b3d4-5de6c27870c8_1695163323.9097738.jpeg)\\n",
                "solutionTags": [
                    "Merge Sort"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    \\n    merge_df = pd.merge(employees, employee_uni, how=\\'left\\', left_on=\\'id\\', right_on=\\'id\\')\\n\\n    result_df = merge_df[[\\'unique_id\\', \\'name\\']]\\n    \\n    return result_df\\n```\n```\\n    merge_df = pd.merge(employees, employee_uni, how=\\'left\\', left_on=\\'id\\', right_on=\\'id\\')\\n```\n```\\n    result_df = merge_df[[\\'unique_id\\', \\'name\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3964851,
                "title": "beats-99-easy-concise-solution-stepbystep-detailed-approach",
                "content": "\\n# Approach\\nThe solution is a Python function that takes two pandas DataFrames (`employees` and `employee_uni`) as input and returns a modified DataFrame containing the unique IDs and names of employees.\\n\\nHere\\'s a breakdown of the approach used in the solution:\\n\\n1. The function `replace_employee_id` accepts two pandas DataFrames, `employees` and `employee_uni`.\\n\\n2. Inside the function, a dictionary called `unique_id_dict` is created. This dictionary is constructed by zipping the \\'id\\' column from the `employee_uni` DataFrame as keys and the \\'unique_id\\' column from the same DataFrame as values. This dictionary maps employee IDs to their corresponding unique IDs.\\n\\n3. The next step involves modifying the `employees` DataFrame. A new column named \\'unique_id\\' is added to the DataFrame using the `apply` function. For each row in the \\'id\\' column of the `employees` DataFrame, the lambda function checks if the employee\\'s ID exists in the `unique_id_dict`. If it does, the corresponding unique ID is retrieved using the `get` method of the dictionary; otherwise, `None` is used.\\n\\n4. Finally, the function returns a new DataFrame containing only the \\'unique_id\\' and \\'name\\' columns.\\n\\nThis approach effectively combines the employee data from the `employees` DataFrame with the unique ID information from the `employee_uni` DataFrame. It utilizes a dictionary lookup to efficiently retrieve unique IDs based on employee IDs, resulting in a modified DataFrame with the desired information. The time complexity of this solution is proportional to the number of employees (linear), and the space complexity is also proportional to the number of employees (linear), assuming that the size of the `employee_uni` DataFrame is not significantly larger than the `employees` DataFrame.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n**- Time complexity:**\\n1. Creating the dictionary `unique_id_dict` involves iterating through the \\'id\\' and \\'unique_id\\' columns of the `employee_uni` DataFrame. Let\\'s denote the number of rows in this DataFrame as `n`.\\n   -Time Complexity: O(n)\\n\\n2. Adding a new column \\'unique_id\\' to the `employees` DataFrame involves using the `apply` function. For each employee, a dictionary lookup is performed using the `get` method, which has an average time complexity of O(1), assuming a good hash distribution.\\n   -Time Complexity: O(n)\\n\\n3. Selecting and returning the \\'unique_id\\' and \\'name\\' columns using indexing takes constant time.\\n   -Time Complexity: O(1)\\n\\n**Overall Time Complexity:** **O(n)**\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n**- Space complexity:**\\n1. The `unique_id_dict` dictionary is created to store unique IDs mapped to employee IDs. In the worst case, all employees might have unique IDs, resulting in space complexity proportional to the number of employees.\\n   -Space Complexity: O(n)\\n\\n2. The modified `employees` DataFrame includes two additional columns (\\'unique_id\\' and \\'name\\') for each employee.\\n   -Space Complexity: O(n)\\n\\n3. Temporary variables and internal data structures used within the function are constant in terms of input size and can be considered as O(1).\\n\\n**Overall Space Complexity:** **O(n)**\\n\\nIn summary, the solution has a time complexity of O(n) and a space complexity of O(n), where \\'n\\' is the number of employees in the DataFrame. This complexity arises mainly due to the need to process each employee and maintain the dictionary of unique IDs.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    # Create a dictionary of unique IDs\\n    unique_id_dict = dict(zip(employee_uni[\\'id\\'], employee_uni[\\'unique_id\\']))\\n\\n    # Add a new column \\'unique_id\\' to the Employees DataFrame\\n    employees[\\'unique_id\\'] = employees[\\'id\\'].apply(lambda x: unique_id_dict.get(x, None))\\n\\n    return employees[[\\'unique_id\\',\\'name\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    # Create a dictionary of unique IDs\\n    unique_id_dict = dict(zip(employee_uni[\\'id\\'], employee_uni[\\'unique_id\\']))\\n\\n    # Add a new column \\'unique_id\\' to the Employees DataFrame\\n    employees[\\'unique_id\\'] = employees[\\'id\\'].apply(lambda x: unique_id_dict.get(x, None))\\n\\n    return employees[[\\'unique_id\\',\\'name\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3820182,
                "title": "replace-employee-id-with-the-unique-identifier-mysql-solution-code",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect EmployeeUNI.unique_id, Employees.name  \\nfrom Employees\\nleft join EmployeeUNI\\non Employees.id = EmployeeUNI.id\\norder by name;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect EmployeeUNI.unique_id, Employees.name  \\nfrom Employees\\nleft join EmployeeUNI\\non Employees.id = EmployeeUNI.id\\norder by name;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3751512,
                "title": "simp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT eu.unique_id , e.name FROM Employees e LEFT JOIN EmployeeUNI eu ON e.id = eu.id\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT eu.unique_id , e.name FROM Employees e LEFT JOIN EmployeeUNI eu ON e.id = eu.id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3671825,
                "title": "select-from-employees-left-join-employeeuni-on-employees-id-employeeuni-id",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT unique_id, name\\nFROM Employees LEFT JOIN EmployeeUNI ON Employees.id = EmployeeUNI.id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT unique_id, name\\nFROM Employees LEFT JOIN EmployeeUNI ON Employees.id = EmployeeUNI.id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3548398,
                "title": "simple-query-using-left-outer-join-will-work-on-all-3-db",
                "content": "\\n```\\nselect name, unique_id from employees e left join EmployeeUNI en on e.id=en.id;\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nselect name, unique_id from employees e left join EmployeeUNI en on e.id=en.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3500067,
                "title": "easy-solution",
                "content": "# Code\\n```\\nselect e2.unique_id as unique_id , e1.name name\\nfrom Employees e1 full join EmployeeUNI e2\\non e1.id = e2.id\\norder by name\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle"
                ],
                "code": "```\\nselect e2.unique_id as unique_id , e1.name name\\nfrom Employees e1 full join EmployeeUNI e2\\non e1.id = e2.id\\norder by name\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3425863,
                "title": "left-join",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect unique_id,name from employees e left join  employeeuni eu on\\ne.id=eu.id\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect unique_id,name from employees e left join  employeeuni eu on\\ne.id=eu.id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1644564,
                "title": "775-ms-faster-than-100-00-of-mysql-online-submissions",
                "content": "select b.unique_id, a.name\\nfrom Employees a left join EmployeeUNI b using (id)\\n;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select b.unique_id, a.name\\nfrom Employees a left join EmployeeUNI b using (id)\\n;",
                "codeTag": "Unknown"
            },
            {
                "id": 1303072,
                "title": "simple-mysql-solution",
                "content": "```\\nselect unique_id, name\\nfrom employees left join employeeuni using(id)\\n```",
                "solutionTags": [],
                "code": "```\\nselect unique_id, name\\nfrom employees left join employeeuni using(id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1202011,
                "title": "let-mysql-do-the-work-understand-sql-use-left-join",
                "content": "```\\nselect unique_id, name\\nfrom Employees\\nleft join EmployeeUNI\\non Employees.id = EmployeeUNI.id; \\n```",
                "solutionTags": [],
                "code": "```\\nselect unique_id, name\\nfrom Employees\\nleft join EmployeeUNI\\non Employees.id = EmployeeUNI.id; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1160135,
                "title": "left-join",
                "content": "```\\nselect unique_id,name\\nfrom employees\\nleft join employeeuni\\non employees.id = employeeUNI.id\\n",
                "solutionTags": [],
                "code": "```\\nselect unique_id,name\\nfrom employees\\nleft join employeeuni\\non employees.id = employeeUNI.id\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1083009,
                "title": "left-join",
                "content": "```\\n# Write your MySQL query statement below\\n-- Employees         EmployeeUNI\\n-- 1 2 3 4     5          1 2 3\\n-- 1 2 3 null  null\\n\\nSelect \\n    EmployeeUNI.unique_id AS unique_id,\\n    Employees.name AS name\\nFrom \\n    Employees\\nLeft Join\\n    EmployeeUNI\\n    On Employees.id = EmployeeUNI.id\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\n-- Employees         EmployeeUNI\\n-- 1 2 3 4     5          1 2 3\\n-- 1 2 3 null  null\\n\\nSelect \\n    EmployeeUNI.unique_id AS unique_id,\\n    Employees.name AS name\\nFrom \\n    Employees\\nLeft Join\\n    EmployeeUNI\\n    On Employees.id = EmployeeUNI.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 841044,
                "title": "any-db-left-join-100",
                "content": "```\\nselect euni.unique_id, e.name\\nfrom employees e left join employeeuni euni on euni.id = e.id\\n```",
                "solutionTags": [],
                "code": "```\\nselect euni.unique_id, e.name\\nfrom employees e left join employeeuni euni on euni.id = e.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 794052,
                "title": "mysql-faster-than-51",
                "content": "```\\nselect employeeuni.unique_id, employees.name\\nfrom employees\\nleft join employeeuni on employees.id = employeeuni.id\\n```",
                "solutionTags": [],
                "code": "```\\nselect employeeuni.unique_id, employees.name\\nfrom employees\\nleft join employeeuni on employees.id = employeeuni.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683776,
                "title": "oracle-short-solution",
                "content": "```\\n/* Write your PL/SQL query statement below */\\nSELECT B.unique_id,A.name FROM Employees A LEFT JOIN EmployeeUNI B ON A.id=B.id;\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT B.unique_id,A.name FROM Employees A LEFT JOIN EmployeeUNI B ON A.id=B.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 545699,
                "title": "oracle",
                "content": "```\\n/* Write your PL/SQL query statement below */\\nselect b.unique_id, a.name\\nfrom Employees a left outer join EmployeeUNI b on a.id = b.id\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect b.unique_id, a.name\\nfrom Employees a left outer join EmployeeUNI b on a.id = b.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4092533,
                "title": "replace-employee-id-with-the-unique-identifier",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect eu.unique_id,e.name from EmployeeUNI eu right join Employees e on eu.id=e.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect eu.unique_id,e.name from EmployeeUNI eu right join Employees e on eu.id=e.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090976,
                "title": "simple-direct-solution-in-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nProblem to test LEFT JOIN \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nleft joining the table with respect to id\\n\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT  EmployeeUNI.unique_id,Employees.name\\nFROM Employees \\nLEFT JOIN EmployeeUNI\\nON Employees.id = EmployeeUNI.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT  EmployeeUNI.unique_id,Employees.name\\nFROM Employees \\nLEFT JOIN EmployeeUNI\\nON Employees.id = EmployeeUNI.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090452,
                "title": "simple-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT ei.unique_id , e.name\\nFROM Employees e\\nLEFT JOIN EMployeeUNI ei \\nON e.id = ei.id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT ei.unique_id , e.name\\nFROM Employees e\\nLEFT JOIN EMployeeUNI ei \\nON e.id = ei.id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4090242,
                "title": "simple-mysql-query",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT eu.unique_id, e.name FROM Employees e LEFT JOIN EmployeeUNI eu ON eu.id=e.id;;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT eu.unique_id, e.name FROM Employees e LEFT JOIN EmployeeUNI eu ON eu.id=e.id;;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4087838,
                "title": "left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect Em.unique_id,Et.name from Employees Et left join EmployeeUNi Em on Em.id = Et.id ; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Em.unique_id,Et.name from Employees Et left join EmployeeUNi Em on Em.id = Et.id ; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085930,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect es.name, ei.unique_id from employees es left join employeeuni ei\\non es.id=ei.id\\n \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect es.name, ei.unique_id from employees es left join employeeuni ei\\non es.id=ei.id\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085561,
                "title": "left-join",
                "content": "# Write your MySQL query statement below\\nSELECT EmployeeUNI.unique_id,Employees.name \\nfrom Employees LEFT JOIN EmployeeUNI ON \\nEmployees.id=EmployeeUNI.id",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# Write your MySQL query statement below\\nSELECT EmployeeUNI.unique_id,Employees.name \\nfrom Employees LEFT JOIN EmployeeUNI ON \\nEmployees.id=EmployeeUNI.id",
                "codeTag": "Unknown"
            },
            {
                "id": 4085252,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect  E.name as name, EU.unique_id as unique_id from Employees E left join EmployeeUNI EU on E.id = EU.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect  E.name as name, EU.unique_id as unique_id from Employees E left join EmployeeUNI EU on E.id = EU.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4083750,
                "title": "mysql-left-join-solution",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT empu.unique_id , emp.name FROM Employees emp LEFT JOIN EmployeeUNI empu USING(id);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT empu.unique_id , emp.name FROM Employees emp LEFT JOIN EmployeeUNI empu USING(id);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081393,
                "title": "simple-sql-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLeft join\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT e2.unique_id , e1.name from Employees e1\\nLEFT JOIN EmployeeUNI e2\\nON e2.id = e1.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT e2.unique_id , e1.name from Employees e1\\nLEFT JOIN EmployeeUNI e2\\nON e2.id = e1.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4081192,
                "title": "pandas-merge-and-filter",
                "content": "# Intuition\\ntake two data frames and left join them using id column\\nafter merging filter the df to have only unique_id, name as columns\\nand return it\\n\\n# Approach\\nuse df = pd.merge(df_1, df_2, on=\\'column_name\\', how=\\'left\\')\\nthen ---> filter df[[\\'column_1\\', \\'column_2\\']]\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n\\n  df = pd.merge(employees, employee_uni, on=\\'id\\', how=\\'left\\')\\n  df = df [[\\'unique_id\\', \\'name\\']]\\n\\n  return df\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n\\n  df = pd.merge(employees, employee_uni, on=\\'id\\', how=\\'left\\')\\n  df = df [[\\'unique_id\\', \\'name\\']]\\n\\n  return df\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4080391,
                "title": "solution-using-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT unique_id,name\\nFROM Employees\\nLEFT JOIN EmployeeUNI on EmployeeUNI.id = Employees.id\\n\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT unique_id,name\\nFROM Employees\\nLEFT JOIN EmployeeUNI on EmployeeUNI.id = Employees.id\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080191,
                "title": "easy-sql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT EU.UNIQUE_ID , E.NAME FROM EMPLOYEEUNI EU RIGHT JOIN EMPLOYEES E ON E.ID = EU.ID;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT EU.UNIQUE_ID , E.NAME FROM EMPLOYEEUNI EU RIGHT JOIN EMPLOYEES E ON E.ID = EU.ID;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079662,
                "title": "right-join-approach",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT  EmployeeUNI.unique_id, Employees.name FROM EmployeeUNI\\nRight JOIN Employees \\nON Employees.id = EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT  EmployeeUNI.unique_id, Employees.name FROM EmployeeUNI\\nRight JOIN Employees \\nON Employees.id = EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078886,
                "title": "sql-simple-solution",
                "content": "# Code\\n```\\nSELECT eu.unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT eu.unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078720,
                "title": "mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT eu.unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT eu.unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078270,
                "title": "left-outer-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT EmployeeUNI.unique_id,Employees.name\\nFROM Employees\\nLEFT OUTER JOIN EmployeeUNI \\nON Employees.id=EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT EmployeeUNI.unique_id,Employees.name\\nFROM Employees\\nLEFT OUTER JOIN EmployeeUNI \\nON Employees.id=EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076626,
                "title": "using-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT EmployeeUNI.unique_id , Employees.name FROM Employees  \\nLEFT JOIN EmployeeUNI on EmployeeUNI.id = Employees.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT EmployeeUNI.unique_id , Employees.name FROM Employees  \\nLEFT JOIN EmployeeUNI on EmployeeUNI.id = Employees.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076574,
                "title": "ok",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT EmployeeUNI.unique_id, Employees.name from Employees LEFT OUTER JOIN EmployeeUNI ON Employees.id = EmployeeUNI.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT EmployeeUNI.unique_id, Employees.name from Employees LEFT OUTER JOIN EmployeeUNI ON Employees.id = EmployeeUNI.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076078,
                "title": "employee-name-with-unique-ids",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect Employees.name, EmployeeUNI.unique_id from Employees left join EmployeeUNI on Employees.id = EmployeeUNI.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Employees.name, EmployeeUNI.unique_id from Employees left join EmployeeUNI on Employees.id = EmployeeUNI.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4076063,
                "title": "easy-solution-using-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT EmployeeuNI.unique_id,Employees.name FROM Employees LEFT JOIN EmployeeUNI ON Employees.id= EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT EmployeeuNI.unique_id,Employees.name FROM Employees LEFT JOIN EmployeeUNI ON Employees.id= EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4075363,
                "title": "easy-solution-with-beats-99-34",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT u.unique_id,e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI u\\nON e.id=u.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT u.unique_id,e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI u\\nON e.id=u.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074750,
                "title": "mysql-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT em.unique_id, e.name FROM Employees e\\nLEFT JOIN EmployeeUNI em\\nON em.id = e.id  order by e.id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT em.unique_id, e.name FROM Employees e\\nLEFT JOIN EmployeeUNI em\\nON em.id = e.id  order by e.id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074509,
                "title": "oracle-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect u.unique_id, e.name\\nfrom Employees e, EmployeeUNI u\\nwhere e.id = u.id(+);\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect u.unique_id, e.name\\nfrom Employees e, EmployeeUNI u\\nwhere e.id = u.id(+);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074363,
                "title": "pandas-merge-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    result = employees.merge(employee_uni, how = \\'left\\')\\n\\n    return result[[\\'unique_id\\', \\'name\\']]\\n    \\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    result = employees.merge(employee_uni, how = \\'left\\')\\n\\n    return result[[\\'unique_id\\', \\'name\\']]\\n    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4073277,
                "title": "sql-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect unique_id,name from employees LEFT JOIN employeeuni using(id)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect unique_id,name from employees LEFT JOIN employeeuni using(id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4073095,
                "title": "simple-code",
                "content": "Here employeeuni is renamed as en and employees as e\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect en.unique_id as unique_id ,e.name as name \\nfrom employees as e\\nleft Join employeeuni as en on e.id=en.id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect en.unique_id as unique_id ,e.name as name \\nfrom employees as e\\nleft Join employeeuni as en on e.id=en.id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4072271,
                "title": "replace-employee-id-with-the-unique-identifier-sql-left-join",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn this SQL Query We are selecting unique_id from EmployeeUNI table and name from Employees table and perform left join on the basis of id form Employees table and id from EmployeeUNI tabel are same\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT EmployeeUNI.unique_id as unique_id, Employees.name as name from Employees LEFT JOIN EmployeeUNI on Employees.id=EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT EmployeeUNI.unique_id as unique_id, Employees.name as name from Employees LEFT JOIN EmployeeUNI on Employees.id=EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071431,
                "title": "fast-simple-solution",
                "content": "# Query\\n```\\n/* SQL query */\\nSELECT B.UNIQUE_ID UNIQUE_ID, A.NAME NAME FROM EMPLOYEES A LEFT JOIN EMPLOYEEUNI B ON A.ID=B.ID;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* SQL query */\\nSELECT B.UNIQUE_ID UNIQUE_ID, A.NAME NAME FROM EMPLOYEES A LEFT JOIN EMPLOYEEUNI B ON A.ID=B.ID;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071419,
                "title": "simple-solution-using-left-outer-join",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect EmployeeUNI.unique_id, Employees.name \\nfrom Employees\\nleft outer join EmployeeUNI\\non Employees.id = EmployeeUNI.id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect EmployeeUNI.unique_id, Employees.name \\nfrom Employees\\nleft outer join EmployeeUNI\\non Employees.id = EmployeeUNI.id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071057,
                "title": "beats-100",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect EmployeeUNI.unique_id, Employees.name from Employees left join EmployeeUNI \\n\\non Employees.id = EmployeeUNI.id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect EmployeeUNI.unique_id, Employees.name from Employees left join EmployeeUNI \\n\\non Employees.id = EmployeeUNI.id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070027,
                "title": "simple-pandas-solution-with-merge",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(employees, employee_uni, how = \\'left\\', on = \\'id\\')[[\\'unique_id\\', \\'name\\']]\\n    return df\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(employees, employee_uni, how = \\'left\\', on = \\'id\\')[[\\'unique_id\\', \\'name\\']]\\n    return df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4068558,
                "title": "method-i-using-right-join-method-ii-using-left-join",
                "content": "\\n# Code\\n```\\n# using right join\\nSELECT eu.unique_id AS unique_id, e.name AS name FROM EmployeeUNI eu RIGHT OUTER JOIN Employees e ON  eu.id= e.id \\n\\n# using left join\\n# SELECT eu.unique_id AS unique_id, e.name AS name FROM Employees e LEFT OUTER JOIN EmployeeUNI eu ON e.id = eu.id\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\n# Code\\n```\\n# using right join\\nSELECT eu.unique_id AS unique_id, e.name AS name FROM EmployeeUNI eu RIGHT OUTER JOIN Employees e ON  eu.id= e.id \\n\\n# using left join\\n# SELECT eu.unique_id AS unique_id, e.name AS name FROM Employees e LEFT OUTER JOIN EmployeeUNI eu ON e.id = eu.id\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 4068055,
                "title": "sql-simple-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect  employeeuni.unique_id, employees.name from employeeuni right outer join employees on employees.id = employeeuni.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect  employeeuni.unique_id, employees.name from employeeuni right outer join employees on employees.id = employeeuni.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4064176,
                "title": "simple-mysql-solution-using-left-join",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need to take out the unique_id of an employee with their name.\\nAnd if they are not having the unique_id then it will be null.\\nSo left join will work here.\\nTake Employees as the left table and EmplyeeUNI as right table.\\nSo we have to take all the employee names from the left table and unique_id from the right table if employee id matches.i.e. all the records from left table and common records between left and right table.\\n\\nIn \"select\" we can mentioned which column we want to display from both left and right table.\\n\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT u.unique_id , e.name\\nFROM Employees as e\\nLEFT JOIN EmployeeUNI as u\\nON e.id = u.id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT u.unique_id , e.name\\nFROM Employees as e\\nLEFT JOIN EmployeeUNI as u\\nON e.id = u.id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4063971,
                "title": "beats-100-in-run-time-and-memory",
                "content": "# Intuition\\nSimple and straight approach.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect EmployeeUNI.unique_id as unique_id,Employees.name from Employees\\nLEFT JOIN EmployeeUNI \\nON Employees.id = EmployeeUNI.id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect EmployeeUNI.unique_id as unique_id,Employees.name from Employees\\nLEFT JOIN EmployeeUNI \\nON Employees.id = EmployeeUNI.id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062159,
                "title": "sql-very-simple-please-upvote-if-u-like-the-solution",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect a.unique_id,b.name from EmployeeUNI as a\\nright join Employees as b\\non (a.id = b.id)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect a.unique_id,b.name from EmployeeUNI as a\\nright join Employees as b\\non (a.id = b.id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4062084,
                "title": "left-join-for-null-value",
                "content": "\\nselect e2.unique_id as unique_id , e1.name name\\nfrom Employees e1 left join EmployeeUNI e2\\non e1.id = e2.id\\n\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "\\nselect e2.unique_id as unique_id , e1.name name\\nfrom Employees e1 left join EmployeeUNI e2\\non e1.id = e2.id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061134,
                "title": "sql-left-join-easy-solution-pls-upvote-if-you-understand-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect employeeuni.unique_id,employees.name\\n\\nfrom Employees LEFT JOIN  employeeuni\\nON employees.id=employeeuni.id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect employeeuni.unique_id,employees.name\\n\\nfrom Employees LEFT JOIN  employeeuni\\nON employees.id=employeeuni.id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060376,
                "title": "best-approach-easy-sql-code-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires showing the unique ID for each employee if available and replacing it with NULL if not. To achieve this, we need to combine data from two tables: the \"Employees\" table that contains employee names and the \"EmployeeUNI\" table that contains unique IDs. Since not all employees may have a unique ID, we want to ensure that every employee\\'s name is displayed in the result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe SQL query achieves this using a LEFT JOIN between the \"Employees\" and \"EmployeeUNI\" tables, as follows:\\n\\n// Select the \"unique_id\" and \"name\" columns for the result table\\nSELECT unique_id, name\\n\\n// Alias the \"Employees\" table as \"emp\" to simplify the query\\nFROM Employees as emp\\n\\n// Perform a LEFT JOIN with the \"EmployeeUNI\" table (aliased as \"uni\")\\n based on matching values in the \"id\" columns of both tables\\nLEFT JOIN EmployeeUNI as uni ON uni.id = emp.id;\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT unique_id, name\\nFROM Employees as emp\\nleft join EmployeeUNI as uni\\nON uni.id = emp.iddb\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Database",
                    "Shell"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT unique_id, name\\nFROM Employees as emp\\nleft join EmployeeUNI as uni\\nON uni.id = emp.iddb\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060357,
                "title": "replace-employee-id-with-the-unique-identifier",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLEFT JOIN\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT unique_id, NAME\\nFROM EMPLOYEES\\nLEFT JOIN EMPLOYEEUNI\\nON EMPLOYEES.ID = EMPLOYEEUNI.ID\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/d8f036d7-3e5a-462a-a87b-11752ec9de40_1695045649.3426242.jpeg)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT unique_id, NAME\\nFROM EMPLOYEES\\nLEFT JOIN EMPLOYEEUNI\\nON EMPLOYEES.ID = EMPLOYEEUNI.ID\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4059831,
                "title": "best-solution-for-beginners",
                "content": "# Code\\n```\\nselect unique_id,name from Employees emp left join EmployeeUNI eu\\non emp.id=eu.id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "MS SQL Server",
                    "Oracle",
                    "Database"
                ],
                "code": "```\\nselect unique_id,name from Employees emp left join EmployeeUNI eu\\non emp.id=eu.id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058899,
                "title": "mysql-series-right-join",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect a.unique_id as unique_id ,b.name as name from EmployeeUNI a  \\nright join Employees b on\\na.id=b.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect a.unique_id as unique_id ,b.name as name from EmployeeUNI a  \\nright join Employees b on\\na.id=b.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058810,
                "title": "sql-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect e1.unique_id as unique_id , e.name as name from Employees e left join EmployeeUNI e1 on e.id=e1.id; \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect e1.unique_id as unique_id , e.name as name from Employees e left join EmployeeUNI e1 on e.id=e1.id; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057278,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nbasically here employees table id column is primary key and employeeuni id is foregin key and which have unique id for each employee \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nso in this problem we have to apply left join because we want employees table all rows and employeeuni table unique_id of each employee which will match in employeeuni table \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nIt is depends on records means how maney records present in the employees table and employeeuni table\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe result contains two column so its sapce complexity will be constants\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect e2.unique_id,e1.name \\nfrom employees e1 \\nleft join employeeuni e2\\n on e1.id=e2.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect e2.unique_id,e1.name \\nfrom employees e1 \\nleft join employeeuni e2\\n on e1.id=e2.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056824,
                "title": "left-join-solution",
                "content": "# Code\\n```\\nselect U.unique_id, E.name\\nfrom Employees E left join EmployeeUNI U\\non E.id = U.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect U.unique_id, E.name\\nfrom Employees E left join EmployeeUNI U\\non E.id = U.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056743,
                "title": "1378-replace-employee-id-with-the-unique-identifier-left-join-easy-way",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect EmployeeUNI.unique_id as unique_id,Employees.name as name\\n from Employees \\n left Join EmployeeUNI \\n on \\nEmployees.id=EmployeeUNI.id;\\n```\\n```\\n1 line display and column name \\n2 line from table which table to display row \\n3 line join second table in such that it must contain all element of first table so we are use left join\\n4 line on base of both table have column value are same like here id is primary key in Employee but foreign key in EmployeeUNI\\n \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect EmployeeUNI.unique_id as unique_id,Employees.name as name\\n from Employees \\n left Join EmployeeUNI \\n on \\nEmployees.id=EmployeeUNI.id;\\n```\n```\\n1 line display and column name \\n2 line from table which table to display row \\n3 line join second table in such that it must contain all element of first table so we are use left join\\n4 line on base of both table have column value are same like here id is primary key in Employee but foreign key in EmployeeUNI\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056504,
                "title": "mysql-solution-with-left-join",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect Employees.name, EmployeeUNI.unique_id from Employees left join EmployeeUNI on Employees.id = EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Employees.name, EmployeeUNI.unique_id from Employees left join EmployeeUNI on Employees.id = EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4054393,
                "title": "simple-merge-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    return pd.merge(employee_uni, employees, how=\\'right\\')[[\\'unique_id\\',\\'name\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    return pd.merge(employee_uni, employees, how=\\'right\\')[[\\'unique_id\\',\\'name\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4053097,
                "title": "replace-employee-id-with-unique-id",
                "content": "# Intuition\\n<!-- have to replace all the IDs in Employees table with Unique ID from EmployeeUNI table -->\\n\\n# Approach\\n<!-- need to use left join as we are selecting the whole name column from left table -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect e.name, u.unique_id from Employees e left join EmployeeUNI u on e.id = u.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect e.name, u.unique_id from Employees e left join EmployeeUNI u on e.id = u.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4052630,
                "title": "simple-solution-using-left-join",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\n\\nSELECT unique_id,name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu\\nON e.id = eu.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n\\nSELECT unique_id,name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu\\nON e.id = eu.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050971,
                "title": "my-sql-100-eassy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect e.name,euni.unique_id from employeeuni euni  right join employees e on e.id=euni.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect e.name,euni.unique_id from employeeuni euni  right join employees e on e.id=euni.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048173,
                "title": "simple-left-join-replace-employee-id-with-unique-id",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince every entity in Employees Table should present in output,so  we should apply LEFT JOIN or RIGHT JOIN appropriately\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**USING LEFT JOIN or RIGHT JOIN** \\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below \\n#LEFT JOIN\\nSELECT Eu.unique_id,E.name FROM Employees E LEFT JOIN  EmployeeUNI Eu  ON E.id = Eu.id;\\n\\n#RIGHT JOIN\\nSELECT Eu.unique_id,E.name FROM  EmployeeUNI Eu  RIGHT JOIN  Employees E  ON E.id = Eu.id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below \\n#LEFT JOIN\\nSELECT Eu.unique_id,E.name FROM Employees E LEFT JOIN  EmployeeUNI Eu  ON E.id = Eu.id;\\n\\n#RIGHT JOIN\\nSELECT Eu.unique_id,E.name FROM  EmployeeUNI Eu  RIGHT JOIN  Employees E  ON E.id = Eu.id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047723,
                "title": "sql-query-using-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect b.unique_id,a.name\\n\\nfrom Employees a\\nleft join EmployeeUNI b\\non a.id=b.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect b.unique_id,a.name\\n\\nfrom Employees a\\nleft join EmployeeUNI b\\non a.id=b.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046879,
                "title": "simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n->\\n\\n# Code\\n```\\nselect  EmployeeUNI.unique_id ,Employees.name\\n from Employees \\nleft join EmployeeUNI \\non Employees .id = EmployeeUNI .id ;\\n\\n**Bold**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n->\\n\\n# Code\\n```\\nselect  EmployeeUNI.unique_id ,Employees.name\\n from Employees \\nleft join EmployeeUNI \\non Employees .id = EmployeeUNI .id ;\\n\\n**Bold**",
                "codeTag": "Unknown"
            },
            {
                "id": 4046657,
                "title": "3-ways-to-solve-this-question-by-mysql-query",
                "content": "#WAY TO USE:\\nRUN EACH QUERY ONE BY ONE. IF YOU RUN ALL THREE TOGETHER THEN YOU WILL GET AN ERROR. \\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT UNIQUE_ID, NAME FROM EMPLOYEES AS E LEFT JOIN EMPLOYEEUNI AS C ON E.ID=C.ID;\\n\\nSELECT EU.UNIQUE_ID, E.NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EU USING(ID);\\n\\nSELECT unique_id,name FROM Employees LEFT JOIN EmployeeUNI ON Employees.id = EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT UNIQUE_ID, NAME FROM EMPLOYEES AS E LEFT JOIN EMPLOYEEUNI AS C ON E.ID=C.ID;\\n\\nSELECT EU.UNIQUE_ID, E.NAME FROM EMPLOYEES E LEFT JOIN EMPLOYEEUNI EU USING(ID);\\n\\nSELECT unique_id,name FROM Employees LEFT JOIN EmployeeUNI ON Employees.id = EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046457,
                "title": "mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect unique_id, name from Employees  left join EmployeeUNI on Employees.id  = EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect unique_id, name from Employees  left join EmployeeUNI on Employees.id  = EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044782,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect eu.unique_id,e.name\\nfrom Employees as e\\nleft join EmployeeUNI as eu\\non e.id = eu.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect eu.unique_id,e.name\\nfrom Employees as e\\nleft join EmployeeUNI as eu\\non e.id = eu.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4044164,
                "title": "show-unique-id-for-employee-left-join-sql",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT eu.unique_id, e.name \\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT eu.unique_id, e.name \\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043812,
                "title": "left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect u.unique_id,e.name from employees e left join employeeuni u on\\ne.id = u.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect u.unique_id,e.name from employees e left join employeeuni u on\\ne.id = u.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042553,
                "title": "left-join-simple-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect eu.unique_id , e.name from Employees e left join EmployeeUNI eu  using(id)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect eu.unique_id , e.name from Employees e left join EmployeeUNI eu  using(id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4042516,
                "title": "left-join",
                "content": "SELECT eu.unique_id as unique_id\\n      ,e.name\\nFROM Employees e\\n    LEFT JOIN EmployeeUNI eu\\n        ON e.id = eu.id",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "SELECT eu.unique_id as unique_id\\n      ,e.name\\nFROM Employees e\\n    LEFT JOIN EmployeeUNI eu\\n        ON e.id = eu.id",
                "codeTag": "Unknown"
            },
            {
                "id": 4041704,
                "title": "mysql-inner-join",
                "content": "# Intuition\\nUse inner join\\n\\n# Approach\\nSelect the required columns from `Sales` joining with `Product` using product_id as a common key\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect EmployeeUNI.unique_id,Employees.name from Employees LEFT OUTER JOIN EmployeeUNI on Employees.id=EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect EmployeeUNI.unique_id,Employees.name from Employees LEFT OUTER JOIN EmployeeUNI on Employees.id=EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041395,
                "title": "1-liner-left-join-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect u.unique_id,e.name from Employees e left join EmployeeUNI u on e.id= u.id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect u.unique_id,e.name from Employees e left join EmployeeUNI u on e.id= u.id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041100,
                "title": "simple-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect unique_id,name\\nfrom Employees as a\\nleft join EmployeeUNI as b\\non a.id = b.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect unique_id,name\\nfrom Employees as a\\nleft join EmployeeUNI as b\\non a.id = b.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040962,
                "title": "mysql-left-join-easy-to-understand",
                "content": "# Intuition\\n\\n- The **LEFT JOIN** keyword returns all records from the left table`Employees`, and the matching records from the right table `EmployeeUNI`. \\n\\n    > The result is `null` records from the right side, if there is no match for the `id` in the `Employees` table with the `id` in the `EmployeeUNI` table.\\n\\n- **Reference**: https://www.w3schools.com/sql/sql_join_left.asp\\n\\n---\\n\\n#### Please Upvotes if it helps! Thank you \\uD83C\\uDF5E\\n\\n\\n# Code\\n```sql\\n# Write your MySQL query statement below\\nSELECT \\n  EmployeeUNI.unique_id, \\n  Employees.name \\nFROM \\n  Employees \\n  LEFT JOIN EmployeeUNI on Employees.id = EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\n# Write your MySQL query statement below\\nSELECT \\n  EmployeeUNI.unique_id, \\n  Employees.name \\nFROM \\n  Employees \\n  LEFT JOIN EmployeeUNI on Employees.id = EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040621,
                "title": "clean-and-simple",
                "content": "\\n# Code\\n```\\nSELECT unique_id, name\\nFROM Employees\\nLEFT JOIN EmployeeUNI\\nUSING(id);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT unique_id, name\\nFROM Employees\\nLEFT JOIN EmployeeUNI\\nUSING(id);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040145,
                "title": "mysql-solution",
                "content": "# Code\\n```\\nselect unique_id, name\\nfrom Employees e\\nLEFT JOIN EmployeeUNI u\\nON e.id = u.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect unique_id, name\\nfrom Employees e\\nLEFT JOIN EmployeeUNI u\\nON e.id = u.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4039508,
                "title": "replace-employee-id-with-the-unique-identifier",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT EU.UNIQUE_ID , E.NAME FROM \\nEMPLOYEES E LEFT JOIN EMPLOYEEUNI EU \\nON E.ID = EU.ID;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT EU.UNIQUE_ID , E.NAME FROM \\nEMPLOYEES E LEFT JOIN EMPLOYEEUNI EU \\nON E.ID = EU.ID;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038700,
                "title": "pandas-left-merge",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nLeft merge both dataframes. And return unique_id and name.\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    return employees.merge(employee_uni, how=\\'left\\')[[\\'unique_id\\',\\'name\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    return employees.merge(employee_uni, how=\\'left\\')[[\\'unique_id\\',\\'name\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4038481,
                "title": "using-joins",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect b.unique_id,a.name  from employees as a left join employeeuni as b\\non a.id=b.id\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect b.unique_id,a.name  from employees as a left join employeeuni as b\\non a.id=b.id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4037454,
                "title": "mysql-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse a left join using Employees table as left to get the unique_id from the right table (EmployeeUNI)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect EmployeeUNI.unique_id,Employees.name from Employees LEFT OUTER JOIN EmployeeUNI on Employees.id=EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect EmployeeUNI.unique_id,Employees.name from Employees LEFT OUTER JOIN EmployeeUNI on Employees.id=EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035818,
                "title": "t-sql-statement",
                "content": "# Intuition\\nFollow the problem to join the tables.\\nThe shared column is id, so join two tables on id.\\nTake the Employees as the main table as the problem said, use left join here.\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nSELECT eu.unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu\\nON e.id = eu.id\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nSELECT eu.unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu\\nON e.id = eu.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4035040,
                "title": "pd-solution",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef replace_employee_id(empls: pd.DataFrame, empl_un: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(empls,empl_un,on=\\'id\\',how=\\'left\\')\\n    return df[[\\'unique_id\\',\\'name\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef replace_employee_id(empls: pd.DataFrame, empl_un: pd.DataFrame) -> pd.DataFrame:\\n    df = pd.merge(empls,empl_un,on=\\'id\\',how=\\'left\\')\\n    return df[[\\'unique_id\\',\\'name\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4034148,
                "title": "oracle",
                "content": "\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nselect eu.unique_id, e.name from employees e left outer join employeeuni eu\\non eu.id=e.id ;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nselect eu.unique_id, e.name from employees e left outer join employeeuni eu\\non eu.id=e.id ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032348,
                "title": "easy-solution-mysql",
                "content": "\\n\\n# Code\\n```\\n\\nselect EmployeeUNI.unique_id,Employees.name from Employees left join EmployeeUNI on Employees.id = EmployeeUNI.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n\\nselect EmployeeUNI.unique_id,Employees.name from Employees left join EmployeeUNI on Employees.id = EmployeeUNI.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4032149,
                "title": "easy-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirstly we select unique_id from table EmployeeUNI and name from table Employees and joining both tables using LEFT JOIN . Condition applied that id of both the tables are equal\\n\\n# Complexity\\n- Time complexity:250\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nselect et.unique_id,e.name \\nfrom Employees e left join EmployeeUNI et\\non et.id = e.id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect et.unique_id,e.name \\nfrom Employees e left join EmployeeUNI et\\non et.id = e.id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4031458,
                "title": "left-join",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect unique_id,name\\nfrom Employees\\nLEFT JOIN EmployeeUNI\\non Employees.id= EmployeeUNI.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect unique_id,name\\nfrom Employees\\nLEFT JOIN EmployeeUNI\\non Employees.id= EmployeeUNI.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4031295,
                "title": "easy-mysql-solution-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect unique_id,name\\nfrom Employees\\nleft join EmployeeUNI\\non Employees.id = EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect unique_id,name\\nfrom Employees\\nleft join EmployeeUNI\\non Employees.id = EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027852,
                "title": "intermediate-level-a-c-to-me",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT E1.unique_id, E2.name\\nFROM EmployeeUNI AS E1\\nRIGHT JOIN Employees AS E2\\nON E1.id = E2.id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT E1.unique_id, E2.name\\nFROM EmployeeUNI AS E1\\nRIGHT JOIN Employees AS E2\\nON E1.id = E2.id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025468,
                "title": "using-left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect unique_id,name from employees left join employeeuni on employees.id=employeeuni.id \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect unique_id,name from employees left join employeeuni on employees.id=employeeuni.id \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025446,
                "title": "sql-easy-to-understand-left-join",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT  e2.unique_id,e1.name FROM Employees AS e1 LEFT JOIN EmployeeUNI AS e2 \\nON e1.id = e2.id; \\n```\\n---\\n![Upvote.jpeg](https://assets.leetcode.com/users/images/bb127ce3-0549-4ce4-bdfb-7dc519a6e6f6_1694327005.3117259.jpeg)\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT  e2.unique_id,e1.name FROM Employees AS e1 LEFT JOIN EmployeeUNI AS e2 \\nON e1.id = e2.id; \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025342,
                "title": "basic-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUnderstand the topic of Joins very carefully and then you will not face any confusion/doubt in this question.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT unique_id, name FROM Employees\\nLEFT JOIN EmployeeUNI \\nON Employees.id = EmployeeUNI.id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT unique_id, name FROM Employees\\nLEFT JOIN EmployeeUNI \\nON Employees.id = EmployeeUNI.id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4025276,
                "title": "replace-employee-id-with-the-unique-identifier-in-mysql",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSELECT unique_id,name FROM EMPLOYEES\\nLEFT JOIN EmployeeUni Unique_id USING(id)\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT unique_id,name FROM EMPLOYEES\\nLEFT JOIN EmployeeUni Unique_id USING(id)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4023225,
                "title": "1378-replace-employee-id-with-the-unique-identifier-mysql-runtime-3555ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT\\n    EmployeeUNI.unique_id AS unique_id,\\n    Employees.name AS name\\nFROM\\n    Employees\\nLEFT JOIN\\n    EmployeeUNI ON Employees.id = EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT\\n    EmployeeUNI.unique_id AS unique_id,\\n    Employees.name AS name\\nFROM\\n    Employees\\nLEFT JOIN\\n    EmployeeUNI ON Employees.id = EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022921,
                "title": "sql-left-join-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect eu.unique_id as unique_id, e.name as name from Employees e\\nleft join EmployeeUNI eu\\non e.id = eu.id\\n;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect eu.unique_id as unique_id, e.name as name from Employees e\\nleft join EmployeeUNI eu\\non e.id = eu.id\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022599,
                "title": "prantosh-the-simplest-query-u-have-ever-seen",
                "content": "# Intuition\\nwe have to use join here (left join) and then extract the unique id columns and name on the basis of first column of each\\n\\n# Approach\\njoin\\n\\n# Complexity\\n- Time complexity:\\neasy\\n\\n- Space complexity:\\nmeans\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect em.unique_id ,e.name\\nfrom employees e\\nleft join employeeuni em\\non e.id=em.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect em.unique_id ,e.name\\nfrom employees e\\nleft join employeeuni em\\non e.id=em.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4021499,
                "title": "sql-1378-sql-basic-using-join-ak",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT unique_id, name FROM Employees\\nLEFT JOIN EmployeeUNI ON Employees.id=EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT unique_id, name FROM Employees\\nLEFT JOIN EmployeeUNI ON Employees.id=EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020698,
                "title": "left-join",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n# insert into Employees (id, name) values (\\'1\\', \\'Alice\\')\\n# insert into Employees (id, name) values (\\'7\\', \\'Bob\\')\\n# insert into Employees (id, name) values (\\'11\\', \\'Meir\\')\\n# insert into Employees (id, name) values (\\'90\\', \\'Winston\\')\\n\\n# Truncate table EmployeeUNI\\n# insert into EmployeeUNI (id, unique_id) values (\\'3\\', \\'1\\')\\n# insert into EmployeeUNI (id, unique_id) values (\\'11\\', \\'2\\')\\n# insert into EmployeeUNI (id, unique_id) values (\\'90\\', \\'3\\')\\n\\nselect u.unique_id,e.name\\nfrom Employees e left join  EmployeeUNI u\\non u.id=e.id;\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n# insert into Employees (id, name) values (\\'1\\', \\'Alice\\')\\n# insert into Employees (id, name) values (\\'7\\', \\'Bob\\')\\n# insert into Employees (id, name) values (\\'11\\', \\'Meir\\')\\n# insert into Employees (id, name) values (\\'90\\', \\'Winston\\')\\n\\n# Truncate table EmployeeUNI\\n# insert into EmployeeUNI (id, unique_id) values (\\'3\\', \\'1\\')\\n# insert into EmployeeUNI (id, unique_id) values (\\'11\\', \\'2\\')\\n# insert into EmployeeUNI (id, unique_id) values (\\'90\\', \\'3\\')\\n\\nselect u.unique_id,e.name\\nfrom Employees e left join  EmployeeUNI u\\non u.id=e.id;\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020250,
                "title": "pandas-one-line-solution",
                "content": "```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    return pd.merge(left=employees, right=employee_uni, how=\"left\", on=\"id\")[[\"unique_id\", \"name\"]]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef replace_employee_id(employees: pd.DataFrame, employee_uni: pd.DataFrame) -> pd.DataFrame:\\n    return pd.merge(left=employees, right=employee_uni, how=\"left\", on=\"id\")[[\"unique_id\", \"name\"]]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4019723,
                "title": "easy-sql-queries-with-explanation",
                "content": "# Intuition\\nThe problem appears to involve retrieving data from two database tables, \\'Employees\\' and \\'EmployeeUNI\\', by performing a LEFT JOIN operation on them. We want to select the \\'unique_id\\' from the \\'EmployeeUNI\\' table and the \\'name\\' from the \\'Employees\\' table where the \\'id values\\' match.\\n\\n# Approach\\n1) We use aliases E for the Employees table and EU for the EmployeeUNI table to simplify the query.\\n2) We perform a LEFT JOIN between the Employees and EmployeeUNI tables on the id column. This will include all records from the Employees table and only matching records from the EmployeeUNI table.\\n3) In the SELECT statement, we select EU.unique_id and E.name to retrieve the desired columns.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this SQL query is typically determined by the efficiency of the database\\'s query execution engine. In most cases, it would depend on the indexing and optimization of the tables involved. Generally, for a LEFT JOIN operation, the time complexity is roughly proportional to the sum of the number of rows in the two tables being joined, but it can vary based on database-specific optimizations.\\n- Space complexity:\\nThe space complexity of the query depends on the number of rows returned in the result set. Since we are selecting specific columns (EU.unique_id and E.name), the space complexity would be linear with respect to the number of matching rows in the result set.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect EU.unique_id ,E.name\\nfrom Employees as E\\nleft join EmployeeUNI as EU\\non E.id = EU.id;\\n\\n/*\\n\\nSo now let us understand what exactly is happening here\\nFirst of all \"EU\" and \"E\" are aliases. Now where are these EU and E aliases coming from?\\nAs we can see in the next two lines, \"Employees as E\" and \"left join EmployeeUNI as EU\"\\nAfter the aliases thing, we are coming towards joining the table using LEFT JOIN.\\nSo we are basically joining the \"EmployeeUNI\" table to \"Employee\" table. Here, its imp to know that the left side table is \"Employees\" and right side table is \"EmployeeUNI\" \\nSo, as we know that in left join, it returns all the records from the left and the matching records from the right.\\nThus, in the starting, as we have said that \"select E.name\" from Employees (i.e the left table) therefore it will return all the names from the left table\\nAnd here:- \"on E.id = EU.id;\" we have said that when the \"id\" in Employee table and EmployeeUNI table matches select the corresponding unique_id and if \"id\" in both table does not match it will return null\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect EU.unique_id ,E.name\\nfrom Employees as E\\nleft join EmployeeUNI as EU\\non E.id = EU.id;\\n\\n/*\\n\\nSo now let us understand what exactly is happening here\\nFirst of all \"EU\" and \"E\" are aliases. Now where are these EU and E aliases coming from?\\nAs we can see in the next two lines, \"Employees as E\" and \"left join EmployeeUNI as EU\"\\nAfter the aliases thing, we are coming towards joining the table using LEFT JOIN.\\nSo we are basically joining the \"EmployeeUNI\" table to \"Employee\" table. Here, its imp to know that the left side table is \"Employees\" and right side table is \"EmployeeUNI\" \\nSo, as we know that in left join, it returns all the records from the left and the matching records from the right.\\nThus, in the starting, as we have said that \"select E.name\" from Employees (i.e the left table) therefore it will return all the names from the left table\\nAnd here:- \"on E.id = EU.id;\" we have said that when the \"id\" in Employee table and EmployeeUNI table matches select the corresponding unique_id and if \"id\" in both table does not match it will return null\\n\\n\\n*/\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018492,
                "title": "my-sql-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nSELECT em.unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI em ON e.id = em.id;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nSELECT em.unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI em ON e.id = em.id;",
                "codeTag": "Unknown"
            },
            {
                "id": 4018259,
                "title": "my-sql-approach",
                "content": "# Intuition\\nThis is a beginner level problem where UNION can be used.\\n# Approach\\nThere are 2 identifiable situations:\\n    1) when id does exists in both tables.\\n    2) when id does not exist in EmployeesUNI table\\nUsing UNION add combine outputs for both cases.\\nUse UNION ALL to include duplicate records as well.\\n# Complexity\\n- Time complexity:\\n2163ms\\n- Space complexity:\\n0.00 MB\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect \\nempuni.unique_id ,\\nemp.name\\nfrom Employees emp , EmployeeUNI empuni where emp.id = empuni.id \\n\\nUNION ALL\\n\\nselect null unique_id,emp.name from Employees emp where emp.id not in (select id from EmployeeUNI);\\n\\n ##not exists (select id from EmployeeUNI) ;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\nempuni.unique_id ,\\nemp.name\\nfrom Employees emp , EmployeeUNI empuni where emp.id = empuni.id \\n\\nUNION ALL\\n\\nselect null unique_id,emp.name from Employees emp where emp.id not in (select id from EmployeeUNI);\\n\\n ##not exists (select id from EmployeeUNI) ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4017055,
                "title": "easy-sql-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect \\neu.unique_id as unique_id , e.name as name from Employees e left join EmployeeUNI eu on e.id = eu.id;\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect \\neu.unique_id as unique_id , e.name as name from Employees e left join EmployeeUNI eu on e.id = eu.id;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015754,
                "title": "simple-solution-using-left-join",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect name,unique_id from Employees\\nleft join EmployeeUNI\\non Employees.id=EmployeeUNI.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect name,unique_id from Employees\\nleft join EmployeeUNI\\non Employees.id=EmployeeUNI.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4015312,
                "title": "easy-right-join-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT eu.unique_id, e.name FROM EmployeeUNI as eu\\nRIGHT JOIN Employees as e ON e.id = eu.id\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT eu.unique_id, e.name FROM EmployeeUNI as eu\\nRIGHT JOIN Employees as e ON e.id = eu.id\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013163,
                "title": "mysql-detailed-explaination-easy-to-understand",
                "content": "## Intuition\\nTo show the unique ID of each user, we need to perform a left join between the \"Employees\" and \"EmployeeUNI\" tables on the \"id\" column. This will allow us to retrieve the unique IDs for employees who have them and display null for those who do not.\\n\\n## Approach\\n```sql\\nSELECT em.unique_id AS unique_id, \\ne.name AS name \\nFROM Employees AS e\\nLEFT JOIN EmployeeUNI AS em \\nON e.id = em.id;\\n```\\n\\n## Code Explanation\\n1. We perform a left join between the \"Employees\" table (aliased as `e`) and the \"EmployeeUNI\" table (aliased as `em`) using the common column \"id.\" This retrieves information about employees and their unique IDs.\\n\\n2. We select the \"unique_id\" and \"name\" columns from the joined tables.\\n\\nThe query efficiently shows the unique ID of each user, replacing it with null for users who do not have a unique ID. The result is returned in any order.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```sql\\nSELECT em.unique_id AS unique_id, \\ne.name AS name \\nFROM Employees AS e\\nLEFT JOIN EmployeeUNI AS em \\nON e.id = em.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012663,
                "title": "sql-easy-solution",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect Employees.name,EmployeeUNI.unique_id from Employees left join EmployeeUNI on Employees.id=EmployeeUNI.id;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Employees.name,EmployeeUNI.unique_id from Employees left join EmployeeUNI on Employees.id=EmployeeUNI.id;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012552,
                "title": "best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect \\neu.unique_id as unique_id, e.name as name\\nfrom Employees e left join EmployeeUNI eu on e.id = eu.id\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect \\neu.unique_id as unique_id, e.name as name\\nfrom Employees e left join EmployeeUNI eu on e.id = eu.id\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012357,
                "title": "konka-vamsi",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect t.unique_id , e.name\\nfrom employees as e\\nleft join employeeuni as t on\\ne.id = t.id\\norder by unique_id\\n\\n\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect t.unique_id , e.name\\nfrom employees as e\\nleft join employeeuni as t on\\ne.id = t.id\\norder by unique_id\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011091,
                "title": "mysql-simple-solution",
                "content": "# Intuition\\nEasy Solution in MySQL\\n\\n# Approach\\n### **Left Join Solving**\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect unique_id, name from Employees E left join EmployeeUNI EUNI using(id);\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect unique_id, name from Employees E left join EmployeeUNI EUNI using(id);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011045,
                "title": "beats-5-to-62-80-sql-left-join-order-by",
                "content": "My First approach and my first submission code with a simple Left Join. While analysing the Time complexity after submission, My approach inly beats 5% of the MYSQL user, and le me \\uD83E\\uDD2F. I was like how did others beat me even in this simple SQL coding approach \\uD83D\\uDE2D\\n\\n# My First submission Code\\n```\\n# Write your MySQL query statement below\\nSelect name, unique_id From Employees Left Join EmployeeUNI on Employees.id = EmployeeUNI.id\\n```\\n\\n Then I\\'ve decided to analyse it further. A few days back I\\'ve came across the topic **Order By Null**, On further analysis I\\'ve came upon a common saying of Order By NULL increases the query peformance, Kinda not suRE, but in this time complexity of query has been reduced noticibaly after ading order by.\\n\\nStack overflow link of Order By NULL discussion (Reference) : https://stackoverflow.com/questions/5231907/order-by-null-in-mysql \\n\\n# Optiomized MYSQL query (with order by)\\n```\\n# Write your MySQL query statement below\\nSelect name, unique_id From Employees Left Join EmployeeUNI on Employees.id = EmployeeUNI.id order by unique_id asc\\n```\\n\\n**Comments on Further optimization of time complexity are most welcome \\uD83E\\uDD70 **\\n\\n**If you find this post usefull, Kindly upvote**\\n**Have a nice day!**",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect name, unique_id From Employees Left Join EmployeeUNI on Employees.id = EmployeeUNI.id\\n```\n```\\n# Write your MySQL query statement below\\nSelect name, unique_id From Employees Left Join EmployeeUNI on Employees.id = EmployeeUNI.id order by unique_id asc\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1920264,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 1570383,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 1975564,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 2010151,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 1917503,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 1889305,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 1574830,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 2068240,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 2062246,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 2060627,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 1920264,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 1570383,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 1975564,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 2010151,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 1917503,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 1889305,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 1574830,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 2068240,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 2062246,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 2060627,
                "content": [
                    {
                        "username": "samiul_1504106",
                        "content": "[noticeable tip for beginners]\\nwe can use both left join and right join in this case. note that, if we select from employees and then join employeeUni then we have to use left join. if we select from employeeUNI and then join employees table then we have to use right join. It means, the join depends on the this thing also."
                    },
                    {
                        "username": "minhphamduy",
                        "content": "If anyone suggest how can right join, just swap them : \\nSELECT unique_id, name\\nFROM employeeuni u\\nRIGHT JOIN employees e ON e.id = u.id;"
                    },
                    {
                        "username": "Steven-Code",
                        "content": "[@rakhikumari6602](/rakhikumari6602) The query you provided is wrong because name is not in the EmployeeUNI. And Also the right join will work if we only are considering Employees as the right table as every element has to be return as non null. "
                    },
                    {
                        "username": "rakhikumari6602",
                        "content": "select unique_id,name from EmployeeUNI left join Employees on EmployeeUNI.id=Employees.id;  I did this and still don\\'t understand why we used rightjoin,can you pls help"
                    },
                    {
                        "username": "detoxursoul",
                        "content": "#just figured - \"faster than\" metrics in the submissions screen is relative (current server load etc.) and maybe unreliable for very lightweight querly like this one. I ran the below query again and again and \"faster than\" ranged from 8% to 90%\\n\\nselect unique_id ,name     \\nfrom employees as emp\\nleft join  employeeUNI as uni\\non uni.id = emp.id"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "we need to get more leetcoders doing sql! \\uD83D\\uDCC0"
                    },
                    {
                        "username": "himanshusajwan001",
                        "content": "Is it possible that the EmployeeUNI table has two records for the same id. Same id with two unique_id, since the id is not a primary column for the table?"
                    },
                    {
                        "username": "Kathan-Vakharia",
                        "content": "Yes, it is possible. I feel like \\'id\\' column of EmployeeUNI table should also have a Unique Constraint."
                    },
                    {
                        "username": "edithi",
                        "content": "Merge Tables: You need to combine the information from the Employees table and the EmployeeUNI table based on the \\'id\\' column. Use the pd.merge() function to perform a left join to keep all records from the Employees table and match them with the corresponding \\'unique_id\\' from the EmployeeUNI table.\\n\\nSelect Columns: After merging the tables, you\\'ll have a new DataFrame with columns from both tables. You only need the \\'unique_id\\' and \\'name\\' columns for the final output. Use DataFrame indexing to select these columns.\\n\\nReplace Null: For users who do not have a unique ID (i.e., their \\'id\\' does not exist in the EmployeeUNI table), the \\'unique_id\\' column will have null values. You need to replace these null values with the string \\'null\\'. You can achieve this using DataFrame methods.\\n\\nBy following these steps, you can generate the desired output that shows the unique ID of each user, replacing null for users who do not have a unique ID."
                    },
                    {
                        "username": "user5714z",
                        "content": "Write this query like this and it will be accepted:\\n\\nselect e2.unique_id,e1.name from employees as e1 left join employeeuni as e2 on e1.id = e2.id\\n\\nExplanation :\\nby using left join we can fetch ids which don\\'t have unique ids as well and if we try to use right join we are only fetching unique ids but still not unique id remains. "
                    },
                    {
                        "username": "user9059OG",
                        "content": "jojo reference ?"
                    },
                    {
                        "username": "sparshm2k",
                        "content": "*Giorno\\'s theme starts playing out of nowhere*"
                    },
                    {
                        "username": "mahala",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\n\\nAnd why we shouldn\\'t do the group by e.name as they are asking explicitly in the question \"for each user\" so it means that there will be group by, right? Correct me if I am wrong! Thanks\\n\\nSELECT IFNULL(eu.unique_id,NULL) AS unique_id,e.name FROM Employees AS e\\nLEFT JOIN EmployeeUNI AS eu\\nON e.id = eu.id\\nGROUP BY e.name\\nORDER BY e.name DESC,unique_id;\\n"
                    },
                    {
                        "username": "manikpurivibhu",
                        "content": "I think the question says \"show \\'null\\'\", so you need to use string \\'null\\' not the value NULL"
                    },
                    {
                        "username": "402Coder",
                        "content": "[@Mingj33](/Mingj33) \\'null\\' is a character string made up of 4 letter values.  NULL is the absence of any value which is why it shows up as blank in the results.  It isn\\'t even an empty string, NULL is just nothing."
                    },
                    {
                        "username": "402Coder",
                        "content": "GROUP BY is only used when using an aggregate function such as count(), sum(), avg(), etc.  In this problem you could also drop the IFNULL(eu.unique_id, NULL) b/c you are being redundant.  The value is already NULL and then you are doing an additional check to replace NULL with NULL.  "
                    },
                    {
                        "username": "Mingj33",
                        "content": "I have same question. Why is incorrect when we assign \\'null\\' value? In the accepted answer the null values are actually space without \\'null\\'.  "
                    },
                    {
                        "username": "Annasmy",
                        "content": "Hi all,\\nMy solution is correct but not being accepted. What\\'s the issue here? Please help.\\nSELECT \\nIf(a.id=b.id, b.unique_id, \\'null\\' ) as unique_id,\\nname\\nfrom EmployeeUNI as b right join Employees as a on b.id = a.id;"
                    },
                    {
                        "username": "user5217lw",
                        "content": "The description has a problem in the data of EmployeeUNI table:\\n\\ndescription\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n+----+-----------+\\n\\nreal data\\n+----+-----------+\\n| id | unique_id |\\n+----+-----------+\\n| 3  | 1          |\\n| 11 | 2         |\\n| 90 | 3         |\\n| 10| 104      |\\n+----+-----------+\\n"
                    },
                    {
                        "username": "mutnejaanchal3008",
                        "content": "SELECT U.UNIQUE_ID ,E.NAME FROM EMPLOYEEUNI U  RIGHT JOIN EMPLOYEES E ON U.ID = E.ID;"
                    }
                ]
            },
            {
                "id": 2059244,
                "content": [
                    {
                        "username": "reduardorafa",
                        "content": "SELECT EmployeeUNI.unique_id,employees.name\\nFROM employees\\nLEFT OUTER JOIN employeeUNI \\nON employees.id = EmployeeUNI.id"
                    },
                    {
                        "username": "Navajish",
                        "content": "SELECT COALESCE(eu.unique_id, NULL) AS unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id;"
                    },
                    {
                        "username": "LeetExplorer",
                        "content": "Left join question \\u2705\\u2705\\u2705 Solution\\nSelect unique_id, name\\nfrom Employees\\nLeft join EmployeeUNI\\non Employees.id = EmployeeUNI.id "
                    },
                    {
                        "username": "bottidev",
                        "content": "I had a very hard time figuring this out because of the way the following is worded:\\n\"Each row of this table contains the id and the corresponding unique id of an employee in the company.\"\\n\\nFor some reason my dumb brain thought that this meant the \"unique_id\" column in EmployeeUNI was the one supposed to match Employees \"id\" column, but it is the other way around."
                    },
                    {
                        "username": "kondruradhakrishna",
                        "content": "SELECT unique_id,name From Employee AS emp\\nLEFT JOIN EmployeeUNI AS uni\\non uni.id=emp.id\\nwhere uni.id IS NULL;\\nwhatever i tried in online compiler it work. But here it is not work and i am getting reason for this problem"
                    },
                    {
                        "username": "Barri96",
                        "content": "Se tiene que realizar el lefth join, pero por el lado de la tabla con mas datos. Saludos\\n\\nSELECT b.unique_id, a. name From employees a left join employeeuni b on a.id=b.id;"
                    },
                    {
                        "username": "Prince72",
                        "content": "Using Left Join\\n\\nselect u.unique_id, e.name \\nfrom Employees  e\\n Left Join  EmployeeUNI u  on u.id = e.id;\\n\\n Using Right Join\\n\\nSelect u.unique_id, e.name \\nfrom EmployeeUNI u\\n right Join  Employees  e on u.id = e.id;"
                    },
                    {
                        "username": "Godfather_28",
                        "content": "how this works ?\\n"
                    },
                    {
                        "username": "user9005A",
                        "content": "Full outer join doesn\\'t work in my SQL. Switch the console to MySQL server and plug in the following code; it works and pulls all the values, including null values.\\n\\n/* Write your T-SQL query statement below */\\nWITH hub AS (\\n  SELECT  ee.unique_id, ey.name\\n  FROM EmployeeUNI ee\\n  full outer JOIN Employees ey ON ee.id = ey.id\\n  \\n)\\nSELECT hub.unique_id, hub.name\\nFROM hub;\\n\\n"
                    },
                    {
                        "username": "mightoguy",
                        "content": "how did you understaand that join (left)  is to be used\\n"
                    },
                    {
                        "username": "santiagoal",
                        "content": "Typically, you should use JOIN clause when working with columns that belong to more than 1 table. So in this case, the name can be only retrieved from the 1st table and, the unique_id can be only retrieved from the 2nd table, thus, the JOIN let you merge tables and the ON condition is how you want to merge those tables, for instance, in this case, we want that every row of the merged table corresponds to an user id"
                    },
                    {
                        "username": "AneeshAhmed1110",
                        "content": "Select unique_id from EmployeeUNI\\nright join employeeUNI on employeeUNI.id=employees.id;\\n\\nwhat is the error in this query?"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "Select unique_id ,name from employeeUNI \\nright join employees  on employeeUNI.id=employees.id;"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "first of you have taken the same table on both side \\nsecond you have print the both unique_id,name "
                    },
                    {
                        "username": "kevin-DL",
                        "content": "Both sides of the join are the same table"
                    }
                ]
            },
            {
                "id": 2055835,
                "content": [
                    {
                        "username": "reduardorafa",
                        "content": "SELECT EmployeeUNI.unique_id,employees.name\\nFROM employees\\nLEFT OUTER JOIN employeeUNI \\nON employees.id = EmployeeUNI.id"
                    },
                    {
                        "username": "Navajish",
                        "content": "SELECT COALESCE(eu.unique_id, NULL) AS unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id;"
                    },
                    {
                        "username": "LeetExplorer",
                        "content": "Left join question \\u2705\\u2705\\u2705 Solution\\nSelect unique_id, name\\nfrom Employees\\nLeft join EmployeeUNI\\non Employees.id = EmployeeUNI.id "
                    },
                    {
                        "username": "bottidev",
                        "content": "I had a very hard time figuring this out because of the way the following is worded:\\n\"Each row of this table contains the id and the corresponding unique id of an employee in the company.\"\\n\\nFor some reason my dumb brain thought that this meant the \"unique_id\" column in EmployeeUNI was the one supposed to match Employees \"id\" column, but it is the other way around."
                    },
                    {
                        "username": "kondruradhakrishna",
                        "content": "SELECT unique_id,name From Employee AS emp\\nLEFT JOIN EmployeeUNI AS uni\\non uni.id=emp.id\\nwhere uni.id IS NULL;\\nwhatever i tried in online compiler it work. But here it is not work and i am getting reason for this problem"
                    },
                    {
                        "username": "Barri96",
                        "content": "Se tiene que realizar el lefth join, pero por el lado de la tabla con mas datos. Saludos\\n\\nSELECT b.unique_id, a. name From employees a left join employeeuni b on a.id=b.id;"
                    },
                    {
                        "username": "Prince72",
                        "content": "Using Left Join\\n\\nselect u.unique_id, e.name \\nfrom Employees  e\\n Left Join  EmployeeUNI u  on u.id = e.id;\\n\\n Using Right Join\\n\\nSelect u.unique_id, e.name \\nfrom EmployeeUNI u\\n right Join  Employees  e on u.id = e.id;"
                    },
                    {
                        "username": "Godfather_28",
                        "content": "how this works ?\\n"
                    },
                    {
                        "username": "user9005A",
                        "content": "Full outer join doesn\\'t work in my SQL. Switch the console to MySQL server and plug in the following code; it works and pulls all the values, including null values.\\n\\n/* Write your T-SQL query statement below */\\nWITH hub AS (\\n  SELECT  ee.unique_id, ey.name\\n  FROM EmployeeUNI ee\\n  full outer JOIN Employees ey ON ee.id = ey.id\\n  \\n)\\nSELECT hub.unique_id, hub.name\\nFROM hub;\\n\\n"
                    },
                    {
                        "username": "mightoguy",
                        "content": "how did you understaand that join (left)  is to be used\\n"
                    },
                    {
                        "username": "santiagoal",
                        "content": "Typically, you should use JOIN clause when working with columns that belong to more than 1 table. So in this case, the name can be only retrieved from the 1st table and, the unique_id can be only retrieved from the 2nd table, thus, the JOIN let you merge tables and the ON condition is how you want to merge those tables, for instance, in this case, we want that every row of the merged table corresponds to an user id"
                    },
                    {
                        "username": "AneeshAhmed1110",
                        "content": "Select unique_id from EmployeeUNI\\nright join employeeUNI on employeeUNI.id=employees.id;\\n\\nwhat is the error in this query?"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "Select unique_id ,name from employeeUNI \\nright join employees  on employeeUNI.id=employees.id;"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "first of you have taken the same table on both side \\nsecond you have print the both unique_id,name "
                    },
                    {
                        "username": "kevin-DL",
                        "content": "Both sides of the join are the same table"
                    }
                ]
            },
            {
                "id": 2054310,
                "content": [
                    {
                        "username": "reduardorafa",
                        "content": "SELECT EmployeeUNI.unique_id,employees.name\\nFROM employees\\nLEFT OUTER JOIN employeeUNI \\nON employees.id = EmployeeUNI.id"
                    },
                    {
                        "username": "Navajish",
                        "content": "SELECT COALESCE(eu.unique_id, NULL) AS unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id;"
                    },
                    {
                        "username": "LeetExplorer",
                        "content": "Left join question \\u2705\\u2705\\u2705 Solution\\nSelect unique_id, name\\nfrom Employees\\nLeft join EmployeeUNI\\non Employees.id = EmployeeUNI.id "
                    },
                    {
                        "username": "bottidev",
                        "content": "I had a very hard time figuring this out because of the way the following is worded:\\n\"Each row of this table contains the id and the corresponding unique id of an employee in the company.\"\\n\\nFor some reason my dumb brain thought that this meant the \"unique_id\" column in EmployeeUNI was the one supposed to match Employees \"id\" column, but it is the other way around."
                    },
                    {
                        "username": "kondruradhakrishna",
                        "content": "SELECT unique_id,name From Employee AS emp\\nLEFT JOIN EmployeeUNI AS uni\\non uni.id=emp.id\\nwhere uni.id IS NULL;\\nwhatever i tried in online compiler it work. But here it is not work and i am getting reason for this problem"
                    },
                    {
                        "username": "Barri96",
                        "content": "Se tiene que realizar el lefth join, pero por el lado de la tabla con mas datos. Saludos\\n\\nSELECT b.unique_id, a. name From employees a left join employeeuni b on a.id=b.id;"
                    },
                    {
                        "username": "Prince72",
                        "content": "Using Left Join\\n\\nselect u.unique_id, e.name \\nfrom Employees  e\\n Left Join  EmployeeUNI u  on u.id = e.id;\\n\\n Using Right Join\\n\\nSelect u.unique_id, e.name \\nfrom EmployeeUNI u\\n right Join  Employees  e on u.id = e.id;"
                    },
                    {
                        "username": "Godfather_28",
                        "content": "how this works ?\\n"
                    },
                    {
                        "username": "user9005A",
                        "content": "Full outer join doesn\\'t work in my SQL. Switch the console to MySQL server and plug in the following code; it works and pulls all the values, including null values.\\n\\n/* Write your T-SQL query statement below */\\nWITH hub AS (\\n  SELECT  ee.unique_id, ey.name\\n  FROM EmployeeUNI ee\\n  full outer JOIN Employees ey ON ee.id = ey.id\\n  \\n)\\nSELECT hub.unique_id, hub.name\\nFROM hub;\\n\\n"
                    },
                    {
                        "username": "mightoguy",
                        "content": "how did you understaand that join (left)  is to be used\\n"
                    },
                    {
                        "username": "santiagoal",
                        "content": "Typically, you should use JOIN clause when working with columns that belong to more than 1 table. So in this case, the name can be only retrieved from the 1st table and, the unique_id can be only retrieved from the 2nd table, thus, the JOIN let you merge tables and the ON condition is how you want to merge those tables, for instance, in this case, we want that every row of the merged table corresponds to an user id"
                    },
                    {
                        "username": "AneeshAhmed1110",
                        "content": "Select unique_id from EmployeeUNI\\nright join employeeUNI on employeeUNI.id=employees.id;\\n\\nwhat is the error in this query?"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "Select unique_id ,name from employeeUNI \\nright join employees  on employeeUNI.id=employees.id;"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "first of you have taken the same table on both side \\nsecond you have print the both unique_id,name "
                    },
                    {
                        "username": "kevin-DL",
                        "content": "Both sides of the join are the same table"
                    }
                ]
            },
            {
                "id": 2045499,
                "content": [
                    {
                        "username": "reduardorafa",
                        "content": "SELECT EmployeeUNI.unique_id,employees.name\\nFROM employees\\nLEFT OUTER JOIN employeeUNI \\nON employees.id = EmployeeUNI.id"
                    },
                    {
                        "username": "Navajish",
                        "content": "SELECT COALESCE(eu.unique_id, NULL) AS unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id;"
                    },
                    {
                        "username": "LeetExplorer",
                        "content": "Left join question \\u2705\\u2705\\u2705 Solution\\nSelect unique_id, name\\nfrom Employees\\nLeft join EmployeeUNI\\non Employees.id = EmployeeUNI.id "
                    },
                    {
                        "username": "bottidev",
                        "content": "I had a very hard time figuring this out because of the way the following is worded:\\n\"Each row of this table contains the id and the corresponding unique id of an employee in the company.\"\\n\\nFor some reason my dumb brain thought that this meant the \"unique_id\" column in EmployeeUNI was the one supposed to match Employees \"id\" column, but it is the other way around."
                    },
                    {
                        "username": "kondruradhakrishna",
                        "content": "SELECT unique_id,name From Employee AS emp\\nLEFT JOIN EmployeeUNI AS uni\\non uni.id=emp.id\\nwhere uni.id IS NULL;\\nwhatever i tried in online compiler it work. But here it is not work and i am getting reason for this problem"
                    },
                    {
                        "username": "Barri96",
                        "content": "Se tiene que realizar el lefth join, pero por el lado de la tabla con mas datos. Saludos\\n\\nSELECT b.unique_id, a. name From employees a left join employeeuni b on a.id=b.id;"
                    },
                    {
                        "username": "Prince72",
                        "content": "Using Left Join\\n\\nselect u.unique_id, e.name \\nfrom Employees  e\\n Left Join  EmployeeUNI u  on u.id = e.id;\\n\\n Using Right Join\\n\\nSelect u.unique_id, e.name \\nfrom EmployeeUNI u\\n right Join  Employees  e on u.id = e.id;"
                    },
                    {
                        "username": "Godfather_28",
                        "content": "how this works ?\\n"
                    },
                    {
                        "username": "user9005A",
                        "content": "Full outer join doesn\\'t work in my SQL. Switch the console to MySQL server and plug in the following code; it works and pulls all the values, including null values.\\n\\n/* Write your T-SQL query statement below */\\nWITH hub AS (\\n  SELECT  ee.unique_id, ey.name\\n  FROM EmployeeUNI ee\\n  full outer JOIN Employees ey ON ee.id = ey.id\\n  \\n)\\nSELECT hub.unique_id, hub.name\\nFROM hub;\\n\\n"
                    },
                    {
                        "username": "mightoguy",
                        "content": "how did you understaand that join (left)  is to be used\\n"
                    },
                    {
                        "username": "santiagoal",
                        "content": "Typically, you should use JOIN clause when working with columns that belong to more than 1 table. So in this case, the name can be only retrieved from the 1st table and, the unique_id can be only retrieved from the 2nd table, thus, the JOIN let you merge tables and the ON condition is how you want to merge those tables, for instance, in this case, we want that every row of the merged table corresponds to an user id"
                    },
                    {
                        "username": "AneeshAhmed1110",
                        "content": "Select unique_id from EmployeeUNI\\nright join employeeUNI on employeeUNI.id=employees.id;\\n\\nwhat is the error in this query?"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "Select unique_id ,name from employeeUNI \\nright join employees  on employeeUNI.id=employees.id;"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "first of you have taken the same table on both side \\nsecond you have print the both unique_id,name "
                    },
                    {
                        "username": "kevin-DL",
                        "content": "Both sides of the join are the same table"
                    }
                ]
            },
            {
                "id": 2039942,
                "content": [
                    {
                        "username": "reduardorafa",
                        "content": "SELECT EmployeeUNI.unique_id,employees.name\\nFROM employees\\nLEFT OUTER JOIN employeeUNI \\nON employees.id = EmployeeUNI.id"
                    },
                    {
                        "username": "Navajish",
                        "content": "SELECT COALESCE(eu.unique_id, NULL) AS unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id;"
                    },
                    {
                        "username": "LeetExplorer",
                        "content": "Left join question \\u2705\\u2705\\u2705 Solution\\nSelect unique_id, name\\nfrom Employees\\nLeft join EmployeeUNI\\non Employees.id = EmployeeUNI.id "
                    },
                    {
                        "username": "bottidev",
                        "content": "I had a very hard time figuring this out because of the way the following is worded:\\n\"Each row of this table contains the id and the corresponding unique id of an employee in the company.\"\\n\\nFor some reason my dumb brain thought that this meant the \"unique_id\" column in EmployeeUNI was the one supposed to match Employees \"id\" column, but it is the other way around."
                    },
                    {
                        "username": "kondruradhakrishna",
                        "content": "SELECT unique_id,name From Employee AS emp\\nLEFT JOIN EmployeeUNI AS uni\\non uni.id=emp.id\\nwhere uni.id IS NULL;\\nwhatever i tried in online compiler it work. But here it is not work and i am getting reason for this problem"
                    },
                    {
                        "username": "Barri96",
                        "content": "Se tiene que realizar el lefth join, pero por el lado de la tabla con mas datos. Saludos\\n\\nSELECT b.unique_id, a. name From employees a left join employeeuni b on a.id=b.id;"
                    },
                    {
                        "username": "Prince72",
                        "content": "Using Left Join\\n\\nselect u.unique_id, e.name \\nfrom Employees  e\\n Left Join  EmployeeUNI u  on u.id = e.id;\\n\\n Using Right Join\\n\\nSelect u.unique_id, e.name \\nfrom EmployeeUNI u\\n right Join  Employees  e on u.id = e.id;"
                    },
                    {
                        "username": "Godfather_28",
                        "content": "how this works ?\\n"
                    },
                    {
                        "username": "user9005A",
                        "content": "Full outer join doesn\\'t work in my SQL. Switch the console to MySQL server and plug in the following code; it works and pulls all the values, including null values.\\n\\n/* Write your T-SQL query statement below */\\nWITH hub AS (\\n  SELECT  ee.unique_id, ey.name\\n  FROM EmployeeUNI ee\\n  full outer JOIN Employees ey ON ee.id = ey.id\\n  \\n)\\nSELECT hub.unique_id, hub.name\\nFROM hub;\\n\\n"
                    },
                    {
                        "username": "mightoguy",
                        "content": "how did you understaand that join (left)  is to be used\\n"
                    },
                    {
                        "username": "santiagoal",
                        "content": "Typically, you should use JOIN clause when working with columns that belong to more than 1 table. So in this case, the name can be only retrieved from the 1st table and, the unique_id can be only retrieved from the 2nd table, thus, the JOIN let you merge tables and the ON condition is how you want to merge those tables, for instance, in this case, we want that every row of the merged table corresponds to an user id"
                    },
                    {
                        "username": "AneeshAhmed1110",
                        "content": "Select unique_id from EmployeeUNI\\nright join employeeUNI on employeeUNI.id=employees.id;\\n\\nwhat is the error in this query?"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "Select unique_id ,name from employeeUNI \\nright join employees  on employeeUNI.id=employees.id;"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "first of you have taken the same table on both side \\nsecond you have print the both unique_id,name "
                    },
                    {
                        "username": "kevin-DL",
                        "content": "Both sides of the join are the same table"
                    }
                ]
            },
            {
                "id": 2017205,
                "content": [
                    {
                        "username": "reduardorafa",
                        "content": "SELECT EmployeeUNI.unique_id,employees.name\\nFROM employees\\nLEFT OUTER JOIN employeeUNI \\nON employees.id = EmployeeUNI.id"
                    },
                    {
                        "username": "Navajish",
                        "content": "SELECT COALESCE(eu.unique_id, NULL) AS unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id;"
                    },
                    {
                        "username": "LeetExplorer",
                        "content": "Left join question \\u2705\\u2705\\u2705 Solution\\nSelect unique_id, name\\nfrom Employees\\nLeft join EmployeeUNI\\non Employees.id = EmployeeUNI.id "
                    },
                    {
                        "username": "bottidev",
                        "content": "I had a very hard time figuring this out because of the way the following is worded:\\n\"Each row of this table contains the id and the corresponding unique id of an employee in the company.\"\\n\\nFor some reason my dumb brain thought that this meant the \"unique_id\" column in EmployeeUNI was the one supposed to match Employees \"id\" column, but it is the other way around."
                    },
                    {
                        "username": "kondruradhakrishna",
                        "content": "SELECT unique_id,name From Employee AS emp\\nLEFT JOIN EmployeeUNI AS uni\\non uni.id=emp.id\\nwhere uni.id IS NULL;\\nwhatever i tried in online compiler it work. But here it is not work and i am getting reason for this problem"
                    },
                    {
                        "username": "Barri96",
                        "content": "Se tiene que realizar el lefth join, pero por el lado de la tabla con mas datos. Saludos\\n\\nSELECT b.unique_id, a. name From employees a left join employeeuni b on a.id=b.id;"
                    },
                    {
                        "username": "Prince72",
                        "content": "Using Left Join\\n\\nselect u.unique_id, e.name \\nfrom Employees  e\\n Left Join  EmployeeUNI u  on u.id = e.id;\\n\\n Using Right Join\\n\\nSelect u.unique_id, e.name \\nfrom EmployeeUNI u\\n right Join  Employees  e on u.id = e.id;"
                    },
                    {
                        "username": "Godfather_28",
                        "content": "how this works ?\\n"
                    },
                    {
                        "username": "user9005A",
                        "content": "Full outer join doesn\\'t work in my SQL. Switch the console to MySQL server and plug in the following code; it works and pulls all the values, including null values.\\n\\n/* Write your T-SQL query statement below */\\nWITH hub AS (\\n  SELECT  ee.unique_id, ey.name\\n  FROM EmployeeUNI ee\\n  full outer JOIN Employees ey ON ee.id = ey.id\\n  \\n)\\nSELECT hub.unique_id, hub.name\\nFROM hub;\\n\\n"
                    },
                    {
                        "username": "mightoguy",
                        "content": "how did you understaand that join (left)  is to be used\\n"
                    },
                    {
                        "username": "santiagoal",
                        "content": "Typically, you should use JOIN clause when working with columns that belong to more than 1 table. So in this case, the name can be only retrieved from the 1st table and, the unique_id can be only retrieved from the 2nd table, thus, the JOIN let you merge tables and the ON condition is how you want to merge those tables, for instance, in this case, we want that every row of the merged table corresponds to an user id"
                    },
                    {
                        "username": "AneeshAhmed1110",
                        "content": "Select unique_id from EmployeeUNI\\nright join employeeUNI on employeeUNI.id=employees.id;\\n\\nwhat is the error in this query?"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "Select unique_id ,name from employeeUNI \\nright join employees  on employeeUNI.id=employees.id;"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "first of you have taken the same table on both side \\nsecond you have print the both unique_id,name "
                    },
                    {
                        "username": "kevin-DL",
                        "content": "Both sides of the join are the same table"
                    }
                ]
            },
            {
                "id": 2016136,
                "content": [
                    {
                        "username": "reduardorafa",
                        "content": "SELECT EmployeeUNI.unique_id,employees.name\\nFROM employees\\nLEFT OUTER JOIN employeeUNI \\nON employees.id = EmployeeUNI.id"
                    },
                    {
                        "username": "Navajish",
                        "content": "SELECT COALESCE(eu.unique_id, NULL) AS unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id;"
                    },
                    {
                        "username": "LeetExplorer",
                        "content": "Left join question \\u2705\\u2705\\u2705 Solution\\nSelect unique_id, name\\nfrom Employees\\nLeft join EmployeeUNI\\non Employees.id = EmployeeUNI.id "
                    },
                    {
                        "username": "bottidev",
                        "content": "I had a very hard time figuring this out because of the way the following is worded:\\n\"Each row of this table contains the id and the corresponding unique id of an employee in the company.\"\\n\\nFor some reason my dumb brain thought that this meant the \"unique_id\" column in EmployeeUNI was the one supposed to match Employees \"id\" column, but it is the other way around."
                    },
                    {
                        "username": "kondruradhakrishna",
                        "content": "SELECT unique_id,name From Employee AS emp\\nLEFT JOIN EmployeeUNI AS uni\\non uni.id=emp.id\\nwhere uni.id IS NULL;\\nwhatever i tried in online compiler it work. But here it is not work and i am getting reason for this problem"
                    },
                    {
                        "username": "Barri96",
                        "content": "Se tiene que realizar el lefth join, pero por el lado de la tabla con mas datos. Saludos\\n\\nSELECT b.unique_id, a. name From employees a left join employeeuni b on a.id=b.id;"
                    },
                    {
                        "username": "Prince72",
                        "content": "Using Left Join\\n\\nselect u.unique_id, e.name \\nfrom Employees  e\\n Left Join  EmployeeUNI u  on u.id = e.id;\\n\\n Using Right Join\\n\\nSelect u.unique_id, e.name \\nfrom EmployeeUNI u\\n right Join  Employees  e on u.id = e.id;"
                    },
                    {
                        "username": "Godfather_28",
                        "content": "how this works ?\\n"
                    },
                    {
                        "username": "user9005A",
                        "content": "Full outer join doesn\\'t work in my SQL. Switch the console to MySQL server and plug in the following code; it works and pulls all the values, including null values.\\n\\n/* Write your T-SQL query statement below */\\nWITH hub AS (\\n  SELECT  ee.unique_id, ey.name\\n  FROM EmployeeUNI ee\\n  full outer JOIN Employees ey ON ee.id = ey.id\\n  \\n)\\nSELECT hub.unique_id, hub.name\\nFROM hub;\\n\\n"
                    },
                    {
                        "username": "mightoguy",
                        "content": "how did you understaand that join (left)  is to be used\\n"
                    },
                    {
                        "username": "santiagoal",
                        "content": "Typically, you should use JOIN clause when working with columns that belong to more than 1 table. So in this case, the name can be only retrieved from the 1st table and, the unique_id can be only retrieved from the 2nd table, thus, the JOIN let you merge tables and the ON condition is how you want to merge those tables, for instance, in this case, we want that every row of the merged table corresponds to an user id"
                    },
                    {
                        "username": "AneeshAhmed1110",
                        "content": "Select unique_id from EmployeeUNI\\nright join employeeUNI on employeeUNI.id=employees.id;\\n\\nwhat is the error in this query?"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "Select unique_id ,name from employeeUNI \\nright join employees  on employeeUNI.id=employees.id;"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "first of you have taken the same table on both side \\nsecond you have print the both unique_id,name "
                    },
                    {
                        "username": "kevin-DL",
                        "content": "Both sides of the join are the same table"
                    }
                ]
            },
            {
                "id": 2003623,
                "content": [
                    {
                        "username": "reduardorafa",
                        "content": "SELECT EmployeeUNI.unique_id,employees.name\\nFROM employees\\nLEFT OUTER JOIN employeeUNI \\nON employees.id = EmployeeUNI.id"
                    },
                    {
                        "username": "Navajish",
                        "content": "SELECT COALESCE(eu.unique_id, NULL) AS unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id;"
                    },
                    {
                        "username": "LeetExplorer",
                        "content": "Left join question \\u2705\\u2705\\u2705 Solution\\nSelect unique_id, name\\nfrom Employees\\nLeft join EmployeeUNI\\non Employees.id = EmployeeUNI.id "
                    },
                    {
                        "username": "bottidev",
                        "content": "I had a very hard time figuring this out because of the way the following is worded:\\n\"Each row of this table contains the id and the corresponding unique id of an employee in the company.\"\\n\\nFor some reason my dumb brain thought that this meant the \"unique_id\" column in EmployeeUNI was the one supposed to match Employees \"id\" column, but it is the other way around."
                    },
                    {
                        "username": "kondruradhakrishna",
                        "content": "SELECT unique_id,name From Employee AS emp\\nLEFT JOIN EmployeeUNI AS uni\\non uni.id=emp.id\\nwhere uni.id IS NULL;\\nwhatever i tried in online compiler it work. But here it is not work and i am getting reason for this problem"
                    },
                    {
                        "username": "Barri96",
                        "content": "Se tiene que realizar el lefth join, pero por el lado de la tabla con mas datos. Saludos\\n\\nSELECT b.unique_id, a. name From employees a left join employeeuni b on a.id=b.id;"
                    },
                    {
                        "username": "Prince72",
                        "content": "Using Left Join\\n\\nselect u.unique_id, e.name \\nfrom Employees  e\\n Left Join  EmployeeUNI u  on u.id = e.id;\\n\\n Using Right Join\\n\\nSelect u.unique_id, e.name \\nfrom EmployeeUNI u\\n right Join  Employees  e on u.id = e.id;"
                    },
                    {
                        "username": "Godfather_28",
                        "content": "how this works ?\\n"
                    },
                    {
                        "username": "user9005A",
                        "content": "Full outer join doesn\\'t work in my SQL. Switch the console to MySQL server and plug in the following code; it works and pulls all the values, including null values.\\n\\n/* Write your T-SQL query statement below */\\nWITH hub AS (\\n  SELECT  ee.unique_id, ey.name\\n  FROM EmployeeUNI ee\\n  full outer JOIN Employees ey ON ee.id = ey.id\\n  \\n)\\nSELECT hub.unique_id, hub.name\\nFROM hub;\\n\\n"
                    },
                    {
                        "username": "mightoguy",
                        "content": "how did you understaand that join (left)  is to be used\\n"
                    },
                    {
                        "username": "santiagoal",
                        "content": "Typically, you should use JOIN clause when working with columns that belong to more than 1 table. So in this case, the name can be only retrieved from the 1st table and, the unique_id can be only retrieved from the 2nd table, thus, the JOIN let you merge tables and the ON condition is how you want to merge those tables, for instance, in this case, we want that every row of the merged table corresponds to an user id"
                    },
                    {
                        "username": "AneeshAhmed1110",
                        "content": "Select unique_id from EmployeeUNI\\nright join employeeUNI on employeeUNI.id=employees.id;\\n\\nwhat is the error in this query?"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "Select unique_id ,name from employeeUNI \\nright join employees  on employeeUNI.id=employees.id;"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "first of you have taken the same table on both side \\nsecond you have print the both unique_id,name "
                    },
                    {
                        "username": "kevin-DL",
                        "content": "Both sides of the join are the same table"
                    }
                ]
            },
            {
                "id": 1975687,
                "content": [
                    {
                        "username": "reduardorafa",
                        "content": "SELECT EmployeeUNI.unique_id,employees.name\\nFROM employees\\nLEFT OUTER JOIN employeeUNI \\nON employees.id = EmployeeUNI.id"
                    },
                    {
                        "username": "Navajish",
                        "content": "SELECT COALESCE(eu.unique_id, NULL) AS unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id;"
                    },
                    {
                        "username": "LeetExplorer",
                        "content": "Left join question \\u2705\\u2705\\u2705 Solution\\nSelect unique_id, name\\nfrom Employees\\nLeft join EmployeeUNI\\non Employees.id = EmployeeUNI.id "
                    },
                    {
                        "username": "bottidev",
                        "content": "I had a very hard time figuring this out because of the way the following is worded:\\n\"Each row of this table contains the id and the corresponding unique id of an employee in the company.\"\\n\\nFor some reason my dumb brain thought that this meant the \"unique_id\" column in EmployeeUNI was the one supposed to match Employees \"id\" column, but it is the other way around."
                    },
                    {
                        "username": "kondruradhakrishna",
                        "content": "SELECT unique_id,name From Employee AS emp\\nLEFT JOIN EmployeeUNI AS uni\\non uni.id=emp.id\\nwhere uni.id IS NULL;\\nwhatever i tried in online compiler it work. But here it is not work and i am getting reason for this problem"
                    },
                    {
                        "username": "Barri96",
                        "content": "Se tiene que realizar el lefth join, pero por el lado de la tabla con mas datos. Saludos\\n\\nSELECT b.unique_id, a. name From employees a left join employeeuni b on a.id=b.id;"
                    },
                    {
                        "username": "Prince72",
                        "content": "Using Left Join\\n\\nselect u.unique_id, e.name \\nfrom Employees  e\\n Left Join  EmployeeUNI u  on u.id = e.id;\\n\\n Using Right Join\\n\\nSelect u.unique_id, e.name \\nfrom EmployeeUNI u\\n right Join  Employees  e on u.id = e.id;"
                    },
                    {
                        "username": "Godfather_28",
                        "content": "how this works ?\\n"
                    },
                    {
                        "username": "user9005A",
                        "content": "Full outer join doesn\\'t work in my SQL. Switch the console to MySQL server and plug in the following code; it works and pulls all the values, including null values.\\n\\n/* Write your T-SQL query statement below */\\nWITH hub AS (\\n  SELECT  ee.unique_id, ey.name\\n  FROM EmployeeUNI ee\\n  full outer JOIN Employees ey ON ee.id = ey.id\\n  \\n)\\nSELECT hub.unique_id, hub.name\\nFROM hub;\\n\\n"
                    },
                    {
                        "username": "mightoguy",
                        "content": "how did you understaand that join (left)  is to be used\\n"
                    },
                    {
                        "username": "santiagoal",
                        "content": "Typically, you should use JOIN clause when working with columns that belong to more than 1 table. So in this case, the name can be only retrieved from the 1st table and, the unique_id can be only retrieved from the 2nd table, thus, the JOIN let you merge tables and the ON condition is how you want to merge those tables, for instance, in this case, we want that every row of the merged table corresponds to an user id"
                    },
                    {
                        "username": "AneeshAhmed1110",
                        "content": "Select unique_id from EmployeeUNI\\nright join employeeUNI on employeeUNI.id=employees.id;\\n\\nwhat is the error in this query?"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "Select unique_id ,name from employeeUNI \\nright join employees  on employeeUNI.id=employees.id;"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "first of you have taken the same table on both side \\nsecond you have print the both unique_id,name "
                    },
                    {
                        "username": "kevin-DL",
                        "content": "Both sides of the join are the same table"
                    }
                ]
            },
            {
                "id": 1954660,
                "content": [
                    {
                        "username": "reduardorafa",
                        "content": "SELECT EmployeeUNI.unique_id,employees.name\\nFROM employees\\nLEFT OUTER JOIN employeeUNI \\nON employees.id = EmployeeUNI.id"
                    },
                    {
                        "username": "Navajish",
                        "content": "SELECT COALESCE(eu.unique_id, NULL) AS unique_id, e.name\\nFROM Employees e\\nLEFT JOIN EmployeeUNI eu ON e.id = eu.id;"
                    },
                    {
                        "username": "LeetExplorer",
                        "content": "Left join question \\u2705\\u2705\\u2705 Solution\\nSelect unique_id, name\\nfrom Employees\\nLeft join EmployeeUNI\\non Employees.id = EmployeeUNI.id "
                    },
                    {
                        "username": "bottidev",
                        "content": "I had a very hard time figuring this out because of the way the following is worded:\\n\"Each row of this table contains the id and the corresponding unique id of an employee in the company.\"\\n\\nFor some reason my dumb brain thought that this meant the \"unique_id\" column in EmployeeUNI was the one supposed to match Employees \"id\" column, but it is the other way around."
                    },
                    {
                        "username": "kondruradhakrishna",
                        "content": "SELECT unique_id,name From Employee AS emp\\nLEFT JOIN EmployeeUNI AS uni\\non uni.id=emp.id\\nwhere uni.id IS NULL;\\nwhatever i tried in online compiler it work. But here it is not work and i am getting reason for this problem"
                    },
                    {
                        "username": "Barri96",
                        "content": "Se tiene que realizar el lefth join, pero por el lado de la tabla con mas datos. Saludos\\n\\nSELECT b.unique_id, a. name From employees a left join employeeuni b on a.id=b.id;"
                    },
                    {
                        "username": "Prince72",
                        "content": "Using Left Join\\n\\nselect u.unique_id, e.name \\nfrom Employees  e\\n Left Join  EmployeeUNI u  on u.id = e.id;\\n\\n Using Right Join\\n\\nSelect u.unique_id, e.name \\nfrom EmployeeUNI u\\n right Join  Employees  e on u.id = e.id;"
                    },
                    {
                        "username": "Godfather_28",
                        "content": "how this works ?\\n"
                    },
                    {
                        "username": "user9005A",
                        "content": "Full outer join doesn\\'t work in my SQL. Switch the console to MySQL server and plug in the following code; it works and pulls all the values, including null values.\\n\\n/* Write your T-SQL query statement below */\\nWITH hub AS (\\n  SELECT  ee.unique_id, ey.name\\n  FROM EmployeeUNI ee\\n  full outer JOIN Employees ey ON ee.id = ey.id\\n  \\n)\\nSELECT hub.unique_id, hub.name\\nFROM hub;\\n\\n"
                    },
                    {
                        "username": "mightoguy",
                        "content": "how did you understaand that join (left)  is to be used\\n"
                    },
                    {
                        "username": "santiagoal",
                        "content": "Typically, you should use JOIN clause when working with columns that belong to more than 1 table. So in this case, the name can be only retrieved from the 1st table and, the unique_id can be only retrieved from the 2nd table, thus, the JOIN let you merge tables and the ON condition is how you want to merge those tables, for instance, in this case, we want that every row of the merged table corresponds to an user id"
                    },
                    {
                        "username": "AneeshAhmed1110",
                        "content": "Select unique_id from EmployeeUNI\\nright join employeeUNI on employeeUNI.id=employees.id;\\n\\nwhat is the error in this query?"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "Select unique_id ,name from employeeUNI \\nright join employees  on employeeUNI.id=employees.id;"
                    },
                    {
                        "username": "tenplus_086",
                        "content": "first of you have taken the same table on both side \\nsecond you have print the both unique_id,name "
                    },
                    {
                        "username": "kevin-DL",
                        "content": "Both sides of the join are the same table"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find a Corresponding Node of a Binary Tree in a Clone of That Tree",
        "question_content": "<p>Given two binary trees <code>original</code> and <code>cloned</code> and given a reference to a node <code>target</code> in the original tree.</p>\n\n<p>The <code>cloned</code> tree is a <strong>copy of</strong> the <code>original</code> tree.</p>\n\n<p>Return <em>a reference to the same node</em> in the <code>cloned</code> tree.</p>\n\n<p><strong>Note</strong> that you are <strong>not allowed</strong> to change any of the two trees or the <code>target</code> node and the answer <strong>must be</strong> a reference to a node in the <code>cloned</code> tree.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/21/e1.png\" style=\"width: 544px; height: 426px;\" />\n<pre>\n<strong>Input:</strong> tree = [7,4,3,null,null,6,19], target = 3\n<strong>Output:</strong> 3\n<strong>Explanation:</strong> In all examples the original and cloned trees are shown. The target node is a green node from the original tree. The answer is the yellow node from the cloned tree.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/21/e2.png\" style=\"width: 221px; height: 159px;\" />\n<pre>\n<strong>Input:</strong> tree = [7], target =  7\n<strong>Output:</strong> 7\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2020/02/21/e3.png\" style=\"width: 459px; height: 486px;\" />\n<pre>\n<strong>Input:</strong> tree = [8,null,6,null,5,null,4,null,3,null,2,null,1], target = 4\n<strong>Output:</strong> 4\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the <code>tree</code> is in the range <code>[1, 10<sup>4</sup>]</code>.</li>\n\t<li>The values of the nodes of the <code>tree</code> are unique.</li>\n\t<li><code>target</code> node is a node from the <code>original</code> tree and is not <code>null</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> Could you solve the problem if repeated values on the tree are allowed?</p>\n",
        "solutions": [
            {
                "id": 537728,
                "title": "java-simple-solution",
                "content": "```\\n\\tpublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n\\t\\tif (original == null || original == target)\\n\\t\\t\\treturn cloned;\\n\\t\\tTreeNode res = getTargetCopy(original.left, cloned.left, target);\\n\\t\\tif (res != null)\\n\\t\\t\\treturn res;\\n\\t\\treturn getTargetCopy(original.right, cloned.right, target);\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n\\t\\tif (original == null || original == target)\\n\\t\\t\\treturn cloned;\\n\\t\\tTreeNode res = getTargetCopy(original.left, cloned.left, target);\\n\\t\\tif (res != null)\\n\\t\\t\\treturn res;\\n\\t\\treturn getTargetCopy(original.right, cloned.right, target);\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537686,
                "title": "python-clean-and-pythonic-way-using-generator-solving-followup-too",
                "content": "IMO only if with the followup this problem could be tagged as medium...\\n\\n``` python\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        def it(node):\\n            if node:\\n                yield node\\n                yield from it(node.left)\\n                yield from it(node.right)\\n                \\n        for n1, n2 in zip(it(original), it(cloned)):\\n            if n1 == target:\\n                return n2\\n```\\n\\n**Beyond...**\\n\\nIdk why this problem doesn\\'t accept Go solution, but Go Channels can be used as the same way...\\n**Non-tested** code below:\\n\\n```go\\nfunc getTargetCopy(original, cloned, target *TreeNode) *TreeNode {\\n\\tvar it func(*TreeNode, chan *TreeNode)\\n    it = func(node *TreeNode, ch chan *TreeNode) {\\n\\t\\tif node != nil {\\n\\t\\t\\tch <- node\\n\\t\\t\\tit(node.Left)\\n\\t\\t\\tit(node.Right)\\n\\t\\t}\\n\\t}\\n\\t\\n\\tch1, ch2 := make(chan *TreeNode), make(chan *TreeNode)\\n\\tgo it(original, ch1)\\n\\tgo it(cloned, ch2)\\n\\t\\n\\tfor {\\n\\t\\tn1, n2 := <-ch1, <-ch2\\n\\t\\tif n1 == target {\\n\\t\\t\\treturn n2\\n\\t\\t}\\n\\t}\\n\\treturn nil\\n}\\n```",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        def it(node):\\n            if node:\\n                yield node\\n                yield from it(node.left)\\n                yield from it(node.right)\\n                \\n        for n1, n2 in zip(it(original), it(cloned)):\\n            if n1 == target:\\n                return n2\\n```\n```go\\nfunc getTargetCopy(original, cloned, target *TreeNode) *TreeNode {\\n\\tvar it func(*TreeNode, chan *TreeNode)\\n    it = func(node *TreeNode, ch chan *TreeNode) {\\n\\t\\tif node != nil {\\n\\t\\t\\tch <- node\\n\\t\\t\\tit(node.Left)\\n\\t\\t\\tit(node.Right)\\n\\t\\t}\\n\\t}\\n\\t\\n\\tch1, ch2 := make(chan *TreeNode), make(chan *TreeNode)\\n\\tgo it(original, ch1)\\n\\tgo it(cloned, ch2)\\n\\t\\n\\tfor {\\n\\t\\tn1, n2 := <-ch1, <-ch2\\n\\t\\tif n1 == target {\\n\\t\\t\\treturn n2\\n\\t\\t}\\n\\t}\\n\\treturn nil\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538009,
                "title": "c-minimalizm",
                "content": "Searh in the original tree, navigating in the both original and cloned trees in the same direction.\\n\\n```cpp\\nTreeNode* getTargetCopy(TreeNode* orig, TreeNode* clone, TreeNode* targ) {\\n  return orig == nullptr ? nullptr :\\n    orig == targ ? clone : \\n      getTargetCopy(orig->left, clone->left, targ) ?: getTargetCopy(orig->right, clone->right, targ);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nTreeNode* getTargetCopy(TreeNode* orig, TreeNode* clone, TreeNode* targ) {\\n  return orig == nullptr ? nullptr :\\n    orig == targ ? clone : \\n      getTargetCopy(orig->left, clone->left, targ) ?: getTargetCopy(orig->right, clone->right, targ);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 997851,
                "title": "python-js-java-c-o-n-by-dfs-or-bfs-w-hint",
                "content": "---\\n**Hint**:\\n\\nDescription says cloned tree is a full copy of original one.\\nIn addtion, it also guarantees target node is selected from original tree.\\n\\nThat is, the **topology** for both cloned tree and original tree **is the same**.\\n\\nTherefore, we can develop a paired DFS or BFS traversal algorithm to locate the target by directly [checking identity with is operator](https://docs.python.org/3/reference/expressions.html#is-not) without comparing node.val.\\n\\n---\\n\\n**Implementation** by paired DFS\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        \\n        if not original:\\n            ## base case or stop condition:\\n            # empty node or empty tree\\n            return None\\n        \\n        ## general cases:\\n        if original is target:\\n            \\n            # current original node is target, so is cloned\\n            return cloned\\n        \\n        # either left subtree has target or right subtree has target\\n        return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar getTargetCopy = function(original, cloned, target) {\\n    \\n    if( original == null ){\\n        \\n        // Base case aka stop condition\\n        // empty tree or empty node\\n        return null;\\n    }\\n    \\n    // General cases\\n    if( original == target ){\\n       \\n        // current original node is target, so is cloned\\n        return cloned;\\n    }\\n    \\n    // Either left subtree has target, or right subtree has target\\n    return getTargetCopy(original.left, cloned.left, target) || \\n           getTargetCopy(original.right, cloned.right, target);\\n    \\n};\\n```\\n\\n---\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n\\n        if( original == null ){\\n            // Base case aka stop condition\\n            // empty tree or empty node\\n            return null;\\n        }\\n        \\n        // General case:\\n        if( original == target ){\\n            // current original node is target, so is cloned\\n            return cloned;\\n        }\\n        \\n        // Either left subtree has target, or right subtree has target\\n        TreeNode left =  getTargetCopy(original.left, cloned.left, target);\\n        \\n        if( left != null ){ \\n            return left; \\n        \\n        }else{\\n            return getTargetCopy(original.right, cloned.right, target);\\n        }        \\n        \\n        \\n    }\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        \\n        if( original == NULL ){\\n            // Base case aka stop condition\\n            // empty tree or empty node\\n            return NULL;\\n        }\\n        \\n        // General case:\\n        if( original == target ){\\n            // current original node is target, so is cloned\\n            return cloned;\\n        }\\n        \\n        // Either left subtree has target, or right subtree has target\\n        TreeNode *left =  getTargetCopy(original->left, cloned->left, target);\\n        \\n        if( left != NULL ){ \\n            return left; \\n        \\n        }else{\\n            return getTargetCopy(original->right, cloned->right, target);\\n        }\\n        \\n    }\\n};\\n```\\n\\n\\n---\\n\\nShare another two implementation:\\n\\n**Implementation** by paired DFS:\\n```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        \\n        def helper( node: TreeNode, cloned: TreeNode):\\n            \\n            if node is target:\\n                yield cloned\\n            \\n            if node.left:\\n                yield from helper( node.left, cloned.left )\\n            \\n            if node.right:\\n                yield from helper( node.right, cloned.right )\\n                \\n        # -------------------------------------------------------------------\\n        return next( helper(original, cloned) )\\n```\\n\\n---\\n\\n**Implementation** by paired BFS:\\n```\\nfrom collections import deque\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        \\n        def helper( node: TreeNode, mirror: TreeNode ):\\n            \\n            traversal_queue = deque([node])\\n            mirror_queue = deque([mirror])\\n            \\n            while traversal_queue:\\n                \\n                cur, clone = traversal_queue.pop(), mirror_queue.pop()\\n                \\n                if cur:\\n                    \\n                    if cur is target:\\n                        yield clone\\n                        \\n                    traversal_queue.append( cur.left )\\n                    traversal_queue.append( cur.right )\\n                    \\n                    mirror_queue.append( clone.left )\\n                    mirror_queue.append( clone.right )\\n                    \\n        # -------------------------------------------------------------------\\n        return next( helper(original, cloned ) ) \\n```\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about **is** and **is not** operator](https://docs.python.org/3/reference/expressions.html#is-not)\\n\\n[2] [Python official docs about generator and **yield** statement](https://docs.python.org/3/howto/functional.html#generators)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        \\n        if not original:\\n            ## base case or stop condition:\\n            # empty node or empty tree\\n            return None\\n        \\n        ## general cases:\\n        if original is target:\\n            \\n            # current original node is target, so is cloned\\n            return cloned\\n        \\n        # either left subtree has target or right subtree has target\\n        return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)\\n```\n```\\nvar getTargetCopy = function(original, cloned, target) {\\n    \\n    if( original == null ){\\n        \\n        // Base case aka stop condition\\n        // empty tree or empty node\\n        return null;\\n    }\\n    \\n    // General cases\\n    if( original == target ){\\n       \\n        // current original node is target, so is cloned\\n        return cloned;\\n    }\\n    \\n    // Either left subtree has target, or right subtree has target\\n    return getTargetCopy(original.left, cloned.left, target) || \\n           getTargetCopy(original.right, cloned.right, target);\\n    \\n};\\n```\n```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n\\n        if( original == null ){\\n            // Base case aka stop condition\\n            // empty tree or empty node\\n            return null;\\n        }\\n        \\n        // General case:\\n        if( original == target ){\\n            // current original node is target, so is cloned\\n            return cloned;\\n        }\\n        \\n        // Either left subtree has target, or right subtree has target\\n        TreeNode left =  getTargetCopy(original.left, cloned.left, target);\\n        \\n        if( left != null ){ \\n            return left; \\n        \\n        }else{\\n            return getTargetCopy(original.right, cloned.right, target);\\n        }        \\n        \\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        \\n        if( original == NULL ){\\n            // Base case aka stop condition\\n            // empty tree or empty node\\n            return NULL;\\n        }\\n        \\n        // General case:\\n        if( original == target ){\\n            // current original node is target, so is cloned\\n            return cloned;\\n        }\\n        \\n        // Either left subtree has target, or right subtree has target\\n        TreeNode *left =  getTargetCopy(original->left, cloned->left, target);\\n        \\n        if( left != NULL ){ \\n            return left; \\n        \\n        }else{\\n            return getTargetCopy(original->right, cloned->right, target);\\n        }\\n        \\n    }\\n};\\n```\n```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        \\n        def helper( node: TreeNode, cloned: TreeNode):\\n            \\n            if node is target:\\n                yield cloned\\n            \\n            if node.left:\\n                yield from helper( node.left, cloned.left )\\n            \\n            if node.right:\\n                yield from helper( node.right, cloned.right )\\n                \\n        # -------------------------------------------------------------------\\n        return next( helper(original, cloned) )\\n```\n```\\nfrom collections import deque\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        \\n        def helper( node: TreeNode, mirror: TreeNode ):\\n            \\n            traversal_queue = deque([node])\\n            mirror_queue = deque([mirror])\\n            \\n            while traversal_queue:\\n                \\n                cur, clone = traversal_queue.pop(), mirror_queue.pop()\\n                \\n                if cur:\\n                    \\n                    if cur is target:\\n                        yield clone\\n                        \\n                    traversal_queue.append( cur.left )\\n                    traversal_queue.append( cur.right )\\n                    \\n                    mirror_queue.append( clone.left )\\n                    mirror_queue.append( clone.right )\\n                    \\n        # -------------------------------------------------------------------\\n        return next( helper(original, cloned ) ) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 997816,
                "title": "python-postorder-traversal-explained",
                "content": "Let us find path to our node in `original` tree and write it down to `self.path` list: `0` for left turn and `1` for right turn. Let us use `dfs` function, which returns if given node is in path between root and given `node`.\\n1. We need to stop if we reached `None` node, in this case we return `False`. If we met `node == target`, then we return `True`.\\n2. Visit left and right nodes: `L = dfs(node.left)` and `R = dfs(node.right)`. \\n3. If both of them are `False`, it means we do not need to visit any of them, we do nothing. If one of them is `True` and another is `False`, then we need to choose the one with target. It can not happen, that both of them are `True`.\\n4. Finally, we create empty `self.path`, run our `dfs` and what we will have in the end is path to `target` node, but in reversed order. So, we start with `cloned` node and follow this path.\\n\\n**Complexity**: time complexity is `O(n)` to potentially visit all nodes (I think there is not way to improve it, because we do not have parent links, so we need to find `target` node at least). Space complexity is `O(h)`.\\n\\n```\\nclass Solution:\\n    def getTargetCopy(self, original, cloned, target):\\n        def dfs(node):\\n            if not node: return False\\n            if node == target: return True\\n            L, R = dfs(node.left), dfs(node.right)\\n            if L or R: self.path += [0] if L else [1]\\n            return L or R\\n        \\n        self.path = []\\n        dfs(original)\\n        for i in self.path[::-1]:\\n            cloned = cloned.left if i == 0 else cloned.right\\n        \\n        return cloned\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original, cloned, target):\\n        def dfs(node):\\n            if not node: return False\\n            if node == target: return True\\n            L, R = dfs(node.left), dfs(node.right)\\n            if L or R: self.path += [0] if L else [1]\\n            return L or R\\n        \\n        self.path = []\\n        dfs(original)\\n        for i in self.path[::-1]:\\n            cloned = cloned.left if i == 0 else cloned.right\\n        \\n        return cloned\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046675,
                "title": "c-super-simple-dfs-easy-understanding-solution",
                "content": "**Time Complexity O(n)\\nSpace Complexity O(h), where h is height of binary tree.**\\n\\n```\\nTreeNode* ans;\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) \\n    {\\n        if (cloned == NULL)\\n            return cloned;\\n        if (cloned->val == target->val) // If target node found in cloned tree save it into a variable.\\n            ans = cloned;\\n        getTargetCopy(original, cloned->left, target);\\n        getTargetCopy(original, cloned->right, target);\\n        return ans;\\n    }\\n```\\n\\nHope you like it.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nTreeNode* ans;\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) \\n    {\\n        if (cloned == NULL)\\n            return cloned;\\n        if (cloned->val == target->val) // If target node found in cloned tree save it into a variable.\\n            ans = cloned;\\n        getTargetCopy(original, cloned->left, target);\\n        getTargetCopy(original, cloned->right, target);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 539557,
                "title": "easy-java-solution-with-explanation-beats-100-o-n-time",
                "content": "The idea here is to travese both original and cloned tree together. \\nOnce we found the target node in original tree, return the cloned node. \\nFinding the target node in Tree can be found using DFS or BFS. I use the DFS.\\n\\nTime complexity: O(n) (total nodes in the tree)\\nSpace Complexity: O(h)  (max height of the tree)\\n\\n```\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(original == target || original == null) {\\n            return cloned;\\n        }\\n        \\n        TreeNode oleft = original.left;\\n        TreeNode cleft = cloned.left;\\n        TreeNode left = getTargetCopy(oleft, cleft, target);\\n        if(left != null)   //Found the target node in left subtree.\\n            return left;\\n        \\n\\t\\t//Target node is not in left subtree, then it must be in right subtree.\\n        TreeNode oright = original.right;\\n        TreeNode cright = cloned.right;\\n        TreeNode right = getTargetCopy(oright, cright, target);\\n        \\n        return right;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(original == target || original == null) {\\n            return cloned;\\n        }\\n        \\n        TreeNode oleft = original.left;\\n        TreeNode cleft = cloned.left;\\n        TreeNode left = getTargetCopy(oleft, cleft, target);\\n        if(left != null)   //Found the target node in left subtree.\\n            return left;\\n        \\n\\t\\t//Target node is not in left subtree, then it must be in right subtree.\\n        TreeNode oright = original.right;\\n        TreeNode cright = cloned.right;\\n        TreeNode right = getTargetCopy(oright, cright, target);\\n        \\n        return right;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2046151,
                "title": "python-simple-2-approaches-recursion-3-liner-and-morris",
                "content": "I have implemented two approaches for this problem.\\n1. #### Recursive Preorder \\nThe recursive approach is easier to read and more concise (3 liner). The algorithm is quite straightforward as the second tree in which we need to find the `target` is cloned:\\n1. Start a preoder traversal for both the trees simulataneously. \\n2. If you hit the null nodes, return None\\n3. If `target` matches the first tree\\'s current node, return the current node from the cloned tree. Once a match is found, immediately return to the caller function.\\n\\n\\n```\\nclass Solution:    \\n    def getTargetCopy(self, node1: TreeNode, node2: TreeNode, target: TreeNode) -> TreeNode:        \\n        if not node1 or target == node1:  # if node1 is null, node2 will also be null\\n            return node2\\n        \\n        return self.getTargetCopy(node1.left, node2.left, target) or self.getTargetCopy(node1.right, node2.right, target)        \\n```\\n**Time - O(N)** - Iterate all nodes in tree atleast once\\n**Space - O(N)** - space required for recursive call stack\\n\\n---\\n\\n2. #### Morris Traversal\\n\\nFor this approach, we need to understand the [Morris traversal](https://en.wikipedia.org/wiki/Tree_traversal#Morris_in-order_traversal_using_threading). This approach solves the problem with `O(1) ` space as it uses the concept of threading or connecting the inorder successor of the node. This modifies the tree temporarily for traversal. Due to this modification process, unlike recursive approach, we need to traverse the entire tree even if we have found the match. The whole tree traversal is required to restore the tree to its original state.\\n\\nBelow is my second implementation using Morris traversal. Though it looks ugly compared to Recursive approach, it does the job :)\\n. \\n```\\nclass Solution:    \\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        \\n        curr1=original\\n        curr2=cloned\\n        \\n        found = None\\n        while curr1:\\n            if not curr1.left:\\n                if curr1==target:\\n                    found=curr2\\n                curr1=curr1.right\\n                curr2=curr2.right\\n            else:\\n                temp1 = curr1.left\\n                temp2 = curr2.left\\n                \\n                while temp1.right and temp1.right!=curr1:\\n                    temp1=temp1.right\\n                    temp2=temp2.right\\n                \\n                if temp1.right==curr1:\\n                    temp1.right=None\\n                    temp2.right=None\\n                    if curr1 == target:\\n                        found=curr2\\n                    curr1=curr1.right\\n                    curr2=curr2.right\\n                else:\\n                    temp1.right=curr1\\n                    temp2.right=curr2\\n                    curr1=curr1.left\\n                    curr2=curr2.left\\n        return found\\n```\\n\\n**Time - O(N)** - Iterate all nodes in tree atleast once\\n**Space - O(1)** \\n\\n---\\n\\n***Please upvote if you find it useful***\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:    \\n    def getTargetCopy(self, node1: TreeNode, node2: TreeNode, target: TreeNode) -> TreeNode:        \\n        if not node1 or target == node1:  # if node1 is null, node2 will also be null\\n            return node2\\n        \\n        return self.getTargetCopy(node1.left, node2.left, target) or self.getTargetCopy(node1.right, node2.right, target)        \\n```\n```\\nclass Solution:    \\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        \\n        curr1=original\\n        curr2=cloned\\n        \\n        found = None\\n        while curr1:\\n            if not curr1.left:\\n                if curr1==target:\\n                    found=curr2\\n                curr1=curr1.right\\n                curr2=curr2.right\\n            else:\\n                temp1 = curr1.left\\n                temp2 = curr2.left\\n                \\n                while temp1.right and temp1.right!=curr1:\\n                    temp1=temp1.right\\n                    temp2=temp2.right\\n                \\n                if temp1.right==curr1:\\n                    temp1.right=None\\n                    temp2.right=None\\n                    if curr1 == target:\\n                        found=curr2\\n                    curr1=curr1.right\\n                    curr2=curr2.right\\n                else:\\n                    temp1.right=curr1\\n                    temp2.right=curr2\\n                    curr1=curr1.left\\n                    curr2=curr2.left\\n        return found\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046226,
                "title": "c-dfs",
                "content": "Traverse both trees the same way.\\n\\nWhen the memory address of the original node is equal to the target node,\\n then that node must be the answer.\\n\\n**Solved live on stream.  There are dozens of us, come join every day 6pm-9pm Pacfic Time.  Link in profile**\\n```\\nclass Solution {\\n    \\n    void dfs(TreeNode* og, TreeNode* copy, TreeNode* target, TreeNode*& ans) {\\n        if(!og) return;\\n        \\n        if(og == target) {\\n            ans = copy;\\n        }\\n        \\n        dfs(og->left, copy->left, target, ans);\\n        dfs(og->right, copy->right, target, ans);\\n        \\n        return;\\n    }\\n    \\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        \\n        TreeNode* ans = nullptr;\\n        dfs(original, cloned, target, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    void dfs(TreeNode* og, TreeNode* copy, TreeNode* target, TreeNode*& ans) {\\n        if(!og) return;\\n        \\n        if(og == target) {\\n            ans = copy;\\n        }\\n        \\n        dfs(og->left, copy->left, target, ans);\\n        dfs(og->right, copy->right, target, ans);\\n        \\n        return;\\n    }\\n    \\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        \\n        TreeNode* ans = nullptr;\\n        dfs(original, cloned, target, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046988,
                "title": "python-double-dfs-intuition-easily-explained-with-time-and-space-complexity",
                "content": "The idea is to traverse the tree (in any manner, BFS, DFS or Zigzag).\\n\\nAt first, I thought **Why not directly Iterate over the Cloned Tree**, but sooner when I saw `target of type treenode (not integer)`. Then I realized, that we will need to traverse through both the trees.\\n\\nSee, **If** the **target** would have been **an integer**, then there must be **exactly one node containing the target** integer value (otherwise the question will become ambiguous). If there will be multiple nodes of same value, it will not be possible for us to distinguish which node (having value = Target) is the question actually talking about.\\n\\nSo, **if** the target is an integer value, then it is 100% sure that **the tree contains only unique values**. So, we can easily **apply dfs only on the cloned tree**, and if the node_value = target, then return the node pointer/address.\\n\\nThe code for above kind-of situation is given below: (**NOT working code**)\\n```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: int) -> TreeNode:\\n        def dfs(root):\\n            if not root:\\n                return None\\n            if root.val == target:\\n                return root\\n            left = dfs(root.left)\\n            if left:\\n                return left\\n            right = dfs(root.right)\\n            if right:\\n                return right\\n            return None\\n        return dfs(cloned)\\n```\\n\\nBut...\\n\\nNow as **the target** is a reference to a object of type treenode, it **will contain address**. Also, it is clearly mentioned that **the address is of original tree** not cloned tree.\\n\\n***So How will you get the corresponding address in the cloned tree?***\\n\\nIts simple, as the cloned tree is exactly the copy of origninal tree. So, we can **traverse both the trees parallely**. \\n\\nAs soon as we get that a_`node_in_original_tree == target_node`, we can directly return the address of a cloned tree (as we were also parallely traversing through the cloned tree).\\n\\n**I hope you got the intuition.**\\n\\n\\nThe full code is given below: (***ACTUAL SOLUTION => THE WORKING CODE***)\\n```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        def dfs(root, clone):\\n            if not root:\\n                return None\\n            if root == target:\\n                return clone\\n            l = dfs(root.left, clone.left)\\n            if l:\\n                return l\\n            r = dfs(root.right, clone.right)\\n            if r:\\n                return r\\n            return None\\n        return dfs(original, cloned)\\n```\\n**Time and Space Complexity Analysis:**\\nWe need to go through all the element of both the trees, but we are doing this parallely as the both the tree structures are exactly same. So, if there are \\'n\\' elements/nodes in any one of the tree, then **time complexity = O(n)**.\\n**The Stack Space = O(n)** implicitly created in the stack region of Main Memory by the recursive DFS function calls.\\nApart from the stack space, we have not used any variable length space, and as stack space may not be considered in the complexity, so **space complexity = O(1)**.\\n\\n\\n***Now why not BFS or any other method? Why DFS?***\\nWe could have literally used any of the methods, but in any other method you will need an explicit declaraded variable length space, like queue for BFS having O(n) space. But the stack in DFS is created implicitly through recursive function calls, which may not be considered in some cases, as it was not created explicitly by the programmer. Hence, Space complexity is reduced to O(1) (not actually, just theoritically).\\n\\n**NOTE:** During INTERVIEWS, Its always better to say these kind of space complexities by clearly specifying both ways.\\n* With stack space & output space.\\n* And without stack & output space.\\n\\n**EDIT:** A **simple DFS code** on a tree, printing the DFS node sequences only, **can be seen below**, which we have just modified in our actual solution as per the requirement to traverse two equivalent trees parallely.\\n```\\n        def dfs(root):\\n            if not root:\\n                return None\\n\\t\\t\\tprint(root.val)\\n            dfs(root.left)\\n            dfs(root.right)\\n```\\n\\n\\n***UPVOTE***, If helpful.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: int) -> TreeNode:\\n        def dfs(root):\\n            if not root:\\n                return None\\n            if root.val == target:\\n                return root\\n            left = dfs(root.left)\\n            if left:\\n                return left\\n            right = dfs(root.right)\\n            if right:\\n                return right\\n            return None\\n        return dfs(cloned)\\n```\n```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        def dfs(root, clone):\\n            if not root:\\n                return None\\n            if root == target:\\n                return clone\\n            l = dfs(root.left, clone.left)\\n            if l:\\n                return l\\n            r = dfs(root.right, clone.right)\\n            if r:\\n                return r\\n            return None\\n        return dfs(original, cloned)\\n```\n```\\n        def dfs(root):\\n            if not root:\\n                return None\\n\\t\\t\\tprint(root.val)\\n            dfs(root.left)\\n            dfs(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997895,
                "title": "find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree-java-c",
                "content": "The idea is simple here.  Do a dfs in both the original and the cloned trees at the same time, if we find the node in the original tree, return the node in the cloned tree.\\n\\nNOTE:\\nDon\\'t compare value. Compare the object/pointer.  Otherwise, it will not work when there are duplicate values. \\n\\nC++\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if (original == nullptr) return nullptr;\\n\\t\\t//Don\\'t compare value. Compare the pointer\\n        if (original == target) return cloned;\\n        TreeNode* left = getTargetCopy(original->left, cloned->left, target);\\n\\t\\t// early return if we already find it\\n        if (left != nullptr) return left;\\n        return getTargetCopy(original->right, cloned->right, target);\\n        \\n    }\\n};\\n```\\n\\njava\\n```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original == null) return null;\\n\\t\\t//Don\\'t compare value. Compare the object\\n        if (original == target) return cloned;\\n        TreeNode left = getTargetCopy(original.left, cloned.left, target);\\n\\t\\t// early return if we already find it\\n        if (left != null) return left;\\n        return getTargetCopy(original.right, cloned.right, target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if (original == nullptr) return nullptr;\\n\\t\\t//Don\\'t compare value. Compare the pointer\\n        if (original == target) return cloned;\\n        TreeNode* left = getTargetCopy(original->left, cloned->left, target);\\n\\t\\t// early return if we already find it\\n        if (left != nullptr) return left;\\n        return getTargetCopy(original->right, cloned->right, target);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original == null) return null;\\n\\t\\t//Don\\'t compare value. Compare the object\\n        if (original == target) return cloned;\\n        TreeNode left = getTargetCopy(original.left, cloned.left, target);\\n\\t\\t// early return if we already find it\\n        if (left != null) return left;\\n        return getTargetCopy(original.right, cloned.right, target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046436,
                "title": "java-extremely-easy-solution",
                "content": "```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original == null) return null;\\n        if (original == target)  return cloned;\\n        \\n        TreeNode left = getTargetCopy(original.left, cloned.left, target);\\n        TreeNode right = getTargetCopy(original.right, cloned.right, target);\\n        if (left != null) return left;\\n        return right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original == null) return null;\\n        if (original == target)  return cloned;\\n        \\n        TreeNode left = getTargetCopy(original.left, cloned.left, target);\\n        TreeNode right = getTargetCopy(original.right, cloned.right, target);\\n        if (left != null) return left;\\n        return right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551049,
                "title": "c-simple-no-additional-data-structures-traverse-both-trees-synchronously",
                "content": "```\\nTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n\\tif (original == target) {\\n\\t\\treturn cloned;\\n\\t}\\n\\n\\tif (!original) {\\n\\t\\treturn nullptr;\\n\\t}\\n\\n\\tif (auto left = getTargetCopy(original->left, cloned->left, target)) {\\n\\t\\treturn left;\\n\\t}\\n\\treturn getTargetCopy(original->right, cloned->right, target);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n\\tif (original == target) {\\n\\t\\treturn cloned;\\n\\t}\\n\\n\\tif (!original) {\\n\\t\\treturn nullptr;\\n\\t}\\n\\n\\tif (auto left = getTargetCopy(original->left, cloned->left, target)) {\\n\\t\\treturn left;\\n\\t}\\n\\treturn getTargetCopy(original->right, cloned->right, target);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1312487,
                "title": "c-python-dfs-clean-concise-worked-with-follow-up-questions",
                "content": "**Idea**\\n- DFS parallel on both `original` and `cloned` if the `original == target` return `cloned`. Else find `target` in the left subtree and the right subtree.\\n- Since we compare by the reference between `original` and `target`, not compare by the value. So this solution can work well with follow up questions which is elements in the tree can have duplicate values.\\n\\n**Pyton 3**\\n```python\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        if original == None: return None\\n        if original == target:\\n            return cloned\\n        left = self.getTargetCopy(original.left, cloned.left, target)\\n        if left != None: return left\\n        return self.getTargetCopy(original.right, cloned.right, target)\\n```\\n\\n**C++**\\n```c++\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if (original == nullptr) return nullptr;\\n        if (original == target) return cloned;\\n        TreeNode* left = getTargetCopy(original->left, cloned->left, target);\\n        if (left != nullptr) return left;\\n        return getTargetCopy(original->right, cloned->right, target);\\n    }\\n};\\n```\\n\\n**Complexity**\\n- Time: `O(N)`, where `N` is number of elements in the binary tree. In worst case, we trarverse all elements in the binary tree.\\n- Space: `O(H)`, where `H` is the height of the binary tree.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        if original == None: return None\\n        if original == target:\\n            return cloned\\n        left = self.getTargetCopy(original.left, cloned.left, target)\\n        if left != None: return left\\n        return self.getTargetCopy(original.right, cloned.right, target)\\n```\n```c++\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if (original == nullptr) return nullptr;\\n        if (original == target) return cloned;\\n        TreeNode* left = getTargetCopy(original->left, cloned->left, target);\\n        if (left != nullptr) return left;\\n        return getTargetCopy(original->right, cloned->right, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998549,
                "title": "c-python-the-devil-is-in-the-detail-dfs-stopping-searching-at-desired-node-value",
                "content": "Idea: \\nThe devil is in the details (In Chinese, \\u9B54\\u9B3C\\u85CF\\u5728\\u7EC6\\u8282\\u4E2D)\\n\\nThis question is an easy one. \\nThe point of this essay is to remind of the importance of highlight of detail.\\n\\nTo be specific, if none repated value exists, then approach 2 (comparing node value) is much more desired than approach 1 (comparising node). \\n\\n\\n\\n\\nApproach 1: Pre-order DFS (can handle repeated node value)\\nStopping searching at desired node.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(!original) return NULL;\\n        if(original == target) return cloned;\\n        auto left = getTargetCopy(original->left, cloned->left, target); if(left) return left;\\n        auto right = getTargetCopy(original->right, cloned->right, target);\\n        return right;        \\n    }\\n}; \\n```\\n\\nApproach 2: Pre-order DFS (can not handle repeated node value)\\nStopping searching at desired node value.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        return dfs(cloned, target);\\n    }\\n    \\nprivate:\\n    TreeNode* dfs(TreeNode* cloned, TreeNode* target) {\\n        if(!cloned) return NULL;\\n        if(cloned->val == target->val) return cloned;\\n        auto left = dfs(cloned->left, target);\\n        if(left) return left;\\n        auto right = dfs(cloned->right, target);\\n        return right;\\n    }\\n};\\n```\\n\\nApproach 3: DFS (in Python)\\n```\\nclass Solution(object):\\n    def getTargetCopy(self, original, cloned, target):\\n        \"\"\"\\n        :type original: TreeNode\\n        :type cloned: TreeNode\\n        :type target: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not original: return None\\n        if original == target:return cloned\\n        left = self.getTargetCopy(original.left, cloned.left, target)\\n        if left: return left\\n        right = self.getTargetCopy(original.right, cloned.right, target)\\n        return right\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(!original) return NULL;\\n        if(original == target) return cloned;\\n        auto left = getTargetCopy(original->left, cloned->left, target); if(left) return left;\\n        auto right = getTargetCopy(original->right, cloned->right, target);\\n        return right;        \\n    }\\n}; \\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        return dfs(cloned, target);\\n    }\\n    \\nprivate:\\n    TreeNode* dfs(TreeNode* cloned, TreeNode* target) {\\n        if(!cloned) return NULL;\\n        if(cloned->val == target->val) return cloned;\\n        auto left = dfs(cloned->left, target);\\n        if(left) return left;\\n        auto right = dfs(cloned->right, target);\\n        return right;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def getTargetCopy(self, original, cloned, target):\\n        \"\"\"\\n        :type original: TreeNode\\n        :type cloned: TreeNode\\n        :type target: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        if not original: return None\\n        if original == target:return cloned\\n        left = self.getTargetCopy(original.left, cloned.left, target)\\n        if left: return left\\n        right = self.getTargetCopy(original.right, cloned.right, target)\\n        return right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048592,
                "title": "c-2-approaches-dfs-bfs-explanation-through-comments-o-n-solution",
                "content": "**Please upvote if you find this solution helpful :)**\\n**Approach-1: Use DFS (TC-O(N), SC-O(N))**\\n```\\nclass Solution {\\npublic:\\n    //Use DFS (Pre-order-traversal) \\n\\t//Root-Left-Right approach in the dfs function\\n    void dfs(TreeNode* node, TreeNode* target, TreeNode* &res)\\n    {\\n        if(!node) return; //if node is NULL we return\\n        \\n        if(node->val == target->val)    //if node value is equal to the target value\\n        {\\n            res = node; //we store the node in res and return\\n            return;\\n        }\\n        \\n        dfs(node->left, target, res); //traverse left child of the node\\n        dfs(node->right, target, res);  //traverse right child of the node\\n    }\\n    \\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) \\n    {\\n       \\n        TreeNode* res;   //Define res node for storing result\\n        dfs(cloned, target, res);   //Calling dfs function\\n        return res; \\n    }\\n};\\n```\\n\\n**Approach-2: Use BFS (TC-O(N), SC-O(N))**\\n```\\nclass Solution {\\npublic:\\n    //Use BFS (Level-Order-Traversal)    \\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) \\n    {\\n       \\n        TreeNode* res;   //Define res node for storing result\\n        queue<TreeNode*> q; //and queue of node for storing nodes of the level\\n        \\n        if(cloned)  q.push(cloned); //if node is not null put it into the queue\\n        \\n        //iterate until queue gets empty\\n        while(!q.empty())\\n        {\\n            int size = q.size(); \\n            \\n            //iterate over each level of the tree\\n            for(int i=0; i<size; i++)\\n            {\\n                TreeNode* node = q.front(); q.pop();\\n                \\n                //if node value is equal to the target value store it into the res\\n                if(node->val == target->val)\\n                    res = node;\\n                \\n                //if left is not null, store it into the queue\\n                if(node->left) q.push(node->left);\\n                \\n                //if right is not null, store it into the queue\\n                if(node->right) q.push(node->right);\\n            }\\n        }\\n      \\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Use DFS (Pre-order-traversal) \\n\\t//Root-Left-Right approach in the dfs function\\n    void dfs(TreeNode* node, TreeNode* target, TreeNode* &res)\\n    {\\n        if(!node) return; //if node is NULL we return\\n        \\n        if(node->val == target->val)    //if node value is equal to the target value\\n        {\\n            res = node; //we store the node in res and return\\n            return;\\n        }\\n        \\n        dfs(node->left, target, res); //traverse left child of the node\\n        dfs(node->right, target, res);  //traverse right child of the node\\n    }\\n    \\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) \\n    {\\n       \\n        TreeNode* res;   //Define res node for storing result\\n        dfs(cloned, target, res);   //Calling dfs function\\n        return res; \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    //Use BFS (Level-Order-Traversal)    \\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) \\n    {\\n       \\n        TreeNode* res;   //Define res node for storing result\\n        queue<TreeNode*> q; //and queue of node for storing nodes of the level\\n        \\n        if(cloned)  q.push(cloned); //if node is not null put it into the queue\\n        \\n        //iterate until queue gets empty\\n        while(!q.empty())\\n        {\\n            int size = q.size(); \\n            \\n            //iterate over each level of the tree\\n            for(int i=0; i<size; i++)\\n            {\\n                TreeNode* node = q.front(); q.pop();\\n                \\n                //if node value is equal to the target value store it into the res\\n                if(node->val == target->val)\\n                    res = node;\\n                \\n                //if left is not null, store it into the queue\\n                if(node->left) q.push(node->left);\\n                \\n                //if right is not null, store it into the queue\\n                if(node->right) q.push(node->right);\\n            }\\n        }\\n      \\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048567,
                "title": "c-easy-recursion-simple-daily-leetcoding-challenge-may-day-17",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* ans;\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) \\n    {\\n        // if my cloned tree is null then return NULL\\n        // because we can not find our target in NULL tree\\n        if(cloned==NULL)\\n            return NULL;\\n        \\n        // at any point of time , if my clones tree node value is equal to target then store it into our ans\\n        // Node found\\n        if(cloned->val == target->val)  \\n            ans = cloned;\\n        \\n        // going to left for cheking our target\\n        getTargetCopy(original,cloned->left,target);\\n        \\n        // going to right for checking our target\\n        getTargetCopy(original,cloned->right,target);\\n        \\n        // at the end return our stored ans\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* ans;\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) \\n    {\\n        // if my cloned tree is null then return NULL\\n        // because we can not find our target in NULL tree\\n        if(cloned==NULL)\\n            return NULL;\\n        \\n        // at any point of time , if my clones tree node value is equal to target then store it into our ans\\n        // Node found\\n        if(cloned->val == target->val)  \\n            ans = cloned;\\n        \\n        // going to left for cheking our target\\n        getTargetCopy(original,cloned->left,target);\\n        \\n        // going to right for checking our target\\n        getTargetCopy(original,cloned->right,target);\\n        \\n        // at the end return our stored ans\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998841,
                "title": "javascript-clean-dfs-and-bfs-solutions",
                "content": "# Solution-1: DFS\\n```\\nvar getTargetCopy = function(original, cloned, target) {\\n    \\n    function traverse(oNode, cNode) {\\n        if(!oNode) return;\\n        if(oNode === target) return cNode;\\n        return traverse(oNode.left, cNode.left) || traverse(oNode.right, cNode.right);\\n    }\\n    return traverse(original, cloned);\\n};\\n```\\n\\n# Solution-2: BFS\\n```\\nvar getTargetCopy = function(original, cloned, target) {\\n    \\n    let queue = [[original, cloned]];\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        for(let [oNode, cNode] of queue) {\\n            if(oNode === target) return cNode;\\n            if(oNode.left) next.push([oNode.left, cNode.left]);\\n            if(oNode.right) next.push([oNode.right, cNode.right]);\\n        }\\n        queue = next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar getTargetCopy = function(original, cloned, target) {\\n    \\n    function traverse(oNode, cNode) {\\n        if(!oNode) return;\\n        if(oNode === target) return cNode;\\n        return traverse(oNode.left, cNode.left) || traverse(oNode.right, cNode.right);\\n    }\\n    return traverse(original, cloned);\\n};\\n```\n```\\nvar getTargetCopy = function(original, cloned, target) {\\n    \\n    let queue = [[original, cloned]];\\n    \\n    while(queue.length) {\\n        const next = [];\\n        \\n        for(let [oNode, cNode] of queue) {\\n            if(oNode === target) return cNode;\\n            if(oNode.left) next.push([oNode.left, cNode.left]);\\n            if(oNode.right) next.push([oNode.right, cNode.right]);\\n        }\\n        queue = next;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 998426,
                "title": "c-super-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* o_root, TreeNode* c_root, TreeNode* target) {\\n        if (o_root) {\\n            inOrder(o_root->left, c_root->left, target);\\n            if (o_root == target) {\\n\\t\\t\\t\\t ans = c_root;\\n\\t\\t\\t\\t return;\\n\\t\\t\\t}\\n            inOrder(o_root->right, c_root->right, target);\\n        }\\n    }\\n\\t\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        inOrder(original, cloned, target);\\n        return ans;\\n    }\\nprivate:\\n    TreeNode* ans;\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inOrder(TreeNode* o_root, TreeNode* c_root, TreeNode* target) {\\n        if (o_root) {\\n            inOrder(o_root->left, c_root->left, target);\\n            if (o_root == target) {\\n\\t\\t\\t\\t ans = c_root;\\n\\t\\t\\t\\t return;\\n\\t\\t\\t}\\n            inOrder(o_root->right, c_root->right, target);\\n        }\\n    }\\n\\t\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        inOrder(original, cloned, target);\\n        return ans;\\n    }\\nprivate:\\n    TreeNode* ans;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882487,
                "title": "python-solution-with-explanation-faster-than-91",
                "content": "```\\nclass Solution(object):\\n    def getTargetCopy(self, original, cloned, target):\\n        \"\"\"\\n        :type original: TreeNode\\n        :type cloned: TreeNode\\n        :type target: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\'\\'\\'\\n        Idea : Traverse throughout both tree together\\n            - Check if you came accross a node in orginal tree equal to the target\\n                - If yes, since they are cloned, just return the curent node of the cloned tree \\n        \\'\\'\\'\\n        if not original or not cloned:\\n            return None\\n        stack = []\\n        stack.append((original,cloned))\\n        while stack:\\n            org, clone = stack.pop()\\n            \\n            if org == target:       # check if we reach to the target node at the orginal tree\\n                return clone\\n            # Traversing together \\n            if org.left:\\n                stack.append((org.left, clone.left))\\n            if org.right:\\n                stack.append((org.right, clone.right))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def getTargetCopy(self, original, cloned, target):\\n        \"\"\"\\n        :type original: TreeNode\\n        :type cloned: TreeNode\\n        :type target: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        \\'\\'\\'\\n        Idea : Traverse throughout both tree together\\n            - Check if you came accross a node in orginal tree equal to the target\\n                - If yes, since they are cloned, just return the curent node of the cloned tree \\n        \\'\\'\\'\\n        if not original or not cloned:\\n            return None\\n        stack = []\\n        stack.append((original,cloned))\\n        while stack:\\n            org, clone = stack.pop()\\n            \\n            if org == target:       # check if we reach to the target node at the orginal tree\\n                return clone\\n            # Traversing together \\n            if org.left:\\n                stack.append((org.left, clone.left))\\n            if org.right:\\n                stack.append((org.right, clone.right))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046277,
                "title": "python-dfs-few-lines",
                "content": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        \\n        if original is None:\\n            return \\n        elif original == target:\\n            return cloned\\n        else:\\n            return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        \\n        if original is None:\\n            return \\n        elif original == target:\\n            return cloned\\n        else:\\n            return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 540602,
                "title": "python-follow-up",
                "content": "Traverse the original with DFS until you find the target and save the path in a variable.\\nWalk the path in cloned and return the path end. The traverse() function walks through original until target is found. As traverse is using depth first search it saves the path in reverse order because of the program\\'s stack. We store True if we have to go to the left and False if we have to go to the right. After we have the path to the target node with True/False (left/right) values - we walk the same path in the cloned tree and return the last node in the path\\n```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        path = []\\n        def traverse(x):\\n            if not x: \\n                return False\\n            if x is target:\\n                return True\\n            if traverse(x.left):\\n                path.append(True)\\n                return True\\n            if traverse(x.right):\\n                path.append(False)\\n                return True\\n            return False\\n\\n        traverse(original)\\n        pointer = cloned\\n        for x in reversed(path):\\n            if x:\\n                pointer = pointer.left\\n            else:\\n                pointer = pointer.right\\n        return pointer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        path = []\\n        def traverse(x):\\n            if not x: \\n                return False\\n            if x is target:\\n                return True\\n            if traverse(x.left):\\n                path.append(True)\\n                return True\\n            if traverse(x.right):\\n                path.append(False)\\n                return True\\n            return False\\n\\n        traverse(original)\\n        pointer = cloned\\n        for x in reversed(path):\\n            if x:\\n                pointer = pointer.left\\n            else:\\n                pointer = pointer.right\\n        return pointer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574046,
                "title": "java-easy-solution-with-explanation",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        // check if treenode is null\\n        if (original==null){\\n            return original;\\n        }\\n        // intiate a queue for storing nodes\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        // add the root to the queue\\n        q.add(cloned);\\n        // while to iterate till last node\\n        while(!q.isEmpty()){\\n            // take out the first node from the stack \\n            TreeNode temp = q.poll();\\n            // check if it satifies the condition\\n            if(temp.val==target.val){\\n                return temp;\\n            }\\n            // if condition does not satifies add its child nodes to the queue\\n            if(temp.left!=null){\\n                q.add(temp.left);\\n            }\\n            if(temp.right!=null){\\n                q.add(temp.right);\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```\\n# upvote if u found it useful",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        // check if treenode is null\\n        if (original==null){\\n            return original;\\n        }\\n        // intiate a queue for storing nodes\\n        Queue<TreeNode> q = new LinkedList<TreeNode>();\\n        // add the root to the queue\\n        q.add(cloned);\\n        // while to iterate till last node\\n        while(!q.isEmpty()){\\n            // take out the first node from the stack \\n            TreeNode temp = q.poll();\\n            // check if it satifies the condition\\n            if(temp.val==target.val){\\n                return temp;\\n            }\\n            // if condition does not satifies add its child nodes to the queue\\n            if(temp.left!=null){\\n                q.add(temp.left);\\n            }\\n            if(temp.right!=null){\\n                q.add(temp.right);\\n            }\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047443,
                "title": "very-concise-recursive-solution",
                "content": "```csharp\\npublic TreeNode GetTargetCopy(TreeNode a, TreeNode b, TreeNode x)\\n{\\n\\tif (a is null) return a;\\n\\tif (a == x) return b;\\n\\treturn GetTargetCopy(a.left, b.left, x) ?? GetTargetCopy(a.right, b.right, x);\\n}\\n```\\n\\nAlternatively, just for fun, you can write it all on one line:\\n```csharp\\npublic TreeNode GetTargetCopy(TreeNode a, TreeNode b, TreeNode x) => a is null ? a : a == x ? b : GetTargetCopy(a.left, b.left, x) ?? GetTargetCopy(a.right, b.right, x);\\n```",
                "solutionTags": [
                    "C#",
                    "Recursion"
                ],
                "code": "```csharp\\npublic TreeNode GetTargetCopy(TreeNode a, TreeNode b, TreeNode x)\\n{\\n\\tif (a is null) return a;\\n\\tif (a == x) return b;\\n\\treturn GetTargetCopy(a.left, b.left, x) ?? GetTargetCopy(a.right, b.right, x);\\n}\\n```\n```csharp\\npublic TreeNode GetTargetCopy(TreeNode a, TreeNode b, TreeNode x) => a is null ? a : a == x ? b : GetTargetCopy(a.left, b.left, x) ?? GetTargetCopy(a.right, b.right, x);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1001866,
                "title": "python3-iterative-preorder-dfs",
                "content": "**Algo**\\nTraverse the two trees at the same time. Once `target` is found on `original`, return the corresponding node on `cloned`. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        stack = [(original, cloned)]\\n        while stack: \\n            x, y = stack.pop()\\n            if x == target: return y\\n            if x:\\n                stack.append((x.left, y.left))\\n                stack.append((x.right, y.right))\\n```\\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(N)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        stack = [(original, cloned)]\\n        while stack: \\n            x, y = stack.pop()\\n            if x == target: return y\\n            if x:\\n                stack.append((x.left, y.left))\\n                stack.append((x.right, y.right))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998011,
                "title": "corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree-c-level-order-traversal",
                "content": "```\\nTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) \\n{\\n  if(!original)\\n    return original;\\n  \\n  TreeNode *v1,*v2;\\n  queue<TreeNode*>q1,q2;\\n   \\n  q1.push(original);\\n  q2.push(cloned);\\n  \\n  while(!q1.empty())\\n  {\\n     v1=q1.front();\\n     v2=q2.front();\\n     q1.pop();\\n     q2.pop();\\n    \\n     if(v1==target)\\n     break;\\n    \\n    if(v1->left)\\n      q1.push(v1->left);\\n    if(v1->right)\\n      q1.push(v1->right);\\n    if(v2->left)\\n      q2.push(v2->left);\\n    if(v2->right)\\n      q2.push(v2->right);\\n  }\\n  \\n  return v2;\\n   \\n}\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) \\n{\\n  if(!original)\\n    return original;\\n  \\n  TreeNode *v1,*v2;\\n  queue<TreeNode*>q1,q2;\\n   \\n  q1.push(original);\\n  q2.push(cloned);\\n  \\n  while(!q1.empty())\\n  {\\n     v1=q1.front();\\n     v2=q2.front();\\n     q1.pop();\\n     q2.pop();\\n    \\n     if(v1==target)\\n     break;\\n    \\n    if(v1->left)\\n      q1.push(v1->left);\\n    if(v1->right)\\n      q1.push(v1->right);\\n    if(v2->left)\\n      q2.push(v2->left);\\n    if(v2->right)\\n      q2.push(v2->right);\\n  }\\n  \\n  return v2;\\n   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 689078,
                "title": "javascript-iterative-bfs-solution-with-followup",
                "content": "The follow up asks for the problem to be solved if repeated values on the tree are allowed, this means that checking if the cloned.val === the target.val is no longer sufficient. \\nWhat I am doing here is navigating the original tree with a breadth first search in order to find the target node, and maintaining those same steps on the cloned tree. That way when we find the exact target node, we can return the current node of the cloned tree with confidence. \\n\\n\\n```\\nvar getTargetCopy = function(original, cloned, target) {\\n    \\n    let queue = [original];\\n    let cloneQueue = [cloned];\\n    \\n    while(queue.length > 0) {\\n        let len = queue.length;\\n        for(let i=0; i<len; i++) {\\n            let node = queue.shift();\\n            let cloneNode = cloneQueue.shift();\\n                       \\n            if(node == target) {\\n                return cloneNode;\\n            }\\n            \\n            if(node.left) {\\n                queue.push(node.left);\\n                cloneQueue.push(cloneNode.left);\\n            }\\n            \\n            if(node.right) {\\n                queue.push(node.right);\\n                cloneQueue.push(cloneNode.right);\\n            }\\n            \\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar getTargetCopy = function(original, cloned, target) {\\n    \\n    let queue = [original];\\n    let cloneQueue = [cloned];\\n    \\n    while(queue.length > 0) {\\n        let len = queue.length;\\n        for(let i=0; i<len; i++) {\\n            let node = queue.shift();\\n            let cloneNode = cloneQueue.shift();\\n                       \\n            if(node == target) {\\n                return cloneNode;\\n            }\\n            \\n            if(node.left) {\\n                queue.push(node.left);\\n                cloneQueue.push(cloneNode.left);\\n            }\\n            \\n            if(node.right) {\\n                queue.push(node.right);\\n                cloneQueue.push(cloneNode.right);\\n            }\\n            \\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 584323,
                "title": "100-00-fast-in-run-time-and-memory-iterative-recursive-dfs-bfs-lambda",
                "content": "---------------------\\n**null coalescing operator:**\\n**?:** This is an equivalent of the null coalescence operator, but it is only supported in GCC. So I won\\'t use it in the production code just yet.\\n\\nThe nulll coalescing operator is **?:**. It can be used to provide a default for null references:  **value =valueThatMightBeNil ?: valueIfNil;**\\nThis is the same as writing-\\n**value = valueThatMightBeNil ? valueThatMightBeNil : valueIfNil;**\\n\\nReference: https://en.wikipedia.org/wiki/Null_coalescing_operator\\n```\\nclass Solution { // using null coalescing operator\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        return (original==nullptr)? nullptr :\\n        (original==target)? cloned : \\n        getTargetCopy(original->left,cloned->left,target) ?: getTargetCopy(original->right,cloned->right,target);\\n    }\\n};\\n```\\n\\n--------------\\n**DFS:**\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* original, TreeNode* cloned, TreeNode* target, TreeNode* &resultNode){\\n        if(!original || resultNode) return;\\n        if(original==target) resultNode = cloned;\\n        if(original->left) dfs(original->left,cloned->left,target,resultNode);\\n        if(original->right) dfs(original->right,cloned->right,target,resultNode);\\n    }\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        TreeNode* resultNode(nullptr);\\n        dfs(original,cloned,target,resultNode);\\n        return resultNode;\\n    }\\n};\\n\\n```\\n\\n------------\\n**Recursive: DFS**\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(!original)\\n            return nullptr;\\n        if(original==target)\\n            return cloned;\\n        TreeNode* left = getTargetCopy(original->left,cloned->left,target);\\n        if(left)\\n            return left;\\n        return getTargetCopy(original->right,cloned->right,target);\\n    }\\n};\\n```\\n\\n---------\\n**Iterative: BFS**\\n\\n```\\nclass Solution { // bfs - Level Order\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(!original) return nullptr;\\n        \\n        queue<TreeNode*> toDo1,toDo2;\\n        toDo1.push(original);\\n        toDo2.push(cloned);\\n        \\n        while(!toDo1.empty()){\\n            if(toDo1.front()==target) return toDo2.front();\\n            if(toDo1.front()->left){\\n                toDo1.push(toDo1.front()->left);\\n                toDo2.push(toDo2.front()->left);\\n            }\\n            if(toDo1.front()->right){\\n                toDo1.push(toDo1.front()->right);\\n                toDo2.push(toDo2.front()->right);\\n            }\\n            toDo1.pop();\\n            toDo2.pop();\\n        }\\n        return nullptr;\\n    }\\n}; \\n```\\n\\n-------\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        // check if the parameters are correct\\n        if(!original || !cloned || !target) return nullptr;\\n        \\n        // check if the target is at the root of the original\\n        if(original==target) return cloned;\\n        \\n        queue<TreeNode*> q,clonedQ;\\n        q.push(original);\\n        clonedQ.push(cloned);\\n        \\n        auto process_node = [&q,&clonedQ,target](TreeNode* node, TreeNode* cloned){\\n            if(!node) return false;\\n            q.push(node);\\n            clonedQ.push(cloned);\\n            return (node==target);\\n        };\\n        \\n        bool found(false);\\n        \\n        // apply bfs\\n        while(!found && !q.empty()){\\n            int size(q.size());\\n            while(!found && size>0){\\n                TreeNode* node(q.front());\\n                TreeNode* nodeCloned(clonedQ.front());\\n                q.pop();\\n                clonedQ.pop();\\n                found = process_node(node->left,nodeCloned->left) || process_node(node->right,nodeCloned->right);\\n            }\\n        }\\n        return clonedQ.back();\\n    }\\n};\\n```\\n\\n**Extra: Using lambda**\\nhttps://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/discuss/577243/C%2B%2B-solution\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution { // using null coalescing operator\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        return (original==nullptr)? nullptr :\\n        (original==target)? cloned : \\n        getTargetCopy(original->left,cloned->left,target) ?: getTargetCopy(original->right,cloned->right,target);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* original, TreeNode* cloned, TreeNode* target, TreeNode* &resultNode){\\n        if(!original || resultNode) return;\\n        if(original==target) resultNode = cloned;\\n        if(original->left) dfs(original->left,cloned->left,target,resultNode);\\n        if(original->right) dfs(original->right,cloned->right,target,resultNode);\\n    }\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        TreeNode* resultNode(nullptr);\\n        dfs(original,cloned,target,resultNode);\\n        return resultNode;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(!original)\\n            return nullptr;\\n        if(original==target)\\n            return cloned;\\n        TreeNode* left = getTargetCopy(original->left,cloned->left,target);\\n        if(left)\\n            return left;\\n        return getTargetCopy(original->right,cloned->right,target);\\n    }\\n};\\n```\n```\\nclass Solution { // bfs - Level Order\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(!original) return nullptr;\\n        \\n        queue<TreeNode*> toDo1,toDo2;\\n        toDo1.push(original);\\n        toDo2.push(cloned);\\n        \\n        while(!toDo1.empty()){\\n            if(toDo1.front()==target) return toDo2.front();\\n            if(toDo1.front()->left){\\n                toDo1.push(toDo1.front()->left);\\n                toDo2.push(toDo2.front()->left);\\n            }\\n            if(toDo1.front()->right){\\n                toDo1.push(toDo1.front()->right);\\n                toDo2.push(toDo2.front()->right);\\n            }\\n            toDo1.pop();\\n            toDo2.pop();\\n        }\\n        return nullptr;\\n    }\\n}; \\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        // check if the parameters are correct\\n        if(!original || !cloned || !target) return nullptr;\\n        \\n        // check if the target is at the root of the original\\n        if(original==target) return cloned;\\n        \\n        queue<TreeNode*> q,clonedQ;\\n        q.push(original);\\n        clonedQ.push(cloned);\\n        \\n        auto process_node = [&q,&clonedQ,target](TreeNode* node, TreeNode* cloned){\\n            if(!node) return false;\\n            q.push(node);\\n            clonedQ.push(cloned);\\n            return (node==target);\\n        };\\n        \\n        bool found(false);\\n        \\n        // apply bfs\\n        while(!found && !q.empty()){\\n            int size(q.size());\\n            while(!found && size>0){\\n                TreeNode* node(q.front());\\n                TreeNode* nodeCloned(clonedQ.front());\\n                q.pop();\\n                clonedQ.pop();\\n                found = process_node(node->left,nodeCloned->left) || process_node(node->right,nodeCloned->right);\\n            }\\n        }\\n        return clonedQ.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 567916,
                "title": "js-very-simple-solution-faster-memory-efficient",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} original\\n * @param {TreeNode} cloned\\n * @param {TreeNode} target\\n * @return {TreeNode}\\n */\\n\\nvar getTargetCopy = function(original, cloned, target) {\\n    if (!cloned) {\\n        return null;\\n    }\\n    \\n    if (cloned.val === target.val) {\\n        return cloned;\\n    }\\n    \\n    return getTargetCopy(original, cloned.left, target) || getTargetCopy(original, cloned.right, target);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} original\\n * @param {TreeNode} cloned\\n * @param {TreeNode} target\\n * @return {TreeNode}\\n */\\n\\nvar getTargetCopy = function(original, cloned, target) {\\n    if (!cloned) {\\n        return null;\\n    }\\n    \\n    if (cloned.val === target.val) {\\n        return cloned;\\n    }\\n    \\n    return getTargetCopy(original, cloned.left, target) || getTargetCopy(original, cloned.right, target);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3191531,
                "title": "python-3-dfs",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach taken is to use a stack to perform an iterative depth-first search (DFS) of the binary trees. The stack initially contains a tuple of the root nodes of both the original and cloned trees. The while loop runs as long as there are tuples in the stack, and for each tuple that is popped off the stack, the corresponding nodes in the original and cloned trees are compared to the target node. If the original node matches the target, then the corresponding node in the cloned tree is returned. Otherwise, if the original node has left and/or right children, then tuples of the corresponding nodes are added to the stack.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        stack = [(original, cloned)]\\n        \\n        while stack:\\n            node1, node2 = stack.pop()\\n            \\n            if node1 == target:\\n                return node2\\n            \\n            if node1.left:\\n                stack.append((node1.left, node2.left))\\n                \\n            if node1.right:\\n                stack.append((node1.right, node2.right))\\n        \\n        return None\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        stack = [(original, cloned)]\\n        \\n        while stack:\\n            node1, node2 = stack.pop()\\n            \\n            if node1 == target:\\n                return node2\\n            \\n            if node1.left:\\n                stack.append((node1.left, node2.left))\\n                \\n            if node1.right:\\n                stack.append((node1.right, node2.right))\\n        \\n        return None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2987647,
                "title": "c-dfs-easy-straightforward-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/5150a06e-6de5-4772-a942-dd875be7e179_1672677995.0244467.png)\\n\\n**T->O(Number of Nodes) [Worst Case Complexity] && S->O(Height of the Tree) [Worst Case Complexity]**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t//     DFS -> PreOrder Traversal\\n\\t\\t\\tTreeNode* dfs(TreeNode* curr,int val){\\n\\t\\t\\t\\tif(!curr) return NULL;        \\n\\t\\t\\t\\tif(curr->val == val) return curr;\\n\\t\\t\\t\\tTreeNode* l = dfs(curr->left,val);\\n\\t\\t\\t\\tif(l) return l ;\\n\\t\\t\\t\\tTreeNode* r = dfs(curr->right,val);\\n\\t\\t\\t\\tif(r) return r;\\n\\t\\t\\t\\treturn NULL;\\n\\t\\t\\t}\\n\\n\\t\\t\\tTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n\\t\\t\\t\\tint val = target->val;\\n\\t\\t\\t\\treturn dfs(cloned,val);\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t//     DFS -> PreOrder Traversal\\n\\t\\t\\tTreeNode* dfs(TreeNode* curr,int val){\\n\\t\\t\\t\\tif(!curr) return NULL;        \\n\\t\\t\\t\\tif(curr->val == val) return curr;\\n\\t\\t\\t\\tTreeNode* l = dfs(curr->left,val);\\n\\t\\t\\t\\tif(l) return l ;\\n\\t\\t\\t\\tTreeNode* r = dfs(curr->right,val);\\n\\t\\t\\t\\tif(r) return r;\\n\\t\\t\\t\\treturn NULL;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2102673,
                "title": "c-simple-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(cloned==NULL || original==target) return cloned;\\n        TreeNode* a = getTargetCopy(original->left, cloned->left, target);\\n        TreeNode* b = getTargetCopy(original->right, cloned->right, target);\\n        return a!=NULL?a:b!=NULL?b:NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(cloned==NULL || original==target) return cloned;\\n        TreeNode* a = getTargetCopy(original->left, cloned->left, target);\\n        TreeNode* b = getTargetCopy(original->right, cloned->right, target);\\n        return a!=NULL?a:b!=NULL?b:NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046541,
                "title": "c-easiest-solution",
                "content": "* Recursive dfs\\n* Self explanatory code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        \\n        if(!original)\\n            return NULL;\\n        \\n        if(original == target)\\n            return cloned;\\n        \\n        TreeNode* Lt = getTargetCopy(original -> left, cloned -> left, target);\\n        \\n        if(Lt)\\n            return Lt;\\n        \\n        return getTargetCopy(original -> right, cloned -> right, target);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        \\n        if(!original)\\n            return NULL;\\n        \\n        if(original == target)\\n            return cloned;\\n        \\n        TreeNode* Lt = getTargetCopy(original -> left, cloned -> left, target);\\n        \\n        if(Lt)\\n            return Lt;\\n        \\n        return getTargetCopy(original -> right, cloned -> right, target);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046526,
                "title": "c-binary-tree-dfs-recursion",
                "content": "# C++ Code:\\n```\\nclass Solution {\\npublic:\\n    //first find the target node in the original tree and if found, return that node from cloned tree\\n    \\n    //using inorder traversal Node->left->right\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        //base case\\n        if(original == NULL)\\n            return NULL;\\n        \\n        if(original->val == target->val)\\n            return cloned; //return reference from cloned tree\\n        \\n        //call on left and then right\\n        TreeNode* left= getTargetCopy(original->left,cloned->left,target);\\n        \\n        TreeNode* right= getTargetCopy(original->right,cloned->right,target);\\n        \\n        if(left) return left;\\n        \\n        //else\\n        return right;\\n        \\n    }\\n};\\n```\\n**Do Upvote, If you find this helpful!**\\nHappy coding  !!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //first find the target node in the original tree and if found, return that node from cloned tree\\n    \\n    //using inorder traversal Node->left->right\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        //base case\\n        if(original == NULL)\\n            return NULL;\\n        \\n        if(original->val == target->val)\\n            return cloned; //return reference from cloned tree\\n        \\n        //call on left and then right\\n        TreeNode* left= getTargetCopy(original->left,cloned->left,target);\\n        \\n        TreeNode* right= getTargetCopy(original->right,cloned->right,target);\\n        \\n        if(left) return left;\\n        \\n        //else\\n        return right;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 697626,
                "title": "java-solution-incl-follow-up",
                "content": "```Java\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n\\tif(original == null) return null;\\n\\tif(original == target) return cloned;\\n\\n\\tTreeNode left = getTargetCopy(original.left, cloned.left, target);\\n\\tif(left == null){\\n\\t\\treturn getTargetCopy(original.right, cloned.right, target);\\n\\t}else{\\n\\t\\treturn left;    \\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n\\tif(original == null) return null;\\n\\tif(original == target) return cloned;\\n\\n\\tTreeNode left = getTargetCopy(original.left, cloned.left, target);\\n\\tif(left == null){\\n\\t\\treturn getTargetCopy(original.right, cloned.right, target);\\n\\t}else{\\n\\t\\treturn left;    \\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 681358,
                "title": "java-iterative",
                "content": "```\\npublic final TreeNode getTargetCopy(final TreeNode orig, final TreeNode clone, final TreeNode t) {\\n        TreeNode m = orig, n = clone;\\n        Stack<TreeNode> a = new Stack<>(), b = new Stack<>();\\n        while (m != null || !a.isEmpty()) {\\n            while (m != null) {\\n                a.push(m);\\n                m = m.left;\\n                b.push(n);\\n                n = n.left;\\n            }\\n            m = a.pop();\\n            n = b.pop();\\n            if (m.equals(t)) return n;\\n            m = m.right;\\n            n = n.right;\\n        }\\n        return null;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic final TreeNode getTargetCopy(final TreeNode orig, final TreeNode clone, final TreeNode t) {\\n        TreeNode m = orig, n = clone;\\n        Stack<TreeNode> a = new Stack<>(), b = new Stack<>();\\n        while (m != null || !a.isEmpty()) {\\n            while (m != null) {\\n                a.push(m);\\n                m = m.left;\\n                b.push(n);\\n                n = n.left;\\n            }\\n            m = a.pop();\\n            n = b.pop();\\n            if (m.equals(t)) return n;\\n            m = m.right;\\n            n = n.right;\\n        }\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3447816,
                "title": "notmy-gettargetcopy",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} original\\n * @param {TreeNode} cloned\\n * @param {TreeNode} target\\n * @return {TreeNode}\\n */\\n\\nvar getTargetCopy = function (original, cloned, target) {\\n  if (original === null) return null;\\n  if (original === target) return cloned;\\n  return (\\n    getTargetCopy(original.left, cloned.left, target) ||\\n    getTargetCopy(original.right, cloned.right, target)\\n  );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} original\\n * @param {TreeNode} cloned\\n * @param {TreeNode} target\\n * @return {TreeNode}\\n */\\n\\nvar getTargetCopy = function (original, cloned, target) {\\n  if (original === null) return null;\\n  if (original === target) return cloned;\\n  return (\\n    getTargetCopy(original.left, cloned.left, target) ||\\n    getTargetCopy(original.right, cloned.right, target)\\n  );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081482,
                "title": "c-easy-sol-with-explanation",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n       if(!cloned || !original){\\n           return NULL;\\n       }\\n        if(original==target)\\n\\t\\t{\\n\\t\\treturn cloned;\\n\\t\\t} // or we can do if(cloned->val==target->val) but its of no use because there is no duplicate  value so its nt necessary to compare values. we can simply compare the nodes.\\n             // return cloned;\\n        }\\n        TreeNode* lef= getTargetCopy(original->left, cloned->left, target);\\n//         Note: we will iterate through original  & cloned simultaneously to avoid encountring duplicate value. eg: if i have 5. 2 times in a tree and we dont know which 5 I have to return and if it matches exactly in the clone\\'s node position.\\n        if(lef){\\n            return lef;\\n        }\\n        return getTargetCopy(original->right, cloned->right, target);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n       if(!cloned || !original){\\n           return NULL;\\n       }\\n        if(original==target)\\n\\t\\t{\\n\\t\\treturn cloned;\\n\\t\\t} // or we can do if(cloned->val==target->val) but its of no use because there is no duplicate  value so its nt necessary to compare values. we can simply compare the nodes.\\n             // return cloned;\\n        }\\n        TreeNode* lef= getTargetCopy(original->left, cloned->left, target);\\n//         Note: we will iterate through original  & cloned simultaneously to avoid encountring duplicate value. eg: if i have 5. 2 times in a tree and we dont know which 5 I have to return and if it matches exactly in the clone\\'s node position.\\n        if(lef){\\n            return lef;\\n        }\\n        return getTargetCopy(original->right, cloned->right, target);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047764,
                "title": "c-preorder-traversal-o-n-dlc-may17",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* ans;\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(cloned== NULL)\\n            return NULL;\\n        if(cloned->val == target->val)  //Node found\\n            ans = cloned;\\n        \\n        //check in the left\\n        getTargetCopy(original, cloned->left, target);\\n        //check in the right\\n        getTargetCopy(original, cloned->right, target);\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* ans;\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(cloned== NULL)\\n            return NULL;\\n        if(cloned->val == target->val)  //Node found\\n            ans = cloned;\\n        \\n        //check in the left\\n        getTargetCopy(original, cloned->left, target);\\n        //check in the right\\n        getTargetCopy(original, cloned->right, target);\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047392,
                "title": "python3-bfs-99-27-time-and-94-29-memory-efficient",
                "content": "\\n#       Runtime: 584 ms, faster than 99.27% of Python3 online submissions\\n#       Memory Usage: 23.9 MB, less than 94.29% of Python3 online submissions\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        # the basic idea is to iterate over both of the binary trees and then return the target node in the cloned\\n        \\n        que = deque()\\n        \\n        que.append((original,cloned))\\n        \\n        while que:\\n            origion, clone = que.popleft()\\n            \\n            if origion == target:\\n                return clone\\n            \\n            if origion.left:\\n                que.append((origion.left,clone.left))\\n            \\n            if origion.right:\\n                que.append((origion.right,clone.right))\\n",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\n#       Runtime: 584 ms, faster than 99.27% of Python3 online submissions\\n#       Memory Usage: 23.9 MB, less than 94.29% of Python3 online submissions\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        # the basic idea is to iterate over both of the binary trees and then return the target node in the cloned\\n        \\n        que = deque()\\n        \\n        que.append((original,cloned))\\n        \\n        while que:\\n            origion, clone = que.popleft()\\n            \\n            if origion == target:\\n                return clone\\n            \\n            if origion.left:\\n                que.append((origion.left,clone.left))\\n            \\n            if origion.right:\\n                que.append((origion.right,clone.right))\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2047224,
                "title": "c-level-order-traversal-1379-find-a-corresponding-node-of-a-binary-tree",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n\\t\\t\\tqueue<TreeNode*>q;\\n\\t\\t\\tq.push(cloned);\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{   \\n\\t\\t\\t\\tfor(int i=0;i<q.size();i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tTreeNode*curr=q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tif(curr->val==target->val)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn curr;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(curr->left)\\n\\t\\t\\t\\t\\t\\tq.push(curr->left);\\n\\t\\t\\t\\t\\tif(curr->right)\\n\\t\\t\\t\\t\\t\\tq.push(curr->right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn nullptr;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n\\t\\t\\tqueue<TreeNode*>q;\\n\\t\\t\\tq.push(cloned);\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{   \\n\\t\\t\\t\\tfor(int i=0;i<q.size();i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tTreeNode*curr=q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tif(curr->val==target->val)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\treturn curr;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2046562,
                "title": "cpp-depth-first-search-time-o-n-spcae-o-n",
                "content": "Idea: We will start from root of both original and cloned trees and traverse them using dfs, if we find the node in original tree equal to target node we will return corresponding node from cloned tree.\\n```class Solution {\\npublic:\\n    TreeNode* ans;\\n    \\n    \\n    void help(TreeNode* original, TreeNode* cloned, TreeNode* target)\\n    {\\n        if(original == NULL) return;\\n        help(original->left,cloned->left,target);\\n        if(original == target) \\n        {\\n            ans = cloned;\\n            return;\\n        }\\n        help(original->right,cloned->right,target);\\n        return;\\n    }\\n    \\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        help(original,cloned,target);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* ans;\\n    \\n    \\n    void help(TreeNode* original, TreeNode* cloned, TreeNode* target)\\n    {\\n        if(original == NULL) return;\\n        help(original->left,cloned->left,target);\\n        if(original == target) \\n        {\\n            ans = cloned;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2046171,
                "title": "c-simple-recursion-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* traverse(TreeNode* original, TreeNode* cloned, TreeNode* target)\\n    {   \\n        if(!original)\\n            return NULL;\\n\\t\\t\\t\\n        if(original == target)\\n             return cloned;\\n\\t\\t\\t \\n         return max(traverse(original->left, cloned->left, target),traverse(original->right, cloned->right, target));\\n    }\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        return traverse(original, cloned, target);\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* traverse(TreeNode* original, TreeNode* cloned, TreeNode* target)\\n    {   \\n        if(!original)\\n            return NULL;\\n\\t\\t\\t\\n        if(original == target)\\n             return cloned;\\n\\t\\t\\t \\n         return max(traverse(original->left, cloned->left, target),traverse(original->right, cloned->right, target));\\n    }\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        return traverse(original, cloned, target);\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295126,
                "title": "c-simple-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        queue<TreeNode*>q;\\n        q.push(cloned);\\n        while(!q.empty()){\\n            TreeNode *t=q.front();\\n            if(t->val==target->val)\\n                return t;\\n            q.pop();\\n            if(t->left!=NULL)\\n                q.push(t->left);\\n            if(t->right!=NULL)\\n                q.push(t->right);\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        queue<TreeNode*>q;\\n        q.push(cloned);\\n        while(!q.empty()){\\n            TreeNode *t=q.front();\\n            if(t->val==target->val)\\n                return t;\\n            q.pop();\\n            if(t->left!=NULL)\\n                q.push(t->left);\\n            if(t->right!=NULL)\\n                q.push(t->right);\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700511,
                "title": "python-recursive-3-liner-that-hopefully-accounts-for-repeat-values",
                "content": "```\\nclass Solution:\\n    def getTargetCopy(self, original, cloned, target):\\n        if not original: return None\\n        \\n        if original == target: return cloned\\n        \\n        return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original, cloned, target):\\n        if not original: return None\\n        \\n        if original == target: return cloned\\n        \\n        return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)",
                "codeTag": "Java"
            },
            {
                "id": 663885,
                "title": "python-intuitive-solution",
                "content": "Iterate recursively over both the trees and return the node when the original node is equal to target node.\\n```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        if not original:\\n            return None\\n        if original == target:\\n            return cloned\\n        l = self.getTargetCopy(original.left, cloned.left, target)         \\n        r = self.getTargetCopy(original.right, cloned.right, target) \\n        return l if l else r \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        if not original:\\n            return None\\n        if original == target:\\n            return cloned\\n        l = self.getTargetCopy(original.left, cloned.left, target)         \\n        r = self.getTargetCopy(original.right, cloned.right, target) \\n        return l if l else r \\n```",
                "codeTag": "Java"
            },
            {
                "id": 634150,
                "title": "python-bfs",
                "content": "```python\\nclass Solution(object):\\n    def getTargetCopy(self, original, cloned, target):\\n        \"\"\"\\n        :type original: TreeNode\\n        :type cloned: TreeNode\\n        :type target: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        p, children = [cloned], []\\n        while p:\\n            for x in p:\\n                if x.val == target.val:\\n                    return x\\n                if x.left:\\n                    children.append(x.left)\\n                if x.right:\\n                    children.append(x.right)\\n            p, children = children, []\\n\\n        return None\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution(object):\\n    def getTargetCopy(self, original, cloned, target):\\n        \"\"\"\\n        :type original: TreeNode\\n        :type cloned: TreeNode\\n        :type target: TreeNode\\n        :rtype: TreeNode\\n        \"\"\"\\n        p, children = [cloned], []\\n        while p:\\n            for x in p:\\n                if x.val == target.val:\\n                    return x\\n                if x.left:\\n                    children.append(x.left)\\n                if x.right:\\n                    children.append(x.right)\\n            p, children = children, []\\n\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631033,
                "title": "javascript-solution",
                "content": "> Runtime: 312 ms, faster than 91.67% of JavaScript online submissions for Find a Corresponding Node of a Binary Tree in a Clone of That Tree.\\nMemory Usage: 74.2 MB, less than 100.00% of JavaScript online submissions for Find a Corresponding Node of a Binary Tree in a Clone of That Tree.\\n\\n```js\\nvar getTargetCopy = function(original, cloned, target) {\\n    if (!cloned) return\\n    if (cloned.val == target.val) {\\n        return cloned\\n    }else{\\n        return getTargetCopy(original, cloned.left, target) || getTargetCopy(original, cloned.right, target)\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar getTargetCopy = function(original, cloned, target) {\\n    if (!cloned) return\\n    if (cloned.val == target.val) {\\n        return cloned\\n    }else{\\n        return getTargetCopy(original, cloned.left, target) || getTargetCopy(original, cloned.right, target)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 546717,
                "title": "javascript-solution",
                "content": "```\\nvar getTargetCopy = function(original, cloned, target) {\\n    \\n      if(!original) return null;\\n    \\n      if(original === target) return cloned;\\n\\t  \\n      let left = getTargetCopy(original.left,cloned.left,target)\\n      if(left) return left\\n\\t  \\n      let right =getTargetCopy(original.right,cloned.right,target)\\n      return right\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar getTargetCopy = function(original, cloned, target) {\\n    \\n      if(!original) return null;\\n    \\n      if(original === target) return cloned;\\n\\t  \\n      let left = getTargetCopy(original.left,cloned.left,target)\\n      if(left) return left\\n\\t  \\n      let right =getTargetCopy(original.right,cloned.right,target)\\n      return right\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 542453,
                "title": "short-and-clear-java-solution-for-followup-question-100-runtime",
                "content": "```\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original == null) return null;\\n        if (original.val == target.val) return cloned; // check if current node is what we are looking for\\n        TreeNode res = getTargetCopy(original.left, cloned.left, target); // go left in both trees\\n        if (res != null) return res;\\n        return getTargetCopy(original.right, cloned.right, target); // go right in both trees\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original == null) return null;\\n        if (original.val == target.val) return cloned; // check if current node is what we are looking for\\n        TreeNode res = getTargetCopy(original.left, cloned.left, target); // go left in both trees\\n        if (res != null) return res;\\n        return getTargetCopy(original.right, cloned.right, target); // go right in both trees\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 537194,
                "title": "is-there-something-wrong-with-this-problem-it-works-with-simple-search",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    TreeNode result;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(cloned == null || target == null) return null;\\n        rec(cloned, target);\\n        return result;\\n    }\\n    \\n    public void rec(TreeNode clone, TreeNode target){\\n        if(clone == null) return;\\n        if(result != null) return;\\n        \\n        if(clone.val == target.val){\\n            result = clone;\\n            return;\\n        }\\n        \\n        rec(clone.left,target);\\n        rec(clone.right,target);\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    TreeNode result;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(cloned == null || target == null) return null;\\n        rec(cloned, target);\\n        return result;\\n    }\\n    \\n    public void rec(TreeNode clone, TreeNode target){\\n        if(clone == null) return;\\n        if(result != null) return;\\n        \\n        if(clone.val == target.val){\\n            result = clone;\\n            return;\\n        }\\n        \\n        rec(clone.left,target);\\n        rec(clone.right,target);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390173,
                "title": "c-accepted-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\n\\npublic class Solution {\\n    public TreeNode result;\\n    public void dfs(TreeNode root, int val){\\n        if(root!=null){\\n            if(root.val==val)\\n                result=root;\\n            dfs(root.left,val);\\n            dfs(root.right,val);\\n        }\\n    }\\n    public TreeNode GetTargetCopy(TreeNode original, TreeNode cloned, TreeNode target) {\\n        dfs(cloned, target.val);\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\n\\npublic class Solution {\\n    public TreeNode result;\\n    public void dfs(TreeNode root, int val){\\n        if(root!=null){\\n            if(root.val==val)\\n                result=root;\\n            dfs(root.left,val);\\n            dfs(root.right,val);\\n        }\\n    }\\n    public TreeNode GetTargetCopy(TreeNode original, TreeNode cloned, TreeNode target) {\\n        dfs(cloned, target.val);\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208640,
                "title": "java-easy-sol-inorder-traversal-2ms-simple-and-easy",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    TreeNode ans = null;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original==null) return null;\\n        if (original == target) {\\n            ans = cloned;\\n        }\\n        getTargetCopy(original.left, cloned.left, target);\\n        getTargetCopy(original.right, cloned.right, target);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    TreeNode ans = null;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original==null) return null;\\n        if (original == target) {\\n            ans = cloned;\\n        }\\n        getTargetCopy(original.left, cloned.left, target);\\n        getTargetCopy(original.right, cloned.right, target);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040707,
                "title": "bfs-in-cloned-o-n-time-o-w-space",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(cloned==NULL)return NULL;\\n        if(cloned->val==target->val)return cloned;\\n        queue<TreeNode*>q;\\n        q.push(cloned);\\n        while(!q.empty()){\\n            TreeNode* curr=q.front();\\n            if(curr->val==target->val)return curr;\\n            q.pop();\\n            if(curr->left)q.push(curr->left);\\n            if(curr->right)q.push(curr->right);\\n        }\\n        return NULL;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(cloned==NULL)return NULL;\\n        if(cloned->val==target->val)return cloned;\\n        queue<TreeNode*>q;\\n        q.push(cloned);\\n        while(!q.empty()){\\n            TreeNode* curr=q.front();\\n            if(curr->val==target->val)return curr;\\n            q.pop();\\n            if(curr->left)q.push(curr->left);\\n            if(curr->right)q.push(curr->right);\\n        }\\n        return NULL;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756003,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode * ans;\\n    void find(TreeNode* root, int val)\\n    {\\n        if(root == NULL)\\n            return;\\n        if(root->val == val)\\n        {\\n            ans = root;\\n            return;\\n        }\\n        find(root->right,val);\\n        find(root->left,val);\\n    }\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n            find(cloned, target->val);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode * ans;\\n    void find(TreeNode* root, int val)\\n    {\\n        if(root == NULL)\\n            return;\\n        if(root->val == val)\\n        {\\n            ans = root;\\n            return;\\n        }\\n        find(root->right,val);\\n        find(root->left,val);\\n    }\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n            find(cloned, target->val);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354216,
                "title": "c-easy-to-understand-bfs-level-order-solution",
                "content": "Run BFS for both the trees parallelly\\nBoth The trees are same so the bfs will also be the same \\nOnce we find node in original tree to be equal to target return current node of cloned tree\\n\\n\\n\\n```\\nTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        queue<TreeNode*> originalq;\\n        queue<TreeNode*> clonedq;\\n        \\n        originalq.push(original);\\n        clonedq.push(cloned);\\n        \\n        while(originalq.empty() == false){\\n            TreeNode* a = originalq.front();\\n            TreeNode* b = clonedq.front();\\n            originalq.pop();\\n            clonedq.pop();\\n            \\n            if(a == target){\\n                return b;\\n            }\\n            \\n            if(a->left != NULL){\\n                originalq.push(a->left);\\n                clonedq.push(b->left);\\n            }\\n            if(a->right !=  NULL ){\\n                originalq.push(a->right);\\n                clonedq.push(b->right);\\n            }\\n        }\\n        \\n        return NULL;\\n        \\n    }\\n```\\n\\nTime Complexity is O(N)\\nSpace Complexity is O(N)",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\nTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        queue<TreeNode*> originalq;\\n        queue<TreeNode*> clonedq;\\n        \\n        originalq.push(original);\\n        clonedq.push(cloned);\\n        \\n        while(originalq.empty() == false){\\n            TreeNode* a = originalq.front();\\n            TreeNode* b = clonedq.front();\\n            originalq.pop();\\n            clonedq.pop();\\n            \\n            if(a == target){\\n                return b;\\n            }\\n            \\n            if(a->left != NULL){\\n                originalq.push(a->left);\\n                clonedq.push(b->left);\\n            }\\n            if(a->right !=  NULL ){\\n                originalq.push(a->right);\\n                clonedq.push(b->right);\\n            }\\n        }\\n        \\n        return NULL;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2046958,
                "title": "c-easy-solution-by-2-methods-repeated-non-repeated",
                "content": "**Time Complexity : O(n)\\nSpace Complexity : O(n)**\\n\\n**C++ Code:**\\n **Method 1: When Repeated element is not allowed** \\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        queue<TreeNode*>q;\\n        q.push(cloned);\\n        while(!q.empty())\\n        {\\n            auto temp = q.front();\\n            q.pop();\\n            if(temp->left!=NULL)\\n                q.push(temp->left);\\n            if(temp->right!=NULL)\\n                q.push(temp->right);\\n            if(temp->val==target->val)\\n                return temp;\\n        }\\n    return NULL;\\n    }\\n};\\n```\\n**Method 2:\\nWhen Repeated element is allowed**\\n\\n**Time Complexity : O(n)\\nSpace Complexity : O(n)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        queue<TreeNode*>q1;\\n        q1.push(original);\\n        int count = 1;\\n        while(!q1.empty())\\n        {\\n            auto temp = q1.front();\\n            q1.pop();\\n             \\n            if(temp==target)\\n              break;\\n            if(temp!=NULL && temp->left!=NULL)\\n                q1.push(temp->left);\\n            else if(temp!=NULL && temp->left==NULL)\\n                q1.push(NULL);\\n            count++;\\n            if(temp!=NULL && temp->right!=NULL)\\n                q1.push(temp->right);\\n            else if(temp!=NULL && temp->right==NULL) \\n                q1.push(NULL);\\n            count++;\\n        }\\n         queue<TreeNode*>q2;\\n         q2.push(cloned);\\n         count--;\\n         while(!q2.empty())\\n        {\\n            auto temp = q2.front();\\n            q2.pop();\\n             \\n            if(count==0 && temp->val==target->val)\\n              return temp;\\n            if(temp!=NULL && temp->left!=NULL)\\n                q2.push(temp->left);\\n            else if(temp!=NULL && temp->left==NULL)\\n                q2.push(NULL);\\n            count--;\\n            if(temp!=NULL && temp->right!=NULL)\\n                q2.push(temp->right);\\n            else if(temp!=NULL && temp->right==NULL)\\n                q2.push(NULL);\\n            count--;\\n        }\\n    return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        queue<TreeNode*>q;\\n        q.push(cloned);\\n        while(!q.empty())\\n        {\\n            auto temp = q.front();\\n            q.pop();\\n            if(temp->left!=NULL)\\n                q.push(temp->left);\\n            if(temp->right!=NULL)\\n                q.push(temp->right);\\n            if(temp->val==target->val)\\n                return temp;\\n        }\\n    return NULL;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        queue<TreeNode*>q1;\\n        q1.push(original);\\n        int count = 1;\\n        while(!q1.empty())\\n        {\\n            auto temp = q1.front();\\n            q1.pop();\\n             \\n            if(temp==target)\\n              break;\\n            if(temp!=NULL && temp->left!=NULL)\\n                q1.push(temp->left);\\n            else if(temp!=NULL && temp->left==NULL)\\n                q1.push(NULL);\\n            count++;\\n            if(temp!=NULL && temp->right!=NULL)\\n                q1.push(temp->right);\\n            else if(temp!=NULL && temp->right==NULL) \\n                q1.push(NULL);\\n            count++;\\n        }\\n         queue<TreeNode*>q2;\\n         q2.push(cloned);\\n         count--;\\n         while(!q2.empty())\\n        {\\n            auto temp = q2.front();\\n            q2.pop();\\n             \\n            if(count==0 && temp->val==target->val)\\n              return temp;\\n            if(temp!=NULL && temp->left!=NULL)\\n                q2.push(temp->left);\\n            else if(temp!=NULL && temp->left==NULL)\\n                q2.push(NULL);\\n            count--;\\n            if(temp!=NULL && temp->right!=NULL)\\n                q2.push(temp->right);\\n            else if(temp!=NULL && temp->right==NULL)\\n                q2.push(NULL);\\n            count--;\\n        }\\n    return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046881,
                "title": "recursion-is-tough-but-lets-work-on-it",
                "content": "so clearly in one glance we can see it\\'s a tree and that mean recursion and that means thinking hard,\\n```class Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n      //  TreeNode ans=new TreeNode(-1);\\n       if(original==null||original==target)return cloned ;\\n       \\n      \\n       TreeNode res=  getTargetCopy(original.left,cloned.left,target);\\n \\n        \\n    if(res!=null)return res;\\n        \\n           TreeNode x=  getTargetCopy(original.right,cloned.right,target);\\n        return x;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```class Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n      //  TreeNode ans=new TreeNode(-1);\\n       if(original==null||original==target)return cloned ;\\n       \\n      \\n       TreeNode res=  getTargetCopy(original.left,cloned.left,target);\\n \\n        \\n    if(res!=null)return res;\\n        \\n           TreeNode x=  getTargetCopy(original.right,cloned.right,target);\\n        return x;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046329,
                "title": "java-dfs-easy-solution",
                "content": "\\'\\'\\'\\n  class Solution {\\nTreeNode ans;\\n\\npublic void inorder(TreeNode c,TreeNode target) {\\n    if (c != null) {\\n        inorder(c.left, target);\\n        if (c.val == target.val) {\\n            ans = c;    \\n        }\\n        inorder(c.right, target);    \\n    }\\n}\\n\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) \\n{\\n    inorder(cloned,target);\\n    return ans;\\n}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\nTreeNode ans;\\n\\npublic void inorder(TreeNode c,TreeNode target) {\\n    if (c != null) {\\n        inorder(c.left, target);\\n        if (c.val == target.val) {\\n            ans = c;    \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2046161,
                "title": "find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree-c-dfs",
                "content": "Simple Approach for this Solution is clone should follow that path only which is followerd by the original pointer i.e if we are moving towards left of original then clone should be traversed in that way and so on.\\n\\nPlease Upvote :)\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* clone, TreeNode* target)     {\\n        if(original==NULL)\\n            return NULL;\\n        if(original==target)\\n            return clone;\\n        TreeNode* left = getTargetCopy(original->left,clone->left,target);\\n       \\n        TreeNode* right = getTargetCopy(original->right,clone->right,target);\\n         if(left)return left;\\n         else return right;\\n    }\\n};\\n```\\nMy other Solutions:\\nhttps://leetcode.com/problems/count-sorted-vowel-strings/discuss/2027270/Count-Sorted-Vowel-Strings\\nhttps://leetcode.com/problems/partition-labels/discuss/1868704/partition-labels-on-solution-c-greedy-simple-solution\\nhttps://leetcode.com/problems/power-of-four/discuss/1799832/power-of-four-c100bit-manipualtion-easy-solution\\nhttps://leetcode.com/problems/partition-labels/discuss/1868704/partition-labels-on-solution-c-greedy-simple-solution\\nhttps://leetcode.com/problems/binary-tree-level-order-traversal/discuss/1862025/binary-tree-level-order-traversal-queue-binary-tree-easy-solution\\nhttps://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/discuss/1850726/minimum-remove-to-make-valid-parentheses-c-on-simple-logic-easy-solution\\nhttps://leetcode.com/problems/maximum-number-of-vowels-in-a-substring-of-given-length/discuss/1849453/maximum-number-of-vowels-in-a-substring-of-given-length-csliding-window\\nhttps://leetcode.com/problems/reverse-prefix-of-word/discuss/1840375/reverse-prefix-of-word-100-c\\nhttps://leetcode.com/problems/find-n-unique-integers-sum-up-to-zero/discuss/1826246/find-n-unique-integers-sum-up-to-zero-100-simple-solution\\nhttps://leetcode.com/problems/find-minimum-in-rotated-sorted-array/discuss/1814346/find-minimum-in-rotated-sorted-array-binary-search-100-ceasy-solution\\nhttps://leetcode.com/problems/is-subsequence/discuss/1811098/is-subsequence-100-c-easy-solution\\nhttps://leetcode.com/problems/search-in-rotated-sorted-array/discuss/1808021/search-in-rotated-sorted-array-ologn-solution-simple-solution-binary-search\\nhttps://leetcode.com/problems/check-if-number-is-a-sum-of-powers-of-three/discuss/1799853/check-if-number-is-a-sum-of-powers-of-three-100-easy-solution\\nhttps://leetcode.com/problems/sequential-digits/discuss/1751815/sequential-digits-c-100-easy-solution\\nhttps://leetcode.com/problems/binary-gap/discuss/1749101/binary-gap-100-c-simple-solution\\nhttps://leetcode.com/problems/kth-largest-element-in-an-array/discuss/1730888/kth-largest-element-in-an-array-c-sorting-simple-solution\\nhttps://leetcode.com/problems/queries-on-number-of-points-inside-a-circle/discuss/1726527/queries-on-number-of-points-inside-a-circle-c-simple-mathematics\\nhttps://leetcode.com/problems/integer-to-roman/discuss/1726042/integer-to-roman-c-easy-to-understand\\nhttps://leetcode.com/problems/rings-and-rods/discuss/1724149/rings-and-rods-100-c-using-hashmap\\nhttps://leetcode.com/problems/number-complement/discuss/1722669/number-compliment\\nhttps://leetcode.com/problems/find-the-duplicate-number/discuss/1809351/find-the-duplicate-number-o1-space-binary-search-easy-solution\\nhttps://leetcode.com/problems/smallest-string-with-a-given-numeric-value/discuss/1872424/Smallest-String-With-A-Given-Numeric-Value-oror-C%2B%2B-O(n)-oror-Simple-Solution-with-Explaination\\nhttps://leetcode.com/problems/broken-calculator/discuss/1875269/Broken-Calculator-oror-C%2B%2B-100-O(n)-oror-Greedy-solution-with-Explanation-oror-Easy-Simple-Solution\\nhttps://leetcode.com/problems/generate-parentheses/discuss/1875357/Generate-Parentheses-oror-C%2B%2B-recursive-Approach-with-explaination-oror-Easy-Approach\\nhttps://leetcode.com/problems/boats-to-save-people/discuss/1877923/Boats-to-Save-People-oror-c%2B%2B-Greedy-oror-two-pointers-oror-sorting-oror-easy-Solution-with-explaination\\nhttps://leetcode.com/problems/minimum-add-to-make-parentheses-valid/discuss/1901110/Minimum-Add-to-Make-Parentheses-Valid-oror-c%2B%2B-oror-100-oror-Simple-Solution-oror-String\\nhttps://leetcode.com/problems/game-of-life/discuss/1937884/Game-of-Life-oror-100-oror-C%2B%2B-oror-Matrix-IMPLEMENTATION\\nhttps://leetcode.com/problems/letter-case-permutation/discuss/2005077/Letter-Case-Permutation-oror-c%2B%2Boror-RecursionororEasy-Solution\\nhttps://leetcode.com/problems/max-number-of-k-sum-pairs/discuss/2006992/Max-Number-of-K-Sum-Pairs-oror-C%2B%2Boror-HashMapororEasy-Solution\\nhttps://leetcode.com/problems/implement-stack-using-queues/discuss/2009042/Implement-Stack-using-Queues-oror-c%2B%2B-oror-easySolutionoror-100",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* clone, TreeNode* target)     {\\n        if(original==NULL)\\n            return NULL;\\n        if(original==target)\\n            return clone;\\n        TreeNode* left = getTargetCopy(original->left,clone->left,target);\\n       \\n        TreeNode* right = getTargetCopy(original->right,clone->right,target);\\n         if(left)return left;\\n         else return right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046157,
                "title": "c-dfs-easy-to-understand",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n\\t\\t\\tif(original == nullptr)\\n\\t\\t\\t\\treturn nullptr;\\n\\n\\t\\t\\tif(original == target)\\n\\t\\t\\t\\treturn cloned;\\n\\n\\t\\t\\tTreeNode* left = getTargetCopy(original->left, cloned->left, target);\\n\\t\\t\\tTreeNode* right = getTargetCopy(original->right, cloned->right, target);\\n\\n\\t\\t\\tif(left != nullptr) return left;\\n\\t\\t\\tif(right != nullptr) return right;\\n\\n\\t\\t\\treturn nullptr;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n\\t\\t\\tif(original == nullptr)\\n\\t\\t\\t\\treturn nullptr;\\n\\n\\t\\t\\tif(original == target)\\n\\t\\t\\t\\treturn cloned;\\n\\n\\t\\t\\tTreeNode* left = getTargetCopy(original->left, cloned->left, target);\\n\\t\\t\\tTreeNode* right = getTargetCopy(original->right, cloned->right, target);\\n\\n\\t\\t\\tif(left != nullptr) return left;\\n\\t\\t\\tif(right != nullptr) return right;\\n\\n\\t\\t\\treturn nullptr;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1677564,
                "title": "java-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    TreeNode res;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(original != null){\\n            getTargetCopy(original.left, cloned.left, target);\\n            if(original == target){\\n                res = cloned;\\n            }\\n            getTargetCopy(original.right, cloned.right, target);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    TreeNode res;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(original != null){\\n            getTargetCopy(original.left, cloned.left, target);\\n            if(original == target){\\n                res = cloned;\\n            }\\n            getTargetCopy(original.right, cloned.right, target);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 999082,
                "title": "c-dfs-simple-solution-one-traversal",
                "content": "**Approach :**\\n\\nUsing pre-order traversal (DFS)\\n1. Check if root is target return cloned root\\n2. Check left subtree if found return\\n3. Check right subtree and return.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(original==NULL || original==target){\\n            return cloned;\\n        }\\n        TreeNode *left=getTargetCopy(original->left,cloned->left,target);\\n        if(left)\\n            return left;\\n        return getTargetCopy(original->right,cloned->right,target);\\n    }\\n};\\n```\\n**Time complexity** :\\nO(n) where n is number of nodes in binary tree",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(original==NULL || original==target){\\n            return cloned;\\n        }\\n        TreeNode *left=getTargetCopy(original->left,cloned->left,target);\\n        if(left)\\n            return left;\\n        return getTargetCopy(original->right,cloned->right,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810106,
                "title": "c-oneliner-recursive-dfs-explained-100-time-40-space",
                "content": "Not the most efficient, but I wanted to have some fun.\\n\\nThe main idea is proceed with your usual recursive DFS approach going hand in hand: when we move `left` with original we do the same with `cloned` and same with the `right` branches. When `original == target`, it will then mean that we are in the same position of the tree also with `cloned`, so we can return its current pointer.\\n\\nNotice that I added a fourth parameter (`tmp`) just for the sake of making it a oneliner (ie: without having to use an extra line to declare it), plus I used the assignment trick to get both a value for the ternary operator and update the value of `tmp` in one single go, with `(tmp = getTargetCopy(original->left, cloned->left, target))`.\\n\\nThe final condition is closed with a `NULL`, which is what we would get ending up on a dead leaf of some non-matching branch.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target, TreeNode* tmp = NULL) {\\n        return original == target ? cloned : original->left && (tmp = getTargetCopy(original->left, cloned->left, target)) ? tmp : original->right ? getTargetCopy(original->right, cloned->right, target) : NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target, TreeNode* tmp = NULL) {\\n        return original == target ? cloned : original->left && (tmp = getTargetCopy(original->left, cloned->left, target)) ? tmp : original->right ? getTargetCopy(original->right, cloned->right, target) : NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 620640,
                "title": "python3-beginner-s-solution-656ms",
                "content": "```\\nclass Solution:\\n    from collections import deque\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        \\n        queue = deque()\\n        queue.append(cloned)\\n        \\n        def isMatch(tree, target):\\n            if tree is None and target is None:\\n                return 1\\n            elif tree is None or target is None:\\n                return 0\\n            elif tree.val != target.val:\\n                return 0\\n            else:\\n                left = isMatch(tree.left, target.left)\\n                right = isMatch(tree.right, target.right)\\n                return left and right\\n        \\n        while queue:\\n            head = queue.pop()\\n            if isMatch(head, target):\\n                return head\\n            else:\\n                if head.left is not None:\\n                    queue.append(head.left)\\n                if head.right is not None:\\n                    queue.append(head.right)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    from collections import deque\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        \\n        queue = deque()\\n        queue.append(cloned)\\n        \\n        def isMatch(tree, target):\\n            if tree is None and target is None:\\n                return 1\\n            elif tree is None or target is None:\\n                return 0\\n            elif tree.val != target.val:\\n                return 0\\n            else:\\n                left = isMatch(tree.left, target.left)\\n                right = isMatch(tree.right, target.right)\\n                return left and right\\n        \\n        while queue:\\n            head = queue.pop()\\n            if isMatch(head, target):\\n                return head\\n            else:\\n                if head.left is not None:\\n                    queue.append(head.left)\\n                if head.right is not None:\\n                    queue.append(head.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607713,
                "title": "c-bfs-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        queue<TreeNode*>q;\\n        q.push(original);\\n        q.push(cloned);\\n        while(!q.empty()){\\n            TreeNode* o = q.front();\\n            q.pop();\\n            TreeNode* c = q.front();\\n            q.pop();\\n            if(o==target)\\n                return c;\\n            if(o->left)\\n                q.push(o->left);\\n            if(c->left)\\n                q.push(c->left);\\n            if(o->right)\\n                q.push(o->right);\\n            if(c->right)\\n                q.push(c->right);\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        queue<TreeNode*>q;\\n        q.push(original);\\n        q.push(cloned);\\n        while(!q.empty()){\\n            TreeNode* o = q.front();\\n            q.pop();\\n            TreeNode* c = q.front();\\n            q.pop();\\n            if(o==target)\\n                return c;\\n            if(o->left)\\n                q.push(o->left);\\n            if(c->left)\\n                q.push(c->left);\\n            if(o->right)\\n                q.push(o->right);\\n            if(c->right)\\n                q.push(c->right);\\n        }\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573102,
                "title": "javascript-simple-and-naive-approach-with-follow-up-o-n",
                "content": "To make the problem simple, we can think about it, like the search of the element in the tree but passing additional value to return it in case we will find required value. \\n\\nMoreover, If to change  ```node.val```  comparison check for the object comparison check it will deal with duplicates.\\n```\\nconst getTargetCopy = (original, cloned, target) => {\\n    if (!original && !cloned) return;\\n    if (original === target) return cloned\\n    return getTargetCopy(original.left, cloned.left, target) || getTargetCopy(original.right, cloned.right, target);\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```node.val```\n```\\nconst getTargetCopy = (original, cloned, target) => {\\n    if (!original && !cloned) return;\\n    if (original === target) return cloned\\n    return getTargetCopy(original.left, cloned.left, target) || getTargetCopy(original.right, cloned.right, target);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 550560,
                "title": "java-follow-up-solution",
                "content": "Not the most efficient but pretty clear, we first search for the target node in the original tree while recording every step in the traversal, and then reproduce that traversal on the cloned tree.\\n```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        Stack<Character> traversalToTarget = new Stack<>();\\n        if (!generatePathToTarget(original, target, traversalToTarget)){\\n            System.out.println(\"Didn\\'t find target in original tree!\");\\n\\t\\t\\treturn null;\\n        }\\n        \\n        TreeNode current = cloned;\\n        while (!traversalToTarget.empty()){\\n            Character direction = traversalToTarget.pop();\\n            if (direction == \\'r\\'){\\n                current = current.right;\\n            }\\n            else{\\n                current = current.left;\\n            }\\n        }\\n        return current;\\n    }\\n    \\n    private boolean generatePathToTarget(TreeNode current, TreeNode target, Stack<Character> path){\\n        if (current == target){\\n            return true;\\n        }\\n        if (current.right == null && current.left == null){\\n            return false;\\n        }\\n        \\n        if (current.right != null && generatePathToTarget(current.right, target, path)){\\n            path.push(\\'r\\');\\n            return true;\\n        }\\n        \\n        if (current.left != null && generatePathToTarget(current.left, target, path)){\\n            path.push(\\'l\\');\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        Stack<Character> traversalToTarget = new Stack<>();\\n        if (!generatePathToTarget(original, target, traversalToTarget)){\\n            System.out.println(\"Didn\\'t find target in original tree!\");\\n\\t\\t\\treturn null;\\n        }\\n        \\n        TreeNode current = cloned;\\n        while (!traversalToTarget.empty()){\\n            Character direction = traversalToTarget.pop();\\n            if (direction == \\'r\\'){\\n                current = current.right;\\n            }\\n            else{\\n                current = current.left;\\n            }\\n        }\\n        return current;\\n    }\\n    \\n    private boolean generatePathToTarget(TreeNode current, TreeNode target, Stack<Character> path){\\n        if (current == target){\\n            return true;\\n        }\\n        if (current.right == null && current.left == null){\\n            return false;\\n        }\\n        \\n        if (current.right != null && generatePathToTarget(current.right, target, path)){\\n            path.push(\\'r\\');\\n            return true;\\n        }\\n        \\n        if (current.left != null && generatePathToTarget(current.left, target, path)){\\n            path.push(\\'l\\');\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538549,
                "title": "java-easy-o-n-parallel-search-solves-followup",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original == null)\\n            return null;\\n        \\n        if (original == target)\\n            return cloned;\\n        \\n        TreeNode l = getTargetCopy(original.left, cloned.left, target);\\n        TreeNode r = getTargetCopy(original.right, cloned.right, target);\\n        \\n        return l != null ? l : r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original == null)\\n            return null;\\n        \\n        if (original == target)\\n            return cloned;\\n        \\n        TreeNode l = getTargetCopy(original.left, cloned.left, target);\\n        TreeNode r = getTargetCopy(original.right, cloned.right, target);\\n        \\n        return l != null ? l : r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735295,
                "title": "easy-to-understand-c-solution-using-preorder-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\nprivate:\\n    void preorder(TreeNode* cloned, TreeNode* target, TreeNode* &node)\\n    {\\n        if(cloned==NULL)return;\\n        if (cloned->val == target->val)\\n            node = cloned;\\n        preorder(cloned->left, target, node);\\n        preorder(cloned->right, target, node);\\n    }\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if (target == nullptr || cloned == nullptr) return nullptr;\\n        TreeNode* node = new TreeNode;\\n        preorder(cloned, target, node);\\n        return node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\nprivate:\\n    void preorder(TreeNode* cloned, TreeNode* target, TreeNode* &node)\\n    {\\n        if(cloned==NULL)return;\\n        if (cloned->val == target->val)\\n            node = cloned;\\n        preorder(cloned->left, target, node);\\n        preorder(cloned->right, target, node);\\n    }\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if (target == nullptr || cloned == nullptr) return nullptr;\\n        TreeNode* node = new TreeNode;\\n        preorder(cloned, target, node);\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673988,
                "title": "easy-java-dfs-pre-order-global-variable-target-fetching-beats-90-explained",
                "content": "# Approach\\n- Create two global variables , t_value(int) and referenced(TreeNode).\\n- We fetch the t_value from the target node.\\n- Then we traverse through the cloned tree using pre-order traversal till we find a root such that root.val == t_val\\n- When found, store the root value (TreeNode) as referenced and return that in the main function.\\n\\n# Complexity\\n- Time complexity: O(n) - n is the number of nodes\\n\\n- Space complexity: O(1) - two container variables declared\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        t_value = target.val;\\n        treeTraverse(cloned);\\n        return referenced;\\n    }\\n\\n    public int t_value; // for target value\\n\\n    public TreeNode referenced; // for the node containing t_value in cloned tree\\n\\n    public void treeTraverse(TreeNode x){\\n        \\n        // pre-order traversal DFS\\n\\n        if(x == null){\\n            return;\\n        }\\n\\n        // target value match condition\\n\\n        if(x.val == t_value){  \\n            referenced = x; // containing the target node\\n        }\\n\\n        treeTraverse(x.left);\\n        treeTraverse(x.right);\\n\\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/48033741-a22c-4983-b2d4-301736762252_1687531863.7990797.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        t_value = target.val;\\n        treeTraverse(cloned);\\n        return referenced;\\n    }\\n\\n    public int t_value; // for target value\\n\\n    public TreeNode referenced; // for the node containing t_value in cloned tree\\n\\n    public void treeTraverse(TreeNode x){\\n        \\n        // pre-order traversal DFS\\n\\n        if(x == null){\\n            return;\\n        }\\n\\n        // target value match condition\\n\\n        if(x.val == t_value){  \\n            referenced = x; // containing the target node\\n        }\\n\\n        treeTraverse(x.left);\\n        treeTraverse(x.right);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491474,
                "title": "easy-to-understand-c-with-explanation",
                "content": "# Intuition\\nWe will use Pre-order traversal to find the reference.\\n# Approach\\nAlgorithm Preorder(tree)\\n\\n- Visit the root.\\n- Traverse the left subtree, i.e., call Preorder(left->subtree)\\n- Traverse the right subtree, i.e., call Preorder(right->subtree)\\n\\nWe will use recursion to do the traversal, we will keep checking if the **target == currentNode** (which is *root* in each case). If it is true, we will simply put the current Node\\'s reference to *ref* variable.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n\\n    void preOrder(TreeNode* root, TreeNode* &ref, TreeNode* target){\\n        if(root == NULL)\\n            return;\\n\\n        if(root->val == target->val)\\n            ref = root;\\n\\n        preOrder(root->left,ref,target);\\n        preOrder(root->right,ref,target);\\n    }\\n\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        TreeNode* ref = NULL;\\n        preOrder(cloned,ref,target);\\n        return ref;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n\\n    void preOrder(TreeNode* root, TreeNode* &ref, TreeNode* target){\\n        if(root == NULL)\\n            return;\\n\\n        if(root->val == target->val)\\n            ref = root;\\n\\n        preOrder(root->left,ref,target);\\n        preOrder(root->right,ref,target);\\n    }\\n\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        TreeNode* ref = NULL;\\n        preOrder(cloned,ref,target);\\n        return ref;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449517,
                "title": "java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n\\n    TreeNode ans;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(cloned == null){\\n            return cloned;\\n        }\\n        if(cloned.val == target.val){\\n            ans = cloned;\\n        }\\n        getTargetCopy(original, cloned.left, target);\\n        getTargetCopy(original, cloned.right, target);\\n        return ans;\\n    }\\n\\n    \\n}\\n```\\n\\n\\u2705 IF YOU LIKE THIS SOLUTION, **PLEASE UPVOTE.**\\n\\nThank you :)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    TreeNode ans;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(cloned == null){\\n            return cloned;\\n        }\\n        if(cloned.val == target.val){\\n            ans = cloned;\\n        }\\n        getTargetCopy(original, cloned.left, target);\\n        getTargetCopy(original, cloned.right, target);\\n        return ans;\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364861,
                "title": "very-easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    TreeNode ans=null;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        \\n        return preOrder(original,cloned,target);   \\n    }\\n\\n    public final TreeNode preOrder(final TreeNode original, final TreeNode cloned, final TreeNode target){\\n        if(original==null){\\n            return null;\\n        }\\n        if(target==original){\\n            ans=cloned;\\n        }\\n        preOrder(original.left,cloned.left,target);\\n        preOrder(original.right,cloned.right,target);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    TreeNode ans=null;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        \\n        return preOrder(original,cloned,target);   \\n    }\\n\\n    public final TreeNode preOrder(final TreeNode original, final TreeNode cloned, final TreeNode target){\\n        if(original==null){\\n            return null;\\n        }\\n        if(target==original){\\n            ans=cloned;\\n        }\\n        preOrder(original.left,cloned.left,target);\\n        preOrder(original.right,cloned.right,target);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360208,
                "title": "using-recursion-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/3ecd8dfd-8c19-4fa5-8b73-83551c113080_1680200954.0556824.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        if not original or target==original:\\n            return cloned\\n        return self.getTargetCopy(original.left,cloned.left,target) or self.getTargetCopy(original.right,cloned.right,target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        if not original or target==original:\\n            return cloned\\n        return self.getTargetCopy(original.left,cloned.left,target) or self.getTargetCopy(original.right,cloned.right,target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331276,
                "title": "simple-bfs-approach-in-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        if not original:\\n            return None\\n        list1=deque([(original,cloned)])\\n        while list1:\\n            og,cln=list1.popleft()\\n            if og==target:\\n                return cln\\n            if og.left:\\n                list1.append((og.left,cln.left))\\n            if og.right:\\n                list1.append((og.right,cln.right))\\n        return None\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        if not original:\\n            return None\\n        list1=deque([(original,cloned)])\\n        while list1:\\n            og,cln=list1.popleft()\\n            if og==target:\\n                return cln\\n            if og.left:\\n                list1.append((og.left,cln.left))\\n            if og.right:\\n                list1.append((og.right,cln.right))\\n        return None\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214152,
                "title": "easy-to-understand-java-solution-with-simple-explanation",
                "content": "# Approach\\nFirst we check if the original tree is null or not. If it is null, we simply return null.\\nNext we check if value of first element of original tree is equal to target value, if yes, we return cloned tree (since we got the value we needed we do not need to traverse in cloned tree)\\nWe then created a node \"ans\" which will traverse in left side of both the trees and store the answer.\\nIf ans is not equal to null we will return ans.\\nOtherwise we will traverse in right side of tree and return it.\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(original==null){ return null;}\\n        if(original.val==target.val){ return cloned;}\\n        TreeNode ans = getTargetCopy(original.left, cloned.left,target);\\n        if(ans!=null){ return ans;}\\n        return getTargetCopy(original.right, cloned.right, target);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(original==null){ return null;}\\n        if(original.val==target.val){ return cloned;}\\n        TreeNode ans = getTargetCopy(original.left, cloned.left,target);\\n        if(ans!=null){ return ans;}\\n        return getTargetCopy(original.right, cloned.right, target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2518279,
                "title": "python-bfs-dfs",
                "content": "\\n```\\n\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        head = cloned\\n        \"BFS\"\\n        q = []\\n        q.append(head)\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                head = q.pop(0)\\n                if head.val == target.val:\\n                    return head\\n                if head.left:\\n                    q.append(head.left)\\n                if head.right:\\n                    q.append(head.right)\\n        \\n        # \"DFS\"\\n        # res = TreeNode(0)\\n        # def dfs(head,target):\\n        #     nonlocal res\\n        #     if head.val == target.val:\\n        #         res = head\\n        #         return\\n        #     if head.left:\\n        #         dfs(head.left,target)\\n        #     if head.right:\\n        #         dfs(head.right,target)\\n        # dfs(cloned,target)\\n        # return res\\n```\\n\\n### \\uD83D\\uDE02 Random Dev Meme\\n<img src=\"https://random-memer.herokuapp.com/\" width=\"512px\"/>",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        head = cloned\\n        \"BFS\"\\n        q = []\\n        q.append(head)\\n        while q:\\n            size = len(q)\\n            for _ in range(size):\\n                head = q.pop(0)\\n                if head.val == target.val:\\n                    return head\\n                if head.left:\\n                    q.append(head.left)\\n                if head.right:\\n                    q.append(head.right)\\n        \\n        # \"DFS\"\\n        # res = TreeNode(0)\\n        # def dfs(head,target):\\n        #     nonlocal res\\n        #     if head.val == target.val:\\n        #         res = head\\n        #         return\\n        #     if head.left:\\n        #         dfs(head.left,target)\\n        #     if head.right:\\n        #         dfs(head.right,target)\\n        # dfs(cloned,target)\\n        # return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480673,
                "title": "c-easy-solution-iterative-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        stack<TreeNode*> s;\\n        s.push(cloned);\\n        TreeNode* current=s.top();\\n        while(!s.empty())\\n        {\\n            current=s.top();\\n            s.pop();\\n            if(current->val==target->val)\\n                return current;\\n            \\n            if(current->left)\\n                s.push(current->left);\\n            if(current->right)\\n                s.push(current->right);\\n        }\\n        return current;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        stack<TreeNode*> s;\\n        s.push(cloned);\\n        TreeNode* current=s.top();\\n        while(!s.empty())\\n        {\\n            current=s.top();\\n            s.pop();\\n            if(current->val==target->val)\\n                return current;\\n            \\n            if(current->left)\\n                s.push(current->left);\\n            if(current->right)\\n                s.push(current->right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2372124,
                "title": "easy-java-solution-using-bfs-and-queue",
                "content": "```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(cloned);\\n        while(!q.isEmpty()){\\n            TreeNode curr = q.poll();\\n            if(curr.val == target.val)\\n                return curr;\\n            if(curr.left!=null)\\n                q.add(curr.left);\\n            if(curr.right!=null)\\n                q.add(curr.right);\\n        }\\n        return null;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(cloned);\\n        while(!q.isEmpty()){\\n            TreeNode curr = q.poll();\\n            if(curr.val == target.val)\\n                return curr;\\n            if(curr.left!=null)\\n                q.add(curr.left);\\n            if(curr.right!=null)\\n                q.add(curr.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2233274,
                "title": "c-easy-understanding",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\n  public:\\n    TreeNode * getTargetCopy(TreeNode * original, TreeNode * cloned, TreeNode * target) {\\n\\n      return traverse(cloned, target);\\n\\n    }\\n\\n  TreeNode * traverse(TreeNode * cloned, TreeNode * target) {\\n\\n    if (target == NULL)\\n      return NULL;\\n    if (cloned == NULL)\\n      return NULL;\\n\\n    if (target -> val == cloned -> val) {\\n\\n      return cloned;\\n    }\\n\\n    TreeNode * right = traverse(cloned -> right, target);\\n    TreeNode * left = traverse(cloned -> left, target);\\n\\n    return right ? right : left;\\n\\n  }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\n  public:\\n    TreeNode * getTargetCopy(TreeNode * original, TreeNode * cloned, TreeNode * target) {\\n\\n      return traverse(cloned, target);\\n\\n    }\\n\\n  TreeNode * traverse(TreeNode * cloned, TreeNode * target) {\\n\\n    if (target == NULL)\\n      return NULL;\\n    if (cloned == NULL)\\n      return NULL;\\n\\n    if (target -> val == cloned -> val) {\\n\\n      return cloned;\\n    }\\n\\n    TreeNode * right = traverse(cloned -> right, target);\\n    TreeNode * left = traverse(cloned -> left, target);\\n\\n    return right ? right : left;\\n\\n  }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2148312,
                "title": "c-simple-traversal-of-tree",
                "content": "```\\nclass Solution {\\n    \\n    private:\\n    \\n    TreeNode* solve(TreeNode* original, TreeNode* cloned, TreeNode* target)\\n    {\\n        if(original==NULL)\\n        {\\n            return NULL;\\n        }\\n        if(original->val==target->val)\\n        {\\n            return cloned;\\n        }\\n        \\n        TreeNode* left=solve(original->left,cloned->left,target);\\n        TreeNode* right=solve(original->right,cloned->right,target);\\n        \\n        if(left!=NULL)\\n        {\\n            return left;\\n        }\\n        else if(right!=NULL)\\n        {\\n            return right;\\n        }\\n        return NULL;\\n    }\\n    \\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        \\n        return solve(original,cloned,target);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    private:\\n    \\n    TreeNode* solve(TreeNode* original, TreeNode* cloned, TreeNode* target)\\n    {\\n        if(original==NULL)\\n        {\\n            return NULL;\\n        }\\n        if(original->val==target->val)\\n        {\\n            return cloned;\\n        }\\n        \\n        TreeNode* left=solve(original->left,cloned->left,target);\\n        TreeNode* right=solve(original->right,cloned->right,target);\\n        \\n        if(left!=NULL)\\n        {\\n            return left;\\n        }\\n        else if(right!=NULL)\\n        {\\n            return right;\\n        }\\n        return NULL;\\n    }\\n    \\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        \\n        return solve(original,cloned,target);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098991,
                "title": "intution-explanation-2-approach-space-optimisation-constant-space-solution",
                "content": "Intution : Since both trees are cloned of each other, that mean both are exact copy of each other in terms of arrangements, that mean inorder traversal along with pre or post order traversal of both the trees will be same (in terms of values). \\n\\nConsider them like 2 parllel universe(which are exact clones of each other), where each there exists a person A with same personality,occupation everything same but his name is different). So while traversing the tree just mirror each operation performed on cloned tree. When you find target node in the orignal tree then clonnedcurr will be your clone of target in the orignal tree.\\n\\nHope this helps.\\n\\n```\\n\\n# Appraoch 1 \\n\\nNormal DFS Based solution : \\n\\n\\n\\nclass Solution {\\n  public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n      \\n      return dfs(original,cloned,target);\\n      \\n\\t}\\n    public TreeNode dfs(TreeNode original,TreeNode cloned,TreeNode targetNInOrignal) {\\n            if(original==null)\\n                return null;\\n            if(original.equals(targetNInOrignal)) {\\n                return cloned;\\n            }\\n        \\n            TreeNode targetInCloned = null; \\n            if(targetInCloned==null && original.left!=null) {\\n                 targetInCloned = dfs(original.left,cloned.left,targetNInOrignal);\\n            }\\n\\n            if(targetInCloned==null && original.right!=null) {\\n               targetInCloned  = dfs(original.right,cloned.right,targetNInOrignal);\\n            }\\n            return targetInCloned;\\n    }\\n}\\n```\\nT(n) = O(n)\\nS(n) = O(n)\\n\\n# Approach 2\\n\\nUsed threaded binary tree to optimize for space. Rest of the apporach is same.\\n\\n```\\nclass Solution {\\n  public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n            return findClonedReference(original,cloned,target);\\n      \\n\\t}\\n    public TreeNode findClonedReference(TreeNode original,TreeNode cloned,TreeNode targetNInOrignal) {\\n        TreeNode curr = original;\\n        TreeNode clonedcurr = cloned;\\n        TreeNode output = null;\\n        \\n        while(curr!=null) {\\n            if(curr.equals(targetNInOrignal)) {\\n                output = clonedcurr;\\n            }\\n            if(curr.left==null) {\\n                curr=curr.right;\\n                clonedcurr = clonedcurr.right;\\n            }else {\\n                \\n                TreeNode temp = curr.left;\\n                TreeNode clonedTemp = clonedcurr.left;\\n                while(temp.right!=null && temp.right!=curr) {\\n                    temp = temp.right;\\n                    clonedTemp=clonedTemp.right;\\n                }\\n\\n                \\n                if(temp.right==curr) {\\n                    temp.right=null;\\n                    clonedTemp.right=null;\\n                    curr=curr.right;\\n                    clonedcurr=clonedcurr.right;\\n                }else {\\n                    temp.right=curr;\\n                    clonedTemp.right = clonedcurr;\\n                    curr=curr.left;\\n                    clonedcurr=clonedcurr.left;\\n                }\\n                \\n            }\\n            \\n        }\\n        return output;\\n\\n    }\\n}\\n```\\n\\nT(n) = O(n)\\nS(n) = O(1)\\n\\n\\nHope it helps.\\n```",
                "solutionTags": [],
                "code": "```\\n\\n# Appraoch 1 \\n\\nNormal DFS Based solution : \\n\\n\\n\\nclass Solution {\\n  public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n      \\n      return dfs(original,cloned,target);\\n      \\n\\t}\\n    public TreeNode dfs(TreeNode original,TreeNode cloned,TreeNode targetNInOrignal) {\\n            if(original==null)\\n                return null;\\n            if(original.equals(targetNInOrignal)) {\\n                return cloned;\\n            }\\n        \\n            TreeNode targetInCloned = null; \\n            if(targetInCloned==null && original.left!=null) {\\n                 targetInCloned = dfs(original.left,cloned.left,targetNInOrignal);\\n            }\\n\\n            if(targetInCloned==null && original.right!=null) {\\n               targetInCloned  = dfs(original.right,cloned.right,targetNInOrignal);\\n            }\\n            return targetInCloned;\\n    }\\n}\\n```\n```\\nclass Solution {\\n  public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n            return findClonedReference(original,cloned,target);\\n      \\n\\t}\\n    public TreeNode findClonedReference(TreeNode original,TreeNode cloned,TreeNode targetNInOrignal) {\\n        TreeNode curr = original;\\n        TreeNode clonedcurr = cloned;\\n        TreeNode output = null;\\n        \\n        while(curr!=null) {\\n            if(curr.equals(targetNInOrignal)) {\\n                output = clonedcurr;\\n            }\\n            if(curr.left==null) {\\n                curr=curr.right;\\n                clonedcurr = clonedcurr.right;\\n            }else {\\n                \\n                TreeNode temp = curr.left;\\n                TreeNode clonedTemp = clonedcurr.left;\\n                while(temp.right!=null && temp.right!=curr) {\\n                    temp = temp.right;\\n                    clonedTemp=clonedTemp.right;\\n                }\\n\\n                \\n                if(temp.right==curr) {\\n                    temp.right=null;\\n                    clonedTemp.right=null;\\n                    curr=curr.right;\\n                    clonedcurr=clonedcurr.right;\\n                }else {\\n                    temp.right=curr;\\n                    clonedTemp.right = clonedcurr;\\n                    curr=curr.left;\\n                    clonedcurr=clonedcurr.left;\\n                }\\n                \\n            }\\n            \\n        }\\n        return output;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048038,
                "title": "c-dfs-one-liner",
                "content": "```cpp\\nclass Solution {\\npublic:\\n\\tTreeNode* getTargetCopy(TreeNode* o, TreeNode* c, TreeNode* t) {\\n\\t\\treturn o ? o == t ? c : (TreeNode*)((uintptr_t)getTargetCopy(o->left, c->left, t) | (uintptr_t)getTargetCopy(o->right, c->right, t)) : 0;\\n\\t}\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n\\tTreeNode* getTargetCopy(TreeNode* o, TreeNode* c, TreeNode* t) {\\n\\t\\treturn o ? o == t ? c : (TreeNode*)((uintptr_t)getTargetCopy(o->left, c->left, t) | (uintptr_t)getTargetCopy(o->right, c->right, t)) : 0;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047476,
                "title": "90-faster-c-solution-using-dfs-inorder-traversal-intuitive-approach",
                "content": "__Thanks for checking out my solution\\nDo Upvote if it helped :))__\\n```\\nclass Solution\\n{ // Runtime: 532 ms, faster than 90.88% of C++ online submissions for Find a Corresponding Node of a Binary Tree in a Clone of That Tree.\\npublic:\\n    void find(TreeNode *o, TreeNode *res, TreeNode *t, TreeNode *&ans)   //Ans Node Stores the corresponding Node Address in the cloned tree\\n    {\\n        ios_base::sync_with_stdio(false);\\n        if (o == NULL) // Using inorder\\n            return;\\n        find(o->left, res->left, t, ans); // Go Left\\n        if (o == t)                       // Check Node\\n        {\\n            ans = res;                    // Here we check if the node is same as target\\n            return;                       // If Yes Store and return\\n        }\\n        find(o->right, res->right, t, ans); // Go Right\\n    }\\n    TreeNode *getTargetCopy(TreeNode *original, TreeNode *cloned, TreeNode *target)\\n    {\\n        ios_base::sync_with_stdio(false);              //Speed++\\n        TreeNode *ans;\\n        find(original, cloned, target, ans);\\n        return ans;\\n    }\\n};\\n```\\n__Time Complexity : O(N)\\nSpace Complexity : O(N)\\nN : Number of Nodes in the Tree__",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution\\n{ // Runtime: 532 ms, faster than 90.88% of C++ online submissions for Find a Corresponding Node of a Binary Tree in a Clone of That Tree.\\npublic:\\n    void find(TreeNode *o, TreeNode *res, TreeNode *t, TreeNode *&ans)   //Ans Node Stores the corresponding Node Address in the cloned tree\\n    {\\n        ios_base::sync_with_stdio(false);\\n        if (o == NULL) // Using inorder\\n            return;\\n        find(o->left, res->left, t, ans); // Go Left\\n        if (o == t)                       // Check Node\\n        {\\n            ans = res;                    // Here we check if the node is same as target\\n            return;                       // If Yes Store and return\\n        }\\n        find(o->right, res->right, t, ans); // Go Right\\n    }\\n    TreeNode *getTargetCopy(TreeNode *original, TreeNode *cloned, TreeNode *target)\\n    {\\n        ios_base::sync_with_stdio(false);              //Speed++\\n        TreeNode *ans;\\n        find(original, cloned, target, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047350,
                "title": "simple-3-liner-code-dfs-easy-solution-c",
                "content": "**Approach** :  We\\'ll use the concept which we used to find the ***max height of a binary tree*** and in the meanwhile just check if the node is our required node or not . if it is the node that we want then just return it ! that\\'s it \\n\\n\\n```\\n//Main code\\nTreeNode *find(TreeNode *cloned, TreeNode *target)\\n{\\n    if (cloned == NULL) return NULL;\\n    if (cloned->val == target->val)return cloned;   //if node matched then just return it\\n    return max(find(cloned->left, target), find(cloned->right, target));  //it not matched then traverse to other nodes using concept of maximum height \\n}\\n\\n\\n//it is only for taking new function\\n//TreeNode *getTargetCopy(TreeNode *original, TreeNode *cloned, TreeNode *target)\\n//{\\n   // TreeNode *ans = find(cloned, target);\\n   // return ans;\\n//}\\n```\\n\\n\\nDo upvote it since I am also a begineer and tried to contribute for the begineers",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n//Main code\\nTreeNode *find(TreeNode *cloned, TreeNode *target)\\n{\\n    if (cloned == NULL) return NULL;\\n    if (cloned->val == target->val)return cloned;   //if node matched then just return it\\n    return max(find(cloned->left, target), find(cloned->right, target));  //it not matched then traverse to other nodes using concept of maximum height \\n}\\n\\n\\n//it is only for taking new function\\n//TreeNode *getTargetCopy(TreeNode *original, TreeNode *cloned, TreeNode *target)\\n//{\\n   // TreeNode *ans = find(cloned, target);\\n   // return ans;\\n//}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2047336,
                "title": "c-most-elegant-solution",
                "content": "> It\\'s a no brainer as it is a binary tree. We simply need to traverse the entire tree till we find our match. \\nAs oppossed to a binary tree we cannot decide whether to go left or right, so we go through all the nodes and check for the values.\\n\\n> T(n) => O(N)\\nSc    => O(N) for recursion\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(!cloned || !original)return NULL;\\n        \\n        if(cloned->val == target->val)return cloned;\\n        \\n        TreeNode* findleft = getTargetCopy(original->left,cloned->left,target);\\n        if(findleft)return findleft;\\n        \\n        TreeNode* findright = getTargetCopy(original->right,cloned->right,target);\\n        if(findright)return findright;\\n        \\n        return NULL;\\n    }\\n};\\n```\\n\\n> Feel free to post your questions if any!",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(!cloned || !original)return NULL;\\n        \\n        if(cloned->val == target->val)return cloned;\\n        \\n        TreeNode* findleft = getTargetCopy(original->left,cloned->left,target);\\n        if(findleft)return findleft;\\n        \\n        TreeNode* findright = getTargetCopy(original->right,cloned->right,target);\\n        if(findright)return findright;\\n        \\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047335,
                "title": "c-full-explanation-with-without-duplicates-easy-to-understand",
                "content": "**1. Without Duplicates** using simple preorder traversal, finding the node using value of target node\\n\\n**CODE:**\\n```\\nTreeNode * ans=NULL;\\nvoid func(TreeNode *root,int t){\\n\\tif(!root)return;\\n\\tif(root->val == t){\\n\\t\\tans=root;\\n\\t\\treturn;\\n\\t}\\n\\tfunc(root->left,t);\\n\\tfunc(root->right,t);         \\n}\\nTreeNode* getTargetCopy(TreeNode* o, TreeNode* c, TreeNode* target) {\\n\\tfunc(c,target->val);\\n\\treturn ans;\\n}\\n```\\n**2. With Duplicates**\\nIn this approach, `findHeightWidth` function will fetch the height and width coordinates from original tree which are calculated as per following figure:\\n```\\n/*\\n                        Height\\n            7           0\\n          /   \\\\\\n         4     3        1\\n             /  \\\\\\n            6   19      2\\n\\nWidth:  -1  0  1  2\\n\\nSo coordinates for each node is:\\n7-> (0,0)\\n4-> (1,-1)\\n3-> (1,1)\\n6-> (2,0)\\n19-> (2,2)\\n\\n*/\\n```\\n\\nNow `findAns` is called on Cloned tree and passed h and w of target node. Now here we do opposite operations so that i and j becomes 0 when target node is fetched.\\n\\n**CODE:**\\n```\\nint h,w; //height and width\\nTreeNode* ans;\\nvoid findAns(TreeNode* root,int i,int j){\\n\\tif(!root)return;\\n\\tif(!i and !j){\\n\\t\\tans=root;\\n\\t\\treturn;\\n\\t}\\n\\tfindAns(root->left,i-1,j+1);\\n\\tfindAns(root->right,i-1,j-1);\\n}\\nvoid findHeightWidth(TreeNode* root,TreeNode * t,int i,int j){\\n\\tif(!root)return;\\n\\tif(root==t){\\n\\t\\th=i;\\n\\t\\tw=j;\\n\\t\\treturn;\\n\\t}\\n\\tfindHeightWidth(root->left,t,i+1,j-1);\\n\\tfindHeightWidth(root->right,t,i+1,j+1);\\n}\\nTreeNode* getTargetCopy(TreeNode* o, TreeNode* c, TreeNode* t) {\\n\\t//to find height,width coordinated of target node in original tree\\n\\tfindHeightWidth(o,t,0,0); \\n\\tfindAns(c,h,w);\\n\\treturn ans;\\n}\\n```\\n\\n**Found it helpfull? Pls do upvote ; )**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nTreeNode * ans=NULL;\\nvoid func(TreeNode *root,int t){\\n\\tif(!root)return;\\n\\tif(root->val == t){\\n\\t\\tans=root;\\n\\t\\treturn;\\n\\t}\\n\\tfunc(root->left,t);\\n\\tfunc(root->right,t);         \\n}\\nTreeNode* getTargetCopy(TreeNode* o, TreeNode* c, TreeNode* target) {\\n\\tfunc(c,target->val);\\n\\treturn ans;\\n}\\n```\n```\\n/*\\n                        Height\\n            7           0\\n          /   \\\\\\n         4     3        1\\n             /  \\\\\\n            6   19      2\\n\\nWidth:  -1  0  1  2\\n\\nSo coordinates for each node is:\\n7-> (0,0)\\n4-> (1,-1)\\n3-> (1,1)\\n6-> (2,0)\\n19-> (2,2)\\n\\n*/\\n```\n```\\nint h,w; //height and width\\nTreeNode* ans;\\nvoid findAns(TreeNode* root,int i,int j){\\n\\tif(!root)return;\\n\\tif(!i and !j){\\n\\t\\tans=root;\\n\\t\\treturn;\\n\\t}\\n\\tfindAns(root->left,i-1,j+1);\\n\\tfindAns(root->right,i-1,j-1);\\n}\\nvoid findHeightWidth(TreeNode* root,TreeNode * t,int i,int j){\\n\\tif(!root)return;\\n\\tif(root==t){\\n\\t\\th=i;\\n\\t\\tw=j;\\n\\t\\treturn;\\n\\t}\\n\\tfindHeightWidth(root->left,t,i+1,j-1);\\n\\tfindHeightWidth(root->right,t,i+1,j+1);\\n}\\nTreeNode* getTargetCopy(TreeNode* o, TreeNode* c, TreeNode* t) {\\n\\t//to find height,width coordinated of target node in original tree\\n\\tfindHeightWidth(o,t,0,0); \\n\\tfindAns(c,h,w);\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2047281,
                "title": "c-faster-than-83",
                "content": "```\\nTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n       \\n        if(original!=NULL)\\n        {    \\n             if(original==target)\\n                 return cloned;\\n            TreeNode *left=getTargetCopy(original->left,cloned->left,target);\\n            if(left!=NULL)\\n            {\\n                return left;\\n            }\\n            TreeNode *right=getTargetCopy(original->right,cloned->right,target);\\n            if(right!=NULL)\\n            {\\n                return right;\\n            }  \\n        }    \\n        return NULL;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n       \\n        if(original!=NULL)\\n        {    \\n             if(original==target)\\n                 return cloned;\\n            TreeNode *left=getTargetCopy(original->left,cloned->left,target);\\n            if(left!=NULL)\\n            {\\n                return left;\\n            }\\n            TreeNode *right=getTargetCopy(original->right,cloned->right,target);\\n            if(right!=NULL)\\n            {\\n                return right;\\n            }  \\n        }    \\n        return NULL;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2046967,
                "title": "find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree-java-100-faster",
                "content": "#### **Find a Corresponding Node of a Binary Tree in a Clone of that Tree**\\n```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original != null) {\\n            if (original == target) return cloned;\\n            TreeNode left = getTargetCopy(original.left, cloned.left, target);\\n            if (left != null) return left;\\n            TreeNode right = getTargetCopy(original.right, cloned.right, target);\\n            if (right != null) return right;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original != null) {\\n            if (original == target) return cloned;\\n            TreeNode left = getTargetCopy(original.left, cloned.left, target);\\n            if (left != null) return left;\\n            TreeNode right = getTargetCopy(original.right, cloned.right, target);\\n            if (right != null) return right;\\n        }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046737,
                "title": "java-code-also-works-for-follow-up-question",
                "content": "```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\nif (original == null || original == target)\\n\\t\\t\\treturn cloned;\\n\\t\\tTreeNode res = getTargetCopy(original.left, cloned.left, target);\\n\\t\\tif (res != null)\\n\\t\\t\\treturn res;\\n\\t\\treturn getTargetCopy(original.right, cloned.right, target);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\nif (original == null || original == target)\\n\\t\\t\\treturn cloned;\\n\\t\\tTreeNode res = getTargetCopy(original.left, cloned.left, target);\\n\\t\\tif (res != null)\\n\\t\\t\\treturn res;\\n\\t\\treturn getTargetCopy(original.right, cloned.right, target);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2046713,
                "title": "finding-from-path-works-with-duplicates-c-different-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string getPath(TreeNode* curr, TreeNode* t, string path){\\n        \\n\\t\\t//case where target not found\\n        if(curr==NULL)\\n            return path;\\n        \\n\\t\\t//case where target found\\n        if(t==curr)\\n            return path + \"F\";\\n        \\n        string a = getPath(curr->left, t, path+\"L\");\\n        string b = getPath(curr->right, t, path+\"R\");\\n        \\n\\t\\t//To return path with found target\\n        if(a[a.length()-1]==\\'F\\')\\n            return a;\\n        return b;\\n    }\\n    TreeNode* getNode(TreeNode* curr, string path, int ind){\\n        if(path[ind]==\\'F\\')\\n            return curr;\\n        \\n        if(path[ind]==\\'L\\')\\n            return getNode(curr->left,path,ind+1);\\n        \\n        if(path[ind]==\\'R\\')\\n            return getNode(curr->right,path,ind+1);\\n        \\n        return curr;\\n    }\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        \\n        string path = getPath(original, target, \"\"); // To calculate path from original tree and target\\n        return getNode(cloned, path,0); // use that target to find cloned node\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getPath(TreeNode* curr, TreeNode* t, string path){\\n        \\n\\t\\t//case where target not found\\n        if(curr==NULL)\\n            return path;\\n        \\n\\t\\t//case where target found\\n        if(t==curr)\\n            return path + \"F\";\\n        \\n        string a = getPath(curr->left, t, path+\"L\");\\n        string b = getPath(curr->right, t, path+\"R\");\\n        \\n\\t\\t//To return path with found target\\n        if(a[a.length()-1]==\\'F\\')\\n            return a;\\n        return b;\\n    }\\n    TreeNode* getNode(TreeNode* curr, string path, int ind){\\n        if(path[ind]==\\'F\\')\\n            return curr;\\n        \\n        if(path[ind]==\\'L\\')\\n            return getNode(curr->left,path,ind+1);\\n        \\n        if(path[ind]==\\'R\\')\\n            return getNode(curr->right,path,ind+1);\\n        \\n        return curr;\\n    }\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        \\n        string path = getPath(original, target, \"\"); // To calculate path from original tree and target\\n        return getNode(cloned, path,0); // use that target to find cloned node\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046556,
                "title": "c-easy-understanding-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(original == NULL) return NULL;\\n        if(original == target) return cloned;\\n        TreeNode* left = getTargetCopy(original->left,cloned->left,target);\\n        if(left != NULL) return left;\\n        TreeNode* right = getTargetCopy(original->right,cloned->right,target);\\n        if(right != NULL) return right;\\n        return NULL;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(original == NULL) return NULL;\\n        if(original == target) return cloned;\\n        TreeNode* left = getTargetCopy(original->left,cloned->left,target);\\n        if(left != NULL) return left;\\n        TreeNode* right = getTargetCopy(original->right,cloned->right,target);\\n        if(right != NULL) return right;\\n        return NULL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046513,
                "title": "c-2-approaches-dfs-bfs-with-comments",
                "content": "DFS  -> \\n\\n```\\n\\nclass Solution {\\npublic:\\n    TreeNode *ans=NULL;  //for storing the reference to required node.\\n    int val; //for storing the value we need to find\\n\\t\\n    void trav(TreeNode * root) //pre order traversal \\n    {\\n        if(!root) return; // if root==NULL then return\\n        if(root->val==val) // if found\\n        {\\n            ans=root; //update global variable and return\\n            return;\\n        }\\n        trav(root->left); \\n        trav(root->right);\\n    }\\n    \\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target)\\n    {\\n     val=target->val; //updating global variables to avoid passing on each function call\\n        trav(cloned); //traversing tree \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\nBFS using Queue -> \\n\\n```    \\nTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target)\\n    {\\n        queue<TreeNode *> q;\\n        q.push(cloned);  //pushing elements to queue for BFS\\n        while(q.size())\\n        {\\n            int sz=q.size();\\n            // processing elements of queue one by one\\n            for(int i=0;i<sz;i++)\\n            {\\n                TreeNode *cur=q.front();\\n                q.pop();\\n                if(cur->val==target->val) return cur;// if found then return\\n                if(cur->left) q.push(cur->left);\\n                if(cur->right) q.push(cur->right);\\n            }\\n        }\\n        return NULL; // considering case when not found. \\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode *ans=NULL;  //for storing the reference to required node.\\n    int val; //for storing the value we need to find\\n\\t\\n    void trav(TreeNode * root) //pre order traversal \\n    {\\n        if(!root) return; // if root==NULL then return\\n        if(root->val==val) // if found\\n        {\\n            ans=root; //update global variable and return\\n            return;\\n        }\\n        trav(root->left); \\n        trav(root->right);\\n    }\\n    \\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target)\\n    {\\n     val=target->val; //updating global variables to avoid passing on each function call\\n        trav(cloned); //traversing tree \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046295,
                "title": "c-dfs-bfs",
                "content": "DFS\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if (!original || original == target) return cloned;\\n        TreeNode* ans;\\n        return (ans = getTargetCopy(original->left , cloned->left , target))\\n              ? ans : getTargetCopy(original->right, cloned->right, target);\\n    }\\n};\\n```\\nBFS\\n```\\nclass Solution {\\n    using entry = pair<TreeNode*,TreeNode*>;\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        queue<entry> q;\\n        q.emplace(original, cloned);\\n        while (!q.empty()) {\\n            entry &e = q.front();\\n            TreeNode *node = e.first;\\n            if (node == target) return e.second;\\n            if (node-> left) q.emplace(node-> left, e.second-> left);\\n            if (node->right) q.emplace(node->right, e.second->right);\\n            q.pop();\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if (!original || original == target) return cloned;\\n        TreeNode* ans;\\n        return (ans = getTargetCopy(original->left , cloned->left , target))\\n              ? ans : getTargetCopy(original->right, cloned->right, target);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    using entry = pair<TreeNode*,TreeNode*>;\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        queue<entry> q;\\n        q.emplace(original, cloned);\\n        while (!q.empty()) {\\n            entry &e = q.front();\\n            TreeNode *node = e.first;\\n            if (node == target) return e.second;\\n            if (node-> left) q.emplace(node-> left, e.second-> left);\\n            if (node->right) q.emplace(node->right, e.second->right);\\n            q.pop();\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2046252,
                "title": "c-bfs",
                "content": "```\\n    //Method 1\\n    public TreeNode GetTargetCopy(TreeNode original, TreeNode cloned, TreeNode target)\\n    {\\n        if (original == null) return null;\\n        if (original == target) return cloned;\\n        TreeNode left = GetTargetCopy(original.left, cloned.left, target);\\n        TreeNode right = GetTargetCopy(original.right, cloned.right, target);\\n        return left != null ? left : right;\\n    }\\n\\n\\n\\n    //Method 2\\n    TreeNode result;\\n    public TreeNode GetTargetCopy(TreeNode original, TreeNode cloned, TreeNode target)\\n    {\\n        Inorder(original, cloned, target);\\n        return result;\\n    }\\n\\n    public void Inorder(TreeNode original, TreeNode cloned, TreeNode target)\\n    {\\n        if (original == null) return;\\n        Inorder(original.left, cloned.left, target);\\n        if (original == target)\\n            result = cloned;\\n        Inorder(original.right, cloned.right, target);\\n    }\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n    //Method 1\\n    public TreeNode GetTargetCopy(TreeNode original, TreeNode cloned, TreeNode target)\\n    {\\n        if (original == null) return null;\\n        if (original == target) return cloned;\\n        TreeNode left = GetTargetCopy(original.left, cloned.left, target);\\n        TreeNode right = GetTargetCopy(original.right, cloned.right, target);\\n        return left != null ? left : right;\\n    }\\n\\n\\n\\n    //Method 2\\n    TreeNode result;\\n    public TreeNode GetTargetCopy(TreeNode original, TreeNode cloned, TreeNode target)\\n    {\\n        Inorder(original, cloned, target);\\n        return result;\\n    }\\n\\n    public void Inorder(TreeNode original, TreeNode cloned, TreeNode target)\\n    {\\n        if (original == null) return;\\n        Inorder(original.left, cloned.left, target);\\n        if (original == target)\\n            result = cloned;\\n        Inorder(original.right, cloned.right, target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1763982,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        if cloned is None:\\n            return cloned\\n        if cloned.val == target.val:\\n            return cloned\\n        a = self.getTargetCopy(original, cloned.left, target)\\n        if a is not None:\\n            return a\\n        else:\\n            return self.getTargetCopy(original, cloned.right, target)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        if cloned is None:\\n            return cloned\\n        if cloned.val == target.val:\\n            return cloned\\n        a = self.getTargetCopy(original, cloned.left, target)\\n        if a is not None:\\n            return a\\n        else:\\n            return self.getTargetCopy(original, cloned.right, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1677569,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} original\\n * @param {TreeNode} cloned\\n * @param {TreeNode} target\\n * @return {TreeNode}\\n */\\nvar getTargetCopy = function(original, cloned, target) {\\n    function tra(o, c) {\\n        if(!o) return;\\n        if(o === target) return c;\\n        return tra(o.left, c.left) || tra(o.right, c.right);\\n    }\\n    return tra(original, cloned);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} original\\n * @param {TreeNode} cloned\\n * @param {TreeNode} target\\n * @return {TreeNode}\\n */\\nvar getTargetCopy = function(original, cloned, target) {\\n    function tra(o, c) {\\n        if(!o) return;\\n        if(o === target) return c;\\n        return tra(o.left, c.left) || tra(o.right, c.right);\\n    }\\n    return tra(original, cloned);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1646530,
                "title": "c-easy-recursion-dfs",
                "content": "**Upvote if you found solution helpful**\\n```C++\\nclass Solution\\n{\\npublic:\\n    TreeNode *ans;\\n    void solve(TreeNode *O, TreeNode *C, TreeNode *Key)\\n    {\\n        if (O != NULL)\\n        {\\n            solve(O->left, C->left, Key);\\n            if (O == Key)\\n            {\\n                ans = C;\\n            }\\n            solve(O->right, C->right, Key);\\n        }\\n    }\\n    TreeNode *getTargetCopy(TreeNode *original, TreeNode *cloned, TreeNode *target)\\n    {\\n        solve(original, cloned, target);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```C++\\nclass Solution\\n{\\npublic:\\n    TreeNode *ans;\\n    void solve(TreeNode *O, TreeNode *C, TreeNode *Key)\\n    {\\n        if (O != NULL)\\n        {\\n            solve(O->left, C->left, Key);\\n            if (O == Key)\\n            {\\n                ans = C;\\n            }\\n            solve(O->right, C->right, Key);\\n        }\\n    }\\n    TreeNode *getTargetCopy(TreeNode *original, TreeNode *cloned, TreeNode *target)\\n    {\\n        solve(original, cloned, target);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1416008,
                "title": "1-ms-faster-than-98-04-of-java-online-submissions",
                "content": "Its actually a very easy question , you should try it first, if failed then you can see the solution.\\nIts just finding a certain node, forget that there are two trees, you could just use the cloned tree and find the target node, either by using DFS || BFS.\\n```\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(original==null) return null;\\n        if(original==target){\\n            return cloned;\\n        }\\n        TreeNode lt=getTargetCopy(original.left,cloned.left,target);\\n        if(lt!=null)\\n            return lt;\\n        TreeNode rt=getTargetCopy(original.right,cloned.right,target);\\n        if(rt!=null)\\n            return rt;\\n        return null;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(original==null) return null;\\n        if(original==target){\\n            return cloned;\\n        }\\n        TreeNode lt=getTargetCopy(original.left,cloned.left,target);\\n        if(lt!=null)\\n            return lt;\\n        TreeNode rt=getTargetCopy(original.right,cloned.right,target);\\n        if(rt!=null)\\n            return rt;\\n        return null;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1316913,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode *res = NULL;\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(target==NULL || cloned==NULL)\\n            return NULL;\\n        \\n    if(cloned->val==target->val){\\n        res=cloned;\\n    }\\n    getTargetCopy(original,cloned->left,target);\\n    getTargetCopy(original,cloned->right,target);\\n    return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *res = NULL;\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(target==NULL || cloned==NULL)\\n            return NULL;\\n        \\n    if(cloned->val==target->val){\\n        res=cloned;\\n    }\\n    getTargetCopy(original,cloned->left,target);\\n    getTargetCopy(original,cloned->right,target);\\n    return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1133292,
                "title": "easy-to-understand-3-line-python-solution",
                "content": "(edit) Edited the solution to traverse both original and cloned trees, as per @blanquito \\'s suggestion\\n```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        if not original: return None\\n        if original is target: return cloned\\n        else: return self.getTargetCopy(original.left,cloned.left,target) or self.getTargetCopy(original.right,cloned.right,target)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        if not original: return None\\n        if original is target: return cloned\\n        else: return self.getTargetCopy(original.left,cloned.left,target) or self.getTargetCopy(original.right,cloned.right,target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1074454,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    public TreeNode GetTargetCopy(TreeNode original, TreeNode cloned, TreeNode target) {\\n        if (original == null)\\n            return null;\\n        \\n        if (original == target)\\n            return cloned;\\n        \\n        TreeNode l = GetTargetCopy(original.left, cloned.left, target),\\n                 r = GetTargetCopy(original.right, cloned.right, target);\\n        \\n        return l ?? r;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public TreeNode GetTargetCopy(TreeNode original, TreeNode cloned, TreeNode target) {\\n        if (original == null)\\n            return null;\\n        \\n        if (original == target)\\n            return cloned;\\n        \\n        TreeNode l = GetTargetCopy(original.left, cloned.left, target),\\n                 r = GetTargetCopy(original.right, cloned.right, target);\\n        \\n        return l ?? r;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1017001,
                "title": "c-bfs-solution-with-queue",
                "content": "```\\nTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n\\tqueue< pair<TreeNode*, TreeNode*> > q;\\n\\tq.push( { original, cloned } );\\n\\twhile (!q.empty()) {\\n\\t\\tauto cur = q.front();\\n\\t\\tq.pop();\\n\\t\\tif (cur.first == target)\\n\\t\\t\\treturn cur.second;\\n\\t\\tif (cur.first->left)\\n\\t\\t\\tq.push( { cur.first->left, cur.second->left } );\\n\\t\\tif (cur.first->right)\\n\\t\\t\\tq.push( { cur.first->right, cur.second->right } );\\n\\t}\\n\\treturn nullptr;\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nTreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n\\tqueue< pair<TreeNode*, TreeNode*> > q;\\n\\tq.push( { original, cloned } );\\n\\twhile (!q.empty()) {\\n\\t\\tauto cur = q.front();\\n\\t\\tq.pop();\\n\\t\\tif (cur.first == target)\\n\\t\\t\\treturn cur.second;\\n\\t\\tif (cur.first->left)\\n\\t\\t\\tq.push( { cur.first->left, cur.second->left } );\\n\\t\\tif (cur.first->right)\\n\\t\\t\\tq.push( { cur.first->right, cur.second->right } );\\n\\t}\\n\\treturn nullptr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 999014,
                "title": "easy-clear-solution-98-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* o, TreeNode* c, TreeNode* t) {\\n        ios::sync_with_stdio(0); cout.tie(0); cin.tie(0);\\n        if(o==nullptr)return nullptr;\\n        if(o==t)return c;\\n        TreeNode* left=getTargetCopy(o->left,c->left,t);\\n        if(left!=nullptr)return left;\\n        return getTargetCopy(o->right,c->right,t);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* o, TreeNode* c, TreeNode* t) {\\n        ios::sync_with_stdio(0); cout.tie(0); cin.tie(0);\\n        if(o==nullptr)return nullptr;\\n        if(o==t)return c;\\n        TreeNode* left=getTargetCopy(o->left,c->left,t);\\n        if(left!=nullptr)return left;\\n        return getTargetCopy(o->right,c->right,t);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 968833,
                "title": "c-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(!cloned || !original) return cloned;\\n        \\n        if(original == target)\\n            return cloned;\\n        \\n        const auto left = getTargetCopy(original -> left, cloned -> left, target);\\n        const auto right = getTargetCopy(original -> right, cloned -> right, target);   \\n        \\n        return left ? left : right;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(!cloned || !original) return cloned;\\n        \\n        if(original == target)\\n            return cloned;\\n        \\n        const auto left = getTargetCopy(original -> left, cloned -> left, target);\\n        const auto right = getTargetCopy(original -> right, cloned -> right, target);   \\n        \\n        return left ? left : right;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868581,
                "title": "simple-c-recursion",
                "content": "```\\nTreeNode* getTargetCopy(TreeNode* o, TreeNode* c, TreeNode* target) {\\n        \\n        if(o==NULL || target==NULL)\\n            return NULL;\\n        if(o==target)\\n            return c;\\n        else\\n        {\\n            TreeNode* temp = getTargetCopy(o->left,c->left,target);\\n            return (temp!=NULL)?temp:getTargetCopy(o->right,c->right,target);\\n        }\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nTreeNode* getTargetCopy(TreeNode* o, TreeNode* c, TreeNode* target) {\\n        \\n        if(o==NULL || target==NULL)\\n            return NULL;\\n        if(o==target)\\n            return c;\\n        else\\n        {\\n            TreeNode* temp = getTargetCopy(o->left,c->left,target);\\n            return (temp!=NULL)?temp:getTargetCopy(o->right,c->right,target);\\n        }\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 866864,
                "title": "python3-dfs-solution-beats-100-in-runtime",
                "content": "## This solution uses DFS for searching in cloned graph , as we already have node value there is no need to search in the original Graph.\\n![image](https://assets.leetcode.com/users/images/e83d394c-fdba-489d-bebb-b93b429f4043_1601206536.633203.png)\\n\\n```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        def traverse(node,target):\\n            if node:\\n                if node.val==target:return node\\n                else:\\n                    return traverse(node.left,target) or traverse(node.right,target)\\n        return traverse(cloned,target.val)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        def traverse(node,target):\\n            if node:\\n                if node.val==target:return node\\n                else:\\n                    return traverse(node.left,target) or traverse(node.right,target)\\n        return traverse(cloned,target.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851589,
                "title": "java-clean-recursion-explained-clearly",
                "content": "Since clone is a perfect copy of original, we can traverse both left & right sides together\\nin each recursive call. But how do we know if we found the target in cloned?\\n\\nIf original is the same reference value as target, then the cloned node must also contain\\nthe same val as target.val, hence we found the target in cloned! \\n\\nOn the other hand, if original is null, then cloned must also be null! We can combine these \\ntwo observations and come up with the base case in our code, if our original is null or original\\nis exactly the target, just return the cloned node.\\n\\nWhat if we have not reached a basecase? Then it\\'s time to explore both left and right sides!\\nSimply get the result of passing the left children of both original & cloned. If the result\\nof the left side is NOT null, then we found our cloned target & return it. \\n\\nIf the result on the left side is indeed null, we did not find out answer. So it is time to\\nexplore the right side! If the right side\\'s result is also null, then we just return null.\\nIf the right side\\'s result is NOT null, then we found our cloned target & return it.\\nIn either case, just return the result of the right side!\\n\\n```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        \\n        //Base Case: Out of bounds or reached target\\n        //If original is null, so is cloned, so you are returning clond as null\\n        //If original is the target, then cloned must also be the target\\n        if (original == null || original == target)\\n            return cloned;\\n        \\n        //Explore rest of the trees\\n        TreeNode leftSide = getTargetCopy(original.left, cloned.left, target);\\n        if (leftSide != null)\\n            return leftSide;\\n        \\n        return getTargetCopy(original.right, cloned.right, target);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        \\n        //Base Case: Out of bounds or reached target\\n        //If original is null, so is cloned, so you are returning clond as null\\n        //If original is the target, then cloned must also be the target\\n        if (original == null || original == target)\\n            return cloned;\\n        \\n        //Explore rest of the trees\\n        TreeNode leftSide = getTargetCopy(original.left, cloned.left, target);\\n        if (leftSide != null)\\n            return leftSide;\\n        \\n        return getTargetCopy(original.right, cloned.right, target);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847437,
                "title": "7-different-solutions",
                "content": "# BFS\\n- Normal Bfs\\n```python\\n    def getTargetCopyBFS(self, original, cloned, target):\\n        a, b, c, d = [original], [], [cloned], []\\n        while a:\\n            while a:\\n                i, j = a.pop(), c.pop()\\n                if i == target:\\n                    return j\\n                if i.left:\\n                    b.append(i.left)\\n                    d.append(j.left)\\n                if i.right:\\n                    b.append(i.right)\\n                    d.append(j.right)\\n            a, b, c, d = b, a, d, c\\n```\\n- Bfs in Zigzag Order\\nIn this way we are traversing the tree in a z-shape manner.\\n```python\\n    def getTargetCopyBFSZigzag(self, original, cloned, target):\\n        a, b, c, d, flag = [original], [], [cloned], [], True\\n        while a:\\n            while a:\\n                i, j = a.pop(), c.pop()\\n                if i == target:\\n                    return j\\n                if flag:\\n                    if i.left:\\n                        b.append(i.left)\\n                        d.append(j.left)\\n                    if i.right:\\n                        b.append(i.right)\\n                        d.append(j.right)\\n                else:\\n                    if i.right:\\n                        b.append(i.right)\\n                        d.append(j.right)\\n                    if i.left:\\n                        b.append(i.left)\\n                        d.append(j.left)\\n            a, b, c, d, flag = b, a, d, c, not flag\\n\\n\\n```\\n# DFS\\nActually if you take the recursive version of DFS into account, there would be another 3 ways to solve this quiz.\\nIn this post recursive version were ignored since they are too simple.\\n- Pre-Order\\n```python\\n    def getTargetCopyDfsPreOrder(self, original, cloned, target):\\n        s1, s2 = [], []\\n        while s1 or original:\\n            if original:\\n                if original == target:\\n                    return cloned\\n                s1.append(original)\\n                original = original.left\\n                s2.append(cloned)\\n                cloned = cloned.left\\n            else:\\n                original = s1.pop().right\\n                cloned = s2.pop().right\\n```\\n- In-Order\\n```python\\n    def getTargetCopyDfsInOrder(self, original, cloned, target):\\n        s1, s2 = [], []\\n        while s1 or original:\\n            if original:\\n                s1.append(original)\\n                original = original.left\\n                s2.append(cloned)\\n                cloned = cloned.left\\n            else:\\n                original = s1.pop()\\n                cloned = s2.pop()\\n                if original and original == target:\\n                    return cloned\\n                original = original.right\\n                cloned = cloned.right\\n```\\n- Post-Order\\n```python\\n    def getTargetCopyDfsPostOrder(self, original, cloned, target):\\n        s1, s2 = [], []\\n        while s1 or original:\\n            if original:\\n                s1.append((original, False))\\n                original = original.left\\n                s2.append((cloned, False))\\n                cloned = cloned.left\\n            else:\\n                original, o_flag = s1.pop()\\n                cloned, c_flag = s2.pop()\\n                if not o_flag:\\n                    s1.append((original, True))\\n                    s2.append((cloned, True))\\n                    original = original.right\\n                    cloned = cloned.right\\n                elif original and original == target:\\n                    return cloned\\n                else:\\n                    original = False\\n```\\n# Morris(Threading Tree)\\nIf we return instantaneously when the target is found we would get the Time-Out error. \\nThe reason is that the tree is modified and not restored.\\nTo prevent this error, we use a variable to save the return value and let the while loop run completely so that the tree is intact.\\n- Pre-Order\\n```python\\n    def getTargetCopyMorrisPreOrder(self, original, cloned, target):\\n        res = None\\n        while original:\\n            if original.left:\\n                m, t = cloned.left, original.left\\n                while t.right and t.right != original:\\n                    t = t.right\\n                    m = m.right\\n                if t.right:\\n                    original, cloned = original.right, cloned.right\\n                    t.right = None\\n                    m.right = None\\n                else:\\n                    t.right = original\\n                    m.right = cloned\\n                    if original == target:\\n                        res = cloned\\n                    original, cloned = original.left, cloned.left\\n            else:\\n                if original == target:\\n                    res = cloned\\n                original, cloned = original.right, cloned.right\\n        return res\\n```\\n- In-Order\\n```python\\n    def getTargetCopyMorrisInOrder(self, original, cloned, target):\\n        res = None\\n        while original:\\n            if original.left:\\n                m, t = cloned.left, original.left\\n                while t.right and t.right != original:\\n                    t = t.right\\n                    m = m.right\\n                if t.right:\\n                    if original == target:\\n                        res = cloned\\n                    original, cloned = original.right, cloned.right\\n                    t.right = None\\n                    m.right = None\\n                else:\\n                    t.right = original\\n                    m.right = cloned\\n                    original, cloned = original.left, cloned.left\\n            else:\\n                if original == target:\\n                    res = cloned\\n                original, cloned = original.right, cloned.right\\n        return res\\n```",
                "solutionTags": [],
                "code": "```python\\n    def getTargetCopyBFS(self, original, cloned, target):\\n        a, b, c, d = [original], [], [cloned], []\\n        while a:\\n            while a:\\n                i, j = a.pop(), c.pop()\\n                if i == target:\\n                    return j\\n                if i.left:\\n                    b.append(i.left)\\n                    d.append(j.left)\\n                if i.right:\\n                    b.append(i.right)\\n                    d.append(j.right)\\n            a, b, c, d = b, a, d, c\\n```\n```python\\n    def getTargetCopyBFSZigzag(self, original, cloned, target):\\n        a, b, c, d, flag = [original], [], [cloned], [], True\\n        while a:\\n            while a:\\n                i, j = a.pop(), c.pop()\\n                if i == target:\\n                    return j\\n                if flag:\\n                    if i.left:\\n                        b.append(i.left)\\n                        d.append(j.left)\\n                    if i.right:\\n                        b.append(i.right)\\n                        d.append(j.right)\\n                else:\\n                    if i.right:\\n                        b.append(i.right)\\n                        d.append(j.right)\\n                    if i.left:\\n                        b.append(i.left)\\n                        d.append(j.left)\\n            a, b, c, d, flag = b, a, d, c, not flag\\n\\n\\n```\n```python\\n    def getTargetCopyDfsPreOrder(self, original, cloned, target):\\n        s1, s2 = [], []\\n        while s1 or original:\\n            if original:\\n                if original == target:\\n                    return cloned\\n                s1.append(original)\\n                original = original.left\\n                s2.append(cloned)\\n                cloned = cloned.left\\n            else:\\n                original = s1.pop().right\\n                cloned = s2.pop().right\\n```\n```python\\n    def getTargetCopyDfsInOrder(self, original, cloned, target):\\n        s1, s2 = [], []\\n        while s1 or original:\\n            if original:\\n                s1.append(original)\\n                original = original.left\\n                s2.append(cloned)\\n                cloned = cloned.left\\n            else:\\n                original = s1.pop()\\n                cloned = s2.pop()\\n                if original and original == target:\\n                    return cloned\\n                original = original.right\\n                cloned = cloned.right\\n```\n```python\\n    def getTargetCopyDfsPostOrder(self, original, cloned, target):\\n        s1, s2 = [], []\\n        while s1 or original:\\n            if original:\\n                s1.append((original, False))\\n                original = original.left\\n                s2.append((cloned, False))\\n                cloned = cloned.left\\n            else:\\n                original, o_flag = s1.pop()\\n                cloned, c_flag = s2.pop()\\n                if not o_flag:\\n                    s1.append((original, True))\\n                    s2.append((cloned, True))\\n                    original = original.right\\n                    cloned = cloned.right\\n                elif original and original == target:\\n                    return cloned\\n                else:\\n                    original = False\\n```\n```python\\n    def getTargetCopyMorrisPreOrder(self, original, cloned, target):\\n        res = None\\n        while original:\\n            if original.left:\\n                m, t = cloned.left, original.left\\n                while t.right and t.right != original:\\n                    t = t.right\\n                    m = m.right\\n                if t.right:\\n                    original, cloned = original.right, cloned.right\\n                    t.right = None\\n                    m.right = None\\n                else:\\n                    t.right = original\\n                    m.right = cloned\\n                    if original == target:\\n                        res = cloned\\n                    original, cloned = original.left, cloned.left\\n            else:\\n                if original == target:\\n                    res = cloned\\n                original, cloned = original.right, cloned.right\\n        return res\\n```\n```python\\n    def getTargetCopyMorrisInOrder(self, original, cloned, target):\\n        res = None\\n        while original:\\n            if original.left:\\n                m, t = cloned.left, original.left\\n                while t.right and t.right != original:\\n                    t = t.right\\n                    m = m.right\\n                if t.right:\\n                    if original == target:\\n                        res = cloned\\n                    original, cloned = original.right, cloned.right\\n                    t.right = None\\n                    m.right = None\\n                else:\\n                    t.right = original\\n                    m.right = cloned\\n                    original, cloned = original.left, cloned.left\\n            else:\\n                if original == target:\\n                    res = cloned\\n                original, cloned = original.right, cloned.right\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 774600,
                "title": "c-recursion",
                "content": "I don\\'t know what the question means by \"Solve the problem if repeated values on the tree are allowed\", considering I am comparing the references so repeated values is not a concern to the code\\n\\n```\\npublic class Solution {\\n    public TreeNode GetTargetCopy(TreeNode original, TreeNode cloned, TreeNode target) {\\n        if (original == target) return cloned;\\n        TreeNode answer = null;\\n        if (original.right != null)\\n            answer = GetTargetCopy(original.right, cloned.right, target);\\n        if (answer == null && original.left != null) \\n            answer = GetTargetCopy(original.left, cloned.left, target);\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public TreeNode GetTargetCopy(TreeNode original, TreeNode cloned, TreeNode target) {\\n        if (original == target) return cloned;\\n        TreeNode answer = null;\\n        if (original.right != null)\\n            answer = GetTargetCopy(original.right, cloned.right, target);\\n        if (answer == null && original.left != null) \\n            answer = GetTargetCopy(original.left, cloned.left, target);\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 750718,
                "title": "c-recursive-easy-to-understand",
                "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\'\\'\\'\\n\\nclass Solution {\\n\\n\\tpublic:\\n\\n    TreeNode* ans=nullptr;\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(cloned){\\n            if(original==target){\\n                ans=cloned;\\n            }\\n            getTargetCopy(original->left,cloned->left,target);\\n            getTargetCopy(original->right,cloned->right,target);\\n        }\\n        return ans;\\n    }\\n\\t};\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\n\\tpublic:\\n\\n    TreeNode* ans=nullptr;\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(cloned){\\n            if(original==target){\\n                ans=cloned;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 592644,
                "title": "i-dont-know-why-it-got-more-dislikes-than-likes-pretty-simple-question-c",
                "content": "class Solution {\\npublic:\\n\\n\\n    void findNode(TreeNode* root1,TreeNode* tar,TreeNode* &ans)\\n    {\\n        if(root1==NULL)\\n            return;\\n        if(root1->val == tar->val)\\n            ans=root1;\\n        findNode(root1->left,tar,ans);\\n        findNode(root1->right,tar,ans);\\n    }\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target)    {\\n        TreeNode* ans = NULL;\\n        findNode(cloned,target,ans);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    void findNode(TreeNode* root1,TreeNode* tar,TreeNode* &ans)\\n    {\\n        if(root1==NULL)\\n            return;\\n        if(root1->val == tar->val)\\n            ans=root1;\\n        findNode(root1->left,tar,ans);\\n        findNode(root1->right,tar,ans);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 587141,
                "title": "java-accepted-code-with-clear-explanation-of-question-and-logic-behind-answer",
                "content": "OK !!\\nlets do this!!\\nthis question is first of all very badly formed and explained!!!\\n\\nlet me try if i can do better!\\nso we have been given three parameters!one orignal tree,one cloned tree and a target node with some value in it which we later on need to compare!!\\n\\nbut the part that is important is that even if the trees are cloned with same values ,their nodes(left and right values) are different!\\nbecause one memory location cannot store multiple values at the same time!!\\nso they may have the same values but they are stored in different memory locations!!\\nour task is to find a node in the cloned tree whose value is same as the target node!!\\n\\ntherefore we need simultaneous traversal!\\nwe need to traverse both the trees simultaneously and return the address of the cloned tree\\'s node (acc to the question).\\nso  now lets see my solution!\\n```\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original == null) return null;\\n        if (original.val == target.val) return cloned; // check if current node is what we are looking for\\n        TreeNode res = getTargetCopy(original.left, cloned.left, target); // go left in both trees\\n        if (res != null) return res;//if we have found the target then return it\\n        return getTargetCopy(original.right, cloned.right, target); // go right in both trees\\n    }\\n\\t```\\n\\t\\n\\t\\n\\t\\n\\tfirst we traverse left subtree!\\n\\tif we find it well and good we return the cloned tree node\\n\\telse we recusively traverse the right node!!\\n\\t\\n\\t\\n\\t\\n\\thope it helps!!\\n\\t\\n\\tlet me know if there is any doubt!!",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original == null) return null;\\n        if (original.val == target.val) return cloned; // check if current node is what we are looking for\\n        TreeNode res = getTargetCopy(original.left, cloned.left, target); // go left in both trees\\n        if (res != null) return res;//if we have found the target then return it\\n        return getTargetCopy(original.right, cloned.right, target); // go right in both trees\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 549878,
                "title": "python-simple-bfs-follow-up-solutions",
                "content": "# Solution 1\\n- The tree node values are unique, we can do simple BFS search over the `cloned` tree.\\n\\n```Python\\nclass Solution:\\n    def getTargetCopy(self, original, cloned, target):\\n        parents, children = [cloned], list()\\n        while parents:\\n            for p in parents:\\n                if p.val == target.val: return p\\n                if p.left: children.append(p.left)\\n                if p.right: children.append(p.right)\\n            parents = children\\n            children = list()\\n```\\n\\n# Solution 2\\n- If tree node values aren\\'t unique, we must compare the current branch with the target tree.\\n\\n```Python\\nclass Solution:\\n    def getTargetCopy(self, original, cloned, target):\\n        \\n        def is_equal(t1, t2):\\n            if not t1 and not t2: return True\\n            if not t1 or not t2: return False\\n            return (t1.val == t2.val) and is_equal(t1.left, t2.left) and is_equal(t1.right, t2.right)\\n        \\n        p, c = [cloned], list()\\n        while p:\\n            for p_i in p:\\n                if is_equal(p_i, target): return p_i\\n                if p_i.left: c.append(p_i.left)\\n                if p_i.right: c.append(p_i.right)\\n            p = c\\n            c = list()\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```Python\\nclass Solution:\\n    def getTargetCopy(self, original, cloned, target):\\n        parents, children = [cloned], list()\\n        while parents:\\n            for p in parents:\\n                if p.val == target.val: return p\\n                if p.left: children.append(p.left)\\n                if p.right: children.append(p.right)\\n            parents = children\\n            children = list()\\n```\n```Python\\nclass Solution:\\n    def getTargetCopy(self, original, cloned, target):\\n        \\n        def is_equal(t1, t2):\\n            if not t1 and not t2: return True\\n            if not t1 or not t2: return False\\n            return (t1.val == t2.val) and is_equal(t1.left, t2.left) and is_equal(t1.right, t2.right)\\n        \\n        p, c = [cloned], list()\\n        while p:\\n            for p_i in p:\\n                if is_equal(p_i, target): return p_i\\n                if p_i.left: c.append(p_i.left)\\n                if p_i.right: c.append(p_i.right)\\n            p = c\\n            c = list()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 539484,
                "title": "simple-clean-and-fast-python-solution-7-lines-beats-92",
                "content": "Simple idea here is that if we search both trees simultaneously and with the same algorithm (BFS) we will get to the two nodes we need at the same exact moment.\\nWe will use double-ended queue for BFS to do pops and pushes in O(1) time.\\nWe will store tuples in queue to keep the code dry.\\n\\nAlgorithm has O(N) time, O(N) space complexity. Enjoy!\\n\\n```\\n# IDEA: perform BFS on both original and cloned trees simultaneously using same queue and comparing original nodes to target\\n#       since trees are the same we will find target at exactly the same moment on both trees; O(N) time, O(N) space\\n#\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        que = collections.deque([(original, cloned)]) # start at the root\\n        while que:\\n            nodeOrig, nodeClon = que.popleft()\\n            if nodeOrig is target: # if original node is found - cloned node is our answer\\n                return nodeClon\\n            if nodeOrig.left:  que.append((nodeOrig.left, nodeClon.left))\\n            if nodeOrig.right: que.append((nodeOrig.right, nodeClon.right))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n# IDEA: perform BFS on both original and cloned trees simultaneously using same queue and comparing original nodes to target\\n#       since trees are the same we will find target at exactly the same moment on both trees; O(N) time, O(N) space\\n#\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        que = collections.deque([(original, cloned)]) # start at the root\\n        while que:\\n            nodeOrig, nodeClon = que.popleft()\\n            if nodeOrig is target: # if original node is found - cloned node is our answer\\n                return nodeClon\\n            if nodeOrig.left:  que.append((nodeOrig.left, nodeClon.left))\\n            if nodeOrig.right: que.append((nodeOrig.right, nodeClon.right))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537681,
                "title": "python-bfs",
                "content": "```\\ndef getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        q = collections.deque()\\n        q.append((original,cloned))\\n        while q:\\n            ornode, clnode = q.popleft()\\n            if ornode==target:\\n                return clnode\\n            if ornode.left: q.append((ornode.left, clnode.left))\\n            if ornode.right: q.append((ornode.right, clnode.right))\\n        return None\\n```",
                "solutionTags": [],
                "code": "```\\ndef getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        q = collections.deque()\\n        q.append((original,cloned))\\n        while q:\\n            ornode, clnode = q.popleft()\\n            if ornode==target:\\n                return clnode\\n            if ornode.left: q.append((ornode.left, clnode.left))\\n            if ornode.right: q.append((ornode.right, clnode.right))\\n        return None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 537655,
                "title": "a-few-solutions",
                "content": "Traverse trees `A` and `B` simultaneously to find and return the corresponding target `T` node.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun getTargetCopy(A: TreeNode?, B: TreeNode?, T: TreeNode?): TreeNode? {\\n        fun go(a: TreeNode? = A, b: TreeNode? = B): TreeNode? {\\n            if (a == T)\\n                return b\\n            var L = if (a?.left != null)  go(a?.left, b?.left)   else null\\n            var R = if (a?.right != null) go(a?.right, b?.right) else null\\n            return if (L != null) L else R\\n        }\\n        return go()\\n    }\\n}\\n```\\n\\n*Java*\\n```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode A, final TreeNode B, final TreeNode T) {\\n        if (A == null || B == null)\\n            return null;\\n        if (A == T)\\n            return B;\\n        TreeNode L = getTargetCopy(A.left, B.left, T);\\n        TreeNode R = getTargetCopy(A.right, B.right, T);\\n        if (L != null)\\n            return L;\\n        return R;\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet getTargetCopy = (A, B, T) => {\\n    let go = (a = A, b = B) => {\\n        if (a == T)\\n            return b;\\n        let L = a.left  ? go(a.left,  b.left)  : null,\\n            R = a.right ? go(a.right, b.right) : null;\\n        return L ? L : R;\\n    };\\n    return go();\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def getTargetCopy(self, A: TreeNode, B: TreeNode, T: TreeNode) -> TreeNode:\\n        def go(a = A, b = B):\\n            if a == T:\\n                return b\\n            L = go(a.left, b.left)   if a.left  else None\\n            R = go(a.right, b.right) if a.right else None\\n            return L if L else R\\n        return go()\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using fun = function<TreeNode*(TreeNode*, TreeNode*)>;\\n    TreeNode* getTargetCopy(TreeNode* A, TreeNode* B, TreeNode* T) {\\n        fun go = [&](auto a, auto b) {\\n            if (a == T)\\n                return b;\\n            auto L = a->left  ? go(a->left,  b->left)  : nullptr,\\n                 R = a->right ? go(a->right, b->right) : nullptr;\\n            return L ? L : R;\\n        };\\n        return go(A, B);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun getTargetCopy(A: TreeNode?, B: TreeNode?, T: TreeNode?): TreeNode? {\\n        fun go(a: TreeNode? = A, b: TreeNode? = B): TreeNode? {\\n            if (a == T)\\n                return b\\n            var L = if (a?.left != null)  go(a?.left, b?.left)   else null\\n            var R = if (a?.right != null) go(a?.right, b?.right) else null\\n            return if (L != null) L else R\\n        }\\n        return go()\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode A, final TreeNode B, final TreeNode T) {\\n        if (A == null || B == null)\\n            return null;\\n        if (A == T)\\n            return B;\\n        TreeNode L = getTargetCopy(A.left, B.left, T);\\n        TreeNode R = getTargetCopy(A.right, B.right, T);\\n        if (L != null)\\n            return L;\\n        return R;\\n    }\\n}\\n```\n```\\nlet getTargetCopy = (A, B, T) => {\\n    let go = (a = A, b = B) => {\\n        if (a == T)\\n            return b;\\n        let L = a.left  ? go(a.left,  b.left)  : null,\\n            R = a.right ? go(a.right, b.right) : null;\\n        return L ? L : R;\\n    };\\n    return go();\\n};\\n```\n```\\nclass Solution:\\n    def getTargetCopy(self, A: TreeNode, B: TreeNode, T: TreeNode) -> TreeNode:\\n        def go(a = A, b = B):\\n            if a == T:\\n                return b\\n            L = go(a.left, b.left)   if a.left  else None\\n            R = go(a.right, b.right) if a.right else None\\n            return L if L else R\\n        return go()\\n```\n```\\nclass Solution {\\npublic:\\n    using fun = function<TreeNode*(TreeNode*, TreeNode*)>;\\n    TreeNode* getTargetCopy(TreeNode* A, TreeNode* B, TreeNode* T) {\\n        fun go = [&](auto a, auto b) {\\n            if (a == T)\\n                return b;\\n            auto L = a->left  ? go(a->left,  b->left)  : nullptr,\\n                 R = a->right ? go(a->right, b->right) : nullptr;\\n            return L ? L : R;\\n        };\\n        return go(A, B);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892390,
                "title": "c-solution-runtime-386-ms-beats-98-98-memory-163-9-mb-beats-39-76",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    \\n    TreeNode * ans;\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(cloned == NULL){\\n            return cloned;\\n        }\\n        if (cloned->val == target->val){\\n            ans = cloned;\\n        }\\n        getTargetCopy(original,cloned->left,target);\\n         getTargetCopy(original,cloned->right,target);\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    \\n    TreeNode * ans;\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(cloned == NULL){\\n            return cloned;\\n        }\\n        if (cloned->val == target->val){\\n            ans = cloned;\\n        }\\n        getTargetCopy(original,cloned->left,target);\\n         getTargetCopy(original,cloned->right,target);\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360821,
                "title": "python3-iterative-and-recursive-dfs",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n), whenre n is the number of nodes in cloned tree\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(h), where h is the height of the cloned tree\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n                                                            #DFS\\n        stack = [(cloned)]\\n        while stack:\\n            n = stack.pop()\\n            if n.val == target.val: return n\\n            if n.left: stack.append(n.left)\\n            if n.right: stack.append(n.right)\\n                                                            #Recursive DFS\\n        if not original: return None\\n        if original is target: return cloned\\n        return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n                                                            #DFS\\n        stack = [(cloned)]\\n        while stack:\\n            n = stack.pop()\\n            if n.val == target.val: return n\\n            if n.left: stack.append(n.left)\\n            if n.right: stack.append(n.right)\\n                                                            #Recursive DFS\\n        if not original: return None\\n        if original is target: return cloned\\n        return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292045,
                "title": "very-basic-cpp-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\n    TreeNode* ans;\\nprivate:\\n    void sol(TreeNode* clo,TreeNode* tar){\\n        if(clo==NULL) return;\\n        if(clo->val==tar->val) ans = clo;\\n        sol(clo->left,tar);\\n        sol(clo->right,tar);\\n    }\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* org, TreeNode* clo, TreeNode* tar) {\\n        sol(clo,tar);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\n    TreeNode* ans;\\nprivate:\\n    void sol(TreeNode* clo,TreeNode* tar){\\n        if(clo==NULL) return;\\n        if(clo->val==tar->val) ans = clo;\\n        sol(clo->left,tar);\\n        sol(clo->right,tar);\\n    }\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* org, TreeNode* clo, TreeNode* tar) {\\n        sol(clo,tar);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147022,
                "title": "clean-python-pre-order-iterative",
                "content": "\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def getTargetCopy(self, original, cloned, target):\\n        stack = [(original, cloned)]\\n        \\n        while original != target:\\n            original, cloned = stack.pop()\\n\\n            if original:\\n                stack.append((original.right, cloned.right))\\n                stack.append((original.left, cloned.left))\\n        \\n        return cloned\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def getTargetCopy(self, original, cloned, target):\\n        stack = [(original, cloned)]\\n        \\n        while original != target:\\n            original, cloned = stack.pop()\\n\\n            if original:\\n                stack.append((original.right, cloned.right))\\n                stack.append((original.left, cloned.left))\\n        \\n        return cloned\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142071,
                "title": "c-using-recursion-to-search-for-target-in-left-and-right-subtree",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(original==NULL) return NULL;\\n        if(target==original) return cloned;\\n        TreeNode* ans1 = getTargetCopy(original->left,cloned->left,target);\\n        TreeNode* ans2 = getTargetCopy(original->right,cloned->right,target);\\n        if(ans1==NULL)return ans2;\\n        return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(original==NULL) return NULL;\\n        if(target==original) return cloned;\\n        TreeNode* ans1 = getTargetCopy(original->left,cloned->left,target);\\n        TreeNode* ans2 = getTargetCopy(original->right,cloned->right,target);\\n        if(ans1==NULL)return ans2;\\n        return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800621,
                "title": "java-3ms-59-20-faster-memory-usage-less-than-37-65",
                "content": "```\\nclass Solution {\\n    int res;\\n    TreeNode ans;\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        res = target.val;\\n        rec(cloned);\\n    return ans;\\n    }\\n    \\n    public  void rec(TreeNode root){\\n        if(root==null) return;\\n        if(root.val==res){\\n            ans=root;\\n            return;\\n        }\\n        rec(root.left);\\n        rec(root.right);\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/b490b122-fee3-4546-9bf2-dbc01d77afb3_1668096716.6910505.png)\\n",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    int res;\\n    TreeNode ans;\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        res = target.val;\\n        rec(cloned);\\n    return ans;\\n    }\\n    \\n    public  void rec(TreeNode root){\\n        if(root==null) return;\\n        if(root.val==res){\\n            ans=root;\\n            return;\\n        }\\n        rec(root.left);\\n        rec(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693301,
                "title": "cpp-easiest-implementation",
                "content": "```\\nTreeNode* ans(TreeNode* original,TreeNode* cloned,TreeNode* target,TreeNode* anss)\\n    {\\n         if(original!=NULL)\\n        {\\n          if(original->val==target->val)\\n               anss->left=cloned;\\n         ans(original->left,cloned->left,target,anss);\\n         ans(original->right,cloned->right,target,anss);\\n        }\\n        return anss->left;\\n    }\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        TreeNode* anss=new TreeNode();\\n        return ans(original,cloned,target,anss);\\n        \\n          \\n         \\n    }",
                "solutionTags": [],
                "code": "```\\nTreeNode* ans(TreeNode* original,TreeNode* cloned,TreeNode* target,TreeNode* anss)\\n    {\\n         if(original!=NULL)\\n        {\\n          if(original->val==target->val)\\n               anss->left=cloned;\\n         ans(original->left,cloned->left,target,anss);\\n         ans(original->right,cloned->right,target,anss);\\n        }\\n        return anss->left;\\n    }\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        TreeNode* anss=new TreeNode();\\n        return ans(original,cloned,target,anss);\\n        \\n          \\n         \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2565525,
                "title": "c-recursive-duplicated-allowed",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(original==NULL){return NULL;}\\n        if(original==target){\\n            return cloned;\\n        }\\n        TreeNode* a=getTargetCopy(original->left,cloned->left,target);\\n        if(a!=NULL){return a; }\\n        TreeNode* b=getTargetCopy(original->right,cloned->right,target);\\n        if(b!=NULL){return b;}\\n        return NULL;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(original==NULL){return NULL;}",
                "codeTag": "Java"
            },
            {
                "id": 2478278,
                "title": "java-solution",
                "content": "class Solution {\\n    \\n    TreeNode temp;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target){\\n        solve(original,target);\\n        solve(cloned,temp);\\n        return temp;\\n    }\\n    \\n    public void solve(TreeNode root,TreeNode target){\\n        if(root==null) return; \\n        \\n        if(target.val == root.val){\\n            temp = root;\\n            return;\\n        }\\n        solve(root.left, target);\\n        solve(root.right, target);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n    TreeNode temp;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target){\\n        solve(original,target);\\n        solve(cloned,temp);\\n        return temp;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2466572,
                "title": "python-easy-level-order-traversal",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        def levelOrder(root, target):\\n            if not root:\\n                return\\n            queue = []\\n            queue.append(root)\\n            while len(queue) != 0:\\n                root = queue.pop(0)\\n                if root.val == target.val:\\n                    return root\\n                if root.left:\\n                    queue.append(root.left)\\n                if root.right:\\n                    queue.append(root.right)\\n        return levelOrder(cloned, target)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        def levelOrder(root, target):\\n            if not root:\\n                return\\n            queue = []\\n            queue.append(root)\\n            while len(queue) != 0:\\n                root = queue.pop(0)\\n                if root.val == target.val:\\n                    return root\\n                if root.left:\\n                    queue.append(root.left)\\n                if root.right:\\n                    queue.append(root.right)\\n        return levelOrder(cloned, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441601,
                "title": "python-simple-recursive-solution",
                "content": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        if not original or not cloned:\\n            return None\\n        \\n        if cloned.val == target.val:\\n            return cloned\\n        \\n        return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        if not original or not cloned:\\n            return None\\n        \\n        if cloned.val == target.val:\\n            return cloned\\n        \\n        return self.getTargetCopy(original.left, cloned.left, target) or self.getTargetCopy(original.right, cloned.right, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361123,
                "title": "java-short-2ms-solution-faster-than-84-35",
                "content": "Runtime: 2 ms, faster than 84.35% of Java online submissions\\nMemory Usage: 50.2 MB, less than 87.26% of Java online submissions\\n```\\nclass Solution {\\n    int target = 0;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        this.target = target.val;\\n        return find(cloned);\\n    }\\n    \\n    TreeNode find(TreeNode root) {\\n        if (root == null) return null;\\n        if (root.val == target){\\n            return root;\\n        }\\n\\n        TreeNode left = find(root.left);\\n        TreeNode right = find(root.right);\\n        \\n        if (left != null) return left;\\n        else return right;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int target = 0;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        this.target = target.val;\\n        return find(cloned);\\n    }\\n    \\n    TreeNode find(TreeNode root) {\\n        if (root == null) return null;\\n        if (root.val == target){\\n            return root;\\n        }\\n\\n        TreeNode left = find(root.left);\\n        TreeNode right = find(root.right);\\n        \\n        if (left != null) return left;\\n        else return right;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359812,
                "title": "python-dfs-o-n",
                "content": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        def DFS(node1,node2):\\n            if node1==target:\\n                return node2\\n            if node1 and node1.left is None and node1.right is None:\\n                return\\n            \\n            res1 = DFS(node1.left,node2.left) if node1 else None\\n            if res1 is not None:\\n                return res1\\n            res2 = DFS(node1.right,node2.right) if node1 else None\\n            if res2 is not None:\\n                return res2\\n        res=DFS(original,cloned)\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        def DFS(node1,node2):\\n            if node1==target:\\n                return node2\\n            if node1 and node1.left is None and node1.right is None:\\n                return\\n            \\n            res1 = DFS(node1.left,node2.left) if node1 else None\\n            if res1 is not None:\\n                return res1\\n            res2 = DFS(node1.right,node2.right) if node1 else None\\n            if res2 is not None:\\n                return res2\\n        res=DFS(original,cloned)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2350251,
                "title": "c-solution-100-faster-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        TreeNode* c;\\n        if(cloned->val==target->val){\\n            return cloned;\\n        }\\n        else{\\n            if(cloned->left!=NULL){ c= getTargetCopy(original, cloned->left, target);\\n            if(c->val==target->val){\\n            return c;\\n        }\\n                                  }\\n        if(cloned->right!=NULL) {c= getTargetCopy(original, cloned->right, target);\\n             if(c->val==target->val){\\n            return c;\\n        }\\n                                }\\n        }\\n        return cloned;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        TreeNode* c;\\n        if(cloned->val==target->val){\\n            return cloned;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2347596,
                "title": "java-solution-1ms-runtime",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(cloned.val==target.val){\\n            return cloned;\\n        }\\n        \\n        \\n        TreeNode rightNode = null;\\n        TreeNode leftNode = null;\\n        \\n        if(cloned.left!=null){\\n            rightNode = getTargetCopy(original, cloned.left, target);\\n            if(rightNode!=null) return rightNode;\\n        }\\n        \\n        if(cloned.right!=null){\\n            leftNode = getTargetCopy(original, cloned.right, target);\\n            if(leftNode!=null) return leftNode;\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\n\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(cloned.val==target.val){\\n            return cloned;\\n        }\\n        \\n        \\n        TreeNode rightNode = null;\\n        TreeNode leftNode = null;\\n        \\n        if(cloned.left!=null){\\n            rightNode = getTargetCopy(original, cloned.left, target);\\n            if(rightNode!=null) return rightNode;\\n        }\\n        \\n        if(cloned.right!=null){\\n            leftNode = getTargetCopy(original, cloned.right, target);\\n            if(leftNode!=null) return leftNode;\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303052,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* ans;\\n    \\n    void solve(TreeNode* original, TreeNode* cloned, TreeNode* target){\\n        if(original==NULL)\\n            return;\\n        if(original==target){\\n            ans = cloned; return;\\n        }\\n        solve(original->left,cloned->left,target);\\n        solve(original->right,cloned->right,target);\\n    }\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        solve(original,cloned,target);\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode* ans;\\n    \\n    void solve(TreeNode* original, TreeNode* cloned, TreeNode* target){\\n        if(original==NULL)\\n            return;\\n        if(original==target){\\n            ans = cloned; return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2287480,
                "title": "c-solution-with-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(cloned);\\n        TreeNode *cur;\\n        \\n        while(!q.empty())\\n        {\\n            cur = q.front();\\n            q.pop();\\n            \\n            if(cur->val == target->val)\\n                break;\\n            \\n            if(cur->left)\\n                q.push(cur->left);\\n            \\n            if(cur->right)\\n                q.push(cur->right);\\n        }\\n            \\n        return cur;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        \\n        queue<TreeNode*> q;\\n        q.push(cloned);\\n        TreeNode *cur;\\n        \\n        while(!q.empty())\\n        {\\n            cur = q.front();\\n            q.pop();\\n            \\n            if(cur->val == target->val)\\n                break;\\n            \\n            if(cur->left)\\n                q.push(cur->left);\\n            \\n            if(cur->right)\\n                q.push(cur->right);\\n        }\\n            \\n        return cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2245771,
                "title": "simple-java-solution-using-static-variable",
                "content": "```class Solution {\\n    public static TreeNode ans=null;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n            \\n            if(original==target)\\n            {\\n             ans=cloned;   \\n             }\\n           \\n        if(original.left!=null )\\n            getTargetCopy(original.left,cloned.left,target);\\n        if(original.right!=null)\\n            getTargetCopy(original.right,cloned.right,target);\\n        \\n        return ans;\\n      \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```class Solution {\\n    public static TreeNode ans=null;\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n            \\n            if(original==target)\\n            {\\n             ans=cloned;   \\n             }\\n           \\n        if(original.left!=null )\\n            getTargetCopy(original.left,cloned.left,target);\\n        if(original.right!=null)\\n            getTargetCopy(original.right,cloned.right,target);\\n        \\n        return ans;\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2176190,
                "title": "easy-solution-java",
                "content": "static TreeNode r;\\n\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        \\n     if (original != null) {\\n            getTargetCopy(original.left, cloned.left, target);\\n            if (original == target)\\n                r= cloned;\\n            getTargetCopy(original.right, cloned.right, target);\\n        }\\n\\n        return r;\\n    }",
                "solutionTags": [],
                "code": "static TreeNode r;\\n\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        \\n     if (original != null) {\\n            getTargetCopy(original.left, cloned.left, target);\\n            if (original == target)\\n                r= cloned;\\n            getTargetCopy(original.right, cloned.right, target);\\n        }\\n\\n        return r;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2117609,
                "title": "java-solution",
                "content": "We will do a DFS on both the original & cloned tree simultaneously , if we find the target node in the original tree we will return it in the cloned tree.\\n\\nthings to consider:-\\n* we can\\'t compare value \\n* we have to compare pointers because if values will be same for more than one node it will not work.\\n\\nWe will use kinda Two-Pointer Approach  like one pointer p1 at original tree and another pointer p2 at cloned tree and will do the traversal.\\n\\n```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original == null) return null; //step 1\\n\\t\\t//Don\\'t compare value. Compare the object\\n        if (original == target) return cloned;  //step 2\\n        TreeNode left = getTargetCopy(original.left, cloned.left, target); //step 3\\n\\t\\t// early return if we already find it\\n        if (left != null) return left; //step 4\\n        return getTargetCopy(original.right, cloned.right, target); //step 5\\n    }\\n}\\n```\\n\\nAgain some imp things to note we are comparing objects/pointers so...\\nfor ex. if(original==target) .\\n\\n\\nexplanation of the code step wise:-\\n1. check if original is null then you gotta return null\\n2. compare \\'objects\\' target and original ...note both original and target are given as objects in the inputs ...and return cloned if both are equal . (these was comparison for root)\\n3. now comparison will be for left node by doing a dfs and storing the result in \\' left \\' by calling the same fn getTargetCopy\\n4. if we get the result in left only we will return it\\n5. otherwise we will move on to do dfs on the right sight by calling the fn getTargetCopy.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if (original == null) return null; //step 1\\n\\t\\t//Don\\'t compare value. Compare the object\\n        if (original == target) return cloned;  //step 2\\n        TreeNode left = getTargetCopy(original.left, cloned.left, target); //step 3\\n\\t\\t// early return if we already find it\\n        if (left != null) return left; //step 4\\n        return getTargetCopy(original.right, cloned.right, target); //step 5\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2081542,
                "title": "c-very-easy-to-understand",
                "content": "### Approach\\n- Simple **DFS (pre order traversal)**.\\n\\n### Code\\n```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\nprivate: \\n    void runPreorder(TreeNode* orgRoot, TreeNode* clnRoot, TreeNode* target, TreeNode* &ans) {\\n        if(orgRoot == NULL) return;\\n        if(orgRoot == target) {\\n            ans = clnRoot;\\n            return;\\n        }\\n        runPreorder(orgRoot->left, clnRoot->left, target, ans);\\n        runPreorder(orgRoot->right, clnRoot->right, target, ans);\\n    }\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        TreeNode* ans;\\n        runPreorder(original, cloned, target, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```cpp\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\n\\nclass Solution {\\nprivate: \\n    void runPreorder(TreeNode* orgRoot, TreeNode* clnRoot, TreeNode* target, TreeNode* &ans) {\\n        if(orgRoot == NULL) return;\\n        if(orgRoot == target) {\\n            ans = clnRoot;\\n            return;\\n        }\\n        runPreorder(orgRoot->left, clnRoot->left, target, ans);\\n        runPreorder(orgRoot->right, clnRoot->right, target, ans);\\n    }\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        TreeNode* ans;\\n        runPreorder(original, cloned, target, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051229,
                "title": "c-simple-dfs-o-n-o-1",
                "content": "**Approach:**\\n\\tSimple inorder traversal, just return cloned when we got the result otherwise go in recursion(DFS).\\n\\t**Time Complexity: O(N)\\n\\tSpace Complexity: O(1)**\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(!original) return NULL;\\n\\t\\t\\n\\t\\t// if we spot out target at current node\\n        if(cloned->val == target->val) return cloned;\\n\\t\\t\\n\\t\\t// if we found our target in left subtree\\n        TreeNode* temp = getTargetCopy(original->left,cloned->left,target);\\n        if(temp) return temp;\\n\\t\\t\\n\\t\\t// considering that my target will definitely be in right subtree\\n        return getTargetCopy(original->right,cloned->right,target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(!original) return NULL;\\n\\t\\t\\n\\t\\t// if we spot out target at current node\\n        if(cloned->val == target->val) return cloned;\\n\\t\\t\\n\\t\\t// if we found our target in left subtree\\n        TreeNode* temp = getTargetCopy(original->left,cloned->left,target);\\n        if(temp) return temp;\\n\\t\\t\\n\\t\\t// considering that my target will definitely be in right subtree\\n        return getTargetCopy(original->right,cloned->right,target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049589,
                "title": "c-simulation-approach-bfs",
                "content": "In this code, if there is same value on different Node, \\nthen simulation approach can still work. \\n\\nThe  idea is run two BFS for original tree and cloned tree in the same time.\\n\\n```C++\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        queue<TreeNode*> Q1;\\n        queue<TreeNode*> Q2;\\n        Q1.push(original);\\n        Q2.push(cloned);\\n        while(!Q1.empty()) {\\n            TreeNode* e1=Q1.front();\\n            TreeNode* e2=Q2.front();\\n            if(e1 == target) return e2; //return cloned node of target\\n            Q1.pop();\\n            Q2.pop();\\n            for(auto &c:{e1->left, e1->right})if(c!=nullptr) Q1.push(c);\\n            for(auto &c:{e2->left, e2->right})if(c!=nullptr) Q2.push(c);\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Simulation"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        queue<TreeNode*> Q1;\\n        queue<TreeNode*> Q2;\\n        Q1.push(original);\\n        Q2.push(cloned);\\n        while(!Q1.empty()) {\\n            TreeNode* e1=Q1.front();\\n            TreeNode* e2=Q2.front();\\n            if(e1 == target) return e2; //return cloned node of target\\n            Q1.pop();\\n            Q2.pop();\\n            for(auto &c:{e1->left, e1->right})if(c!=nullptr) Q1.push(c);\\n            for(auto &c:{e2->left, e2->right})if(c!=nullptr) Q2.push(c);\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049392,
                "title": "js-fast-and-easy-understanding-solution",
                "content": "```\\nvar getTargetCopy = function(origin, cloned, target){\\n    var arr = [cloned]\\n    while(arr.length){\\n        var node = arr.shift()\\n        if(node.val !==target.val){\\n           if(node.left) arr.push(node.left)\\n           if(node.right) arr.push(node.right)\\n        }\\n        else if(node.val === target.val) return node;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getTargetCopy = function(origin, cloned, target){\\n    var arr = [cloned]\\n    while(arr.length){\\n        var node = arr.shift()\\n        if(node.val !==target.val){\\n           if(node.left) arr.push(node.left)\\n           if(node.right) arr.push(node.right)\\n        }\\n        else if(node.val === target.val) return node;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2049330,
                "title": "python-dfs-solution",
                "content": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        def dfs(node,target_node):\\n            if node.val==target_node.val:\\n                return node # return the node if val of target node and current node are same\\n            found_node=None\\n\\t\\t\\t# Check for the left node\\n            if node.left: \\n                found_node=dfs(node.left,target_node)\\n\\t\\t\\t# Only check for the right node if the value is not found in left node\\n            if node.right and found_node==None: \\n                found_node=dfs(node.right,target_node)\\n            return found_node\\n        \\n        return dfs(cloned,target) # Pass cloned Tree and Target Node\\n```\\n**Time Complexity** : O(n)",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        def dfs(node,target_node):\\n            if node.val==target_node.val:\\n                return node # return the node if val of target node and current node are same\\n            found_node=None\\n\\t\\t\\t# Check for the left node\\n            if node.left: \\n                found_node=dfs(node.left,target_node)\\n\\t\\t\\t# Only check for the right node if the value is not found in left node\\n            if node.right and found_node==None: \\n                found_node=dfs(node.right,target_node)\\n            return found_node\\n        \\n        return dfs(cloned,target) # Pass cloned Tree and Target Node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049272,
                "title": "c-follow-up-answer",
                "content": "This is a solution to the follow-up question for repeated values. Feedback please!\\n```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(original == nullptr) {\\n            return nullptr;\\n        }\\n        if(original == target) {\\n            return cloned;\\n        } \\n        TreeNode* next = getTargetCopy(original->left, cloned->left, target);\\n        if(next != nullptr) {\\n            return next;\\n        }\\n        next = getTargetCopy(original->right, cloned->right, target);\\n        if(next != nullptr) {\\n            return next;\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n        if(original == nullptr) {\\n            return nullptr;\\n        }\\n        if(original == target) {\\n            return cloned;\\n        } \\n        TreeNode* next = getTargetCopy(original->left, cloned->left, target);\\n        if(next != nullptr) {\\n            return next;\\n        }\\n        next = getTargetCopy(original->right, cloned->right, target);\\n        if(next != nullptr) {\\n            return next;\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048706,
                "title": "java-very-easy-solution",
                "content": "```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(target == null || original == null || cloned == null) return null;\\n        \\n        if(original == target)return cloned;\\n        \\n        TreeNode right = getTargetCopy(original.right, cloned.right, target);\\n        if(right != null)return right;\\n        TreeNode left = getTargetCopy(original.left, cloned.left, target);\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(target == null || original == null || cloned == null) return null;\\n        \\n        if(original == target)return cloned;\\n        \\n        TreeNode right = getTargetCopy(original.right, cloned.right, target);\\n        if(right != null)return right;\\n        TreeNode left = getTargetCopy(original.left, cloned.left, target);\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048636,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* ans;\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n    if(cloned==NULL){\\n        return cloned;\\n        \\n    }\\n        if (target->val == cloned->val){\\n            ans= cloned;\\n        }\\n         getTargetCopy(original , cloned->left, target);\\n        \\n         getTargetCopy(original, cloned->right, target);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nPLEASE UPVOTE!!!",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* ans;\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n    if(cloned==NULL){\\n        return cloned;\\n        \\n    }\\n        if (target->val == cloned->val){\\n            ans= cloned;\\n        }\\n         getTargetCopy(original , cloned->left, target);\\n        \\n         getTargetCopy(original, cloned->right, target);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048616,
                "title": "c-dfs-traversal",
                "content": "Approach: Using DFS traversal\\nTime Complexity: O(n)  { n = total number of nodes in tree }\\n\\n```\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n\\t\\n        if(original == NULL || cloned == NULL) return NULL;\\n        \\n        if(original == target) return cloned;\\n        \\n        TreeNode* findLeft = getTargetCopy(original->left, cloned->left, target);\\n        if(findLeft) return findLeft;\\n        \\n        return getTargetCopy(original->right, cloned->right, target); \\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n    TreeNode* getTargetCopy(TreeNode* original, TreeNode* cloned, TreeNode* target) {\\n\\t\\n        if(original == NULL || cloned == NULL) return NULL;\\n        \\n        if(original == target) return cloned;\\n        \\n        TreeNode* findLeft = getTargetCopy(original->left, cloned->left, target);\\n        if(findLeft) return findLeft;\\n        \\n        return getTargetCopy(original->right, cloned->right, target); \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2048527,
                "title": "java-preorder-dfs-easy",
                "content": "```\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(original==null || original==target) return cloned;\\n        TreeNode ret = getTargetCopy(original.left, cloned.left, target);\\n        if(ret!=null) return ret;\\n        return getTargetCopy(original.right, cloned.right, target);\\n    }\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\npublic final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(original==null || original==target) return cloned;\\n        TreeNode ret = getTargetCopy(original.left, cloned.left, target);\\n        if(ret!=null) return ret;\\n        return getTargetCopy(original.right, cloned.right, target);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2048417,
                "title": "java-easy-solution",
                "content": "```\\n IF you like the solution please upvote\\n \\n \\nclass Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(original==null || cloned==null) return original;\\n        \\n        if(original==target && (cloned.val==target.val)){\\n\\n                return cloned;\\n            \\n        }\\n        TreeNode l=getTargetCopy(original.left,cloned.left,target);\\n        TreeNode r=getTargetCopy(original.right,cloned.right,target);\\n        \\n        return (l==null?r:l);\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "class Solution {\\n    public final TreeNode getTargetCopy(final TreeNode original, final TreeNode cloned, final TreeNode target) {\\n        if(original==null || cloned==null) return original;\\n        \\n        if(original==target && (cloned.val==target.val)){\\n\\n                return cloned;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2048411,
                "title": "simple-python-9-lines-of-code-iterative-way-easy-to-understand-o-n-time-space-complexity",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        nodes=[(original,cloned)]\\n        while nodes:\\n            curr_node,curr_clone=nodes.pop(0)\\n            if not curr_node:\\n                continue\\n            \\n            if curr_node is target:\\n                return curr_clone\\n            \\n            nodes.append((curr_node.left,curr_clone.left))\\n            nodes.append((curr_node.right,curr_clone.right))\\n```\\nUpvote if you find it usefuf !\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n    def getTargetCopy(self, original: TreeNode, cloned: TreeNode, target: TreeNode) -> TreeNode:\\n        nodes=[(original,cloned)]\\n        while nodes:\\n            curr_node,curr_clone=nodes.pop(0)\\n            if not curr_node:\\n                continue\\n            \\n            if curr_node is target:\\n                return curr_clone\\n            \\n            nodes.append((curr_node.left,curr_clone.left))\\n            nodes.append((curr_node.right,curr_clone.right))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1833595,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 1566720,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 1693306,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 1570279,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 1566980,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 2017041,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 1574563,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 1728245,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 2067959,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 2046934,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 1833595,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 1566720,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 1693306,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 1570279,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 1566980,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 2017041,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 1574563,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 1728245,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 2067959,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            },
            {
                "id": 2046934,
                "content": [
                    {
                        "username": "Msey",
                        "content": "Leetcode motivates us learning new languages by force lol\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for May, Day 17.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS: Recursive Inorder Traversal.\n\n  \n**Approach 2:** DFS: Iterative Inorder Traversal.\n\n  \n**Approach 3:** BFS: Iterative Traversal.\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "alexeytatarchuk",
                        "content": "Is there any reason why Golang was not allowed for this question?)"
                    },
                    {
                        "username": "Zimzozaur",
                        "content": "Good question"
                    },
                    {
                        "username": "yashovardhan99",
                        "content": "Is there any reason why Kotlin was not allowed for this question? Given that the Kotlin solution will be very similar to Java, I don\\'t see any reason not to allow Kotlin for this question."
                    },
                    {
                        "username": "Yarin1",
                        "content": "interested why some languages including C are not shown in this question"
                    },
                    {
                        "username": "Ak_15",
                        "content": "for creating node and referring node values in c needs more functions and pointers bruh..but in java see those comment line...that\\'s all very few lines of code\\n"
                    },
                    {
                        "username": "RandomPerson344352",
                        "content": "What are we supposed to use the original tree for?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "[@waz007](/waz007) For this problem, The values of the nodes of the tree are unique."
                    },
                    {
                        "username": "waz007",
                        "content": "Hint: What if there are multiple nodes with the same value as target? And we\\'re interested in the exact corresponding TreeNode in cloned as the one referenced within original?"
                    },
                    {
                        "username": "Michael_Teng6",
                        "content": "hahahahahaha"
                    },
                    {
                        "username": "namesake_copy",
                        "content": "please support golang in the ide like the rest of the problems :pray:"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "user1177lt",
                        "content": "why  swift is not available for this problem?\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "The point of this problem really evades me. It would be interesting to solve the follow up question, however."
                    }
                ]
            }
        ]
    }
]