[
    {
        "title": "Minimum Number of Moves to Make Palindrome",
        "question_content": "You are given a string s consisting only of lowercase English letters.\nIn one move, you can select any two adjacent characters of s and swap them.\nReturn the minimum number of moves needed to make s a palindrome.\nNote that the input will be generated such that s can always be converted to a palindrome.\n&nbsp;\nExample 1:\n\nInput: s = \"aabb\"\nOutput: 2\nExplanation:\nWe can obtain two palindromes from s, \"abba\" and \"baab\". \n- We can obtain \"abba\" from s in 2 moves: \"aabb\" -> \"abab\" -> \"abba\".\n- We can obtain \"baab\" from s in 2 moves: \"aabb\" -> \"abab\" -> \"baab\".\nThus, the minimum number of moves needed to make s a palindrome is 2.\n\nExample 2:\n\nInput: s = \"letelt\"\nOutput: 2\nExplanation:\nOne of the palindromes we can obtain from s in 2 moves is \"lettel\".\nOne of the ways we can obtain it is \"letelt\" -> \"letetl\" -> \"lettel\".\nOther palindromes such as \"tleelt\" can also be obtained in 2 moves.\nIt can be shown that it is not possible to obtain a palindrome in less than 2 moves.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 2000\n\ts consists only of lowercase English letters.\n\ts can be converted to a palindrome using a finite number of moves.",
        "solutions": [
            {
                "id": 1847011,
                "title": "c-2-pointers-with-detail-proof-and-explanation",
                "content": "In this post I \\'m not trying to give the most efficient algorithm or the simplest code. I just try to explain the essence of the problem.\\n\\nA palindrome is an axial symmetry string. Every position holds the same letter with its position symmetry. \\n\\n<img src=\"https://assets.leetcode.com/users/images/05b7eb94-bdf5-409a-b96a-6daf13cdbefb_1647201205.0560412.png\" alt=\"drawing\" width=\"700\"/>\\n\\n\\n\\nThe most common idea that we can come up with is using two pointers for the left end and right end. If the current two letters are the same, we advance the pointer. If not, we search for the nearest letter that will make them same and swap it. Look at the following example. \\n1. The current two letters \\'a\\' and \\'d\\' are different. \\n2. We need to exchange one of them to be the same with the other. Notice here, you may keep either one of them. Though the final string may be different, the count of moves we spend are equal(you\\'ll see that later). Here let\\'s keep the right end letter \\'d\\' and search for the nearest \\'d\\' from the left end.\\n\\n<img src=\"https://assets.leetcode.com/users/images/7b842f9f-2350-4517-aebf-ee9483ee151b_1647201247.1059253.png\" alt=\"drawing\" width=\"700\"/>\\n\\n3. After we find the nearest \\'d\\', we need to swap it to the 0-position.\\n\\n<img src=\"https://assets.leetcode.com/users/images/3b3270d3-5637-4232-9cc8-c4f5fae42ae1_1647201266.464941.png\" alt=\"drawing\" width=\"700\"/>\\n\\n4. We advance the two pointers and repeat the same steps until the two pointers meet.\\n\\n<img src=\"https://assets.leetcode.com/users/images/d1ef03b5-8b45-4a93-a157-7316f3886cb4_1647201281.6635847.png\" alt=\"drawing\" width=\"700\"/>\\n\\n\\nI believe the aforementioned method is easy to understand. However, the difficulty is how we can know the method leads to the minimum moves. Can we convert the string to an arbitrary palindrome with minimal moves? If not, what kind of string we can convert to with minimal moves?\\n\\n**The key point is relative order between the letters.**\\n\\nSince the palindrome is axial symmetry, the same letter pair in the left part and right part must have the opposite relative order. So if two letter pairs have the same relative order, you can\\'t avoid swapping them. In the meantime, if two letter pairs already have the opposite relative order, you should avoid swapping them, or you\\'ll introduce redundant moves and lead to non-optimal solution.\\n\\nLet\\'s look at the example now. All the letters in the left part and right part have the same order. \\n\\n<img src=\"https://assets.leetcode.com/users/images/b0cb65ed-38a6-4b55-aa58-d7ebfbc76006_1647201297.2784958.png\" alt=\"drawing\" width=\"700\"/>\\n\\nSo you need to swap letters to make all the letter pairs in left and right opposite.  You don\\'t have to start from the end, and you can convert either left part or right part. Though this can lead to different palindrome, they all cost the same moves. See the below moves which randomly select the letter pair to swap. After 6 moves, it ends with a different palindrome compared to the former solution.\\n\\n<img src=\"https://assets.leetcode.com/users/images/e94bd00b-3354-4107-a134-efe9110d528d_1647201351.8659885.png\" alt=\"drawing\" width=\"300\"/>\\n\\nWhen we say \"randomly\" here, it means the order of the letter pair we swap. In fact, you can see that all the letter pairs we swap are exactly the combination of the 4 letters \\'abcd\\'. That\\'s why we need 6 moves. We swap every letter pair because in this example, all the letter pair from left and right have the same order. So they all need to be swapped once each. \\nLet\\'s look at another example. \\n\\n<img src=\"https://assets.leetcode.com/users/images/0a16b279-dff9-41fb-982a-f46696a80c1e_1647201374.874811.png\" alt=\"drawing\" width=\"700\"/>\\n\\nIn this example, let\\'s compare the letter pairs relative order in left and right side.\\n(a, b) -- (b, a) -- opposite\\n(a, c) -- (c, a) -- opposite\\n(a, d) -- (a, d) -- same\\n(b, c) -- (b, c) -- same\\n(b, d) -- (b, d) -- same\\n(c, d) -- (c, d) -- same\\nSo, we need to swap 4 letter pairs at least.\\n\\nWe see that (a, b) and (a, c) pair already have the opposite order in the left and right side. So they don\\'t need to be swapped again. But for all the other 4 letter pairs, they still need to be swapped. During your solution you should avoid swapping the letter pair that are already in their right order. \\nSee below, you should not try to swap (c,d) first, which will cause (c, a) be swapped. The same with (b, d).\\n\\n<img src=\"https://assets.leetcode.com/users/images/770e6660-c9f2-447b-be4b-44127be57754_1647201397.2791355.png\" alt=\"drawing\" width=\"700\"/>\\n\\n\\nSo you can swap (a,d) or (b,c) either you like.\\n\\n\\n<img src=\"https://assets.leetcode.com/users/images/2545dcef-6b66-4996-bed8-f6c2cb58a7bc_1647201429.7843585.png\" alt=\"drawing\" width=\"500\"/>\\n\\nAfter 4 moves, we get to the end.\\n\\nTill now, let\\'s answer the question posed earlier. What kind of palindrome can we convert to with minimal moves? The answer should be the palindromes that keep the letter pair order which have already met the conditions. \\nIn the above example \"abcdbcad\", palindromes like \"cabddbac\", \"bacddcab\" are definitely impossible with minimal moves to convert to. Because they require to swap (a,c), (a, b) which are already in good state.\\n\\nLet\\'s try a little more tricky example. The letters are not located on their target side. So what we should keep in mind is just do the necessary swap. \\n\\n<img src=\"https://assets.leetcode.com/users/images/43b6273c-3ff4-458d-a93b-f51f15c17eec_1647201462.2549217.png\" alt=\"drawing\" width=\"700\"/>\\n\\nFirst, we need to know which letter belongs to which side. We should choose the closest letters to each side in order to reduce the moves. Green ones belong to the left side while blue ones belong to the right side.\\n\\n<img src=\"https://assets.leetcode.com/users/images/9cdeae3b-e49d-44f7-97b8-488b3c4af38e_1647201475.2718742.png\" alt=\"drawing\" width=\"700\"/>\\n\\nNow, besides keeping the relative orders, we still need to think about the side. We can not avoid the moves that swap all the blue ones to the right of the green ones.\\n\\n<img src=\"https://assets.leetcode.com/users/images/97d0aa9e-c8a5-4748-8112-f1f91df983e8_1647201505.9667459.png\" alt=\"drawing\" width=\"700\"/>\\n\\n\\nFinally, let\\'s see why the two pointers algorithm work well. See below, if you keep right end \\'d\\' still, you know that all the other letters are to its left. So when you find and swap the nearest \\'d\\' to left end , you are sure that every single swap you make isn\\'t unnecessary, because \\'d\\' should be in front of all of them. \\n\\n<img src=\"https://assets.leetcode.com/users/images/52baf247-4204-45c6-b445-04b31619e35b_1647201520.1659758.png\" alt=\"drawing\" width=\"700\"/>\\n\\n\\nAfter the whole idea is clear, let\\'s talk a little bit about a special case we need to notice. When the string length is odd, there must be a letter that has no partner. See the following example, the \\'z\\' has no counterpart. So when we try to search \\'z\\' from the left end, we will end up meeting the right end pointer q. In that case, we know \\'z\\' should be the centerpoint of the result. \\n\\n<img src=\"https://assets.leetcode.com/users/images/cd584ade-5e37-4873-b1bc-c8edba1057db_1647201537.4622815.png\" alt=\"drawing\" width=\"700\"/>\\n\\nYou can record the position of \\'z\\' and advance the q pointer. At the end of the whole process, you can swap \\'z\\' to the centerpoint. Notice here, you should avoid trying to swap the \\'z\\' to the center before the whole process ends. That is because at this time you can\\'t guarantee all the swap you do is necessary. See the example below. The green \\'d\\' is swapped to the right side of \\'z\\' which is an unnecessary cost, because it should be on the left size at the end. However, when you do this after the whole process ends, you won\\'t have this problem.\\n<img src=\"https://assets.leetcode.com/users/images/96fe39f1-06bd-4a38-8344-0e643a562187_1653135480.8935752.png\" alt=\"drawing\" width=\"700\"/>\\n\\n```\\nindrome(string s) {\\n     \\n        int l = 0;\\n        int r = s.length() - 1;\\n\\n        int count = 0;\\n        int center_i = -1;\\n        \\n        while (l < r) {\\n            if (s[l] == s[r]) {\\n                l++;\\n                r--;\\n                continue;\\n            }\\n\\n            int k = l + 1;\\n            for (; k < r; k++) {\\n                if (s[k] == s[r]) {\\n                    break;\\n                }\\n            }\\n\\n            if (k == r) {\\n                center_i = r;\\n                r--;\\n                continue;\\n            }\\n\\n            for (int j = k; j > l; j--) {\\n                swapChar(j, j - 1);\\n                count++;\\n            }\\n            \\n            l++;\\n            r--;\\n        }\\n        \\n        if (center_i != -1) {\\n            count += (center_i - s.size() / 2);\\n        } \\n     \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nindrome(string s) {\\n     \\n        int l = 0;\\n        int r = s.length() - 1;\\n\\n        int count = 0;\\n        int center_i = -1;\\n        \\n        while (l < r) {\\n            if (s[l] == s[r]) {\\n                l++;\\n                r--;\\n                continue;\\n            }\\n\\n            int k = l + 1;\\n            for (; k < r; k++) {\\n                if (s[k] == s[r]) {\\n                    break;\\n                }\\n            }\\n\\n            if (k == r) {\\n                center_i = r;\\n                r--;\\n                continue;\\n            }\\n\\n            for (int j = k; j > l; j--) {\\n                swapChar(j, j - 1);\\n                count++;\\n            }\\n            \\n            l++;\\n            r--;\\n        }\\n        \\n        if (center_i != -1) {\\n            count += (center_i - s.size() / 2);\\n        } \\n     \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822174,
                "title": "c-python-short-greedy-solution",
                "content": "# **Explanation**\\nConsidering the first and the last char in final palindrome.\\nIf they are neither the first nor the last char in the initial string,\\nyou must waste some steps:\\nAssume start with \"...a....a..\"\\n\".a.......a.\" can be ealier completed thand \"a.........a\".\\n\\nThen compare the situation \"a....b..a...b\"\\nIt takes same number of steps to \"ab.........ba\" and \"ba.........ab\".\\nSo  we can actually greedy move the characters to match string prefix.\\n\\nOther reference: https://www.codechef.com/problems/ENCD12\\n\\n# **Complexity**\\nTime `O(n^2)`, can be improved to `O(nlogn)` by segment tree\\nSpace `O(n)`\\n\\n**C++**\\n```cpp\\n    int minMovesToMakePalindrome(string s) {\\n        int res = 0;\\n        while (s.size()) {   \\n            int i = s.find(s.back());\\n            if (i == s.size() - 1)\\n                res += i / 2;\\n            else\\n                res += i, s.erase(i, 1);\\n            s.pop_back();\\n        }\\n        return res; \\n    }\\n```\\n**Python**\\n```py\\n    def minMovesToMakePalindrome(self, s):\\n        s = list(s)\\n        res = 0\\n        while s:\\n            i = s.index(s[-1])\\n            if i == len(s) - 1:\\n                res += i / 2\\n            else:\\n                res += i\\n                s.pop(i)\\n            s.pop()\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\n    int minMovesToMakePalindrome(string s) {\\n        int res = 0;\\n        while (s.size()) {   \\n            int i = s.find(s.back());\\n            if (i == s.size() - 1)\\n                res += i / 2;\\n            else\\n                res += i, s.erase(i, 1);\\n            s.pop_back();\\n        }\\n        return res; \\n    }\\n```\n```py\\n    def minMovesToMakePalindrome(self, s):\\n        s = list(s)\\n        res = 0\\n        while s:\\n            i = s.index(s[-1])\\n            if i == len(s) - 1:\\n                res += i / 2\\n            else:\\n                res += i\\n                s.pop(i)\\n            s.pop()\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1823173,
                "title": "java-c-2-pointers-step-by-step-dry-run-for-easy-explanation",
                "content": "Below is the dry-run and detailed steps using example string \"aletelt\".  Do \"**Upvote**\" if it helps :)  \\n\\t\\n#### \\tComplexity\\n\\tTime: O(n^2), Space: O(n)\\n\\t\\n#### \\tApproach:\\n\\tIntially, steps = 0.\\n\\t* \\tWe will use 2 index pointers initially - \"l\" as Left and \"r\" as right.  \\n\\t* \\t\\'l\\' will move to right and \\'r\\' will move to left in each iteration. ( l -->    <-- r )  \\n\\t* \\tEach time, we want to check whether characters at \"l\" & \"r\" are equal. \\n\\t\\t* \\tIf yes, then we dont need to do anything as both characters on left & right boundry already are palindrome. Hence, we do l++ & r--.\\n\\t\\t* \\tElse, we assign a index pointer \"k\" at same index as \"r\". It\\'s purpose is to find kth index of character matching with (equal to)\\n\\t\\t\\tcharacter at lth index. So,  keep moving this pointer towards left until we find the character.  We did this in code using\\n\\t\\t    method findKthIndexMatchingwithLthIndex().\\n\\t\\t\\t* \\tIf character not found, k index will reach at index of l.  (k==l).\\n\\t\\t\\t* \\tElse, if found, now we want to bring this character to the index of \"r\". Hence keep swapping while(k < r).  \\n\\t* \\tRepeat above steps. \\t\\n        \\n#### \\t\\tExample & Dry-run\\n        \"a   l   e   t   e   l   t\"\\n         l                       r                  // strArr[l] != strArr[r].  initiate index k = r\\n                                 k                  // loop through k using method findKthIndexMatchingwithLthIndex(), until strArr[l] == strArr[k]\\n                                    \\n         \"a   l   e   t   e   l   t\"\\n          l                       r\\n          k                                         // k reached to index l but did not find any index of k which is equal to strArr[l]\\n                                                    // So, now swap strArr[l] & strArr[l+1]   => now steps = 1\\n                                                    \\n         \"l   a   e   t   e   l   t\"                                                              \\n          l                       r                 // strArr[l] != strArr[r].  initiate index k = r\\n                                  k                 // loop through k using method findKthIndexMatchingwithLthIndex(), until strArr[l] == strArr[k]\\n                                  \\n         \"l   a   e   t   e   l   t\"\\n          l                       r\\n                              k                     // reached k, where strArr[l] == strArr[k]   \\n                                                    // Here k != l, so using while loop, keep swapping element at k and k+1, until k < r. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// Here \"steps\" will be updated to 2 i.e steps now = 2\\n           \\n          \"l   a   e   t   e   t   l\" \\n           l                       r\\n                                   k                // now do l++ and r--\\n                                   \\n          \"l   a   e   t   e   t   l\" \\n               l               r\\n                               k \\n                                   \\n    Similarly, keep following above steps or below code, below will be rest of the dry run.\\n            \\n           \"l   a   e   t   e   t   l\"              // strArr[l] != strArr[r]\\n                l               r\\n                                k\\n                                \\n           \"l   a   e   t   e   t   l\"          \\n                l               r\\n                k                                   // k reached to index l but did not find any index of k which is equal to str[l]\\n                                                    // So, now swap strArr[l] & strArr[l+1]  => now steps = 3\\n                \\n           \"l   e   a   t   e   t   l\"              // strArr[l] != strArr[r]\\n                l               r     \\n                                k\\n            \\n           \"l   e   a   t   e   t   l\"\\n                l               r      \\n                            k                       // reached k, where strArr[l] == strArr[k]   \\n                                                    // Here k != l, so using while loop, keep swapping element at k and k+1, until k < r. \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tHere \"steps\" will be updated to 4 i.e steps now = 4\\n                            \\n           \"l   e   a   t   t   e   l\"\\n                l               r                                  \\n                                k\\n            \\n           \"l   e   a   t   t   e   l\" \\n                    l       r\\n                            k\\n                            \\n           \"l   e   a   t   t   e   l\" \\n                    l       r\\n                    k                               // k reached to index l but did not find any index of k which is equal to str[l]\\n                                                    // So, now swap strArr[l] & strArr[l+1]   => now steps = 5\\n                    \\n           \"l   e   t   a   t   e   l\"              //  We have got palindrome by now\\n                    l       r         \\n                            k\\n\\t\\t\\t\\t\\t\\t\\t\\n\\t\\tDo \"Upvote\" if it helps :) \\n\\t\\t\\n\\t\\t\\n### JAVA code:\\n\\tclass Solution {\\n\\n\\t\\tpublic int minMovesToMakePalindrome(String s) {\\n\\t\\t\\tint len = s.length();\\n\\t\\t\\tchar[] strArr = s.toCharArray();        \\n\\t\\t\\tint steps = 0;\\n\\t\\t\\tint l = 0, r = len-1;                                           // use two pointers l for left and r for right. \\n\\n\\t\\t\\twhile(l < r){            \\n\\t\\t\\t\\tif(strArr[l] == strArr[r]){                                 // Both characters are equal. so keep going futher.\\n\\t\\t\\t\\t\\tl++; r--;\\n\\t\\t\\t\\t}else{                                                      // Both characters are not equal.    \\n\\t\\t\\t\\t\\tint k = r;\\n\\t\\t\\t\\t\\tk = findKthIndexMatchingwithLthIndex(strArr, l, k);     // loop through k, until char at index k = char at index l              \\n\\n\\t\\t\\t\\t\\tif(k == l){                                             // we did not find any char at k = char at index l    \\n\\t\\t\\t\\t\\t\\tswap(strArr, l);\\n\\t\\t\\t\\t\\t\\tsteps++;   \\n\\t\\t\\t\\t\\t}else{                                                  \\n\\t\\t\\t\\t\\t\\twhile(k < r){                                           \\n\\t\\t\\t\\t\\t\\t\\tswap(strArr, k);\\n\\t\\t\\t\\t\\t\\t\\tsteps++;\\n\\t\\t\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tl++; r--;\\n\\t\\t\\t\\t\\t}                \\n\\t\\t\\t\\t}// end of else\\n\\n\\t\\t\\t}   // end of while\\n\\t\\t\\tSystem.out.println(\"palindrome: \"+String.valueOf(strArr));\\n\\t\\t\\treturn steps;\\n\\n\\t\\t}\\n\\n\\t\\tpublic int findKthIndexMatchingwithLthIndex(char[] strArr, int l, int k){\\n\\t\\t\\twhile(k > l){\\n\\t\\t\\t\\tif(strArr[k] == strArr[l]){  return k;  }                    \\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t\\treturn k;\\n\\t\\t}\\n\\n\\t\\tpublic void swap(char[] strArr, int l){\\n\\t\\t\\tif(l+1 < strArr.length){\\n\\t\\t\\t\\tchar tempCh = strArr[l];\\n\\t\\t\\t\\tstrArr[l] = strArr[l+1];\\n\\t\\t\\t\\tstrArr[l+1] = tempCh;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n//\\n//\\n//\\n//\\n\\t\\n### \\tC++ Code:\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint minMovesToMakePalindrome(string s) {\\n\\t\\t\\tint len = s.length();\\n\\t\\t\\tstring strArr = s;        \\n\\t\\t\\tint steps = 0;\\n\\t\\t\\tint l = 0, r = len-1;                                           // use two pointers l for left and r for right. \\n\\n\\t\\t\\twhile(l < r){            \\n\\t\\t\\t\\tif(strArr[l] == strArr[r]){                                 // Both characters are equal. so keep going futher.\\n\\t\\t\\t\\t\\tl++; r--;\\n\\t\\t\\t\\t}else{                                                      // Both characters are not equal.    \\n\\t\\t\\t\\t\\tint k = r;\\n\\t\\t\\t\\t\\tk = findKthIndexMatchingwithLthIndex(strArr, l, k);     // loop through k, until char at index k = char at index l              \\n\\n\\t\\t\\t\\t\\tif(k == l){                                             // we did not find any char at k = char at index l    \\n\\t\\t\\t\\t\\t\\tswap(strArr[l], strArr[l+1]);\\n\\t\\t\\t\\t\\t\\tsteps++;   \\n\\t\\t\\t\\t\\t}else{                                                  \\n\\t\\t\\t\\t\\t\\twhile(k < r){                                           \\n\\t\\t\\t\\t\\t\\t\\tswap(strArr[k], strArr[k+1]);\\n\\t\\t\\t\\t\\t\\t\\tsteps++;\\n\\t\\t\\t\\t\\t\\t\\tk++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tl++; r--;\\n\\t\\t\\t\\t\\t}                \\n\\t\\t\\t\\t}   // end of else\\n\\n\\t\\t\\t}   // end of while\\n\\t\\t\\treturn steps;\\n\\t\\t}\\n\\n\\t\\tint findKthIndexMatchingwithLthIndex(string strArr, int l, int k){\\n\\t\\t\\twhile(k > l){\\n\\t\\t\\t\\tif(strArr[k] == strArr[l]){  return k;  }                    \\n\\t\\t\\t\\tk--;\\n\\t\\t\\t}\\n\\t\\t\\treturn k;\\n\\t\\t}\\n\\t};\\n\\nDo \"**Upvote**\" if it helps :)  \\nAny suggestions, question, or more optimized solution is welcomed.",
                "solutionTags": [
                    "Java",
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\n\\n\\t\\tpublic int minMovesToMakePalindrome(String s) {\\n\\t\\t\\tint len = s.length();\\n\\t\\t\\tchar[] strArr = s.toCharArray();        \\n\\t\\t\\tint steps = 0;\\n\\t\\t\\tint l = 0, r = len-1;                                           // use two pointers l for left and r for right. \\n\\n\\t\\t\\twhile(l < r){            \\n\\t\\t\\t\\tif(strArr[l] == strArr[r]){                                 // Both characters are equal. so keep going futher.\\n\\t\\t\\t\\t\\tl++; r--;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1821967,
                "title": "python-2-solutions-o-n-2-and-o-n-log-n-explained",
                "content": "#### Solution 1\\nThe idea is to greedy construct palindrome, symbol by symbol, using two pointers technique. Imagine that we have `abc...cdeba`. Then for the first two symbols they are already on place. For symbol `c`, we start form the `-3` symbol and look for symbol `c`. When we found it, we do swaps. So, we have `abc...dceba -> abc...decba`. Then we proceed in similar way. \\n\\n#### Complexity\\nIt is `O(n^2)` for time and `O(n)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s):\\n        l, r, s = 0, len(s) - 1, list(s)\\n        ans = 0\\n        while l < r:\\n            if s[l] != s[r]:\\n                k = r\\n                while k > l and s[k] != s[l]:\\n                    k -= 1\\n                if k == l:\\n                    ans += 1\\n                    s[l], s[l + 1] = s[l + 1], s[l]\\n                else:\\n                    while k < r:\\n                        s[k], s[k + 1] = s[k + 1], s[k]\\n                        k += 1\\n                        ans += 1\\n                    l, r = l + 1, r - 1\\n            else:\\n                l, r = l + 1, r - 1\\n        return ans\\n```\\n\\n#### Solution 2 (advanced)\\nThere is also `O(n log n)` solution, using BIT, similar idea to CF1616E. The idea is to create `P` first: are pairs of indexes for each letter. Imagine, that we have `a` on positions `0, 4, 9, 11`, then we create pairs `[0, 11], [4, 9]`. Then we sort these pairs, because we want to proceed them from left to right.\\n\\nThis solution is inspired by user **TheScrasse** from CodeForces, here is his more detailed explanation:\\n\\nSince it\\'s useless to swap equal characters, you know which pairs of characters will stay on symmetrical positions in the final string, i.e. the i-th leftmost occurrence and the i-th rightmost occurrence of any character `c`. In the string `acabcaaababbc`, for example, you can make these \"symmetrical pairs\": positions `(1, 10), (2, 13), (3, 8), (4, 12), (6, 7), (9, 11)`. The character in position `5` should go in the center of the final string (i.e. position `7`). The symmetrical pairs have to be nested inside each other, in some order. Given two symmetrical pairs, which of them should be located outside the other one? It turns out that the pair that contains the leftmost element should be located outside. In fact, if you want to reach `xyyx`, the initial configurations with `x` on the left (`xxyy, xyxy, xyyx`) require `2, 1, 0` moves respectively, while reaching `yxxy` requires `2, 1, 2` moves respectively. So you can sort the symmetrical pairs by leftmost element and construct the array a such that `ai` is the final position of `si` in the palindromic string (in this case, `[1, 2, 3, 4, 7, 5, 9, 11, 6, 13, 8, 10, 12]`) and the result is the number of inversions of `a`.\\n\\n#### Complexity\\nIt is `O(n log n)` for time and `O(n)` for space.\\n\\n#### Code\\n```python\\nclass BIT:\\n    def __init__(self, n):\\n        self.sums = [0] * (n+1)\\n    \\n    def update(self, i, delta):\\n        while i < len(self.sums):\\n            self.sums[i] += delta\\n            i += i & (-i)\\n    \\n    def query(self, i):\\n        res = 0\\n        while i > 0:\\n            res += self.sums[i]\\n            i -= i & (-i)\\n        return res\\n\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s):\\n        n = len(s)\\n        s = [ord(x) - 95 for x in s]\\n        ans, bit = 0, BIT(n)\\n        if sum(x % 2 == 1 for x in Counter(s).values()) > 1: return -1\\n\\n        idx = defaultdict(list)\\n        for i, c in enumerate(s):\\n            idx[c].append(i)\\n\\n        B, P = [0] * n, []\\n        for c, I in idx.items():\\n            cnt = len(I)\\n            if cnt % 2:\\n                B[I[cnt//2]] = n//2 + 1\\n            for i in range((cnt)//2):\\n                P += [(I[i], I[~i])]\\n\\n        for i, (l, r) in enumerate(sorted(P)):\\n            B[l], B[r] = i + 1, n - i\\n        \\n        for i, b in enumerate(B):\\n            ans += i - bit.query(b)\\n            bit.update(b, 1)\\n        \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please Upvote!",
                "solutionTags": [
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s):\\n        l, r, s = 0, len(s) - 1, list(s)\\n        ans = 0\\n        while l < r:\\n            if s[l] != s[r]:\\n                k = r\\n                while k > l and s[k] != s[l]:\\n                    k -= 1\\n                if k == l:\\n                    ans += 1\\n                    s[l], s[l + 1] = s[l + 1], s[l]\\n                else:\\n                    while k < r:\\n                        s[k], s[k + 1] = s[k + 1], s[k]\\n                        k += 1\\n                        ans += 1\\n                    l, r = l + 1, r - 1\\n            else:\\n                l, r = l + 1, r - 1\\n        return ans\\n```\n```python\\nclass BIT:\\n    def __init__(self, n):\\n        self.sums = [0] * (n+1)\\n    \\n    def update(self, i, delta):\\n        while i < len(self.sums):\\n            self.sums[i] += delta\\n            i += i & (-i)\\n    \\n    def query(self, i):\\n        res = 0\\n        while i > 0:\\n            res += self.sums[i]\\n            i -= i & (-i)\\n        return res\\n\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s):\\n        n = len(s)\\n        s = [ord(x) - 95 for x in s]\\n        ans, bit = 0, BIT(n)\\n        if sum(x % 2 == 1 for x in Counter(s).values()) > 1: return -1\\n\\n        idx = defaultdict(list)\\n        for i, c in enumerate(s):\\n            idx[c].append(i)\\n\\n        B, P = [0] * n, []\\n        for c, I in idx.items():\\n            cnt = len(I)\\n            if cnt % 2:\\n                B[I[cnt//2]] = n//2 + 1\\n            for i in range((cnt)//2):\\n                P += [(I[i], I[~i])]\\n\\n        for i, (l, r) in enumerate(sorted(P)):\\n            B[l], B[r] = i + 1, n - i\\n        \\n        for i, b in enumerate(B):\\n            ans += i - bit.query(b)\\n            bit.update(b, 1)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821936,
                "title": "list-vs-bit",
                "content": "This question sounds intimidating. Even with 2,000 characters, full search is not practical. Thus, we need to figure out some greedy approach.\\n    \\n**Intuition 1:** It is always cheaper to keep either the left or right character in place, as opposed to moving some other character to the left and right.\\n \\n **Intuition 2:** It actually does not matter whether we keep the left or right character. Consider this example: \\'accabb\\'.\\n - Keep left:  \\'acc*a*bb\\' -> \\'ac*c*bb**a**\\' (2 moves) ->\\'acbb**c**a\\' (2 moves).\\n - Keep right: \\'acca*b*b\\' -> \\'**b**accab\\' (4 moves).\\n \\nA simple quadratic solution is accepted (approach 1), and we can improve it to O(n log n) by collecting indexes for each character, and adjusting them using a mutable prefix sum (approach 2).\\n\\n#### Approach 1: List\\nWe will keep the rigth character and move the first matching character from the left.\\n    \\nNote that it is important to use an efficient data structure here - such as a linked list, so we can modify the string in O(1).\\n\\n**C++**\\n```cpp\\nint minMovesToMakePalindrome(string s) {\\n    int res = 0;\\n    list<char> l(begin(s), end(s));\\n    while(l.size() > 1) {\\n        auto it = begin(l);\\n        int step = 0;\\n        for (; *it != l.back(); ++it)\\n            ++step;\\n        res += step == l.size() - 1 ? step / 2 : step;\\n        if (it != prev(end(l)))\\n            l.erase(it);\\n        l.pop_back();\\n    }\\n    return res;\\n}\\n```\\n#### Approach 2: BIT\\nWe store indexes for each character in a deque `pos`. Then, for each character on the right, we can find the index of the matching character on the left.\\n\\nBut wait, we need to adjust the index - by the count of characters we have used before that index. For that, we use BIT to give us a prefix sum in O(log n).\\n\\n**C++**\\n```cpp\\nconstexpr int static n = 2000;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nint minMovesToMakePalindrome(string s) {\\n    int res = 0, sz = s.size();\\n    deque<int> pos[26] = {};\\n    for (int i = 0; i < sz; ++i)\\n        pos[(s[i] - \\'a\\')].push_back(i);\\n    for (int i = sz - 1; i >= 0; --i) {\\n        int idx = s[i] - \\'a\\';\\n        if (!pos[idx].empty()) {\\n            int p = pos[idx].front() - prefix_sum(pos[idx].front());\\n            add(pos[idx].front(), 1);\\n            if (pos[idx].size() > 1)\\n                pos[idx].pop_front();\\n            else\\n                p /= 2;\\n            res += p;\\n            pos[idx].pop_back();\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minMovesToMakePalindrome(string s) {\\n    int res = 0;\\n    list<char> l(begin(s), end(s));\\n    while(l.size() > 1) {\\n        auto it = begin(l);\\n        int step = 0;\\n        for (; *it != l.back(); ++it)\\n            ++step;\\n        res += step == l.size() - 1 ? step / 2 : step;\\n        if (it != prev(end(l)))\\n            l.erase(it);\\n        l.pop_back();\\n    }\\n    return res;\\n}\\n```\n```cpp\\nconstexpr int static n = 2000;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nint minMovesToMakePalindrome(string s) {\\n    int res = 0, sz = s.size();\\n    deque<int> pos[26] = {};\\n    for (int i = 0; i < sz; ++i)\\n        pos[(s[i] - \\'a\\')].push_back(i);\\n    for (int i = sz - 1; i >= 0; --i) {\\n        int idx = s[i] - \\'a\\';\\n        if (!pos[idx].empty()) {\\n            int p = pos[idx].front() - prefix_sum(pos[idx].front());\\n            add(pos[idx].front(), 1);\\n            if (pos[idx].size() > 1)\\n                pos[idx].pop_front();\\n            else\\n                p /= 2;\\n            res += p;\\n            pos[idx].pop_back();\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1821950,
                "title": "java-solution-using-greedy",
                "content": "If a character is at boundry, there is not point in moving it towards center.\\nAt any given moment, there can be 2 option for making the boundry palindrome.\\nChoose the one with minimum value greedily and keep updating the string.\\n\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int count = 0;\\n        \\n        while(s.length() > 2) {\\n            char ch1 = s.charAt(0);\\n            int len = s.length();\\n            char ch2 = s.charAt(len - 1);\\n            \\n            if (ch1 == ch2) {\\n                s = s.substring(1, len - 1);\\n            } else {\\n                int id1 = s.lastIndexOf(ch1);\\n                int id2 = s.indexOf(ch2);\\n                \\n                int steps1 = len - id1 - 1;\\n                int steps2 = id2;\\n                \\n                StringBuilder sb = new StringBuilder();\\n                \\n                if (steps1 > steps2) {\\n                    count += steps2;\\n                    sb.append(s.substring(0, id2));\\n                    sb.append(s.substring(id2 + 1, len - 1));\\n                } else {\\n                    count += steps1;\\n                    sb.append(s.substring(1, id1));\\n                    sb.append(s.substring(id1 + 1));\\n                }\\n                \\n                s = sb.toString();\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int count = 0;\\n        \\n        while(s.length() > 2) {\\n            char ch1 = s.charAt(0);\\n            int len = s.length();\\n            char ch2 = s.charAt(len - 1);\\n            \\n            if (ch1 == ch2) {\\n                s = s.substring(1, len - 1);\\n            } else {\\n                int id1 = s.lastIndexOf(ch1);\\n                int id2 = s.indexOf(ch2);\\n                \\n                int steps1 = len - id1 - 1;\\n                int steps2 = id2;\\n                \\n                StringBuilder sb = new StringBuilder();\\n                \\n                if (steps1 > steps2) {\\n                    count += steps2;\\n                    sb.append(s.substring(0, id2));\\n                    sb.append(s.substring(id2 + 1, len - 1));\\n                } else {\\n                    count += steps1;\\n                    sb.append(s.substring(1, id1));\\n                    sb.append(s.substring(id1 + 1));\\n                }\\n                \\n                s = sb.toString();\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1821984,
                "title": "python3-2-pointers-solution-explained",
                "content": "```\\n\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \"\"\"\\n        2 pointers, left and right, such that right = n - left - 1\\n        i.e., they are equidistant from both ends\\n        \\n        in a palindromic arrangement of s, s[left] == s[right]\\n\\n        if s[left] and s[right] are not equal:\\n        1. from j = right, check whether there is an element equal to s[left]. \\n           decrement j until an equal element is not found\\n        2. similarly, i = left, check whether there is an element equal to s[right].\\n           increment i until an equal element is not found\\n        3. now we need to decide to either move element at left to element at i, or\\n           element at right to element at j\\n        4. calculate the cost for both possibilities, (i - left and right - j)\\n        5. choose the minimum and move those elements by adjacent swaps\\n        \\n        \\n        \"\"\"\\n        s = list(s)\\n        n = len(s)\\n        count = 0\\n        \\n        for left in range(n // 2):\\n            right = n - left - 1\\n            if s[left] != s[right]:\\n                i = left\\n                j = right\\n                \\n                while s[left] != s[j]:\\n                    j -= 1\\n                    \\n                    \\n                while s[right] != s[i]:\\n                    i += 1\\n                    \\n                    \\n                if right - j < i - left:\\n                    count += right - j\\n                    for x in range(j, right):\\n                        s[x] = s[x+1]\\n                else:\\n                    count += i - left\\n                    for x in range(i, left, -1):\\n                        s[x] = s[x-1]\\n                        \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \"\"\"\\n        2 pointers, left and right, such that right = n - left - 1\\n        i.e., they are equidistant from both ends\\n        \\n        in a palindromic arrangement of s, s[left] == s[right]\\n\\n        if s[left] and s[right] are not equal:\\n        1. from j = right, check whether there is an element equal to s[left]. \\n           decrement j until an equal element is not found\\n        2. similarly, i = left, check whether there is an element equal to s[right].\\n           increment i until an equal element is not found\\n        3. now we need to decide to either move element at left to element at i, or\\n           element at right to element at j\\n        4. calculate the cost for both possibilities, (i - left and right - j)\\n        5. choose the minimum and move those elements by adjacent swaps\\n        \\n        \\n        \"\"\"\\n        s = list(s)\\n        n = len(s)\\n        count = 0\\n        \\n        for left in range(n // 2):\\n            right = n - left - 1\\n            if s[left] != s[right]:\\n                i = left\\n                j = right\\n                \\n                while s[left] != s[j]:\\n                    j -= 1\\n                    \\n                    \\n                while s[right] != s[i]:\\n                    i += 1\\n                    \\n                    \\n                if right - j < i - left:\\n                    count += right - j\\n                    for x in range(j, right):\\n                        s[x] = s[x+1]\\n                else:\\n                    count += i - left\\n                    for x in range(i, left, -1):\\n                        s[x] = s[x-1]\\n                        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822211,
                "title": "two-pointer-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.length();\\n       \\n    int left = 0, right = s.size() - 1, ans = 0;\\n    while (left < right) {\\n        int l = left, r = right;\\n        while (s[l] != s[r]) r--;   \\n        if (l == r) {\\n            // here we hit the odd element\\n            swap(s[r], s[r + 1]);\\n            ans++;\\n            continue;\\n        } else {\\n            // normal element\\n            while (r < right) swap(s[r], s[r + 1]), ans++, r++;\\n        }\\n        left++, right--;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.length();\\n       \\n    int left = 0, right = s.size() - 1, ans = 0;\\n    while (left < right) {\\n        int l = left, r = right;\\n        while (s[l] != s[r]) r--;   \\n        if (l == r) {\\n            // here we hit the odd element\\n            swap(s[r], s[r + 1]);\\n            ans++;\\n            continue;\\n        } else {\\n            // normal element\\n            while (r < right) swap(s[r], s[r + 1]), ans++, r++;\\n        }\\n        left++, right--;\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822360,
                "title": "c-two-pointer-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n       int n = s.length();\\n       int i =0,j=n-1;\\n        int ans = 0;\\n        while(i<j){\\n            if(s[i]==s[j]){     // Both Characters are same move 2 pointers\\n                i++;\\n                j--;\\n            }else{\\n\\t\\t\\t// Both characters are not same\\n                int found = -1;\\n\\t\\t\\t\\t//find index nearest to j which matches with i index\\n                for(int k=j-1;k>i;k--){\\n                    if(s[k]==s[i]){\\n                        found = k;\\n                        break;\\n                    }\\n                }\\n                \\n\\t\\t\\t\\t// found the character which is equal to s[i]\\n                if(found>0){\\n                    for(int k=found;k<j;k++){\\n                        swap(s[k],s[k+1]);\\n                        ans++;\\n                    }\\n                    i++;\\n                    j--;\\n                }else{\\n\\t\\t\\t\\t/* If not found means that character at ith index would have been odd character.\\n\\t\\t\\t\\tso swap it so it would eventually end at middle of string*/\\n                    swap(s[i],s[i+1]);\\n                    ans++;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n       int n = s.length();\\n       int i =0,j=n-1;\\n        int ans = 0;\\n        while(i<j){\\n            if(s[i]==s[j]){     // Both Characters are same move 2 pointers\\n                i++;\\n                j--;\\n            }else{\\n\\t\\t\\t// Both characters are not same\\n                int found = -1;\\n\\t\\t\\t\\t//find index nearest to j which matches with i index\\n                for(int k=j-1;k>i;k--){\\n                    if(s[k]==s[i]){\\n                        found = k;\\n                        break;\\n                    }\\n                }\\n                \\n\\t\\t\\t\\t// found the character which is equal to s[i]\\n                if(found>0){\\n                    for(int k=found;k<j;k++){\\n                        swap(s[k],s[k+1]);\\n                        ans++;\\n                    }\\n                    i++;\\n                    j--;\\n                }else{\\n\\t\\t\\t\\t/* If not found means that character at ith index would have been odd character.\\n\\t\\t\\t\\tso swap it so it would eventually end at middle of string*/\\n                    swap(s[i],s[i+1]);\\n                    ans++;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822915,
                "title": "python-with-proof-for-why-move-a-from-the-form-of-a-a-to-a-a-works",
                "content": "# Proof\\nProvide with a not very solid but acceptable proof:\\n\\n(1) let\\'s convert the string to an array to \\nexample: `\"abcab\"` -> `[\"a\", \"b\", \"c\", \"a\", \"b\"]`\\n\\n(2) let\\'s only consider to move `first element` to be Palindrome. In our example\\n\\nit will be to move from the form of\\n`[\"a\", ..., \"a\", ...]`\\nlet\\'s assume between first `\"a\"` and last `\"a\"` there are number of x elements and behind last `\"a\"` we have number of y elements\\n`\"a\", ..., \"a\", ...` = `\"a\", arr_with_length_x, \"a\", array_with_length_y`\\n`\"a\", arr_with_length_x, \"a\", array_with_length_y` -> `\"a\", arr_with_length_x, array_with_length_y, \"a\"`\\n\\nAs first `\"a\"` is at start of string so to move last `\"a\"` to the end of string, it takes y moves.\\n\\nLet\\'s consider to make another kinds of `Palindrome`, i.e. we move first `\"a\"` to index d (in the form of `[..., \"a\", ..., \"a\", ...]`)\\n`\"a\", arr_with_length_x, \"a\", array_with_length_y` -> `arr_with_length_d, \"a\", arr_with_length_x_minus_d, arr_with_length_y_minus_d, \"a\", arr_with_length_d`\\nthen for first `\"a\"`, it takes `d` moves and relatively it takes `y-d` moves for last `\"a\"`, thus it is `d`+`y-d` = `y` moves in total\\n\\ni.e. no difference on moves count if just want to make `\"a\"` Palindrome\\n\\n(3) let\\'s compare two kinds forms, which is better? \\n**3.1.** `\"a\", arr_with_length_d, arr_with_length_x_minus_d, arr_with_length_y_minus_d, arr_with_length_d, \"a\"`\\n**3.2.**  `arr_with_length_d, \"a\", arr_with_length_x_minus_d, arr_with_length_y_minus_d, \"a\", arr_with_length_d`\\nIt is obvious 3.1. is better (min moves) coz, from (2) we already proof to move `\"a\"`, 3.1. and 3.2. both takes `y` moves\\nAnd on form of **3.2.**, if to move element in `arr_with_length_d` out of itself , it will defintely pass by `\"a\"` and thus always requires one more extra moves than the **3.1.**\\n\\n## Examples for (3)\\nLet\\'s start with `axxayy`\\n\\n### using 3.1. \\n`axxayy` -> `axxyya` (2 moves)\\nthen this equilvalent to move `xxyy`  to Palindrome\\n\\n`xxyy` -> `xyyx` (2 moves)\\n\\n### using 3.2.\\n`axxayy` -> `xxaayy` (same as 3.1. it is 2 moves as proof in (2))\\nMoving `xxaayy` -> `xyaayx` it takes:\\n`xxaayy` -> `xaayyx` (4moves) when moving x to last, x swap with `a` two times\\n`xaayyx` -> `xyaayx` (2moves) when moving y to index 1,y swaps with `a` two times\\n\\ntotally 6 moves = original 2 moves (same as in `3.1.`) + 4 moves (swaps with by `a` 4 times)\\n# Solution\\nProvide with a recursive solution using above greedy solution\\n\\n```\\nclass Solution(object):\\n    def minMovesToMakePalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count, length_of_s = 0, len(s)\\n        if length_of_s <= 2:\\n            return count\\n        for i in reversed(range(length_of_s)):\\n            if s[i] != s[0]:\\n                continue\\n            if i == 0:\\n\\t\\t\\t\\t# move to middle is a speical case which takes len(s)/2 moves then do recursive for remaining part\\n                count += len(s)/2 + self.minMovesToMakePalindrome(s[1:])  \\n            else:\\n\\t\\t\\t    # this move takes len(s)-1 - i (move from i to last index len(s)-1)and then do recursive for remaining part\\n                count += len(s)-1-i + self.minMovesToMakePalindrome(s[1:i]+s[i+1:])\\n            break\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def minMovesToMakePalindrome(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count, length_of_s = 0, len(s)\\n        if length_of_s <= 2:\\n            return count\\n        for i in reversed(range(length_of_s)):\\n            if s[i] != s[0]:\\n                continue\\n            if i == 0:\\n\\t\\t\\t\\t# move to middle is a speical case which takes len(s)/2 moves then do recursive for remaining part\\n                count += len(s)/2 + self.minMovesToMakePalindrome(s[1:])  \\n            else:\\n\\t\\t\\t    # this move takes len(s)-1 - i (move from i to last index len(s)-1)and then do recursive for remaining part\\n                count += len(s)-1-i + self.minMovesToMakePalindrome(s[1:i]+s[i+1:])\\n            break\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831890,
                "title": "c-greedy-solution-with-explanation",
                "content": "## Approach:\\nWhen do you say that the string is Palindrome?\\nWhen it reads same forward and backward right.\\nThis is what we will try to do in this approach.\\n\\nWe will go with same approach.\\n- We will go with first half of the elements and see if their corresponding character from last is equal, If it is equal then we move on to next character.\\n- If it is not we will find the pos of the nearest character from right which is same as given character.\\n\\t- Now there are two subcases:\\n\\t- If that position is equal to the idx itself, This means we are at odd index, Reason is since we are given a palindrome is always possible, So if this would not have been the case we would have found the position in right. In this case we will just swap it with the next element and increase the counter. For the sake of understanding, Take example of **\"abb\"** we will make it **\"bab\"** with 1 swap.\\n\\t- If it is not then we have to swap each consecutive element from the position we found from the right, To make characters equal at that particular position.\\n\\n## Code:\\n```\\n int minMovesToMakePalindrome(string s) {\\n        int l,r,n,cnt=0;\\n        n=s.length();\\n        l=0;\\n        r=n-1;\\n        \\n        while(l<r){\\n            if(s[l] == s[r]){\\n                l++;\\n                r--;\\n                continue;\\n            }\\n            \\n            int idx=r;\\n            while(idx>l && s[idx] != s[l])\\n                idx--;\\n            \\n            if(idx == l){\\n                // This means odd case, Just swap it with itself and do not need to go further\\n                swap(s[idx], s[idx+1]);\\n                cnt++;\\n                continue;\\n            }\\n            \\n            while(idx<r){\\n                swap(s[idx],s[idx+1]);\\n                cnt++;\\n                idx++;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return cnt;\\n    }\\n```\\n\\n**Hope you like it!!\\nPlease do upvote it if you like it and let me know if there are any mistakes/questions in the comments below \\uD83D\\uDC47\\uD83D\\uDC47 .**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n int minMovesToMakePalindrome(string s) {\\n        int l,r,n,cnt=0;\\n        n=s.length();\\n        l=0;\\n        r=n-1;\\n        \\n        while(l<r){\\n            if(s[l] == s[r]){\\n                l++;\\n                r--;\\n                continue;\\n            }\\n            \\n            int idx=r;\\n            while(idx>l && s[idx] != s[l])\\n                idx--;\\n            \\n            if(idx == l){\\n                // This means odd case, Just swap it with itself and do not need to go further\\n                swap(s[idx], s[idx+1]);\\n                cnt++;\\n                continue;\\n            }\\n            \\n            while(idx<r){\\n                swap(s[idx],s[idx+1]);\\n                cnt++;\\n                idx++;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2835985,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\nprivate:\\n    void swap(string& s, int i, int j){\\n        char t = s[i];\\n        s[i] = s[j];\\n        s[j] = t;\\n    }\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ans = 0, l = 0, r = s.size() - 1;\\n        \\n        while(l < r){\\n            if(s[l] == s[r]){\\n                l++; r--;\\n                continue;\\n            }\\n            \\n            int r_ = r;\\n            while(s[r_] != s[l]){\\n                r_--;\\n            }\\n\\n            if(r_ == l){\\n                ans +=  s.size() / 2 - l;\\n                l++;\\n            }else{\\n                ans += r - r_;\\n                while(r_ < r){\\n                    swap(s, r_, r_ + 1);\\n                    r_++;\\n                }\\n                l++; r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void swap(string& s, int i, int j){\\n        char t = s[i];\\n        s[i] = s[j];\\n        s[j] = t;\\n    }\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ans = 0, l = 0, r = s.size() - 1;\\n        \\n        while(l < r){\\n            if(s[l] == s[r]){\\n                l++; r--;\\n                continue;\\n            }\\n            \\n            int r_ = r;\\n            while(s[r_] != s[l]){\\n                r_--;\\n            }\\n\\n            if(r_ == l){\\n                ans +=  s.size() / 2 - l;\\n                l++;\\n            }else{\\n                ans += r - r_;\\n                while(r_ < r){\\n                    swap(s, r_, r_ + 1);\\n                    r_++;\\n                }\\n                l++; r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822089,
                "title": "python-simple-solution-with-graphic-explanation",
                "content": "* start from the first letter. we can tell that its corresponding position is the last index `n - 1`. Search for the right most same letter and swap it to the target position\\n![image](https://assets.leetcode.com/users/images/cbe86863-015a-4862-889e-3b299320e4ab_1646496857.8893888.png)\\n\\n* if we cannot find a same letter, this letter should be placed at center. We can skip it for now.\\n![image](https://assets.leetcode.com/users/images/52746b4e-a196-423d-8d3c-680217980215_1646496883.8686996.png)\\n\\n* keep iterating\\n![image](https://assets.leetcode.com/users/images/6e23cb1f-ef52-4fe6-9d48-f305fc279b43_1646496905.636108.png)\\n\\n* finally, we swap the unique letter to center\\n![image](https://assets.leetcode.com/users/images/6940bb70-abeb-4451-bc9f-b74ecda4bcae_1646496922.0397792.png)\\n\\ncode:\\n```\\ndef minMovesToMakePalindrome(self, s: str) -> int:\\n    ans = 0\\n    n = len(s)\\n    target = n - 1 # 0\\'s corresponding index\\n    for i in range(math.ceil(n / 2)):\\n        for j in range(target, i - 1, -1):\\n            # search backward\\n            if j == i:\\n                # occurrance is 1, needs to be placed at center\\n                ans += n // 2 - i\\n            elif s[i] == s[j]:\\n                s = s[:j] + s[j + 1 : target + 1] + s[j] + s[target + 1:]\\n                ans += target - j\\n                target -= 1\\n                break\\n    return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef minMovesToMakePalindrome(self, s: str) -> int:\\n    ans = 0\\n    n = len(s)\\n    target = n - 1 # 0\\'s corresponding index\\n    for i in range(math.ceil(n / 2)):\\n        for j in range(target, i - 1, -1):\\n            # search backward\\n            if j == i:\\n                # occurrance is 1, needs to be placed at center\\n                ans += n // 2 - i\\n            elif s[i] == s[j]:\\n                s = s[:j] + s[j + 1 : target + 1] + s[j] + s[target + 1:]\\n                ans += target - j\\n                target -= 1\\n                break\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2466919,
                "title": "clean-java-code-with-explanation",
                "content": "* **Check if the character in start and end index are same if yes then decrease the end by 1 and increase the start by 1**\\n*  **Otherwise search for the character similar to the starting index by decrementing the end** \\n*  **If it is seen that on decrementing the end it points to same index as start then swap the character with the  character in the next index and increment the ans count**\\n\\n*   **Otherwise check the last index pointer is less than the ending indx if yes then increase it as well as increase the ans and keep on swapping the last index  pointer with its next position.**\\n\\n***Please Upvote if you like my approach***\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        int ans = 0;\\n        \\n        int start = 0 , end = s.length() - 1;\\n        \\n        char ch[] = s.toCharArray();\\n        \\n        while(start < end)\\n        {\\n           \\n            int r = end;\\n            \\n            if(ch[start] == ch[end])\\n            {\\n                start++;\\n                end--;\\n                continue;\\n            }\\n            \\n            while(ch[start] != ch[r])\\n            {\\n                r--; \\n            }// aabb l is pointing at 0 th index while r is pointing to b which is not equal to a so r-- by doing this we are searching whether any a is present there other than the one which l is pointing\\n            \\n            if(start == r) // means no a is present other than first index\\n            {\\n                //swap them\\n               \\n                swap(ch,r,r+1);\\n                ans++;\\n               \\n            }\\n            else \\n            {\\n                while(r<end)\\n                {\\n                    swap(ch,r,r+1);\\n                    ans++;\\n                    r++;\\n                }\\n               \\n            }\\n            \\n            \\n        }\\n        return ans;\\n    }\\n    \\n    private void swap(char ch[] , int i , int j)\\n    {\\n        \\n                char c = ch[i];\\n                ch[i] = ch[j];\\n                ch[j] = c;\\n      \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        int ans = 0;\\n        \\n        int start = 0 , end = s.length() - 1;\\n        \\n        char ch[] = s.toCharArray();\\n        \\n        while(start < end)\\n        {\\n           \\n            int r = end;\\n            \\n            if(ch[start] == ch[end])\\n            {\\n                start++;\\n                end--;\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2266606,
                "title": "c-two-pointer-easy-understanding",
                "content": "class Solution {\\npublic:\\n\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int p=0;\\n        int q=n-1;\\n        int ans=0;\\n        int y=-1;\\n        while(p<=q)\\n        {\\n            if(s[p]!=s[q])\\n            {\\n                int temp=q-1;\\n                while(s[temp]!=s[p])\\n                    temp--;\\n                if(temp!=p)\\n                {\\n                    for(int i=temp;i<q;i++)\\n                    {\\n                        swap(s[i],s[i+1]);\\n                        ans++;\\n                    }\\n                }\\n                else\\n                {\\n                    y=p;\\n                    q++;\\n                }\\n            }\\n            p++;\\n            q--;\\n        }\\n        if(y!=-1)                          //  If the frequency of a particular letter is odd\\n        {                                    // Only at most one letter can have odd frequency\\n            ans+=abs(s.size()/2-y);     // This is the required swaps to bring that letter to the middle\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int p=0;\\n        int q=n-1;\\n        int ans=0;\\n        int y=-1;\\n        while(p<=q)\\n        {\\n            if(s[p]!=s[q])\\n            {\\n                int temp=q-1;\\n                while(s[temp]!=s[p])\\n                    temp--;\\n                if(temp!=p)\\n                {\\n                    for(int i=temp;i<q;i++)\\n                    {\\n                        swap(s[i],s[i+1]);\\n                        ans++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1880549,
                "title": "java-easy-explanation-two-pointer",
                "content": "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        char []arr=s.toCharArray();\\n        int start=0;\\n        int n=s.length();\\n        int end=s.length()-1;\\n        int res=0;\\n        while(start<end)\\n        {\\n            int k=end;\\n            // if we found pal char \\n            if(arr[start]==arr[end])\\n            {\\n                start++;\\n                end--;\\n                continue;   \\n            }\\n            // char is not pal we will search particular char\\n            // towards starting point\\n            // because it is the right way to make min moves\\n            // then we will swap\\n            // and return the answer\\n            while(arr[start]!=arr[k])\\n            {\\n                k--;\\n                \\n            }\\n            if(k==start)\\n            {\\n                res++;\\n                swap(arr,start,start+1);\\n            }\\n            else\\n            {\\n                while(k<end)\\n                {\\n                    res++;\\n                    swap(arr,k,k+1);\\n                    k++;\\n                }\\n            }\\n        }\\n            \\n            return res;\\n    }\\n        \\n        \\n public static void swap(char arr[],int i,int j)\\n {\\n    char temp=arr[i];\\n    arr[i]=arr[j];\\n    arr[j]=temp;\\n }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        char []arr=s.toCharArray();\\n        int start=0;\\n        int n=s.length();\\n        int end=s.length()-1;\\n        int res=0;\\n        while(start<end)\\n        {\\n            int k=end;\\n            // if we found pal char \\n            if(arr[start]==arr[end])\\n            {\\n                start++;\\n                end--;\\n                continue;   \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2138121,
                "title": "without-considering-any-odd-element-case-using-two-pointer-method",
                "content": "**Hello guys,**\\nthis is a simple solution for  `Minimum Number of Moves to Make Palindrome` problem\\n\\nLet `l=0, r=n-1`\\n\\n`if(s[l]==s[r]) l++,r--;`\\n\\n`else`\\n`{`\\nsearch s[l] from right side of the string \\nand seach s[r] from left side of the string\\n\\nlet we get `s[l]` at `idx2` from right then there will be` r-idx2` swaps required\\nand for we get `s[r]` at `idx1` from left then there will be `idx1-l` swaps required\\n\\nwe will take swap action from min distance and pull that particular character to `l` or `r`\\n`}`\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int n=s.size();\\n        int l=0,r=n-1;\\n        \\n        int cnt=0;\\n        while(l<r)\\n        {\\n            if(s[l]==s[r])\\n            {\\n                l++,r--;\\n            }\\n            else\\n            {\\n                int idx1=l,idx2=r;\\n                \\n                // left search\\n                char c=s[r];\\n                for(int i=l+1;i<n;++i)\\n                {\\n                    if(s[i]==c)\\n                    {\\n                        idx1=i; break;\\n                    }\\n                }\\n                \\n                // right search\\n                c=s[l];\\n                for(int i=r-1;i>=0;i--)\\n                {\\n                    if(s[i]==c) {\\n                        idx2=i; break;\\n                    }\\n                }\\n                \\n                // swap \\n                if(idx1-l<=r-idx2)\\n                {\\n                    while(idx1>l)\\n                    {\\n                        swap(s[idx1],s[idx1-1]);\\n                        idx1--;\\n                        \\n                        cnt++;\\n                    }\\n                }\\n                else\\n                {\\n                    while(idx2<r)\\n                    {\\n                        swap(s[idx2], s[idx2+1]);\\n                        idx2++;\\n                        \\n                        cnt++;\\n                    }\\n                }\\n                \\n                l++,r--;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```\\n\\nThanks...",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int n=s.size();\\n        int l=0,r=n-1;\\n        \\n        int cnt=0;\\n        while(l<r)\\n        {\\n            if(s[l]==s[r])\\n            {\\n                l++,r--;\\n            }\\n            else\\n            {\\n                int idx1=l,idx2=r;\\n                \\n                // left search\\n                char c=s[r];\\n                for(int i=l+1;i<n;++i)\\n                {\\n                    if(s[i]==c)\\n                    {\\n                        idx1=i; break;\\n                    }\\n                }\\n                \\n                // right search\\n                c=s[l];\\n                for(int i=r-1;i>=0;i--)\\n                {\\n                    if(s[i]==c) {\\n                        idx2=i; break;\\n                    }\\n                }\\n                \\n                // swap \\n                if(idx1-l<=r-idx2)\\n                {\\n                    while(idx1>l)\\n                    {\\n                        swap(s[idx1],s[idx1-1]);\\n                        idx1--;\\n                        \\n                        cnt++;\\n                    }\\n                }\\n                else\\n                {\\n                    while(idx2<r)\\n                    {\\n                        swap(s[idx2], s[idx2+1]);\\n                        idx2++;\\n                        \\n                        cnt++;\\n                    }\\n                }\\n                \\n                l++,r--;\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841912,
                "title": "c-superfast-92-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int solve(string &s,char target,int last,int index)\\n    {\\n        int pos=-1;\\n        for(int i=last;i>=0;i--)\\n        {\\n            if(s[i]==target)\\n            {\\n                pos=i;\\n                break;\\n            }\\n        }\\n        int c=0;\\n\\t\\t//if my string is \"abb\" and hence i got same pos of a from last and from end then return c i.e 0\\n        if(pos==index)return c;\\n        while(pos!=last)\\n        {\\n            swap(s[pos],s[pos+1]);\\n            pos++;\\n            c++;\\n        }\\n        return c;\\n    }\\n    int minMovesToMakePalindrome(string s) \\n    {\\n        int ans=0;\\n        int n=s.size();\\n        int res=0;\\n\\t\\t//for even\\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(s[i]!=s[n-1-i])\\n            {\\n                int ch=solve(s,s[i],n-1-i,i);\\n                if(ch==0)\\n                {\\n                    ans=INT_MAX;\\n                    break;\\n                }\\n                res+=ch;\\n            }\\n        }\\n\\t\\t//for odd and my single element is in left\\n        if(n&1 && ans==INT_MAX)\\n        {\\n            ans=0;\\n            reverse(s.begin(),s.end());\\n            for(int i=0;i<n/2;i++)\\n            {\\n                if(s[i]!=s[n-1-i])\\n                {\\n                    int ch=solve(s,s[i],n-1-i,-1);\\n                    ans+=ch;\\n                }\\n            }\\n            return ans+res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string &s,char target,int last,int index)\\n    {\\n        int pos=-1;\\n        for(int i=last;i>=0;i--)\\n        {\\n            if(s[i]==target)\\n            {\\n                pos=i;\\n                break;\\n            }\\n        }\\n        int c=0;\\n\\t\\t//if my string is \"abb\" and hence i got same pos of a from last and from end then return c i.e 0\\n        if(pos==index)return c;\\n        while(pos!=last)\\n        {\\n            swap(s[pos],s[pos+1]);\\n            pos++;\\n            c++;\\n        }\\n        return c;\\n    }\\n    int minMovesToMakePalindrome(string s) \\n    {\\n        int ans=0;\\n        int n=s.size();\\n        int res=0;\\n\\t\\t//for even\\n        for(int i=0;i<n/2;i++)\\n        {\\n            if(s[i]!=s[n-1-i])\\n            {\\n                int ch=solve(s,s[i],n-1-i,i);\\n                if(ch==0)\\n                {\\n                    ans=INT_MAX;\\n                    break;\\n                }\\n                res+=ch;\\n            }\\n        }\\n\\t\\t//for odd and my single element is in left\\n        if(n&1 && ans==INT_MAX)\\n        {\\n            ans=0;\\n            reverse(s.begin(),s.end());\\n            for(int i=0;i<n/2;i++)\\n            {\\n                if(s[i]!=s[n-1-i])\\n                {\\n                    int ch=solve(s,s[i],n-1-i,-1);\\n                    ans+=ch;\\n                }\\n            }\\n            return ans+res;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830147,
                "title": "c-runtime-8-ms-faster-than-99-93-memory-6-6-mb-less-than-98-24",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ans = 0;\\n        \\n        while(s.length() > 0){\\n            int n = s.length();\\n            char c = s[n-1];\\n            int ind = s.find(c);\\n            //cout<<s<<\" \"<<ind<<\" \"<<c<<endl;\\n            if(ind == n-1){\\n                ans += n/2;\\n                s.pop_back();\\n            } else {\\n                ans += ind;\\n                s.pop_back();\\n                s.erase(ind,1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ans = 0;\\n        \\n        while(s.length() > 0){\\n            int n = s.length();\\n            char c = s[n-1];\\n            int ind = s.find(c);\\n            //cout<<s<<\" \"<<ind<<\" \"<<c<<endl;\\n            if(ind == n-1){\\n                ans += n/2;\\n                s.pop_back();\\n            } else {\\n                ans += ind;\\n                s.pop_back();\\n                s.erase(ind,1);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1821980,
                "title": "c-easy-swap-solution",
                "content": "```C++\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int res = 0;\\n        for(int i = 0, j = s.length() - 1; i < s.length() / 2; i++, j--) {\\n            if(s[i] == s[j]) continue;\\n            int f = j - 1;\\n            for(; f >= i; f--) { //find closest character\\n                if(s[i] == s[f]) break;\\n            }\\n            if(f == i) { //if closest character is at s[i], s[i] should move to middle of s\\n                res += s.length() / 2 - i;\\n                j++;\\n            } else { //else, calculate distance and swap all characters\\n                res += j - f;\\n                for(; f < j; f++) {\\n                    swap(s[f], s[f+1]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int res = 0;\\n        for(int i = 0, j = s.length() - 1; i < s.length() / 2; i++, j--) {\\n            if(s[i] == s[j]) continue;\\n            int f = j - 1;\\n            for(; f >= i; f--) { //find closest character\\n                if(s[i] == s[f]) break;\\n            }\\n            if(f == i) { //if closest character is at s[i], s[i] should move to middle of s\\n                res += s.length() / 2 - i;\\n                j++;\\n            } else { //else, calculate distance and swap all characters\\n                res += j - f;\\n                for(; f < j; f++) {\\n                    swap(s[f], s[f+1]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621577,
                "title": "brute-force-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int i = 0, j = s.length()-1,k,ans=0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;j--;\\n            }else{\\n                k = j;\\n                while(k>=i && s[k] != s[i]){\\n                    k--;\\n                }\\n                if(k==i){\\n                    ans++;\\n                    swap(s[i],s[i+1]);\\n                }else{\\n                    while(k<j){\\n                        swap(s[k],s[k+1]);\\n                        k++;\\n                        ans++;\\n                    }\\n                    i++;j--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int i = 0, j = s.length()-1,k,ans=0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;j--;\\n            }else{\\n                k = j;\\n                while(k>=i && s[k] != s[i]){\\n                    k--;\\n                }\\n                if(k==i){\\n                    ans++;\\n                    swap(s[i],s[i+1]);\\n                }else{\\n                    while(k<j){\\n                        swap(s[k],s[k+1]);\\n                        k++;\\n                        ans++;\\n                    }\\n                    i++;j--;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453981,
                "title": "java-solution-string-builder-greedy-two-pointer",
                "content": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) \\n    {\\n        int n=s.length();\\n        StringBuilder sb=new StringBuilder(s);\\n        int ans=0;\\n        \\n        while(sb.length()>1)\\n        {\\n            char ch=sb.charAt(0);\\n            int pos=sb.lastIndexOf(ch+\"\");\\n            \\n            if(pos==0)\\n            ans+=n/2;\\n            \\n            else\\n            {\\n                ans+=n-pos-1;\\n                sb.deleteCharAt(pos);\\n                n--;\\n            }\\n            \\n            sb.deleteCharAt(0);\\n            n--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) \\n    {\\n        int n=s.length();\\n        StringBuilder sb=new StringBuilder(s);\\n        int ans=0;\\n        \\n        while(sb.length()>1)\\n        {\\n            char ch=sb.charAt(0);\\n            int pos=sb.lastIndexOf(ch+\"\");\\n            \\n            if(pos==0)\\n            ans+=n/2;\\n            \\n            else\\n            {\\n                ans+=n-pos-1;\\n                sb.deleteCharAt(pos);\\n                n--;\\n            }\\n            \\n            sb.deleteCharAt(0);\\n            n--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1827875,
                "title": "java-greedy-two-pointers",
                "content": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String str) {\\n        int n=str.length();\\n        char[] s=str.toCharArray();\\n        int lptr=0;\\n        int rptr=n-1;\\n        \\n        int res=0;\\n        while(lptr<rptr){\\n            int r=rptr;\\n            \\n            if(s[lptr]==s[r]){\\n                lptr++;\\n                rptr--;\\n                continue;\\n            }\\n            \\n            while(s[lptr]!=s[r]) r--;\\n            \\n            if(lptr==r){\\n                swap(s,lptr,lptr+1);\\n                res++;\\n            }\\n            else{\\n                while(r!=rptr){\\n                    swap(s,r,r+1);\\n                    r++;\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void swap(char[] s,int l,int r){\\n        char temp=s[l];\\n        s[l]=s[r];\\n        s[r]=temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String str) {\\n        int n=str.length();\\n        char[] s=str.toCharArray();\\n        int lptr=0;\\n        int rptr=n-1;\\n        \\n        int res=0;\\n        while(lptr<rptr){\\n            int r=rptr;\\n            \\n            if(s[lptr]==s[r]){\\n                lptr++;\\n                rptr--;\\n                continue;\\n            }\\n            \\n            while(s[lptr]!=s[r]) r--;\\n            \\n            if(lptr==r){\\n                swap(s,lptr,lptr+1);\\n                res++;\\n            }\\n            else{\\n                while(r!=rptr){\\n                    swap(s,r,r+1);\\n                    r++;\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public void swap(char[] s,int l,int r){\\n        char temp=s[l];\\n        s[l]=s[r];\\n        s[r]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822337,
                "title": "explanation-logical-proof-why-greedy-works",
                "content": "This may not be a concrete proof but atleast having some idea is better than nothing. I could not find any good explanation out there, so please comment here if you have found a better resource :)\\n\\n\\nYou might have already read the approach - \\n1. initialise left and right pointers to 0 and size-1 respectively\\n2. find character to the left of right pointer which is equal to character at l and modify the string. If not found return -1 (handle odd length string case as well)\\n\\nWhy does this work? Why is it enough replace just 1 character (either to the left or right), could there be a better solution by replacing both characters ?\\n\\nThink about this - No matter what you do, in order to align 2 characters in the given string, it would taken a min of swaps depending on the following 2 values - pos(right), pos(left) .i.e. in the end you will end up making these many swaps for sure for these 2 characters.\\n\\nNow, you can notice that in our method we are exaclty doing this - making a minimum number of swaps. .i.e. moving one of the left or the right character by this minimum number of swaps.\\n\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        int count = 0;\\n        int l = 0;\\n        int r = s.length()-1;\\n        \\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        int skip = 0;\\n        \\n        while(l<r){\\n            \\n            char leftChar = sb.charAt(l); \\n            char rightChar = sb.charAt(r);\\n            int temp = r; \\n            \\n            while(l < temp &&  leftChar != sb.charAt(temp)){\\n                temp--;\\n            }\\n            \\n            if(l == temp){\\n                if(s.length()%2 == 0){\\n                    return -1;\\n                } else {\\n                    if(skip == 1) return -1;\\n                    skip = 1;\\n                    count = count + s.length()/2 - l;\\n                    l = l + 1;\\n                }\\n                continue;\\n            }\\n            \\n            count = count + r - temp;\\n            \\n            sb.deleteCharAt(temp);\\n            sb.insert(r, leftChar);\\n            \\n            \\n            r--;\\n            l++;\\n            \\n        }\\n        \\n\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        int count = 0;\\n        int l = 0;\\n        int r = s.length()-1;\\n        \\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        int skip = 0;\\n        \\n        while(l<r){\\n            \\n            char leftChar = sb.charAt(l); \\n            char rightChar = sb.charAt(r);\\n            int temp = r; \\n            \\n            while(l < temp &&  leftChar != sb.charAt(temp)){\\n                temp--;\\n            }\\n            \\n            if(l == temp){\\n                if(s.length()%2 == 0){\\n                    return -1;\\n                } else {\\n                    if(skip == 1) return -1;\\n                    skip = 1;\\n                    count = count + s.length()/2 - l;\\n                    l = l + 1;\\n                }\\n                continue;\\n            }\\n            \\n            count = count + r - temp;\\n            \\n            sb.deleteCharAt(temp);\\n            sb.insert(r, leftChar);\\n            \\n            \\n            r--;\\n            l++;\\n            \\n        }\\n        \\n\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2755656,
                "title": "intuition-made-easy-for-you-c-explanation",
                "content": "```\\nint solve(string s)\\n    {\\n         int n=s.size(),ans=0,i=0,j=n-1;\\n        \\n         while(i<j)\\n         {\\n            if(s[i]!=s[j])\\n            {\\n    //Step 1 ->We are fixing the first half and changing 2nd half according to it    \\n                \\n                int idx=j;\\n                while(s[idx]!=s[i])  //j se i ki trf aao aur dekho kaunsa idx s[i] ke equal\\n                    idx--;\\n      \\n    //Step 2 -> special case like \"ahbbaaa\" here h should come in middle so just swap with its next element and (NO i++,j-- here as process krna baaki hai use to ab \"abhbaaa\" is string me process kro NO i++ and j--)\\n                \\n                if(i==idx) \\n                {\\n                    swap(s[idx],s[idx+1]);\\n                    ans++;\\n                    continue;  //IMPORTANT --> No i++ and j-- for special case\\n                }\\n                \\n    //Step 3 -> Agar koi milgya hume s[i] ke equal to use hume jth place tk lana to idx<j jab tk hai tb tk swap marte rho aur ans++ krdo\\n                \\n                else\\n                {\\n                    while(idx<j)\\n                    {\\n                        swap(s[idx],s[idx+1]);\\n                        idx++; ans++;\\n                    }\\n                }\\n            }\\n             \\n            i++;\\n            j--;    //i aur j position match krwadi ab aage bdo         \\n         }\\n        return ans;\\n    }\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        return solve(s);\\n    }",
                "solutionTags": [],
                "code": "```\\nint solve(string s)\\n    {\\n         int n=s.size(),ans=0,i=0,j=n-1;\\n        \\n         while(i<j)\\n         {\\n            if(s[i]!=s[j])\\n            {\\n    //Step 1 ->We are fixing the first half and changing 2nd half according to it    \\n                \\n                int idx=j;\\n                while(s[idx]!=s[i])  //j se i ki trf aao aur dekho kaunsa idx s[i] ke equal\\n                    idx--;\\n      \\n    //Step 2 -> special case like \"ahbbaaa\" here h should come in middle so just swap with its next element and (NO i++,j-- here as process krna baaki hai use to ab \"abhbaaa\" is string me process kro NO i++ and j--)\\n                \\n                if(i==idx) \\n                {\\n                    swap(s[idx],s[idx+1]);\\n                    ans++;\\n                    continue;  //IMPORTANT --> No i++ and j-- for special case\\n                }\\n                \\n    //Step 3 -> Agar koi milgya hume s[i] ke equal to use hume jth place tk lana to idx<j jab tk hai tb tk swap marte rho aur ans++ krdo\\n                \\n                else\\n                {\\n                    while(idx<j)\\n                    {\\n                        swap(s[idx],s[idx+1]);\\n                        idx++; ans++;\\n                    }\\n                }\\n            }\\n             \\n            i++;\\n            j--;    //i aur j position match krwadi ab aage bdo         \\n         }\\n        return ans;\\n    }\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        return solve(s);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2567960,
                "title": "python-greedy-2-pointer",
                "content": "\\tclass Solution:\\n\\t\\tdef minMovesToMakePalindrome(self, s: str) -> int:\\n\\t\\t\\ts = list(s) #makes it easy for assignment op\\n\\n\\t\\t\\tres = 0\\n\\t\\t\\tleft, right = 0, len(s) - 1\\n\\n\\t\\t\\twhile left < right:\\n\\t\\t\\t\\tl, r = left, right\\n\\n\\t\\t\\t\\t#find matching char\\n\\t\\t\\t\\twhile s[l] != s[r]:\\n\\t\\t\\t\\t\\tr -= 1\\n\\n\\t\\t\\t\\t# if index dont match then swap\\n\\t\\t\\t\\tif l != r:\\n\\t\\t\\t\\t\\t# swap one by one\\n\\t\\t\\t\\t\\twhile r < right:\\n\\t\\t\\t\\t\\t\\ts[r], s[r + 1] = s[r + 1], s[r]\\n\\t\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\t\\tr += 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts[r], s[r + 1] = s[r + 1], s[r]\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\tcontinue # get outside the main while loop\\n\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\t\\tright -= 1\\n\\n\\t\\t\\treturn res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minMovesToMakePalindrome(self, s: str) -> int:\\n\\t\\t\\ts = list(s) #makes it easy for assignment op\\n\\n\\t\\t\\tres = 0\\n\\t\\t\\tleft, right = 0, len(s) - 1\\n\\n\\t\\t\\twhile left < right:\\n\\t\\t\\t\\tl, r = left, right\\n\\n\\t\\t\\t\\t#find matching char\\n\\t\\t\\t\\twhile s[l] != s[r]:\\n\\t\\t\\t\\t\\tr -= 1\\n\\n\\t\\t\\t\\t# if index dont match then swap\\n\\t\\t\\t\\tif l != r:\\n\\t\\t\\t\\t\\t# swap one by one\\n\\t\\t\\t\\t\\twhile r < right:\\n\\t\\t\\t\\t\\t\\ts[r], s[r + 1] = s[r + 1], s[r]\\n\\t\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\t\\tr += 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ts[r], s[r + 1] = s[r + 1], s[r]\\n\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\tcontinue # get outside the main while loop\\n\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\t\\tright -= 1\\n\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 2537153,
                "title": "c-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s)\\n    {\\n        int n=s.size(),i=0,j=n-1,ans=0;\\n        int yes=-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                int temp=j-1;\\n                while(s[temp]!=s[i])\\n                    temp--;\\n                if(i!=temp)\\n                {\\n                    for(int k=temp+1;k<=j;k++)\\n                    {\\n                        swap(s[k-1],s[k]);\\n                        ans++;\\n                    }\\n                }\\n                else\\n                {\\n                    yes=i;\\n                    j++;\\n                }\\n            }\\n            i++;\\n            j--;\\n        }\\n        if(yes!=-1)\\n        {\\n            ans+=((s.size())/2-yes);\\n        }\\n        return ans;\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s)\\n    {\\n        int n=s.size(),i=0,j=n-1,ans=0;\\n        int yes=-1;\\n        while(i<j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                int temp=j-1;\\n                while(s[temp]!=s[i])\\n                    temp--;\\n                if(i!=temp)\\n                {\\n                    for(int k=temp+1;k<=j;k++)\\n                    {\\n                        swap(s[k-1],s[k]);\\n                        ans++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2451681,
                "title": "c-short-and-simple-greedy-solution",
                "content": "\\n```\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size(), ans = 0;\\n        while(n)\\n        {\\n            int i = 0;\\n            while(s[i] != s[n-1]) i++;\\n            if(i == n-1) ans += (n-1)/2;\\n            else ans += i, s.erase(s.begin()+i),n--;\\n            s.pop_back();\\n            n--;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size(), ans = 0;\\n        while(n)\\n        {\\n            int i = 0;\\n            while(s[i] != s[n-1]) i++;\\n            if(i == n-1) ans += (n-1)/2;\\n            else ans += i, s.erase(s.begin()+i),n--;\\n            s.pop_back();\\n            n--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2419573,
                "title": "easy-two-pointer-c-method-75-faster",
                "content": "```\\n int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int i=0;\\n        int j=n-1;\\n        int cnt=0;\\n        int centre_ele=-1;\\n        int left,right;\\n        while(i<=j)\\n        {\\n            //non-matching elements\\n            if(s[i]!=s[j])\\n            {\\n                left=i+1;\\n                while(s[left]!=s[j] && left<j)\\n                {\\n                    left++;\\n                }\\n                \\n                //odd element found -> to be made middle element\\n                if(left==j)\\n                {\\n                   \\n                    centre_ele=j;\\n                    j--;\\n                    continue;\\n                }\\n                \\n                else\\n                {\\n                    for(int k=left;k>i;k--)\\n                    {\\n                        swap(s[k],s[k-1]);\\n                        cnt++;\\n                    }\\n                }\\n                \\n            }\\n            //normal matching elements\\n            else\\n            {\\n                i++;\\n                j--;\\n            }\\n        }\\n        \\n        \\n        \\n        if(centre_ele!=-1)\\n        {\\n            cnt+=centre_ele -(n / 2);\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int i=0;\\n        int j=n-1;\\n        int cnt=0;\\n        int centre_ele=-1;\\n        int left,right;\\n        while(i<=j)\\n        {\\n            //non-matching elements\\n            if(s[i]!=s[j])\\n            {\\n                left=i+1;\\n                while(s[left]!=s[j] && left<j)\\n                {\\n                    left++;\\n                }\\n                \\n                //odd element found -> to be made middle element\\n                if(left==j)\\n                {\\n                   \\n                    centre_ele=j;\\n                    j--;\\n                    continue;\\n                }\\n                \\n                else\\n                {\\n                    for(int k=left;k>i;k--)\\n                    {\\n                        swap(s[k],s[k-1]);\\n                        cnt++;\\n                    }\\n                }\\n                \\n            }\\n            //normal matching elements\\n            else\\n            {\\n                i++;\\n                j--;\\n            }\\n        }\\n        \\n        \\n        \\n        if(centre_ele!=-1)\\n        {\\n            cnt+=centre_ele -(n / 2);\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2152484,
                "title": "python3-peel-the-string",
                "content": "\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0 \\n        while len(s) > 2: \\n            lo = s.find(s[-1])\\n            hi = s.rfind(s[0])\\n            if lo < len(s)-hi-1: \\n                ans += lo \\n                s = s[:lo] + s[lo+1:-1]\\n            else: \\n                ans += len(s)-hi-1\\n                s = s[1:hi] + s[hi+1:]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0 \\n        while len(s) > 2: \\n            lo = s.find(s[-1])\\n            hi = s.rfind(s[0])\\n            if lo < len(s)-hi-1: \\n                ans += lo \\n                s = s[:lo] + s[lo+1:-1]\\n            else: \\n                ans += len(s)-hi-1\\n                s = s[1:hi] + s[hi+1:]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910883,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Greedy Approach***\\n\\n* ***Time Complexity : O(N * N)***\\n* ***Space Complexity : O(1)***\\n\\n```\\nint minMovesToMakePalindrome(string str) {\\n        \\n        int n = str.size();\\n        \\n        int low = 0;\\n        \\n        int high = n - 1;\\n        \\n        int count = 0;\\n        \\n        while(low <= high)\\n        {\\n            if(str[low] == str[high])\\n            {\\n                low++;\\n                \\n                high--;\\n            }\\n            else\\n            {\\n                int idx = high - 1;\\n                \\n                while(idx > low)\\n                {\\n                    if(str[low] == str[idx])\\n                    {\\n                        break;\\n                    }\\n                    \\n                    idx--;\\n                }\\n                \\n                if(idx == low)\\n                {\\n                    count++;\\n                    \\n                    swap(str[idx], str[idx + 1]);\\n                }\\n                \\n                else\\n                {\\n                    while(idx < high)\\n                    {\\n                        count++;\\n                    \\n                        swap(str[idx], str[idx + 1]);\\n                    \\n                        idx++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nint minMovesToMakePalindrome(string str) {\\n        \\n        int n = str.size();\\n        \\n        int low = 0;\\n        \\n        int high = n - 1;\\n        \\n        int count = 0;\\n        \\n        while(low <= high)\\n        {\\n            if(str[low] == str[high])\\n            {\\n                low++;\\n                \\n                high--;\\n            }\\n            else\\n            {\\n                int idx = high - 1;\\n                \\n                while(idx > low)\\n                {\\n                    if(str[low] == str[idx])\\n                    {\\n                        break;\\n                    }\\n                    \\n                    idx--;\\n                }\\n                \\n                if(idx == low)\\n                {\\n                    count++;\\n                    \\n                    swap(str[idx], str[idx + 1]);\\n                }\\n                \\n                else\\n                {\\n                    while(idx < high)\\n                    {\\n                        count++;\\n                    \\n                        swap(str[idx], str[idx + 1]);\\n                    \\n                        idx++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1828689,
                "title": "c-two-pointers-implementation",
                "content": "**PLEASE UPVOTE IF U LIKE MY SOLUTION AND EXPLANATION  :\\')**\\n\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int n=s.length();\\n        int left=0,right=n-1;\\n        int res=0;\\n        \\n        while(left<right)\\n        {\\n            int l=left,r=right; \\n            while(s[l]!=s[r])\\n            l++;//traversing from the left in search of the same ele as s[r]\\n        \\n            //if we do not get another occurence of s[r] i.e., there is only one instance and hence it will be the middle ele\\n            //we swap s[l] with the previous char to check whether another instance of that char is present so that we can \\n            //swap to make a valid palindromic string\\n            \\n        if(l==r)\\n        {\\n            //on doing this repeatedly for each window we have the single char at s[l] and finally at the last\\n            //iteration l will point to the middle of the string and hence the single ele will be placed at the middle of the\\n            //string resulting into a valid palindromic string\\n            \\n            swap(s[l-1],s[l]);\\n            res++;\\n            //here we do not decrease the size of the current window \\n            //for checking once again in the same window\\n            continue;\\n        }\\n        else\\n        {\\n            while(l>left)\\n            {\\n                swap(s[l-1],s[l]);\\n                res++;\\n                l--;\\n            }\\n        }\\n            //swap is done and hence we are sure that s[left]==s[right]\\n            //now we decrease the size of the window from both the sides and do the same process again\\n            left++;\\n            right--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int n=s.length();\\n        int left=0,right=n-1;\\n        int res=0;\\n        \\n        while(left<right)\\n        {\\n            int l=left,r=right; \\n            while(s[l]!=s[r])\\n            l++;//traversing from the left in search of the same ele as s[r]\\n        \\n            //if we do not get another occurence of s[r] i.e., there is only one instance and hence it will be the middle ele\\n            //we swap s[l] with the previous char to check whether another instance of that char is present so that we can \\n            //swap to make a valid palindromic string\\n            \\n        if(l==r)\\n        {\\n            //on doing this repeatedly for each window we have the single char at s[l] and finally at the last\\n            //iteration l will point to the middle of the string and hence the single ele will be placed at the middle of the\\n            //string resulting into a valid palindromic string\\n            \\n            swap(s[l-1],s[l]);\\n            res++;\\n            //here we do not decrease the size of the current window \\n            //for checking once again in the same window\\n            continue;\\n        }\\n        else\\n        {\\n            while(l>left)\\n            {\\n                swap(s[l-1],s[l]);\\n                res++;\\n                l--;\\n            }\\n        }\\n            //swap is done and hence we are sure that s[left]==s[right]\\n            //now we decrease the size of the window from both the sides and do the same process again\\n            left++;\\n            right--;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823441,
                "title": "python-easy-and-good-solution",
                "content": "**let\\'s take one example:** let ```s = \"letelt\"```. we have two cases where final ```s``` can start with ```l``` or final ```s``` can end with ```t```. we calculate moves  for both of them. for final ```s``` starts with ```l``` takes  1 swap(i.e letetl) and for final ```s``` ends with ```t``` takes two swap (i.e tleelt). starting with ```l``` is minimun so continue the process recursion with deleting both start and end letter of s. \\n\\n**TIME COMPLEXITY**:\\n```O(n*n)```\\n\\n**code**\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \\n        @lru_cache(None)\\n        def check(w):\\n\\t\\t#base case\\n            if w==w[::-1]:\\n                return 0\\n            ans=0\\n\\t\\t#if already both ends are equal\\n            if w[0]==w[-1]:\\n                return check(w[1:-1])\\n            else:\\n                wi=w[::-1]\\n\\t\\t\\t\\t#i=first letter of word\\n                i=w[0]\\n\\t\\t\\t\\t#j is the last letter of the word\\n                j=wi[0]\\n\\t\\t\\t\\t#k is the no of swaps to make in w of j letter. This is fo checking swap with ending case\\n                k=w.index(j)\\n\\t\\t\\t\\t#swaps for starting case\\n                z=wi.index(i)\\n\\t\\t\\t\\t#final words after deleting\\n                q=w[:k]+w[k+1:-1]\\n                a=wi[:z]+wi[z+1:-1]\\n                #checking greedy\\n                if k<z:\\n                    ans+=check(q)+k\\n                else:\\n                    ans+=check(a)+z\\n            return ans\\n        return check(s)\\n```\\n**Please Upvote! I Really Appreciate it If You Upvote.**\\n",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```s = \"letelt\"```\n```s```\n```l```\n```s```\n```t```\n```s```\n```l```\n```s```\n```t```\n```l```\n```O(n*n)```\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \\n        @lru_cache(None)\\n        def check(w):\\n\\t\\t#base case\\n            if w==w[::-1]:\\n                return 0\\n            ans=0\\n\\t\\t#if already both ends are equal\\n            if w[0]==w[-1]:\\n                return check(w[1:-1])\\n            else:\\n                wi=w[::-1]\\n\\t\\t\\t\\t#i=first letter of word\\n                i=w[0]\\n\\t\\t\\t\\t#j is the last letter of the word\\n                j=wi[0]\\n\\t\\t\\t\\t#k is the no of swaps to make in w of j letter. This is fo checking swap with ending case\\n                k=w.index(j)\\n\\t\\t\\t\\t#swaps for starting case\\n                z=wi.index(i)\\n\\t\\t\\t\\t#final words after deleting\\n                q=w[:k]+w[k+1:-1]\\n                a=wi[:z]+wi[z+1:-1]\\n                #checking greedy\\n                if k<z:\\n                    ans+=check(q)+k\\n                else:\\n                    ans+=check(a)+z\\n            return ans\\n        return check(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822409,
                "title": "java-o-n-log-n-solution-with-binary-index-trees",
                "content": "```\\nclass Solution {\\n    List<Integer> [] charList;\\n    int [][] charPointers;\\n    int [] BIT;\\n    \\n    public int minMovesToMakePalindrome(String s) {\\n            \\n        charList = new List[26];\\n        charPointers = new int [26][2];\\n        BIT = new int [s.length()];\\n        \\n        for (int i = 0; i < 26; ++i){\\n            charList[i] = new ArrayList<>();\\n        }\\n        \\n        for (int i = 0; i < s.length(); ++i)\\n            charList[s.charAt(i) - \\'a\\'].add(i);\\n        \\n        for (int i = 0; i < 26; ++i){\\n            charPointers[i][0] = 0;\\n            charPointers[i][1] = charList[i].size() - 1;\\n        }\\n        \\n        int l = 0;\\n        int lP, rP;\\n        char c;\\n        int result = 0;\\n        int currentIdx;\\n        boolean [] visited = new boolean [s.length()];\\n        \\n        int mid = s.length() / 2;\\n        \\n        for (int r = s.length() - 1; r > l; --r){\\n            if (visited[r]) continue;\\n            \\n            c = s.charAt(r);\\n            \\n            lP = charList[c - \\'a\\'].get(charPointers[c - \\'a\\'][0]++);\\n            rP = charList[c - \\'a\\'].get(charPointers[c - \\'a\\'][1]--);\\n            \\n            visited[lP] = true;\\n            visited[rP] = true;\\n            \\n            if (lP == rP){\\n                result += Math.max(mid , 0);\\n                addToBIT(lP);\\n                continue;\\n            }\\n            \\n            result += lP  - getBITVal(lP);\\n            addToBIT(lP);\\n            --mid;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void addToBIT(int val){\\n        ++val;\\n        \\n        for (int i = val; i < BIT.length; i += (i & -i)){\\n            ++BIT[i];\\n        }\\n    }\\n    \\n    private int getBITVal(int val){\\n        val++;\\n        int result = 0;\\n        \\n        for (int i = val; i > 0; i -= (i & -i)){\\n            result += BIT[i];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution {\\n    List<Integer> [] charList;\\n    int [][] charPointers;\\n    int [] BIT;\\n    \\n    public int minMovesToMakePalindrome(String s) {\\n            \\n        charList = new List[26];\\n        charPointers = new int [26][2];\\n        BIT = new int [s.length()];\\n        \\n        for (int i = 0; i < 26; ++i){\\n            charList[i] = new ArrayList<>();\\n        }\\n        \\n        for (int i = 0; i < s.length(); ++i)\\n            charList[s.charAt(i) - \\'a\\'].add(i);\\n        \\n        for (int i = 0; i < 26; ++i){\\n            charPointers[i][0] = 0;\\n            charPointers[i][1] = charList[i].size() - 1;\\n        }\\n        \\n        int l = 0;\\n        int lP, rP;\\n        char c;\\n        int result = 0;\\n        int currentIdx;\\n        boolean [] visited = new boolean [s.length()];\\n        \\n        int mid = s.length() / 2;\\n        \\n        for (int r = s.length() - 1; r > l; --r){\\n            if (visited[r]) continue;\\n            \\n            c = s.charAt(r);\\n            \\n            lP = charList[c - \\'a\\'].get(charPointers[c - \\'a\\'][0]++);\\n            rP = charList[c - \\'a\\'].get(charPointers[c - \\'a\\'][1]--);\\n            \\n            visited[lP] = true;\\n            visited[rP] = true;\\n            \\n            if (lP == rP){\\n                result += Math.max(mid , 0);\\n                addToBIT(lP);\\n                continue;\\n            }\\n            \\n            result += lP  - getBITVal(lP);\\n            addToBIT(lP);\\n            --mid;\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void addToBIT(int val){\\n        ++val;\\n        \\n        for (int i = val; i < BIT.length; i += (i & -i)){\\n            ++BIT[i];\\n        }\\n    }\\n    \\n    private int getBITVal(int val){\\n        val++;\\n        int result = 0;\\n        \\n        for (int i = val; i > 0; i -= (i & -i)){\\n            result += BIT[i];\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875388,
                "title": "c-two-pointers-greedy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int low = 0;\\n        int high = s.length()-1;\\n\\n        int count = 0;\\n        while (low<=high)\\n        {\\n            if (s[low] != s[high])\\n            {\\n                int i = high-1;\\n                while (i>=low+1)\\n                {\\n                    if (s[low] == s[i])\\n                    {\\n                        break;\\n                    }\\n                    i--;\\n                }\\n\\n                int j = low+1;\\n                while (j<=high-1)\\n                {\\n                    if (s[high]==s[j])\\n                    {\\n                        break;\\n                    }\\n                    j++;\\n                }\\n\\n                int d1 = high-i;\\n                int d2 = j-low;\\n\\n                if (d1<=d2)\\n                {\\n\\n                    while (i<=high-1)\\n                    {\\n                        swap(s[i],s[i+1]);\\n                        count++;\\n                        i++;\\n                    }\\n                }\\n                else\\n                {\\n                    while (j>=low+1)\\n                    {\\n                        swap(s[j],s[j-1]);\\n                        count++;\\n                        j--;\\n                    }\\n                }\\n            }\\n            low++;\\n            high--;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int low = 0;\\n        int high = s.length()-1;\\n\\n        int count = 0;\\n        while (low<=high)\\n        {\\n            if (s[low] != s[high])\\n            {\\n                int i = high-1;\\n                while (i>=low+1)\\n                {\\n                    if (s[low] == s[i])\\n                    {\\n                        break;\\n                    }\\n                    i--;\\n                }\\n\\n                int j = low+1;\\n                while (j<=high-1)\\n                {\\n                    if (s[high]==s[j])\\n                    {\\n                        break;\\n                    }\\n                    j++;\\n                }\\n\\n                int d1 = high-i;\\n                int d2 = j-low;\\n\\n                if (d1<=d2)\\n                {\\n\\n                    while (i<=high-1)\\n                    {\\n                        swap(s[i],s[i+1]);\\n                        count++;\\n                        i++;\\n                    }\\n                }\\n                else\\n                {\\n                    while (j>=low+1)\\n                    {\\n                        swap(s[j],s[j-1]);\\n                        count++;\\n                        j--;\\n                    }\\n                }\\n            }\\n            low++;\\n            high--;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3785032,
                "title": "easy-understandable-c-solution-greedy-two-pointers",
                "content": "# Intuition + Approach\\n- We basically try to convert the second half of the string into the first half.\\n- To do this, We greedily pick the closest element to the right pointer and swap it until we reach its correct position, i..e.. (n-i-1).\\n- An edge case will be when the length of the string is odd and there\\'s a character which occurs an odd number of times, and then this odd character should be present in the middle of the whole string.\\n- To do this, if the character is found at the same index as the left pointer, then we just shift it by one to the right,so that it comes in the middle eventually.\\n\\n# Complexity\\n- Time complexity: O(n*n) worst case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) , constant space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n---\\n> \\uD83C\\uDF86Upvote\\uD83C\\uDF86\\n\\n---\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minMovesToMakePalindrome(string s){\\n        int left=0,right=s.size()-1;\\n        int out=0;\\n\\n        while(left<right){\\n            if(s[left]==s[right]){\\n                left++;\\n                right--;\\n            }\\n            else{\\n                int r=right-1;\\n                while(s[left]!=s[r])r--;\\n                if(r==left){\\n                    swap(s[r],s[r+1]);\\n                    out++;\\n                }\\n                else{\\n                    while(r<right){\\n                        swap(s[r],s[r+1]);\\n                        out++;\\n                        r++;\\n                    }\\n                    left++;\\n                    right--;\\n                }\\n            }\\n        }\\n\\n        return out;\\n    }\\n};\\n```\\n![upvote xd.jpeg](https://assets.leetcode.com/users/images/affb622f-4207-4037-9821-0f5cba15aa17_1689714255.0265648.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minMovesToMakePalindrome(string s){\\n        int left=0,right=s.size()-1;\\n        int out=0;\\n\\n        while(left<right){\\n            if(s[left]==s[right]){\\n                left++;\\n                right--;\\n            }\\n            else{\\n                int r=right-1;\\n                while(s[left]!=s[r])r--;\\n                if(r==left){\\n                    swap(s[r],s[r+1]);\\n                    out++;\\n                }\\n                else{\\n                    while(r<right){\\n                        swap(s[r],s[r+1]);\\n                        out++;\\n                        r++;\\n                    }\\n                    left++;\\n                    right--;\\n                }\\n            }\\n        }\\n\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460146,
                "title": "simple-iterative-solution",
                "content": "# Intuition\\nin each iteration of the while loop(outer) we are solving a subproblem or trying to make the chars to be equal \\nfor that we can either swap the s[l] to next similar char on the right which is equal to s[r]\\nor we can swap s[r] we the next similar char on the left which is equal to s[l] \\neither way would work\\n//since the ans  is possible in every cases as mentioned by the question if we are unable to make chars similar at an index that the char will be the part of the middlwe of the pallindrome\\nin inner while loops we are calculating the total nbumber of swaps\\neach time we try to make the chars at l and r as equal \\nafter each iteration of the outer while loop we only require to find the min swaps in s[lt..rt] as we have made the rest as pallindrome\\nthis is some kind of a subproblem \\nhere  choosing the next first occrrence on the left or the right which can make the curr 2 as equal is the greedy approach here \\nwhich works for the all the test cases\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n\\n        //here we will be using an iterative recursive approach \\n        int lt=0;\\n        int rt=s.size()-1;\\n        int ans=0;\\n        //ans will keep track of the minimum number of swaps required to make it pallindrome in the most \\n        //optimal ways\\n        int l;\\n        int r;\\n        while(lt<rt){\\n          l=lt;\\n          r=rt;\\n\\n          while(s[l]!=s[r])l++;\\n          //finding the first occurence from the right side which can make the current 2 characters equal\\n          if(l==r){\\n            //then it will be part of the odd length part in btw the whole pallindrome\\n            swap(s[l],s[l-1]);//here we will be using the internal c++  swapping function\\n            ans++;\\n            continue;\\n          }\\n          while(l>lt){\\n            swap(s[l],s[l-1]);\\n            l--;\\n            ans++;\\n          }\\n          lt++;\\n          rt--;\\n          \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n\\n        //here we will be using an iterative recursive approach \\n        int lt=0;\\n        int rt=s.size()-1;\\n        int ans=0;\\n        //ans will keep track of the minimum number of swaps required to make it pallindrome in the most \\n        //optimal ways\\n        int l;\\n        int r;\\n        while(lt<rt){\\n          l=lt;\\n          r=rt;\\n\\n          while(s[l]!=s[r])l++;\\n          //finding the first occurence from the right side which can make the current 2 characters equal\\n          if(l==r){\\n            //then it will be part of the odd length part in btw the whole pallindrome\\n            swap(s[l],s[l-1]);//here we will be using the internal c++  swapping function\\n            ans++;\\n            continue;\\n          }\\n          while(l>lt){\\n            swap(s[l],s[l-1]);\\n            l--;\\n            ans++;\\n          }\\n          lt++;\\n          rt--;\\n          \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942333,
                "title": "best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n\\n        \\n        int result=0;\\n        int start=0,end=s.size()-1;\\n\\n       while(end>start){\\n             if(s[start]!=s[end]){\\n            int i=end;\\n            while(i>start&&s[start]!=s[i]){\\n                i--;\\n            }\\n            if(i==start){\\n                swap(s[start],s[start+1]);\\n                result++;\\n                \\n            }\\n            else{\\n                while(i<end){\\n                    swap(s[i],s[i+1]);\\n                    result++;\\n                    i++;\\n                }\\n                start++;\\n                end--;\\n            }\\n        }\\n        else{\\n            start++;\\n            end--;\\n        }\\n       }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n\\n        \\n        int result=0;\\n        int start=0,end=s.size()-1;\\n\\n       while(end>start){\\n             if(s[start]!=s[end]){\\n            int i=end;\\n            while(i>start&&s[start]!=s[i]){\\n                i--;\\n            }\\n            if(i==start){\\n                swap(s[start],s[start+1]);\\n                result++;\\n                \\n            }\\n            else{\\n                while(i<end){\\n                    swap(s[i],s[i+1]);\\n                    result++;\\n                    i++;\\n                }\\n                start++;\\n                end--;\\n            }\\n        }\\n        else{\\n            start++;\\n            end--;\\n        }\\n       }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812340,
                "title": "python-2-pointers-explanation",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        # At each point, we look at the first and the last elements\\n        # if they are the same, then we skip them, else we find\\n        # another element in the string that matches the left\\n        # element and then we make the necessary swaps to move it\\n        # to the right place. \\n        # if we can\\'t find that element -- this means this is the middle element\\n        # in the palindrome, we just move it one position to the right and continue\\n        # over the next few iterations, it will be moved to the center automatically\\n        # run it for string = \"dpacacp\", answer should be 4\\n        # the character that should be in the middle is \"d\"\\n        l, r, res, st = 0, len(s)-1, 0, list(s)\\n        while l < r:\\n            if st[l] != st[r]:\\n                i = r\\n                while i > l and st[l] != st[i]:\\n                    i -= 1\\n                if i == l:\\n                    st[i], st[i+1] = st[i+1], st[i]\\n                    res += 1\\n                    continue\\n                else:\\n                    while i < r:\\n                        st[i], st[i+1] = st[i+1], st[i]\\n                        i += 1\\n                        res += 1\\n            l, r = l+1, r-1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        # At each point, we look at the first and the last elements\\n        # if they are the same, then we skip them, else we find\\n        # another element in the string that matches the left\\n        # element and then we make the necessary swaps to move it\\n        # to the right place. \\n        # if we can\\'t find that element -- this means this is the middle element\\n        # in the palindrome, we just move it one position to the right and continue\\n        # over the next few iterations, it will be moved to the center automatically\\n        # run it for string = \"dpacacp\", answer should be 4\\n        # the character that should be in the middle is \"d\"\\n        l, r, res, st = 0, len(s)-1, 0, list(s)\\n        while l < r:\\n            if st[l] != st[r]:\\n                i = r\\n                while i > l and st[l] != st[i]:\\n                    i -= 1\\n                if i == l:\\n                    st[i], st[i+1] = st[i+1], st[i]\\n                    res += 1\\n                    continue\\n                else:\\n                    while i < r:\\n                        st[i], st[i+1] = st[i+1], st[i]\\n                        i += 1\\n                        res += 1\\n            l, r = l+1, r-1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2657441,
                "title": "java-easy-solution-w-comments-using-two-pointer-swapping",
                "content": "# Intuition\\nJava Solution to Minimum Number of Moves To Make Palindrome. Uses a Two Pointer approach with swapping.\\n\\nIncluded comments for reference.\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int minMovesToMakePalindrome(String s) {\\n        int len = s.length();\\n        if (len == 0) return -1;\\n\\n        char[] chars = s.toCharArray();             // Init char array of all characters from s\\n        int swaps = 0;                              // int to store final number of swaps taken to make the palindrome\\n\\n        // Use a two-pointer approach, initialize int pointer for left and right\\n        int left = 0;\\n        int right = len - 1;\\n\\n        while (left < right)\\n        {\\n            // Found a palindrome\\n            if (chars[left] == chars[right])\\n            {\\n                left++;                             // Increment left pointer\\n                right--;                            // Decrement right pointer\\n            }\\n            // Characters are not palindrome\\n            else\\n            {\\n                // Search for character moving towards the starting point \\'left\\' to ensure\\n                // minimum number of moves until char at k matches char at \\'left\\'\\n                int k = right;\\n                k = findIndexMatchingLeftIndex(chars, left, k);\\n\\n                // Character matching char at index \\'left\\' was not found between initial k index and left index\\n                if (k == left)\\n                {\\n                    swaps++;                        // Increment swap count\\n                    swapChars(chars, left);         // Swap left with left + 1\\n                }\\n                // Character matching char at index \\'left\\' was found between initial k index and left index\\n                // Swap all characters from k to k + 1\\n                else\\n                {\\n                    while (k < right)\\n                    {\\n                        swaps++;\\n                        swapChars(chars, k);\\n                        k++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return the number of swaps (Moves) needed to make the Palindrome\\n        return swaps;\\n    }\\n\\n    /**\\n     * Swap Characters In The Character Array.\\n     */\\n    public void swapChars(char[] chars, int left) {\\n        // Swap chars[]\\n        if (left -1 < chars.length)\\n        {\\n            char temp = chars[left];\\n            chars[left] = chars[left + 1];\\n            chars[left + 1] = temp;\\n        }\\n    }\\n\\n    /**\\n     * Finds The Kth Index In The Input char[] That Matches The Character At The Left Index Of The Input char[].\\n     */\\n    public int findIndexMatchingLeftIndex(char[] chars, int left, int k) {\\n        while (left < k)\\n        {\\n            if (chars[k] == chars[left])\\n            {\\n                return k;\\n            }\\n            k--;                                    // Decrement k to compare with the previous index of the arr with left\\n        }\\n\\n        return k;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Binary Indexed Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minMovesToMakePalindrome(String s) {\\n        int len = s.length();\\n        if (len == 0) return -1;\\n\\n        char[] chars = s.toCharArray();             // Init char array of all characters from s\\n        int swaps = 0;                              // int to store final number of swaps taken to make the palindrome\\n\\n        // Use a two-pointer approach, initialize int pointer for left and right\\n        int left = 0;\\n        int right = len - 1;\\n\\n        while (left < right)\\n        {\\n            // Found a palindrome\\n            if (chars[left] == chars[right])\\n            {\\n                left++;                             // Increment left pointer\\n                right--;                            // Decrement right pointer\\n            }\\n            // Characters are not palindrome\\n            else\\n            {\\n                // Search for character moving towards the starting point \\'left\\' to ensure\\n                // minimum number of moves until char at k matches char at \\'left\\'\\n                int k = right;\\n                k = findIndexMatchingLeftIndex(chars, left, k);\\n\\n                // Character matching char at index \\'left\\' was not found between initial k index and left index\\n                if (k == left)\\n                {\\n                    swaps++;                        // Increment swap count\\n                    swapChars(chars, left);         // Swap left with left + 1\\n                }\\n                // Character matching char at index \\'left\\' was found between initial k index and left index\\n                // Swap all characters from k to k + 1\\n                else\\n                {\\n                    while (k < right)\\n                    {\\n                        swaps++;\\n                        swapChars(chars, k);\\n                        k++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Return the number of swaps (Moves) needed to make the Palindrome\\n        return swaps;\\n    }\\n\\n    /**\\n     * Swap Characters In The Character Array.\\n     */\\n    public void swapChars(char[] chars, int left) {\\n        // Swap chars[]\\n        if (left -1 < chars.length)\\n        {\\n            char temp = chars[left];\\n            chars[left] = chars[left + 1];\\n            chars[left + 1] = temp;\\n        }\\n    }\\n\\n    /**\\n     * Finds The Kth Index In The Input char[] That Matches The Character At The Left Index Of The Input char[].\\n     */\\n    public int findIndexMatchingLeftIndex(char[] chars, int left, int k) {\\n        while (left < k)\\n        {\\n            if (chars[k] == chars[left])\\n            {\\n                return k;\\n            }\\n            k--;                                    // Decrement k to compare with the previous index of the arr with left\\n        }\\n\\n        return k;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614313,
                "title": "rust-simple-greedy-solution",
                "content": "For any string with length > 1, check the number of moves required to make the string with equal leftmost and rightmost characters. Remove the leftmost and the rightmost characters. Repeat the procedure until the string length less than or equal to 1. The sum of all moves is the answer.\\n\\n```rust\\nuse std::collections::*;\\n \\nimpl Solution {\\n\\tpub fn min_moves_to_make_palindrome(s: String) -> i32 {\\n\\t\\tlet mut s = s.clone();\\n\\t\\tlet mut ans = 0;\\n\\t\\twhile s.len() > 1 {\\n\\t\\t\\tlet i = s.rfind(s.chars().nth(0).unwrap()).unwrap();\\n\\t\\t\\tif i != 0 {\\n\\t\\t\\t\\tans += (s.len() - 1 - i) as i32;\\n\\t\\t\\t\\ts = format!(\"{}{}\", &s[1..i], &s[i + 1..]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlet i = s.find(s.chars().last().unwrap()).unwrap();\\n\\t\\t\\t\\tans += i as i32;\\n\\t\\t\\t\\ts = format!(\"{}{}\", &s[..i], &s[i + 1..(s.len() - 1)]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Greedy"
                ],
                "code": "```rust\\nuse std::collections::*;\\n \\nimpl Solution {\\n\\tpub fn min_moves_to_make_palindrome(s: String) -> i32 {\\n\\t\\tlet mut s = s.clone();\\n\\t\\tlet mut ans = 0;\\n\\t\\twhile s.len() > 1 {\\n\\t\\t\\tlet i = s.rfind(s.chars().nth(0).unwrap()).unwrap();\\n\\t\\t\\tif i != 0 {\\n\\t\\t\\t\\tans += (s.len() - 1 - i) as i32;\\n\\t\\t\\t\\ts = format!(\"{}{}\", &s[1..i], &s[i + 1..]);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlet i = s.find(s.chars().last().unwrap()).unwrap();\\n\\t\\t\\t\\tans += i as i32;\\n\\t\\t\\t\\ts = format!(\"{}{}\", &s[..i], &s[i + 1..(s.len() - 1)]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tans\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2604630,
                "title": "python3-easy-to-understand-2-pointer-solution-with-comments",
                "content": "```\\n\\'\\'\\'\\nidea is to fix one side (left or right) and make other side equal to it\\nfor e.g. \\naabb , I will make right side equal to left.\\n1. index[0] = a != index[3] = b \\n2. now look for a from right to left \\n3. once found swap with adjacent element till it reaches index[3].\\n4. abba. is palindrome. took 2 swaps, \\n\\nfor cases like abb \\n1. we fixed left side a. \\n2. now from right we will move to left looking for a , we found it at index 0 which is our left\\n3. now when left == right, just swap it with next adjacent element and continue.\\n4. you will get your palindrome\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        n = len(s)\\n        lt = 0\\n        rt = n-1\\n        ans = 0\\n        while lt < rt:\\n            l = lt\\n            r = rt\\n            while s[l] != s[r]:\\n                r -= 1\\n            # for abb like case\\n            # swap(s[r], s[r+1])\\n            # bab\\n            if l == r:\\n                s[r], s[r+1] = s[r+1], s[r]\\n                ans += 1\\n                continue\\n            else:\\n\\t\\t\\t# for aabb like case\\n                while r < rt:\\n                    s[r], s[r+1] = s[r+1], s[r]\\n                    ans += 1\\n                    r += 1\\n            lt += 1\\n            rt -= 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\n\\'\\'\\'\\nidea is to fix one side (left or right) and make other side equal to it\\nfor e.g. \\naabb , I will make right side equal to left.\\n1. index[0] = a != index[3] = b \\n2. now look for a from right to left \\n3. once found swap with adjacent element till it reaches index[3].\\n4. abba. is palindrome. took 2 swaps, \\n\\nfor cases like abb \\n1. we fixed left side a. \\n2. now from right we will move to left looking for a , we found it at index 0 which is our left\\n3. now when left == right, just swap it with next adjacent element and continue.\\n4. you will get your palindrome\\n\\n\\'\\'\\'\\n\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        n = len(s)\\n        lt = 0\\n        rt = n-1\\n        ans = 0\\n        while lt < rt:\\n            l = lt\\n            r = rt\\n            while s[l] != s[r]:\\n                r -= 1\\n            # for abb like case\\n            # swap(s[r], s[r+1])\\n            # bab\\n            if l == r:\\n                s[r], s[r+1] = s[r+1], s[r]\\n                ans += 1\\n                continue\\n            else:\\n\\t\\t\\t# for aabb like case\\n                while r < rt:\\n                    s[r], s[r+1] = s[r+1], s[r]\\n                    ans += 1\\n                    r += 1\\n            lt += 1\\n            rt -= 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2603132,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int ans=0;\\n        char arr[]=s.toCharArray();\\n        int i=0; \\n        int j=arr.length-1;\\n        while(i<j){\\n            int high=j;\\n            if(arr[i]==arr[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                while(arr[i]!=arr[high]){\\n                    high--;\\n                }\\n                \\n                if(i==high) {\\n                 swap(arr,high,high+1);  // mid elememt\\n                   ans++;\\n                continue;\\n                    }\\n                \\n                else{\\n                \\n                 while(high<j){  \\n                    swap(arr,high,high+1);\\n                    ans++;\\n                    high++;\\n                }\\n            }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    public static void swap(char ch[],int i,int j){\\n        \\n        char t=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=t;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int ans=0;\\n        char arr[]=s.toCharArray();\\n        int i=0; \\n        int j=arr.length-1;\\n        while(i<j){\\n            int high=j;\\n            if(arr[i]==arr[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                while(arr[i]!=arr[high]){\\n                    high--;\\n                }\\n                \\n                if(i==high) {\\n                 swap(arr,high,high+1);  // mid elememt\\n                   ans++;\\n                continue;\\n                    }\\n                \\n                else{\\n                \\n                 while(high<j){  \\n                    swap(arr,high,high+1);\\n                    ans++;\\n                    high++;\\n                }\\n            }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    public static void swap(char ch[],int i,int j){\\n        \\n        char t=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=t;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2533462,
                "title": "python-2-pointer-approach",
                "content": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        res, left, right = 0, 0, len(s) - 1\\n        while left < right:\\n            l, r = left, right\\n            while s[l] != s[r]:\\n                r -= 1\\n            if l == r:\\n                s[r], s[r + 1] = s[r + 1], s[r]\\n                res += 1\\n                continue\\n            else:\\n                while r < right:\\n                    s[r], s[r + 1] = s[r + 1], s[r]\\n                    res += 1\\n                    r += 1\\n            left += 1\\n            right -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        res, left, right = 0, 0, len(s) - 1\\n        while left < right:\\n            l, r = left, right\\n            while s[l] != s[r]:\\n                r -= 1\\n            if l == r:\\n                s[r], s[r + 1] = s[r + 1], s[r]\\n                res += 1\\n                continue\\n            else:\\n                while r < right:\\n                    s[r], s[r + 1] = s[r + 1], s[r]\\n                    res += 1\\n                    r += 1\\n            left += 1\\n            right -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525848,
                "title": "c-simple-c-code",
                "content": "**Taken the help by master piece submission by**\\nhttps://leetcode.com/be_quick/\\n\\n# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int i = 0, j = s.size()-1, ans = 0;\\n        while(i < j)\\n        {\\n            while(s[i] == s[j])\\n            {\\n                if(i >= j)\\n                    return ans;\\n                i++;\\n                j--;\\n            }\\n            int indx = -1;\\n            for(int k = j-1; k > i; k--)\\n            {\\n                if(s[i] != s[k])\\n                    continue;\\n                indx = k;\\n                break;\\n            }\\n            if(indx != -1)\\n            {\\n                for(int k = indx; k < j; k++)\\n                {\\n                    swap(s[k], s[k+1]);\\n                    ans++;\\n                }\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                swap(s[i], s[i+1]);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int i = 0, j = s.size()-1, ans = 0;\\n        while(i < j)\\n        {\\n            while(s[i] == s[j])\\n            {\\n                if(i >= j)\\n                    return ans;\\n                i++;\\n                j--;\\n            }\\n            int indx = -1;\\n            for(int k = j-1; k > i; k--)\\n            {\\n                if(s[i] != s[k])\\n                    continue;\\n                indx = k;\\n                break;\\n            }\\n            if(indx != -1)\\n            {\\n                for(int k = indx; k < j; k++)\\n                {\\n                    swap(s[k], s[k+1]);\\n                    ans++;\\n                }\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                swap(s[i], s[i+1]);\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512462,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int MinMovesToMakePalindrome(string s) {\\n        List<char> list = s.ToList();\\n        int moves = 0;\\n        while(list.Count > 2){\\n            char target = list[0];\\n            int i = list.FindLastIndex(ch => ch == target);\\n            if(i != 0){\\n                moves += list.Count-i-1;\\n                list.RemoveAt(i);\\n                list.RemoveAt(0);\\n            } else{\\n                target = list[list.Count-1];\\n                i = list.FindIndex(ch => ch == target);\\n                moves += i;\\n                list.RemoveAt(list.Count-1);\\n                list.RemoveAt(i);\\n            }\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinMovesToMakePalindrome(string s) {\\n        List<char> list = s.ToList();\\n        int moves = 0;\\n        while(list.Count > 2){\\n            char target = list[0];\\n            int i = list.FindLastIndex(ch => ch == target);\\n            if(i != 0){\\n                moves += list.Count-i-1;\\n                list.RemoveAt(i);\\n                list.RemoveAt(0);\\n            } else{\\n                target = list[list.Count-1];\\n                i = list.FindIndex(ch => ch == target);\\n                moves += i;\\n                list.RemoveAt(list.Count-1);\\n                list.RemoveAt(i);\\n            }\\n        }\\n        return moves;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399882,
                "title": "java-o-nlogn-harder-variant-of-1505",
                "content": "This question is the harder version of [#1505 (link)](https://leetcode.com/problems/minimum-possible-integer-after-at-most-k-adjacent-swaps-on-digits), so I can recommend that you do that problem first before coming back to this one. The idea is basically the same - to know what its actual position is, we need the prefix sum AND suffix sum of the characters we\\'ve swapped.\\n\\nHere I am using 2 BIT arrays for the sake of simplicity.  There are 2 cases, for the one we are switching to the head, denoted by `a` in my code below, it\\'s cost needed is `L - i + (i - sum(head, L)) - sum(tail, L);`. \\n> It translates to \"Current index - current head position + all the characters behind it that moved to the head previously - all the characters ahead of it that moved to the tail` \\n\\nFor the one moving to tail, it needs `j - R + sum(tail, R) - (i - sum(head, R))`\\n\\n#### Java\\n```Java\\n// Time O(nlogn)\\n// Space O(n)\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] A = s.toCharArray();\\n        Deque<Integer>[] deque = new ArrayDeque[26];\\n        Arrays.setAll(deque, o -> new ArrayDeque<>());\\n        for (int i = 0; i < A.length; i++){\\n            deque[A[i]-\\'a\\'].offer(i);\\n        }\\n        int[] head = new int[A.length+1];\\n        int[] tail = new int[A.length+1];\\n        int i = 0, j = s.length()-1, ans = 0;\\n        while(i < j){\\n            int min = (int)1e9, idx = -1;\\n            for (int k = 0; k < 26; k++){\\n                if (deque[k].size()>=2){\\n                    int L = deque[k].peekFirst(), R = deque[k].peekLast();\\n                    int a = L - i + (i - sum(head, L)) - sum(tail, L);\\n                    int b = j - R + sum(tail, R) - (i - sum(head, R));\\n                    if (a+b < min){\\n                        min=a+b;\\n                        idx=k;\\n                    }\\n                }\\n            }\\n            ans += min;\\n            add(head, deque[idx].pollFirst(), 1);\\n            add(tail, deque[idx].pollLast(), 1);\\n            i++;\\n            j--;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private void add(int[] bit, int idx, int inc){\\n        for (++idx; idx < bit.length; idx += idx & -idx){\\n            bit[idx]+=inc;\\n        }\\n    }\\n\\n    private int sum(int[] bit, int idx){\\n        int ans = 0;\\n        for (++idx; idx > 0; idx -= idx & -idx){\\n            ans += bit[idx];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\n// Time O(nlogn)\\n// Space O(n)\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] A = s.toCharArray();\\n        Deque<Integer>[] deque = new ArrayDeque[26];\\n        Arrays.setAll(deque, o -> new ArrayDeque<>());\\n        for (int i = 0; i < A.length; i++){\\n            deque[A[i]-\\'a\\'].offer(i);\\n        }\\n        int[] head = new int[A.length+1];\\n        int[] tail = new int[A.length+1];\\n        int i = 0, j = s.length()-1, ans = 0;\\n        while(i < j){\\n            int min = (int)1e9, idx = -1;\\n            for (int k = 0; k < 26; k++){\\n                if (deque[k].size()>=2){\\n                    int L = deque[k].peekFirst(), R = deque[k].peekLast();\\n                    int a = L - i + (i - sum(head, L)) - sum(tail, L);\\n                    int b = j - R + sum(tail, R) - (i - sum(head, R));\\n                    if (a+b < min){\\n                        min=a+b;\\n                        idx=k;\\n                    }\\n                }\\n            }\\n            ans += min;\\n            add(head, deque[idx].pollFirst(), 1);\\n            add(tail, deque[idx].pollLast(), 1);\\n            i++;\\n            j--;\\n        }\\n\\n        return ans;\\n    }\\n\\n    private void add(int[] bit, int idx, int inc){\\n        for (++idx; idx < bit.length; idx += idx & -idx){\\n            bit[idx]+=inc;\\n        }\\n    }\\n\\n    private int sum(int[] bit, int idx){\\n        int ans = 0;\\n        for (++idx; idx > 0; idx -= idx & -idx){\\n            ans += bit[idx];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2384907,
                "title": "python-simple-recursion-97-time",
                "content": "```\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n = len(s)\\n        if n <= 1:\\n            return 0\\n        if s[0]==s[-1]:\\n            return self.minMovesToMakePalindrome(s[1:-1])\\n        \\n        ind_l, ind_r = s.find(s[-1]), s.rfind(s[0])\\n        if ind_l <= n-1-ind_r:\\n            return ind_l + self.minMovesToMakePalindrome(s[:ind_l] + s[ind_l+1:-1])\\n        else:\\n            return n-1-ind_r + self.minMovesToMakePalindrome(s[1:ind_r] + s[ind_r+1:])\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n = len(s)\\n        if n <= 1:\\n            return 0\\n        if s[0]==s[-1]:\\n            return self.minMovesToMakePalindrome(s[1:-1])\\n        \\n        ind_l, ind_r = s.find(s[-1]), s.rfind(s[0])\\n        if ind_l <= n-1-ind_r:\\n            return ind_l + self.minMovesToMakePalindrome(s[:ind_l] + s[ind_l+1:-1])\\n        else:\\n            return n-1-ind_r + self.minMovesToMakePalindrome(s[1:ind_r] + s[ind_r+1:])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2259580,
                "title": "c-two-pointers-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n     Two cases can come\\n     while we can compare first half with other half\\n     case 1  aabb -> a != b come back and see if we find a , we finally find an \\'a\\' at aa so swap it till we bring it at end to match , abab swap again abba, now a==a now its turn of b and its matching so we return swaps=2\\n     case 2 - odd number of chars abb , a!=b search for a, we finally get a at a itself which means its the only character in the string so swap it with next index\\n     abb->bab and continue your search , b==b so swaps=1 ans\\n    */\\n    int minMovesToMakePalindrome(string s) {\\n        int left=0;\\n        int right=s.size()-1;\\n        int ans=0;\\n        while(left<right)\\n        {\\n            int l=left;\\n            int r=right;\\n            \\n            //while you not find char same a first element continue decreasing right index\\n            while(s[l]!=s[r])\\n            {\\n                r--;\\n            }\\n            //case 2 ->single element found\\n            if(l==r)\\n            {\\n                swap(s[r],s[r+1]);\\n                ans++;\\n                continue;\\n            }\\n            else\\n            {\\n                while(r<right)\\n                {\\n                    swap(s[r],s[r+1]);\\n                    ans++;\\n                    r++;\\n                }\\n            }\\n            left++;\\n            right--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n     Two cases can come\\n     while we can compare first half with other half\\n     case 1  aabb -> a != b come back and see if we find a , we finally find an \\'a\\' at aa so swap it till we bring it at end to match , abab swap again abba, now a==a now its turn of b and its matching so we return swaps=2\\n     case 2 - odd number of chars abb , a!=b search for a, we finally get a at a itself which means its the only character in the string so swap it with next index\\n     abb->bab and continue your search , b==b so swaps=1 ans\\n    */\\n    int minMovesToMakePalindrome(string s) {\\n        int left=0;\\n        int right=s.size()-1;\\n        int ans=0;\\n        while(left<right)\\n        {\\n            int l=left;\\n            int r=right;\\n            \\n            //while you not find char same a first element continue decreasing right index\\n            while(s[l]!=s[r])\\n            {\\n                r--;\\n            }\\n            //case 2 ->single element found\\n            if(l==r)\\n            {\\n                swap(s[r],s[r+1]);\\n                ans++;\\n                continue;\\n            }\\n            else\\n            {\\n                while(r<right)\\n                {\\n                    swap(s[r],s[r+1]);\\n                    ans++;\\n                    r++;\\n                }\\n            }\\n            left++;\\n            right--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248463,
                "title": "c-easy-solution-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n         int cnt = 0;\\n         while(!s.empty()) {\\n             int other = s.find(s.back());\\n             if(other==s.size()-1) {\\n                   // odd ?\\n                   cnt+=other/2;   // move it to the middle \\n             }else {\\n                   cnt+=other;\\n                   s.erase(other,1);   // delete char at positon \\n             }\\n             s.pop_back();\\n         }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n         int cnt = 0;\\n         while(!s.empty()) {\\n             int other = s.find(s.back());\\n             if(other==s.size()-1) {\\n                   // odd ?\\n                   cnt+=other/2;   // move it to the middle \\n             }else {\\n                   cnt+=other;\\n                   s.erase(other,1);   // delete char at positon \\n             }\\n             s.pop_back();\\n         }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191696,
                "title": "using-two-pointer-simplest-solution",
                "content": "```\\n int i=0;\\n        int j=s.size()-1;\\n        int l=0;\\n        int r=s.size()-1;\\n        int cnt=0;\\n        while(l<r){\\n            if(s[l]==s[r])\\n            {\\n                l++;\\n                r--;\\n                continue;\\n            }\\n            i=l;\\n            j=r;\\n            while(s[j]!=s[i]){\\n                j--;\\n            }\\n            swap(s[j],s[j+1]);\\n            cnt++;         \\n        }\\n        \\n        return cnt;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n int i=0;\\n        int j=s.size()-1;\\n        int l=0;\\n        int r=s.size()-1;\\n        int cnt=0;\\n        while(l<r){\\n            if(s[l]==s[r])\\n            {\\n                l++;\\n                r--;\\n                continue;\\n            }\\n            i=l;\\n            j=r;\\n            while(s[j]!=s[i]){\\n                j--;\\n            }\\n            swap(s[j],s[j+1]);\\n            cnt++;         \\n        }\\n        \\n        return cnt;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2106361,
                "title": "python-2-pointers-greddy",
                "content": "Make first half equal to second half greedily!!\\n\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n=len(s)\\n        s=list(s)\\n        l,r=0,n-1\\n        ans=0\\n        while (l<r):\\n            ll,rr=l,r\\n            while (s[ll]!=s[rr]): rr-=1\\n            if (ll==rr):              # found a middle element in an odd palindrome\\n                s[rr],s[rr+1]=s[rr+1],s[rr]\\n                ans+=1\\n                continue\\n            else:\\n                while (rr<r): \\n                    s[rr],s[rr+1]=s[rr+1],s[rr]\\n                    rr+=1\\n                    ans+=1\\n            l+=1\\n            r-=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n=len(s)\\n        s=list(s)\\n        l,r=0,n-1\\n        ans=0\\n        while (l<r):\\n            ll,rr=l,r\\n            while (s[ll]!=s[rr]): rr-=1\\n            if (ll==rr):              # found a middle element in an odd palindrome\\n                s[rr],s[rr+1]=s[rr+1],s[rr]\\n                ans+=1\\n                continue\\n            else:\\n                while (rr<r): \\n                    s[rr],s[rr+1]=s[rr+1],s[rr]\\n                    rr+=1\\n                    ans+=1\\n            l+=1\\n            r-=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2063971,
                "title": "very-easy-solution-with-proper-comments-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /**\\n    \\n    observation->we only need to move one of two characters of the palindrome string at minimum cost\\n    \\n    \\n    move from left to right\\n        try to find and swap the character according scanning from right to left\\n            -> from required position to left\\n    \\n        in case of odd length of the string you may find a unpaired character which you have to store in the center of the string.\\n        -> you can ignore it if it is present on the right side of the string because it will adjust itself automatically \\n        -> but if it is on the left side \\n            just reverse the string and pass in the same function\\n    */\\n    \\n    int solve(string &a)\\n    {        \\n        int size = a.size();\\n        \\n        int cnt=0;\\n        \\n        //traverse only the half of the string \\n        for(int i=0;i<size/2;i++)\\n        {\\n            \\n            int ind=-1;\\n            \\n            //searching for other pair right to left from required position-> size-1-i \\n            for(int j=size-1-i;j>i;j--)\\n            {\\n                //break if found\\n                if(a[i]==a[j]){\\n                    ind=j;\\n                    break;\\n                }\\n            }\\n        \\n            //in case of unpaired character \\n            //reverse the string and pass to same function\\n            //just to move that unpaired character to right part\\n            if(ind==-1)\\n            {\\n                reverse(a.begin(),a.end());\\n                return cnt+solve(a);\\n            }\\n            \\n            //add the difference of indexes (actual index to required index) in the cound\\n            cnt += size-1-i-ind;\\n            \\n            //modify the string accordingly\\n            for(int j=ind;j<size-1-i;j++)\\n            {\\n                swap(a[j],a[j+1]);\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int minMovesToMakePalindrome(string s) {\\n        return solve(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /**\\n    \\n    observation->we only need to move one of two characters of the palindrome string at minimum cost\\n    \\n    \\n    move from left to right\\n        try to find and swap the character according scanning from right to left\\n            -> from required position to left\\n    \\n        in case of odd length of the string you may find a unpaired character which you have to store in the center of the string.\\n        -> you can ignore it if it is present on the right side of the string because it will adjust itself automatically \\n        -> but if it is on the left side \\n            just reverse the string and pass in the same function\\n    */\\n    \\n    int solve(string &a)\\n    {        \\n        int size = a.size();\\n        \\n        int cnt=0;\\n        \\n        //traverse only the half of the string \\n        for(int i=0;i<size/2;i++)\\n        {\\n            \\n            int ind=-1;\\n            \\n            //searching for other pair right to left from required position-> size-1-i \\n            for(int j=size-1-i;j>i;j--)\\n            {\\n                //break if found\\n                if(a[i]==a[j]){\\n                    ind=j;\\n                    break;\\n                }\\n            }\\n        \\n            //in case of unpaired character \\n            //reverse the string and pass to same function\\n            //just to move that unpaired character to right part\\n            if(ind==-1)\\n            {\\n                reverse(a.begin(),a.end());\\n                return cnt+solve(a);\\n            }\\n            \\n            //add the difference of indexes (actual index to required index) in the cound\\n            cnt += size-1-i-ind;\\n            \\n            //modify the string accordingly\\n            for(int j=ind;j<size-1-i;j++)\\n            {\\n                swap(a[j],a[j+1]);\\n            }\\n        }\\n        return cnt;\\n    }\\n    \\n    int minMovesToMakePalindrome(string s) {\\n        return solve(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906760,
                "title": "typescript-greedy-faster-that-100",
                "content": "```\\nfunction minMovesToMakePalindrome(s: string): number {\\n    let leftIndex = 0\\n    let rightIndex = s.length - 1\\n    const sArr: string[] = Array.from(s)\\n    let sumChange = 0\\n    \\n    while(leftIndex < rightIndex){\\n        if(sArr[leftIndex] === sArr[rightIndex]){\\n            leftIndex ++\\n            rightIndex --\\n            continue\\n        }\\n        let matchRight = leftIndex + 1\\n        let matchLeft = rightIndex - 1\\n        \\n        while(sArr[matchRight] !== sArr[rightIndex]){\\n            matchRight++\\n        }\\n        while(sArr[matchLeft] !== sArr[leftIndex]){\\n            matchLeft--\\n        }\\n        if(matchRight - leftIndex <= rightIndex - matchLeft){\\n            sumChange += matchRight - leftIndex\\n            sArr.splice(matchRight, 1)\\n            sArr.splice(leftIndex, 0, s[rightIndex])\\n        }else{\\n            sumChange += rightIndex - matchLeft\\n            sArr.splice(rightIndex + 1, 0, s[leftIndex])\\n            sArr.splice(matchLeft, 1)\\n        }\\n        leftIndex ++\\n        rightIndex --\\n    }\\n    return sumChange\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction minMovesToMakePalindrome(s: string): number {\\n    let leftIndex = 0\\n    let rightIndex = s.length - 1\\n    const sArr: string[] = Array.from(s)\\n    let sumChange = 0\\n    \\n    while(leftIndex < rightIndex){\\n        if(sArr[leftIndex] === sArr[rightIndex]){\\n            leftIndex ++\\n            rightIndex --\\n            continue\\n        }\\n        let matchRight = leftIndex + 1\\n        let matchLeft = rightIndex - 1\\n        \\n        while(sArr[matchRight] !== sArr[rightIndex]){\\n            matchRight++\\n        }\\n        while(sArr[matchLeft] !== sArr[leftIndex]){\\n            matchLeft--\\n        }\\n        if(matchRight - leftIndex <= rightIndex - matchLeft){\\n            sumChange += matchRight - leftIndex\\n            sArr.splice(matchRight, 1)\\n            sArr.splice(leftIndex, 0, s[rightIndex])\\n        }else{\\n            sumChange += rightIndex - matchLeft\\n            sArr.splice(rightIndex + 1, 0, s[leftIndex])\\n            sArr.splice(matchLeft, 1)\\n        }\\n        leftIndex ++\\n        rightIndex --\\n    }\\n    return sumChange\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1850587,
                "title": "c-greedy-solution-o-n-2",
                "content": "Runtime: 31 ms, faster than 47.44% of C++ online submissions for Minimum Number of Moves to Make Palindrome.\\nMemory Usage: 6.8 MB, less than 50.32% of C++ online submissions for Minimum Number of Moves to Make Palindrome.\\n\\n```\\nTo make string palindrome we can keep left half of string in exact position and change \\nthe right half chars using swaps from from two end point.\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n\\n        int sl = s.length();\\n\\n        // left and right end pointers\\n        int left = 0;\\n        int right = sl - 1;\\n        \\n        // count number of swaps\\n        int swapCount = 0;\\n\\n        // loop through string from both side using left and right pointer\\n        while (left < right)\\n        {\\n            // if left and right pointer chars are not same then \\n            // find the rightmost position X of left pointer char\\n            // then swap from X to right pointer and increment swap count \\n            if (s[left] != s[right])\\n            {\\n                int l = left;\\n                int r = right;\\n                \\n                // get the right most index of s[l] char\\n                while(s[l]!=s[r])r--;\\n                \\n                // only swap once if s[l] is single char in range left and right\\n                if (l == r) {\\n                    swap(s[r], s[r + 1]);\\n                    swapCount++;\\n                    continue;\\n                }\\n                \\n                // swap from r to right and increment count\\n                while(r<right)\\n                {\\n                    swap(s[r+1],s[r]);\\n                    r++;\\n                    swapCount++;\\n                }\\n            }\\n\\n            // reduce right and left pointer from both side in each step\\n            left++;\\n            right--;\\n        }\\n\\n        return swapCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nTo make string palindrome we can keep left half of string in exact position and change \\nthe right half chars using swaps from from two end point.\\n```\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n\\n        int sl = s.length();\\n\\n        // left and right end pointers\\n        int left = 0;\\n        int right = sl - 1;\\n        \\n        // count number of swaps\\n        int swapCount = 0;\\n\\n        // loop through string from both side using left and right pointer\\n        while (left < right)\\n        {\\n            // if left and right pointer chars are not same then \\n            // find the rightmost position X of left pointer char\\n            // then swap from X to right pointer and increment swap count \\n            if (s[left] != s[right])\\n            {\\n                int l = left;\\n                int r = right;\\n                \\n                // get the right most index of s[l] char\\n                while(s[l]!=s[r])r--;\\n                \\n                // only swap once if s[l] is single char in range left and right\\n                if (l == r) {\\n                    swap(s[r], s[r + 1]);\\n                    swapCount++;\\n                    continue;\\n                }\\n                \\n                // swap from r to right and increment count\\n                while(r<right)\\n                {\\n                    swap(s[r+1],s[r]);\\n                    r++;\\n                    swapCount++;\\n                }\\n            }\\n\\n            // reduce right and left pointer from both side in each step\\n            left++;\\n            right--;\\n        }\\n\\n        return swapCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832463,
                "title": "java-greedy-with-explanation",
                "content": "Each time we check the first and the last character. If they are the same, we can quickly shrink this problem into a subproblem with the size of n - 2. \\nIf they are not the same, such as \"a..b..a..b\", then the answer becomes which character we need to choose as the end of both sides. If we choose \\'a\\', we need to move the last \\'a\\' to the end, and the cost will be the distance between the last \\'b\\' and the last \\'a\\'; If we choose \\'b\\', we need to move the first \\'b\\' to the beginning, the cost will be the distance between the first \\'a\\' and the first \\'b\\'. Therefore, we apply a greedy strategy picking the less costly one. \\nWe apply this greedy strategy recursively until the size of the string less than or equal to 2(that would be the base case).\\n```\\npublic class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        List<Character> list = new ArrayList<>();\\n        for (char c : s.toCharArray()) {\\n            list.add(c);\\n        }\\n        return helper(list);\\n    }\\n\\n    private int helper(List<Character> list) {\\n        if (list.size() <= 2) return 0;\\n        int beginning = 0;\\n        int end = list.size() - 1;\\n        // both ends are the same\\n        if (list.get(beginning) == list.get(end)) {\\n            list.remove(end);\\n            list.remove(beginning);\\n            return helper(list);\\n        }\\n        // find the last \\'a\\'\\n        int lastA = end;\\n        while (lastA > beginning) {\\n            if (list.get(lastA) == list.get(beginning)) break;\\n            lastA -= 1;\\n        }\\n        // find the first \\'b\\'\\n        int firstB = beginning;\\n        while (firstB < end) {\\n            if (list.get(firstB) == list.get(end)) break;\\n            firstB += 1;\\n        }\\n        if (firstB - beginning <= end - lastA) {\\n            list.remove(end);\\n            list.remove(firstB);\\n            return firstB - beginning + helper(list);\\n        } else {\\n            list.remove(lastA);\\n            list.remove(0);\\n            return end - lastA + helper(list);\\n        }\\n\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        List<Character> list = new ArrayList<>();\\n        for (char c : s.toCharArray()) {\\n            list.add(c);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1832261,
                "title": "c-solution-without-swapping-uses-maths",
                "content": "```\\npublic class Solution {\\n    public int MinMovesToMakePalindrome (string s) {\\n        int sum = 0;\\n        List<char> chars = s.ToCharArray ().ToList ();\\n        int b = 0, e = chars.Count - 1;\\n        while (b < e) {\\n            if (chars[b] != chars[e]) {\\n                int maxIx = -1;\\n                for (int i = e - 1; i > b; i--) {\\n                    if (chars[i] == chars[b]) {\\n                        maxIx = i;\\n                        break;\\n                    }\\n                }\\n                // check if this is a single letter that needs to be in the middle, \\n                // the way the maths works for the middle letter is that we are leaving it\\n                // to swap it in the end - in order to reduce unneccessary swaps\\n                // and in the end when everything is in place, the cost to swap this letter\\n                // and put in in the middle will be the cost to put in in the middle right now\\n                if (maxIx == -1) {\\n                    sum += (e - b) / 2;\\n                    chars.RemoveAt (b);\\n                } \\n                // the cost to swap the rightmost letter that\\'s the same with the current left\\n                // letter will be the endIndex - currentIndex\\n                else {\\n                    sum += e - maxIx;\\n                    chars.RemoveAt (maxIx);\\n                    chars.RemoveAt (b);\\n                }\\n            } else {\\n                chars.RemoveAt (e);\\n                chars.RemoveAt (b);\\n            }\\n            e = chars.Count - 1;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinMovesToMakePalindrome (string s) {\\n        int sum = 0;\\n        List<char> chars = s.ToCharArray ().ToList ();\\n        int b = 0, e = chars.Count - 1;\\n        while (b < e) {\\n            if (chars[b] != chars[e]) {\\n                int maxIx = -1;\\n                for (int i = e - 1; i > b; i--) {\\n                    if (chars[i] == chars[b]) {\\n                        maxIx = i;\\n                        break;\\n                    }\\n                }\\n                // check if this is a single letter that needs to be in the middle, \\n                // the way the maths works for the middle letter is that we are leaving it\\n                // to swap it in the end - in order to reduce unneccessary swaps\\n                // and in the end when everything is in place, the cost to swap this letter\\n                // and put in in the middle will be the cost to put in in the middle right now\\n                if (maxIx == -1) {\\n                    sum += (e - b) / 2;\\n                    chars.RemoveAt (b);\\n                } \\n                // the cost to swap the rightmost letter that\\'s the same with the current left\\n                // letter will be the endIndex - currentIndex\\n                else {\\n                    sum += e - maxIx;\\n                    chars.RemoveAt (maxIx);\\n                    chars.RemoveAt (b);\\n                }\\n            } else {\\n                chars.RemoveAt (e);\\n                chars.RemoveAt (b);\\n            }\\n            e = chars.Count - 1;\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823949,
                "title": "javascript-two-pointer",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minMovesToMakePalindrome = function(s) {\\n    let left = 0, right = s.length-1, ans = 0;\\n    \\n    \\n    function swapStr(str, first, last){\\n        return str.substr(0, first)\\n           + str[last]\\n           + str.substring(first+1, last)\\n           + str[first]\\n           + str.substr(last+1);\\n    }\\n    \\n    while (left < right) {\\n        let l = left, r = right;\\n        \\n        while (s[l] != s[r]) {\\n            r--;\\n        }\\n        \\n        if (l == r) {\\n            ans++;\\n            s = swapStr(s, r, r+1);\\n            continue;\\n        } else {\\n            while (r < right) {\\n                s = swapStr(s, r, r+1);\\n                ans++;\\n                r++;\\n            }   \\n        }\\n        left++;\\n        right--;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar minMovesToMakePalindrome = function(s) {\\n    let left = 0, right = s.length-1, ans = 0;\\n    \\n    \\n    function swapStr(str, first, last){\\n        return str.substr(0, first)\\n           + str[last]\\n           + str.substring(first+1, last)\\n           + str[first]\\n           + str.substr(last+1);\\n    }\\n    \\n    while (left < right) {\\n        let l = left, r = right;\\n        \\n        while (s[l] != s[r]) {\\n            r--;\\n        }\\n        \\n        if (l == r) {\\n            ans++;\\n            s = swapStr(s, r, r+1);\\n            continue;\\n        } else {\\n            while (r < right) {\\n                s = swapStr(s, r, r+1);\\n                ans++;\\n                r++;\\n            }   \\n        }\\n        left++;\\n        right--;\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822301,
                "title": "python-simple",
                "content": "Old school grinding:\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s,N  = list(s), len(s)\\n        min_swaps = i = 0\\n        while i < N // 2:\\n            L, R = i, N - i - 1\\n            while L < R:\\n                if s[L] == s[R]: break\\n                else: R -= 1\\n            if L == R:\\n                s[L], s[L + 1] = s[L + 1], s[L]\\n                min_swaps += 1\\n            else:\\n                for j in range(R, N - L - 1):\\n                    s[j], s[j + 1] = s[j + 1], s[j]\\n                    min_swaps += 1\\n                i += 1\\n        return min_swaps\\n```\\nGreedy everyone else used\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s, min_swaps = list(s), 0\\n        \\n        while s:\\n            first_occur_index = s.index(s[-1])\\n            if first_occur_index == len(s) - 1:\\n                min_swaps += first_occur_index // 2\\n            else:\\n                min_swaps += first_occur_index\\n                s.pop(first_occur_index)\\n                \\n            s.pop()\\n                                \\n        return min_swaps\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s,N  = list(s), len(s)\\n        min_swaps = i = 0\\n        while i < N // 2:\\n            L, R = i, N - i - 1\\n            while L < R:\\n                if s[L] == s[R]: break\\n                else: R -= 1\\n            if L == R:\\n                s[L], s[L + 1] = s[L + 1], s[L]\\n                min_swaps += 1\\n            else:\\n                for j in range(R, N - L - 1):\\n                    s[j], s[j + 1] = s[j + 1], s[j]\\n                    min_swaps += 1\\n                i += 1\\n        return min_swaps\\n```\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s, min_swaps = list(s), 0\\n        \\n        while s:\\n            first_occur_index = s.index(s[-1])\\n            if first_occur_index == len(s) - 1:\\n                min_swaps += first_occur_index // 2\\n            else:\\n                min_swaps += first_occur_index\\n                s.pop(first_occur_index)\\n                \\n            s.pop()\\n                                \\n        return min_swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822181,
                "title": "c-two-pointers-greedy-algo-o-n-2",
                "content": "The idea is to consider two pointers, from left end and right end, to the middle.\\nWhenever there is a pair of the same letters, swap the right one towards the right end till it finds the correct position.\\nA special condition is that there might be a single letter on the left, which does not find its counterpart on the right. In this case, this letter should be moved to the middle.\\n\\nOne might wonder why we need to operate on the right one, but not the left one. It is equivalent to operate on the left one, and might result in a different result string though.\\n\\nTime complexity `O(N^2)`\\n```\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size(), res = 0, i = 0;\\n        while(i < n / 2)\\n        {\\n            int l = i, r = n - l - 1;\\n            while(l < r)\\n            {\\n                if (s[l] == s[r])\\n                    break;\\n                --r;\\n            }\\n            if (l == r)\\n            {\\n\\t\\t\\t\\t// There is a single letter which should go to the middle.\\n                swap(s[l], s[l + 1]);\\n                ++res;\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// Move the letter to the right till its correct position.\\n                for (int j = r; j < n - l - 1; ++j)\\n                {\\n                    swap(s[j], s[j + 1]);\\n                    ++res;\\n                }\\n                ++i;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size(), res = 0, i = 0;\\n        while(i < n / 2)\\n        {\\n            int l = i, r = n - l - 1;\\n            while(l < r)\\n            {\\n                if (s[l] == s[r])\\n                    break;\\n                --r;\\n            }\\n            if (l == r)\\n            {\\n\\t\\t\\t\\t// There is a single letter which should go to the middle.\\n                swap(s[l], s[l + 1]);\\n                ++res;\\n            }\\n            else\\n            {\\n\\t\\t\\t\\t// Move the letter to the right till its correct position.\\n                for (int j = r; j < n - l - 1; ++j)\\n                {\\n                    swap(s[j], s[j + 1]);\\n                    ++res;\\n                }\\n                ++i;\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1822159,
                "title": "o-n-2-solution-greedy-approach-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\n\\n\\t\\tint minMovesToMakePalindrome(string s) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint i=0;\\n\\t\\t\\tint j= n-1;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\twhile(i <= j){\\n\\t\\t\\t\\tif(s[i] == s[j]){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tint idx1 = -1;\\n\\t\\t\\t\\t\\tint idx2 = -1;\\n\\t\\t\\t\\t\\tfor(int k=i+1; k<j; k++){\\n\\t\\t\\t\\t\\t\\tif(s[k] == s[j]) {\\n\\t\\t\\t\\t\\t\\t\\tidx1 = k;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor(int k=j-1; k>i; k--){\\n\\t\\t\\t\\t\\t\\tif(s[k] == s[i]){\\n\\t\\t\\t\\t\\t\\t\\tidx2 = k;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(idx1 != -1 && abs(idx1 - i) < abs(idx2 - j)){\\n\\t\\t\\t\\t\\t\\tans += abs(idx1 - i);\\n\\n\\t\\t\\t\\t\\t\\tfor(int k = idx1; k>i; k--){\\n\\t\\t\\t\\t\\t\\t\\tswap(s[k], s[k-1]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tans += abs(idx2 - j);\\n\\t\\t\\t\\t\\t\\tfor(int k=idx2; k<j; k++){\\n\\t\\t\\t\\t\\t\\t\\tswap(s[k], s[k+1]);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj--;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\n\\t\\tint minMovesToMakePalindrome(string s) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint i=0;\\n\\t\\t\\tint j= n-1;\\n\\t\\t\\tint ans = 0;\\n\\t\\t\\twhile(i <= j){\\n\\t\\t\\t\\tif(s[i] == s[j]){\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tj--;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1822140,
                "title": "python-greedy-easy-and-clean-solution",
                "content": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        n = len(s)\\n        left, right = 0, n-1\\n        res = 0\\n        while left < right:\\n            if s[left] != s[right]:\\n                lidx, ridx = left+1, right-1\\n                rdelta = 1\\n                while s[left] != s[ridx]:\\n                    ridx -= 1\\n                    rdelta += 1\\n                ldelta = 1\\n                while s[right] != s[lidx]:\\n                    lidx += 1\\n                    ldelta += 1\\n                if ldelta < rdelta:\\n                    for i in range(lidx,left,-1):\\n                        s[i-1],s[i] = s[i],s[i-1]\\n                    res += ldelta\\n                else:\\n                    for i in range(ridx,right):\\n                        s[i],s[i+1] = s[i+1],s[i]\\n                    res += rdelta\\n            left += 1\\n            right -= 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        n = len(s)\\n        left, right = 0, n-1\\n        res = 0\\n        while left < right:\\n            if s[left] != s[right]:\\n                lidx, ridx = left+1, right-1\\n                rdelta = 1\\n                while s[left] != s[ridx]:\\n                    ridx -= 1\\n                    rdelta += 1\\n                ldelta = 1\\n                while s[right] != s[lidx]:\\n                    lidx += 1\\n                    ldelta += 1\\n                if ldelta < rdelta:\\n                    for i in range(lidx,left,-1):\\n                        s[i-1],s[i] = s[i],s[i-1]\\n                    res += ldelta\\n                else:\\n                    for i in range(ridx,right):\\n                        s[i],s[i+1] = s[i+1],s[i]\\n                    res += rdelta\\n            left += 1\\n            right -= 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822077,
                "title": "explained-two-pointer-cpp-solution",
                "content": "```\\n// TWO- POINTER APPROACH\\n\\n// 1. traversed from the two ends and chose the best possible option out of the characters  which has its count left greater than equal to 2 \\n\\n// 2. calculated the no. of swaps\\n\\n// Please do upvote if u like my solution\\n\\nclass Solution {\\npublic:\\n    #define ll int\\n    int minMovesToMakePalindrome(string s) {\\n        ll i=0,j=s.length()-1;\\n        map<char,ll>m;\\n        for(ll i=0;i<s.length();i++){\\n            m[s[i]]++;\\n        }\\n        ll ans=0;\\n        ll n=s.length()/2;\\n        while(i<n){\\n            ll i1=-1,i2=-1;ll c=INT_MAX;\\n            for(auto x:m){\\n                if(x.second>=2){\\n                    ll a=-1,b=-1;\\n                    for(ll z=i;z<s.length();z++){\\n                        if(s[z]==x.first){a=z; break;}\\n                    }\\n                    for(ll z=j;z>=0;z--){\\n                        if(s[z]==x.first){b=z; break;}\\n                    }\\n                    if(abs(a-i)+abs(j-b)<c){i1=a; i2=b; c=(a-i)+(j-b);}\\n                }\\n            }\\n            m[s[i1]]--; m[s[i1]]--;\\n            while(i1>i){\\n                //cout<<i1<<\" \";\\n                swap(s[i1],s[i1-1]);\\n                i1--;\\n                ans++;\\n            }\\n            cout<<endl;\\n            while(i2<j){\\n                // cout<<i2<<\"    \";\\n                swap(s[i2],s[i2+1]);\\n                i2++;\\n                ans++;\\n            }\\n            i++; j--;\\n        }\\n        //cout<<s<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\n// TWO- POINTER APPROACH\\n\\n// 1. traversed from the two ends and chose the best possible option out of the characters  which has its count left greater than equal to 2 \\n\\n// 2. calculated the no. of swaps\\n\\n// Please do upvote if u like my solution\\n\\nclass Solution {\\npublic:\\n    #define ll int\\n    int minMovesToMakePalindrome(string s) {\\n        ll i=0,j=s.length()-1;\\n        map<char,ll>m;\\n        for(ll i=0;i<s.length();i++){\\n            m[s[i]]++;\\n        }\\n        ll ans=0;\\n        ll n=s.length()/2;\\n        while(i<n){\\n            ll i1=-1,i2=-1;ll c=INT_MAX;\\n            for(auto x:m){\\n                if(x.second>=2){\\n                    ll a=-1,b=-1;\\n                    for(ll z=i;z<s.length();z++){\\n                        if(s[z]==x.first){a=z; break;}\\n                    }\\n                    for(ll z=j;z>=0;z--){\\n                        if(s[z]==x.first){b=z; break;}\\n                    }\\n                    if(abs(a-i)+abs(j-b)<c){i1=a; i2=b; c=(a-i)+(j-b);}\\n                }\\n            }\\n            m[s[i1]]--; m[s[i1]]--;\\n            while(i1>i){\\n                //cout<<i1<<\" \";\\n                swap(s[i1],s[i1-1]);\\n                i1--;\\n                ans++;\\n            }\\n            cout<<endl;\\n            while(i2<j){\\n                // cout<<i2<<\"    \";\\n                swap(s[i2],s[i2+1]);\\n                i2++;\\n                ans++;\\n            }\\n            i++; j--;\\n        }\\n        //cout<<s<<endl;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1822032,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = [i for i in s]\\n        start = 0\\n        end = len(s)-1\\n        count = 0\\n        while start < end:\\n            if s[start] != s[end]:\\n                i = start\\n                j = end\\n                j_f = i_f = False\\n                ii = jj = -1\\n                while i < end:\\n                    if s[start] == s[j]:\\n                        j_f = True\\n                        jj = j\\n                        break\\n                    elif s[end] == s[i]:\\n                        i_f = True\\n                        ii = i\\n                        break\\n                    count += 1\\n                    i += 1\\n                    j -= 1\\n                if i_f:\\n                    for i in range(ii, start, -1):\\n                        s[i] = s[i-1]\\n                else:\\n                    for i in range(jj, end):\\n                        s[i] = s[i+1]\\n            start += 1\\n            end -= 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = [i for i in s]\\n        start = 0\\n        end = len(s)-1\\n        count = 0\\n        while start < end:\\n            if s[start] != s[end]:\\n                i = start\\n                j = end\\n                j_f = i_f = False\\n                ii = jj = -1\\n                while i < end:\\n                    if s[start] == s[j]:\\n                        j_f = True\\n                        jj = j\\n                        break\\n                    elif s[end] == s[i]:\\n                        i_f = True\\n                        ii = i\\n                        break\\n                    count += 1\\n                    i += 1\\n                    j -= 1\\n                if i_f:\\n                    for i in range(ii, start, -1):\\n                        s[i] = s[i-1]\\n                else:\\n                    for i in range(jj, end):\\n                        s[i] = s[i+1]\\n            start += 1\\n            end -= 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995630,
                "title": "c-nlogn-solution",
                "content": "You can copy code for counting inversion in nlon\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int getNumOfInversions(vector<int>& A) {\\n        int N = A.size();\\n        if (N <= 1) {\\n            return 0;\\n        }\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> sortList;\\n        int result = 0;\\n    \\n        // Heapsort, O(N*log(N))\\n        for (int i = 0; i < N; i++) {\\n            sortList.push(make_pair(A[i], i));\\n        }\\n    \\n        // Create a sorted list of indexes\\n        vector<int> x;\\n        while (!sortList.empty()) {\\n    \\n            // O(log(N))\\n            int v = sortList.top().first;\\n            int i = sortList.top().second;\\n            sortList.pop();\\n    \\n            // Find the current minimum\\'s index\\n            // the index y can represent how many minimums on the left\\n            int y = upper_bound(x.begin(), x.end(), i) - x.begin();\\n    \\n            // i can represent how many elements on the left\\n            // i - y can find how many bigger nums on the left\\n            result += i - y;\\n    \\n            x.insert(upper_bound(x.begin(), x.end(), i), i);\\n        }\\n    \\n        return result;\\n    }\\n    ll get_ans(string s1,string s2)\\n    {\\n        int n = (int)s1.size();\\n        vector<vector<int>> pos(26);\\n        for(int i=0;i<n;i++){\\n            pos[s2[i]-\\'a\\'].push_back(i);\\n        }\\n        vector<int> p(n);\\n        for(int i=n-1;i>=0;i--){\\n            p[i]=pos[s1[i]-\\'a\\'].back();\\n            pos[s1[i]-\\'a\\'].pop_back();\\n        }\\n        return getNumOfInversions(p);\\n    }\\n    int minMovesToMakePalindrome(string s) {\\n        int n=(int)s.size();\\n\\t\\tstring s1 = s;\\n\\t\\treverse(s1.begin(),s1.end());\\n\\t\\treturn get_ans(s,s1)/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int getNumOfInversions(vector<int>& A) {\\n        int N = A.size();\\n        if (N <= 1) {\\n            return 0;\\n        }\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> sortList;\\n        int result = 0;\\n    \\n        // Heapsort, O(N*log(N))\\n        for (int i = 0; i < N; i++) {\\n            sortList.push(make_pair(A[i], i));\\n        }\\n    \\n        // Create a sorted list of indexes\\n        vector<int> x;\\n        while (!sortList.empty()) {\\n    \\n            // O(log(N))\\n            int v = sortList.top().first;\\n            int i = sortList.top().second;\\n            sortList.pop();\\n    \\n            // Find the current minimum\\'s index\\n            // the index y can represent how many minimums on the left\\n            int y = upper_bound(x.begin(), x.end(), i) - x.begin();\\n    \\n            // i can represent how many elements on the left\\n            // i - y can find how many bigger nums on the left\\n            result += i - y;\\n    \\n            x.insert(upper_bound(x.begin(), x.end(), i), i);\\n        }\\n    \\n        return result;\\n    }\\n    ll get_ans(string s1,string s2)\\n    {\\n        int n = (int)s1.size();\\n        vector<vector<int>> pos(26);\\n        for(int i=0;i<n;i++){\\n            pos[s2[i]-\\'a\\'].push_back(i);\\n        }\\n        vector<int> p(n);\\n        for(int i=n-1;i>=0;i--){\\n            p[i]=pos[s1[i]-\\'a\\'].back();\\n            pos[s1[i]-\\'a\\'].pop_back();\\n        }\\n        return getNumOfInversions(p);\\n    }\\n    int minMovesToMakePalindrome(string s) {\\n        int n=(int)s.size();\\n\\t\\tstring s1 = s;\\n\\t\\treverse(s1.begin(),s1.end());\\n\\t\\treturn get_ans(s,s1)/2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949565,
                "title": "easy-to-understand",
                "content": "# Intuition\\ntwo pointer approach: inititalize two pointers to the start of the array and the end of the array respectively, and then check if they are the same, if they arent, move the right backwards and find the same charater in the array, and swap the adjacent characters till it reaches the correct spot, performing a final swap in the middle of the array at the end while ensure the correct answer \\n\\n# Approach\\n1) convert it to character array\\n2) use count variable to track the number of swaps\\n3) initialise two pointers let and right, and also a \"find\" variable to find the character which is same as the character in the position \"left\" \\n4) after finding the character, swap it with adjacent characters until you reach the right index.\\n5) perform these oprations until you reach the middle of the array, at the middle of the array, swap the adjacent elements to get the required answer\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) \\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int count=0;\\n        char[] charArray=s.toCharArray();\\n        int right=charArray.length-1;\\n        int left=0;\\n        int find=0;\\n        while(left<right){\\n            find=right;// the find variable to find the same character as left\\n            if(charArray[left]==charArray[right]){\\n                left++;// if at the right position, move the pointers\\n                right--;\\n            }else{\\n                \\n                \\n                while(charArray[find]!=charArray[left]){\\n                    find--;// move the find pointer backwards until you find the right spot\\n                }\\n                if(left==find){\\n                    swap(charArray,find,find+1);\\n                    count++;continue;// for middle of the array\\n                }else{\\n                while((find)<right){\\n                    swap(charArray,find,find+1);\\n                    find+=1;count+=1;// for moving the find variable value to the correct spot by swapping adjacent element until it reaches the \"right\" index. update he counter for every swap                }}\\n                \\n            }\\n            \\n        }\\n        return count;\\n        \\n        \\n    }\\n    public void swap(char[] c,int a,int b){\\n        char temp=c[a];\\n        c[a]=c[b];\\n        c[b]=temp;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int count=0;\\n        char[] charArray=s.toCharArray();\\n        int right=charArray.length-1;\\n        int left=0;\\n        int find=0;\\n        while(left<right){\\n            find=right;// the find variable to find the same character as left\\n            if(charArray[left]==charArray[right]){\\n                left++;// if at the right position, move the pointers\\n                right--;\\n            }else{\\n                \\n                \\n                while(charArray[find]!=charArray[left]){\\n                    find--;// move the find pointer backwards until you find the right spot\\n                }\\n                if(left==find){\\n                    swap(charArray,find,find+1);\\n                    count++;continue;// for middle of the array\\n                }else{\\n                while((find)<right){\\n                    swap(charArray,find,find+1);\\n                    find+=1;count+=1;// for moving the find variable value to the correct spot by swapping adjacent element until it reaches the \"right\" index. update he counter for every swap                }}\\n                \\n            }\\n            \\n        }\\n        return count;\\n        \\n        \\n    }\\n    public void swap(char[] c,int a,int b){\\n        char temp=c[a];\\n        c[a]=c[b];\\n        c[b]=temp;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843056,
                "title": "greedy-approach",
                "content": "# Intuition\\nGreedy approach -> \\n    At each instance we can do following things: \\n    1. keep left most character as-it-is, and make some moves to move other equivalent character to right. \\n    2. keep right most character as-it-is, and make some moves to move other equivalent character to left. \\n    Choose greedy solution which would needs to minimum moves to make left-most and right-most characters same. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nFor example : \\nconsider - \\nl--e--t--e--l--t\\n0-1--2-3--4-5 (indexes)\\n to make left and right chars same, we have following 2 options\\n1. move l (at index 4) to 5th index - with move count 1\\n2. move t (at index 2) to 0th index - with move count 2 ( we needed 2 swaps).\\n\\nFrom above 2 possibilities , we can chose first one (as it has lower moves) & repeat same for subproblem subproblem \\n**e t e t**\\n\\n# Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String str) {\\n        char[] s = str.toCharArray();\\n        return minMovesToMakePalindrome(s,0, s.length-1);\\n    }\\n\\n    int minMovesToMakePalindrome(char[] s, int left, int right){\\n\\n        while(left < right && s[left]==s[right]){\\n            left++;\\n            right--;\\n        }\\n\\n        if(left>=right) return 0;\\n\\n        int l = left+1;\\n        while(l < right && s[l]!=s[right]) l++;\\n\\n        int r = right-1;\\n        while(left < r && s[r]!=s[left]) r--;\\n\\n        int leftMoves = l-left;\\n        int rightMoves = right-r;  \\n\\n        int currentMoves = 0; \\n\\n        if(leftMoves < rightMoves){\\n            currentMoves = leftMoves;\\n            l--;\\n            while(left<=l){\\n                swap(s, l, l+1);\\n                l--;\\n            }\\n        }else{\\n            currentMoves = rightMoves;\\n            r++;\\n            while(r<=right){\\n                swap(s, r, r-1);\\n                r++;\\n            }\\n        }\\n\\n        return currentMoves + minMovesToMakePalindrome(s, left+1, right-1);\\n    }\\n\\n    public void swap(char[] s, int i1, int i2){\\n        char temp = s[i1];\\n        s[i1] = s[i2];\\n        s[i2] = temp; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String str) {\\n        char[] s = str.toCharArray();\\n        return minMovesToMakePalindrome(s,0, s.length-1);\\n    }\\n\\n    int minMovesToMakePalindrome(char[] s, int left, int right){\\n\\n        while(left < right && s[left]==s[right]){\\n            left++;\\n            right--;\\n        }\\n\\n        if(left>=right) return 0;\\n\\n        int l = left+1;\\n        while(l < right && s[l]!=s[right]) l++;\\n\\n        int r = right-1;\\n        while(left < r && s[r]!=s[left]) r--;\\n\\n        int leftMoves = l-left;\\n        int rightMoves = right-r;  \\n\\n        int currentMoves = 0; \\n\\n        if(leftMoves < rightMoves){\\n            currentMoves = leftMoves;\\n            l--;\\n            while(left<=l){\\n                swap(s, l, l+1);\\n                l--;\\n            }\\n        }else{\\n            currentMoves = rightMoves;\\n            r++;\\n            while(r<=right){\\n                swap(s, r, r-1);\\n                r++;\\n            }\\n        }\\n\\n        return currentMoves + minMovesToMakePalindrome(s, left+1, right-1);\\n    }\\n\\n    public void swap(char[] s, int i1, int i2){\\n        char temp = s[i1];\\n        s[i1] = s[i2];\\n        s[i2] = temp; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826741,
                "title": "kotlin-two-pointers-solution",
                "content": "# Intuition\\nKotlin two pointers solution\\n\\n# Approach\\ntwo pointers solution\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    fun minMovesToMakePalindrome(str: String): Int {\\n        var ans = 0\\n        var s = StringBuilder(str)\\n\\n        while (s.length > 1) {\\n            if (s[0] == s[s.length-1]) {\\n                s = s.deleteCharAt(0)\\n                s = s.deleteCharAt(s.length-1)\\n                continue\\n            }\\n            for (i in s.length-1 downTo 0) {\\n                if (s[0] == s[i] && i == 0) {\\n                    s = s.deleteCharAt(0)\\n                    ans += (s.length/2).toInt()\\n                    break\\n                } else if (s[0] == s[i]) {\\n                    ans += (s.length - i - 1)\\n                    s = s.deleteCharAt(0)\\n                    s = s.deleteCharAt(i-1)\\n                    break\\n                }\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    fun minMovesToMakePalindrome(str: String): Int {\\n        var ans = 0\\n        var s = StringBuilder(str)\\n\\n        while (s.length > 1) {\\n            if (s[0] == s[s.length-1]) {\\n                s = s.deleteCharAt(0)\\n                s = s.deleteCharAt(s.length-1)\\n                continue\\n            }\\n            for (i in s.length-1 downTo 0) {\\n                if (s[0] == s[i] && i == 0) {\\n                    s = s.deleteCharAt(0)\\n                    ans += (s.length/2).toInt()\\n                    break\\n                } else if (s[0] == s[i]) {\\n                    ans += (s.length - i - 1)\\n                    s = s.deleteCharAt(0)\\n                    s = s.deleteCharAt(i-1)\\n                    break\\n                }\\n            }\\n        }\\n\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795700,
                "title": "c-easy-o-n-2-two-pointer-in-place-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int minMovesToMakePalindrome(string s) {\\n        int left = 0, right = s.length()-1, center = -1, swaps = 0;\\n        while (left<right) {\\n            if (s[left] == s[right]) {\\n                left++;\\n                right--;\\n                continue;\\n            }\\n            int index=-1;\\n            for (int i=left+1;i<right;i++) {\\n                if (s[i] == s[right]) {\\n                    index=i;\\n                    break;\\n                }\\n            }\\n            if (index == -1) {\\n                center = right;\\n                right--;\\n                continue;\\n            }\\n            for (int i=index-1;i>=left;i--) {\\n                swap(s[i], s[i+1]);\\n                swaps++;\\n            } \\n            left++;\\n            right--;\\n        }\\n        if (center!=-1) {\\n            swaps+=center-s.length()/2;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minMovesToMakePalindrome(string s) {\\n        int left = 0, right = s.length()-1, center = -1, swaps = 0;\\n        while (left<right) {\\n            if (s[left] == s[right]) {\\n                left++;\\n                right--;\\n                continue;\\n            }\\n            int index=-1;\\n            for (int i=left+1;i<right;i++) {\\n                if (s[i] == s[right]) {\\n                    index=i;\\n                    break;\\n                }\\n            }\\n            if (index == -1) {\\n                center = right;\\n                right--;\\n                continue;\\n            }\\n            for (int i=index-1;i>=left;i--) {\\n                swap(s[i], s[i+1]);\\n                swaps++;\\n            } \\n            left++;\\n            right--;\\n        }\\n        if (center!=-1) {\\n            swaps+=center-s.length()/2;\\n        }\\n        return swaps;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767315,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int n  =s.size();\\n        int lt = 0 , rt = n-1, ans = 0;\\n        while(lt<rt){\\n            int l = lt;\\n            int r = rt;\\n            while(s[l] != s[r])\\n            r--;\\n            if(l==r){\\n                swap(s[r], s[r+1]);\\n                ans ++;\\n                continue;\\n            }\\n            else{\\n                while(r<rt){\\n                    swap(s[r], s[r+1]);\\n                    ans++; \\n                    r++;\\n\\n                }\\n            }\\n            lt++;\\n            rt--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        int n  =s.size();\\n        int lt = 0 , rt = n-1, ans = 0;\\n        while(lt<rt){\\n            int l = lt;\\n            int r = rt;\\n            while(s[l] != s[r])\\n            r--;\\n            if(l==r){\\n                swap(s[r], s[r+1]);\\n                ans ++;\\n                continue;\\n            }\\n            else{\\n                while(r<rt){\\n                    swap(s[r], s[r+1]);\\n                    ans++; \\n                    r++;\\n\\n                }\\n            }\\n            lt++;\\n            rt--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3746793,
                "title": "optimal-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n       int n = s.length();\\n       int i =0,j=n-1;\\n        int ans = 0;\\n        while(i<j){\\n            if(s[i]==s[j]){     // Both Characters are same move 2 pointers\\n                i++;\\n                j--;\\n            }else{\\n\\t\\t\\t// Both characters are not same\\n                int found = -1;\\n\\t\\t\\t\\t//find index nearest to j which matches with i index\\n                for(int k=j-1;k>i;k--){\\n                    if(s[k]==s[i]){\\n                        found = k;\\n                        break;\\n                    }\\n                }\\n                \\n\\t\\t\\t\\t// found the character which is equal to s[i]\\n                if(found>0){\\n                    for(int k=found;k<j;k++){\\n                        swap(s[k],s[k+1]);\\n                        ans++;\\n                    }\\n                    i++;\\n                    j--;\\n                }else{\\n\\t\\t\\t\\t/* If not found means that character at ith index would have been odd character.\\n\\t\\t\\t\\tso swap it so it would eventually end at middle of string*/\\n                    swap(s[i],s[i+1]);\\n                    ans++;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n       int n = s.length();\\n       int i =0,j=n-1;\\n        int ans = 0;\\n        while(i<j){\\n            if(s[i]==s[j]){     // Both Characters are same move 2 pointers\\n                i++;\\n                j--;\\n            }else{\\n\\t\\t\\t// Both characters are not same\\n                int found = -1;\\n\\t\\t\\t\\t//find index nearest to j which matches with i index\\n                for(int k=j-1;k>i;k--){\\n                    if(s[k]==s[i]){\\n                        found = k;\\n                        break;\\n                    }\\n                }\\n                \\n\\t\\t\\t\\t// found the character which is equal to s[i]\\n                if(found>0){\\n                    for(int k=found;k<j;k++){\\n                        swap(s[k],s[k+1]);\\n                        ans++;\\n                    }\\n                    i++;\\n                    j--;\\n                }else{\\n\\t\\t\\t\\t/* If not found means that character at ith index would have been odd character.\\n\\t\\t\\t\\tso swap it so it would eventually end at middle of string*/\\n                    swap(s[i],s[i+1]);\\n                    ans++;\\n                }\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729975,
                "title": "straightforward-greedy-algorithm-in-python-beating-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn each turn, it is necessary to match the first character `s[0]` and the last charactor `s[-1]` of the string `s`. Do nothing if the first and the last ones already match (i.e., `s[0] == s[-1]`). Otherwise, my greedy approach determines to replace the first or the last one by considering the cost. The cost to replace the first character `s[0]` is its distance to the leftmost occurrence of `s[-1]`; the cost to replace the last character `s[-1]` is its distance to the rightmost occurrence of `s[0]`. Pick up the choice with the lower cost and trim the first and the last characters from the string. \\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$, where $$n$$ is the length of the input string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The input is $$O(n)$$. Only constant extra memeory is used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0\\n        while len(s) > 2:\\n            if s[0] != s[-1]:\\n                l, r = s.find(s[-1]), s.rfind(s[0])\\n                if l < len(s) - r - 1: \\n                    ans += l\\n                    s = s[:l] + s[l+1:-1]\\n                else:\\n                    ans += len(s) - r - 1\\n                    s = s[1:r] + s[r+1:]\\n            else:\\n                s = s[1:-1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0\\n        while len(s) > 2:\\n            if s[0] != s[-1]:\\n                l, r = s.find(s[-1]), s.rfind(s[0])\\n                if l < len(s) - r - 1: \\n                    ans += l\\n                    s = s[:l] + s[l+1:-1]\\n                else:\\n                    ans += len(s) - r - 1\\n                    s = s[1:r] + s[r+1:]\\n            else:\\n                s = s[1:-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3725253,
                "title": "straightforward-brute-force-in-python-beating-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIn each turn, it is necessary to match the first character `s[0]` and the last charactor `s[-1]` of the string `s`. Do nothing if the first and the last ones already match (i.e., `s[0] == s[-1]`). Otherwise, my greedy approach determines to replace the first or the last one by considering the cost. The cost to replace the first character `s[0]` is its distance to the leftmost occurrence of `s[-1]`; the cost to replace the last character `s[-1]` is its distance to the rightmost occurrence of `s[0]`. Pick up the choice with the lower cost and trim the first and the last characters from the string. \\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$, where $$n$$ is the length of the input string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The input is $$O(n)$$. Only constant extra memeory is used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        l, r = 0, len(s)-1\\n        ans = 0\\n        while len(s) > 2:\\n            if s[0] != s[-1]:\\n                nl, nr = s.find(s[-1]), s.rfind(s[0])\\n                if nl < len(s) - nr - 1: \\n                    ans += nl\\n                    s = s[:nl] + s[nl+1:-1]\\n                else:\\n                    ans += len(s) - nr - 1\\n                    s = s[1:nr] + s[nr+1:]\\n            else:\\n                s = s[1:-1]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        l, r = 0, len(s)-1\\n        ans = 0\\n        while len(s) > 2:\\n            if s[0] != s[-1]:\\n                nl, nr = s.find(s[-1]), s.rfind(s[0])\\n                if nl < len(s) - nr - 1: \\n                    ans += nl\\n                    s = s[:nl] + s[nl+1:-1]\\n                else:\\n                    ans += len(s) - nr - 1\\n                    s = s[1:nr] + s[nr+1:]\\n            else:\\n                s = s[1:-1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712720,
                "title": "c-two-pointer-approach-greedy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        int ans=0;\\n        while(j>=i)\\n        {\\n            if(s[i]==s[j]) \\n            {\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                int ct=0;\\n                int idx=-1;\\n                for(int k=i;k<=j;k++)\\n                {\\n                    if(s[k]==s[j]) \\n                    {\\n                        idx=k;\\n                        ct=k-i;\\n                        break;\\n                    }\\n                }\\n               // cout<<i<<\" \"<<j<<\\n                int ct1=0;\\n                int idx2=-1;\\n                for(int k=j;k>=i;k--)\\n                {\\n                    if(s[k]==s[i])\\n                    {\\n                        idx2=k;\\n                        ct1=j-k;\\n                        break;\\n                    }\\n                }\\n                if(ct<=ct1)\\n                {\\n                    ans+=ct;\\n                    while(idx>i)\\n                    {\\n                        swap(s[idx],s[idx-1]);\\n                        idx--;\\n                    }\\n                }\\n                else\\n                {\\n                    ans+=ct1;\\n                    while(idx2<j)\\n                    {\\n                        swap(s[idx2],s[idx2+1]);\\n                        idx2++;\\n                    }\\n                }\\n                i++;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        int ans=0;\\n        while(j>=i)\\n        {\\n            if(s[i]==s[j]) \\n            {\\n                i++;\\n                j--;\\n            }\\n            else\\n            {\\n                int ct=0;\\n                int idx=-1;\\n                for(int k=i;k<=j;k++)\\n                {\\n                    if(s[k]==s[j]) \\n                    {\\n                        idx=k;\\n                        ct=k-i;\\n                        break;\\n                    }\\n                }\\n               // cout<<i<<\" \"<<j<<\\n                int ct1=0;\\n                int idx2=-1;\\n                for(int k=j;k>=i;k--)\\n                {\\n                    if(s[k]==s[i])\\n                    {\\n                        idx2=k;\\n                        ct1=j-k;\\n                        break;\\n                    }\\n                }\\n                if(ct<=ct1)\\n                {\\n                    ans+=ct;\\n                    while(idx>i)\\n                    {\\n                        swap(s[idx],s[idx-1]);\\n                        idx--;\\n                    }\\n                }\\n                else\\n                {\\n                    ans+=ct1;\\n                    while(idx2<j)\\n                    {\\n                        swap(s[idx2],s[idx2+1]);\\n                        idx2++;\\n                    }\\n                }\\n                i++;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3686481,
                "title": "simple-c-two-pointers-greedy-solution",
                "content": "```\\nint solve( string &s , int i , int j )\\n    {\\n        if( i >= j ) return 0 ;\\n        \\n        if( s[i] == s[j] )\\n        {\\n            return solve( s , i+1 , j-1 ) ;\\n        }\\n        \\n        int ans = INT_MAX ;\\n        \\n        int p1 = i + 1 ;\\n        int p2 = j - 1 ;\\n        \\n        \\n        while( p1 < j  && s[p1] != s[j] )\\n        {\\n            p1++ ;\\n        }\\n        \\n        while( p2 > i  && s[p2] != s[i] )\\n        {\\n            p2-- ;\\n        }\\n        \\n        int temp = 0 ;\\n        \\n        if( p1 < j && p2 > i )\\n        {\\n            if( (p1 - i ) <= ( j - p2 ) )\\n            {\\n                temp = 1 ;\\n            }\\n            else\\n            {\\n                temp = 2 ;\\n            }\\n        }\\n        else if( p1 < j )\\n        {\\n            temp = 1 ;\\n            \\n        }\\n        else if( p2 > i )\\n        {\\n            temp = 2 ;\\n        }\\n        \\n        if(temp == 1 )\\n        {\\n            ans = p1 - i ;\\n            while( p1 > i )\\n            {\\n                swap( s[p1] , s[p1-1] ) ;\\n                p1-- ;\\n            }\\n            \\n        }\\n        else if( temp == 2 )\\n        {\\n            ans = j - p2 ;\\n            while( p2 < j )\\n            {\\n                swap( s[p2] , s[p2 + 1] ) ;\\n                p2++ ;\\n            }\\n            \\n        }\\n        \\n        return ans + solve( s , i+1 , j-1 ) ;\\n        \\n    }\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        return solve( s , 0 , s.size()-1 ) ; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint solve( string &s , int i , int j )\\n    {\\n        if( i >= j ) return 0 ;\\n        \\n        if( s[i] == s[j] )\\n        {\\n            return solve( s , i+1 , j-1 ) ;\\n        }\\n        \\n        int ans = INT_MAX ;\\n        \\n        int p1 = i + 1 ;\\n        int p2 = j - 1 ;\\n        \\n        \\n        while( p1 < j  && s[p1] != s[j] )\\n        {\\n            p1++ ;\\n        }\\n        \\n        while( p2 > i  && s[p2] != s[i] )\\n        {\\n            p2-- ;\\n        }\\n        \\n        int temp = 0 ;\\n        \\n        if( p1 < j && p2 > i )\\n        {\\n            if( (p1 - i ) <= ( j - p2 ) )\\n            {\\n                temp = 1 ;\\n            }\\n            else\\n            {\\n                temp = 2 ;\\n            }\\n        }\\n        else if( p1 < j )\\n        {\\n            temp = 1 ;\\n            \\n        }\\n        else if( p2 > i )\\n        {\\n            temp = 2 ;\\n        }\\n        \\n        if(temp == 1 )\\n        {\\n            ans = p1 - i ;\\n            while( p1 > i )\\n            {\\n                swap( s[p1] , s[p1-1] ) ;\\n                p1-- ;\\n            }\\n            \\n        }\\n        else if( temp == 2 )\\n        {\\n            ans = j - p2 ;\\n            while( p2 < j )\\n            {\\n                swap( s[p2] , s[p2 + 1] ) ;\\n                p2++ ;\\n            }\\n            \\n        }\\n        \\n        return ans + solve( s , i+1 , j-1 ) ;\\n        \\n    }\\n    int minMovesToMakePalindrome(string s) {\\n        \\n        return solve( s , 0 , s.size()-1 ) ; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3641189,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string str) {\\n    int size=str.size()-1;\\n    int count=0;\\n    int left=0;\\n    int right=size;\\n    while(left<right){\\n        int l=left,r=right;\\n        while(str[r]!=str[l]) r--;\\n        if(l==r){\\n            swap(str[r],str[r+1]);\\n            count++;\\n            continue;\\n        }\\n        else{\\n            while(r<right){\\n                swap(str[r],str[r+1]);\\n                r++;\\n                count++;\\n            }\\n        }\\n        left++;\\n        right--;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string str) {\\n    int size=str.size()-1;\\n    int count=0;\\n    int left=0;\\n    int right=size;\\n    while(left<right){\\n        int l=left,r=right;\\n        while(str[r]!=str[l]) r--;\\n        if(l==r){\\n            swap(str[r],str[r+1]);\\n            count++;\\n            continue;\\n        }\\n        else{\\n            while(r<right){\\n                swap(str[r],str[r+1]);\\n                r++;\\n                count++;\\n            }\\n        }\\n        left++;\\n        right--;\\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592644,
                "title": "minimum-number-of-moves-to-make-palindrome-2-pointers",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string &s) {\\n        int i=0,j=s.length()-1;\\n        int ans=0;\\n        while(i<j){\\n          if(i==j)break;\\n          if(s[i]!=s[j]){\\n            size_t found=s.find(s[j]);\\n            if(found == j){\\n              int k=j;\\n              for ( k = j; k > i ; k--) {\\n                /* code */\\n                if(s[k]==s[i])break;\\n                \\n              }\\n              ans += j-k;\\n              s.erase(k,1);\\n              s.erase(i,1);\\n              j-=2;\\n              \\n            }\\n            else{ \\n              ans+=found - i;\\n              s.erase(j,1);\\n              s.erase(found,1);\\n              j-=2;\\n            }\\n            \\n          }\\n          else {\\n            s.erase(j,1);\\n            s.erase(i,1);\\n            j-=2;\\n            \\n          }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string &s) {\\n        int i=0,j=s.length()-1;\\n        int ans=0;\\n        while(i<j){\\n          if(i==j)break;\\n          if(s[i]!=s[j]){\\n            size_t found=s.find(s[j]);\\n            if(found == j){\\n              int k=j;\\n              for ( k = j; k > i ; k--) {\\n                /* code */\\n                if(s[k]==s[i])break;\\n                \\n              }\\n              ans += j-k;\\n              s.erase(k,1);\\n              s.erase(i,1);\\n              j-=2;\\n              \\n            }\\n            else{ \\n              ans+=found - i;\\n              s.erase(j,1);\\n              s.erase(found,1);\\n              j-=2;\\n            }\\n            \\n          }\\n          else {\\n            s.erase(j,1);\\n            s.erase(i,1);\\n            j-=2;\\n            \\n          }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551712,
                "title": "easy-c-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing two pointer approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing simple two pointer approach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int i =0;\\n        int j = n-1;\\n        int ans = 0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }else if(s[i]!=s[j]){\\n                int l = i;\\n                int r =  j;\\n                \\n                while(s[i]!=s[r]){\\n                    r--;\\n                }\\n                int val1 =j-r;\\n                while(s[l]!=s[j]){\\n                    l++;\\n                }\\n                int val2 =l-i;\\n                if(val1<=val2){\\n                    while(r<j){\\n                        swap(s[r],s[r+1]);\\n                        r++;\\n                    }\\n                }else{\\n                    while(l>i){\\n                        swap(s[l],s[l-1]);\\n                        l--;\\n                    }\\n                }\\n                ans+=min(val1,val2);\\n                i++;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n//please Upvote if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int i =0;\\n        int j = n-1;\\n        int ans = 0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }else if(s[i]!=s[j]){\\n                int l = i;\\n                int r =  j;\\n                \\n                while(s[i]!=s[r]){\\n                    r--;\\n                }\\n                int val1 =j-r;\\n                while(s[l]!=s[j]){\\n                    l++;\\n                }\\n                int val2 =l-i;\\n                if(val1<=val2){\\n                    while(r<j){\\n                        swap(s[r],s[r+1]);\\n                        r++;\\n                    }\\n                }else{\\n                    while(l>i){\\n                        swap(s[l],s[l-1]);\\n                        l--;\\n                    }\\n                }\\n                ans+=min(val1,val2);\\n                i++;\\n                j--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n//please Upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3546515,
                "title": "greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- check 2 cases\\n- 1 only one character\\n- 2 there are 2 characters\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2), while s takes n, index takes n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s, res = list(s), 0\\n        while s:\\n            i = s.index(s[-1])\\n            # if there is only 1 character at the end, find moves, pop it only\\n            if i == len(s) - 1: \\n                res += i // 2\\n            else:\\n                res += i\\n                s.pop(i) # pop from the left first, after that, pop from the right\\n            s.pop() # pop from the right\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s, res = list(s), 0\\n        while s:\\n            i = s.index(s[-1])\\n            # if there is only 1 character at the end, find moves, pop it only\\n            if i == len(s) - 1: \\n                res += i // 2\\n            else:\\n                res += i\\n                s.pop(i) # pop from the left first, after that, pop from the right\\n            s.pop() # pop from the right\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458939,
                "title": "intuitive-solution-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem we just need to think for the end positions which item will be best to swap with minimun swaps. For example, if we have string \"aaccbb\", we need to think that which operation will result into minimum swaps: \\n\\n1) swapping a with nearest b \\n    OR\\n2) swapping b with nearest a \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        first = 0\\n        last = len(s)-1\\n        totalSwaps = 0\\n        s = list(s)\\n                    \\n        def swapsRequired(left, right, direction):\\n            if direction:\\n                closestIdx = right\\n                swapWith = s[right]\\n                for i in range(right-1, left,-1):\\n                    if s[i] == swapWith:\\n                        closestIdx = min(closestIdx, i)\\n                return (closestIdx-left, closestIdx)\\n\\n            else:\\n                closestIdx = left\\n                swapWith = s[left]\\n                for i in range(left+1, right):\\n                    if s[i] == swapWith:\\n                        closestIdx = max(i, closestIdx)\\n                return (right - closestIdx, closestIdx)\\n\\n        while first < last:\\n            if s[first] == s[last]:\\n                first += 1\\n                last -= 1\\n                continue\\n            leftSwap, leftIdx = swapsRequired(first, last, 1)\\n            rightSwap, rightIdx = swapsRequired(first, last, 0)\\n            if leftSwap < rightSwap:\\n                while first < leftIdx:\\n                    s[leftIdx], s[leftIdx-1] = s[leftIdx-1], s[leftIdx]\\n                    leftIdx -= 1\\n            else:\\n                while rightIdx < last:\\n                    s[rightIdx], s[rightIdx+1] = s[rightIdx+1], s[rightIdx]\\n                    rightIdx += 1\\n            totalSwaps += min(leftSwap, rightSwap)\\n            first += 1\\n            last -= 1   \\n\\n        return totalSwaps           \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        first = 0\\n        last = len(s)-1\\n        totalSwaps = 0\\n        s = list(s)\\n                    \\n        def swapsRequired(left, right, direction):\\n            if direction:\\n                closestIdx = right\\n                swapWith = s[right]\\n                for i in range(right-1, left,-1):\\n                    if s[i] == swapWith:\\n                        closestIdx = min(closestIdx, i)\\n                return (closestIdx-left, closestIdx)\\n\\n            else:\\n                closestIdx = left\\n                swapWith = s[left]\\n                for i in range(left+1, right):\\n                    if s[i] == swapWith:\\n                        closestIdx = max(i, closestIdx)\\n                return (right - closestIdx, closestIdx)\\n\\n        while first < last:\\n            if s[first] == s[last]:\\n                first += 1\\n                last -= 1\\n                continue\\n            leftSwap, leftIdx = swapsRequired(first, last, 1)\\n            rightSwap, rightIdx = swapsRequired(first, last, 0)\\n            if leftSwap < rightSwap:\\n                while first < leftIdx:\\n                    s[leftIdx], s[leftIdx-1] = s[leftIdx-1], s[leftIdx]\\n                    leftIdx -= 1\\n            else:\\n                while rightIdx < last:\\n                    s[rightIdx], s[rightIdx+1] = s[rightIdx+1], s[rightIdx]\\n                    rightIdx += 1\\n            totalSwaps += min(leftSwap, rightSwap)\\n            first += 1\\n            last -= 1   \\n\\n        return totalSwaps           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452962,
                "title": "python-readable-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGreedy idea.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe check the leftmost and rightmost characters, if they are equal, pop these two out. Otherwise, we examine the index of the first character equal rightmost and the index of last character equal leftmost. The SMALLEST should be the steps we move. It is where greedy works.\\n\\nPop out these two characters and do the above again, until no more than one character left.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        temp = [_ for _ in s]\\n        ans = 0\\n        while len(temp) > 1:\\n            if temp[0] == temp[-1]:\\n                temp.pop(0)\\n                temp.pop()\\n            else:\\n                left,right = temp[0],temp[-1]\\n                a,b = -1,-1\\n                for i in range(len(temp)):\\n                    if temp[i] == right:\\n                        a = i\\n                        break\\n                for j in range(len(temp)):\\n                    if temp[~j] == left:\\n                        b = j\\n                        break\\n                if a < b:\\n                    ans += a\\n                    temp.pop(a)\\n                    temp.pop()\\n                else:\\n                    ans += b\\n                    temp.pop(~b)\\n                    temp.pop(0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        temp = [_ for _ in s]\\n        ans = 0\\n        while len(temp) > 1:\\n            if temp[0] == temp[-1]:\\n                temp.pop(0)\\n                temp.pop()\\n            else:\\n                left,right = temp[0],temp[-1]\\n                a,b = -1,-1\\n                for i in range(len(temp)):\\n                    if temp[i] == right:\\n                        a = i\\n                        break\\n                for j in range(len(temp)):\\n                    if temp[~j] == left:\\n                        b = j\\n                        break\\n                if a < b:\\n                    ans += a\\n                    temp.pop(a)\\n                    temp.pop()\\n                else:\\n                    ans += b\\n                    temp.pop(~b)\\n                    temp.pop(0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444737,
                "title": "simple-2-pointer-algorithm-simple-easy-specially-designed-for-beginner-s-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int ans=0;\\n        for(int i=0;i<n/2;i++){\\n            if(s[i]!=s[n-i-1]){\\n                // we have to do something peter \\n                //we have to find in the range (i+1,n-i-1);\\n                char ch = s[i];\\n                int idx = -1;\\n                for(int j = n-i-1;j>i;j--){\\n                    if(s[j]==ch){\\n                        // find the nearest character\\n                        idx = j;\\n                        break;\\n                    }\\n                }\\n                char ch2 = s[n-i-1];\\n                int idx2= -1;\\n                for(int j=i;j<n-i-1;j++){\\n                    if(s[j]==ch2){\\n                        idx2=j;\\n                        break;\\n                    }\\n                }\\n                int diff = n-1-i-idx;\\n                int diff2 = idx2 - i;\\n                if(idx!=-1 && idx2!=-1){\\n                    // if they both are actively available;\\n                    if(diff < diff2){\\n                        for(int j=idx;j<n-i-1;j++) s[j]=s[j+1];\\n                        s[n-i-1]=ch;\\n                        ans+=diff;\\n                    }else{\\n                        for(int j=idx2;j>i;j--) s[j]=s[j-1];\\n                        s[i]=ch2;\\n                        ans+=diff2;\\n                    }\\n                }\\n                else if(idx!=-1){\\n                    for(int j=idx;j<n-i-1;j++) s[j]=s[j+1];\\n                    s[n-i-1]=ch;\\n                    ans+=diff;\\n                }else if(idx2!=-1){\\n                    for(int j=idx2;j>i;j--) s[j]=s[j-1];\\n                    s[i]=ch2;\\n                    ans+=diff2;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int ans=0;\\n        for(int i=0;i<n/2;i++){\\n            if(s[i]!=s[n-i-1]){\\n                // we have to do something peter \\n                //we have to find in the range (i+1,n-i-1);\\n                char ch = s[i];\\n                int idx = -1;\\n                for(int j = n-i-1;j>i;j--){\\n                    if(s[j]==ch){\\n                        // find the nearest character\\n                        idx = j;\\n                        break;\\n                    }\\n                }\\n                char ch2 = s[n-i-1];\\n                int idx2= -1;\\n                for(int j=i;j<n-i-1;j++){\\n                    if(s[j]==ch2){\\n                        idx2=j;\\n                        break;\\n                    }\\n                }\\n                int diff = n-1-i-idx;\\n                int diff2 = idx2 - i;\\n                if(idx!=-1 && idx2!=-1){\\n                    // if they both are actively available;\\n                    if(diff < diff2){\\n                        for(int j=idx;j<n-i-1;j++) s[j]=s[j+1];\\n                        s[n-i-1]=ch;\\n                        ans+=diff;\\n                    }else{\\n                        for(int j=idx2;j>i;j--) s[j]=s[j-1];\\n                        s[i]=ch2;\\n                        ans+=diff2;\\n                    }\\n                }\\n                else if(idx!=-1){\\n                    for(int j=idx;j<n-i-1;j++) s[j]=s[j+1];\\n                    s[n-i-1]=ch;\\n                    ans+=diff;\\n                }else if(idx2!=-1){\\n                    for(int j=idx2;j>i;j--) s[j]=s[j-1];\\n                    s[i]=ch2;\\n                    ans+=diff2;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3444152,
                "title": "two-pointer-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe approach used in this code is to traverse the string from both ends simultaneously and comparing the characters. If the characters are not the same, we need to perform a swap operation to make them equal. If the string has odd length and we reach the middle of the string, we need to handle the middle element differently by swapping it with the adjacent element. We continue this process until we reach the middle of the string.\\n\\n# Complexity\\nThe time complexity of this algorithm is O(n^2) where n is the length of the string s because we are traversing the string multiple times. The space complexity is O(1) because we are not using any additional data structure to store the string or intermediate results.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.length();\\n       \\n        int left = 0, right = s.size() - 1, ans = 0;\\n        \\n        // Traverse the string from both ends simultaneously\\n        while (left < right) {\\n            int l = left, r = right;\\n            \\n            // Compare the characters at left and right positions\\n            while (s[l] != s[r]) {\\n                r--;   \\n            }\\n            \\n            // If l==r, we have reached the odd middle element of the string\\n            if (l == r) {\\n                // Swap the middle element with the adjacent element\\n                swap(s[r], s[r + 1]);\\n                ans++;\\n                continue;\\n            } \\n            else {\\n                // If l!=r, we have reached a normal element\\n                // Move the unequal character to the right side of the string\\n                while (r < right) {\\n                    swap(s[r], s[r + 1]);\\n                    ans++;\\n                    r++;\\n                }\\n            }\\n            // Move to the next set of left and right characters\\n            left++;\\n            right--;\\n        }\\n        // Return the number of moves required to make the string a palindrome\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.length();\\n       \\n        int left = 0, right = s.size() - 1, ans = 0;\\n        \\n        // Traverse the string from both ends simultaneously\\n        while (left < right) {\\n            int l = left, r = right;\\n            \\n            // Compare the characters at left and right positions\\n            while (s[l] != s[r]) {\\n                r--;   \\n            }\\n            \\n            // If l==r, we have reached the odd middle element of the string\\n            if (l == r) {\\n                // Swap the middle element with the adjacent element\\n                swap(s[r], s[r + 1]);\\n                ans++;\\n                continue;\\n            } \\n            else {\\n                // If l!=r, we have reached a normal element\\n                // Move the unequal character to the right side of the string\\n                while (r < right) {\\n                    swap(s[r], s[r + 1]);\\n                    ans++;\\n                    r++;\\n                }\\n            }\\n            // Move to the next set of left and right characters\\n            left++;\\n            right--;\\n        }\\n        // Return the number of moves required to make the string a palindrome\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3442688,
                "title": "simple-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int i=0,j=s.size()-1,ans=0;\\n        while(i<j){\\n            if(s[i]==s[j])\\n              {\\n                  i++;\\n                  j--;\\n              }\\n              else{\\n                  int idx=-1;\\n                  for(int k=j-1;k>i;k--){\\n                    if(s[k]==s[i]){\\n                        idx = k;\\n                        break;\\n                    }\\n                }\\n                  if(idx>0){\\n                      for(int k=idx;k<j;k++){\\n                          swap(s[k],s[k+1]);\\n                          ans++;\\n                      }\\n                      i++;j--;\\n                  }\\n                  else{\\n                      swap(s[i],s[i+1]);\\n                      ans++;\\n                  }\\n              }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\nABouve one pass perfectly but lower one does not pass propery,give tle why\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int i=0,j=s.size()-1,ans=0;\\n        while(i<j){\\n            if(s[i]==s[j])\\n              {\\n                  i++;\\n                  j--;\\n              }\\n              else{\\n                  int idx=-1;\\n                  for(int k=i+1;k<j;k++){\\n                      if(s[k]==s[j]){\\n                          idx=k;break;\\n                      }\\n                  }\\n                  if(idx>0){\\n                      for(int k=idx;k>i;k--){\\n                          swap(s[k],s[k-1]);\\n                          ans++;\\n                      }\\n                      i++;j--;\\n                  }\\n                  else{\\n                      swap(s[i],s[i+1]);\\n                      ans++;\\n                  }\\n              }\\n        }\\n        return ans;\\n    }\\n};\\n\\ncan amyone explain",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int i=0,j=s.size()-1,ans=0;\\n        while(i<j){\\n            if(s[i]==s[j])\\n              {\\n                  i++;\\n                  j--;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 3419327,
                "title": "sakshi-awadhiya",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        //using two pointer approach\\n\\n      int ans=0; // creating ans variable\\n        char arr[]=s.toCharArray(); //convert string to character array\\n        int i=0;  //creating i pointer\\n        int j=arr.length-1; // creating j pointer\\n        while(i<j){ \\n            int high=j; //crating high variable\\n            if(arr[i]==arr[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                while(arr[i]!=arr[high]){\\n                    high--;\\n                }\\n                \\n                if(i==high) {\\n                 swap(arr,high,high+1);  // mid elememt\\n                   ans++;\\n                continue;\\n                }\\n                else{\\n                \\n                 while(high<j){  \\n                    swap(arr,high,high+1);\\n                    ans++;\\n                    high++;\\n                }\\n            }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    // write swap function to swap \\n    public static void swap(char ch[],int i,int j){\\n        \\n        char t=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=t;\\n    }\\n}\\n   \\n        \\n    \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        //using two pointer approach\\n\\n      int ans=0; // creating ans variable\\n        char arr[]=s.toCharArray(); //convert string to character array\\n        int i=0;  //creating i pointer\\n        int j=arr.length-1; // creating j pointer\\n        while(i<j){ \\n            int high=j; //crating high variable\\n            if(arr[i]==arr[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                while(arr[i]!=arr[high]){\\n                    high--;\\n                }\\n                \\n                if(i==high) {\\n                 swap(arr,high,high+1);  // mid elememt\\n                   ans++;\\n                continue;\\n                }\\n                else{\\n                \\n                 while(high<j){  \\n                    swap(arr,high,high+1);\\n                    ans++;\\n                    high++;\\n                }\\n            }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    // write swap function to swap \\n    public static void swap(char ch[],int i,int j){\\n        \\n        char t=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=t;\\n    }\\n}\\n   \\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376624,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ret = 0 ;\\n        while(s.size() > 1){\\n            int i = s.find(s.back()) ;\\n            //the string in the middle\\n            if(i == s.size() - 1){\\n                ret += s.size()/2 ;\\n            }\\n            else{\\n                ret += i ;\\n                s.erase(i, 1) ;\\n            }\\n            s.pop_back() ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ret = 0 ;\\n        while(s.size() > 1){\\n            int i = s.find(s.back()) ;\\n            //the string in the middle\\n            if(i == s.size() - 1){\\n                ret += s.size()/2 ;\\n            }\\n            else{\\n                ret += i ;\\n                s.erase(i, 1) ;\\n            }\\n            s.pop_back() ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3285097,
                "title": "c-greedy",
                "content": "# Intuition\\nfind the min move to make left bound and right bound the same. then recursion\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int res = 0;\\n        while(s.size() > 1) res += oneStep(s);\\n        return res;\\n    }\\n\\n    int oneStep(string& s){\\n        vector<int> left(26, 9999), right(26, -1);\\n        const int n = s.size();\\n        for(int i=0;i<n;i++){\\n            left[s[i]-\\'a\\'] = min(left[s[i]-\\'a\\'], i);\\n            right[s[i]-\\'a\\'] = max(right[s[i]-\\'a\\'], i);\\n        }\\n        int bestChar = -1, minMove = 9999999;\\n        for(int i=0;i<26;i++){\\n            if(left[i] == right[i]) continue;\\n            int numMove = left[i] + n-1-right[i];\\n            if(numMove < minMove){\\n                minMove = numMove;\\n                bestChar = i;\\n            }\\n        }\\n        string t;\\n        for(int i=0;i<n;i++){\\n            if(i!= left[bestChar] && i!=right[bestChar])\\n            t += s[i];\\n        }\\n        s = move(t);\\n        return minMove;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int res = 0;\\n        while(s.size() > 1) res += oneStep(s);\\n        return res;\\n    }\\n\\n    int oneStep(string& s){\\n        vector<int> left(26, 9999), right(26, -1);\\n        const int n = s.size();\\n        for(int i=0;i<n;i++){\\n            left[s[i]-\\'a\\'] = min(left[s[i]-\\'a\\'], i);\\n            right[s[i]-\\'a\\'] = max(right[s[i]-\\'a\\'], i);\\n        }\\n        int bestChar = -1, minMove = 9999999;\\n        for(int i=0;i<26;i++){\\n            if(left[i] == right[i]) continue;\\n            int numMove = left[i] + n-1-right[i];\\n            if(numMove < minMove){\\n                minMove = numMove;\\n                bestChar = i;\\n            }\\n        }\\n        string t;\\n        for(int i=0;i<n;i++){\\n            if(i!= left[bestChar] && i!=right[bestChar])\\n            t += s[i];\\n        }\\n        s = move(t);\\n        return minMove;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281388,
                "title": "c-two-pointers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) \\n    {\\n        int n = s.size();\\n        int left = 0, right = n - 1;\\n        int ans = 0;\\n        while (left < right) {\\n            // Find the first character from left that doesn\\'t match the corresponding character from right\\n            while (left < right && s[left] == s[right]) {\\n                left++;\\n                right--;\\n            }\\n            // If we have processed the entire string, we\\'re done\\n            if (left >= right) {\\n                break;\\n            }\\n            // Find the character from right that matches the current character from left\\n            int j = right;\\n            while (j > left && s[j] != s[left]) {\\n                j--;\\n            }\\n            // If we can\\'t find a matching character, swap the current character from left with the next character\\n            if (j == left) {\\n                swap(s[left], s[left + 1]);\\n                ans++;\\n            }\\n            // Otherwise, swap the characters from j to right and move left and right pointers towards each other\\n            else {\\n                while (j < right) {\\n                    swap(s[j], s[j + 1]);\\n                    ans++;\\n                    j++;\\n                }\\n                left++;\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) \\n    {\\n        int n = s.size();\\n        int left = 0, right = n - 1;\\n        int ans = 0;\\n        while (left < right) {\\n            // Find the first character from left that doesn\\'t match the corresponding character from right\\n            while (left < right && s[left] == s[right]) {\\n                left++;\\n                right--;\\n            }\\n            // If we have processed the entire string, we\\'re done\\n            if (left >= right) {\\n                break;\\n            }\\n            // Find the character from right that matches the current character from left\\n            int j = right;\\n            while (j > left && s[j] != s[left]) {\\n                j--;\\n            }\\n            // If we can\\'t find a matching character, swap the current character from left with the next character\\n            if (j == left) {\\n                swap(s[left], s[left + 1]);\\n                ans++;\\n            }\\n            // Otherwise, swap the characters from j to right and move left and right pointers towards each other\\n            else {\\n                while (j < right) {\\n                    swap(s[j], s[j + 1]);\\n                    ans++;\\n                    j++;\\n                }\\n                left++;\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248824,
                "title": "c-easy-to-understand-code-two-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        int j = n-1;\\n        int ans = 0;\\n        while(i<j){\\n            int x = i,y=j;\\n            \\n            while(s[x]!=s[y])y--;\\n            \\n            // accbb,abb case for this condition dry run\\n            if(x==y){\\n                swap(s[y],s[y+1]);\\n                ans++;\\n                continue;\\n            }\\n            //aabb case for this condition dry run\\n            else{\\n                while(y<j){\\n                    swap(s[y],s[y+1]);\\n                    y++;\\n                    ans++;\\n                }\\n            }\\n            \\n            i++;j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        int j = n-1;\\n        int ans = 0;\\n        while(i<j){\\n            int x = i,y=j;\\n            \\n            while(s[x]!=s[y])y--;\\n            \\n            // accbb,abb case for this condition dry run\\n            if(x==y){\\n                swap(s[y],s[y+1]);\\n                ans++;\\n                continue;\\n            }\\n            //aabb case for this condition dry run\\n            else{\\n                while(y<j){\\n                    swap(s[y],s[y+1]);\\n                    y++;\\n                    ans++;\\n                }\\n            }\\n            \\n            i++;j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3245541,
                "title": "scala-4-ways-recursion-two-pointers-greedy-with-arraybuffer-or-fenwick-tree-no-pointers-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Desocribe your approach to solving the problem. -->\\n1. construct palindrome using recursion, handle carefully for odd number palindromes, see approach #4 for iterative approach\\n2. two pointers O(N^2) (left and right and closing in)\\n3. two pointers with BIT to track num of chars swapped to the right of certain index\\n4. no pointers, popping processed chars from both ends as we closing in, this is actually the iterative version of approach #1 which is recursive\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n1. O(N^2) with either approach 1 or 3\\n2. O(NlogN) for approach 2\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\nSome thoughts:\\nProof that abab has two arrangements that requires equal number of min moves (abba or baab):\\nfor n=8, a in (1,5), b in (3,8) , a.b.a..a to begin with:\\n1. \\'a\\' pair has imsymmetricity around the invisible center , the imbalance is that one side is 3 chars away from center while the other side is 0, so either left moves rightward by 3(arrives at 4), or right moves rightward by 3 (arrives at 8), the imbalance amount is 3, similarly , \\'b\\' pair has an imbalance amount of 2 on two sides of the invisible center. because moving either one first will offset the imbalance amount of another by exactly 1, the total min move is 3+2-1=4, regardless we picked \\'a\\' or \\'b\\' as our first move\\n2. at every pair making step, we do not waste any swap to move both chars in the pair , we only locate the matching target to the left or right and pick one of them for our action , this guarantees minimum swaps needed\\n\\n# Code\\n```\\nclass BIT (var sz:Int) {\\n        sz+=1 // size internal Array with size+1 because BIT does not use index 0\\n        var arr:Array[Int]=Array.fill[Int](this.sz){0}\\n    def add(i:Int, v:Int) : Unit = { //note that we add the incremental change, not update !\\n        var idx=i+1\\n        while (idx<sz) {  \\n            arr(idx)+=v\\n            idx += idx & -idx\\n        }\\n    }\\n    def query(i:Int) ={\\n        var sum=0;\\n        var idx=i+1;\\n        while (idx!=0) {  \\n            sum+= arr(idx) \\n            idx -= idx & -idx\\n        }\\n        sum\\n    }\\n};\\nobject Solution {\\n    //construct palindrome using recursion, compare whether to keep left end or right end along the way\\n    def minMovesToMakePalindrome(s: String): Int = {\\n        var n=s.length\\n        if (n<=1) 0\\n        else if (s(0)==s.last) minMovesToMakePalindrome(s.slice(1,s.length-1))\\n        else {\\n            val (l,r)=(s.indexOf(s.last),s.lastIndexOf(s(0))) //(l,r) = (,) both parenthesis mandatory\\n            if (r==0) n/2+minMovesToMakePalindrome(s.substring(1))\\n            else if (l==s.size-1) n/2+minMovesToMakePalindrome(s.substring(0,s.size-1))\\n            else l + minMovesToMakePalindrome(s.slice(0,l)+s.slice(l+1,s.size-1)) //pick either l,r or mix and match all yields the same result, this is because a..b..a...b can be arranged in a.b...b.a or b.a...a.b but same minimum move. This has something to do with the number of inversions inherent in the given input eg a in (1,5) position, b in (3,8) position, as in a.b.a..b init state, then a(5)->a(8) takes 3 steps, b(3)->b(1) takes 2 steps, matching first pair moves the other pairs with the gap one step smaller 3+2-1=4 is the min moves needed\\n            //There are cases where Palindrome is made of odd number of chars. If we do not test that as above, \\n            //We can use following trick will ensure that the odd char be left unmatched until the very last recursive call\\n            //if (l<=n-1-r) l + minMovesToMakePalindrome(s.slice(0,l)+s.slice(l+1,s.size-1)) //if s(0) is odd char, r=0 && l>r => l<=n-1-r, keep the odd char at idx 0, match the right end char with idx l;\\n            //else n-1-r + minMovesToMakePalindrome(s.slice(1,r)+s.slice(r+1,s.length)) //otherwise s.last is odd char, l==s.size-1 && r<l => l>n-1-r, keep the odd char at idx s.size-1, match the left end char with idx r\\n        }\\n    }\\n\\n    def minMovesToMakePalindromeBIT(s: String): Int = {\\n        //use Fenwick Tree \\n        import scala.collection.mutable.{ArrayDeque}; //Array does not println well because it\\'s JVM Array\\n        var d=Array.fill[ArrayDeque[Int]](26){ArrayDeque[Int]()}\\n        for ( (c,i) <- s.zipWithIndex)  d(c-\\'a\\').append(i) // note (c,i) order, opposite to python\\'s enumerate(l)\\n        var res=0;\\n        val bit=new BIT(s.size);\\n        for (i <- s.length-1 to 0 by -1) {\\n            val j=s(i)-\\'a\\';\\n            if (!d(j).isEmpty) {\\n                //This statement adjusts (reduces) the swapping needed if there are already some characters whose position is ahead of (smaller than) the current position. Similarly, p/=2 is to calculate the steps needed to swap a character to the central position when there are odd number of chars in this palindrome.\\n                var p=d(j)(0)-bit.query(d(j)(0))\\n                bit.add(d(j)(0),1);\\n                if (d(j).size!=1)  d(j).dropInPlace(1) //must be InPlace!\\n                else  p /= 2; // p accounts for previous swapped chars, so p/2 is the #swaps to make it center\\n                res += p;\\n                d(j).dropRightInPlace(1)\\n            }\\n        }\\n        res\\n    }\\n    //greedy 2 using ListBuffer or ArrayBuffer, note that ListBuffer timed exceeded while ArrayBuffer not\\n    //A ListBuffer is like an array buffer except that it uses a linked list internally instead of an array. If you plan to convert the buffer to a list once it is built up, use a list buffer instead of an array buffer.\\n    def minMovesToMakePalindrome2(S: String): Int = {\\n       var res=0\\n       val s=scala.collection.mutable.ArrayBuffer.from[Char](S) //not exists collection.mutable.List\\n       var l=0\\n       var r,i=s.length-1\\n        while (l<r) {\\n            if (s(l)==s(r)) { l+=1; r-=1}\\n            else {\\n                i=s.lastIndexOf(s(l),r) // keeping left end or right end yields same number of moves, we keep left char\\n                val t=s(i)\\n                if (l==i) {\\n                    s(l)=s(l+1)\\n                    s(l+1)=t\\n                    res+=1\\n                } \\n                else {\\n                    for (k <- i until r )  s(k)=s(k+1)\\n                    res+=r-i\\n                    s(r)=t\\n                    l+=1\\n                    r-=1\\n                }\\n            }\\n        }\\n        return res\\n    }\\n    //greedy 1\\n    def minMovesToMakePalindrome1(S: String): Int = {\\n       var res=0 \\n       val s=scala.collection.mutable.ArrayBuffer.from[Char](S)\\n       while (s.size>0) {\\n           val i=s.indexOf(s.last)\\n           if (i==s.size-1) res += i/2 // only one single char allowed in each Palindrome, so i must be even\\n           else  {\\n               res += i\\n               s.remove(i)\\n           }\\n           s.remove(s.size-1)\\n       }\\n       res\\n    }\\n}\\n```\\n\\nC++ with Fenwick Tree:\\n```\\nusing namespace std;\\nclass BIT {\\npublic: \\n    BIT(int sz) {\\n        this->sz=sz+1;\\n        arr=new int[this->sz];\\n        for (int i=0; i<this->sz; ++i) *(arr+i)=0;\\n    }\\n    ~BIT() {\\n        delete[] arr;\\n    }\\n    int* arr;\\n    int sz;\\n    void add(int idx, int val) {\\n        for (++idx; idx<this->sz; idx += idx & -idx)  arr[idx]+=val;\\n    }\\n    int query(int idx) {\\n        int sum=0;\\n        for (++idx; idx; idx -= idx & -idx)  sum+= arr[idx] ;\\n        return sum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        deque<int> d[26];\\n        for (int i=0; i<s.size(); ++i) {\\n            d[s[i]-\\'a\\'].push_back(i);\\n        }\\n        int res=0;\\n        BIT bit(s.size());\\n        for (int i=s.size()-1; i>=0; --i) {\\n            int j=s[i]-\\'a\\';\\n            if (!d[j].empty()) {\\n                int p=d[j].front()-bit.query(d[j].front());\\n                bit.add(d[j].front(),1);\\n                if (d[j].size()!=1)  d[j].pop_front();\\n                else  p /= 2;\\n                res += p;\\n                d[j].pop_back();\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nclass BIT (var sz:Int) {\\n        sz+=1 // size internal Array with size+1 because BIT does not use index 0\\n        var arr:Array[Int]=Array.fill[Int](this.sz){0}\\n    def add(i:Int, v:Int) : Unit = { //note that we add the incremental change, not update !\\n        var idx=i+1\\n        while (idx<sz) {  \\n            arr(idx)+=v\\n            idx += idx & -idx\\n        }\\n    }\\n    def query(i:Int) ={\\n        var sum=0;\\n        var idx=i+1;\\n        while (idx!=0) {  \\n            sum+= arr(idx) \\n            idx -= idx & -idx\\n        }\\n        sum\\n    }\\n};\\nobject Solution {\\n    //construct palindrome using recursion, compare whether to keep left end or right end along the way\\n    def minMovesToMakePalindrome(s: String): Int = {\\n        var n=s.length\\n        if (n<=1) 0\\n        else if (s(0)==s.last) minMovesToMakePalindrome(s.slice(1,s.length-1))\\n        else {\\n            val (l,r)=(s.indexOf(s.last),s.lastIndexOf(s(0))) //(l,r) = (,) both parenthesis mandatory\\n            if (r==0) n/2+minMovesToMakePalindrome(s.substring(1))\\n            else if (l==s.size-1) n/2+minMovesToMakePalindrome(s.substring(0,s.size-1))\\n            else l + minMovesToMakePalindrome(s.slice(0,l)+s.slice(l+1,s.size-1)) //pick either l,r or mix and match all yields the same result, this is because a..b..a...b can be arranged in a.b...b.a or b.a...a.b but same minimum move. This has something to do with the number of inversions inherent in the given input eg a in (1,5) position, b in (3,8) position, as in a.b.a..b init state, then a(5)->a(8) takes 3 steps, b(3)->b(1) takes 2 steps, matching first pair moves the other pairs with the gap one step smaller 3+2-1=4 is the min moves needed\\n            //There are cases where Palindrome is made of odd number of chars. If we do not test that as above, \\n            //We can use following trick will ensure that the odd char be left unmatched until the very last recursive call\\n            //if (l<=n-1-r) l + minMovesToMakePalindrome(s.slice(0,l)+s.slice(l+1,s.size-1)) //if s(0) is odd char, r=0 && l>r => l<=n-1-r, keep the odd char at idx 0, match the right end char with idx l;\\n            //else n-1-r + minMovesToMakePalindrome(s.slice(1,r)+s.slice(r+1,s.length)) //otherwise s.last is odd char, l==s.size-1 && r<l => l>n-1-r, keep the odd char at idx s.size-1, match the left end char with idx r\\n        }\\n    }\\n\\n    def minMovesToMakePalindromeBIT(s: String): Int = {\\n        //use Fenwick Tree \\n        import scala.collection.mutable.{ArrayDeque}; //Array does not println well because it\\'s JVM Array\\n        var d=Array.fill[ArrayDeque[Int]](26){ArrayDeque[Int]()}\\n        for ( (c,i) <- s.zipWithIndex)  d(c-\\'a\\').append(i) // note (c,i) order, opposite to python\\'s enumerate(l)\\n        var res=0;\\n        val bit=new BIT(s.size);\\n        for (i <- s.length-1 to 0 by -1) {\\n            val j=s(i)-\\'a\\';\\n            if (!d(j).isEmpty) {\\n                //This statement adjusts (reduces) the swapping needed if there are already some characters whose position is ahead of (smaller than) the current position. Similarly, p/=2 is to calculate the steps needed to swap a character to the central position when there are odd number of chars in this palindrome.\\n                var p=d(j)(0)-bit.query(d(j)(0))\\n                bit.add(d(j)(0),1);\\n                if (d(j).size!=1)  d(j).dropInPlace(1) //must be InPlace!\\n                else  p /= 2; // p accounts for previous swapped chars, so p/2 is the #swaps to make it center\\n                res += p;\\n                d(j).dropRightInPlace(1)\\n            }\\n        }\\n        res\\n    }\\n    //greedy 2 using ListBuffer or ArrayBuffer, note that ListBuffer timed exceeded while ArrayBuffer not\\n    //A ListBuffer is like an array buffer except that it uses a linked list internally instead of an array. If you plan to convert the buffer to a list once it is built up, use a list buffer instead of an array buffer.\\n    def minMovesToMakePalindrome2(S: String): Int = {\\n       var res=0\\n       val s=scala.collection.mutable.ArrayBuffer.from[Char](S) //not exists collection.mutable.List\\n       var l=0\\n       var r,i=s.length-1\\n        while (l<r) {\\n            if (s(l)==s(r)) { l+=1; r-=1}\\n            else {\\n                i=s.lastIndexOf(s(l),r) // keeping left end or right end yields same number of moves, we keep left char\\n                val t=s(i)\\n                if (l==i) {\\n                    s(l)=s(l+1)\\n                    s(l+1)=t\\n                    res+=1\\n                } \\n                else {\\n                    for (k <- i until r )  s(k)=s(k+1)\\n                    res+=r-i\\n                    s(r)=t\\n                    l+=1\\n                    r-=1\\n                }\\n            }\\n        }\\n        return res\\n    }\\n    //greedy 1\\n    def minMovesToMakePalindrome1(S: String): Int = {\\n       var res=0 \\n       val s=scala.collection.mutable.ArrayBuffer.from[Char](S)\\n       while (s.size>0) {\\n           val i=s.indexOf(s.last)\\n           if (i==s.size-1) res += i/2 // only one single char allowed in each Palindrome, so i must be even\\n           else  {\\n               res += i\\n               s.remove(i)\\n           }\\n           s.remove(s.size-1)\\n       }\\n       res\\n    }\\n}\\n```\n```\\nusing namespace std;\\nclass BIT {\\npublic: \\n    BIT(int sz) {\\n        this->sz=sz+1;\\n        arr=new int[this->sz];\\n        for (int i=0; i<this->sz; ++i) *(arr+i)=0;\\n    }\\n    ~BIT() {\\n        delete[] arr;\\n    }\\n    int* arr;\\n    int sz;\\n    void add(int idx, int val) {\\n        for (++idx; idx<this->sz; idx += idx & -idx)  arr[idx]+=val;\\n    }\\n    int query(int idx) {\\n        int sum=0;\\n        for (++idx; idx; idx -= idx & -idx)  sum+= arr[idx] ;\\n        return sum;\\n    }\\n};\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        deque<int> d[26];\\n        for (int i=0; i<s.size(); ++i) {\\n            d[s[i]-\\'a\\'].push_back(i);\\n        }\\n        int res=0;\\n        BIT bit(s.size());\\n        for (int i=s.size()-1; i>=0; --i) {\\n            int j=s[i]-\\'a\\';\\n            if (!d[j].empty()) {\\n                int p=d[j].front()-bit.query(d[j].front());\\n                bit.add(d[j].front(),1);\\n                if (d[j].size()!=1)  d[j].pop_front();\\n                else  p /= 2;\\n                res += p;\\n                d[j].pop_back();\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244038,
                "title": "python-simple-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s):\\n        n = len(s)\\n\\n        if n <= 1:\\n            return 0\\n\\n        if s[0] == s[-1]:\\n            return self.minMovesToMakePalindrome(s[1:-1])\\n\\n        l, r = s.find(s[-1]), s.rfind(s[0])\\n\\n        (2,4)\\n\\n        if l <= n-1-r:\\n            return l + self.minMovesToMakePalindrome(s[:l] + s[l+1:-1])\\n        else:\\n            return n-1-r + self.minMovesToMakePalindrome(s[1:r] + s[r+1:])\\n\\n\\n\\n\\n\\n        \\n\\n        \\n\\n        \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s):\\n        n = len(s)\\n\\n        if n <= 1:\\n            return 0\\n\\n        if s[0] == s[-1]:\\n            return self.minMovesToMakePalindrome(s[1:-1])\\n\\n        l, r = s.find(s[-1]), s.rfind(s[0])\\n\\n        (2,4)\\n\\n        if l <= n-1-r:\\n            return l + self.minMovesToMakePalindrome(s[:l] + s[l+1:-1])\\n        else:\\n            return n-1-r + self.minMovesToMakePalindrome(s[1:r] + s[r+1:])\\n\\n\\n\\n\\n\\n        \\n\\n        \\n\\n        \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214766,
                "title": "java-easy-2-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust find the character for one end to other that matches and if the match is made then we need that number to move to the end. \\nIf we donot find such number we need to make it mode to middle.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse to pointer to do this .\\nThis could be also done by having greedy appreoach.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) \\n    {\\n        int strt = 0;\\n        int end = s.length()-1;\\n        int ans = 0;\\n        while(strt<end)\\n        {\\n            if(s.charAt(end) == s.charAt(strt))\\n            {\\n                strt++;\\n                end --;\\n                continue;\\n            }\\n            int r__ = end;\\n            while(s.charAt(r__) != s.charAt(strt))\\n            r__--;\\n\\n\\n            if(r__ == strt)\\n            {\\n                ans += s.length()/2 - strt;\\n                strt++;\\n            }\\n            else\\n            {\\n                ans += end - r__;\\n                while(end>r__)\\n                {\\n                    s = swap(s,r__,r__+1);\\n                    r__++;\\n                    //ans++;\\n                }\\n                strt++;\\n                end--;\\n                //swap(s,r)\\n            }\\n            //strt++;\\n\\n        }\\n        return ans ;\\n    }\\n    public String swap(String s , int i , int j)\\n    {\\n        StringBuilder sb = new StringBuilder(s);\\n    \\n        char temp = s.charAt(i);\\n        sb.setCharAt(i,s.charAt(j));\\n        sb.setCharAt(j,temp);\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) \\n    {\\n        int strt = 0;\\n        int end = s.length()-1;\\n        int ans = 0;\\n        while(strt<end)\\n        {\\n            if(s.charAt(end) == s.charAt(strt))\\n            {\\n                strt++;\\n                end --;\\n                continue;\\n            }\\n            int r__ = end;\\n            while(s.charAt(r__) != s.charAt(strt))\\n            r__--;\\n\\n\\n            if(r__ == strt)\\n            {\\n                ans += s.length()/2 - strt;\\n                strt++;\\n            }\\n            else\\n            {\\n                ans += end - r__;\\n                while(end>r__)\\n                {\\n                    s = swap(s,r__,r__+1);\\n                    r__++;\\n                    //ans++;\\n                }\\n                strt++;\\n                end--;\\n                //swap(s,r)\\n            }\\n            //strt++;\\n\\n        }\\n        return ans ;\\n    }\\n    public String swap(String s , int i , int j)\\n    {\\n        StringBuilder sb = new StringBuilder(s);\\n    \\n        char temp = s.charAt(i);\\n        sb.setCharAt(i,s.charAt(j));\\n        sb.setCharAt(j,temp);\\n        return sb.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3197767,
                "title": "python3-with-lots-of-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each letter pair, you have to move one to match the index of the other. The fastest way to do this is to only move one of the letters, starting with the one that has to move furthest. \\n\\nIf you have aaaaaaaaabb, either all the a\\'s have to move between the bs or both bs need to move to the center. This is an equivalent operation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy algorithm. Start at the outside of the onion and peel off layers\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        wild_west = list(s)\\n        moves = 0\\n        while wild_west:\\n            # index of first char that matches the last char\\n            matching_end = wild_west.index(wild_west[-1])\\n            # if end is the only one of its kind move it to centre\\n            if matching_end == len(wild_west) - 1:\\n                moves_to_middle = matching_end // 2\\n                moves += matching_end // 2\\n            else:\\n                # move first match of end to the start\\n                moves += matching_end\\n                # remove the first match\\n                wild_west.pop(matching_end)\\n                \\n            # remove the end of the list \\n            wild_west.pop()\\n\\n        return moves\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        wild_west = list(s)\\n        moves = 0\\n        while wild_west:\\n            # index of first char that matches the last char\\n            matching_end = wild_west.index(wild_west[-1])\\n            # if end is the only one of its kind move it to centre\\n            if matching_end == len(wild_west) - 1:\\n                moves_to_middle = matching_end // 2\\n                moves += matching_end // 2\\n            else:\\n                # move first match of end to the start\\n                moves += matching_end\\n                # remove the first match\\n                wild_west.pop(matching_end)\\n                \\n            # remove the end of the list \\n            wild_west.pop()\\n\\n        return moves\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178787,
                "title": "bit-solution",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nused BIT to calculate inversions\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- o(NLOGN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- o(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass BIT():\\n\\tdef __init__(self, n):\\n\\t\\tself.n = n\\n\\t\\tself.tree = [0] * (n + 1)\\n\\n\\tdef sum(self, i):\\n\\t\\tans = 0\\n\\t\\ti += 1\\n\\t\\twhile i > 0:\\n\\t\\t\\tans += self.tree[i]\\n\\t\\t\\ti -= (i & (-i))\\n\\t\\treturn ans\\n\\n\\tdef update(self, i, value):\\n\\t\\ti += 1\\n\\t\\twhile i <= self.n:\\n\\t\\t\\tself.tree[i] += value\\n\\t\\t\\ti += (i & (-i))\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        idx=defaultdict(list)\\n        n=len(s)\\n        for i in range(n):\\n            idx[s[i]].append(i)\\n        pp=[]\\n        d=[0]*n\\n        for ch,l in idx.items():\\n            if len(l)&1:\\n                d[l[len(l)//2]]=n//2\\n            for i in range(len(l)//2):\\n                pp.append((l[i],l[-i-1]))\\n        for i,(l,r) in enumerate(sorted(pp)):\\n            d[l]=i\\n            d[r]=n-i-1\\n        bt=BIT(n)\\n        ans=0 #calculate inversions\\n        for i in range(n):\\n            ans+=i-bt.sum(d[i])\\n            bt.update(d[i],1)\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass BIT():\\n\\tdef __init__(self, n):\\n\\t\\tself.n = n\\n\\t\\tself.tree = [0] * (n + 1)\\n\\n\\tdef sum(self, i):\\n\\t\\tans = 0\\n\\t\\ti += 1\\n\\t\\twhile i > 0:\\n\\t\\t\\tans += self.tree[i]\\n\\t\\t\\ti -= (i & (-i))\\n\\t\\treturn ans\\n\\n\\tdef update(self, i, value):\\n\\t\\ti += 1\\n\\t\\twhile i <= self.n:\\n\\t\\t\\tself.tree[i] += value\\n\\t\\t\\ti += (i & (-i))\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        idx=defaultdict(list)\\n        n=len(s)\\n        for i in range(n):\\n            idx[s[i]].append(i)\\n        pp=[]\\n        d=[0]*n\\n        for ch,l in idx.items():\\n            if len(l)&1:\\n                d[l[len(l)//2]]=n//2\\n            for i in range(len(l)//2):\\n                pp.append((l[i],l[-i-1]))\\n        for i,(l,r) in enumerate(sorted(pp)):\\n            d[l]=i\\n            d[r]=n-i-1\\n        bt=BIT(n)\\n        ans=0 #calculate inversions\\n        for i in range(n):\\n            ans+=i-bt.sum(d[i])\\n            bt.update(d[i],1)\\n        return ans\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165964,
                "title": "recursive-by-deleting-letters-at-left-or-right-end-that-produce-less-swaps",
                "content": "# Intuition\\nEach time swapping letters to match the end letter will produce lest swaps. But we need to decide if we want to match letters at left end or we want to swap letters at right end. Once we decide which one to match, we can delete these letters. And keep doing till we are left with no letters (even length) or 1 letter (odd length). \\n\\n\\nSpace complexity will be O(N) \\nThe recursive stack will run N/2 long since we delete 2 letters each time. \\nSpace taken by letters array is N\\n\\nTime complexity will be O(N^2). We have stack recursive fn executed N/2 times and each time it does a liner pass to delete 2 letters at the end so O(N) - Total O(N^2). \\n\\n# Code\\n```\\nclass Solution:\\n    \\n    # Check if matching left most letter will lead to less swaps or \\n    # if swapping right most letter will need to less swaps \\n    # Eg: [e]v{p}xuw[e]qo{p} \\n    # If we make move the rightmost \\'e\\' to right we need 3 swaps\\n    # If we move the left post \\'p\\' left we need 2 swaps\\n    # So we will move the p left and delete p from both ends\\n    def swapsToMatchLastLetter(self, letters):\\n        # If one letter left then it is the last letter in odd length string so no more swaps\\n        if len(letters) == 1:\\n            letters.pop()\\n            return 0\\n        # If letters at 2 ends match then we don\\'t need any swaps \\n        if letters[0] == letters[-1]:\\n            letters.pop()\\n            letters.pop(0)\\n            return 0\\n\\n        # We save left most and right most letter\\n        last_left, last_right = letters[0], letters[-1]\\n        # We set our index finding pointers to edge cases\\n        rightmost_left_letter = 1\\n        leftmost_right_letter = len(letters) - 1\\n        \\n        # Iterate string and find the first index on right for left most letter\\n        # and first index on left for right most letter\\n        for start in range(1, len(letters) - 1):\\n            if letters[start] == last_left:\\n                rightmost_left_letter = max(rightmost_left_letter, start)\\n            if letters[start] == last_right:\\n                leftmost_right_letter = min(leftmost_right_letter, start)\\n\\n        # If the index did not change from initial value then we did not find the letter\\n        left_exists = rightmost_left_letter != 0\\n        right_exists = leftmost_right_letter != len(letters) - 1\\n        # If we found a letter to swap with then num swaps makes sense else give it a high value so we ignore\\n        # this swap option\\n        swaps_to_match_left_end = (len(letters) - 1) - rightmost_left_letter if left_exists else float(\\'inf\\')\\n        swaps_to_match_right_end = leftmost_right_letter - 0 if right_exists else float(\\'inf\\')\\n\\n        # Swap the letter that will produce less swaps\\n        if swaps_to_match_left_end < swaps_to_match_right_end:\\n            letters.pop(rightmost_left_letter)\\n            letters.pop(0)\\n            return swaps_to_match_left_end\\n        else: \\n            letters.pop(leftmost_right_letter)\\n            letters.pop()\\n            return swaps_to_match_right_end\\n\\n\\n    def recursive_swaps(self, letters):\\n        if not letters:\\n            return 0\\n\\n        swaps = 0 \\n        # Find min number of swaps to match letters at the end and the delete those letters\\n        # Look at comment above. \\n        # This is a greedy approach that works because if we try to match an inner letter vs \\n        # outermost letters then we will need more swaps. Here we will need less swaps as one \\n        # letter is already at the edge (left-most or right-most)\\n        swaps += self.swapsToMatchLastLetter(letters)\\n        # Now calculate how many swaps for next remaining letters\\n        swaps += self.recursive_swaps(letters)\\n\\n        return swaps\\n\\n\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        letters = list(s)\\n        return self.recursive_swaps(letters)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # Check if matching left most letter will lead to less swaps or \\n    # if swapping right most letter will need to less swaps \\n    # Eg: [e]v{p}xuw[e]qo{p} \\n    # If we make move the rightmost \\'e\\' to right we need 3 swaps\\n    # If we move the left post \\'p\\' left we need 2 swaps\\n    # So we will move the p left and delete p from both ends\\n    def swapsToMatchLastLetter(self, letters):\\n        # If one letter left then it is the last letter in odd length string so no more swaps\\n        if len(letters) == 1:\\n            letters.pop()\\n            return 0\\n        # If letters at 2 ends match then we don\\'t need any swaps \\n        if letters[0] == letters[-1]:\\n            letters.pop()\\n            letters.pop(0)\\n            return 0\\n\\n        # We save left most and right most letter\\n        last_left, last_right = letters[0], letters[-1]\\n        # We set our index finding pointers to edge cases\\n        rightmost_left_letter = 1\\n        leftmost_right_letter = len(letters) - 1\\n        \\n        # Iterate string and find the first index on right for left most letter\\n        # and first index on left for right most letter\\n        for start in range(1, len(letters) - 1):\\n            if letters[start] == last_left:\\n                rightmost_left_letter = max(rightmost_left_letter, start)\\n            if letters[start] == last_right:\\n                leftmost_right_letter = min(leftmost_right_letter, start)\\n\\n        # If the index did not change from initial value then we did not find the letter\\n        left_exists = rightmost_left_letter != 0\\n        right_exists = leftmost_right_letter != len(letters) - 1\\n        # If we found a letter to swap with then num swaps makes sense else give it a high value so we ignore\\n        # this swap option\\n        swaps_to_match_left_end = (len(letters) - 1) - rightmost_left_letter if left_exists else float(\\'inf\\')\\n        swaps_to_match_right_end = leftmost_right_letter - 0 if right_exists else float(\\'inf\\')\\n\\n        # Swap the letter that will produce less swaps\\n        if swaps_to_match_left_end < swaps_to_match_right_end:\\n            letters.pop(rightmost_left_letter)\\n            letters.pop(0)\\n            return swaps_to_match_left_end\\n        else: \\n            letters.pop(leftmost_right_letter)\\n            letters.pop()\\n            return swaps_to_match_right_end\\n\\n\\n    def recursive_swaps(self, letters):\\n        if not letters:\\n            return 0\\n\\n        swaps = 0 \\n        # Find min number of swaps to match letters at the end and the delete those letters\\n        # Look at comment above. \\n        # This is a greedy approach that works because if we try to match an inner letter vs \\n        # outermost letters then we will need more swaps. Here we will need less swaps as one \\n        # letter is already at the edge (left-most or right-most)\\n        swaps += self.swapsToMatchLastLetter(letters)\\n        # Now calculate how many swaps for next remaining letters\\n        swaps += self.recursive_swaps(letters)\\n\\n        return swaps\\n\\n\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        letters = list(s)\\n        return self.recursive_swaps(letters)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092239,
                "title": "greedy-algo",
                "content": "# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        res = 0\\n        s = list(s)\\n        while s:\\n            last = s[-1]\\n            i = s.index(last)\\n            if i == len(s) - 1:\\n                res += i // 2\\n            else:\\n                res += i\\n                s.pop(i)\\n            s.pop()\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        res = 0\\n        s = list(s)\\n        while s:\\n            last = s[-1]\\n            i = s.index(last)\\n            if i == len(s) - 1:\\n                res += i // 2\\n            else:\\n                res += i\\n                s.pop(i)\\n            s.pop()\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047896,
                "title": "beats-98-2023-py-soln-string-slicing-approach",
                "content": "\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0 \\n        while len(s) > 2: \\n            lo = s.find(s[-1])\\n            hi = s.rfind(s[0])\\n            if lo < len(s)-hi-1: \\n                ans += lo \\n                s = s[:lo] + s[lo+1:-1]\\n            else: \\n                ans += len(s)-hi-1\\n                s = s[1:hi] + s[hi+1:]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0 \\n        while len(s) > 2: \\n            lo = s.find(s[-1])\\n            hi = s.rfind(s[0])\\n            if lo < len(s)-hi-1: \\n                ans += lo \\n                s = s[:lo] + s[lo+1:-1]\\n            else: \\n                ans += len(s)-hi-1\\n                s = s[1:hi] + s[hi+1:]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3033009,
                "title": "just-do-what-the-question-tells-you-java",
                "content": "Just do what the question tells you..\\ncheck left and right and pick the minimum one\\n\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        int left = 0, right = s.length() - 1;\\n        char[] chars = s.toCharArray();\\n        int count = 0;\\n        while(!isPalindrome(chars)){\\n            \\n            count += makeRight(chars, left++, right--); \\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    \\n    public int makeRight(char[] chars, int left, int right){\\n        \\n        char leftChar = chars[left], rightChar = chars[right];\\n        \\n        if(leftChar == rightChar) return 0;\\n        \\n        int moveRight = chars.length, moveLeft = chars.length;\\n        \\n        for(int i = right - 1; i > left; i--){\\n            \\n            if(chars[i] == leftChar){\\n                moveRight = right - i;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = left + 1; i < right; i++){\\n            if(chars[i] == rightChar){\\n                moveLeft = i - left;\\n                break;\\n            }\\n        }\\n        \\n        if(moveLeft < moveRight){\\n            swap(chars, left, moveLeft, true);\\n            return moveLeft;\\n        }else{\\n            swap(chars, right, moveRight, false);\\n            return moveRight;\\n        }\\n        \\n        \\n    }\\n    \\n    \\n    public void swap(char[] chars, int start, int steps, boolean isMovedLeft){\\n        \\n        if(isMovedLeft){\\n            for(int i = start + steps; i > start; i--){\\n                char temp = chars[i];\\n                chars[i] = chars[i - 1];\\n                chars[i - 1] = temp;\\n            }\\n        }else{\\n            for(int i = start - steps; i < start; i++){\\n                char temp = chars[i];\\n                chars[i] = chars[i + 1];\\n                chars[i + 1] = temp;\\n            }\\n        }\\n        \\n    }\\n    \\n    \\n    public boolean isPalindrome(char[] chars){\\n        \\n        int left = 0, right = chars.length-1;\\n        \\n        while(left < right){\\n            if(chars[left++] != chars[right--]) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        int left = 0, right = s.length() - 1;\\n        char[] chars = s.toCharArray();\\n        int count = 0;\\n        while(!isPalindrome(chars)){\\n            \\n            count += makeRight(chars, left++, right--); \\n        }\\n        \\n        return count;\\n        \\n    }\\n    \\n    \\n    public int makeRight(char[] chars, int left, int right){\\n        \\n        char leftChar = chars[left], rightChar = chars[right];\\n        \\n        if(leftChar == rightChar) return 0;\\n        \\n        int moveRight = chars.length, moveLeft = chars.length;\\n        \\n        for(int i = right - 1; i > left; i--){\\n            \\n            if(chars[i] == leftChar){\\n                moveRight = right - i;\\n                break;\\n            }\\n        }\\n        \\n        for(int i = left + 1; i < right; i++){\\n            if(chars[i] == rightChar){\\n                moveLeft = i - left;\\n                break;\\n            }\\n        }\\n        \\n        if(moveLeft < moveRight){\\n            swap(chars, left, moveLeft, true);\\n            return moveLeft;\\n        }else{\\n            swap(chars, right, moveRight, false);\\n            return moveRight;\\n        }\\n        \\n        \\n    }\\n    \\n    \\n    public void swap(char[] chars, int start, int steps, boolean isMovedLeft){\\n        \\n        if(isMovedLeft){\\n            for(int i = start + steps; i > start; i--){\\n                char temp = chars[i];\\n                chars[i] = chars[i - 1];\\n                chars[i - 1] = temp;\\n            }\\n        }else{\\n            for(int i = start - steps; i < start; i++){\\n                char temp = chars[i];\\n                chars[i] = chars[i + 1];\\n                chars[i + 1] = temp;\\n            }\\n        }\\n        \\n    }\\n    \\n    \\n    public boolean isPalindrome(char[] chars){\\n        \\n        int left = 0, right = chars.length-1;\\n        \\n        while(left < right){\\n            if(chars[left++] != chars[right--]) return false;\\n        }\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003940,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinMovesToMakePalindrome(string s) {\\n        List<char> strList = s.ToList();\\n\\n        int result=0;\\n        while( strList.Any())\\n        {\\n            //Find last element in list\\n            char lastElement = strList[strList.Count-1];\\n            int index = strList.FindIndex(ch=> ch== lastElement);\\n\\n            //if element match not found and it is last element\\n            //then move that element to center of string to make palindrome\\n            if(index == strList.Count -1)\\n                result += (index/2);\\n            //add i index to result and remove the item;\\n            else\\n            {\\n                result +=index;\\n                strList.RemoveAt(index);\\n            }\\n            strList.RemoveAt(strList.Count-1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinMovesToMakePalindrome(string s) {\\n        List<char> strList = s.ToList();\\n\\n        int result=0;\\n        while( strList.Any())\\n        {\\n            //Find last element in list\\n            char lastElement = strList[strList.Count-1];\\n            int index = strList.FindIndex(ch=> ch== lastElement);\\n\\n            //if element match not found and it is last element\\n            //then move that element to center of string to make palindrome\\n            if(index == strList.Count -1)\\n                result += (index/2);\\n            //add i index to result and remove the item;\\n            else\\n            {\\n                result +=index;\\n                strList.RemoveAt(index);\\n            }\\n            strList.RemoveAt(strList.Count-1);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000931,
                "title": "python-solution-is-giving-me-tle-but-same-c-doesn-t",
                "content": "\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int l=0,r=s.length()-1,ans=0;\\n        \\n        while(l<r){\\n            if(s[l]!=s[r]){\\n                int p=r;\\n                while(p>l and s[l]!=s[p])\\n                    p-=1;\\n                if(p==l){\\n                    swap(s[p],s[p+1]);\\n                    ans+=1;\\n                }\\n                else{\\n                    while(p<r){\\n                         swap(s[p],s[p+1]);\\n                        p+=1;\\n                        ans+=1;\\n                    }\\n                    l++,r--;\\n                }\\n            }\\n\\n            else{\\n                     l++,r--;\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```\\nWhat should I do now ?\\n## Py\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s,l,r=list(s),0,len(s)-1\\n        ans=0\\n        while(l<r):\\n            if(s[l]!=s[r]):\\n                p=r\\n                while(p>l and s[l]!=s[p]):\\n                    p-=1\\n                if(p==l):\\n                    s[p],s[p+1]=s[p],s[p+1]\\n                    ans+=1\\n                else:\\n                    while(p<r):\\n                        s[p],s[p+1]=s[p+1],s[p]\\n                        p+=1\\n                        ans+=1\\n                    l,r=l+1,r-1\\n            else:\\n                l,r=l+1,r-1\\n        return ans\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int l=0,r=s.length()-1,ans=0;\\n        \\n        while(l<r){\\n            if(s[l]!=s[r]){\\n                int p=r;\\n                while(p>l and s[l]!=s[p])\\n                    p-=1;\\n                if(p==l){\\n                    swap(s[p],s[p+1]);\\n                    ans+=1;\\n                }\\n                else{\\n                    while(p<r){\\n                         swap(s[p],s[p+1]);\\n                        p+=1;\\n                        ans+=1;\\n                    }\\n                    l++,r--;\\n                }\\n            }\\n\\n            else{\\n                     l++,r--;\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s,l,r=list(s),0,len(s)-1\\n        ans=0\\n        while(l<r):\\n            if(s[l]!=s[r]):\\n                p=r\\n                while(p>l and s[l]!=s[p]):\\n                    p-=1\\n                if(p==l):\\n                    s[p],s[p+1]=s[p],s[p+1]\\n                    ans+=1\\n                else:\\n                    while(p<r):\\n                        s[p],s[p+1]=s[p+1],s[p]\\n                        p+=1\\n                        ans+=1\\n                    l,r=l+1,r-1\\n            else:\\n                l,r=l+1,r-1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991116,
                "title": "full-proof-o-n-and-o-1-c-solution-with-in-depth-explaination",
                "content": "# Intuition\\nSo the intuition behind this is that, if we can make the extreme elements (first and last index elements) of the string a palindrome taking optimal moves than we can recurse the algorithm on the substring from 2nd and 2nd last index, and so on and repeating this we can find the optimal no of moves.\\n\\nBut how to find the optimal moves for the first and last elements to be palindrome. This can be done by comparing which of the elements at last and first index is better suited for being the palindromic element.\\n\\nIf first and last elements are different, say first one is a and last one is b (a........b) than the substring can become palindromic with either choosing b or a at its extreme ends. ie a.......a or b.......b (where dots indicates all the elements in between the extreme ends). So now we have 2 options either to find another a from the string and make the last element a or to find another b from the string and to make the first element b.\\n(we won\\'t move first and last elements because we want to take least moves and thus we consider that atleast one of them is already palindromic)\\n\\nWe make the greedy choice here, we choose whichever elements is closer to the extremes, ie we want b at first index, so find after how many elements is another \\'b\\' from first element (to match it with the b at the other end) and similarly find after how many elements is another \\'a\\' from last element. (to match it with the a at the first index)\\n\\nIf b is closer, bring it to the first element or if a is closer, bring it to the last element. now we have a.....a or b.....b based on the closeness of same elements from both the ends. and thus the extremes of this substring are made palindromic and now consider the inner substring and do this recursively.\\n\\n# Why this works ??\\nThis works because every time we are only bringing the similar element to the first or last index and rest all the elements are either right shifted (while bringing b to first index) or left shifted (while bringing a to last index) one space. Thus their order within the next smaller substring is not changed and we can again recurse them greedily. This would not be the case if we can move or swap any number with any other number, in that case the effect of swapping inner elements before choosing greedily would be different than after choosing greedily.\\n\\n# Walk through an example \\ns = lleett\\nso the extreme elements are l and t at index 0 and 5.\\nthus finding the no of elements between 0 and next t, which is 3 and between index 5 and l is also 3. so we can make any one either l or t as the extreme elements in palindromic substring. we choose to make l as last element too.\\ns = l(eett)l \\n(we can see clearly here that the numbers between the extremes are just shifted to left side by 1 space and thier inner order has not changed.)\\nnow considering the substring eett\\nboth again have same distance from both ends, ie other t is 1 element away from first e and vice versa. we can again choose to move any one here.\\nthus s = l(e(tt)e)l\\nthus s is converted to a palindromic substring. and the swaps it takes is, distance swapped in pass one (ie 3)+1 and distance swapped in pass 2 (ie 1) + 1 = (3+1)+(1+1)=6.\\n\\ni hope you understood it, if yes than please upvote it.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\nwe can write this code recursively too it would be far better for understanding, so you can write it yourself to check your understanding of the problem, we have written if iteratively because it takes less space.\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int left=0;\\n        int right=n-1;\\n        int count=0;\\n        int mid=n/2;\\n        for(int i=0;i<n/2;i++)\\n        {\\n            char a=s[left];\\n            char b=s[right];\\n//finding the closest duplicate and swapping.\\n            if(a!=b)\\n            {\\n                int count1=0;\\n                for(int j=left+1;j<right;j++)\\n                {\\n                    if(s[j]!=b)\\n                    {\\n                        count1+=1;\\n                    }\\n                    else break;\\n                }\\n                int count2=0;\\n                for(int j=right-1;j>left;j--)\\n                {\\n                    if(s[j]!=a)\\n                    {\\n                        count2+=1;\\n                    }\\n                    else break;\\n                }\\n                if(count1>count2) //means that duplicate of a is\\n                //closer to right index of our window.\\n                {\\n                    //now we will swap that duplicate till it reaches \\n                    //till it reaches the right\\'th index.\\n                    int k=right-count2-1;\\n//k stores the index of that duplicate no.\\n                    count+=count2+1;\\n                    while(k<right)\\n                    {\\n                        swap(s[k],s[k+1]);\\n                        k++;\\n                    }\\n                }\\n                else \\n                {\\n//else either both have same distance or b is closer to left index,\\n//in which case, we will swap it, till it reaches left\\'th index\\n                    int k=count1+1+left;\\n//k stores the index of that duplicate no.\\n                    count+=count1+1;\\n                    while(k>left)\\n                    {\\n                        swap(s[k],s[k-1]);\\n                        k--;\\n                    }\\n                }\\n\\n            }\\n//decreasing the size of the subarray.\\n            left+=1;\\n            right-=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int left=0;\\n        int right=n-1;\\n        int count=0;\\n        int mid=n/2;\\n        for(int i=0;i<n/2;i++)\\n        {\\n            char a=s[left];\\n            char b=s[right];\\n//finding the closest duplicate and swapping.\\n            if(a!=b)\\n            {\\n                int count1=0;\\n                for(int j=left+1;j<right;j++)\\n                {\\n                    if(s[j]!=b)\\n                    {\\n                        count1+=1;\\n                    }\\n                    else break;\\n                }\\n                int count2=0;\\n                for(int j=right-1;j>left;j--)\\n                {\\n                    if(s[j]!=a)\\n                    {\\n                        count2+=1;\\n                    }\\n                    else break;\\n                }\\n                if(count1>count2) //means that duplicate of a is\\n                //closer to right index of our window.\\n                {\\n                    //now we will swap that duplicate till it reaches \\n                    //till it reaches the right\\'th index.\\n                    int k=right-count2-1;\\n//k stores the index of that duplicate no.\\n                    count+=count2+1;\\n                    while(k<right)\\n                    {\\n                        swap(s[k],s[k+1]);\\n                        k++;\\n                    }\\n                }\\n                else \\n                {\\n//else either both have same distance or b is closer to left index,\\n//in which case, we will swap it, till it reaches left\\'th index\\n                    int k=count1+1+left;\\n//k stores the index of that duplicate no.\\n                    count+=count1+1;\\n                    while(k>left)\\n                    {\\n                        swap(s[k],s[k-1]);\\n                        k--;\\n                    }\\n                }\\n\\n            }\\n//decreasing the size of the subarray.\\n            left+=1;\\n            right-=1;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981753,
                "title": "python-sliding-window-48-time-61-space",
                "content": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        output = 0\\n        l, r = 0, len(s) - 1\\n\\n        while l < r:\\n            if s[l] != s[r]:\\n                left, right = s[l], s[r]\\n                swap = None\\n                # Find string to match with left boundary\\n                for i in range(l + 1, r):\\n                    if s[i] == right:\\n                        swap = i\\n                        break\\n                # Find string to match with right boundary\\n                for j in range(r - 1, l, -1):\\n                    if s[j] == left and (not swap or swap - l > r - j):\\n                        swap = -j\\n                        break\\n                # If swapping with left boundary\\n                if swap >= 0:\\n                    s = s[0:l] + s[swap] + s[l:swap] + s[swap + 1:]\\n                    output += swap - l\\n                # Else swap with right boundary\\n                else:\\n                    swap = -swap\\n                    s = s[0:swap] + s[swap + 1:r + 1] + s[swap] + s[r + 1:]\\n                    output += r - (swap)\\n            l += 1\\n            r -= 1\\n\\n        return output\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        output = 0\\n        l, r = 0, len(s) - 1\\n\\n        while l < r:\\n            if s[l] != s[r]:\\n                left, right = s[l], s[r]\\n                swap = None\\n                # Find string to match with left boundary\\n                for i in range(l + 1, r):\\n                    if s[i] == right:\\n                        swap = i\\n                        break\\n                # Find string to match with right boundary\\n                for j in range(r - 1, l, -1):\\n                    if s[j] == left and (not swap or swap - l > r - j):\\n                        swap = -j\\n                        break\\n                # If swapping with left boundary\\n                if swap >= 0:\\n                    s = s[0:l] + s[swap] + s[l:swap] + s[swap + 1:]\\n                    output += swap - l\\n                # Else swap with right boundary\\n                else:\\n                    swap = -swap\\n                    s = s[0:swap] + s[swap + 1:r + 1] + s[swap] + s[r + 1:]\\n                    output += r - (swap)\\n            l += 1\\n            r -= 1\\n\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892996,
                "title": "proof-of-correctness",
                "content": "https://leetcode.com/problems/minimum-number-of-moves-to-make-palindrome/solutions/1847011/c-2-pointers-with-detail-proof-and-explanation/ gives a fantastic explanation of correctness, complete with beautiful visuals. In this post I provide a mathematical explanation to complement it.\\n\\nLet\\'s discuss the case where $n$ is even for simplicity.\\n\\nWithout loss of generality, we may assume that the characters in the string are distinct. It is obviously never optimal to swap two identical characters, so the relative ordering of identical characters remains unchanged throughout the algorithm. Therefore, we can replace all subsequences like \"a...a..a...a...a....a\" with \"a1...a2..a3...a3...a2....a1\". Let\\'s call the characters \"a\", \"b\", \"c\", ..., for simplicity.\\n\\nAdditionally, we may assume without loss of generality that the final string constructed by our algorithm is \"abc...cba\" by renaming characters  in the final output.\\n\\nCall a *lefty* a tuple $(i, j, k)$ with $0 \\\\le i < j \\\\le k < n / 2$ and $s[i] = s[j]$. Call a *nonversion* a quadruple $(i, j, k, \\\\ell)$ with $0 \\\\le i < j < n/2$, $n/2 \\\\le k < \\\\ell < n$, and $(s[i], s[j]) = (s[k], s[\\\\ell])$. Call the *skew* of a string $s$ the sum of the number of leftys in $s$ and the number of nonversions in $s$.\\n\\nNote that the skew of a palindromic string is zero and that a swap may decrease the skew of a string by at most one, as a swap may eliminate at most one lefty and at most one nonversion, but cannot do so simultaneously. Therefore, it suffices to show that every operation in our algorithm decreases the number of nonversions by one.\\n\\nConsider some stage in the execution of our algorithm, for example:\\n\\n```\\n\"\"\"\\nabcfed|cfedba\\n  |\\n  | Suppose we are on c.\\n\\nWe will make the following series of swaps:\\n\\n    abcfed|cfedba\\n--> abcfed|fcedba\\n--> abcfed|fecdba\\n--> abcfed|fcdcba\\n\"\"\"\\n```\\n\\nDenote by $c$ the character that we are currently swapping. By construction of the algorithm, we will always swap the right instance of $c$ with some lexicographically greater character $d$. The relative ordering of $c$s and $d$s must transform either via $(c_1, c_2, d_1, d_2) \\\\rightsquigarrow (c_1, d_1, c_2, d_2)$ or via $(c_1, d_1, c_2, d_2) \\\\rightsquigarrow (c_1, d_1, d_2, c_2)$. In the former case, the lefty $(c_1, c_2, c_2)$ is eliminated, and in the latter case, the nonversion $(c_1, d_1, c_2, d_2)$ is eliminated. In both cases, the skew of the string decreases by one.\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"\"\"\\nabcfed|cfedba\\n  |\\n  | Suppose we are on c.\\n\\nWe will make the following series of swaps:\\n\\n    abcfed|cfedba\\n--> abcfed|fcedba\\n--> abcfed|fecdba\\n--> abcfed|fcdcba\\n\"\"\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2819524,
                "title": "c-two-pointers",
                "content": "```\\nclass Solution {\\nprivate:\\n    void swap(string& s, int i, int j){\\n        char t = s[i];\\n        s[i] = s[j];\\n        s[j] = t;\\n    }\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ans = 0, l = 0, r = s.size() - 1;\\n        \\n        while(l < r){\\n            if(s[l] == s[r]){\\n                l++; r--;\\n                continue;\\n            }\\n            \\n            int r_ = r;\\n            while(s[r_] != s[l]){\\n                r_--;\\n            }\\n\\n            if(r_ == l){\\n                ans +=  s.size() / 2 - l;\\n                l++;\\n            }else{\\n                ans += r - r_;\\n                while(r_ < r){\\n                    swap(s, r_, r_ + 1);\\n                    r_++;\\n                }\\n                l++; r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void swap(string& s, int i, int j){\\n        char t = s[i];\\n        s[i] = s[j];\\n        s[j] = t;\\n    }\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int ans = 0, l = 0, r = s.size() - 1;\\n        \\n        while(l < r){\\n            if(s[l] == s[r]){\\n                l++; r--;\\n                continue;\\n            }\\n            \\n            int r_ = r;\\n            while(s[r_] != s[l]){\\n                r_--;\\n            }\\n\\n            if(r_ == l){\\n                ans +=  s.size() / 2 - l;\\n                l++;\\n            }else{\\n                ans += r - r_;\\n                while(r_ < r){\\n                    swap(s, r_, r_ + 1);\\n                    r_++;\\n                }\\n                l++; r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800512,
                "title": "easy-to-understand-2-pointer-solution",
                "content": "# Intuition\\nStart on the outer corners, moving in from left and right, and do the min swaps needed to make them the same.\\n\\n# Approach\\nAt each iteration we find the number of swaps needed to make s[i] == s[j] from the right and from the left. Then we simply do our swaps from the side requiring the least.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \\'\\'\\'\\n            Intuition: Start on the outer corners, moving in from left and right, and do min swaps to make them the same.\\n\\n            Spacetime: O(n)\\n            Runtime: O(n^2)\\n        \\'\\'\\'\\n\\n        i, j = 0, len(s) - 1\\n        sArr = list(s)\\n        swaps = 0\\n\\n        while i < j:\\n            if sArr[i] != sArr[j]:\\n                minSwapsI = math.inf # min swaps needed to get i the same as position j\\n                minSwapsJ = math.inf\\n\\n                # get min swaps needed to make pos i == pos j\\n                for k in range(i+1,j):\\n                    if sArr[k] == sArr[j]:\\n                        minSwapsI = k - i\\n                        break\\n\\n                # get min swaps needed to make pos j == pos i\\n                for k in range(j-1, i, -1):\\n                    if sArr[k] == sArr[i]:\\n                        minSwapsJ = j - k\\n                        break\\n                \\n                # make min swaps needed\\n                if minSwapsI < minSwapsJ:\\n                    for k in range(i + minSwapsI, i, -1):\\n                        sArr[k-1], sArr[k] = sArr[k], sArr[k-1]\\n                else:\\n                    for k in range(j - minSwapsJ, j):\\n                        sArr[k+1], sArr[k] = sArr[k], sArr[k+1]\\n                \\n                swaps += min(minSwapsI, minSwapsJ) # update swap count\\n\\n            # update pointers\\n            i += 1\\n            j -= 1\\n\\n        return swaps\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \\'\\'\\'\\n            Intuition: Start on the outer corners, moving in from left and right, and do min swaps to make them the same.\\n\\n            Spacetime: O(n)\\n            Runtime: O(n^2)\\n        \\'\\'\\'\\n\\n        i, j = 0, len(s) - 1\\n        sArr = list(s)\\n        swaps = 0\\n\\n        while i < j:\\n            if sArr[i] != sArr[j]:\\n                minSwapsI = math.inf # min swaps needed to get i the same as position j\\n                minSwapsJ = math.inf\\n\\n                # get min swaps needed to make pos i == pos j\\n                for k in range(i+1,j):\\n                    if sArr[k] == sArr[j]:\\n                        minSwapsI = k - i\\n                        break\\n\\n                # get min swaps needed to make pos j == pos i\\n                for k in range(j-1, i, -1):\\n                    if sArr[k] == sArr[i]:\\n                        minSwapsJ = j - k\\n                        break\\n                \\n                # make min swaps needed\\n                if minSwapsI < minSwapsJ:\\n                    for k in range(i + minSwapsI, i, -1):\\n                        sArr[k-1], sArr[k] = sArr[k], sArr[k-1]\\n                else:\\n                    for k in range(j - minSwapsJ, j):\\n                        sArr[k+1], sArr[k] = sArr[k], sArr[k+1]\\n                \\n                swaps += min(minSwapsI, minSwapsJ) # update swap count\\n\\n            # update pointers\\n            i += 1\\n            j -= 1\\n\\n        return swaps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759000,
                "title": "c-solution-greedy",
                "content": "```\\nint minMovesToMakePalindrome(char * s){\\n    int len = strlen(s), minMoves = 0, idx = 0;\\n\\n    while(len > 0) {\\n        char  *ret = strchr(s, s[len - 1]);\\n        int pos = ret - s;\\n    \\n        if(pos == len - 1) {\\n            minMoves += pos / 2;\\n        } else {\\n            minMoves += pos;\\n            memmove(&s[pos], &s[pos+1], len - pos);     // remove the matched char from string\\n            -- len;\\n        }\\n        \\n        if(len > 0)                                     // remove the last char from string\\n            s[len-1] = \\'\\\\0\\';\\n        --len;    \\n    }\\n    return minMoves;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint minMovesToMakePalindrome(char * s){\\n    int len = strlen(s), minMoves = 0, idx = 0;\\n\\n    while(len > 0) {\\n        char  *ret = strchr(s, s[len - 1]);\\n        int pos = ret - s;\\n    \\n        if(pos == len - 1) {\\n            minMoves += pos / 2;\\n        } else {\\n            minMoves += pos;\\n            memmove(&s[pos], &s[pos+1], len - pos);     // remove the matched char from string\\n            -- len;\\n        }\\n        \\n        if(len > 0)                                     // remove the last char from string\\n            s[len-1] = \\'\\\\0\\';\\n        --len;    \\n    }\\n    return minMoves;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2727642,
                "title": "java-o-n-2",
                "content": "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int len = s.length();\\n        int ans = 0;\\n        for(int i=0; i<len/2; i++){\\n            int j = s.length()-1;\\n            int count = 0;\\n            while(s.charAt(j) != s.charAt(0)){\\n                j--;\\n                count++;\\n            }\\n            if(j==0){\\n                s = s.substring(1);\\n                ans += (s.length()/2);\\n            }\\n            else{\\n               s = s.substring(1, j)+s.substring(j+1);\\n               ans += count;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int len = s.length();\\n        int ans = 0;\\n        for(int i=0; i<len/2; i++){\\n            int j = s.length()-1;\\n            int count = 0;\\n            while(s.charAt(j) != s.charAt(0)){\\n                j--;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2702477,
                "title": "two-pointers-chararray",
                "content": "# Intuition\\nTraverse an array of chars, swaping them until they match in pairs.\\n\\n# Approach\\nThe array is traversed until the first pointer is equal to the lenght. The first pointer will be increased only when the chars of the two pointers are the same.\\nWhile traversing, the chars in the index pointers are compared and the different ones are swaped by the rightmost one.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n\\n# Code\\n```\\npublic class Solution {\\n\\npublic int MinMovesToMakePalindrome(String s)\\n        {\\n            var ans = 0;\\n            var firstPointer = 0;\\n            var end = s.Length - 1;\\n            char[] ch = s.ToCharArray();\\n\\n            //Do not even start to make swaps\\n            if (CanFormPalindrome(s) == false) \\n                return -1;\\n\\n            while (firstPointer < end)\\n            {\\n                var secondPointer = end;\\n                if (ch[firstPointer] == ch[end])\\n                {\\n                    firstPointer++; // first char will remain in the same index, so it will be ignored \\n                    end--; // last char will remain in the same index so it will be ignored \\n\\n                    continue;\\n                }\\n\\n                while (ch[firstPointer] != ch[secondPointer])\\n                {\\n                    secondPointer--; //decreasing until find the same chars between the two pointers\\n                }\\n\\n\\n                if (firstPointer == secondPointer) //If both reach the same index, swap the chars so it never get stucked in a infinite loop\\n                {\\n                    Swap(ch, secondPointer, secondPointer + 1); // Change one char with the rightmost one\\n                    ans++;\\n                }\\n                else\\n                {\\n                    while (secondPointer < end)\\n                    {\\n                        Swap(ch, secondPointer, secondPointer + 1); // Change one char with the rightmost one\\n                        ans++;\\n                        secondPointer++;\\n                    }\\n                }\\n            }\\n\\n\\n            return ans;\\n        }\\n\\n        static void Swap(char[] ch, int i, int j)\\n        {\\n            var temp = ch[i];\\n            ch[i] = ch[j];\\n            ch[j] = temp;\\n        }\\n\\n        static bool CanFormPalindrome(string str)\\n        {\\n            int NO_OF_CHARS = 256;\\n\\n            // Create a count array and initialize all\\n            // values as 0\\n            int[] count = new int[NO_OF_CHARS];\\n            Array.Fill(count, 0);\\n\\n            // For each character in input strings,\\n            // increment count in the corresponding\\n            // count array\\n            for (int i = 0; i < str.Length; i++)\\n            {\\n                count[(int)(str[i])]++;\\n            }\\n\\n            // Count odd occurring characters\\n            int odd = 0;\\n            for (int i = 0; i < NO_OF_CHARS; i++)\\n            {\\n                if ((count[i] & 1) == 1)\\n                    odd++;\\n\\n                if (odd > 1)\\n                    return false;\\n            }\\n\\n            // Return true if odd count is 0 or 1,\\n            return true;\\n        }\\n        \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n\\npublic int MinMovesToMakePalindrome(String s)\\n        {\\n            var ans = 0;\\n            var firstPointer = 0;\\n            var end = s.Length - 1;\\n            char[] ch = s.ToCharArray();\\n\\n            //Do not even start to make swaps\\n            if (CanFormPalindrome(s) == false) \\n                return -1;\\n\\n            while (firstPointer < end)\\n            {\\n                var secondPointer = end;\\n                if (ch[firstPointer] == ch[end])\\n                {\\n                    firstPointer++; // first char will remain in the same index, so it will be ignored \\n                    end--; // last char will remain in the same index so it will be ignored \\n\\n                    continue;\\n                }\\n\\n                while (ch[firstPointer] != ch[secondPointer])\\n                {\\n                    secondPointer--; //decreasing until find the same chars between the two pointers\\n                }\\n\\n\\n                if (firstPointer == secondPointer) //If both reach the same index, swap the chars so it never get stucked in a infinite loop\\n                {\\n                    Swap(ch, secondPointer, secondPointer + 1); // Change one char with the rightmost one\\n                    ans++;\\n                }\\n                else\\n                {\\n                    while (secondPointer < end)\\n                    {\\n                        Swap(ch, secondPointer, secondPointer + 1); // Change one char with the rightmost one\\n                        ans++;\\n                        secondPointer++;\\n                    }\\n                }\\n            }\\n\\n\\n            return ans;\\n        }\\n\\n        static void Swap(char[] ch, int i, int j)\\n        {\\n            var temp = ch[i];\\n            ch[i] = ch[j];\\n            ch[j] = temp;\\n        }\\n\\n        static bool CanFormPalindrome(string str)\\n        {\\n            int NO_OF_CHARS = 256;\\n\\n            // Create a count array and initialize all\\n            // values as 0\\n            int[] count = new int[NO_OF_CHARS];\\n            Array.Fill(count, 0);\\n\\n            // For each character in input strings,\\n            // increment count in the corresponding\\n            // count array\\n            for (int i = 0; i < str.Length; i++)\\n            {\\n                count[(int)(str[i])]++;\\n            }\\n\\n            // Count odd occurring characters\\n            int odd = 0;\\n            for (int i = 0; i < NO_OF_CHARS; i++)\\n            {\\n                if ((count[i] & 1) == 1)\\n                    odd++;\\n\\n                if (odd > 1)\\n                    return false;\\n            }\\n\\n            // Return true if odd count is 0 or 1,\\n            return true;\\n        }\\n        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689790,
                "title": "python3-two-pointer-greedy-approach",
                "content": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n=len(s)\\n        left,right=0,n-1\\n        ans=0\\n        while left<=right:\\n            if s[left]!=s[right]:\\n                ind1=right\\n                while left<=ind1 and s[ind1]!=s[left]:\\n                    ind1-=1\\n                ind2=left\\n                while right>=ind2 and s[ind2]!=s[right]:\\n                    ind2+=1\\n                leftShift=right-ind1\\n                rightShift=ind2-left\\n                if leftShift<=rightShift:\\n                    s=s[:ind1]+s[ind1+1:right+1]+s[ind1]+s[right+1:]\\n                    ans+=leftShift\\n                else:\\n                    s=s[:left]+s[ind2]+s[left:ind2]+s[ind2+1:]\\n                    ans+=rightShift\\n            left+=1\\n            right-=1\\n        return ans\\n            \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n=len(s)\\n        left,right=0,n-1\\n        ans=0\\n        while left<=right:\\n            if s[left]!=s[right]:\\n                ind1=right\\n                while left<=ind1 and s[ind1]!=s[left]:\\n                    ind1-=1\\n                ind2=left\\n                while right>=ind2 and s[ind2]!=s[right]:\\n                    ind2+=1\\n                leftShift=right-ind1\\n                rightShift=ind2-left\\n                if leftShift<=rightShift:\\n                    s=s[:ind1]+s[ind1+1:right+1]+s[ind1]+s[right+1:]\\n                    ans+=leftShift\\n                else:\\n                    s=s[:left]+s[ind2]+s[left:ind2]+s[ind2+1:]\\n                    ans+=rightShift\\n            left+=1\\n            right-=1\\n        return ans\\n            \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668217,
                "title": "javascript-2-pointer-like-bubble-sort",
                "content": "```\\nvar minMovesToMakePalindrome = function(str) {\\n  if (str.length < 2) return 0;\\n  \\n  const s = str.split(\\'\\'), mid = Math.floor(str.length / 2);\\n  let l = 0, r = s.length - 1, res = 0, midMisplacedIdx = -1;\\n  \\n  while (l < r) {\\n    if (s[l] !== s[r]) {\\n      // Here we need swapping as both the chars are not equal\\n      // We start from the right at position (r - 1) till (l + 1) to find a match for s[l]\\n\\t  // We need the value of i after the loop ends, so not assigning it within the loop initiation\\n      let i = r - 1;\\n      for (; i > l; i--) {\\n        if (s[l] === s[i]) {\\n          bubbleUp(s, i, r);\\n          res += (r - i);\\n          break;\\n        }\\n      }\\n      \\n      // If no match is found till s[l], we know that this is the mid value for an odd lengthed palindrome\\n      // Since mid remains unique in odd lengthed palindrome, we store its index for future,\\n      // skip working on s[l] and continue to the next iteration (here we\\'re also avoiding making any change to r)\\n      if (i === l) {\\n        midMisplacedIdx = l;\\n        l++;\\n        continue;\\n      }\\n    }\\n    \\n    l++;\\n    r--;\\n  }\\n  \\n  // At the end, we move s[midMisplacedIdx] to mid and compute the swap count as (mid - l)\\n  // We don\\'t have to swap here as we\\'re only interested in the count\\n  if (midMisplacedIdx >= 0 && midMisplacedIdx < mid) {\\n    bubbleUp(s, midMisplacedIdx, mid); // can be skipped\\n    res += (mid - midMisplacedIdx);\\n  }\\n  \\n  return res;\\n};\\n\\n// Better call it sifting or bubbling to the right but the question calls this swap\\n// We\\'re basically bubbling an item from one index to the other towards its right\\nfunction bubbleUp(arr, from, to) {\\n  for (let i = from; i < to; i++) {\\n    [arr[i],arr[i + 1]] = [arr[i + 1],arr[i]];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nvar minMovesToMakePalindrome = function(str) {\\n  if (str.length < 2) return 0;\\n  \\n  const s = str.split(\\'\\'), mid = Math.floor(str.length / 2);\\n  let l = 0, r = s.length - 1, res = 0, midMisplacedIdx = -1;\\n  \\n  while (l < r) {\\n    if (s[l] !== s[r]) {\\n      // Here we need swapping as both the chars are not equal\\n      // We start from the right at position (r - 1) till (l + 1) to find a match for s[l]\\n\\t  // We need the value of i after the loop ends, so not assigning it within the loop initiation\\n      let i = r - 1;\\n      for (; i > l; i--) {\\n        if (s[l] === s[i]) {\\n          bubbleUp(s, i, r);\\n          res += (r - i);\\n          break;\\n        }\\n      }\\n      \\n      // If no match is found till s[l], we know that this is the mid value for an odd lengthed palindrome\\n      // Since mid remains unique in odd lengthed palindrome, we store its index for future,\\n      // skip working on s[l] and continue to the next iteration (here we\\'re also avoiding making any change to r)\\n      if (i === l) {\\n        midMisplacedIdx = l;\\n        l++;\\n        continue;\\n      }\\n    }\\n    \\n    l++;\\n    r--;\\n  }\\n  \\n  // At the end, we move s[midMisplacedIdx] to mid and compute the swap count as (mid - l)\\n  // We don\\'t have to swap here as we\\'re only interested in the count\\n  if (midMisplacedIdx >= 0 && midMisplacedIdx < mid) {\\n    bubbleUp(s, midMisplacedIdx, mid); // can be skipped\\n    res += (mid - midMisplacedIdx);\\n  }\\n  \\n  return res;\\n};\\n\\n// Better call it sifting or bubbling to the right but the question calls this swap\\n// We\\'re basically bubbling an item from one index to the other towards its right\\nfunction bubbleUp(arr, from, to) {\\n  for (let i = from; i < to; i++) {\\n    [arr[i],arr[i + 1]] = [arr[i + 1],arr[i]];\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2662747,
                "title": "java-solution-using-string-builder",
                "content": "```\\n    public int minMovesToMakePalindrome(String s) {\\n        int result = 0;\\n\\n        // using stringbuilder to be efficient. \\n        StringBuilder sb = new StringBuilder(s);\\n\\n        int end = sb.length() - 1;\\n\\n        while(end > 0){\\n            char lastChar = sb.charAt(end);\\n\\n            // finding the first index of the last char\\n            int firstIdx = sb.indexOf(String.valueOf(lastChar));\\n\\n            // if the last char appears only once we need to move it to the middle of the string.\\n            if(firstIdx == end){\\n                result += end / 2;\\n            }\\n            // else it should be move to the begining of the string to become palindrome.\\n            else{\\n                result += firstIdx;\\n            }\\n\\n            // removing the end char to consider next char. \\n            sb.deleteCharAt(end);\\n\\n            // if char appears more than once then remove the first index.\\n            if(firstIdx != end){\\n                end--;\\n                sb.deleteCharAt(firstIdx);\\n            }\\n\\n            end--;\\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int minMovesToMakePalindrome(String s) {\\n        int result = 0;\\n\\n        // using stringbuilder to be efficient. \\n        StringBuilder sb = new StringBuilder(s);\\n\\n        int end = sb.length() - 1;\\n\\n        while(end > 0){\\n            char lastChar = sb.charAt(end);\\n\\n            // finding the first index of the last char\\n            int firstIdx = sb.indexOf(String.valueOf(lastChar));\\n\\n            // if the last char appears only once we need to move it to the middle of the string.\\n            if(firstIdx == end){\\n                result += end / 2;\\n            }\\n            // else it should be move to the begining of the string to become palindrome.\\n            else{\\n                result += firstIdx;\\n            }\\n\\n            // removing the end char to consider next char. \\n            sb.deleteCharAt(end);\\n\\n            // if char appears more than once then remove the first index.\\n            if(firstIdx != end){\\n                end--;\\n                sb.deleteCharAt(firstIdx);\\n            }\\n\\n            end--;\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2643335,
                "title": "java-easy-it-depends-on-you",
                "content": "```\\nclass Solution {\\n  public static void swap(char arr[],int i,int j){\\n        \\n        char temp=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=temp;\\n    }\\n    public int minMovesToMakePalindrome(String s) {\\n        int ans=0;\\n        char strarr[]=s.toCharArray();\\n        int i=0; \\n        int j=strarr.length-1;\\n        while(i<j){\\n            int r=j;\\n            if(strarr[i]==strarr[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                while(strarr[i]!=strarr[r]){\\n                    r--;\\n                }\\n                \\n                if(i==r){\\n                   swap(strarr,r,r+1);\\n                   ans++;\\n                   continue;\\n                 }               \\n                else{\\n                 while(r<j){  \\n                    swap(strarr,r,r+1);\\n                    ans++;\\n                    r++;\\n                }\\n              }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public static void swap(char arr[],int i,int j){\\n        \\n        char temp=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=temp;\\n    }\\n    public int minMovesToMakePalindrome(String s) {\\n        int ans=0;\\n        char strarr[]=s.toCharArray();\\n        int i=0; \\n        int j=strarr.length-1;\\n        while(i<j){\\n            int r=j;\\n            if(strarr[i]==strarr[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                while(strarr[i]!=strarr[r]){\\n                    r--;\\n                }\\n                \\n                if(i==r){\\n                   swap(strarr,r,r+1);\\n                   ans++;\\n                   continue;\\n                 }               \\n                else{\\n                 while(r<j){  \\n                    swap(strarr,r,r+1);\\n                    ans++;\\n                    r++;\\n                }\\n              }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2616060,
                "title": "simple-java-solution-with-explanation-greedy-with-simulation",
                "content": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] arr = s.toCharArray();\\n        int count = 0, rightLimit = arr.length - 1, oddIndex = -1;\\n        // simulation: for avery element in the string find the nearest right-most compliment \\n        // and make the extremeties a palindrome like : b[a]......[a]...b -> ba.........ab\\n        // continue inwards until you reach the centre of the string\\n        for (int left = 0; left < arr.length / 2; left++) {\\n            // assume that the current character is single occuring character\\n            oddIndex = (oddIndex == -1 ? left : oddIndex); \\n            for (int right = rightLimit; right > left; right--) {\\n                if (arr[right] == arr[left]) {\\n                    // refute assumption that the current character is single occuring character\\n                    oddIndex = (oddIndex == left ? -1 : oddIndex);\\n                    // swap current right counterpart to make extremes palindrome\\n                    // count the number of swaps required in the process and add to answer\\n                    count += swapChars(arr, right, rightLimit);\\n                    // reduce the right limit, this implies (rightLimit - endOfString] is now a palindrome\\n                    rightLimit--;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if (oddIndex != -1) {\\n            // if the oddIndex has a non-negative value\\n            // swap it to the centre of the string and account for those swaps\\n            count += swapChars(arr, oddIndex, arr.length / 2);\\n        }\\n        return count;\\n    }\\n    \\n    // simulate swapping, move 1 character each to the left in the given range\\n    // and then replace the final character with the first character\\n    int swapChars(char[] arr, int left, int right) {\\n        char temp = arr[left];\\n        for (int i = left; i < right; i++) arr[i] = arr[i + 1];\\n        arr[right] = temp;\\n        return right - left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] arr = s.toCharArray();\\n        int count = 0, rightLimit = arr.length - 1, oddIndex = -1;\\n        // simulation: for avery element in the string find the nearest right-most compliment \\n        // and make the extremeties a palindrome like : b[a]......[a]...b -> ba.........ab\\n        // continue inwards until you reach the centre of the string\\n        for (int left = 0; left < arr.length / 2; left++) {\\n            // assume that the current character is single occuring character\\n            oddIndex = (oddIndex == -1 ? left : oddIndex); \\n            for (int right = rightLimit; right > left; right--) {\\n                if (arr[right] == arr[left]) {\\n                    // refute assumption that the current character is single occuring character\\n                    oddIndex = (oddIndex == left ? -1 : oddIndex);\\n                    // swap current right counterpart to make extremes palindrome\\n                    // count the number of swaps required in the process and add to answer\\n                    count += swapChars(arr, right, rightLimit);\\n                    // reduce the right limit, this implies (rightLimit - endOfString] is now a palindrome\\n                    rightLimit--;\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        if (oddIndex != -1) {\\n            // if the oddIndex has a non-negative value\\n            // swap it to the centre of the string and account for those swaps\\n            count += swapChars(arr, oddIndex, arr.length / 2);\\n        }\\n        return count;\\n    }\\n    \\n    // simulate swapping, move 1 character each to the left in the given range\\n    // and then replace the final character with the first character\\n    int swapChars(char[] arr, int left, int right) {\\n        char temp = arr[left];\\n        for (int i = left; i < right; i++) arr[i] = arr[i + 1];\\n        arr[right] = temp;\\n        return right - left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607435,
                "title": "python-o-nlogn-by-counting-inversions-in-a-permutation",
                "content": "Enumerate all characters of the string and represent target palindrome as permutation of indices of characters of the original string. Number of moves is going to be equal then to the number of inversions in the permutation (See [Permutation Inversion](https://mathworld.wolfram.com/PermutationInversion.html))\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \\n        # Calculate the permutation\\n        \\n        count = Counter(s)\\n        p = []\\n        v = [-1] * len(s) # List v will represent the permutation\\n        j = 0\\n        for i, c in enumerate(s):\\n            if count[c] > 1:\\n                p.append(c)\\n                v[i] = j \\n                j += 1\\n            elif count[c] == 1: # The character that is not paired with another equal character will go to the center of the palindrome\\n                v[i] = len(s) // 2       \\n            count[c] -= 2\\n                \\n        j = (len(s) + 1) // 2\\n                \\n        p.reverse()\\n        d = defaultdict(list)\\n        for c in p:\\n            d[c].append(j)\\n            j += 1\\n        \\n        for i in range(len(v))[::-1]:\\n            if v[i] == -1:\\n                v[i] = d[s[i]].pop()\\n                \\n        # Count number of inversions in the permutation\\n        \\n        u = SortedList()\\n        r = 0\\n        v.reverse()\\n        for j in v:\\n            r += u.bisect_right(j)\\n            u.add(j)\\n            \\n        return r\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        \\n        # Calculate the permutation\\n        \\n        count = Counter(s)\\n        p = []\\n        v = [-1] * len(s) # List v will represent the permutation\\n        j = 0\\n        for i, c in enumerate(s):\\n            if count[c] > 1:\\n                p.append(c)\\n                v[i] = j \\n                j += 1\\n            elif count[c] == 1: # The character that is not paired with another equal character will go to the center of the palindrome\\n                v[i] = len(s) // 2       \\n            count[c] -= 2\\n                \\n        j = (len(s) + 1) // 2\\n                \\n        p.reverse()\\n        d = defaultdict(list)\\n        for c in p:\\n            d[c].append(j)\\n            j += 1\\n        \\n        for i in range(len(v))[::-1]:\\n            if v[i] == -1:\\n                v[i] = d[s[i]].pop()\\n                \\n        # Count number of inversions in the permutation\\n        \\n        u = SortedList()\\n        r = 0\\n        v.reverse()\\n        for j in v:\\n            r += u.bisect_right(j)\\n            u.add(j)\\n            \\n        return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2598453,
                "title": "greedy-approach-explained-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        if(s.length() < 3) return 0;\\n\\t\\t// here we are thinking to finding every character that is nearest and then shifting it to that position to make palindrome \\n        int pt1 = 0;\\n        int pt2 = s.length()-1;\\n        int ans = 0;\\n        int tpl = 0 , tpr = pt2; // to store temporary pointer left and right ...\\n        while(pt1 < pt2){\\n            // if both end have not same character then come inside and make it same \\n            if(s[pt1] != s[pt2]){\\n                // search in left for right end character and in right leftmost character\\n                tpl = pt1 + 1;\\n                tpr = pt2 - 1;\\n                // bool to store which pointer found the character in first\\n                bool l = 0 , r = 0;\\n                while(tpl < pt2 && tpr > pt1){\\n                    if(s[tpl] == s[pt2]){\\n                        l = 1;\\n                        break;\\n                    }\\n                    if(s[tpr] == s[pt1]){\\n                        r = 1;\\n                        break;\\n                    }\\n                    tpl++;\\n                    tpr--;\\n                }\\n                // found\\n                if(l){\\n                    // Here if left pointer found character so we have to shift characters to right\\n                    int t = tpl;\\n                    // shifting characters\\n                    while(t > pt1){ s[t] = s[t-1]; ans++; t--;}\\n                    // finally changing pt1 character to pt2 as this character if found\\n                    s[pt1] = s[pt2];\\n                }else{\\n                    // Here if right pointer found character so we have to shift characters to left\\n                    int t = tpr;\\n                    while(t < pt2){ s[t] = s[t+1]; ans++; t++;}\\n                    s[pt2] = s[pt1];\\n                }\\n            }\\n            pt1++;\\n            pt2--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        if(s.length() < 3) return 0;\\n\\t\\t// here we are thinking to finding every character that is nearest and then shifting it to that position to make palindrome \\n        int pt1 = 0;\\n        int pt2 = s.length()-1;\\n        int ans = 0;\\n        int tpl = 0 , tpr = pt2; // to store temporary pointer left and right ...\\n        while(pt1 < pt2){\\n            // if both end have not same character then come inside and make it same \\n            if(s[pt1] != s[pt2]){\\n                // search in left for right end character and in right leftmost character\\n                tpl = pt1 + 1;\\n                tpr = pt2 - 1;\\n                // bool to store which pointer found the character in first\\n                bool l = 0 , r = 0;\\n                while(tpl < pt2 && tpr > pt1){\\n                    if(s[tpl] == s[pt2]){\\n                        l = 1;\\n                        break;\\n                    }\\n                    if(s[tpr] == s[pt1]){\\n                        r = 1;\\n                        break;\\n                    }\\n                    tpl++;\\n                    tpr--;\\n                }\\n                // found\\n                if(l){\\n                    // Here if left pointer found character so we have to shift characters to right\\n                    int t = tpl;\\n                    // shifting characters\\n                    while(t > pt1){ s[t] = s[t-1]; ans++; t--;}\\n                    // finally changing pt1 character to pt2 as this character if found\\n                    s[pt1] = s[pt2];\\n                }else{\\n                    // Here if right pointer found character so we have to shift characters to left\\n                    int t = tpr;\\n                    while(t < pt2){ s[t] = s[t+1]; ans++; t++;}\\n                    s[pt2] = s[pt1];\\n                }\\n            }\\n            pt1++;\\n            pt2--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2565218,
                "title": "java-simple-solution-greedy-intuitive-approach",
                "content": "```\\nclass Solution {\\n    public int find(char[] sArr, char key, int from, int to){\\n        for(int i=from;i<=to; i++){\\n            if(key == sArr[i])\\n                return i;\\n        }\\n        return -1;\\n    }\\n    public void swap(char[] sArr, int i, int j){\\n        char t = sArr[i];\\n        sArr[i] = sArr[j];\\n        sArr[j] = t;\\n    }\\n    public void shift(char[] sArr, int from, int to){\\n        for(int i=from;i>to;i--){\\n            swap(sArr, i, i-1);\\n        }\\n    }\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] sArr = s.toCharArray();\\n        int n = sArr.length;\\n        int left = 0;\\n        int right = sArr.length-1;\\n        int ans = 0;\\n        while(left<right){\\n            int index = find(sArr, sArr[right], left, right);\\n            if(index == right){\\n                ans += right-n/2;\\n                right--;\\n            }\\n            else{\\n                shift(sArr, index, left);\\n                ans += index-left;\\n                left++;\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int find(char[] sArr, char key, int from, int to){\\n        for(int i=from;i<=to; i++){\\n            if(key == sArr[i])\\n                return i;\\n        }\\n        return -1;\\n    }\\n    public void swap(char[] sArr, int i, int j){\\n        char t = sArr[i];\\n        sArr[i] = sArr[j];\\n        sArr[j] = t;\\n    }\\n    public void shift(char[] sArr, int from, int to){\\n        for(int i=from;i>to;i--){\\n            swap(sArr, i, i-1);\\n        }\\n    }\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] sArr = s.toCharArray();\\n        int n = sArr.length;\\n        int left = 0;\\n        int right = sArr.length-1;\\n        int ans = 0;\\n        while(left<right){\\n            int index = find(sArr, sArr[right], left, right);\\n            if(index == right){\\n                ans += right-n/2;\\n                right--;\\n            }\\n            else{\\n                shift(sArr, index, left);\\n                ans += index-left;\\n                left++;\\n                right--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551292,
                "title": "simple-to-understand-two-pointer",
                "content": "\\nWe don\\'t care to actually do the swap. \\nAll we need to do is figure out how far away from the end it is.\\nThe only edge case, since the prompt gaurantees a palindrome, is an odd palindrome, which means the character that has no duplicate will need to be at the center.\\n\\n\\n\\n\\n\\n\\n```\\nA = 0\\n# if length == 1, then no swaps needed\\nwhile len(s) > 1:\\n\\t#grab first character\\n\\tletter = s[0]\\n\\t#loop backwards to ensure we grab min swap character\\n\\tfor i in range(len(s)-1,-1,-1):\\n\\t\\t#we\\'ve found the closest character to the end to swap\\n\\t\\tif s[i] == letter and i != 0:\\n\\t\\t\\t#get our new string excluding the two same characters, and add to our total\\n\\t\\t\\tA += (len(s) - i - 1)\\n\\t\\t\\ts = s[1:i] + s[i+1:]\\n\\t\\t\\tbreak\\n\\t\\t#odd palindrome case, just add distance from center to our total and remove it\\n        if i == 0:\\n\\t\\t\\tcenter = len(s) // 2\\n\\t\\t\\tA += center\\n\\t\\t\\ts = s[1:]\\n\\t\\t\\tbreak\\nreturn A\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nA = 0\\n# if length == 1, then no swaps needed\\nwhile len(s) > 1:\\n\\t#grab first character\\n\\tletter = s[0]\\n\\t#loop backwards to ensure we grab min swap character\\n\\tfor i in range(len(s)-1,-1,-1):\\n\\t\\t#we\\'ve found the closest character to the end to swap\\n\\t\\tif s[i] == letter and i != 0:\\n\\t\\t\\t#get our new string excluding the two same characters, and add to our total\\n\\t\\t\\tA += (len(s) - i - 1)\\n\\t\\t\\ts = s[1:i] + s[i+1:]\\n\\t\\t\\tbreak\\n\\t\\t#odd palindrome case, just add distance from center to our total and remove it\\n        if i == 0:\\n\\t\\t\\tcenter = len(s) // 2\\n\\t\\t\\tA += center\\n\\t\\t\\ts = s[1:]\\n\\t\\t\\tbreak\\nreturn A\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2545661,
                "title": "accepted-java-two-pointers-with-simple-explanation",
                "content": "Just maintain two pointers for the String,\\nFor every character at position i there has got to be a corresponding char at pos j same as that of i so we find this char towrads the left of j and when we find it we bring this at position j and increment the number of swaps accordingly.\\nIf we do not find any other char to the left of j other than i itself this means that the char at i occurs just once and this will inturn be the middle character of the palindrome so we swap it with i+1 th char and move forward.\\n\\n\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] arr=s.toCharArray();\\n        int ans=0;\\n        \\n        for(int i=0;i<s.length()/2;i++){\\n            int j=s.length()-1-i;\\n            \\n            while(arr[i]!=arr[j]){\\n                j--;\\n            }\\n             int swaps=0;\\n            if(j==i){ //condn where char at i will be middle elem.\\n                char c=arr[i];\\n                arr[i]=arr[i+1];\\n                arr[i+1]=c;\\n                swaps++;\\n                i--;\\n            }else{\\n           \\n            for(int x=j;x<s.length()-1-i;x++){\\n                arr[x]=arr[x+1];\\n                swaps++;\\n            }\\n            arr[s.length()-1-i]=arr[i];\\n            }\\n            ans+=swaps;\\n         \\n           \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        char[] arr=s.toCharArray();\\n        int ans=0;\\n        \\n        for(int i=0;i<s.length()/2;i++){\\n            int j=s.length()-1-i;\\n            \\n            while(arr[i]!=arr[j]){\\n                j--;\\n            }\\n             int swaps=0;\\n            if(j==i){ //condn where char at i will be middle elem.\\n                char c=arr[i];\\n                arr[i]=arr[i+1];\\n                arr[i+1]=c;\\n                swaps++;\\n                i--;\\n            }else{\\n           \\n            for(int x=j;x<s.length()-1-i;x++){\\n                arr[x]=arr[x+1];\\n                swaps++;\\n            }\\n            arr[s.length()-1-i]=arr[i];\\n            }\\n            ans+=swaps;\\n         \\n           \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2517633,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int result = 0;\\n        int left = 0, right = s.length()-1;\\n        while(left < right) {\\n            int l = left, r = right;\\n            while(s[l] != s[r])\\n                r--;\\n            // if the element we reached is the middle element then take the element to the adjacent index\\n            if(l == r) {\\n                swap(s[r], s[r+1]);\\n                result++;\\n                continue;\\n            } \\n            // if the element is a normal element then set it to its right position\\n            else {\\n                while(r < right) {\\n                    swap(s[r], s[r+1]);\\n                    r++;\\n                    result++;\\n                }\\n            }\\n            left++;\\n            right--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int result = 0;\\n        int left = 0, right = s.length()-1;\\n        while(left < right) {\\n            int l = left, r = right;\\n            while(s[l] != s[r])\\n                r--;\\n            // if the element we reached is the middle element then take the element to the adjacent index\\n            if(l == r) {\\n                swap(s[r], s[r+1]);\\n                result++;\\n                continue;\\n            } \\n            // if the element is a normal element then set it to its right position\\n            else {\\n                while(r < right) {\\n                    swap(s[r], s[r+1]);\\n                    r++;\\n                    result++;\\n                }\\n            }\\n            left++;\\n            right--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500675,
                "title": "python-bfs-tle-and-greedy-two-pointers-solution",
                "content": "```\\nimport collections\\n\\nclass Solution:\\n    # BFS TLE\\n    # def minMovesToMakePalindrome(self, s: str) -> int:\\n    #     queue = collections.deque()\\n    #     queue.append((s, 0))\\n    #     seen = set()\\n    #     while queue:\\n    #         text, operation = queue.popleft()\\n    #         if text in seen:\\n    #             continue\\n    #         if text == text[::-1]:\\n    #             return operation\\n    #         seen.add(text)\\n    #         for i in range(len(text)-1):\\n    #             new_text = text[:i] + text[i+1] + text[i] + text[i+2:]\\n    #             if new_text not in seen:\\n    #                 queue.append((new_text, operation+1))\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        n = len(s)\\n        count = 0\\n        for left in range(n // 2):\\n            right = n - left - 1\\n            if s[left] != s[right]:\\n                i = left\\n                j = right\\n                while s[left] != s[j]:\\n                    j -= 1\\n                      \\n                while s[right] != s[i]:\\n                    i += 1\\n                    \\n                if right - j < i - left:\\n                    count += right - j\\n                    for x in range(j, right):\\n                        s[x], s[x+1] = s[x+1], s[x]\\n                else:\\n                    count += i - left\\n                    for x in range(i, left, -1):\\n                        s[x], s[x-1] = s[x-1], s[x]  \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    # BFS TLE\\n    # def minMovesToMakePalindrome(self, s: str) -> int:\\n    #     queue = collections.deque()\\n    #     queue.append((s, 0))\\n    #     seen = set()\\n    #     while queue:\\n    #         text, operation = queue.popleft()\\n    #         if text in seen:\\n    #             continue\\n    #         if text == text[::-1]:\\n    #             return operation\\n    #         seen.add(text)\\n    #         for i in range(len(text)-1):\\n    #             new_text = text[:i] + text[i+1] + text[i] + text[i+2:]\\n    #             if new_text not in seen:\\n    #                 queue.append((new_text, operation+1))\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        s = list(s)\\n        n = len(s)\\n        count = 0\\n        for left in range(n // 2):\\n            right = n - left - 1\\n            if s[left] != s[right]:\\n                i = left\\n                j = right\\n                while s[left] != s[j]:\\n                    j -= 1\\n                      \\n                while s[right] != s[i]:\\n                    i += 1\\n                    \\n                if right - j < i - left:\\n                    count += right - j\\n                    for x in range(j, right):\\n                        s[x], s[x+1] = s[x+1], s[x]\\n                else:\\n                    count += i - left\\n                    for x in range(i, left, -1):\\n                        s[x], s[x-1] = s[x-1], s[x]  \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454656,
                "title": "two-pointer-greedy-approach",
                "content": "```\\n public int minMovesToMakePalindrome(String s) {\\n        int lo = 0;\\n        int hi = s.length() - 1;\\n        int ans = 0;\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        while (lo < hi) {\\n            \\n            if (sb.charAt(lo) == sb.charAt(hi)) {\\n                lo++;\\n                hi--;\\n                continue;\\n            }\\n            int l = lo + 1;\\n            int h = hi - 1;\\n            \\n            while (sb.charAt(l) != sb.charAt(hi)) {\\n                l++;\\n            } \\n            \\n            while (sb.charAt(h) != sb.charAt(lo)) {\\n                h--;\\n            }\\n            //Can also be done using Arrays while bubbling the value to the position\\n            if (l - lo < hi - h) {\\n                sb.insert(lo, sb.charAt(l));\\n                sb.deleteCharAt(l + 1);\\n                ans += l - lo;\\n            } else {\\n                sb.insert(hi + 1, sb.charAt(h));\\n                sb.deleteCharAt(h);\\n                ans += hi - h;\\n            }\\n            lo++;\\n            hi--;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\n public int minMovesToMakePalindrome(String s) {\\n        int lo = 0;\\n        int hi = s.length() - 1;\\n        int ans = 0;\\n        StringBuilder sb = new StringBuilder(s);\\n        \\n        while (lo < hi) {\\n            \\n            if (sb.charAt(lo) == sb.charAt(hi)) {\\n                lo++;\\n                hi--;\\n                continue;\\n            }\\n            int l = lo + 1;\\n            int h = hi - 1;\\n            \\n            while (sb.charAt(l) != sb.charAt(hi)) {\\n                l++;\\n            } \\n            \\n            while (sb.charAt(h) != sb.charAt(lo)) {\\n                h--;\\n            }\\n            //Can also be done using Arrays while bubbling the value to the position\\n            if (l - lo < hi - h) {\\n                sb.insert(lo, sb.charAt(l));\\n                sb.deleteCharAt(l + 1);\\n                ans += l - lo;\\n            } else {\\n                sb.insert(hi + 1, sb.charAt(h));\\n                sb.deleteCharAt(h);\\n                ans += hi - h;\\n            }\\n            lo++;\\n            hi--;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2448331,
                "title": "java-detail-explained-greedy-solution",
                "content": "```\\n    //Greedy strategy to check one char by one char as peel an onion i<-->j until nothing left.\\n    public int minMovesToMakePalindrome(String s) {\\n        int res = 0;\\n        while(s.length() > 0) {\\n            char e = s.charAt(s.length() - 1);\\n            int i = s.indexOf(e);\\n            //if single char, it means for palindromic, it should in the middle. so move i /2 steps to put it in the middle.\\n            if(i == s.length() - 1) {\\n                res += i/2;\\n            } else {\\n                //move i step to put it to the head.\\n                res += i;\\n               //skip the ith char as it should be put to head and peeled off.\\n                s = s.substring(0, i) + s.substring(i+1);\\n            }\\n            \\n            //remove the last one as peel off the leftmost and right most.\\n            s = s.substring(0, s.length() - 1);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\n    //Greedy strategy to check one char by one char as peel an onion i<-->j until nothing left.\\n    public int minMovesToMakePalindrome(String s) {\\n        int res = 0;\\n        while(s.length() > 0) {\\n            char e = s.charAt(s.length() - 1);\\n            int i = s.indexOf(e);\\n            //if single char, it means for palindromic, it should in the middle. so move i /2 steps to put it in the middle.\\n            if(i == s.length() - 1) {\\n                res += i/2;\\n            } else {\\n                //move i step to put it to the head.\\n                res += i;\\n               //skip the ith char as it should be put to head and peeled off.\\n                s = s.substring(0, i) + s.substring(i+1);\\n            }\\n            \\n            //remove the last one as peel off the leftmost and right most.\\n            s = s.substring(0, s.length() - 1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2401251,
                "title": "c-89-time-greedy-two-pointer",
                "content": "![image](https://assets.leetcode.com/users/images/eb3f97c4-5576-42ae-afd1-90110d8e0dec_1660031490.3080149.png)\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/eb3f97c4-5576-42ae-afd1-90110d8e0dec_1660031490.3080149.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2347637,
                "title": "c-solution-with-comments-2-pointers-swap-time-limit-exceeded",
                "content": "```\\n/* Time Limit is Exceeded for some case. Plase see the below code to understand the logic only. */\\npublic class Solution {\\n    public int MinMovesToMakePalindrome(string s) {\\n        int ans = 0;\\n        // 2 pointers -- left (start), right (end)\\n        int left = 0;\\n        int right = s.Length - 1;\\n        \\n        // l and r copies to initial pointers because these will be moved\\n        int l, r = 0;\\n        while(left < right)\\n        {\\n            l = left;\\n            r = right;\\n            \\n            // move r towards l till matching char is found\\n            while(s[l] != s[r])\\n                r--;\\n            \\n            if(l == r) // there is only 1 character in string so it should be in center\\n            {\\n                s = Swap(r, (r + 1), s);\\n                ans++;\\n                continue;\\n            }\\n            else // there are 2 (or more) same chars and this other char should be moved to opposite end\\n            {\\n                while(r < right) // move second char till r = right\\n                {\\n                    s = Swap(r, (r + 1), s);\\n                    ans++;\\n                    r++;\\n                }\\n            }\\n            // after each iteration move left and right towards each other\\n            left++;\\n            right--;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private static string Swap(int index1, int index2, string str)\\n    {\\n        char[] strChar = str.ToCharArray();\\n        char temp = strChar[index1];\\n        strChar[index1] = strChar[index2];\\n        strChar[index2] = temp;\\n        \\n        return new string(strChar);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n/* Time Limit is Exceeded for some case. Plase see the below code to understand the logic only. */\\npublic class Solution {\\n    public int MinMovesToMakePalindrome(string s) {\\n        int ans = 0;\\n        // 2 pointers -- left (start), right (end)\\n        int left = 0;\\n        int right = s.Length - 1;\\n        \\n        // l and r copies to initial pointers because these will be moved\\n        int l, r = 0;\\n        while(left < right)\\n        {\\n            l = left;\\n            r = right;\\n            \\n            // move r towards l till matching char is found\\n            while(s[l] != s[r])\\n                r--;\\n            \\n            if(l == r) // there is only 1 character in string so it should be in center\\n            {\\n                s = Swap(r, (r + 1), s);\\n                ans++;\\n                continue;\\n            }\\n            else // there are 2 (or more) same chars and this other char should be moved to opposite end\\n            {\\n                while(r < right) // move second char till r = right\\n                {\\n                    s = Swap(r, (r + 1), s);\\n                    ans++;\\n                    r++;\\n                }\\n            }\\n            // after each iteration move left and right towards each other\\n            left++;\\n            right--;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private static string Swap(int index1, int index2, string str)\\n    {\\n        char[] strChar = str.ToCharArray();\\n        char temp = strChar[index1];\\n        strChar[index1] = strChar[index2];\\n        strChar[index2] = temp;\\n        \\n        return new string(strChar);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347480,
                "title": "swift-two-pointer-solution-100-efficient",
                "content": "```\\nclass Solution {\\n    func minMovesToMakePalindrome(_ s: String) -> Int {\\n        let n = s.count\\n        var s = Array(s)\\n        var lptr = 0\\n        var rptr = n - 1\\n        var res = 0\\n        while lptr < rptr {\\n            var r = rptr\\n            if s[lptr] == s[r] {\\n                lptr += 1\\n                rptr -= 1\\n                continue\\n            }\\n            while s[lptr] != s[r] {\\n                r -= 1\\n            }\\n            if lptr == r {\\n                swap(&s, lptr, lptr + 1)\\n                res += 1\\n            } else {\\n                while r != rptr {\\n                    swap(&s, r, r + 1)\\n                    r += 1\\n                    res += 1\\n                }\\n            }\\n        }\\n        return res\\n    }\\n    \\n    func swap(_ s: inout [Character], _ l: Int, _ r: Int) {\\n        let temp = s[l]\\n        s[l] = s[r]\\n        s[r] = temp\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minMovesToMakePalindrome(_ s: String) -> Int {\\n        let n = s.count\\n        var s = Array(s)\\n        var lptr = 0\\n        var rptr = n - 1\\n        var res = 0\\n        while lptr < rptr {\\n            var r = rptr\\n            if s[lptr] == s[r] {\\n                lptr += 1\\n                rptr -= 1\\n                continue\\n            }\\n            while s[lptr] != s[r] {\\n                r -= 1\\n            }\\n            if lptr == r {\\n                swap(&s, lptr, lptr + 1)\\n                res += 1\\n            } else {\\n                while r != rptr {\\n                    swap(&s, r, r + 1)\\n                    r += 1\\n                    res += 1\\n                }\\n            }\\n        }\\n        return res\\n    }\\n    \\n    func swap(_ s: inout [Character], _ l: Int, _ r: Int) {\\n        let temp = s[l]\\n        s[l] = s[r]\\n        s[r] = temp\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333573,
                "title": "java-solution-for-minimum-move-to-make-palindrome",
                "content": "this solution work with all type of string i.e binary, number strings as well \\nbut leet code expecting on their test is 2 move to make palindrome **aabb** and expecting 2 moves but this algorithm give most minimum and solve this with 1 move \\n\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int length = s.length();\\n        if (length == 0 || length == 1) return 0;\\n\\n        char[] str = s.toCharArray();\\n        int start = 0, end = length - 1;\\n        int count = 0;\\n        while (start < end) {\\n            if (str[start] != str[end]){\\n                boolean isSwapped = false;\\n                for (int i = start + 1; i < end; i++){\\n                    if (str[start] == str[i]){\\n                        char temp = str[i];\\n                        str[i] = str[end];\\n                        str[end] = temp;\\n                        count++;\\n                        isSwapped = true;\\n                        break;\\n                    }else if (str[end] == str[i]){\\n                        char temp = str[i];\\n                        str[i] = str[start];\\n                        str[start] = temp;\\n                        count++;\\n                        isSwapped = true;\\n                        break;\\n                    }\\n                }\\n                if (!isSwapped) return 0;\\n            }\\n            start++;\\n            end--;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int length = s.length();\\n        if (length == 0 || length == 1) return 0;\\n\\n        char[] str = s.toCharArray();\\n        int start = 0, end = length - 1;\\n        int count = 0;\\n        while (start < end) {\\n            if (str[start] != str[end]){\\n                boolean isSwapped = false;\\n                for (int i = start + 1; i < end; i++){\\n                    if (str[start] == str[i]){\\n                        char temp = str[i];\\n                        str[i] = str[end];\\n                        str[end] = temp;\\n                        count++;\\n                        isSwapped = true;\\n                        break;\\n                    }else if (str[end] == str[i]){\\n                        char temp = str[i];\\n                        str[i] = str[start];\\n                        str[start] = temp;\\n                        count++;\\n                        isSwapped = true;\\n                        break;\\n                    }\\n                }\\n                if (!isSwapped) return 0;\\n            }\\n            start++;\\n            end--;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326598,
                "title": "3-liner-recursive-solution",
                "content": "Let `a` denotes the first char of `s`, `S` denotes  the palindrome which takes miminum swaps to make, we have two following observations:\\n\\n1. `a` is also the first char of `S`\\n   <details>\\n   <summary>Proof</summary>\\n   \\n   We prove this by contradiction:\\n   Suppose the first character of `S` is not `a`, then `S` must be of form `..a..a..`, since `S` is a permutation of `s` the minimum number of swaps needed to create `S` is the number of inversions of the permuation `S`.\\n   Moving the first `a` to the beggining of `S` decreases the number of inversions by `j` (index of the first `a` in `S`). Moving the last  `a` to the end of `S` increases the number of inversions by at most `j`. So the number of inversions of `a....a` is always equal or smaller than `S`\\'s. So the panlidrome whick takes minimum swaps always have the first char of `a`.\\n   </details>\\n2. Let `i` denotes the furthest index of  char `a` in `s`, move `i`th char to the end of `s` we obtain a new string `s\\'` . The minimum number of moves to make S equal to number of moves to move `i`th char to \\'S\\'\\'s end plus the minimum number of swaps to make substring `s\\'[1..-1]` become a panlindrome.\\n\\t<details>\\n\\t<summary>Proof</summary>\\n\\n\\t The last char of `S` must be `a`, hence moving the furthest `a` to the end would take minimum moves.\\n\\t</details>\\n\\t\\n**Note** : There is an edge case where `a` is the middle char of the panlidrome in this case there\\'s only one `a` in `s`, the result would be equal to half the length of `s` plus min moves to change the rest substring.\\n```python\\ndef minMovesToMakePalindrome(self, s: str) -> int:\\n        if len(s) < 2:\\n          return 0 \\n        j = s.rfind(s[0])\\n        return self.minMovesToMakePalindrome(s[1:]) + len(s)//2  if j==0 \\\\\\n        else len(s)-1-j + self.minMovesToMakePalindrome(s[1:j] + s[j+1:]) \\n```\\n--- \\n<br>\\n<summary><b>Advance solution O(nlogn)</b></summary>\\nThis solution takes only O(nlogn) whereas the previous takes O(n^2)\\nThe idea is to create the panlindrome permutation first and then calculate the number of its inversion (Traverse from left to right, if there exists a right most unused char which is identical to the current one then update the correspond indexes in the permutation)\\n\\n```python\\ndef minMovesToMakePalindrome(self, s: str) -> int:\\n        n = len(s)\\n        idx = collections.defaultdict(collections.deque) ; \\n        for i,j in enumerate(s):\\n            idx[j].append(i)\\n        p = [0] * len(s)\\n        j = 0 \\n        for i in s:\\n            if len(idx[i]) > 1:\\n                p[j] = idx[i].popleft()\\n                p[n-j-1] = idx[i].pop()\\n                j += 1\\n            elif len(idx[i]) == 1:\\n                p[n//2] = idx[i].pop()\\n        from sortedcontainers import SortedList\\n        res = 0\\n        A = SortedList()\\n        for i in p[::-1]:\\n            res += A.bisect(i)\\n            A.add(i)\\n        return res\\n```\\n",
                "solutionTags": [],
                "code": "```python\\ndef minMovesToMakePalindrome(self, s: str) -> int:\\n        if len(s) < 2:\\n          return 0 \\n        j = s.rfind(s[0])\\n        return self.minMovesToMakePalindrome(s[1:]) + len(s)//2  if j==0 \\\\\\n        else len(s)-1-j + self.minMovesToMakePalindrome(s[1:j] + s[j+1:]) \\n```\n```python\\ndef minMovesToMakePalindrome(self, s: str) -> int:\\n        n = len(s)\\n        idx = collections.defaultdict(collections.deque) ; \\n        for i,j in enumerate(s):\\n            idx[j].append(i)\\n        p = [0] * len(s)\\n        j = 0 \\n        for i in s:\\n            if len(idx[i]) > 1:\\n                p[j] = idx[i].popleft()\\n                p[n-j-1] = idx[i].pop()\\n                j += 1\\n            elif len(idx[i]) == 1:\\n                p[n//2] = idx[i].pop()\\n        from sortedcontainers import SortedList\\n        res = 0\\n        A = SortedList()\\n        for i in p[::-1]:\\n            res += A.bisect(i)\\n            A.add(i)\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2323007,
                "title": "java-two-pointer-o-n-or-o-n-2-easy-to-understand",
                "content": "\\n\\n```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n               \\n        int left = 0;\\n        int right = s.length() -1;\\n        int ans = 0;\\n        \\n        char[] str = s.toCharArray();\\n        \\n        while(left < right)\\n        {\\n            // System.out.println(\"-------------------------------------\");\\n            // System.out.println(str[left] + \" <----> \" + str[right]);\\n            if(str[left] == str[right])\\n            {\\n                left++;\\n                right--;\\n                // System.out.println(left + \" <--> \" + right);\\n            }\\n            else\\n            {\\n                int matchIdx = -1;\\n                for(int goRight = left+1; goRight < right; goRight++)\\n                {\\n                    if(str[goRight] == str[right])\\n                    {\\n                        matchIdx = goRight;\\n                        break;\\n                    }\\n                }\\n                \\n                if(matchIdx != -1)\\n                {\\n                    for(int goLeft = matchIdx; goLeft > left; goLeft--)\\n                    {\\n                        str = swap(str, goLeft, goLeft-1);\\n                        ans++;\\n                        // System.out.println(\"swap ->  \" + String.valueOf(str));\\n                    }\\n                }\\n                else\\n                {\\n                    str = swap(str, right, right-1);\\n                    ans++;\\n                    // System.out.println(\"swap else -> \" + String.valueOf(str));\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        \\n        // System.out.println(String.valueOf(str));\\n        \\n        return ans;\\n        \\n    }\\n    \\n    char[] swap(char[] str, int i , int j)\\n    {\\n        char tmp = str[i];\\n        str[i] = str[j];\\n        str[j] = tmp;\\n        return str;\\n    }\\n    \\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n               \\n        int left = 0;\\n        int right = s.length() -1;\\n        int ans = 0;\\n        \\n        char[] str = s.toCharArray();\\n        \\n        while(left < right)\\n        {\\n            // System.out.println(\"-------------------------------------\");\\n            // System.out.println(str[left] + \" <----> \" + str[right]);\\n            if(str[left] == str[right])\\n            {\\n                left++;\\n                right--;\\n                // System.out.println(left + \" <--> \" + right);\\n            }\\n            else\\n            {\\n                int matchIdx = -1;\\n                for(int goRight = left+1; goRight < right; goRight++)\\n                {\\n                    if(str[goRight] == str[right])\\n                    {\\n                        matchIdx = goRight;\\n                        break;\\n                    }\\n                }\\n                \\n                if(matchIdx != -1)\\n                {\\n                    for(int goLeft = matchIdx; goLeft > left; goLeft--)\\n                    {\\n                        str = swap(str, goLeft, goLeft-1);\\n                        ans++;\\n                        // System.out.println(\"swap ->  \" + String.valueOf(str));\\n                    }\\n                }\\n                else\\n                {\\n                    str = swap(str, right, right-1);\\n                    ans++;\\n                    // System.out.println(\"swap else -> \" + String.valueOf(str));\\n                }\\n                \\n            }\\n            \\n            \\n        }\\n        \\n        // System.out.println(String.valueOf(str));\\n        \\n        return ans;\\n        \\n    }\\n    \\n    char[] swap(char[] str, int i , int j)\\n    {\\n        char tmp = str[i];\\n        str[i] = str[j];\\n        str[j] = tmp;\\n        return str;\\n    }\\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321206,
                "title": "c-greedy-o-n-2-sln",
                "content": "```\\nint minMovesToMakePalindromeImpl(string& s, int i, int j) {\\n        if (i >= j) {\\n            return 0;\\n        }\\n        int k = j;\\n        while (s[k] != s[i]) {\\n            --k;\\n        }\\n        if (k == i) {\\n            swap(s[k], s[k + 1]);\\n            return minMovesToMakePalindromeImpl(s, i, j) + 1;\\n        }\\n        rotate(begin(s) + k, begin(s) + k + 1, begin(s) + j + 1);\\n        return minMovesToMakePalindromeImpl(s, i + 1, j - 1) + j - k;\\n    }\\n    \\n    int minMovesToMakePalindrome(string s) {\\n        return minMovesToMakePalindromeImpl(s, 0, size(s) - 1);\\n    }",
                "solutionTags": [],
                "code": "```\\nint minMovesToMakePalindromeImpl(string& s, int i, int j) {\\n        if (i >= j) {\\n            return 0;\\n        }\\n        int k = j;\\n        while (s[k] != s[i]) {\\n            --k;\\n        }\\n        if (k == i) {\\n            swap(s[k], s[k + 1]);\\n            return minMovesToMakePalindromeImpl(s, i, j) + 1;\\n        }\\n        rotate(begin(s) + k, begin(s) + k + 1, begin(s) + j + 1);\\n        return minMovesToMakePalindromeImpl(s, i + 1, j - 1) + j - k;\\n    }\\n    \\n    int minMovesToMakePalindrome(string s) {\\n        return minMovesToMakePalindromeImpl(s, 0, size(s) - 1);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2307648,
                "title": "c-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        int j = s.size() - 1;\\n        int cnt = 0;\\n        while(i < j){\\n            if(s[i] != s[j]){\\n                int k = j;\\n                string str = s;\\n                while(s[i] != s[k] and k >= 0){\\n                    k--;\\n                }\\n                int c1 = 0;\\n                while(str[i] != str[j] and k < (n-1)){\\n                    swap(str[k] , str[k+1]);\\n                    c1++;\\n                    k++;\\n                }\\n                \\n                k = i;\\n                \\n                string t = s;\\n                while(s[j] != s[k] and k < (n-1)){\\n                    k++;\\n                }\\n                // cout<<s<<k<<endl;\\n                int c2 = 0;\\n                while(t[i] != t[j] and k > 0){\\n                    swap(t[k] , t[k-1]);\\n                    c2++;\\n                    k--;\\n                }\\n                \\n                // cout<<c1<<\" \"<<c2<<endl;\\n                if(c1 > c2){\\n                    cnt += c2;\\n                    s = t;\\n                }\\n                else{\\n                    cnt += c1;\\n                    s = str;\\n                }\\n            }else{\\n                i++;\\n                j--;\\n            }\\n        }\\n        cout<<s<<endl;\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        int j = s.size() - 1;\\n        int cnt = 0;\\n        while(i < j){\\n            if(s[i] != s[j]){\\n                int k = j;\\n                string str = s;\\n                while(s[i] != s[k] and k >= 0){\\n                    k--;\\n                }\\n                int c1 = 0;\\n                while(str[i] != str[j] and k < (n-1)){\\n                    swap(str[k] , str[k+1]);\\n                    c1++;\\n                    k++;\\n                }\\n                \\n                k = i;\\n                \\n                string t = s;\\n                while(s[j] != s[k] and k < (n-1)){\\n                    k++;\\n                }\\n                // cout<<s<<k<<endl;\\n                int c2 = 0;\\n                while(t[i] != t[j] and k > 0){\\n                    swap(t[k] , t[k-1]);\\n                    c2++;\\n                    k--;\\n                }\\n                \\n                // cout<<c1<<\" \"<<c2<<endl;\\n                if(c1 > c2){\\n                    cnt += c2;\\n                    s = t;\\n                }\\n                else{\\n                    cnt += c1;\\n                    s = str;\\n                }\\n            }else{\\n                i++;\\n                j--;\\n            }\\n        }\\n        cout<<s<<endl;\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2302517,
                "title": "simple-c-soln-two-pointers",
                "content": "```\\n int minMovesToMakePalindrome(string s) {\\n        \\n        int left= 0;\\n        int right= s.length()-1;\\n        int res=0;\\n        \\n        while(left<right)\\n        {\\n           int l=left, r=right;\\n            \\n            while(s[l]!=s[r])\\n            {\\n                r--;\\n            }\\n            \\n            if(l==r)                                //odd component\\n            {\\n                swap(s[r], s[r+1]);\\n                res++;\\n                continue;\\n                    \\n            }\\n            else \\n            {\\n                while(r<right)\\n                {\\n                    swap(s[r], s[r+1]);\\n                    res++;\\n                    r++;\\n                }\\n            }\\n            \\n            \\n            left++;\\n            right--;\\n                \\n        }\\n        \\n        return res;\\n        \\n    }",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "```\\n int minMovesToMakePalindrome(string s) {\\n        \\n        int left= 0;\\n        int right= s.length()-1;\\n        int res=0;\\n        \\n        while(left<right)\\n        {\\n           int l=left, r=right;\\n            \\n            while(s[l]!=s[r])\\n            {\\n                r--;\\n            }\\n            \\n            if(l==r)                                //odd component\\n            {\\n                swap(s[r], s[r+1]);\\n                res++;\\n                continue;\\n                    \\n            }\\n            else \\n            {\\n                while(r<right)\\n                {\\n                    swap(s[r], s[r+1]);\\n                    res++;\\n                    r++;\\n                }\\n            }\\n            \\n            \\n            left++;\\n            right--;\\n                \\n        }\\n        \\n        return res;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2261685,
                "title": "c-two-pointers-approach",
                "content": "use two pointers if left char is equal to right continue if not equal find the char of left one from right side and simlarly for right char from left side take the minimum of two do swaps check the condition that if there is only one suitable\\n\\n```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.length(),ans=0;\\n        int l=0,r=n-1;\\n        while(l<r)\\n        {\\n            int p,q;\\n            if(s[l]==s[r])\\n            {\\n                l++;\\n                r--;\\n            }\\n            else\\n            {\\n                int key1=s[r],key2=s[l];\\n                p=l+1;\\n                while(p<r)\\n                {\\n                    if(key1!=s[p])\\n                        p++;\\n                    else\\n                        break;\\n                }\\n                q=r-1;\\n                while(q>l)\\n                {\\n                    if(key2!=s[q])\\n                        q--;\\n                    else\\n                        break;\\n                }\\n                if(q!=l&&p!=r)\\n                {\\n                    ans+=min(p-l,r-q);\\n                    if(p-l<r-q)\\n                    {\\n                        while(p>l)\\n                        {\\n                            swap(s[p],s[p-1]);\\n                            p--;\\n                        }    \\n                    }\\n                    else\\n                    {\\n                        while(r>q)\\n                        {\\n                            swap(s[q],s[q+1]);\\n                            q++;\\n                        }\\n                    }\\n                }\\n                else if(q!=l&&p==r)\\n                {\\n                    ans+=(r-q);\\n                    while(r>q)\\n                        {\\n                            swap(s[q],s[q+1]);\\n                            q++;\\n                        }\\n                }\\n                else\\n                {\\n                    ans+=(p-l);\\n                    while(p>l)\\n                        {\\n                            swap(s[p],s[p-1]);\\n                            p--;\\n                        }   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nit may not be optimised but i tried all possibilities",
                "solutionTags": [
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.length(),ans=0;\\n        int l=0,r=n-1;\\n        while(l<r)\\n        {\\n            int p,q;\\n            if(s[l]==s[r])\\n            {\\n                l++;\\n                r--;\\n            }\\n            else\\n            {\\n                int key1=s[r],key2=s[l];\\n                p=l+1;\\n                while(p<r)\\n                {\\n                    if(key1!=s[p])\\n                        p++;\\n                    else\\n                        break;\\n                }\\n                q=r-1;\\n                while(q>l)\\n                {\\n                    if(key2!=s[q])\\n                        q--;\\n                    else\\n                        break;\\n                }\\n                if(q!=l&&p!=r)\\n                {\\n                    ans+=min(p-l,r-q);\\n                    if(p-l<r-q)\\n                    {\\n                        while(p>l)\\n                        {\\n                            swap(s[p],s[p-1]);\\n                            p--;\\n                        }    \\n                    }\\n                    else\\n                    {\\n                        while(r>q)\\n                        {\\n                            swap(s[q],s[q+1]);\\n                            q++;\\n                        }\\n                    }\\n                }\\n                else if(q!=l&&p==r)\\n                {\\n                    ans+=(r-q);\\n                    while(r>q)\\n                        {\\n                            swap(s[q],s[q+1]);\\n                            q++;\\n                        }\\n                }\\n                else\\n                {\\n                    ans+=(p-l);\\n                    while(p>l)\\n                        {\\n                            swap(s[p],s[p-1]);\\n                            p--;\\n                        }   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258616,
                "title": "c-w-comments-2-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        int count=0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                int k=i;\\n                while(k<j && s[k]!=s[j]){\\n                    /*i\\'m finding the other pair of\\n                    the element which should be at opp position;*/\\n                    k++;\\n                }\\n                if(k==j){ \\n                    /* element is odd and should\\n                    be present at the middle of the string;*/\\n                    swap(s[j-1],s[j]);\\n                    count++;\\n                }\\n                else{\\n                    while(k>0 && s[i]!=s[j]){ \\n                        /*this loop will continue till the we\\'ve\\n                        not set both of the ends to be equal.*/\\n                        swap(s[k-1],s[k]);\\n                        count++;\\n                        k--;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int n=s.size();\\n        int i=0,j=n-1;\\n        int count=0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                int k=i;\\n                while(k<j && s[k]!=s[j]){\\n                    /*i\\'m finding the other pair of\\n                    the element which should be at opp position;*/\\n                    k++;\\n                }\\n                if(k==j){ \\n                    /* element is odd and should\\n                    be present at the middle of the string;*/\\n                    swap(s[j-1],s[j]);\\n                    count++;\\n                }\\n                else{\\n                    while(k>0 && s[i]!=s[j]){ \\n                        /*this loop will continue till the we\\'ve\\n                        not set both of the ends to be equal.*/\\n                        swap(s[k-1],s[k]);\\n                        count++;\\n                        k--;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2247603,
                "title": "two-pointer-solution",
                "content": "```\\n int minMovesToMakePalindrome(string s) {\\n        int i=0,j=s.length()-1;\\n        int ans=0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                int ind=-1;\\n\\t\\t\\t\\t//find the first index where they matches\\n                for(int k=i+1;k<j;k++){\\n                    if(s[k]==s[j]){\\n                        ind=k;\\n                        break;\\n                    }\\n                }\\n                if(ind!=-1){\\n\\t\\t\\t\\t//if we found then swap  them\\n                    for(int k=ind;k>i;k--){\\n                        swap(s[k],s[k-1]);\\n                        ans++;\\n                    }\\n                }\\n                else{\\n\\t\\t\\t\\t// this is odd no of char\\n                    swap(s[j],s[j-1]);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n int minMovesToMakePalindrome(string s) {\\n        int i=0,j=s.length()-1;\\n        int ans=0;\\n        while(i<j){\\n            if(s[i]==s[j]){\\n                i++;\\n                j--;\\n            }\\n            else{\\n                int ind=-1;\\n\\t\\t\\t\\t//find the first index where they matches\\n                for(int k=i+1;k<j;k++){\\n                    if(s[k]==s[j]){\\n                        ind=k;\\n                        break;\\n                    }\\n                }\\n                if(ind!=-1){\\n\\t\\t\\t\\t//if we found then swap  them\\n                    for(int k=ind;k>i;k--){\\n                        swap(s[k],s[k-1]);\\n                        ans++;\\n                    }\\n                }\\n                else{\\n\\t\\t\\t\\t// this is odd no of char\\n                    swap(s[j],s[j-1]);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2235103,
                "title": "c-two-pointer-solution",
                "content": "\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        long long l=0,e=s.size()-1;\\n        long long cnt=0;\\n        while(l<e)\\n        {\\n            int a=l,b=e;\\n            while(s[a]!=s[b])\\n            {\\n                b--;\\n            }\\n            \\n            if(a==b)\\n            {\\n                swap(s[b],s[b+1]);\\n                cnt++;\\n                continue;\\n            }\\n            else\\n            {\\n                while(b<e){\\n                swap(s[b],s[b+1]);\\n                cnt++;\\n                b++;\\n                }\\n            }\\n            //cout<<s<<\"\\\\n\";\\n            l++;e--;\\n        }\\n        \\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        long long l=0,e=s.size()-1;\\n        long long cnt=0;\\n        while(l<e)\\n        {\\n            int a=l,b=e;\\n            while(s[a]!=s[b])\\n            {\\n                b--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2120406,
                "title": "c-easy-recursion-o-n-n",
                "content": "class Solution {\\npublic:\\n    int find(string s)\\n    {\\n        int i=0,j=s.size()-1;\\n        if(s.size()==1)return 0;\\n        if(s[i]==s[j])\\n        {\\n            s.pop_back();\\n             if(s.size()==1)return 0;\\n            return find(s.substr(1));\\n        }\\n        else\\n        {\\n            int k=j;\\n            while(s[k]!=s[i])k--;\\n            int k2=i;\\n            while(s[k2]!=s[j])k2++;\\n            if(j-k<k2-i)\\n            {\\n                int t=j-k;\\n                while(k<j){swap(s[k],s[k+1]);k++;}\\n                s.pop_back();\\n                return find(s.substr(1))+t;\\n            }\\n            else\\n            {\\n                int t=k2-i;\\n                while(k2>0){swap(s[k2],s[k2-1]);k2--;}\\n                s.pop_back();\\n                return find(s.substr(1))+t;\\n            }\\n        }\\n    }\\n    int minMovesToMakePalindrome(string s) {\\n        return find(s);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int find(string s)\\n    {\\n        int i=0,j=s.size()-1;\\n        if(s.size()==1)return 0;\\n        if(s[i]==s[j])\\n        {\\n            s.pop_back();\\n             if(s.size()==1)return 0;\\n            return find(s.substr(1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2109119,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int count=0,te=0,counter=0;\\n        for(int j=0;j<s.length()/2;j++){\\n            int c=0;\\n            char temp=s[j];\\n            for(int i=s.size()-1-j;i>j;i--){\\n                if(s[i]==temp){\\n                    char t=s[i];\\n                    s.erase(s.size()-1-c-j,1);\\n                    s.insert(s.end()-j,t);\\n                    count+=c;\\n                    break;\\n                }else if(i==(j+1)){\\n                    te=j;\\n                    s.erase(s.begin()+j);\\n                    j--;\\n                    counter++;\\n                    break;\\n                }\\n              c++;\\n            }\\n         }\\n        if(counter!=0){\\n            count+=(s.size()/2)-te;\\n        }    \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int count=0,te=0,counter=0;\\n        for(int j=0;j<s.length()/2;j++){\\n            int c=0;\\n            char temp=s[j];\\n            for(int i=s.size()-1-j;i>j;i--){\\n                if(s[i]==temp){\\n                    char t=s[i];\\n                    s.erase(s.size()-1-c-j,1);\\n                    s.insert(s.end()-j,t);\\n                    count+=c;\\n                    break;\\n                }else if(i==(j+1)){\\n                    te=j;\\n                    s.erase(s.begin()+j);\\n                    j--;\\n                    counter++;\\n                    break;\\n                }\\n              c++;\\n            }\\n         }\\n        if(counter!=0){\\n            count+=(s.size()/2)-te;\\n        }    \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036420,
                "title": "c-solution",
                "content": "```\\nvoid findmin_ex(char* s, int now, int len, int* ans){\\n    while (now < len){\\n        while (s[len] == \\'A\\'){\\n            len--;\\n        }\\n        if(s[now] == s[len]){\\n            return;\\n        } else {\\n            int copy = now+1;\\n            if (s[copy] == \\'A\\'){\\n                *ans -= 1;\\n            }\\n            while(s[len] != s[copy]){\\n                copy++;\\n                if (s[copy] == \\'A\\'){\\n                    *ans -= 1;\\n                }\\n            }\\n            *ans += copy-now;\\n            s[copy] = \\'A\\';\\n            len--;\\n        }\\n    }\\n}\\n\\nvoid findmin(char* s, int now, int len, int* ans){\\n    while (now < len){\\n        while (s[now] == \\'A\\'){\\n            now++;\\n        }\\n        while (s[len] == \\'A\\'){\\n            len--;\\n        }\\n        if(s[now] == s[len]){\\n            now++;\\n            len--;\\n        } else {\\n            int copy = len-1;\\n            int copya = *ans;\\n            if (s[copy] == \\'A\\'){\\n                *ans -= 1;\\n            }\\n            while(s[now] != s[copy]){\\n                copy--;\\n                if (s[copy] == \\'A\\'){\\n                    *ans -= 1;\\n                }\\n            }\\n            if (copy != now){\\n                *ans += len-copy;\\n                s[copy] = \\'A\\';\\n            } else {\\n                *ans = copya;\\n                findmin_ex(s, now, len, ans);\\n                return;\\n            }\\n            now++;\\n        }\\n    }\\n}\\n\\nint minMovesToMakePalindrome(char * s){\\n    int len = strlen(s);\\n    int ans = 0;\\n    findmin(s, 0, len-1, &ans);\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid findmin_ex(char* s, int now, int len, int* ans){\\n    while (now < len){\\n        while (s[len] == \\'A\\'){\\n            len--;\\n        }\\n        if(s[now] == s[len]){\\n            return;\\n        } else {\\n            int copy = now+1;\\n            if (s[copy] == \\'A\\'){\\n                *ans -= 1;\\n            }\\n            while(s[len] != s[copy]){\\n                copy++;\\n                if (s[copy] == \\'A\\'){\\n                    *ans -= 1;\\n                }\\n            }\\n            *ans += copy-now;\\n            s[copy] = \\'A\\';\\n            len--;\\n        }\\n    }\\n}\\n\\nvoid findmin(char* s, int now, int len, int* ans){\\n    while (now < len){\\n        while (s[now] == \\'A\\'){\\n            now++;\\n        }\\n        while (s[len] == \\'A\\'){\\n            len--;\\n        }\\n        if(s[now] == s[len]){\\n            now++;\\n            len--;\\n        } else {\\n            int copy = len-1;\\n            int copya = *ans;\\n            if (s[copy] == \\'A\\'){\\n                *ans -= 1;\\n            }\\n            while(s[now] != s[copy]){\\n                copy--;\\n                if (s[copy] == \\'A\\'){\\n                    *ans -= 1;\\n                }\\n            }\\n            if (copy != now){\\n                *ans += len-copy;\\n                s[copy] = \\'A\\';\\n            } else {\\n                *ans = copya;\\n                findmin_ex(s, now, len, ans);\\n                return;\\n            }\\n            now++;\\n        }\\n    }\\n}\\n\\nint minMovesToMakePalindrome(char * s){\\n    int len = strlen(s);\\n    int ans = 0;\\n    findmin(s, 0, len-1, &ans);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1840252,
                "title": "c-2-pointers-solution",
                "content": "\\t int minMovesToMakePalindrome(string s) {\\n        int n = s.length(), l = 0, r = n - 1, ans = 0;\\n        \\n        while(l < r) {\\n            int i = l, j = r;\\n            \\n            if(s[i] == s[j])\\n            {\\n                l++;\\n                r--;\\n                continue;\\n            }\\n            \\n            while(s[j] != s[i])\\n                j--;\\n            \\n            if(i == j) {\\n                swap(s[j], s[j + 1]);\\n                ans++;\\n            }\\n            else {\\n                while(j < r) {\\n                    swap(s[j], s[j + 1]);\\n                    ans++;\\n                    j++;\\n                }\\n                \\n                l++;\\n                r--;\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\t int minMovesToMakePalindrome(string s) {\\n        int n = s.length(), l = 0, r = n - 1, ans = 0;\\n        \\n        while(l < r) {\\n            int i = l, j = r;\\n            \\n            if(s[i] == s[j])\\n            {\\n                l++;\\n                r--;\\n                continue;\\n            }\\n            \\n            while(s[j] != s[i])\\n                j--;\\n            \\n            if(i == j) {\\n                swap(s[j], s[j + 1]);\\n                ans++;\\n            }\\n            else {\\n                while(j < r) {\\n                    swap(s[j], s[j + 1]);\\n                    ans++;\\n                    j++;\\n                }\\n                \\n                l++;\\n                r--;\\n            }\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1834805,
                "title": "c-commented-solution-gready-time-o-n-2-space-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string a) {\\n       \\n        int n = a.size(),g,w,k1,k2;\\n        \\n        unordered_map<char,int> m;    // For maping every char of string\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            m[a[i]]++;\\n        }\\n        \\n        int ans =0 ,i =0 ,j= n-1;     // Two pointer one from start another from end of string\\n \\n        while(1)\\n        {\\n            j = n-i-1;\\n            if(i>=j)                          \\n                return ans;                  // Return ans if pointer i greater or equal to pointer j\\n            if(a[i]!=a[j])                     // If both pointer character are diffrent\\n            {\\n                \\n                w = -1 ;\\n                g= -1;\\n                k1 = INT_MAX;\\n                k2 = INT_MAX;\\n                for(int k=i+1;k<j;k++)              // Find same char as a[j] and store distance in variable\\n                {\\n                    if(a[k]==a[j])\\n                    {\\n                        k1 =(k-i);\\n                        g = k;\\n                        break;\\n                    }\\n                }\\n                    \\n                if(m[a[i]]!=1)                                 // If a[i] count is 1 means there is no more same char as a[i]\\n                {\\n                    for(int k=j-1;k>i;k--)            // Find same char as a[i] and store distance in variable\\n                    {\\n                        if(a[k]==a[i])\\n                        {\\n                            k2 = (j-k);\\n                            w = k;\\n                            break;\\n                        }\\n                    }\\n                   \\n                }\\n                \\n                if(k1<k2)                              // Select smallest distance\\n                {\\n                    for(int k=g-1;k>=i;k--)\\n                    {\\n                        swap(a[k],a[k+1]);                  // Swap to tiil ith position\\n                    }\\n                    m[a[j]]-=2;                                // Reduced char from map\\n                    ans += k1;                               // Add to ans\\n                }\\n                else\\n                {\\n                    for(int k=w+1;k<=j;k++)                  //  Swap to tiil jth position\\n                    {\\n                        swap(a[k],a[k-1]);\\n                    }\\n                    m[a[i]]-=2;                                             // Reduced char from map\\n                    ans += k2;                                              // Add to ans\\n                }\\n                \\n            }\\n            i++;\\n            \\n        }\\n        \\n        return ans;        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string a) {\\n       \\n        int n = a.size(),g,w,k1,k2;\\n        \\n        unordered_map<char,int> m;    // For maping every char of string\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            m[a[i]]++;\\n        }\\n        \\n        int ans =0 ,i =0 ,j= n-1;     // Two pointer one from start another from end of string\\n \\n        while(1)\\n        {\\n            j = n-i-1;\\n            if(i>=j)                          \\n                return ans;                  // Return ans if pointer i greater or equal to pointer j\\n            if(a[i]!=a[j])                     // If both pointer character are diffrent\\n            {\\n                \\n                w = -1 ;\\n                g= -1;\\n                k1 = INT_MAX;\\n                k2 = INT_MAX;\\n                for(int k=i+1;k<j;k++)              // Find same char as a[j] and store distance in variable\\n                {\\n                    if(a[k]==a[j])\\n                    {\\n                        k1 =(k-i);\\n                        g = k;\\n                        break;\\n                    }\\n                }\\n                    \\n                if(m[a[i]]!=1)                                 // If a[i] count is 1 means there is no more same char as a[i]\\n                {\\n                    for(int k=j-1;k>i;k--)            // Find same char as a[i] and store distance in variable\\n                    {\\n                        if(a[k]==a[i])\\n                        {\\n                            k2 = (j-k);\\n                            w = k;\\n                            break;\\n                        }\\n                    }\\n                   \\n                }\\n                \\n                if(k1<k2)                              // Select smallest distance\\n                {\\n                    for(int k=g-1;k>=i;k--)\\n                    {\\n                        swap(a[k],a[k+1]);                  // Swap to tiil ith position\\n                    }\\n                    m[a[j]]-=2;                                // Reduced char from map\\n                    ans += k1;                               // Add to ans\\n                }\\n                else\\n                {\\n                    for(int k=w+1;k<=j;k++)                  //  Swap to tiil jth position\\n                    {\\n                        swap(a[k],a[k-1]);\\n                    }\\n                    m[a[i]]-=2;                                             // Reduced char from map\\n                    ans += k2;                                              // Add to ans\\n                }\\n                \\n            }\\n            i++;\\n            \\n        }\\n        \\n        return ans;        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831236,
                "title": "removing-pairs-70-speed",
                "content": "![image](https://assets.leetcode.com/users/images/4fcc293d-ce6f-4f05-ae5d-44c3aff5ff27_1646750948.4992037.png)\\n```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0\\n\\n        def remove_edges(current: str) -> str:\\n            nonlocal ans\\n            left, right = dict(), dict()\\n            len_c1 = len(current) - 1\\n            for i, c in enumerate(current):\\n                if c in right and i != right[c]:\\n                    j = right[c]\\n                    i, j = (i, j) if i < j else (j, i)\\n                    ans += i + len_c1 - j\\n                    return f\"{current[:i]}{current[i + 1:j]}{current[j + 1:]}\"\\n                elif c not in left:\\n                    left[c] = i\\n                j = len_c1 - i\\n                right_c = current[j]\\n                if right_c in left and left[right_c] != j:\\n                    i = left[right_c]\\n                    i, j = (i, j) if i < j else (j, i)\\n                    ans += i + len_c1 - j\\n                    return f\"{current[:i]}{current[i + 1:j]}{current[j + 1:]}\"\\n                elif right_c not in right:\\n                    right[right_c] = j\\n\\n            return \"\"\\n\\n        while len(s) > 2:\\n            s = remove_edges(s)\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        ans = 0\\n\\n        def remove_edges(current: str) -> str:\\n            nonlocal ans\\n            left, right = dict(), dict()\\n            len_c1 = len(current) - 1\\n            for i, c in enumerate(current):\\n                if c in right and i != right[c]:\\n                    j = right[c]\\n                    i, j = (i, j) if i < j else (j, i)\\n                    ans += i + len_c1 - j\\n                    return f\"{current[:i]}{current[i + 1:j]}{current[j + 1:]}\"\\n                elif c not in left:\\n                    left[c] = i\\n                j = len_c1 - i\\n                right_c = current[j]\\n                if right_c in left and left[right_c] != j:\\n                    i = left[right_c]\\n                    i, j = (i, j) if i < j else (j, i)\\n                    ans += i + len_c1 - j\\n                    return f\"{current[:i]}{current[i + 1:j]}{current[j + 1:]}\"\\n                elif right_c not in right:\\n                    right[right_c] = j\\n\\n            return \"\"\\n\\n        while len(s) > 2:\\n            s = remove_edges(s)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830972,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) \\n    {\\n        int n=s.size();\\n        int step=0;\\n        int left=0;\\n        int right=n-1;\\n        while(left<right)\\n        {\\n            int l=left;\\n            int r=right;\\n            while(s[l]!=s[r])\\n            {\\n                r--;\\n            }\\n            if(l==r)\\n            {\\n                swap(s[l],s[l+1]);\\n                step++;\\n            }\\n            else\\n            {\\n            for(int i=r;i<right;i++)\\n            {\\n                swap(s[i],s[i+1]);\\n                step++;\\n            }\\n            left++;\\n            right--;\\n            }\\n        }\\n        return step;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) \\n    {\\n        int n=s.size();\\n        int step=0;\\n        int left=0;\\n        int right=n-1;\\n        while(left<right)\\n        {\\n            int l=left;\\n            int r=right;\\n            while(s[l]!=s[r])\\n            {\\n                r--;\\n            }\\n            if(l==r)\\n            {\\n                swap(s[l],s[l+1]);\\n                step++;\\n            }\\n            else\\n            {\\n            for(int i=r;i<right;i++)\\n            {\\n                swap(s[i],s[i+1]);\\n                step++;\\n            }\\n            left++;\\n            right--;\\n            }\\n        }\\n        return step;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828107,
                "title": "c-what-is-issue-in-this-solution",
                "content": "Can someone chech, what is issue in this code?\\n\\n\\tpublic int MinMovesToMakePalindrome(string s) {\\n        char[] chr = new char[s.Length];\\n        for(int index=0; index<s.Length; index++){\\n            chr[index] = s[index];\\n        }\\n        \\n        int j = s.Length-1;\\n        int i = 0;\\n        int moves = 0;\\n        while(i<j){\\n            if(chr[i]!=chr[j]){\\n                int k = j;\\n                while(k>i){\\n                    if(chr[k]==chr[i]){\\n                        char ch = chr[k];\\n                        chr[k] = chr[j];\\n                        chr[j] = ch;                        \\n                        moves = moves + (j-k);                        \\n                        break;\\n                    }\\n                 k--;\\n                }\\n                if(i==k){\\n                    char ch2 = chr[s.Length/2];\\n                    chr[s.Length/2] = chr[i];\\n                    chr[i] = ch2;                    \\n                    moves = moves + (s.Length/2-i);                    \\n                    continue;\\n                }\\n            }\\n            i++;\\n            j = s.Length-1 - i;\\n        }\\n        return moves;\\n    }",
                "solutionTags": [],
                "code": "Can someone chech, what is issue in this code?\\n\\n\\tpublic int MinMovesToMakePalindrome(string s) {\\n        char[] chr = new char[s.Length];\\n        for(int index=0; index<s.Length; index++){\\n            chr[index] = s[index];\\n        }\\n        \\n        int j = s.Length-1;\\n        int i = 0;\\n        int moves = 0;\\n        while(i<j){\\n            if(chr[i]!=chr[j]){\\n                int k = j;\\n                while(k>i){\\n                    if(chr[k]==chr[i]){\\n                        char ch = chr[k];\\n                        chr[k] = chr[j];\\n                        chr[j] = ch;                        \\n                        moves = moves + (j-k);                        \\n                        break;\\n                    }\\n                 k--;\\n                }\\n                if(i==k){\\n                    char ch2 = chr[s.Length/2];\\n                    chr[s.Length/2] = chr[i];\\n                    chr[i] = ch2;                    \\n                    moves = moves + (s.Length/2-i);                    \\n                    continue;\\n                }\\n            }\\n            i++;\\n            j = s.Length-1 - i;\\n        }\\n        return moves;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1827913,
                "title": "cpp-simple-greedy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int pos = 0;\\n        \\n        int ans = 0;\\n        while(pos < s.size()){\\n            if(pos == s.size() - 1 || pos == s.size()-2) break;\\n            int cpos = s.size()-1;\\n            \\n            while(s[cpos] != s[pos]) cpos--;\\n            \\n            if(cpos == pos){\\n                swap(s[pos], s[pos+1]);\\n                ans++;\\n                continue;\\n            }\\n            \\n            while(cpos != s.size()-1){\\n                swap(s[cpos], s[cpos+1]);\\n                cpos++;\\n                ans++;\\n            }\\n            \\n            pos++;\\n            s.pop_back();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int pos = 0;\\n        \\n        int ans = 0;\\n        while(pos < s.size()){\\n            if(pos == s.size() - 1 || pos == s.size()-2) break;\\n            int cpos = s.size()-1;\\n            \\n            while(s[cpos] != s[pos]) cpos--;\\n            \\n            if(cpos == pos){\\n                swap(s[pos], s[pos+1]);\\n                ans++;\\n                continue;\\n            }\\n            \\n            while(cpos != s.size()-1){\\n                swap(s[cpos], s[cpos+1]);\\n                cpos++;\\n                ans++;\\n            }\\n            \\n            pos++;\\n            s.pop_back();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826144,
                "title": "java-easy-to-understand-solution",
                "content": "```\\n\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int l = 0;\\n        int r = s.length() - 1;\\n        char[] charArray = s.toCharArray();\\n        int output = 0;\\n        while(l < r){\\n            if(charArray[l] == charArray[r]){\\n                l++;\\n                r--;\\n            }else{\\n                char prev = charArray[l];\\n                int k = r;\\n                while(charArray[k] != prev){\\n                    k--;\\n                }\\n                //middle element\\n                if(k == l){\\n                    char temp = charArray[l];\\n                    charArray[l] = charArray[l+1];\\n                    charArray[l+1] = temp; \\n                    output++;\\n                    continue;\\n                }\\n                \\n                for(int i = k;i<r;i++){\\n                    char temp = charArray[i];\\n                    charArray[i] = charArray[i+1];\\n                    charArray[i+1] = temp;\\n                    output++;\\n                }\\n                l++;\\n                r--;\\n            }\\n        }\\n        \\n        return output;\\n        \\n    }\\n}```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        int l = 0;\\n        int r = s.length() - 1;\\n        char[] charArray = s.toCharArray();\\n        int output = 0;\\n        while(l < r){\\n            if(charArray[l] == charArray[r]){\\n                l++;\\n                r--;\\n            }else{\\n                char prev = charArray[l];\\n                int k = r;\\n                while(charArray[k] != prev){\\n                    k--;\\n                }\\n                //middle element\\n                if(k == l){\\n                    char temp = charArray[l];\\n                    charArray[l] = charArray[l+1];\\n                    charArray[l+1] = temp; \\n                    output++;\\n                    continue;\\n                }\\n                \\n                for(int i = k;i<r;i++){\\n                    char temp = charArray[i];\\n                    charArray[i] = charArray[i+1];\\n                    charArray[i+1] = temp;\\n                    output++;\\n                }\\n                l++;\\n                r--;\\n            }\\n        }\\n        \\n        return output;\\n        \\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1826026,
                "title": "python-3-basic-1000ms",
                "content": "```\\nclass Solution:\\n    @lru_cache(None)\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n = len(s)\\n        if n<=1:\\n            return 0\\n        if s[0] == s[-1]:\\n            return self.minMovesToMakePalindrome(s[1:-1])\\n        i = 1\\n        while s[i]!=s[-1]:\\n            i+=1\\n        j = n - 2\\n        while s[j]!=s[0]:\\n            j-=1\\n        if i <= n - 1 - j:\\n            return i + self.minMovesToMakePalindrome(s[:i]+s[i+1:-1])\\n        else:\\n            return n - 1 - j + self.minMovesToMakePalindrome(s[1:j]+s[j+1:])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    @lru_cache(None)\\n    def minMovesToMakePalindrome(self, s: str) -> int:\\n        n = len(s)\\n        if n<=1:\\n            return 0\\n        if s[0] == s[-1]:\\n            return self.minMovesToMakePalindrome(s[1:-1])\\n        i = 1\\n        while s[i]!=s[-1]:\\n            i+=1\\n        j = n - 2\\n        while s[j]!=s[0]:\\n            j-=1\\n        if i <= n - 1 - j:\\n            return i + self.minMovesToMakePalindrome(s[:i]+s[i+1:-1])\\n        else:\\n            return n - 1 - j + self.minMovesToMakePalindrome(s[1:j]+s[j+1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1824278,
                "title": "c-o-n2-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int l=0,r=s.length()-1;\\n        int ans=0;\\n        while(l<r){\\n           if(s[l]!=s[r]){\\n               int rr=r-1;\\n               while(s[rr]!=s[l])\\n                   rr--;\\n               int ll=l;\\n               while(s[ll]!=s[r])\\n                   ll++;\\n               int a=r-rr,b=ll-l;\\n               if(a<b){\\n                   s.erase(begin(s)+rr);\\n                   ans+=a;\\n                   r--;l++;\\n               }\\n               else{\\n                   s.erase(begin(s)+ll);\\n                   ans+=b;\\n                   r-=2;  \\n               }\\n           } \\n            else{\\n                l++;r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int l=0,r=s.length()-1;\\n        int ans=0;\\n        while(l<r){\\n           if(s[l]!=s[r]){\\n               int rr=r-1;\\n               while(s[rr]!=s[l])\\n                   rr--;\\n               int ll=l;\\n               while(s[ll]!=s[r])\\n                   ll++;\\n               int a=r-rr,b=ll-l;\\n               if(a<b){\\n                   s.erase(begin(s)+rr);\\n                   ans+=a;\\n                   r--;l++;\\n               }\\n               else{\\n                   s.erase(begin(s)+ll);\\n                   ans+=b;\\n                   r-=2;  \\n               }\\n           } \\n            else{\\n                l++;r--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823273,
                "title": "c-greedy-o-n-2",
                "content": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        const auto shift_fwd = [&s](int idx_src, int idx_dest) {\\n            const char val = s[idx_src];\\n            for (int i = idx_src; i + 1 <= idx_dest; ++i) {\\n                s[i] = s[i + 1];\\n            }\\n            s[idx_dest] = val;\\n        };        \\n\\n        const auto shift_rev = [&s](int idx_src, int idx_dest) {\\n            const char val = s[idx_src];\\n            for (int i = idx_src; i - 1 >= idx_dest; --i) {\\n                s[i] = s[i - 1];\\n            }\\n            s[idx_dest] = val;\\n        };        \\n        \\n        const auto shift = [&](int idx_src, int idx_dest) {\\n            if (idx_src < idx_dest) {\\n                shift_fwd(idx_src, idx_dest);\\n            } else if (idx_src > idx_dest) {\\n                shift_rev(idx_src, idx_dest);\\n            }\\n        };        \\n        \\n        int total_ops = 0; \\n        int i = 0, j = s.size() - 1;\\n        for (; i < j; ++i, --j) {\\n            if (s[i] == s[j]) {\\n                continue;\\n            }\\n\\n            int lhs_ops = INT_MAX;\\n            int lhs_k = -1;\\n            {\\n                int k = j - 1;            \\n                for (; k > i; --k) {\\n                    if (s[k] == s[i]) {\\n                        break;\\n                    }\\n                }\\n                if (k != i) {\\n                    lhs_k = k;\\n                    lhs_ops = j - k;\\n                }\\n            }\\n\\n            int rhs_ops = INT_MAX;\\n            int rhs_k = -1;\\n            {\\n                int k = i + 1;\\n                for (; k < j; ++k) {\\n                    if (s[k] == s[j]) {\\n                        break;\\n                    }\\n                }\\n                if (k != j) {\\n                    rhs_k = k;\\n                    rhs_ops = k - i;\\n                }\\n            }\\n\\n            if (lhs_ops < rhs_ops) {\\n                total_ops += lhs_ops;\\n                shift(lhs_k, j);\\n            } else {\\n                total_ops += rhs_ops;\\n                shift(rhs_k, i);\\n            }\\n        }            \\n        \\n        return total_ops;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        const auto shift_fwd = [&s](int idx_src, int idx_dest) {\\n            const char val = s[idx_src];\\n            for (int i = idx_src; i + 1 <= idx_dest; ++i) {\\n                s[i] = s[i + 1];\\n            }\\n            s[idx_dest] = val;\\n        };        \\n\\n        const auto shift_rev = [&s](int idx_src, int idx_dest) {\\n            const char val = s[idx_src];\\n            for (int i = idx_src; i - 1 >= idx_dest; --i) {\\n                s[i] = s[i - 1];\\n            }\\n            s[idx_dest] = val;\\n        };        \\n        \\n        const auto shift = [&](int idx_src, int idx_dest) {\\n            if (idx_src < idx_dest) {\\n                shift_fwd(idx_src, idx_dest);\\n            } else if (idx_src > idx_dest) {\\n                shift_rev(idx_src, idx_dest);\\n            }\\n        };        \\n        \\n        int total_ops = 0; \\n        int i = 0, j = s.size() - 1;\\n        for (; i < j; ++i, --j) {\\n            if (s[i] == s[j]) {\\n                continue;\\n            }\\n\\n            int lhs_ops = INT_MAX;\\n            int lhs_k = -1;\\n            {\\n                int k = j - 1;            \\n                for (; k > i; --k) {\\n                    if (s[k] == s[i]) {\\n                        break;\\n                    }\\n                }\\n                if (k != i) {\\n                    lhs_k = k;\\n                    lhs_ops = j - k;\\n                }\\n            }\\n\\n            int rhs_ops = INT_MAX;\\n            int rhs_k = -1;\\n            {\\n                int k = i + 1;\\n                for (; k < j; ++k) {\\n                    if (s[k] == s[j]) {\\n                        break;\\n                    }\\n                }\\n                if (k != j) {\\n                    rhs_k = k;\\n                    rhs_ops = k - i;\\n                }\\n            }\\n\\n            if (lhs_ops < rhs_ops) {\\n                total_ops += lhs_ops;\\n                shift(lhs_k, j);\\n            } else {\\n                total_ops += rhs_ops;\\n                shift(rhs_k, i);\\n            }\\n        }            \\n        \\n        return total_ops;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1823058,
                "title": "two-pointer-approach-c",
                "content": "\\n``` \\nint minMovesToMakePalindrome(string s) {\\n        int moves = 0;\\n        int i =0 , j = s.length()-1;\\n        while(i < j)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                i++;\\n                j--;\\n            }\\n            else{\\n                int k = j-1;\\n                while(s[k]!=s[i])\\n                {\\n                    k--;   \\n                }\\n                if(k==i)\\n                {\\n                    swap(s[k],s[k+1]);\\n                    moves++;\\n                    continue;\\n                }\\n                else{\\n                     while(k < j)\\n                    {\\n                        swap(s[k],s[k+1]);\\n                        k++;\\n                        moves++;\\n                    }\\n                }\\n                i++;\\n                j--;\\n            }\\n        }\\n        return moves;\\n    }",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "\\n``` \\nint minMovesToMakePalindrome(string s) {\\n        int moves = 0;\\n        int i =0 , j = s.length()-1;\\n        while(i < j)\\n        {\\n            if(s[i]==s[j])\\n            {\\n                i++;\\n                j--;\\n            }\\n            else{\\n                int k = j-1;\\n                while(s[k]!=s[i])\\n                {\\n                    k--;   \\n                }\\n                if(k==i)\\n                {\\n                    swap(s[k],s[k+1]);\\n                    moves++;\\n                    continue;\\n                }\\n                else{\\n                     while(k < j)\\n                    {\\n                        swap(s[k],s[k+1]);\\n                        k++;\\n                        moves++;\\n                    }\\n                }\\n                i++;\\n                j--;\\n            }\\n        }\\n        return moves;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1823036,
                "title": "java-solution-o-n-2",
                "content": "````\\nclass Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        char[] cArr = s.toCharArray();\\n        int i = 0, j = s.length() - 1, count = 0;\\n        while(i < j) {\\n            \\n            /// character at begin equal with character at the end, move forward\\n            if (cArr[i] == cArr[j]) {\\n                i++;\\n                j--;\\n            } else {\\n                /*\\n                character at begin not equal with character at the end so we need to move the first \\n                character equal with start from the end\\n                \\n                Two case here:\\n                1. we able to find a character from the end that match with current start character theb\\n                we could swap them\\n                2. we unable to find the character match with current start character\\n                then we should move current start to the middle\\n                For example: abb => bab\\n                */\\n                \\n                ///find the first position from the end that match with character from start\\n                int k = j;\\n                while(k > i && cArr[k] != cArr[i]) {\\n                    k--;\\n                }\\n                \\n                /// we don\\'t found anything, so we need to move start to middle\\n                if (k == i) {\\n                    swap(cArr, i, i + 1);\\n                    count++;\\n                } else {\\n                    /// we found a first character that match with start character\\n                    while(k < j) {\\n                        swap(cArr, k, k + 1);\\n                        k++;\\n                        count++;\\n                    }\\n                    i++;\\n                    j--;\\n                }\\n                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    private void swap(char[] cArr, int i, int j) {\\n        char ch = cArr[i];\\n        cArr[i] = cArr[j];\\n        cArr[j] = ch;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minMovesToMakePalindrome(String s) {\\n        \\n        char[] cArr = s.toCharArray();\\n        int i = 0, j = s.length() - 1, count = 0;\\n        while(i < j) {\\n            \\n            /// character at begin equal with character at the end, move forward\\n            if (cArr[i] == cArr[j]) {\\n                i++;\\n                j--;\\n            }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1576538,
                "content": [
                    {
                        "username": "talkingraisin",
                        "content": "If people are looking for a formal proof, I have written one up [here](https://drive.google.com/file/d/13t_upAk8NEesACY7THM190HkQeiMy2he/view?usp=sharing)."
                    },
                    {
                        "username": "veecos1",
                        "content": "Think greedily"
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "This problem was copied!\\n\\nHere is the link: \\nhttps://molchevskyi.medium.com/best-solutions-for-microsoft-interview-tasks-min-swaps-to-make-palindrome-e931689f8cae"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "Why it is not dp , plz explain?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Definitely not a one which can come up !!"
                    },
                    {
                        "username": "manju_nadha",
                        "content": " `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int lt=0,rt=s.size()-1;\\n        int count=0;\\n        while(lt<rt)\\n        {    int i=lt,j=rt;\\n             while(s[i]!=s[j])\\n             {j--;}\\n             if(i==j)\\n               {while(i<=s.size()/2-1)\\n                 {swap(s[i],s[i+1]);\\n                 count++;\\n                  i++;\\n                 }\\n                 continue;\\n               }\\n               else{\\n                   while(j<rt)\\n                   {swap(s[j],s[j+1]);\\n                   count++;\\n                   j++;}\\n               }\\n                lt++,rt--;\\n        }\\n       \\n          return count;\\n    }\\n  \\n};\\n`this code is working for 91 cases out of 129 can anyone find the error in the logic "
                    }
                ]
            },
            {
                "id": 1648169,
                "content": [
                    {
                        "username": "talkingraisin",
                        "content": "If people are looking for a formal proof, I have written one up [here](https://drive.google.com/file/d/13t_upAk8NEesACY7THM190HkQeiMy2he/view?usp=sharing)."
                    },
                    {
                        "username": "veecos1",
                        "content": "Think greedily"
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "This problem was copied!\\n\\nHere is the link: \\nhttps://molchevskyi.medium.com/best-solutions-for-microsoft-interview-tasks-min-swaps-to-make-palindrome-e931689f8cae"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "Why it is not dp , plz explain?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Definitely not a one which can come up !!"
                    },
                    {
                        "username": "manju_nadha",
                        "content": " `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int lt=0,rt=s.size()-1;\\n        int count=0;\\n        while(lt<rt)\\n        {    int i=lt,j=rt;\\n             while(s[i]!=s[j])\\n             {j--;}\\n             if(i==j)\\n               {while(i<=s.size()/2-1)\\n                 {swap(s[i],s[i+1]);\\n                 count++;\\n                  i++;\\n                 }\\n                 continue;\\n               }\\n               else{\\n                   while(j<rt)\\n                   {swap(s[j],s[j+1]);\\n                   count++;\\n                   j++;}\\n               }\\n                lt++,rt--;\\n        }\\n       \\n          return count;\\n    }\\n  \\n};\\n`this code is working for 91 cases out of 129 can anyone find the error in the logic "
                    }
                ]
            },
            {
                "id": 1568739,
                "content": [
                    {
                        "username": "talkingraisin",
                        "content": "If people are looking for a formal proof, I have written one up [here](https://drive.google.com/file/d/13t_upAk8NEesACY7THM190HkQeiMy2he/view?usp=sharing)."
                    },
                    {
                        "username": "veecos1",
                        "content": "Think greedily"
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "This problem was copied!\\n\\nHere is the link: \\nhttps://molchevskyi.medium.com/best-solutions-for-microsoft-interview-tasks-min-swaps-to-make-palindrome-e931689f8cae"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "Why it is not dp , plz explain?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Definitely not a one which can come up !!"
                    },
                    {
                        "username": "manju_nadha",
                        "content": " `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int lt=0,rt=s.size()-1;\\n        int count=0;\\n        while(lt<rt)\\n        {    int i=lt,j=rt;\\n             while(s[i]!=s[j])\\n             {j--;}\\n             if(i==j)\\n               {while(i<=s.size()/2-1)\\n                 {swap(s[i],s[i+1]);\\n                 count++;\\n                  i++;\\n                 }\\n                 continue;\\n               }\\n               else{\\n                   while(j<rt)\\n                   {swap(s[j],s[j+1]);\\n                   count++;\\n                   j++;}\\n               }\\n                lt++,rt--;\\n        }\\n       \\n          return count;\\n    }\\n  \\n};\\n`this code is working for 91 cases out of 129 can anyone find the error in the logic "
                    }
                ]
            },
            {
                "id": 1978877,
                "content": [
                    {
                        "username": "talkingraisin",
                        "content": "If people are looking for a formal proof, I have written one up [here](https://drive.google.com/file/d/13t_upAk8NEesACY7THM190HkQeiMy2he/view?usp=sharing)."
                    },
                    {
                        "username": "veecos1",
                        "content": "Think greedily"
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "This problem was copied!\\n\\nHere is the link: \\nhttps://molchevskyi.medium.com/best-solutions-for-microsoft-interview-tasks-min-swaps-to-make-palindrome-e931689f8cae"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "Why it is not dp , plz explain?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Definitely not a one which can come up !!"
                    },
                    {
                        "username": "manju_nadha",
                        "content": " `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int lt=0,rt=s.size()-1;\\n        int count=0;\\n        while(lt<rt)\\n        {    int i=lt,j=rt;\\n             while(s[i]!=s[j])\\n             {j--;}\\n             if(i==j)\\n               {while(i<=s.size()/2-1)\\n                 {swap(s[i],s[i+1]);\\n                 count++;\\n                  i++;\\n                 }\\n                 continue;\\n               }\\n               else{\\n                   while(j<rt)\\n                   {swap(s[j],s[j+1]);\\n                   count++;\\n                   j++;}\\n               }\\n                lt++,rt--;\\n        }\\n       \\n          return count;\\n    }\\n  \\n};\\n`this code is working for 91 cases out of 129 can anyone find the error in the logic "
                    }
                ]
            },
            {
                "id": 1909870,
                "content": [
                    {
                        "username": "talkingraisin",
                        "content": "If people are looking for a formal proof, I have written one up [here](https://drive.google.com/file/d/13t_upAk8NEesACY7THM190HkQeiMy2he/view?usp=sharing)."
                    },
                    {
                        "username": "veecos1",
                        "content": "Think greedily"
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "This problem was copied!\\n\\nHere is the link: \\nhttps://molchevskyi.medium.com/best-solutions-for-microsoft-interview-tasks-min-swaps-to-make-palindrome-e931689f8cae"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "Why it is not dp , plz explain?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Definitely not a one which can come up !!"
                    },
                    {
                        "username": "manju_nadha",
                        "content": " `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int lt=0,rt=s.size()-1;\\n        int count=0;\\n        while(lt<rt)\\n        {    int i=lt,j=rt;\\n             while(s[i]!=s[j])\\n             {j--;}\\n             if(i==j)\\n               {while(i<=s.size()/2-1)\\n                 {swap(s[i],s[i+1]);\\n                 count++;\\n                  i++;\\n                 }\\n                 continue;\\n               }\\n               else{\\n                   while(j<rt)\\n                   {swap(s[j],s[j+1]);\\n                   count++;\\n                   j++;}\\n               }\\n                lt++,rt--;\\n        }\\n       \\n          return count;\\n    }\\n  \\n};\\n`this code is working for 91 cases out of 129 can anyone find the error in the logic "
                    }
                ]
            },
            {
                "id": 1710073,
                "content": [
                    {
                        "username": "talkingraisin",
                        "content": "If people are looking for a formal proof, I have written one up [here](https://drive.google.com/file/d/13t_upAk8NEesACY7THM190HkQeiMy2he/view?usp=sharing)."
                    },
                    {
                        "username": "veecos1",
                        "content": "Think greedily"
                    },
                    {
                        "username": "gravity_destroyer",
                        "content": "This problem was copied!\\n\\nHere is the link: \\nhttps://molchevskyi.medium.com/best-solutions-for-microsoft-interview-tasks-min-swaps-to-make-palindrome-e931689f8cae"
                    },
                    {
                        "username": "vishal_v31",
                        "content": "Why it is not dp , plz explain?"
                    },
                    {
                        "username": "tejasX",
                        "content": "Definitely not a one which can come up !!"
                    },
                    {
                        "username": "manju_nadha",
                        "content": " `your inline code...your inline code...\\nclass Solution {\\npublic:\\n    int minMovesToMakePalindrome(string s) {\\n        int lt=0,rt=s.size()-1;\\n        int count=0;\\n        while(lt<rt)\\n        {    int i=lt,j=rt;\\n             while(s[i]!=s[j])\\n             {j--;}\\n             if(i==j)\\n               {while(i<=s.size()/2-1)\\n                 {swap(s[i],s[i+1]);\\n                 count++;\\n                  i++;\\n                 }\\n                 continue;\\n               }\\n               else{\\n                   while(j<rt)\\n                   {swap(s[j],s[j+1]);\\n                   count++;\\n                   j++;}\\n               }\\n                lt++,rt--;\\n        }\\n       \\n          return count;\\n    }\\n  \\n};\\n`this code is working for 91 cases out of 129 can anyone find the error in the logic "
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Weighted Subgraph With the Required Paths",
        "question_content": "<p>You are given an integer <code>n</code> denoting the number of nodes of a <strong>weighted directed</strong> graph. The nodes are numbered from <code>0</code> to <code>n - 1</code>.</p>\n\n<p>You are also given a 2D integer array <code>edges</code> where <code>edges[i] = [from<sub>i</sub>, to<sub>i</sub>, weight<sub>i</sub>]</code> denotes that there exists a <strong>directed</strong> edge from <code>from<sub>i</sub></code> to <code>to<sub>i</sub></code> with weight <code>weight<sub>i</sub></code>.</p>\n\n<p>Lastly, you are given three <strong>distinct</strong> integers <code>src1</code>, <code>src2</code>, and <code>dest</code> denoting three distinct nodes of the graph.</p>\n\n<p>Return <em>the <strong>minimum weight</strong> of a subgraph of the graph such that it is <strong>possible</strong> to reach</em> <code>dest</code> <em>from both</em> <code>src1</code> <em>and</em> <code>src2</code> <em>via a set of edges of this subgraph</em>. In case such a subgraph does not exist, return <code>-1</code>.</p>\n\n<p>A <strong>subgraph</strong> is a graph whose vertices and edges are subsets of the original graph. The <strong>weight</strong> of a subgraph is the sum of weights of its constituent edges.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/17/example1drawio.png\" style=\"width: 263px; height: 250px;\" />\n<pre>\n<strong>Input:</strong> n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5\n<strong>Output:</strong> 9\n<strong>Explanation:</strong>\nThe above figure represents the input graph.\nThe blue edges represent one of the subgraphs that yield the optimal answer.\nNote that the subgraph [[1,0,3],[0,5,6]] also yields the optimal answer. It is not possible to get a subgraph with less weight satisfying all the constraints.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/02/17/example2-1drawio.png\" style=\"width: 350px; height: 51px;\" />\n<pre>\n<strong>Input:</strong> n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2\n<strong>Output:</strong> -1\n<strong>Explanation:</strong>\nThe above figure represents the input graph.\nIt can be seen that there does not exist any path from node 1 to node 2, hence there are no subgraphs satisfying all the constraints.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>3 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= edges.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>edges[i].length == 3</code></li>\n\t<li><code>0 &lt;= from<sub>i</sub>, to<sub>i</sub>, src1, src2, dest &lt;= n - 1</code></li>\n\t<li><code>from<sub>i</sub> != to<sub>i</sub></code></li>\n\t<li><code>src1</code>, <code>src2</code>, and <code>dest</code> are pairwise distinct.</li>\n\t<li><code>1 &lt;= weight[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1844130,
                "title": "python-3-dijkstras-explained",
                "content": "The idea is the following: paths from `s1` to `dest` and from `s2` to dest` can have common point `x`. Then we need to reach:\\n1. From `s1` to `x`, for this we use Dijkstra\\n2. From `s2` to `x`, same.\\n3. From `x` to dest, for this we use Dijkstra on the reversed graph.\\n4. Finally, we check all possible `x`.\\n\\n#### Remark\\nIn python it was quite challenging to get **AC**, and I need to look for faster implementation of Dijkstra, however complexity is still the same, it depends on implementation details.\\n\\n#### Complexity\\nIt is `O(n*log E)` for time and `O(n)` for space.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minimumWeight(self, n, edges, s1, s2, dest):\\n        G1 = defaultdict(list)\\n        G2 = defaultdict(list)\\n        for a, b, w in edges:\\n            G1[a].append((b, w))\\n            G2[b].append((a, w))\\n\\n        def Dijkstra(graph, K):\\n            q, t = [(0, K)], {}\\n            while q:\\n                time, node = heappop(q)\\n                if node not in t:\\n                    t[node] = time\\n                    for v, w in graph[node]:\\n                        heappush(q, (time + w, v))\\n            return [t.get(i, float(\"inf\")) for i in range(n)]\\n        \\n        arr1 = Dijkstra(G1, s1)\\n        arr2 = Dijkstra(G1, s2)\\n        arr3 = Dijkstra(G2, dest)\\n        \\n        ans = float(\"inf\")\\n        for i in range(n):\\n            ans = min(ans, arr1[i] + arr2[i] + arr3[i])\\n        \\n        return ans if ans != float(\"inf\") else -1\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumWeight(self, n, edges, s1, s2, dest):\\n        G1 = defaultdict(list)\\n        G2 = defaultdict(list)\\n        for a, b, w in edges:\\n            G1[a].append((b, w))\\n            G2[b].append((a, w))\\n\\n        def Dijkstra(graph, K):\\n            q, t = [(0, K)], {}\\n            while q:\\n                time, node = heappop(q)\\n                if node not in t:\\n                    t[node] = time\\n                    for v, w in graph[node]:\\n                        heappush(q, (time + w, v))\\n            return [t.get(i, float(\"inf\")) for i in range(n)]\\n        \\n        arr1 = Dijkstra(G1, s1)\\n        arr2 = Dijkstra(G1, s2)\\n        arr3 = Dijkstra(G2, dest)\\n        \\n        ans = float(\"inf\")\\n        for i in range(n):\\n            ans = min(ans, arr1[i] + arr2[i] + arr3[i])\\n        \\n        return ans if ans != float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844091,
                "title": "c-dijkstra-3-times-with-illustration",
                "content": "\\n\\nSee my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Dijkstra\\n\\nDo Dijkstra 3 times.\\n\\nFirst time: store the shortest distance from node `a` to all other nodes in array `da`.\\n\\nSecond time: store the shortest distance from node `b` to all other nodes in array `db`.\\n\\nThird time: store the shortest distance from node `dest` to all other nodes **via Reversed Graph** in array `dd`.\\n\\nThe answer is the minimum `da[i] + db[i] + dd[i]` (`0 <= i < N`).\\n\\n![image](https://assets.leetcode.com/users/images/7b9e5795-cbbe-436d-aae0-53d97a4d15a6_1647161324.3176203.png)\\n\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-284/problems/minimum-weighted-subgraph-with-the-required-paths/\\n// Author: github.com/lzl124631x\\n// Time: O(ElogE + N)\\n// Space: O(E)\\nclass Solution {\\n    typedef pair<long, long> ipair;\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& E, int a, int b, int dest) {\\n        vector<vector<ipair>> G(n), R(n); // `G` is the original graph. `R` is the reversed graph\\n        for (auto &e : E) {\\n            long u = e[0], v = e[1], w = e[2];\\n            G[u].emplace_back(v, w);\\n            R[v].emplace_back(u, w);\\n        }\\n        vector<long> da(n, LONG_MAX), db(n, LONG_MAX), dd(n, LONG_MAX);\\n        auto solve = [&](vector<vector<ipair>> &G, int a, vector<long> &dist) {\\n            priority_queue<ipair, vector<ipair>, greater<ipair>> pq;\\n            dist[a] = 0;\\n            pq.emplace(0, a);\\n            while (pq.size()) {\\n                auto [cost, u] = pq.top();\\n                pq.pop();\\n                if (cost > dist[u]) continue;\\n                for (auto &[v, c] : G[u]) {\\n                    if (dist[v] > dist[u] + c) {\\n                        dist[v] = dist[u] + c;\\n                        pq.emplace(dist[v], v);\\n                    }\\n                }\\n            }\\n        };\\n        solve(G, a, da);\\n        solve(G, b, db);\\n        solve(R, dest, dd);\\n        long ans = LONG_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            if (da[i] == LONG_MAX || db[i] == LONG_MAX || dd[i] == LONG_MAX) continue;\\n            ans = min(ans, da[i] + db[i] + dd[i]);\\n        }\\n        return ans == LONG_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-284/problems/minimum-weighted-subgraph-with-the-required-paths/\\n// Author: github.com/lzl124631x\\n// Time: O(ElogE + N)\\n// Space: O(E)\\nclass Solution {\\n    typedef pair<long, long> ipair;\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& E, int a, int b, int dest) {\\n        vector<vector<ipair>> G(n), R(n); // `G` is the original graph. `R` is the reversed graph\\n        for (auto &e : E) {\\n            long u = e[0], v = e[1], w = e[2];\\n            G[u].emplace_back(v, w);\\n            R[v].emplace_back(u, w);\\n        }\\n        vector<long> da(n, LONG_MAX), db(n, LONG_MAX), dd(n, LONG_MAX);\\n        auto solve = [&](vector<vector<ipair>> &G, int a, vector<long> &dist) {\\n            priority_queue<ipair, vector<ipair>, greater<ipair>> pq;\\n            dist[a] = 0;\\n            pq.emplace(0, a);\\n            while (pq.size()) {\\n                auto [cost, u] = pq.top();\\n                pq.pop();\\n                if (cost > dist[u]) continue;\\n                for (auto &[v, c] : G[u]) {\\n                    if (dist[v] > dist[u] + c) {\\n                        dist[v] = dist[u] + c;\\n                        pq.emplace(dist[v], v);\\n                    }\\n                }\\n            }\\n        };\\n        solve(G, a, da);\\n        solve(G, b, db);\\n        solve(R, dest, dd);\\n        long ans = LONG_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            if (da[i] == LONG_MAX || db[i] == LONG_MAX || dd[i] == LONG_MAX) continue;\\n            ans = min(ans, da[i] + db[i] + dd[i]);\\n        }\\n        return ans == LONG_MAX ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844095,
                "title": "three-dijkstras",
                "content": "**Intuition:** At some point, paths from both sources will reach some common node.\\n\\nSay, this common node is `i`. The weight of the graph will be the sum of:\\n- Minimum distance from first source to `i`.\\n- Minimum distance from second source to `i`.\\n- Minimum distance from `i` to the destination.\\n\\nWe run Dijkstra 3 times from both sources and destination. Note that to find smallest distance from all nodes to the destination, we run Dijkstra in reverse from the destination.\\n\\n**C++**\\n```cpp\\nvoid bfs(int st, vector<vector<pair<int, int>>> &al, vector<long long>& visited) {\\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n    pq.push({0, st});\\n    while (!pq.empty()) {\\n        auto [dist, i] = pq.top(); pq.pop();\\n        if (visited[i] != dist)\\n            continue;\\n        for (auto [j, w] : al[i]) {\\n            if (visited[j] > dist + w) {\\n                visited[j] = dist + w;\\n                pq.push({visited[j], j});\\n            }\\n        }\\n    }\\n}\\nlong long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n    long long max_val = 10000000000, res = LLONG_MAX;\\n    vector<vector<pair<int, int>>> al(n), ral(n);\\n    vector<long long> dd(n, max_val), s1d(n, max_val), s2d(n, max_val);\\n    dd[dest] = s1d[src1] = s2d[src2] = 0;\\n    for (auto &e : edges) {\\n        al[e[0]].push_back({e[1], e[2]});\\n        ral[e[1]].push_back({e[0], e[2]});            \\n    }\\n    bfs(dest, ral, dd);\\n    bfs(src1, al, s1d);\\n    bfs(src2, al, s2d);\\n    if (dd[src1] == max_val || dd[src2] == max_val)\\n        return -1;\\n    for (int i = 0; i < n; ++i)\\n        res = min(res, dd[i] + s1d[i] + s2d[i]);\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvoid bfs(int st, vector<vector<pair<int, int>>> &al, vector<long long>& visited) {\\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n    pq.push({0, st});\\n    while (!pq.empty()) {\\n        auto [dist, i] = pq.top(); pq.pop();\\n        if (visited[i] != dist)\\n            continue;\\n        for (auto [j, w] : al[i]) {\\n            if (visited[j] > dist + w) {\\n                visited[j] = dist + w;\\n                pq.push({visited[j], j});\\n            }\\n        }\\n    }\\n}\\nlong long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n    long long max_val = 10000000000, res = LLONG_MAX;\\n    vector<vector<pair<int, int>>> al(n), ral(n);\\n    vector<long long> dd(n, max_val), s1d(n, max_val), s2d(n, max_val);\\n    dd[dest] = s1d[src1] = s2d[src2] = 0;\\n    for (auto &e : edges) {\\n        al[e[0]].push_back({e[1], e[2]});\\n        ral[e[1]].push_back({e[0], e[2]});            \\n    }\\n    bfs(dest, ral, dd);\\n    bfs(src1, al, s1d);\\n    bfs(src2, al, s2d);\\n    if (dd[src1] == max_val || dd[src2] == max_val)\\n        return -1;\\n    for (int i = 0; i < n; ++i)\\n        res = min(res, dd[i] + s1d[i] + s2d[i]);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844680,
                "title": "c-explanation-with-picture-on-dijkstra-optimisation",
                "content": "**77/78 test cases passes and 1 case TLE is due to not optimized Dijkstra**.\\nIn below i had mentioned what to do optimization in Dijkstra and Why ?\\n\\nwhen we process priority_queue pair by pair in Dijkstra\\nthen if we find any pair where `minDistanceFromSrcTo[u] < dist` (where `dist = pq.top().first` & `u = pq.top().second`)\\nthen all shortest path passes from this node u is already processed so we have to not need to process this pair.\\n\\n![image](https://assets.leetcode.com/users/images/e9a9c719-af08-4fd9-83e7-8511593f6eb2_1647150645.3795204.jpeg)\\n\\n**eg.** during processing let assume that first we found minDistanceFromSrcTo[u] as 5 so we add pair `{5, u}` in priority_queue\\nthen after \\nfor some path we found minDistanceFromSrcTo[u] as 8 so we add pair `{4, u}` in priority_queue\\nso now when we process the queue pair by pair \\nfirst we pop `{4, u}` (as we use min pririty queue in Dijkstra) pair and found all shortest path according to that\\nand then we get `{5, u}` so now we had no need to process this because this is not lead to any shortest path.\\n\\n**In Below solution i had done comment in Dijkstra for optimization mentioned above**\\n\\n**Solution :**\\nhere I had done **Dijkstra 3 times**.\\n**First time** : store the shortest distance from node `src1` to all other nodes in array `fromSrc1To`.\\n**Second time** : store the shortest distance from node `src2` to all other nodes in array `fromSrc2To`.\\n**Third time** : store the shortest distance from node `dest` to all other nodes via Reversed Graph in array `fromDestTo`.\\n**The answer is the minimum of** `fromSrc1To[i] + fromSrc2To[i] + fromDestTo[i]` (`0 <= i < N`).\\n\\n```\\nclass Solution {\\n\\tlong MAXX = 1e10;\\npublic:\\n\\t// DIJKSTRA\\n\\tvoid Dijkstra(long src, vector<pair<long, long>> adj[], vector<long>&minDistanceFromSrcTo)\\n\\t{\\n\\t\\tpriority_queue<pair<long, long>, vector<pair<long, long>>, greater<pair<long, long>>> pq;\\n\\t\\tpq.push({0, src});\\n\\t\\tminDistanceFromSrcTo[src] = 0;\\n\\t\\tlong u, v, wt, dist;\\n\\t\\twhile (!pq.empty()) {\\n\\t\\t\\tu = pq.top().second;\\n\\t\\t\\tdist = pq.top().first;\\n\\t\\t\\tpq.pop();\\n\\t\\t\\t// below line in Dijkstra becomes game changer\\n\\t\\t\\t// because if for any pair in priority_queue pq\\n\\t\\t\\t// minDistanceFromSrcTo[u] < dist\\n\\t\\t\\t// then shortest path passing from this u is already processed\\n\\t\\t\\t// so no need to go below for() loop for time consumption\\n\\t\\t\\tif (minDistanceFromSrcTo[u] < dist) continue;\\n\\t\\t\\tfor (auto it : adj[u]) {\\n\\t\\t\\t\\tv = it.first;\\n\\t\\t\\t\\twt = it.second;\\n\\t\\t\\t\\tif (minDistanceFromSrcTo[u] + wt < minDistanceFromSrcTo[v]) {\\n\\t\\t\\t\\t\\tminDistanceFromSrcTo[v] = wt + minDistanceFromSrcTo[u];\\n\\t\\t\\t\\t\\tpq.push({minDistanceFromSrcTo[v], v});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tlong minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n\\t\\tvector<pair<long, long>> adj[n], revadj[n];\\n\\t\\tfor (auto e : edges) {\\n\\t\\t\\tadj[e[0]].push_back({e[1], e[2]});\\n\\t\\t\\trevadj[e[1]].push_back({e[0], e[2]});\\n\\t\\t}\\n\\n\\t\\tvector<long>fromSrc1To(n, MAXX), fromSrc2To(n, MAXX), fromDestTo(n, MAXX);\\n\\t\\tDijkstra(src1, adj, fromSrc1To);\\n\\t\\tDijkstra(src2, adj, fromSrc2To);\\n\\t\\tDijkstra(dest, revadj, fromDestTo);\\n\\n\\t\\t// BASE CASE : not fount any path from src1 to dest OR src2 to dest\\n\\t\\tif (fromSrc1To[dest] == MAXX || fromSrc2To[dest] == MAXX) return -1;\\n\\n\\t\\tlong ans = MAXX;\\n\\t\\tfor (long i = 0; i < n; i++) {\\n\\t\\t\\tans = min(ans, fromSrc1To[i] + fromSrc2To[i] + fromDestTo[i]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\tlong MAXX = 1e10;\\npublic:\\n\\t// DIJKSTRA\\n\\tvoid Dijkstra(long src, vector<pair<long, long>> adj[], vector<long>&minDistanceFromSrcTo)\\n\\t{\\n\\t\\tpriority_queue<pair<long, long>, vector<pair<long, long>>, greater<pair<long, long>>> pq;\\n\\t\\tpq.push({0, src});\\n\\t\\tminDistanceFromSrcTo[src] = 0;\\n\\t\\tlong u, v, wt, dist;\\n\\t\\twhile (!pq.empty()) {\\n\\t\\t\\tu = pq.top().second;\\n\\t\\t\\tdist = pq.top().first;\\n\\t\\t\\tpq.pop();\\n\\t\\t\\t// below line in Dijkstra becomes game changer\\n\\t\\t\\t// because if for any pair in priority_queue pq\\n\\t\\t\\t// minDistanceFromSrcTo[u] < dist\\n\\t\\t\\t// then shortest path passing from this u is already processed\\n\\t\\t\\t// so no need to go below for() loop for time consumption\\n\\t\\t\\tif (minDistanceFromSrcTo[u] < dist) continue;\\n\\t\\t\\tfor (auto it : adj[u]) {\\n\\t\\t\\t\\tv = it.first;\\n\\t\\t\\t\\twt = it.second;\\n\\t\\t\\t\\tif (minDistanceFromSrcTo[u] + wt < minDistanceFromSrcTo[v]) {\\n\\t\\t\\t\\t\\tminDistanceFromSrcTo[v] = wt + minDistanceFromSrcTo[u];\\n\\t\\t\\t\\t\\tpq.push({minDistanceFromSrcTo[v], v});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tlong minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n\\t\\tvector<pair<long, long>> adj[n], revadj[n];\\n\\t\\tfor (auto e : edges) {\\n\\t\\t\\tadj[e[0]].push_back({e[1], e[2]});\\n\\t\\t\\trevadj[e[1]].push_back({e[0], e[2]});\\n\\t\\t}\\n\\n\\t\\tvector<long>fromSrc1To(n, MAXX), fromSrc2To(n, MAXX), fromDestTo(n, MAXX);\\n\\t\\tDijkstra(src1, adj, fromSrc1To);\\n\\t\\tDijkstra(src2, adj, fromSrc2To);\\n\\t\\tDijkstra(dest, revadj, fromDestTo);\\n\\n\\t\\t// BASE CASE : not fount any path from src1 to dest OR src2 to dest\\n\\t\\tif (fromSrc1To[dest] == MAXX || fromSrc2To[dest] == MAXX) return -1;\\n\\n\\t\\tlong ans = MAXX;\\n\\t\\tfor (long i = 0; i < n; i++) {\\n\\t\\t\\tans = min(ans, fromSrc1To[i] + fromSrc2To[i] + fromDestTo[i]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844479,
                "title": "simultaneous-dijkstra-beats-100-only-1-dijkstra",
                "content": "This problem can actually be solved with just 1 dijkstra. I\\'ll try my best to explain it and comment my code. Hope it\\'s clear.\\n\\nFirst, let me mention a fact about dijkstra\\'s algorithm that is relevant to understanding this solution.\\n\\t* We visit nodes in increasing order of total distance from the source.\\nIf this is not very clear, please refer to this picture, I\\'ve shown it with an example.\\n![image](https://assets.leetcode.com/users/images/31e58c25-00dc-49a0-89aa-4d7398cf5472_1647174348.4265866.jpeg)\\n\\nFrom this it\\'s obvious that the first time we visit a node from the source, we would have visited it with the shortest path possible to that node. (every next node we visit will have a total path length >= current path length)\\nSo in a single source dijkstra, we record the path length the first time a node has been visited and discard future occurrences.\\n\\nIn this problem, we are given 2 sources and a single destination. We have to find the subset of nodes and edges such that the sum of weights of the edges is minumum, and (src1 -> dest) should be connected and (src2 -> dest) should be connected. \\nSo in the subgraph we select, we should have 1 path from src1 to dest and 1 path from src2 to dest. (It wouldnt make sense to have 2 or more paths as removal of one would still keep it connected and with a lesser cost, convince yourself of this)\\n\\nFor a second lets assume src1 = src2. Now its obvious that we just pick any shortest path from the source to the destination. Every edge we have is used by both src1 and src2 and is only counted once.\\nIf src2 moves away from src1, some edges will be used only by src1, some edges only by src2 and some edges by both. We would ideally want them to share a lot of edges so we dont count a lot of distinct edges. So the solution to the problem will look something like this.\\n![image](https://assets.leetcode.com/users/images/1be6d325-7aed-43a9-8d10-d3582d78b2d5_1647175485.8820276.jpeg)\\n\\nIn the 3 dijkstra solution, we consider every meeting point and see which one gives us the lowest cost.\\nHowever we can exploit the fact that we visit paths in increasing order of total distance and solve it with 1 dijkstra.\\n\\nLet me define 3 types of nodes, type_1, type_2 and type_3.\\na type_1 node is only invloved in the path from src1 to meeting point\\na type_2 node is only involved in the path from src_2 to meeting point\\na type 3 node is only involved in the path from meeting point to dest.\\n\\na type_1 node is always trailed by another type_1 node\\na type_2 node is always trailed by another type_2 node\\na type_3 node is either trailed by another type_3 node or is trailed by a type_1 and type_2 node (when they meet).\\n\\nNow when we do a dijkstra, we mark every node with either type_1, type_2 or type_3. The dest will always be a type_3 node.\\nlet dist_1[i] be the distance from src_1 to i using only type_1 nodes\\nlet dist_2[i] be the distance from src_2 to i using only type_2 nodes\\nlet dist[i] be the total distance from src1, src2 to i where i is a type 3 node.\\nthe answer to the question is dist[dest]\\n\\nWe start a dijkstra by adding (src1, type_1, 0) and (src2, type_2, 0) to the priorityQueue simultaneously.\\nAt some point lets say we visit a node i, which is a type_1 node. if this node has not been previously visited as a type_2 node, we simply just update dist_1[i] and queue its neighbours as type_1. However, if this node has already been visited as a type_2 node, this node now becomes a type_3 node. We update dist[i] = dist_1[i] + dist_2[i] . And from here, we queue its neighbours as type_3.\\nAt every point, regardless of the type of node we queue, we will always be visiting nodes in an increasing order of total distance from the source. So the first time we visit dest as a type 3 node, that will be our answer.\\nI hope this explanation was clear. Please go through my code too, maybe it will be make it clearer.\\n\\n```\\nprivate static final int only_1 = 1;    //type_1\\n    private static final int only_2 = 2;    //type_2\\n    private static final int both = 3;      //type_3\\n\\n    // a weighted edge\\n    private static class NodeCostPair {\\n        int to;\\n        long weight;\\n\\n        public NodeCostPair(int to, long weight) {\\n            this.to = to;\\n            this.weight = weight;\\n        }\\n    }\\n\\n    // search node for dijkstra\\n    private static class SeacrhNode implements Comparable<SeacrhNode> {\\n        int to;\\n        long cost;\\n        int type;\\n\\n        public SeacrhNode(int to, long cost, int type) {\\n            this.to = to;\\n            this.type = type;\\n            this.cost = cost;\\n        }\\n\\n        @Override\\n        public int compareTo(SeacrhNode o) {\\n            if(this.cost < o.cost) {\\n                return -1;\\n            }\\n            else if(this.cost > o.cost) {\\n                return 1;\\n            }\\n            else {\\n                if(this.type == both) {\\n                    return -1;\\n                }\\n            }\\n            return 1;\\n        }\\n    }\\n\\n    private static long dijkstra(Map<Integer, List<NodeCostPair>> map, int src_1, int src_2, int dest) {\\n        int n = map.size();\\n        long[] dist_1 = new long[n];\\n        long[] dist_2 = new long[n];\\n        long[] dist = new long[n];\\n        //-1 is unvisited\\n        Arrays.fill(dist_1, -1);\\n        Arrays.fill(dist_2, -1);\\n        Arrays.fill(dist, -1);\\n\\n        PriorityQueue<SeacrhNode> pq = new PriorityQueue<>();\\n        pq.add(new SeacrhNode(src_1, 0, only_1));\\n        pq.add(new SeacrhNode(src_2, 0, only_2));\\n\\n        while(!pq.isEmpty()) {\\n            //get the next search node\\n            SeacrhNode node = pq.poll();\\n            int cur = node.to;\\n            long cost = node.cost;\\n            int type = node.type;\\n\\n            // if this node is type_1\\n            if(type == only_1) {\\n                //we have already visited this node as a type_1 node (with a shorter path)\\n                if(dist_1[cur] != -1) {\\n                    continue;\\n                }\\n                //if it\\'s the first time we are visiting this node as a type_1 node, update dist_1\\n                dist_1[cur] = cost;\\n                //get neighbours\\n                List<NodeCostPair> neighbours = map.get(cur);\\n\\n                //a type_2 searchNode has already visited this node, it is a potential meeting point\\n                //from here on out, it is useless to queue type_1 searchNodes from here,\\n                //as type_3 will be better(subsequent edges will only be counted once)\\n                if(dist_2[cur] != -1) {\\n                    //queueing type_3 search node\\n                    pq.add(new SeacrhNode(cur, dist_1[cur] + dist_2[cur], both));\\n                }\\n                //a type_2 searchNode has not visited this node\\n                else {\\n                    for(NodeCostPair e : neighbours) {\\n                        //queueing type_1 search nodes\\n                        pq.add(new SeacrhNode(e.to, dist_1[cur] + e.weight, only_1));\\n                    }\\n                }\\n            }\\n            //I\\'m not commenting the code for type 2 as it\\'s symmetrical to type_1\\n            else if(type == only_2) {\\n                if(dist_2[cur] != -1) {\\n                    continue;\\n                }\\n                dist_2[cur] = cost;\\n                List<NodeCostPair> neighbours = map.get(cur);\\n                if(dist_1[cur] != -1) {\\n                    pq.add(new SeacrhNode(cur, dist_1[cur] + dist_2[cur], both));\\n                }\\n                else {\\n                    for(NodeCostPair e : neighbours) {\\n                        pq.add(new SeacrhNode(e.to, dist_2[cur] + e.weight, only_2));\\n                    }\\n                }\\n            }\\n            //type_3 searchNode\\n            else {\\n                //we have already visited this node as a type_3 node, (with lower cost)\\n                if(dist[cur] != -1) {\\n                    continue;\\n                }\\n                //the first time we visit dest as a type 3 node, we return the cost to dest\\n                if(cur == dest) {\\n                    return cost;\\n                }\\n                //the first time we visit this node as a type_3 node, update its cost\\n                dist[cur] = cost;\\n                //getting neighbours\\n                List<NodeCostPair> neighbours = map.get(cur);\\n                for(NodeCostPair e : neighbours) {\\n                    //queueing type_3 searchNodes\\n                    pq.add(new SeacrhNode(e.to, dist[cur] + e.weight, both));\\n                }\\n            }\\n        }\\n        //we have not encountered dest as a type_3 node in our dijkstra, return -1\\n        return -1;\\n    }\\n\\n\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        Map<Integer, List<NodeCostPair>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        for(int[] edge : edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int weight = edge[2];\\n            map.get(from).add(new NodeCostPair(to, weight));\\n        }\\n\\n        return dijkstra(map, src1, src2, dest);\\n    }\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nprivate static final int only_1 = 1;    //type_1\\n    private static final int only_2 = 2;    //type_2\\n    private static final int both = 3;      //type_3\\n\\n    // a weighted edge\\n    private static class NodeCostPair {\\n        int to;\\n        long weight;\\n\\n        public NodeCostPair(int to, long weight) {\\n            this.to = to;\\n            this.weight = weight;\\n        }\\n    }\\n\\n    // search node for dijkstra\\n    private static class SeacrhNode implements Comparable<SeacrhNode> {\\n        int to;\\n        long cost;\\n        int type;\\n\\n        public SeacrhNode(int to, long cost, int type) {\\n            this.to = to;\\n            this.type = type;\\n            this.cost = cost;\\n        }\\n\\n        @Override\\n        public int compareTo(SeacrhNode o) {\\n            if(this.cost < o.cost) {\\n                return -1;\\n            }\\n            else if(this.cost > o.cost) {\\n                return 1;\\n            }\\n            else {\\n                if(this.type == both) {\\n                    return -1;\\n                }\\n            }\\n            return 1;\\n        }\\n    }\\n\\n    private static long dijkstra(Map<Integer, List<NodeCostPair>> map, int src_1, int src_2, int dest) {\\n        int n = map.size();\\n        long[] dist_1 = new long[n];\\n        long[] dist_2 = new long[n];\\n        long[] dist = new long[n];\\n        //-1 is unvisited\\n        Arrays.fill(dist_1, -1);\\n        Arrays.fill(dist_2, -1);\\n        Arrays.fill(dist, -1);\\n\\n        PriorityQueue<SeacrhNode> pq = new PriorityQueue<>();\\n        pq.add(new SeacrhNode(src_1, 0, only_1));\\n        pq.add(new SeacrhNode(src_2, 0, only_2));\\n\\n        while(!pq.isEmpty()) {\\n            //get the next search node\\n            SeacrhNode node = pq.poll();\\n            int cur = node.to;\\n            long cost = node.cost;\\n            int type = node.type;\\n\\n            // if this node is type_1\\n            if(type == only_1) {\\n                //we have already visited this node as a type_1 node (with a shorter path)\\n                if(dist_1[cur] != -1) {\\n                    continue;\\n                }\\n                //if it\\'s the first time we are visiting this node as a type_1 node, update dist_1\\n                dist_1[cur] = cost;\\n                //get neighbours\\n                List<NodeCostPair> neighbours = map.get(cur);\\n\\n                //a type_2 searchNode has already visited this node, it is a potential meeting point\\n                //from here on out, it is useless to queue type_1 searchNodes from here,\\n                //as type_3 will be better(subsequent edges will only be counted once)\\n                if(dist_2[cur] != -1) {\\n                    //queueing type_3 search node\\n                    pq.add(new SeacrhNode(cur, dist_1[cur] + dist_2[cur], both));\\n                }\\n                //a type_2 searchNode has not visited this node\\n                else {\\n                    for(NodeCostPair e : neighbours) {\\n                        //queueing type_1 search nodes\\n                        pq.add(new SeacrhNode(e.to, dist_1[cur] + e.weight, only_1));\\n                    }\\n                }\\n            }\\n            //I\\'m not commenting the code for type 2 as it\\'s symmetrical to type_1\\n            else if(type == only_2) {\\n                if(dist_2[cur] != -1) {\\n                    continue;\\n                }\\n                dist_2[cur] = cost;\\n                List<NodeCostPair> neighbours = map.get(cur);\\n                if(dist_1[cur] != -1) {\\n                    pq.add(new SeacrhNode(cur, dist_1[cur] + dist_2[cur], both));\\n                }\\n                else {\\n                    for(NodeCostPair e : neighbours) {\\n                        pq.add(new SeacrhNode(e.to, dist_2[cur] + e.weight, only_2));\\n                    }\\n                }\\n            }\\n            //type_3 searchNode\\n            else {\\n                //we have already visited this node as a type_3 node, (with lower cost)\\n                if(dist[cur] != -1) {\\n                    continue;\\n                }\\n                //the first time we visit dest as a type 3 node, we return the cost to dest\\n                if(cur == dest) {\\n                    return cost;\\n                }\\n                //the first time we visit this node as a type_3 node, update its cost\\n                dist[cur] = cost;\\n                //getting neighbours\\n                List<NodeCostPair> neighbours = map.get(cur);\\n                for(NodeCostPair e : neighbours) {\\n                    //queueing type_3 searchNodes\\n                    pq.add(new SeacrhNode(e.to, dist[cur] + e.weight, both));\\n                }\\n            }\\n        }\\n        //we have not encountered dest as a type_3 node in our dijkstra, return -1\\n        return -1;\\n    }\\n\\n\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        Map<Integer, List<NodeCostPair>> map = new HashMap<>();\\n        for(int i = 0; i < n; i++) {\\n            map.put(i, new ArrayList<>());\\n        }\\n        for(int[] edge : edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int weight = edge[2];\\n            map.get(from).add(new NodeCostPair(to, weight));\\n        }\\n\\n        return dijkstra(map, src1, src2, dest);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844099,
                "title": "java-run-dijkstra-3-times",
                "content": "Run Dijkstra\\'s algorithm 3 times from src1, src2, and dest respectively, to determine the shortest path between each node and src1/src2/dest, then go through each node and min(src1To[i] + src2To[i] + toDest[i]) is the answer.\\n\\n```\\nclass Solution {\\n    ArrayList<int[]>[] nextGraph, preGraph;\\n    \\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        buildGraph(n, edges);\\n        \\n        long[] src1To = new long[n], src2To = new long[n], toDest = new long[n];\\n        Arrays.fill(src1To, -1);\\n        Arrays.fill(src2To, -1);\\n        Arrays.fill(toDest, -1);\\n        \\n        shortestPath(src1, src1To, nextGraph);\\n        shortestPath(src2, src2To, nextGraph);\\n        shortestPath(dest, toDest, preGraph);\\n        \\n        long res = -1;\\n        for (int i = 0; i < n; i++) {\\n            long d1 = src1To[i], d2 = src2To[i], d3 = toDest[i];\\n            if (d1 >= 0 && d2 >= 0 && d3 >= 0) {\\n                long d = d1 + d2 + d3;\\n                if (res == -1 || d < res) {\\n                    res = d;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void buildGraph(int n, int[][] edges) {\\n        nextGraph = new ArrayList[n];\\n        preGraph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            nextGraph[i] = new ArrayList<int[]>();\\n            preGraph[i] = new ArrayList<int[]>();\\n        }\\n       \\n        for (int[] edge : edges) {\\n            int from = edge[0], to = edge[1], weight = edge[2];\\n            nextGraph[from].add(new int[] {to, weight});\\n            preGraph[to].add(new int[] {from, weight});\\n        }\\n    }\\n    \\n    private void shortestPath(int src, long[] srcTo, ArrayList<int[]>[] graph) {\\n        PriorityQueue<long[]> heap = new PriorityQueue<>((a, b) -> Long.compare(a[1], b[1]));\\n        heap.offer(new long[] {src, 0});\\n        \\n        while (!heap.isEmpty()) {\\n            long[] node = heap.poll();\\n            int to = (int) node[0];\\n            long dist = node[1];\\n            if (srcTo[to] != -1 && srcTo[to] <= dist) continue;\\n            srcTo[to] = dist;\\n            for (int[] next : graph[to]) {\\n                heap.offer(new long[] {next[0], dist + next[1]});\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    ArrayList<int[]>[] nextGraph, preGraph;\\n    \\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        buildGraph(n, edges);\\n        \\n        long[] src1To = new long[n], src2To = new long[n], toDest = new long[n];\\n        Arrays.fill(src1To, -1);\\n        Arrays.fill(src2To, -1);\\n        Arrays.fill(toDest, -1);\\n        \\n        shortestPath(src1, src1To, nextGraph);\\n        shortestPath(src2, src2To, nextGraph);\\n        shortestPath(dest, toDest, preGraph);\\n        \\n        long res = -1;\\n        for (int i = 0; i < n; i++) {\\n            long d1 = src1To[i], d2 = src2To[i], d3 = toDest[i];\\n            if (d1 >= 0 && d2 >= 0 && d3 >= 0) {\\n                long d = d1 + d2 + d3;\\n                if (res == -1 || d < res) {\\n                    res = d;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void buildGraph(int n, int[][] edges) {\\n        nextGraph = new ArrayList[n];\\n        preGraph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            nextGraph[i] = new ArrayList<int[]>();\\n            preGraph[i] = new ArrayList<int[]>();\\n        }\\n       \\n        for (int[] edge : edges) {\\n            int from = edge[0], to = edge[1], weight = edge[2];\\n            nextGraph[from].add(new int[] {to, weight});\\n            preGraph[to].add(new int[] {from, weight});\\n        }\\n    }\\n    \\n    private void shortestPath(int src, long[] srcTo, ArrayList<int[]>[] graph) {\\n        PriorityQueue<long[]> heap = new PriorityQueue<>((a, b) -> Long.compare(a[1], b[1]));\\n        heap.offer(new long[] {src, 0});\\n        \\n        while (!heap.isEmpty()) {\\n            long[] node = heap.poll();\\n            int to = (int) node[0];\\n            long dist = node[1];\\n            if (srcTo[to] != -1 && srcTo[to] <= dist) continue;\\n            srcTo[to] = dist;\\n            for (int[] next : graph[to]) {\\n                heap.offer(new long[] {next[0], dist + next[1]});\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844100,
                "title": "c-3-dijkstra-s",
                "content": "## Idea\\n- for each node `i` we calculate the following value\\n\\t```\\n\\tw[i] := dist(src1, i) + dist(src2, i) + dist(i, dest)\\n\\t```\\n\\t- where `dist(a, b)` is defined as the length of the shortest path from node `a` to node `b`.\\n\\t- then the answer would be the minimum value among all `w[i]`s.\\n- to obtain the distance functions, we have to perform **Dijkstra\\'s Algorithm** three times:\\n\\t1. starting from `src1` to get `dist(src1, *)`\\n\\t2. starting from `src2` to get `dist(src2, *)`\\n\\t3. starting from `dest` in the **edge-reversed** graph to get `dist(*, dest)`\\n## Code\\n- C++\\n\\t```\\n\\ttypedef long long ll;\\n\\t\\n\\tclass Solution {\\n\\tprivate:\\n\\t\\tconst ll kInf = 1e18;\\n\\t\\tvector<ll> Dijkstra(vector<vector<pair<int, ll>>>& adj, int src) {\\n\\t\\t\\tint n = adj.size();\\n\\t\\t\\tvector<ll> dist(n, kInf);\\n\\t\\t\\tdist[src] = 0;\\n\\t\\t\\tpriority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;\\n\\t\\t\\t// pq contains pairs of <the current distance estimate from src to id, id>\\n\\t\\t\\tpq.push(make_pair(0, src));\\n\\t\\t\\twhile (!pq.empty()) {\\n\\t\\t\\t\\tauto [d, cur] = pq.top(); pq.pop();\\n\\t\\t\\t\\tif (d != dist[cur]) continue;\\n\\t\\t\\t\\tfor (auto [nei, w] : adj[cur]) {\\n\\t\\t\\t\\t\\tif (dist[nei] > d + w) {\\n\\t\\t\\t\\t\\t\\tdist[nei] = d + w;\\n\\t\\t\\t\\t\\t\\tpq.push(make_pair(dist[nei], nei));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dist;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tlong long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n\\t\\t\\t// build the graphs\\n\\t\\t\\tvector<vector<pair<int, ll>>> adj(n);\\n\\t\\t\\tvector<vector<pair<int, ll>>> rev(n);  // the graph with reversed edges\\n\\t\\t\\tint u, v, w;\\n\\t\\t\\tfor (auto& e : edges) {\\n\\t\\t\\t\\tu = e[0], v = e[1], w = e[2];\\n\\t\\t\\t\\tadj[u].push_back(make_pair(v, w));\\n\\t\\t\\t\\trev[v].push_back(make_pair(u, w));\\n\\t\\t\\t}\\n\\t\\t\\t// Dijkstra\\n\\t\\t\\tvector<ll> dist_from_src1 = Dijkstra(adj, src1);\\n\\t\\t\\tvector<ll> dist_from_src2 = Dijkstra(adj, src2);\\n\\t\\t\\tvector<ll> dist_to_dest   = Dijkstra(rev, dest);\\n\\t\\t\\t// find the smallest w[i]\\n\\t\\t\\tll ans = kInf;\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tans = min(ans, dist_from_src1[i] + dist_from_src2[i] + dist_to_dest[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans == kInf ? -1 : ans;\\n\\t\\t}\\n\\t};\\n\\t```\\n- Time Complexity:\\n\\t- `O(E log E + n)`, where `E` denotes the number of edges in the graph.\\n- Space Complexity:\\n\\t- `O(E + n)`",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\tw[i] := dist(src1, i) + dist(src2, i) + dist(i, dest)\\n\\t```\n```\\n\\ttypedef long long ll;\\n\\t\\n\\tclass Solution {\\n\\tprivate:\\n\\t\\tconst ll kInf = 1e18;\\n\\t\\tvector<ll> Dijkstra(vector<vector<pair<int, ll>>>& adj, int src) {\\n\\t\\t\\tint n = adj.size();\\n\\t\\t\\tvector<ll> dist(n, kInf);\\n\\t\\t\\tdist[src] = 0;\\n\\t\\t\\tpriority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;\\n\\t\\t\\t// pq contains pairs of <the current distance estimate from src to id, id>\\n\\t\\t\\tpq.push(make_pair(0, src));\\n\\t\\t\\twhile (!pq.empty()) {\\n\\t\\t\\t\\tauto [d, cur] = pq.top(); pq.pop();\\n\\t\\t\\t\\tif (d != dist[cur]) continue;\\n\\t\\t\\t\\tfor (auto [nei, w] : adj[cur]) {\\n\\t\\t\\t\\t\\tif (dist[nei] > d + w) {\\n\\t\\t\\t\\t\\t\\tdist[nei] = d + w;\\n\\t\\t\\t\\t\\t\\tpq.push(make_pair(dist[nei], nei));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dist;\\n\\t\\t}\\n\\tpublic:\\n\\t\\tlong long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n\\t\\t\\t// build the graphs\\n\\t\\t\\tvector<vector<pair<int, ll>>> adj(n);\\n\\t\\t\\tvector<vector<pair<int, ll>>> rev(n);  // the graph with reversed edges\\n\\t\\t\\tint u, v, w;\\n\\t\\t\\tfor (auto& e : edges) {\\n\\t\\t\\t\\tu = e[0], v = e[1], w = e[2];\\n\\t\\t\\t\\tadj[u].push_back(make_pair(v, w));\\n\\t\\t\\t\\trev[v].push_back(make_pair(u, w));\\n\\t\\t\\t}\\n\\t\\t\\t// Dijkstra\\n\\t\\t\\tvector<ll> dist_from_src1 = Dijkstra(adj, src1);\\n\\t\\t\\tvector<ll> dist_from_src2 = Dijkstra(adj, src2);\\n\\t\\t\\tvector<ll> dist_to_dest   = Dijkstra(rev, dest);\\n\\t\\t\\t// find the smallest w[i]\\n\\t\\t\\tll ans = kInf;\\n\\t\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\t\\tans = min(ans, dist_from_src1[i] + dist_from_src2[i] + dist_to_dest[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans == kInf ? -1 : ans;\\n\\t\\t}\\n\\t};\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1848106,
                "title": "c-tle-ac-dijkastras-explained",
                "content": "**Elimination of TLE after 3 times Dijkastra :**\\n\\n* Generally while running Dijkastra algorithm, we often forget to check that if some node has lower distance than its current cost, we can ignore processing that node.\\ni.e. if  **dis[u] < cost (where cost = pq.top().first & u = pq.top().second)** then we can stop processing that node.\\n\\n* And doing that only, we eliminate TLE. \\n* This is a good problem, worth solving and checking the actual runtime complexity of Dijkastras.\\n\\n```\\n#define ll long long \\n#define maxi 1e18\\nclass Solution {\\npublic:\\n    void solve(int src,vector<vector<pair<ll,ll>>>&graph,vector<ll>&dis)\\n    {\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>pq;\\n        dis[src]=0;\\n        pq.push({0,src});\\n        while(!pq.empty())\\n        {\\n            int node=pq.top().second;\\n            int distance=pq.top().first;\\n            pq.pop();\\n           \\n            \\n            \\n            /* TLE Elimination */\\n            if(distance>dis[node])\\n                continue;\\n            /* Without above Check u will get TLE */\\n            \\n            for(auto itr:graph[node])\\n            {\\n                if(dis[itr.first]>itr.second+dis[node])\\n                {\\n                    dis[itr.first]=itr.second+dis[node];\\n                    pq.push({dis[itr.first],itr.first});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        \\n        vector<ll>dis1(n,maxi),dis2(n,maxi),dis3(n,maxi);\\n        \\n        vector<vector<pair<long long,long long>>>graph(n),reverse(n);\\n        \\n        for(auto i:edges)\\n        {\\n            int u=i[0];\\n            int v=i[1];\\n            int w=i[2];\\n            \\n            graph[u].push_back({v,w});\\n            reverse[v].push_back({u,w});\\n\\t\\t}\\n        solve(src1,graph,dis1);\\n        solve(src2,graph,dis2);\\n        solve(dest,reverse,dis3);\\n        \\n        long long ans=maxi;\\n        // for(auto i:dis1)\\n        //     cout<<i<<\" \";\\n        // cout<<endl;\\n        //  for(auto i:dis2)\\n        //     cout<<i<<\" \";\\n        // cout<<endl;\\n        \\n        for(int i=0;i<=n-1;i++)\\n        {\\n            if(dis1[i]==maxi or dis2[i]==maxi or dis3[i]==maxi) continue;\\n            \\n            ans=min(ans,dis1[i]+dis2[i]+dis3[i]);\\n        }\\n        return ans==maxi?-1:ans;\\n\\t}\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```\\n#define ll long long \\n#define maxi 1e18\\nclass Solution {\\npublic:\\n    void solve(int src,vector<vector<pair<ll,ll>>>&graph,vector<ll>&dis)\\n    {\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>pq;\\n        dis[src]=0;\\n        pq.push({0,src});\\n        while(!pq.empty())\\n        {\\n            int node=pq.top().second;\\n            int distance=pq.top().first;\\n            pq.pop();\\n           \\n            \\n            \\n            /* TLE Elimination */\\n            if(distance>dis[node])\\n                continue;\\n            /* Without above Check u will get TLE */\\n            \\n            for(auto itr:graph[node])\\n            {\\n                if(dis[itr.first]>itr.second+dis[node])\\n                {\\n                    dis[itr.first]=itr.second+dis[node];\\n                    pq.push({dis[itr.first],itr.first});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        \\n        vector<ll>dis1(n,maxi),dis2(n,maxi),dis3(n,maxi);\\n        \\n        vector<vector<pair<long long,long long>>>graph(n),reverse(n);\\n        \\n        for(auto i:edges)\\n        {\\n            int u=i[0];\\n            int v=i[1];\\n            int w=i[2];\\n            \\n            graph[u].push_back({v,w});\\n            reverse[v].push_back({u,w});\\n\\t\\t}\\n        solve(src1,graph,dis1);\\n        solve(src2,graph,dis2);\\n        solve(dest,reverse,dis3);\\n        \\n        long long ans=maxi;\\n        // for(auto i:dis1)\\n        //     cout<<i<<\" \";\\n        // cout<<endl;\\n        //  for(auto i:dis2)\\n        //     cout<<i<<\" \";\\n        // cout<<endl;\\n        \\n        for(int i=0;i<=n-1;i++)\\n        {\\n            if(dis1[i]==maxi or dis2[i]==maxi or dis3[i]==maxi) continue;\\n            \\n            ans=min(ans,dis1[i]+dis2[i]+dis3[i]);\\n        }\\n        return ans==maxi?-1:ans;\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3320318,
                "title": "c-dijkstra-s-algorithm-intution-and-approach-explained",
                "content": "# Intuition\\n- If we were asked to find the answer from `src1` and `src2` independently, then we would have applied dijkstra indivisually.\\n- So for this question, there can be a possibility that the path from `src1 to dest` and the path from `src2 to dest` would share some of the edges or they can be completely different.\\n- Using this we approach towards the solution of the problem.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUse dijkstra for each of the src1, src2, dest.\\n- First dijkstra store the distance of each node from `src1`.\\n- Second dijkstra store the distance of each node from `src2`.\\n- Third dijkstra use another adjacency list with reversed edge direction to store the distance of each node from `dest`.\\n- Finally, the answer is the minimum of these three distances for every node from `0 <= i <= N`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N * log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\n#define pii pair<ll,ll>\\n#define inf (1ll << 60)\\nclass Solution {\\npublic:\\n    void dijkstra(int src, vector<ll> &dist, vector<vector<pii>> &adj) {\\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\\n        dist[src] = 0;\\n        pq.push({0,src});\\n\\n        while(!pq.empty())\\n        {\\n            auto [wt,v] = pq.top();\\n            pq.pop();\\n\\n            if(wt != dist[v])\\n                continue;\\n\\n            for(auto [u,d] : adj[v])\\n            {\\n                if(dist[u] > wt + d)\\n                {\\n                    dist[u] = wt + d;\\n                    pq.push({dist[u],u});\\n                }\\n            }\\n        }\\n    }\\n\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pii>> adj(n,vector<pii>());\\n        vector<vector<pii>> radj(n,vector<pii>());\\n        for(auto it : edges)\\n        {\\n            int u = it[0], v = it[1], w = it[2];\\n            adj[u].push_back({v,w});\\n            radj[v].push_back({u,w});\\n        }\\n\\n        vector<ll> dist1(n,inf), dist2(n,inf), dist3(n,inf);\\n\\n        dijkstra(src1,dist1,adj);\\n        dijkstra(src2,dist2,adj);\\n        dijkstra(dest,dist3,radj);\\n\\n        if(dist1[dest]==inf || dist2[dest]==inf)\\n            return -1;\\n        \\n        ll ans = inf;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            ll d = dist1[i] + dist2[i] + dist3[i];\\n            ans = min(ans, d);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/cee106b9-62f3-4d26-8368-7cc0489c22f0_1679322278.93872.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\n#define ll long long\\n#define pii pair<ll,ll>\\n#define inf (1ll << 60)\\nclass Solution {\\npublic:\\n    void dijkstra(int src, vector<ll> &dist, vector<vector<pii>> &adj) {\\n        priority_queue<pii, vector<pii>, greater<pii>> pq;\\n        dist[src] = 0;\\n        pq.push({0,src});\\n\\n        while(!pq.empty())\\n        {\\n            auto [wt,v] = pq.top();\\n            pq.pop();\\n\\n            if(wt != dist[v])\\n                continue;\\n\\n            for(auto [u,d] : adj[v])\\n            {\\n                if(dist[u] > wt + d)\\n                {\\n                    dist[u] = wt + d;\\n                    pq.push({dist[u],u});\\n                }\\n            }\\n        }\\n    }\\n\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pii>> adj(n,vector<pii>());\\n        vector<vector<pii>> radj(n,vector<pii>());\\n        for(auto it : edges)\\n        {\\n            int u = it[0], v = it[1], w = it[2];\\n            adj[u].push_back({v,w});\\n            radj[v].push_back({u,w});\\n        }\\n\\n        vector<ll> dist1(n,inf), dist2(n,inf), dist3(n,inf);\\n\\n        dijkstra(src1,dist1,adj);\\n        dijkstra(src2,dist2,adj);\\n        dijkstra(dest,dist3,radj);\\n\\n        if(dist1[dest]==inf || dist2[dest]==inf)\\n            return -1;\\n        \\n        ll ans = inf;\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            ll d = dist1[i] + dist2[i] + dist3[i];\\n            ans = min(ans, d);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845537,
                "title": "java-3-dijkstras-clean-readable-code",
                "content": "The idea is the following: paths from **src1** to **dest** and from **src2** to **dest** can have common point **x**. Then we need to reach:\\n1. From **src1** to **x**, for this we use Dijkstra\\n2. From **src2** to **x**, for this we use Dijkstra again\\n3. From **x** to **dest**, for this we use Dijkstra on the reversed graph.\\n\\nFinally, we check all possible x to find minimum weight of a subgraph\\n\\n\\tclass Solution \\n\\t\\t{\\n\\t\\t\\tclass Edge\\n\\t\\t\\t{\\n\\t\\t\\t\\tint ed;\\n\\t\\t\\t\\tlong wt;\\n\\n\\t\\t\\t\\tEdge(int ed,long wt)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthis.ed=ed;\\n\\t\\t\\t\\t\\tthis.wt=wt;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tclass Pair\\n\\t\\t\\t{\\n\\t\\t\\t\\tint ed;\\n\\t\\t\\t\\tlong wsf;\\n\\n\\t\\t\\t\\tPair(int ed,long wsf)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthis.ed=ed;\\n\\t\\t\\t\\t\\tthis.wsf=wsf;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tpublic long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) \\n\\t\\t\\t{\\n\\t\\t\\t\\tArrayList<ArrayList<Edge>> graph=new ArrayList<>();\\n\\t\\t\\t\\tArrayList<ArrayList<Edge>> rev_graph=new ArrayList<>();\\n\\n\\t\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgraph.add(new ArrayList<>());\\n\\t\\t\\t\\t\\trev_graph.add(new ArrayList<>());\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor(int i=0;i<edges.length;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tgraph.get(edges[i][0]).add(new Edge(edges[i][1],edges[i][2]));\\n\\t\\t\\t\\t\\trev_graph.get(edges[i][1]).add(new Edge(edges[i][0],edges[i][2]));    \\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tlong[] s1tox=new long[n];\\n\\t\\t\\t\\tlong[] s2tox=new long[n];\\n\\t\\t\\t\\tlong[] dtox=new long[n];\\n\\t\\t\\t\\tArrays.fill(s1tox, -1);\\n\\t\\t\\t\\tArrays.fill(s2tox, -1);\\n\\t\\t\\t\\tArrays.fill(dtox, -1);\\n\\n\\t\\t\\t\\tdijkstra(graph,s1tox,src1);\\n\\t\\t\\t\\tdijkstra(graph,s2tox,src2);\\n\\t\\t\\t\\tdijkstra(rev_graph,dtox,dest);\\n\\n\\t\\t\\t\\tlong ans=Long.MAX_VALUE;\\n\\t\\t\\t\\tfor (int i=0;i<n;i++) \\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tlong l1=s1tox[i];\\n\\t\\t\\t\\t\\tlong l2=s2tox[i];\\n\\t\\t\\t\\t\\tlong l3=dtox[i];\\n\\n\\t\\t\\t\\t\\tif (l1!=-1&&l2!=-1&&l3!=-1)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tlong len=l1+l2+l3;\\n\\t\\t\\t\\t\\t\\tans=Math.min(ans,len);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn ans==Long.MAX_VALUE?-1:ans;   \\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic void dijkstra(ArrayList<ArrayList<Edge>> graph,long[] res,int src)\\n\\t\\t\\t{\\n\\t\\t\\t\\tPriorityQueue<Pair> q=new PriorityQueue<>((a,b)->(int)(a.wsf-b.wsf));\\n\\t\\t\\t\\tq.add(new Pair(src,0));\\n\\t\\t\\t\\tboolean[] visited=new boolean[graph.size()];\\n\\n\\t\\t\\t\\twhile(q.size()>0)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint size=q.size();\\n\\n\\t\\t\\t\\t\\twhile(size-->0)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tPair p=q.poll();\\n\\n\\t\\t\\t\\t\\t\\tif(!visited[p.ed])\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tArrayList<Edge> al=graph.get(p.ed);\\n\\t\\t\\t\\t\\t\\t\\tfor(Edge e:al)\\n\\t\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\t\\tif(!visited[e.ed])\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tq.add(new Pair(e.ed,e.wt+p.wsf));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tres[p.ed]=p.wsf;\\n\\t\\t\\t\\t\\t\\t\\tvisited[p.ed]=true;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "class Solution \\n\\t\\t{\\n\\t\\t\\tclass Edge\\n\\t\\t\\t{\\n\\t\\t\\t\\tint ed;\\n\\t\\t\\t\\tlong wt;\\n\\n\\t\\t\\t\\tEdge(int ed,long wt)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tthis.ed=ed;\\n\\t\\t\\t\\t\\tthis.wt=wt;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1845027,
                "title": "c-3-dijkstras-with-detailed-explanation",
                "content": "**Observation-**\\n\\nOptimal subgraph contains 2 independent paths from src1 and src2 to some node (cnode) and then a simple path from that node to dest.\\n*src1 -> node1 -> ... -> cnode \\nsrc2 -> node\\'1 -> ... -> cnode \\ncnode -> ... -> dest*\\n\\n**Approach-**\\n\\nThe idea is to run 3 dijkstras, first and second one to find minimum weight distance from src1 and src2 to all other nodes and third one to find minimum distance from dest to all nodes.\\n\\nTo find minimum distance from dest to all nodes we can just invert all the edges in the given graph.\\n\\nSo, our answer should be min(distFromDest(i) + distFromSrc1(i) + disFromSrc2(i)) for all i, 0 <= i < n.\\n\\n**C++**\\n\\n```cpp\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> q;\\n        vector<vector<pair<ll, ll>>> graph(n), invertedGraph(n);\\n        ll a = INT64_MAX, ans = INT64_MAX;\\n        \\n        for(auto &edge : edges) {\\n            graph[edge[0]].push_back({edge[1], edge[2]});\\n            invertedGraph[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        \\n        vector<ll> dis1(n, a), dis2(n, a), dis(n, a);\\n        \\n\\t\\t//dijkstra from src1\\n        dis1[src1] = 0;\\n        q.push({0, src1});\\n        while(!q.empty()) {\\n            auto [d, c] = q.top();\\n            q.pop();\\n            \\n            if(dis1[c] < d) {\\n                continue;\\n            }\\n            \\n            for(auto &x : graph[c]) {\\n                if(dis1[x.first] > d + x.second) {\\n                    dis1[x.first] = d + x.second;\\n                    q.push({dis1[x.first], x.first});\\n                }\\n            }\\n        }\\n        \\n\\t\\t//dijkstra from src2\\n        dis2[src2] = 0;\\n        q.push({0, src2});\\n        while(!q.empty()) {\\n            auto [d, c] = q.top();\\n            q.pop();\\n            if(dis2[c] < d) {\\n                continue;\\n            }\\n            \\n            for(auto &x : graph[c]) {\\n                if(dis2[x.first] > d + x.second)\\n                {\\n                    dis2[x.first] = d + x.second;\\n                    q.push({dis2[x.first], x.first});\\n                }\\n            }\\n        }\\n        \\n        if(dis2[dest] == a || dist1[dest] == a) {\\n            return -1;\\n        }\\n        \\n\\t\\t//dijkstra from dest\\n        q.push({0, dest});\\n        dis[dest] = 0;\\n        while(!q.empty()) {\\n            auto [d, c] = q.top();\\n            q.pop();\\n            if(dis[c] < d) {\\n                continue;\\n            }\\n            \\n\\t\\t\\t//distFromDest(i) + distFromSrc1(i) + disFromSrc2(i)\\n            if(dis1[c] != a && dis2[c] != a) {\\n                ans = min(ans, d + dis1[c] + dis2[c]);\\n            }\\n\\t\\t\\t\\n            for(auto &x : invertedGraph[c]) {\\n                if(dis[x.first] > d + x.second) {\\n                    dis[x.first] = d + x.second;\\n                    q.push({dis[x.first], x.first});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> q;\\n        vector<vector<pair<ll, ll>>> graph(n), invertedGraph(n);\\n        ll a = INT64_MAX, ans = INT64_MAX;\\n        \\n        for(auto &edge : edges) {\\n            graph[edge[0]].push_back({edge[1], edge[2]});\\n            invertedGraph[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        \\n        vector<ll> dis1(n, a), dis2(n, a), dis(n, a);\\n        \\n\\t\\t//dijkstra from src1\\n        dis1[src1] = 0;\\n        q.push({0, src1});\\n        while(!q.empty()) {\\n            auto [d, c] = q.top();\\n            q.pop();\\n            \\n            if(dis1[c] < d) {\\n                continue;\\n            }\\n            \\n            for(auto &x : graph[c]) {\\n                if(dis1[x.first] > d + x.second) {\\n                    dis1[x.first] = d + x.second;\\n                    q.push({dis1[x.first], x.first});\\n                }\\n            }\\n        }\\n        \\n\\t\\t//dijkstra from src2\\n        dis2[src2] = 0;\\n        q.push({0, src2});\\n        while(!q.empty()) {\\n            auto [d, c] = q.top();\\n            q.pop();\\n            if(dis2[c] < d) {\\n                continue;\\n            }\\n            \\n            for(auto &x : graph[c]) {\\n                if(dis2[x.first] > d + x.second)\\n                {\\n                    dis2[x.first] = d + x.second;\\n                    q.push({dis2[x.first], x.first});\\n                }\\n            }\\n        }\\n        \\n        if(dis2[dest] == a || dist1[dest] == a) {\\n            return -1;\\n        }\\n        \\n\\t\\t//dijkstra from dest\\n        q.push({0, dest});\\n        dis[dest] = 0;\\n        while(!q.empty()) {\\n            auto [d, c] = q.top();\\n            q.pop();\\n            if(dis[c] < d) {\\n                continue;\\n            }\\n            \\n\\t\\t\\t//distFromDest(i) + distFromSrc1(i) + disFromSrc2(i)\\n            if(dis1[c] != a && dis2[c] != a) {\\n                ans = min(ans, d + dis1[c] + dis2[c]);\\n            }\\n\\t\\t\\t\\n            for(auto &x : invertedGraph[c]) {\\n                if(dis[x.first] > d + x.second) {\\n                    dis[x.first] = d + x.second;\\n                    q.push({dis[x.first], x.first});\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844189,
                "title": "python-djikstra-from-all-3-nodes-w-detailed-explanation",
                "content": "The problem asks us to find a subgraph with least distance of src1 and src2 to dest.\\n\\nThere are a couple of key intuitions to get this one right.\\n1) If such a subgraph exists, then src1 and src2 can share a common path that leads to dest.\\n\\t -  If such a common path exists, then src1 will move indepndently to the intersecting InterMediate node, lets say IM.\\n\\t - Similarly src2 will move independently to the intersecting node IM\\n\\t - From IM both will share the common path\\n2) This gives rise to the picture where we have  \\n\\t- src1 -> IM + \\n\\t- src2 -> IM + \\n\\t- IM -> dest is minimum\\n3) The final intuition is that, IM -> dest can be done by reversing the graph and applying Djikstra on the reversed G.\\n\\t- src1 -> IM can be done by Djikstra\\n\\t- src2 -> IM can be done by Djikstra\\n\\n\\t- IM -> dest can be done by Djikstra on the reversed graph\\n4) Once we have these distances then finding IM, is just a matter of finding the node that minimizes the total cost\\n\\n```\\ndef minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        def djikstra(g, src):\\n            distances = defaultdict(lambda: inf)\\n            heap = [(0, src)]\\n\\n            while heap:\\n                dist, node = heappop(heap)\\n                if node in distances: continue \\n                distances[node] = dist\\n                \\n                for neigh in g[node].keys():\\n                    if neigh in distances: continue\\n                    newdist = distances[node] + g[node][neigh]\\n                    heappush(heap, [newdist, neigh])   \\n            return distances\\n        \\n        graph = defaultdict(dict)\\n        rev_graph = defaultdict(dict)\\n        for u,v,w in edges:\\n            graph[u][v] = w if v not in graph[u] else min(w, graph[u][v])\\n            rev_graph[v][u] = w if u not in rev_graph[v] else min(w, rev_graph[v][u])\\n            \\n        src1_distances = djikstra(graph, src1)\\n        src2_distances = djikstra(graph, src2)\\n        dest_distances = djikstra(rev_graph, dest)\\n        \\n        res = inf\\n        for node in range(n):\\n            local_res = src1_distances[node] + src2_distances[node] + dest_distances[node]\\n            res = min(res, local_res)        \\n        return res if res != inf else -1\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\ndef minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        def djikstra(g, src):\\n            distances = defaultdict(lambda: inf)\\n            heap = [(0, src)]\\n\\n            while heap:\\n                dist, node = heappop(heap)\\n                if node in distances: continue \\n                distances[node] = dist\\n                \\n                for neigh in g[node].keys():\\n                    if neigh in distances: continue\\n                    newdist = distances[node] + g[node][neigh]\\n                    heappush(heap, [newdist, neigh])   \\n            return distances\\n        \\n        graph = defaultdict(dict)\\n        rev_graph = defaultdict(dict)\\n        for u,v,w in edges:\\n            graph[u][v] = w if v not in graph[u] else min(w, graph[u][v])\\n            rev_graph[v][u] = w if u not in rev_graph[v] else min(w, rev_graph[v][u])\\n            \\n        src1_distances = djikstra(graph, src1)\\n        src2_distances = djikstra(graph, src2)\\n        dest_distances = djikstra(rev_graph, dest)\\n        \\n        res = inf\\n        for node in range(n):\\n            local_res = src1_distances[node] + src2_distances[node] + dest_distances[node]\\n            res = min(res, local_res)        \\n        return res if res != inf else -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2954139,
                "title": "c-dijkstra-algorithm-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:O(NlogN)\\n\\n- Space complexity:O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dijkstra(int s, vector<long long int>& v, vector<vector<int>>adj[]){\\n        priority_queue<pair<long long int, int>, vector<pair<long long int, int>>, greater<pair<long long int, int>>>q;\\n        v[s]=0;\\n        q.push({0, s});\\n        while(!q.empty()){\\n            long long int wt=q.top().first;\\n            int pos=q.top().second;\\n            q.pop();\\n            if(wt!=v[pos]){continue;}\\n            for(auto it: adj[pos]){\\n                if(v[it[0]]>wt+it[1]){\\n                    v[it[0]]=wt+it[1];\\n                    q.push({v[it[0]], it[0]});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<int>>adj[n];\\n        vector<vector<int>>adj1[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            adj1[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n        long long int ans=1e18;\\n        vector<long long int>v1(n, 1e18), v2(n, 1e18), v3(n, 1e18);\\n        dijkstra(src1, v1, adj);\\n        dijkstra(src2, v2, adj);\\n        dijkstra(dest, v3, adj1);\\n        if(v3[src1]==1e18 || v3[src2]==1e18){return -1;}\\n        for(int i=0; i<n; i++){\\n            ans=min(ans, v1[i]+v2[i]+v3[i]);\\n        }\\n        if(ans==1e18){return -1;}\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dijkstra(int s, vector<long long int>& v, vector<vector<int>>adj[]){\\n        priority_queue<pair<long long int, int>, vector<pair<long long int, int>>, greater<pair<long long int, int>>>q;\\n        v[s]=0;\\n        q.push({0, s});\\n        while(!q.empty()){\\n            long long int wt=q.top().first;\\n            int pos=q.top().second;\\n            q.pop();\\n            if(wt!=v[pos]){continue;}\\n            for(auto it: adj[pos]){\\n                if(v[it[0]]>wt+it[1]){\\n                    v[it[0]]=wt+it[1];\\n                    q.push({v[it[0]], it[0]});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<int>>adj[n];\\n        vector<vector<int>>adj1[n];\\n        for(int i=0; i<edges.size(); i++){\\n            adj[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            adj1[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n        long long int ans=1e18;\\n        vector<long long int>v1(n, 1e18), v2(n, 1e18), v3(n, 1e18);\\n        dijkstra(src1, v1, adj);\\n        dijkstra(src2, v2, adj);\\n        dijkstra(dest, v3, adj1);\\n        if(v3[src1]==1e18 || v3[src2]==1e18){return -1;}\\n        for(int i=0; i<n; i++){\\n            ans=min(ans, v1[i]+v2[i]+v3[i]);\\n        }\\n        if(ans==1e18){return -1;}\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845226,
                "title": "three-dijsktras-in-c",
                "content": "C ++ :\\n```\\nclass Solution {\\npublic:\\n    \\n    typedef pair<long, long> P;\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int a, int b, int d) {\\n        \\n        vector<vector<P>> adj(n);\\n        vector<vector<P>> arr(n);\\n        \\n        for (auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            int w = edge[2];\\n            adj[u].push_back({w, v});\\n            arr[v].push_back({w, u});\\n        }\\n        \\n        vector<long> da(n, LONG_MAX);\\n        vector<long> db(n, LONG_MAX);\\n        vector<long> dd(n, LONG_MAX);\\n        \\n        dikshtra(adj, a, da);\\n        dikshtra(adj, b, db);\\n        dikshtra(arr, d, dd);\\n        \\n        long ans = LONG_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            if (da[i] == LONG_MAX || db[i] == LONG_MAX || dd[i] == LONG_MAX) continue;\\n            ans = min(ans, da[i] + db[i] + dd[i]);\\n        }\\n        \\n        return ans == LONG_MAX ? -1 : ans;\\n    }\\n    \\n    void dikshtra(vector<vector<P>> &G, int a, vector<long> &dist){\\n        \\n        dist[a] = 0;\\n        priority_queue<P, vector<P>, greater<P>> pq;\\n        pq.push({0, a});\\n        \\n        while (!pq.empty()) {\\n            auto [cost, u] = pq.top(); pq.pop();\\n            \\n            if (cost > dist[u]) continue;\\n            \\n            for (auto &[c, v] : G[u]) {\\n                if (dist[v] > dist[u] + c) {\\n                    dist[v] = dist[u] + c;\\n                    pq.push({dist[v], v});\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    typedef pair<long, long> P;\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int a, int b, int d) {\\n        \\n        vector<vector<P>> adj(n);\\n        vector<vector<P>> arr(n);\\n        \\n        for (auto edge : edges) {\\n            int u = edge[0];\\n            int v = edge[1];\\n            int w = edge[2];\\n            adj[u].push_back({w, v});\\n            arr[v].push_back({w, u});\\n        }\\n        \\n        vector<long> da(n, LONG_MAX);\\n        vector<long> db(n, LONG_MAX);\\n        vector<long> dd(n, LONG_MAX);\\n        \\n        dikshtra(adj, a, da);\\n        dikshtra(adj, b, db);\\n        dikshtra(arr, d, dd);\\n        \\n        long ans = LONG_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            if (da[i] == LONG_MAX || db[i] == LONG_MAX || dd[i] == LONG_MAX) continue;\\n            ans = min(ans, da[i] + db[i] + dd[i]);\\n        }\\n        \\n        return ans == LONG_MAX ? -1 : ans;\\n    }\\n    \\n    void dikshtra(vector<vector<P>> &G, int a, vector<long> &dist){\\n        \\n        dist[a] = 0;\\n        priority_queue<P, vector<P>, greater<P>> pq;\\n        pq.push({0, a});\\n        \\n        while (!pq.empty()) {\\n            auto [cost, u] = pq.top(); pq.pop();\\n            \\n            if (cost > dist[u]) continue;\\n            \\n            for (auto &[c, v] : G[u]) {\\n                if (dist[v] > dist[u] + c) {\\n                    dist[v] = dist[u] + c;\\n                    pq.push({dist[v], v});\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844582,
                "title": "clean-java",
                "content": "In this questions we do 3 times of dijikstra, in order to have 3 maps. Which is the shortest path from every node to src1, src2 and dest. Then we can enumerate each of node to see if they can connect and find out the smallest value.\\n```\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        Map<Integer, List<int[]>> graph = new HashMap<>(); \\n        Map<Integer, List<int[]>> graphReverse = new HashMap<>(); \\n        for (int[] edge: edges) {\\n            graph.computeIfAbsent(edge[0], x -> new ArrayList<>()).add(new int[]{edge[1], edge[2]});\\n            graphReverse.computeIfAbsent(edge[1], x -> new ArrayList<>()).add(new int[]{edge[0], edge[2]});\\n        }\\n        Map<Integer, Long> dist1 = dijkstra(n, graph, src1);\\n        Map<Integer, Long> dist2 = dijkstra(n, graph, src2);\\n        Map<Integer, Long> dist3 = dijkstra(n, graphReverse, dest);\\n        long res = Long.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n            if (dist1.containsKey(i) && dist2.containsKey(i) && dist3.containsKey(i))\\n\\t\\t\\t    res = Math.min(res, dist1.get(i) + dist2.get(i) + dist3.get(i));\\n\\t\\t}\\n\\t\\treturn res == Long.MAX_VALUE ? -1 : res;\\n    }\\n    \\n    public Map<Integer, Long> dijkstra(int n, Map<Integer, List<int[]>> graph, int src) {\\n        PriorityQueue<Point> pq = new PriorityQueue<Point>((a, b) -> (a.distance - b.distance < 0 ? -1 : 1));\\n        pq.offer(new Point(0, src)); //<distance, node>\\n        Map<Integer, Long> dist = new HashMap<>();//\\u5408\\u5E76\\u4E86visited\\u548Cdistance array\\n        int[] pre = new int[n];\\n        Point onePoint = new Point(0, 0);\\n        while (!pq.isEmpty()) {\\n            Point cur = pq.poll();\\n            long curDistance = cur.distance;\\n            int curNode = cur.node;\\n            if (dist.containsKey(curNode)) continue;\\n            dist.put(curNode, curDistance);\\n            for (int[] edge: graph.getOrDefault(curNode, new ArrayList<>())) {\\n                int nei = edge[0], cost = edge[1];\\n                if (!dist.containsKey(nei)) {\\n                    Point insert = new Point(curDistance + cost, nei);\\n                    pq.offer(insert);\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n}\\n\\nclass Point {\\n    long distance;\\n    int node;\\n    public Point(long distance, int node) {\\n        this.distance = distance;\\n        this.node = node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        Map<Integer, List<int[]>> graph = new HashMap<>(); \\n        Map<Integer, List<int[]>> graphReverse = new HashMap<>(); \\n        for (int[] edge: edges) {\\n            graph.computeIfAbsent(edge[0], x -> new ArrayList<>()).add(new int[]{edge[1], edge[2]});\\n            graphReverse.computeIfAbsent(edge[1], x -> new ArrayList<>()).add(new int[]{edge[0], edge[2]});\\n        }\\n        Map<Integer, Long> dist1 = dijkstra(n, graph, src1);\\n        Map<Integer, Long> dist2 = dijkstra(n, graph, src2);\\n        Map<Integer, Long> dist3 = dijkstra(n, graphReverse, dest);\\n        long res = Long.MAX_VALUE;\\n\\t\\tfor (int i = 0; i < n; i++) {\\n            if (dist1.containsKey(i) && dist2.containsKey(i) && dist3.containsKey(i))\\n\\t\\t\\t    res = Math.min(res, dist1.get(i) + dist2.get(i) + dist3.get(i));\\n\\t\\t}\\n\\t\\treturn res == Long.MAX_VALUE ? -1 : res;\\n    }\\n    \\n    public Map<Integer, Long> dijkstra(int n, Map<Integer, List<int[]>> graph, int src) {\\n        PriorityQueue<Point> pq = new PriorityQueue<Point>((a, b) -> (a.distance - b.distance < 0 ? -1 : 1));\\n        pq.offer(new Point(0, src)); //<distance, node>\\n        Map<Integer, Long> dist = new HashMap<>();//\\u5408\\u5E76\\u4E86visited\\u548Cdistance array\\n        int[] pre = new int[n];\\n        Point onePoint = new Point(0, 0);\\n        while (!pq.isEmpty()) {\\n            Point cur = pq.poll();\\n            long curDistance = cur.distance;\\n            int curNode = cur.node;\\n            if (dist.containsKey(curNode)) continue;\\n            dist.put(curNode, curDistance);\\n            for (int[] edge: graph.getOrDefault(curNode, new ArrayList<>())) {\\n                int nei = edge[0], cost = edge[1];\\n                if (!dist.containsKey(nei)) {\\n                    Point insert = new Point(curDistance + cost, nei);\\n                    pq.offer(insert);\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n}\\n\\nclass Point {\\n    long distance;\\n    int node;\\n    public Point(long distance, int node) {\\n        this.distance = distance;\\n        this.node = node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844538,
                "title": "3-dijstars-easy-commented",
                "content": "To calcualte distance of every node to dest, we can\\'t do this naively as that will result in TLE.\\nInstead we can use a trick which is often used in this type of problems, in which we simply reverse the direction of edges and then apply single source shortest path algorithms which is quite easy to see how and why it works.\\nDraw a simple graph and see how above works.\\nFor any doubts comment down below.\\n```\\n#define all(x) x.begin(), x.end()\\n#define sz(x) static_cast<int32_t>(x.size())\\n#define pb push_back\\n#define ll long long\\nconst int MOD = 1e9 + 7, N = 100005;\\nconst ll INF = 2e18;\\ntypedef pair<int, int> pii;\\ntemplate <class T> inline void chmax(T &x,T y){ x = max((x), (y));}\\ntemplate <class T> inline void chmin(T &x,T y){ x = min((x), (y));}\\ntemplate <typename T> T powm(T a,T b, ll m){T cnt=1; while(b>0) { if(b%2==1) cnt=(cnt*a)%m; b/=2; a=(a*a)%m; }return cnt%m;}\\ntemplate <typename T> T gcd(T a,T b) {if(a==0) return b; return gcd(b%a,a);}\\n\\n\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& e, int src1, int src2, int dest) {\\n        vector <array<int, 2>> g[n]; // given graph\\n        vector <array<int, 2>> rg[n]; // reverse graph\\n        for (auto x : e) {\\n            g[x[0]].push_back({x[1], x[2]});\\n            rg[x[1]].push_back({x[0], x[2]});\\n        }\\n\\t\\t/*\\n\\t\\t\\tSingle source shortest path algo - dijsktras.\\n\\t\\t*/\\n        auto dj = [&n] (int src, vector<array<int, 2>> g[]) -> vector <long long> {\\n        vector <long long> dis(n + 2,(long long) 2e17);\\n        priority_queue <pair<long long ,int>, vector <pair<long long ,int>>,greater<pair<long long ,int>>> Q;\\n        vector <bool> vis(n + 1,false);\\n        Q.push({0,src});\\n        dis[src] = 0;\\n        while (!Q.empty()) {\\n            pair<long long,int> now = Q.top();\\n            Q.pop();\\n            int node = now.second;\\n            long long tot = now.first;\\n            if (vis[node]) continue;\\n            vis[node] = 1;\\n            for (auto x : g[node]) {\\n                if (tot + x[1] < dis[x[0]]) {\\n                    dis[x[0]] = tot + x[1];\\n                    Q.push({dis[x[0]],x[0]});\\n                }\\n            }\\n         }\\n            return dis;\\n        };\\n        auto dist_src1 = dj(src1, g);\\n        auto dist_src2 = dj(src2, g);\\n        auto dist_dest = dj(dest, rg);\\n        long long ans = INF;\\n        for (int i = 0; i < n; ++i) {\\n            ans = min(ans, dist_src1[i] + dist_src2[i] + dist_dest[i]);\\n        }\\n        if (ans > 2e15) ans = -1; // means there is no such path.\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote if you got something our of this!",
                "solutionTags": [],
                "code": "```\\n#define all(x) x.begin(), x.end()\\n#define sz(x) static_cast<int32_t>(x.size())\\n#define pb push_back\\n#define ll long long\\nconst int MOD = 1e9 + 7, N = 100005;\\nconst ll INF = 2e18;\\ntypedef pair<int, int> pii;\\ntemplate <class T> inline void chmax(T &x,T y){ x = max((x), (y));}\\ntemplate <class T> inline void chmin(T &x,T y){ x = min((x), (y));}\\ntemplate <typename T> T powm(T a,T b, ll m){T cnt=1; while(b>0) { if(b%2==1) cnt=(cnt*a)%m; b/=2; a=(a*a)%m; }return cnt%m;}\\ntemplate <typename T> T gcd(T a,T b) {if(a==0) return b; return gcd(b%a,a);}\\n\\n\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& e, int src1, int src2, int dest) {\\n        vector <array<int, 2>> g[n]; // given graph\\n        vector <array<int, 2>> rg[n]; // reverse graph\\n        for (auto x : e) {\\n            g[x[0]].push_back({x[1], x[2]});\\n            rg[x[1]].push_back({x[0], x[2]});\\n        }\\n\\t\\t/*\\n\\t\\t\\tSingle source shortest path algo - dijsktras.\\n\\t\\t*/\\n        auto dj = [&n] (int src, vector<array<int, 2>> g[]) -> vector <long long> {\\n        vector <long long> dis(n + 2,(long long) 2e17);\\n        priority_queue <pair<long long ,int>, vector <pair<long long ,int>>,greater<pair<long long ,int>>> Q;\\n        vector <bool> vis(n + 1,false);\\n        Q.push({0,src});\\n        dis[src] = 0;\\n        while (!Q.empty()) {\\n            pair<long long,int> now = Q.top();\\n            Q.pop();\\n            int node = now.second;\\n            long long tot = now.first;\\n            if (vis[node]) continue;\\n            vis[node] = 1;\\n            for (auto x : g[node]) {\\n                if (tot + x[1] < dis[x[0]]) {\\n                    dis[x[0]] = tot + x[1];\\n                    Q.push({dis[x[0]],x[0]});\\n                }\\n            }\\n         }\\n            return dis;\\n        };\\n        auto dist_src1 = dj(src1, g);\\n        auto dist_src2 = dj(src2, g);\\n        auto dist_dest = dj(dest, rg);\\n        long long ans = INF;\\n        for (int i = 0; i < n; ++i) {\\n            ans = min(ans, dist_src1[i] + dist_src2[i] + dist_dest[i]);\\n        }\\n        if (ans > 2e15) ans = -1; // means there is no such path.\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844236,
                "title": "python-3-dijkstras-with-detailed-explanation",
                "content": "**Steps:**\\n1. For each node N in the graph, calculate the minimum distance from src1 to N, src2 to N and N to dest.  \\n1. Build the subgraph that contains all the edges in the minimum weighted path from src1 to N, src2 to N and N to dest; in this graph, dest is reachable from both src1 and src2. \\n1. Find the minimum weight sum of these three paths. \\n\\n**Below is the pseudo-code:**\\n```\\nbest_weight = INF\\nfor node = 0 to n-1\\n\\tcur_dist = min_dist(src1, node) + min_dist(src2, node) + min_dist(node, N)\\n\\tbest_dist = min(best_dist, cur_dist)\\nreturn best_dist\\n```\\n\\n**My solution:**\\n```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        graph, reverse_graph = defaultdict(list), defaultdict(list)\\n        for i, j, w in edges:\\n            graph[i].append((j, w))\\n            reverse_graph[j].append((i, w))\\n        \\n        def dijkstra(src, G):\\n            distance = [-1] * n\\n            pq = [(0, src)]\\n            while pq:\\n                w, node = heappop(pq)\\n                if distance[node] >= 0:\\n                    continue\\n                distance[node] = w\\n                for nxt, wt in G[node]:\\n                    if distance[nxt] < 0:\\n                        heappush(pq, (w + wt, nxt))\\n            return distance\\n        \\n        l1 = dijkstra(src1, graph)\\n        l2 = dijkstra(src2, graph)\\n        l3 = dijkstra(dest, reverse_graph)\\n        best_dist = -1\\n        for i in range(n):\\n            if l1[i] >= 0 and l2[i] >= 0 and l3[i] >= 0:\\n                cur_dist = l1[i] + l2[i] + l3[i]\\n                if best_dist < 0 or cur_dist < best_dist:\\n                    best_dist = cur_dist\\n        return best_dist\\n```",
                "solutionTags": [],
                "code": "```\\nbest_weight = INF\\nfor node = 0 to n-1\\n\\tcur_dist = min_dist(src1, node) + min_dist(src2, node) + min_dist(node, N)\\n\\tbest_dist = min(best_dist, cur_dist)\\nreturn best_dist\\n```\n```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        graph, reverse_graph = defaultdict(list), defaultdict(list)\\n        for i, j, w in edges:\\n            graph[i].append((j, w))\\n            reverse_graph[j].append((i, w))\\n        \\n        def dijkstra(src, G):\\n            distance = [-1] * n\\n            pq = [(0, src)]\\n            while pq:\\n                w, node = heappop(pq)\\n                if distance[node] >= 0:\\n                    continue\\n                distance[node] = w\\n                for nxt, wt in G[node]:\\n                    if distance[nxt] < 0:\\n                        heappush(pq, (w + wt, nxt))\\n            return distance\\n        \\n        l1 = dijkstra(src1, graph)\\n        l2 = dijkstra(src2, graph)\\n        l3 = dijkstra(dest, reverse_graph)\\n        best_dist = -1\\n        for i in range(n):\\n            if l1[i] >= 0 and l2[i] >= 0 and l3[i] >= 0:\\n                cur_dist = l1[i] + l2[i] + l3[i]\\n                if best_dist < 0 or cur_dist < best_dist:\\n                    best_dist = cur_dist\\n        return best_dist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126558,
                "title": "c-solution-dijkstra-s-algo",
                "content": "# Code\\n```\\n// Time Complexity: 3*O(V+E)\\n// Space Complexity: 5*O(V+E)\\n#define ll long long int\\n#define pi pair<ll,ll>\\n#define vp vector<pi>\\n\\nclass Solution {\\n    private:\\n    \\n    int N;\\n     void minDistance(vector<vp>&adjList, int src,vector<ll>&dist)\\n     {\\n         // Using dijkstra\\'s algo\\n         priority_queue<pi,vp,greater<pi>>pq;\\n        \\n\\n         // updation for source\\n         pq.push({0,src});\\n         dist[src]=0;\\n \\n         while(!pq.empty())\\n         {\\n             auto it=pq.top();\\n             pq.pop();\\n             int node=it.second;\\n             ll wgt=it.first;\\n               if(wgt>dist[node]) continue;\\n             // traverse over neighbor nodes\\n             for(auto it: adjList[node])\\n             {   int adjNode=it.first;\\n                 ll new_wgt=wgt+it.second;\\n                 // yet not visited\\n                  if(dist[adjNode]>new_wgt)\\n                  {  \\n                      // update dist array\\n                       dist[adjNode]=new_wgt;\\n                       pq.push({new_wgt,adjNode});\\n                  }\\n             }\\n         }\\n             \\n\\n     }\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        // Situation:1 -> src1->src2->dest\\n        // Situation:2 -> src2->src1->dest\\n        // Situation:3 -> src1->dest AND src2->dest\\n           N=n;\\n         // create an adjacency list\\n         vector<vp>adjList(n,vp());\\n\\n         for(auto it: edges)\\n          {\\n              int u=it[0];\\n              int v=it[1];\\n              int wgt=it[2];\\n              adjList[u].push_back({v,wgt});\\n          }\\n\\n\\n         vector<ll>dist1(n,LONG_MAX);\\n         vector<ll>dist2(n,LONG_MAX);\\n        \\n        // Dijkstra for src1 \\n        minDistance(adjList,src1,dist1);\\n        // Dijkstra for src2 \\n        minDistance(adjList,src2,dist2);\\n          \\n        // now use\\n        // Dijkstra for dest \\n          // for this reverse the edges\\n          vector<vp>adjT(n,vp());\\n          for(auto it: edges)\\n          {\\n              int u=it[0];\\n              int v=it[1];\\n              int wgt=it[2];\\n              adjT[v].push_back({u,wgt});\\n          }\\n\\n       vector<ll>dist(n,LONG_MAX);\\n        minDistance(adjT,dest,dist);\\n\\n        // what are the common vertices where you can reach from both source nodes\\n       long long ans = LONG_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            if (dist1[i] == LONG_MAX || dist2[i] == LONG_MAX || dist[i] == LONG_MAX) continue;\\n            ans = min(ans, dist1[i] + dist2[i] + dist[i]);\\n        }\\n        return ans == LONG_MAX ? -1 : ans;\\n\\n    }\\n};\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/8b0a6b1e-1900-4761-b6a4-75603944be13_1675245974.5961459.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\n// Time Complexity: 3*O(V+E)\\n// Space Complexity: 5*O(V+E)\\n#define ll long long int\\n#define pi pair<ll,ll>\\n#define vp vector<pi>\\n\\nclass Solution {\\n    private:\\n    \\n    int N;\\n     void minDistance(vector<vp>&adjList, int src,vector<ll>&dist)\\n     {\\n         // Using dijkstra\\'s algo\\n         priority_queue<pi,vp,greater<pi>>pq;\\n        \\n\\n         // updation for source\\n         pq.push({0,src});\\n         dist[src]=0;\\n \\n         while(!pq.empty())\\n         {\\n             auto it=pq.top();\\n             pq.pop();\\n             int node=it.second;\\n             ll wgt=it.first;\\n               if(wgt>dist[node]) continue;\\n             // traverse over neighbor nodes\\n             for(auto it: adjList[node])\\n             {   int adjNode=it.first;\\n                 ll new_wgt=wgt+it.second;\\n                 // yet not visited\\n                  if(dist[adjNode]>new_wgt)\\n                  {  \\n                      // update dist array\\n                       dist[adjNode]=new_wgt;\\n                       pq.push({new_wgt,adjNode});\\n                  }\\n             }\\n         }\\n             \\n\\n     }\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        // Situation:1 -> src1->src2->dest\\n        // Situation:2 -> src2->src1->dest\\n        // Situation:3 -> src1->dest AND src2->dest\\n           N=n;\\n         // create an adjacency list\\n         vector<vp>adjList(n,vp());\\n\\n         for(auto it: edges)\\n          {\\n              int u=it[0];\\n              int v=it[1];\\n              int wgt=it[2];\\n              adjList[u].push_back({v,wgt});\\n          }\\n\\n\\n         vector<ll>dist1(n,LONG_MAX);\\n         vector<ll>dist2(n,LONG_MAX);\\n        \\n        // Dijkstra for src1 \\n        minDistance(adjList,src1,dist1);\\n        // Dijkstra for src2 \\n        minDistance(adjList,src2,dist2);\\n          \\n        // now use\\n        // Dijkstra for dest \\n          // for this reverse the edges\\n          vector<vp>adjT(n,vp());\\n          for(auto it: edges)\\n          {\\n              int u=it[0];\\n              int v=it[1];\\n              int wgt=it[2];\\n              adjT[v].push_back({u,wgt});\\n          }\\n\\n       vector<ll>dist(n,LONG_MAX);\\n        minDistance(adjT,dest,dist);\\n\\n        // what are the common vertices where you can reach from both source nodes\\n       long long ans = LONG_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            if (dist1[i] == LONG_MAX || dist2[i] == LONG_MAX || dist[i] == LONG_MAX) continue;\\n            ans = min(ans, dist1[i] + dist2[i] + dist[i]);\\n        }\\n        return ans == LONG_MAX ? -1 : ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855544,
                "title": "apply-dijkstra-3-times-shortest-paths-c-clean-code",
                "content": "```\\nclass Solution {\\n    void dijkstra(vector<vector<pair<long long, long long>>>& adj, vector<long long>& dist, long long source, long long n) {\\n        \\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> pq;\\n        pq.push({0LL, source});\\n        \\n        dist[source] = 0LL;\\n        \\n        while(pq.size()) {\\n            long long dis = pq.top().first;\\n            long long node = pq.top().second; \\n            pq.pop();\\n            \\n            if(dis > dist[node]) continue;\\n            \\n            for(auto& it : adj[node]) {\\n                int adjnode = it.first;\\n                int wt = it.second; \\n                \\n                if(wt + dis < dist[adjnode]) {\\n                    dist[adjnode] = (long long)wt + (long long)dis;\\n                    pq.push({dist[adjnode], adjnode});\\n                }\\n            }\\n        }\\n        \\n    }\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        \\n        vector<vector<pair<long long, long long>>> adj(n);\\n        vector<vector<pair<long long, long long>>> rev_adj(n);\\n        \\n        for(auto& edge : edges) {\\n            adj[edge[0]].push_back({edge[1], edge[2]});\\n            rev_adj[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n                \\n        vector<long long> dist_from_src1(n, 1e18);\\n        vector<long long> dist_from_src2(n, 1e18);\\n        vector<long long> dist_from_dest(n, 1e18);\\n        \\n        dijkstra(adj, dist_from_src1, src1, n);\\n        dijkstra(adj, dist_from_src2, src2, n);\\n        dijkstra(rev_adj, dist_from_dest, dest, n);\\n        \\n        \\n        long long minWeight = 1e18;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(dist_from_src1[i] == 1e18 or dist_from_src2[i] == 1e18 or dist_from_dest[i] == 1e18) continue;\\n            minWeight = min(minWeight, dist_from_src1[i] + dist_from_src2[i] + dist_from_dest[i]);\\n        }\\n        \\n        return minWeight >= 1e18 ? -1 : minWeight;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    void dijkstra(vector<vector<pair<long long, long long>>>& adj, vector<long long>& dist, long long source, long long n) {\\n        \\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> pq;\\n        pq.push({0LL, source});\\n        \\n        dist[source] = 0LL;\\n        \\n        while(pq.size()) {\\n            long long dis = pq.top().first;\\n            long long node = pq.top().second; \\n            pq.pop();\\n            \\n            if(dis > dist[node]) continue;\\n            \\n            for(auto& it : adj[node]) {\\n                int adjnode = it.first;\\n                int wt = it.second; \\n                \\n                if(wt + dis < dist[adjnode]) {\\n                    dist[adjnode] = (long long)wt + (long long)dis;\\n                    pq.push({dist[adjnode], adjnode});\\n                }\\n            }\\n        }\\n        \\n    }\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        \\n        vector<vector<pair<long long, long long>>> adj(n);\\n        vector<vector<pair<long long, long long>>> rev_adj(n);\\n        \\n        for(auto& edge : edges) {\\n            adj[edge[0]].push_back({edge[1], edge[2]});\\n            rev_adj[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n                \\n        vector<long long> dist_from_src1(n, 1e18);\\n        vector<long long> dist_from_src2(n, 1e18);\\n        vector<long long> dist_from_dest(n, 1e18);\\n        \\n        dijkstra(adj, dist_from_src1, src1, n);\\n        dijkstra(adj, dist_from_src2, src2, n);\\n        dijkstra(rev_adj, dist_from_dest, dest, n);\\n        \\n        \\n        long long minWeight = 1e18;\\n        \\n        for(int i=0; i<n; i++) {\\n            if(dist_from_src1[i] == 1e18 or dist_from_src2[i] == 1e18 or dist_from_dest[i] == 1e18) continue;\\n            minWeight = min(minWeight, dist_from_src1[i] + dist_from_src2[i] + dist_from_dest[i]);\\n        }\\n        \\n        return minWeight >= 1e18 ? -1 : minWeight;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854911,
                "title": "java-crisp-and-concise-tc-o-v-elogv-sc-o-v",
                "content": "```\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        List<int[]>[] graph = new List[n], graph_rev = new List[n];\\n        for (int i = 0; i < n; i++){\\n            graph[i] = new ArrayList<>();\\n            graph_rev[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(new int[]{e[1], e[2]});\\n            graph_rev[e[1]].add(new int[]{e[0], e[2]});\\n        }\\n        long ans = Long.MAX_VALUE;\\n        long[] a = dijkstra(graph_rev, n, dest);\\n        long[] b = dijkstra(graph, n, src1);\\n        long[] c = dijkstra(graph, n, src2);\\n        \\n        if(b[dest]==Long.MAX_VALUE || c[dest]==Long.MAX_VALUE) return -1;\\n        \\n        for(int i=0; i<n ; i++){\\n            if(a[i]==Long.MAX_VALUE || b[i]==Long.MAX_VALUE || c[i]==Long.MAX_VALUE) continue;\\n            ans = Math.min(ans, a[i]+b[i]+c[i]);\\n        }\\n        return ans==Long.MAX_VALUE ? -1 : ans;\\n    }\\n    long[] dijkstra(List<int[]>[] graph, int n, int src){\\n        long[] dist = new long[n];\\n        Arrays.fill(dist, Long.MAX_VALUE);\\n        dist[src] = 0;\\n        PriorityQueue<long[]> minHeap = new PriorityQueue<>((a, b) -> Long.compare(a[0], b[0]));\\n        minHeap.offer(new long[]{0, src});  // dist, src\\n        while (!minHeap.isEmpty()) {\\n            long[] top = minHeap.poll();\\n            long d = top[0];\\n            int u = (int) top[1];\\n            if (d > dist[u]) continue;\\n            for (int[] nei : graph[u]) {\\n                int v = nei[0], time = nei[1];\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    minHeap.add(new long[]{dist[v], v});\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        List<int[]>[] graph = new List[n], graph_rev = new List[n];\\n        for (int i = 0; i < n; i++){\\n            graph[i] = new ArrayList<>();\\n            graph_rev[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(new int[]{e[1], e[2]});\\n            graph_rev[e[1]].add(new int[]{e[0], e[2]});\\n        }\\n        long ans = Long.MAX_VALUE;\\n        long[] a = dijkstra(graph_rev, n, dest);\\n        long[] b = dijkstra(graph, n, src1);\\n        long[] c = dijkstra(graph, n, src2);\\n        \\n        if(b[dest]==Long.MAX_VALUE || c[dest]==Long.MAX_VALUE) return -1;\\n        \\n        for(int i=0; i<n ; i++){\\n            if(a[i]==Long.MAX_VALUE || b[i]==Long.MAX_VALUE || c[i]==Long.MAX_VALUE) continue;\\n            ans = Math.min(ans, a[i]+b[i]+c[i]);\\n        }\\n        return ans==Long.MAX_VALUE ? -1 : ans;\\n    }\\n    long[] dijkstra(List<int[]>[] graph, int n, int src){\\n        long[] dist = new long[n];\\n        Arrays.fill(dist, Long.MAX_VALUE);\\n        dist[src] = 0;\\n        PriorityQueue<long[]> minHeap = new PriorityQueue<>((a, b) -> Long.compare(a[0], b[0]));\\n        minHeap.offer(new long[]{0, src});  // dist, src\\n        while (!minHeap.isEmpty()) {\\n            long[] top = minHeap.poll();\\n            long d = top[0];\\n            int u = (int) top[1];\\n            if (d > dist[u]) continue;\\n            for (int[] nei : graph[u]) {\\n                int v = nei[0], time = nei[1];\\n                if (dist[v] > d + time) {\\n                    dist[v] = d + time;\\n                    minHeap.add(new long[]{dist[v], v});\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845216,
                "title": "single-source-shortest-path-c-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dik(int src,vector<long long int>&dis,vector<pair<int,int>>adlist[])\\n    {\\n        set<pair<long long int,int>> st;\\n        st.insert(make_pair(0,src));\\n        dis[src]=0;        \\n        while(st.size()!=0)\\n        {\\n            auto p=*st.begin();\\n            st.erase(st.begin());\\n            \\n            for(auto child:adlist[p.second])\\n            {\\n                if(p.first+child.first<dis[child.second])\\n                {\\n                    auto ptr=st.find(make_pair(dis[child.second],child.second));                    \\n                    if(ptr!=st.end()) st.erase(ptr);\\n                    dis[child.second]=p.first+child.first;\\n                    st.insert(make_pair(dis[child.second],child.second));\\n                }\\n            }\\n        }\\n        \\n        return ;\\n        \\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        \\n        vector<pair<int,int>> ad1[n+1],ad2[n+1];\\n        for(auto i:edges)\\n        {\\n            ad1[i[0]].push_back(make_pair(i[2],i[1]));\\n            ad2[i[1]].push_back(make_pair(i[2],i[0]));  // reversing the edges discussed later why?\\n        }\\n        \\n        vector<long long int> v1(n+1,LLONG_MAX),v2(n+1,LLONG_MAX),v3(n+1,LLONG_MAX);\\n        dik(src1,v1,ad1);\\n        dik(src2,v2,ad1);\\n        dik(dest,v3,ad2);\\n        \\n        // case 1 when there is no common path between them....\\n        \\n        if(v3[src1]==LLONG_MAX or v3[src2]==LLONG_MAX) return -1;\\n        long long int ans=v3[src1]+v3[src2];\\n        \\n        \\n        // case2 let assume i node was in between their path....\\n            \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            // let assume i node was in between their path..\\n            \\n            long long int a=v3[i],b=v1[i],c=v2[i];    \\n\\t\\t\\t// a denote cost from dest to i calculated from reverse graph...\\n\\t\\t\\t// b and c denote cost from src1 to i and src2 to i calculated from actual graph..\\n            // cout<<i<<\" \"<<a<<\" \"<<b<<\" \"<<c<<endl; \\n            if(a!=LLONG_MAX and b!=LLONG_MAX and c!=LLONG_MAX) ans=min(ans,a+b+c);\\n        }\\n\\t\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dik(int src,vector<long long int>&dis,vector<pair<int,int>>adlist[])\\n    {\\n        set<pair<long long int,int>> st;\\n        st.insert(make_pair(0,src));\\n        dis[src]=0;        \\n        while(st.size()!=0)\\n        {\\n            auto p=*st.begin();\\n            st.erase(st.begin());\\n            \\n            for(auto child:adlist[p.second])\\n            {\\n                if(p.first+child.first<dis[child.second])\\n                {\\n                    auto ptr=st.find(make_pair(dis[child.second],child.second));                    \\n                    if(ptr!=st.end()) st.erase(ptr);\\n                    dis[child.second]=p.first+child.first;\\n                    st.insert(make_pair(dis[child.second],child.second));\\n                }\\n            }\\n        }\\n        \\n        return ;\\n        \\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        \\n        vector<pair<int,int>> ad1[n+1],ad2[n+1];\\n        for(auto i:edges)\\n        {\\n            ad1[i[0]].push_back(make_pair(i[2],i[1]));\\n            ad2[i[1]].push_back(make_pair(i[2],i[0]));  // reversing the edges discussed later why?\\n        }\\n        \\n        vector<long long int> v1(n+1,LLONG_MAX),v2(n+1,LLONG_MAX),v3(n+1,LLONG_MAX);\\n        dik(src1,v1,ad1);\\n        dik(src2,v2,ad1);\\n        dik(dest,v3,ad2);\\n        \\n        // case 1 when there is no common path between them....\\n        \\n        if(v3[src1]==LLONG_MAX or v3[src2]==LLONG_MAX) return -1;\\n        long long int ans=v3[src1]+v3[src2];\\n        \\n        \\n        // case2 let assume i node was in between their path....\\n            \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            // let assume i node was in between their path..\\n            \\n            long long int a=v3[i],b=v1[i],c=v2[i];    \\n\\t\\t\\t// a denote cost from dest to i calculated from reverse graph...\\n\\t\\t\\t// b and c denote cost from src1 to i and src2 to i calculated from actual graph..\\n            // cout<<i<<\" \"<<a<<\" \"<<b<<\" \"<<c<<endl; \\n            if(a!=LLONG_MAX and b!=LLONG_MAX and c!=LLONG_MAX) ans=min(ans,a+b+c);\\n        }\\n\\t\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1844423,
                "title": "javascript-solution-beats-100",
                "content": "```js\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number} src1\\n * @param {number} src2\\n * @param {number} dest\\n * @return {number}\\n */\\nvar minimumWeight = function (n, edges, src1, src2, dest) {\\n    var paths = new Array(n).fill(0).map(i => []);\\n    var reversePaths = new Array(n).fill(0).map(i => []);\\n    for (var edge of edges) {\\n        var [u, v, w] = edge;\\n        paths[u].push([v, w]);\\n        reversePaths[v].push([u, w]);\\n    }\\n\\n    var dijkstra = function (start, paths) {\\n        var visited = [];\\n        var dp = new Array(n).fill(Number.MAX_SAFE_INTEGER);\\n        dp[start] = 0;\\n        \\n        var pq = new MinPriorityQueue({priority: item => item[1]});\\n        pq.enqueue([start, 0]);\\n        \\n        while(!pq.isEmpty()) {\\n            var [u, cost] = pq.dequeue().element;\\n            if (visited[u] || cost > dp[u]) continue;\\n            visited[u] = true;\\n            for (var path of paths[u]) {\\n                var [v, w] = path;\\n                if (dp[v] > dp[u] + w) {\\n                    dp[v] =  dp[u] + w;\\n                    pq.enqueue([v, dp[v]]);\\n                }\\n            }\\n        }\\n\\n        return dp;\\n    }\\n\\n    var dpStartFromSrc1 = dijkstra(src1, paths);\\n    var dpStartFromSrc2 = dijkstra(src2, paths);\\n    var dpStartFromDesc = dijkstra(dest, reversePaths);\\n\\n    var ans = Number.MAX_SAFE_INTEGER;\\n    for (var i = 0; i < n; i++) {\\n        ans = Math.min(ans, dpStartFromSrc1[i] + dpStartFromSrc2[i] + dpStartFromDesc[i]);\\n    }\\n\\n    return ans === Number.MAX_SAFE_INTEGER ? -1 : ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```js\\n/**\\n * @param {number} n\\n * @param {number[][]} edges\\n * @param {number} src1\\n * @param {number} src2\\n * @param {number} dest\\n * @return {number}\\n */\\nvar minimumWeight = function (n, edges, src1, src2, dest) {\\n    var paths = new Array(n).fill(0).map(i => []);\\n    var reversePaths = new Array(n).fill(0).map(i => []);\\n    for (var edge of edges) {\\n        var [u, v, w] = edge;\\n        paths[u].push([v, w]);\\n        reversePaths[v].push([u, w]);\\n    }\\n\\n    var dijkstra = function (start, paths) {\\n        var visited = [];\\n        var dp = new Array(n).fill(Number.MAX_SAFE_INTEGER);\\n        dp[start] = 0;\\n        \\n        var pq = new MinPriorityQueue({priority: item => item[1]});\\n        pq.enqueue([start, 0]);\\n        \\n        while(!pq.isEmpty()) {\\n            var [u, cost] = pq.dequeue().element;\\n            if (visited[u] || cost > dp[u]) continue;\\n            visited[u] = true;\\n            for (var path of paths[u]) {\\n                var [v, w] = path;\\n                if (dp[v] > dp[u] + w) {\\n                    dp[v] =  dp[u] + w;\\n                    pq.enqueue([v, dp[v]]);\\n                }\\n            }\\n        }\\n\\n        return dp;\\n    }\\n\\n    var dpStartFromSrc1 = dijkstra(src1, paths);\\n    var dpStartFromSrc2 = dijkstra(src2, paths);\\n    var dpStartFromDesc = dijkstra(dest, reversePaths);\\n\\n    var ans = Number.MAX_SAFE_INTEGER;\\n    for (var i = 0; i < n; i++) {\\n        ans = Math.min(ans, dpStartFromSrc1[i] + dpStartFromSrc2[i] + dpStartFromDesc[i]);\\n    }\\n\\n    return ans === Number.MAX_SAFE_INTEGER ? -1 : ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3708682,
                "title": "python3-dijkstra-simple-solution",
                "content": "# Intuition\\nShortest path in positive weight graph -> Dijkstra\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe idea is the following: paths from `s1` to `dest` and from `s2` to `dest` can have common point `x`. Then we need to reach:\\n\\nFrom `s1` to `x`, for this we use Dijkstra\\nFrom `s2` to `x`, same.\\nFrom `x` to `dest`, for this we use Dijkstra on the reversed graph.\\nFinally, we check all possible `x`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(ElogV)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(V + E)$$ ~ $$O(E)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g1 = collections.defaultdict(list)\\n        g2 = collections.defaultdict(list)\\n        for u, v , w in edges:\\n            g1[u].append((v, w))\\n            g2[v].append((u, w))\\n\\n        def get_distance(node: int, g: dict) -> List[float | int]:\\n            distance = [float(\\'inf\\') for _ in range(n)]\\n            distance[node] = 0\\n            q = [(0, node)]\\n            while q:\\n                d, u = heapq.heappop(q)\\n                if d > distance[u]: continue\\n                for v, w in g[u]:\\n                    if d + w < distance[v]:\\n                        distance[v] = d + w\\n                        heapq.heappush(q, (distance[v], v))\\n            return distance\\n        \\n        l1, l2, l3 = get_distance(src1, g1), get_distance(src2, g1), get_distance(dest, g2)\\n        ans = float(\"inf\")\\n        for i in range(n):\\n            ans = min(ans, l1[i] + l2[i] + l3[i])\\n        \\n        return ans if ans != float(\"inf\") else -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph",
                    "Heap (Priority Queue)",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g1 = collections.defaultdict(list)\\n        g2 = collections.defaultdict(list)\\n        for u, v , w in edges:\\n            g1[u].append((v, w))\\n            g2[v].append((u, w))\\n\\n        def get_distance(node: int, g: dict) -> List[float | int]:\\n            distance = [float(\\'inf\\') for _ in range(n)]\\n            distance[node] = 0\\n            q = [(0, node)]\\n            while q:\\n                d, u = heapq.heappop(q)\\n                if d > distance[u]: continue\\n                for v, w in g[u]:\\n                    if d + w < distance[v]:\\n                        distance[v] = d + w\\n                        heapq.heappush(q, (distance[v], v))\\n            return distance\\n        \\n        l1, l2, l3 = get_distance(src1, g1), get_distance(src2, g1), get_distance(dest, g2)\\n        ans = float(\"inf\")\\n        for i in range(n):\\n            ans = min(ans, l1[i] + l2[i] + l3[i])\\n        \\n        return ans if ans != float(\"inf\") else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2396999,
                "title": "c-dijkstra-solution-csharp",
                "content": "ans = Min(dij(src1)[node[i]] + dij(src2)[node[i]] + dij(reverse the directed graph)(dest)[node[i]]);   i : 0 -> n-1\\nthe node[i] should include themselves (src1, src2, dest)\\nthe minimum weight from a node to itself is 0 \\n```\\npublic class Solution {\\n    public long MinimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        Dictionary<int, List<(int, int)>> map = new();\\n        Dictionary<int, List<(int, int)>> reverse = new();\\n        for(int i = 0; i < edges.Length; i++){\\n            if(map.ContainsKey(edges[i][0])){\\n                map[edges[i][0]].Add((edges[i][1], edges[i][2]));\\n            }else{\\n                map.Add(edges[i][0], new List<(int, int)>{ (edges[i][1], edges[i][2]) });\\n            }\\n            if(reverse.ContainsKey(edges[i][1])){\\n                reverse[edges[i][1]].Add((edges[i][0], edges[i][2]));\\n            }else{\\n                reverse.Add(edges[i][1], new List<(int, int)>{ (edges[i][0], edges[i][2]) });\\n            }\\n        }        \\n        var s1 = GetMinWeights(n, src1, map);\\n        var s2 = GetMinWeights(n, src2, map);\\n        var d1 = GetMinWeights(n, dest, reverse);\\n        long ans = long.MaxValue;\\n        for(int i = 0; i < n; i++){\\n            if(s1[i] != long.MaxValue && s2[i] != long.MaxValue && d1[i] != long.MaxValue){\\n                ans = Math.Min(ans, s1[i] + s2[i] + d1[i]);\\n            }\\n        }\\n        return ans == long.MaxValue ? -1 : ans;\\n    }\\n    \\n    public Dictionary<int, long> GetMinWeights(int n, int newPoint, Dictionary<int, List<(int, int)>> map){\\n        Dictionary<int, long> dij = new();\\n        for(int i = 0; i < n; i++){\\n            dij.Add(i, long.MaxValue);\\n        }\\n        dij[newPoint] = 0;\\n        ISet<int> visited = new HashSet<int>{ newPoint };\\n        PriorityQueue<int, long> priorityQueue = new();\\n        while(visited.Count != n){\\n            if(map.ContainsKey(newPoint)){\\n                foreach(var next in map[newPoint]){\\n                    if(visited.Contains(next.Item1)){\\n                        continue;\\n                    }\\n                    long valueF = next.Item2 + dij[newPoint];\\n                    priorityQueue.Enqueue(next.Item1, valueF);\\n                    dij[next.Item1] = Math.Min(dij[next.Item1], valueF);\\n                }    \\n            }     \\n            int point = -1;\\n            while(priorityQueue.Count > 0){\\n                int nextMin = priorityQueue.Dequeue();\\n                if(!visited.Contains(nextMin)){\\n                    point = nextMin;\\n                    break;\\n                }\\n            }\\n            if(point == -1){\\n                break;\\n            }\\n            visited.Add(point);\\n            newPoint = point;\\n        }        \\n        return dij;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long MinimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        Dictionary<int, List<(int, int)>> map = new();\\n        Dictionary<int, List<(int, int)>> reverse = new();\\n        for(int i = 0; i < edges.Length; i++){\\n            if(map.ContainsKey(edges[i][0])){\\n                map[edges[i][0]].Add((edges[i][1], edges[i][2]));\\n            }else{\\n                map.Add(edges[i][0], new List<(int, int)>{ (edges[i][1], edges[i][2]) });\\n            }\\n            if(reverse.ContainsKey(edges[i][1])){\\n                reverse[edges[i][1]].Add((edges[i][0], edges[i][2]));\\n            }else{\\n                reverse.Add(edges[i][1], new List<(int, int)>{ (edges[i][0], edges[i][2]) });\\n            }\\n        }        \\n        var s1 = GetMinWeights(n, src1, map);\\n        var s2 = GetMinWeights(n, src2, map);\\n        var d1 = GetMinWeights(n, dest, reverse);\\n        long ans = long.MaxValue;\\n        for(int i = 0; i < n; i++){\\n            if(s1[i] != long.MaxValue && s2[i] != long.MaxValue && d1[i] != long.MaxValue){\\n                ans = Math.Min(ans, s1[i] + s2[i] + d1[i]);\\n            }\\n        }\\n        return ans == long.MaxValue ? -1 : ans;\\n    }\\n    \\n    public Dictionary<int, long> GetMinWeights(int n, int newPoint, Dictionary<int, List<(int, int)>> map){\\n        Dictionary<int, long> dij = new();\\n        for(int i = 0; i < n; i++){\\n            dij.Add(i, long.MaxValue);\\n        }\\n        dij[newPoint] = 0;\\n        ISet<int> visited = new HashSet<int>{ newPoint };\\n        PriorityQueue<int, long> priorityQueue = new();\\n        while(visited.Count != n){\\n            if(map.ContainsKey(newPoint)){\\n                foreach(var next in map[newPoint]){\\n                    if(visited.Contains(next.Item1)){\\n                        continue;\\n                    }\\n                    long valueF = next.Item2 + dij[newPoint];\\n                    priorityQueue.Enqueue(next.Item1, valueF);\\n                    dij[next.Item1] = Math.Min(dij[next.Item1], valueF);\\n                }    \\n            }     \\n            int point = -1;\\n            while(priorityQueue.Count > 0){\\n                int nextMin = priorityQueue.Dequeue();\\n                if(!visited.Contains(nextMin)){\\n                    point = nextMin;\\n                    break;\\n                }\\n            }\\n            if(point == -1){\\n                break;\\n            }\\n            visited.Add(point);\\n            newPoint = point;\\n        }        \\n        return dij;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2079569,
                "title": "c-dijkstra-s-algorithm-clean-code",
                "content": "```\\n// {weight, node}\\ntypedef pair<long, int> node;\\n\\nclass Solution {\\nprivate:\\n    vector<long> dijkstra(int src, int n, vector<vector<node>> &graph) {\\n        // withoud used array gives TLE\\n        // bcz, a node may be pushed into queue multiple time\\n        // iterating all of its child again and again is not fruitful\\n        \\n        vector<bool> used(n, false);\\n        vector<long> dist(n, 1e18);\\n        dist[src] = 0;\\n        \\n        priority_queue<node, vector<node>, greater<node>> q;\\n        q.push({0, src});\\n        while(!q.empty()) {\\n            auto curr = q.top();\\n            q.pop();\\n            // long w = curr.first;\\n            long u = curr.second;\\n            \\n            if(used[u])\\n                continue;\\n            used[u] = true;\\n            \\n            for(auto it: graph[u]) {\\n                int v = it.first;\\n                long w = it.second;\\n                if(dist[u] + w < dist[v]) {\\n                    dist[v] = dist[u] + w;\\n                    q.push({dist[v], v});\\n                }\\n            }\\n        }\\n        \\n        return dist;\\n    }\\n    \\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<node>> graph(n), rev_graph(n);\\n        for(auto it: edges) {\\n            int u = it[0];\\n            int v = it[1];\\n            int w = it[2];\\n            graph[u].push_back({v, w});\\n            rev_graph[v].push_back({u, w});\\n        }\\n        \\n        vector<long> dist1 = dijkstra(src1, n, graph);\\n        vector<long> dist2 = dijkstra(src2, n, graph);\\n        vector<long> dist3 = dijkstra(dest, n, rev_graph);\\n        \\n        long ans = 1e18;\\n        for(int i = 0; i < n; i++) {\\n            if(dist1[i] != 1e18 && dist2[i] != 1e18 && dist3[i] != 1e18)\\n                ans = min(ans, dist1[i] + dist2[i] + dist3[i]);\\n        }\\n        \\n        return ans == 1e18 ? -1 : ans;\\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// {weight, node}\\ntypedef pair<long, int> node;\\n\\nclass Solution {\\nprivate:\\n    vector<long> dijkstra(int src, int n, vector<vector<node>> &graph) {\\n        // withoud used array gives TLE\\n        // bcz, a node may be pushed into queue multiple time\\n        // iterating all of its child again and again is not fruitful\\n        \\n        vector<bool> used(n, false);\\n        vector<long> dist(n, 1e18);\\n        dist[src] = 0;\\n        \\n        priority_queue<node, vector<node>, greater<node>> q;\\n        q.push({0, src});\\n        while(!q.empty()) {\\n            auto curr = q.top();\\n            q.pop();\\n            // long w = curr.first;\\n            long u = curr.second;\\n            \\n            if(used[u])\\n                continue;\\n            used[u] = true;\\n            \\n            for(auto it: graph[u]) {\\n                int v = it.first;\\n                long w = it.second;\\n                if(dist[u] + w < dist[v]) {\\n                    dist[v] = dist[u] + w;\\n                    q.push({dist[v], v});\\n                }\\n            }\\n        }\\n        \\n        return dist;\\n    }\\n    \\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<node>> graph(n), rev_graph(n);\\n        for(auto it: edges) {\\n            int u = it[0];\\n            int v = it[1];\\n            int w = it[2];\\n            graph[u].push_back({v, w});\\n            rev_graph[v].push_back({u, w});\\n        }\\n        \\n        vector<long> dist1 = dijkstra(src1, n, graph);\\n        vector<long> dist2 = dijkstra(src2, n, graph);\\n        vector<long> dist3 = dijkstra(dest, n, rev_graph);\\n        \\n        long ans = 1e18;\\n        for(int i = 0; i < n; i++) {\\n            if(dist1[i] != 1e18 && dist2[i] != 1e18 && dist3[i] != 1e18)\\n                ans = min(ans, dist1[i] + dist2[i] + dist3[i]);\\n        }\\n        \\n        return ans == 1e18 ? -1 : ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867689,
                "title": "three-min-costs-to-every-node-97-speed",
                "content": "![image](https://assets.leetcode.com/users/images/158e4384-3509-4f1d-b8ff-4323f28650e5_1647791509.264814.png)\\n```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        forward, backward = dict(), dict()\\n        for start, end, weight in edges:\\n            if start in forward:\\n                if end in forward[start]:\\n                    forward[start][end] = min(weight, forward[start][end])\\n                else:\\n                    forward[start][end] = weight\\n            else:\\n                forward[start] = {end: weight}\\n            if end in backward:\\n                if start in backward[end]:\\n                    backward[end][start] = min(weight, backward[end][start])\\n                else:\\n                    backward[end][start] = weight\\n            else:\\n                backward[end] = {start: weight}\\n\\n        def travel(origin: int, relations: dict, costs: list) -> None:\\n            level = {origin}\\n            costs[origin] = 0\\n            while level:\\n                new_level = set()\\n                for node in level:\\n                    if node in relations:\\n                        for next_node, w in relations[node].items():\\n                            if w + costs[node] < costs[next_node]:\\n                                new_level.add(next_node)\\n                                costs[next_node] = w + costs[node]\\n                level = new_level\\n\\n        from_src1 = [inf] * n\\n        from_src2 = [inf] * n\\n        from_dest = [inf] * n\\n\\n        travel(src1, forward, from_src1)\\n        travel(src2, forward, from_src2)\\n        travel(dest, backward, from_dest)\\n\\n        combined_cost = min(sum(tpl)\\n                            for tpl in zip(from_src1, from_src2, from_dest))\\n\\n        return combined_cost if combined_cost < inf else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        forward, backward = dict(), dict()\\n        for start, end, weight in edges:\\n            if start in forward:\\n                if end in forward[start]:\\n                    forward[start][end] = min(weight, forward[start][end])\\n                else:\\n                    forward[start][end] = weight\\n            else:\\n                forward[start] = {end: weight}\\n            if end in backward:\\n                if start in backward[end]:\\n                    backward[end][start] = min(weight, backward[end][start])\\n                else:\\n                    backward[end][start] = weight\\n            else:\\n                backward[end] = {start: weight}\\n\\n        def travel(origin: int, relations: dict, costs: list) -> None:\\n            level = {origin}\\n            costs[origin] = 0\\n            while level:\\n                new_level = set()\\n                for node in level:\\n                    if node in relations:\\n                        for next_node, w in relations[node].items():\\n                            if w + costs[node] < costs[next_node]:\\n                                new_level.add(next_node)\\n                                costs[next_node] = w + costs[node]\\n                level = new_level\\n\\n        from_src1 = [inf] * n\\n        from_src2 = [inf] * n\\n        from_dest = [inf] * n\\n\\n        travel(src1, forward, from_src1)\\n        travel(src2, forward, from_src2)\\n        travel(dest, backward, from_dest)\\n\\n        combined_cost = min(sum(tpl)\\n                            for tpl in zip(from_src1, from_src2, from_dest))\\n\\n        return combined_cost if combined_cost < inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861503,
                "title": "a-few-solutions",
                "content": "Let `a`, `b`, `c` be the single-source-shortest-paths (SSSP) starting from source `S1`, source `S2`, and target `T` correspondingly.  The SSSP starting from `S1` and `S2` are performed on the forward graph `G`.  The SSSP starting from `T` is performed on the reverse graph `R` since the optimal shared path between `S1` and `S2` *must* converge at some `i`<sup>th</sup> node from `i = 0..N - 1` inclusive (note: `i`<sup>th</sup> node candidates include `S1`, `S2`, and `T`).  We use the reverse graph `R` and SSSP starting from `T` to track the cost of a shared path between `S1` and `S2` to `T` in reverse from `T` \\uD83D\\uDC49 `i`, ie. `c[i]`.\\n\\nIn summary, we are trying to find the optimal path convergence node `i` where `S1` and `S2` paths meet on their way to `T`:\\n\\n`a[i] + b[i] + c[i]` = (**single path** cost from `S1` \\uD83D\\uDC49 `i`) + (**single path** cost from `S2` \\uD83D\\uDC49 `i`) + (**shared path** cost from `T` \\uD83D\\uDC49 `i`)\\n\\nNote: SPFA is a natural progression from Bellman-Ford, ie. instead of naively attempting to relax every edge `N - 1` times, we can instead attempt to relax \"candidate\" edges per the queue `q` of potential \"next hops\".\\n\\n---\\n\\n**Kotlin Solutions:**\\n\\n*Bellman-Ford: TLE*\\n```\\nclass Solution {\\n    fun minimumWeight(N: Int, A: Array<IntArray>, S1: Int, S2: Int, T: Int, INF: Long = (1e9 + 7).toLong()): Long {\\n        fun bell(start: Int): LongArray {\\n            var rev = start == T\\n            var dist = LongArray(N) { INF }\\n            dist[start] = 0\\n            var relax = {\\n                for ((u_, v_, w) in A) {\\n                    var (u, v) = if (!rev) Pair(u_, v_) else Pair(v_, u_)\\n                    if (dist[v] > dist[u] + w)\\n                        dist[v] = dist[u] + w\\n                }\\n            }\\n            for (i in 0 until N - 1)\\n                relax()\\n            return dist\\n        }\\n        var a = bell(S1)\\n        var b = bell(S2)\\n        var c = bell(T)\\n        var best = INF\\n        for (i in 0 until N) {\\n            var cand = a[i] + b[i] + c[i]\\n            best = Math.min(best, cand)\\n        }\\n        return if (best < INF) best else -1\\n    }\\n}\\n```\\n\\n*SPFA: AC*\\n```\\nclass Solution {\\n    fun minimumWeight(N: Int, A: Array<IntArray>, S1: Int, S2: Int, T: Int, INF: Long = Long.MAX_VALUE): Long {\\n        var cost = mutableMapOf<String, Long>()\\n        var key = { u: Int, v: Int -> \"$u,$v\" }\\n        fun makeGraph(): Pair<MutableMap<Int, MutableSet<Int>>, MutableMap<Int, MutableSet<Int>>> {\\n            var adj = mutableMapOf<Int, MutableSet<Int>>()\\n            var rev = mutableMapOf<Int, MutableSet<Int>>()\\n            for ((u, v, w) in A) {\\n                if (!adj.contains(u)) adj[u] = mutableSetOf<Int>()\\n                if (!rev.contains(v)) rev[v] = mutableSetOf<Int>()\\n                adj[u]!!.add(v); cost[key(u, v)] = Math.min(w.toLong(), (cost[key(u, v)] ?: INF))\\n                rev[v]!!.add(u); cost[key(v, u)] = Math.min(w.toLong(), (cost[key(v, u)] ?: INF))\\n            }\\n            return Pair(adj, rev)\\n        }\\n        var (adj, rev) = makeGraph()\\n        fun spfa(start: Int): LongArray {\\n            var dist = LongArray(N) { INF }\\n            dist[start] = 0\\n            var q: Queue<Int> = LinkedList<Int>(listOf(start))\\n            while (0 < q.size) {\\n                var u = q.poll()\\n                for (v in if (start != T) adj[u] ?: mutableSetOf<Int>() else rev[u] ?: mutableSetOf<Int>()) {\\n                    if (dist[v] > dist[u] + cost[key(u, v)]!!) {\\n                        dist[v] = dist[u] + cost[key(u, v)]!!; q.add(v)\\n                    }\\n                }\\n            }\\n            return dist\\n        }\\n        var a = spfa(S1)\\n        var b = spfa(S2)\\n        var c = spfa(T)\\n        var (best, cand) = Pair(INF, INF)\\n        for (i in 0 until N) {\\n            if (!(a[i] < INF && b[i] < INF && c[i] < INF))\\n                continue\\n            cand = a[i] + b[i] + c[i]\\n            best = Math.min(best, cand)\\n        }\\n        return if (best < INF) best else -1\\n    }\\n}\\n```\\n\\n---\\n\\n**Javascript Solutions:**\\n\\n*Bellman-Ford: TLE*\\n```\\nlet minimumWeight = (N, A, S1, S2, T, best = Infinity) => {\\n    let bell = start => {\\n        let rev = start == T;\\n        let dist = Array(N).fill(Infinity);\\n        dist[start] = 0;\\n        let relax = () => {\\n            for (let [u, v, w] of A) {\\n                if (rev)\\n                    [u, v] = [v, u];\\n                if (dist[v] > dist[u] + w)\\n                    dist[v] = dist[u] + w;\\n            }\\n        };\\n        for (let i = 0; i < N - 1; ++i)\\n            relax();\\n        return dist;\\n    };\\n    let a = bell(S1),\\n        b = bell(S2),\\n        c = bell(T);\\n    for (let i = 0; i < N; ++i) {\\n        let cand = a[i] + b[i] + c[i];\\n        best = Math.min(best, cand);\\n    }\\n    return best < Infinity ? best : -1;\\n};\\n```\\n\\n*Shortest Paths Faster Algorithm: AC*\\n```\\nlet minimumWeight = (N, A, S1, S2, T, best = Infinity) => {\\n    let key = (u, v) => `${u},${v}`;\\n    let makeGraph = rev => {\\n        let G = { adj: new Map(), cost: new Map() };\\n        let [adj, cost] = [G.adj, G.cost];\\n        for (let [u, v, w] of A) {\\n            if (rev)\\n                [u, v] = [v, u];\\n            if (!adj.has(u))\\n                adj.set(u, new Set());\\n            adj.get(u).add(v);\\n            let k = key(u, v);\\n            cost.set(k, Math.min(cost.get(k) || Infinity, w));\\n        }\\n        return G;\\n    };\\n    let spfa = (start, adj, cost) => {\\n        let dist = Array(N).fill(Infinity);\\n        dist[start] = 0;\\n        let q = [start];\\n        while (q.length) {\\n            let u = q.shift();\\n            for (let v of adj.get(u) || [])\\n                if (dist[v] > dist[u] + cost.get(key(u, v)))\\n                    dist[v] = dist[u] + cost.get(key(u, v)), q.push(v);\\n        }\\n        return dist;\\n    };\\n    let [G, R] = [makeGraph(false), makeGraph(true)];\\n    let a = spfa(S1, G.adj, G.cost),\\n        b = spfa(S2, G.adj, G.cost),\\n        c = spfa(T, R.adj, R.cost);\\n    for (let i = 0; i < N; ++i) {\\n        let cand = a[i] + b[i] + c[i];\\n        best = Math.min(best, cand);\\n    }\\n    return best < Infinity ? best : -1;\\n};\\n```\\n\\n---\\n\\n**Python3 Solutions:**\\n\\n*Bellman-Ford: TLE*\\n```\\nclass Solution:\\n    def minimumWeight(self, N: int, A: List[List[int]], S1: int, S2: int, T: int, INF = float(\\'inf\\')) -> int:\\n        def bell(start):\\n            dist = [INF] * N\\n            dist[start] = 0\\n            def relax():\\n                for u, v, w in A:\\n                    if start == T:\\n                        u, v = v, u\\n                    if dist[v] > dist[u] + w:\\n                        dist[v] = dist[u] + w\\n            for _ in range(N - 1):\\n                relax()\\n            return dist\\n        a = bell(S1)\\n        b = bell(S2)\\n        c = bell(T)\\n        best, cand = INF, INF\\n        for i in range(N):\\n            if not (a[i] < INF and b[i] < INF and c[i] < INF):\\n                continue\\n            cand = a[i] + b[i] + c[i]\\n            best = min(best, cand)\\n        return best if best < INF else -1\\n```\\n\\n*SPFA: AC*\\n```\\nclass Solution:\\n    def minimumWeight(self, N: int, A: List[List[int]], S1: int, S2: int, T: int, INF = float(\\'inf\\')) -> int:\\n        cost, cost_rev = {}, {}\\n        key = lambda u, v: f\\'{u},{v}\\'\\n        def makeGraph():\\n            adj, rev = {i: set() for i in range(N)}, {i: set() for i in range(N)}\\n            for u, v, w in A:\\n                adj[u].add(v); cost[key(u, v)] = min(w, cost[key(u, v)] if key(u, v) in cost else INF)\\n                rev[v].add(u); cost_rev[key(v, u)] = min(w, cost_rev[key(v, u)] if key(v, u) in cost_rev else INF)\\n            return adj, rev\\n        \\n        adj, rev = makeGraph()\\n        def spfa(start):\\n            reverse = bool(start != T)\\n            dist = [INF] * N\\n            dist[start] = 0\\n            q = deque([start])\\n            while q:\\n                u = q.popleft()\\n                for v in (adj[u] if reverse else rev[u]):\\n                    if dist[v] > dist[u] + (cost[key(u, v)] if reverse else cost_rev[key(u, v)]):\\n                        dist[v] = dist[u] + (cost[key(u, v)] if reverse else cost_rev[key(u, v)]); q.append(v)\\n            return dist\\n        a = spfa(S1)\\n        b = spfa(S2)\\n        c = spfa(T)\\n        best, cand = INF, INF\\n        for i in range(N):\\n            if a[i] < INF and b[i] < INF and c[i] < INF:\\n                cand = a[i] + b[i] + c[i]\\n                best = min(best, cand)\\n        return best if best < INF else -1\\n```\\n\\n---\\n\\n**C++ Solutions:**\\n\\n*Bellman-Ford: TLE*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    LL minimumWeight(int N, VVI& A, int S1, int S2, int T, LL INF = 1e9 + 7) {\\n        auto bell = [&](auto start) {\\n            VL dist(N, INF);\\n            dist[start] = 0;\\n            auto rev = start == T;\\n            auto relax = [&]() {\\n                for (auto& edge: A) {\\n                    auto [u, v, w] = make_tuple(edge[0], edge[1], edge[2]);\\n                    if (rev)\\n                        swap(u, v);\\n                    if (dist[v] > dist[u] + w)\\n                        dist[v] = dist[u] + w;\\n                }\\n            };\\n            for (auto i{ 0 }; i + 1 < N; ++i)\\n                relax();\\n            return dist;\\n        };\\n        auto a = bell(S1),\\n             b = bell(S2),\\n             c = bell(T);\\n        auto best = INF;\\n        for (auto i{ 0 }; i < N; ++i) {\\n            if (a[i] < INF && b[i] < INF && c[i] < INF) {\\n                auto cand = a[i] + b[i] + c[i];\\n                best = min(best, cand);\\n            }\\n        }\\n        return best < INF ? best : -1;\\n    }\\n};\\n```\\n\\n*SPFA: TLE*\\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Queue = queue<int>;\\n    using Set = unordered_set<int>;\\n    using Map = unordered_map<int, Set>;\\n    using Cost = unordered_map<string, int>;\\n    LL minimumWeight(int N, VVI& A, int S1, int S2, int T, Map adj = {}, Map rev = {}, Cost cost = {}, LL INF = numeric_limits<LL>::max()) {\\n        auto key = [](auto u, auto v) {\\n            stringstream ss; ss << u << \",\" << v;\\n            return ss.str();\\n        };\\n        for (auto& edge: A) {\\n            auto [u, v, w] = make_tuple(edge[0], edge[1], edge[2]);\\n            adj[u].insert(v), cost[key(u, v)] = cost.find(key(u, v)) == cost.end() ? w : min(cost[key(u, v)], w);\\n            rev[v].insert(u), cost[key(v, u)] = cost.find(key(v, u)) == cost.end() ? w : min(cost[key(v, u)], w);\\n        }\\n        auto spfa = [&](auto start) {\\n            VL dist(N, INF);\\n            dist[start] = 0;\\n            auto reverse = start == T;\\n            Queue q{{{ start }}};\\n            while (q.size()) {\\n                int k = q.size();\\n                while (k--) {\\n                    auto u = q.front(); q.pop();\\n                    for (auto v: reverse ? rev[u] : adj[u])\\n                        if (dist[v] > dist[u] + cost[key(u, v)])\\n                            dist[v] = dist[u] + cost[key(u, v)], q.push(v);\\n                }\\n            }\\n            return dist;\\n        };\\n        auto a = spfa(S1),\\n             b = spfa(S2),\\n             c = spfa(T);\\n        auto best = INF;\\n        for (auto i{ 0 }; i < N; ++i) {\\n            if (a[i] < INF && b[i] < INF && c[i] < INF) {\\n                auto cand = a[i] + b[i] + c[i];\\n                best = min(best, cand);\\n            }\\n        }\\n        return best < INF ? best : -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minimumWeight(N: Int, A: Array<IntArray>, S1: Int, S2: Int, T: Int, INF: Long = (1e9 + 7).toLong()): Long {\\n        fun bell(start: Int): LongArray {\\n            var rev = start == T\\n            var dist = LongArray(N) { INF }\\n            dist[start] = 0\\n            var relax = {\\n                for ((u_, v_, w) in A) {\\n                    var (u, v) = if (!rev) Pair(u_, v_) else Pair(v_, u_)\\n                    if (dist[v] > dist[u] + w)\\n                        dist[v] = dist[u] + w\\n                }\\n            }\\n            for (i in 0 until N - 1)\\n                relax()\\n            return dist\\n        }\\n        var a = bell(S1)\\n        var b = bell(S2)\\n        var c = bell(T)\\n        var best = INF\\n        for (i in 0 until N) {\\n            var cand = a[i] + b[i] + c[i]\\n            best = Math.min(best, cand)\\n        }\\n        return if (best < INF) best else -1\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minimumWeight(N: Int, A: Array<IntArray>, S1: Int, S2: Int, T: Int, INF: Long = Long.MAX_VALUE): Long {\\n        var cost = mutableMapOf<String, Long>()\\n        var key = { u: Int, v: Int -> \"$u,$v\" }\\n        fun makeGraph(): Pair<MutableMap<Int, MutableSet<Int>>, MutableMap<Int, MutableSet<Int>>> {\\n            var adj = mutableMapOf<Int, MutableSet<Int>>()\\n            var rev = mutableMapOf<Int, MutableSet<Int>>()\\n            for ((u, v, w) in A) {\\n                if (!adj.contains(u)) adj[u] = mutableSetOf<Int>()\\n                if (!rev.contains(v)) rev[v] = mutableSetOf<Int>()\\n                adj[u]!!.add(v); cost[key(u, v)] = Math.min(w.toLong(), (cost[key(u, v)] ?: INF))\\n                rev[v]!!.add(u); cost[key(v, u)] = Math.min(w.toLong(), (cost[key(v, u)] ?: INF))\\n            }\\n            return Pair(adj, rev)\\n        }\\n        var (adj, rev) = makeGraph()\\n        fun spfa(start: Int): LongArray {\\n            var dist = LongArray(N) { INF }\\n            dist[start] = 0\\n            var q: Queue<Int> = LinkedList<Int>(listOf(start))\\n            while (0 < q.size) {\\n                var u = q.poll()\\n                for (v in if (start != T) adj[u] ?: mutableSetOf<Int>() else rev[u] ?: mutableSetOf<Int>()) {\\n                    if (dist[v] > dist[u] + cost[key(u, v)]!!) {\\n                        dist[v] = dist[u] + cost[key(u, v)]!!; q.add(v)\\n                    }\\n                }\\n            }\\n            return dist\\n        }\\n        var a = spfa(S1)\\n        var b = spfa(S2)\\n        var c = spfa(T)\\n        var (best, cand) = Pair(INF, INF)\\n        for (i in 0 until N) {\\n            if (!(a[i] < INF && b[i] < INF && c[i] < INF))\\n                continue\\n            cand = a[i] + b[i] + c[i]\\n            best = Math.min(best, cand)\\n        }\\n        return if (best < INF) best else -1\\n    }\\n}\\n```\n```\\nlet minimumWeight = (N, A, S1, S2, T, best = Infinity) => {\\n    let bell = start => {\\n        let rev = start == T;\\n        let dist = Array(N).fill(Infinity);\\n        dist[start] = 0;\\n        let relax = () => {\\n            for (let [u, v, w] of A) {\\n                if (rev)\\n                    [u, v] = [v, u];\\n                if (dist[v] > dist[u] + w)\\n                    dist[v] = dist[u] + w;\\n            }\\n        };\\n        for (let i = 0; i < N - 1; ++i)\\n            relax();\\n        return dist;\\n    };\\n    let a = bell(S1),\\n        b = bell(S2),\\n        c = bell(T);\\n    for (let i = 0; i < N; ++i) {\\n        let cand = a[i] + b[i] + c[i];\\n        best = Math.min(best, cand);\\n    }\\n    return best < Infinity ? best : -1;\\n};\\n```\n```\\nlet minimumWeight = (N, A, S1, S2, T, best = Infinity) => {\\n    let key = (u, v) => `${u},${v}`;\\n    let makeGraph = rev => {\\n        let G = { adj: new Map(), cost: new Map() };\\n        let [adj, cost] = [G.adj, G.cost];\\n        for (let [u, v, w] of A) {\\n            if (rev)\\n                [u, v] = [v, u];\\n            if (!adj.has(u))\\n                adj.set(u, new Set());\\n            adj.get(u).add(v);\\n            let k = key(u, v);\\n            cost.set(k, Math.min(cost.get(k) || Infinity, w));\\n        }\\n        return G;\\n    };\\n    let spfa = (start, adj, cost) => {\\n        let dist = Array(N).fill(Infinity);\\n        dist[start] = 0;\\n        let q = [start];\\n        while (q.length) {\\n            let u = q.shift();\\n            for (let v of adj.get(u) || [])\\n                if (dist[v] > dist[u] + cost.get(key(u, v)))\\n                    dist[v] = dist[u] + cost.get(key(u, v)), q.push(v);\\n        }\\n        return dist;\\n    };\\n    let [G, R] = [makeGraph(false), makeGraph(true)];\\n    let a = spfa(S1, G.adj, G.cost),\\n        b = spfa(S2, G.adj, G.cost),\\n        c = spfa(T, R.adj, R.cost);\\n    for (let i = 0; i < N; ++i) {\\n        let cand = a[i] + b[i] + c[i];\\n        best = Math.min(best, cand);\\n    }\\n    return best < Infinity ? best : -1;\\n};\\n```\n```\\nclass Solution:\\n    def minimumWeight(self, N: int, A: List[List[int]], S1: int, S2: int, T: int, INF = float(\\'inf\\')) -> int:\\n        def bell(start):\\n            dist = [INF] * N\\n            dist[start] = 0\\n            def relax():\\n                for u, v, w in A:\\n                    if start == T:\\n                        u, v = v, u\\n                    if dist[v] > dist[u] + w:\\n                        dist[v] = dist[u] + w\\n            for _ in range(N - 1):\\n                relax()\\n            return dist\\n        a = bell(S1)\\n        b = bell(S2)\\n        c = bell(T)\\n        best, cand = INF, INF\\n        for i in range(N):\\n            if not (a[i] < INF and b[i] < INF and c[i] < INF):\\n                continue\\n            cand = a[i] + b[i] + c[i]\\n            best = min(best, cand)\\n        return best if best < INF else -1\\n```\n```\\nclass Solution:\\n    def minimumWeight(self, N: int, A: List[List[int]], S1: int, S2: int, T: int, INF = float(\\'inf\\')) -> int:\\n        cost, cost_rev = {}, {}\\n        key = lambda u, v: f\\'{u},{v}\\'\\n        def makeGraph():\\n            adj, rev = {i: set() for i in range(N)}, {i: set() for i in range(N)}\\n            for u, v, w in A:\\n                adj[u].add(v); cost[key(u, v)] = min(w, cost[key(u, v)] if key(u, v) in cost else INF)\\n                rev[v].add(u); cost_rev[key(v, u)] = min(w, cost_rev[key(v, u)] if key(v, u) in cost_rev else INF)\\n            return adj, rev\\n        \\n        adj, rev = makeGraph()\\n        def spfa(start):\\n            reverse = bool(start != T)\\n            dist = [INF] * N\\n            dist[start] = 0\\n            q = deque([start])\\n            while q:\\n                u = q.popleft()\\n                for v in (adj[u] if reverse else rev[u]):\\n                    if dist[v] > dist[u] + (cost[key(u, v)] if reverse else cost_rev[key(u, v)]):\\n                        dist[v] = dist[u] + (cost[key(u, v)] if reverse else cost_rev[key(u, v)]); q.append(v)\\n            return dist\\n        a = spfa(S1)\\n        b = spfa(S2)\\n        c = spfa(T)\\n        best, cand = INF, INF\\n        for i in range(N):\\n            if a[i] < INF and b[i] < INF and c[i] < INF:\\n                cand = a[i] + b[i] + c[i]\\n                best = min(best, cand)\\n        return best if best < INF else -1\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    LL minimumWeight(int N, VVI& A, int S1, int S2, int T, LL INF = 1e9 + 7) {\\n        auto bell = [&](auto start) {\\n            VL dist(N, INF);\\n            dist[start] = 0;\\n            auto rev = start == T;\\n            auto relax = [&]() {\\n                for (auto& edge: A) {\\n                    auto [u, v, w] = make_tuple(edge[0], edge[1], edge[2]);\\n                    if (rev)\\n                        swap(u, v);\\n                    if (dist[v] > dist[u] + w)\\n                        dist[v] = dist[u] + w;\\n                }\\n            };\\n            for (auto i{ 0 }; i + 1 < N; ++i)\\n                relax();\\n            return dist;\\n        };\\n        auto a = bell(S1),\\n             b = bell(S2),\\n             c = bell(T);\\n        auto best = INF;\\n        for (auto i{ 0 }; i < N; ++i) {\\n            if (a[i] < INF && b[i] < INF && c[i] < INF) {\\n                auto cand = a[i] + b[i] + c[i];\\n                best = min(best, cand);\\n            }\\n        }\\n        return best < INF ? best : -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using LL = long long;\\n    using VL = vector<LL>;\\n    using VI = vector<int>;\\n    using VVI = vector<VI>;\\n    using Queue = queue<int>;\\n    using Set = unordered_set<int>;\\n    using Map = unordered_map<int, Set>;\\n    using Cost = unordered_map<string, int>;\\n    LL minimumWeight(int N, VVI& A, int S1, int S2, int T, Map adj = {}, Map rev = {}, Cost cost = {}, LL INF = numeric_limits<LL>::max()) {\\n        auto key = [](auto u, auto v) {\\n            stringstream ss; ss << u << \",\" << v;\\n            return ss.str();\\n        };\\n        for (auto& edge: A) {\\n            auto [u, v, w] = make_tuple(edge[0], edge[1], edge[2]);\\n            adj[u].insert(v), cost[key(u, v)] = cost.find(key(u, v)) == cost.end() ? w : min(cost[key(u, v)], w);\\n            rev[v].insert(u), cost[key(v, u)] = cost.find(key(v, u)) == cost.end() ? w : min(cost[key(v, u)], w);\\n        }\\n        auto spfa = [&](auto start) {\\n            VL dist(N, INF);\\n            dist[start] = 0;\\n            auto reverse = start == T;\\n            Queue q{{{ start }}};\\n            while (q.size()) {\\n                int k = q.size();\\n                while (k--) {\\n                    auto u = q.front(); q.pop();\\n                    for (auto v: reverse ? rev[u] : adj[u])\\n                        if (dist[v] > dist[u] + cost[key(u, v)])\\n                            dist[v] = dist[u] + cost[key(u, v)], q.push(v);\\n                }\\n            }\\n            return dist;\\n        };\\n        auto a = spfa(S1),\\n             b = spfa(S2),\\n             c = spfa(T);\\n        auto best = INF;\\n        for (auto i{ 0 }; i < N; ++i) {\\n            if (a[i] < INF && b[i] < INF && c[i] < INF) {\\n                auto cand = a[i] + b[i] + c[i];\\n                best = min(best, cand);\\n            }\\n        }\\n        return best < INF ? best : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1854613,
                "title": "c-dijkstra-s-algo-tc-o-nlogn",
                "content": "```\\nclass Solution {\\nprivate:\\n    typedef pair<long, long>p;\\n    void Dijkstra(vector<vector<p>> &graph,int source,vector<long>&distTo)\\n    {\\n        priority_queue<p, vector<p>, greater<p>>pq;\\n        distTo[source] = 0;\\n        pq.push(make_pair(0,source)); // (dist,from)\\n        while(!pq.empty())\\n        {\\n            long long dist = pq.top().first;\\n            long long prev = pq.top().second;\\n            pq.pop();\\n            vector<p>::iterator it;\\n            if(distTo[prev] < dist)\\n                continue;\\n            for(auto it : graph[prev])\\n            {\\n                long next = it.first;\\n                long nextDist = it.second;\\n                if(distTo[next] > dist + nextDist)\\n                {\\n                    distTo[next] = distTo[prev] + nextDist;\\n                    pq.push(make_pair(distTo[next],next));\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) \\n    {\\n        vector<vector<p>>graph(n);\\n        vector<vector<p>>revGraph(n);\\n        \\n        for(auto it : edges)\\n        {\\n            int u = it[0], v = it[1], w = it[2];\\n            graph[u].push_back({v,w});\\n            revGraph[v].push_back({u,w});\\n        }\\n        \\n        vector<long>d1(n, LONG_MAX), d2(n,LONG_MAX), d3(n,LONG_MAX);\\n        \\n        Dijkstra(graph,src1,d1);\\n        Dijkstra(graph,src2,d2);\\n        Dijkstra(revGraph,dest,d3);\\n        \\n        long res = LONG_MAX;\\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            if(d1[i] == LONG_MAX || d2[i] == LONG_MAX || d3[i] == LONG_MAX)\\n                continue;\\n            res = min(res, d1[i] + d2[i] + d3[i]);\\n        }\\n        return res == LONG_MAX ? -1: res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    typedef pair<long, long>p;\\n    void Dijkstra(vector<vector<p>> &graph,int source,vector<long>&distTo)\\n    {\\n        priority_queue<p, vector<p>, greater<p>>pq;\\n        distTo[source] = 0;\\n        pq.push(make_pair(0,source)); // (dist,from)\\n        while(!pq.empty())\\n        {\\n            long long dist = pq.top().first;\\n            long long prev = pq.top().second;\\n            pq.pop();\\n            vector<p>::iterator it;\\n            if(distTo[prev] < dist)\\n                continue;\\n            for(auto it : graph[prev])\\n            {\\n                long next = it.first;\\n                long nextDist = it.second;\\n                if(distTo[next] > dist + nextDist)\\n                {\\n                    distTo[next] = distTo[prev] + nextDist;\\n                    pq.push(make_pair(distTo[next],next));\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) \\n    {\\n        vector<vector<p>>graph(n);\\n        vector<vector<p>>revGraph(n);\\n        \\n        for(auto it : edges)\\n        {\\n            int u = it[0], v = it[1], w = it[2];\\n            graph[u].push_back({v,w});\\n            revGraph[v].push_back({u,w});\\n        }\\n        \\n        vector<long>d1(n, LONG_MAX), d2(n,LONG_MAX), d3(n,LONG_MAX);\\n        \\n        Dijkstra(graph,src1,d1);\\n        Dijkstra(graph,src2,d2);\\n        Dijkstra(revGraph,dest,d3);\\n        \\n        long res = LONG_MAX;\\n        for(int i = 0 ; i<n ; i++)\\n        {\\n            if(d1[i] == LONG_MAX || d2[i] == LONG_MAX || d3[i] == LONG_MAX)\\n                continue;\\n            res = min(res, d1[i] + d2[i] + d3[i]);\\n        }\\n        return res == LONG_MAX ? -1: res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847426,
                "title": "java-dijkstra",
                "content": "```\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        List<List<Pair<Integer, Long>>> graph = new ArrayList<>();\\n        List<List<Pair<Integer, Long>>> rgraph = new ArrayList<>();\\n        \\n        // init graph\\n        for(int i = 0; i < n; i++){\\n            graph.add(new ArrayList<>());\\n            rgraph.add(new ArrayList<>());\\n        }\\n        \\n        // build graph\\n        for(int[] e : edges){\\n            int from = e[0], to = e[1];\\n            long w = (long) e[2];\\n                       \\n            graph.get(from).add(new Pair<Integer, Long>(to, w));\\n            rgraph.get(to).add(new Pair<Integer, Long>(from, w));\\n        }\\n        \\n        // init cost array for 3 Dijkstra\\'s\\n        long[] cost1 = new long[n], cost2 = new long[n], costDes = new long[n];\\n        Arrays.fill(cost1, Long.MAX_VALUE);\\n        Arrays.fill(cost2, Long.MAX_VALUE);\\n        Arrays.fill(costDes, Long.MAX_VALUE);\\n        \\n        // 3 Dijkstra\\'s\\n        bfs(graph, src1, cost1);\\n        bfs(graph, src2, cost2);\\n        bfs(rgraph, dest, costDes);\\n        \\n        // find min cost\\n        long result = Long.MAX_VALUE;\\n        for(int i = 0; i < n; i++){\\n            if(cost1[i] == Long.MAX_VALUE || cost2[i] == Long.MAX_VALUE ||\\n              costDes[i] == Long.MAX_VALUE){\\n                continue;\\n            }\\n            \\n            result = Math.min(result, cost1[i] + cost2[i] + costDes[i]);\\n        }\\n        \\n        return result < Long.MAX_VALUE? result : -1;\\n    }\\n    \\n    \\n    // Dijkstra\\n    private void bfs(List<List<Pair<Integer, Long>>> g,\\n                    int from, long[] cost){\\n        PriorityQueue<Pair<Integer, Long>> heap = new PriorityQueue<>(\\n            (a, b) -> Long.compare(a.getValue(), b.getValue()));\\n        \\n        cost[from] = 0;\\n        heap.add(new Pair<Integer, Long>(from, cost[from]));\\n        \\n        while(!heap.isEmpty()){\\n            Pair<Integer, Long> curr = heap.poll();\\n            int nodeCurr = curr.getKey();\\n            long costCurr = curr.getValue();\\n            \\n            if(cost[nodeCurr] < costCurr){\\n                continue;\\n            }\\n            \\n            if(g.get(nodeCurr).isEmpty()){\\n                continue;\\n            }\\n            \\n            for(Pair<Integer, Long> entry : g.get(nodeCurr)){\\n                int next = entry.getKey();\\n                long costNext = entry.getValue();\\n                if(cost[next] > cost[nodeCurr] + costNext){\\n                    cost[next] = cost[nodeCurr] + costNext;\\n                    heap.add(new Pair<Integer, Long>(next, cost[next]));\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        List<List<Pair<Integer, Long>>> graph = new ArrayList<>();\\n        List<List<Pair<Integer, Long>>> rgraph = new ArrayList<>();\\n        \\n        // init graph\\n        for(int i = 0; i < n; i++){\\n            graph.add(new ArrayList<>());\\n            rgraph.add(new ArrayList<>());\\n        }\\n        \\n        // build graph\\n        for(int[] e : edges){\\n            int from = e[0], to = e[1];\\n            long w = (long) e[2];\\n                       \\n            graph.get(from).add(new Pair<Integer, Long>(to, w));\\n            rgraph.get(to).add(new Pair<Integer, Long>(from, w));\\n        }\\n        \\n        // init cost array for 3 Dijkstra\\'s\\n        long[] cost1 = new long[n], cost2 = new long[n], costDes = new long[n];\\n        Arrays.fill(cost1, Long.MAX_VALUE);\\n        Arrays.fill(cost2, Long.MAX_VALUE);\\n        Arrays.fill(costDes, Long.MAX_VALUE);\\n        \\n        // 3 Dijkstra\\'s\\n        bfs(graph, src1, cost1);\\n        bfs(graph, src2, cost2);\\n        bfs(rgraph, dest, costDes);\\n        \\n        // find min cost\\n        long result = Long.MAX_VALUE;\\n        for(int i = 0; i < n; i++){\\n            if(cost1[i] == Long.MAX_VALUE || cost2[i] == Long.MAX_VALUE ||\\n              costDes[i] == Long.MAX_VALUE){\\n                continue;\\n            }\\n            \\n            result = Math.min(result, cost1[i] + cost2[i] + costDes[i]);\\n        }\\n        \\n        return result < Long.MAX_VALUE? result : -1;\\n    }\\n    \\n    \\n    // Dijkstra\\n    private void bfs(List<List<Pair<Integer, Long>>> g,\\n                    int from, long[] cost){\\n        PriorityQueue<Pair<Integer, Long>> heap = new PriorityQueue<>(\\n            (a, b) -> Long.compare(a.getValue(), b.getValue()));\\n        \\n        cost[from] = 0;\\n        heap.add(new Pair<Integer, Long>(from, cost[from]));\\n        \\n        while(!heap.isEmpty()){\\n            Pair<Integer, Long> curr = heap.poll();\\n            int nodeCurr = curr.getKey();\\n            long costCurr = curr.getValue();\\n            \\n            if(cost[nodeCurr] < costCurr){\\n                continue;\\n            }\\n            \\n            if(g.get(nodeCurr).isEmpty()){\\n                continue;\\n            }\\n            \\n            for(Pair<Integer, Long> entry : g.get(nodeCurr)){\\n                int next = entry.getKey();\\n                long costNext = entry.getValue();\\n                if(cost[next] > cost[nodeCurr] + costNext){\\n                    cost[next] = cost[nodeCurr] + costNext;\\n                    heap.add(new Pair<Integer, Long>(next, cost[next]));\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1847412,
                "title": "python-three-dijkstras-explained-100-faster",
                "content": "The optimal path consists of shortest paths from src1 to x, from src2 to x, and x to dest for a junction x.\\n\\nSo we run 3 Dijkstras algorithm based on the sources src1, src2, and dest.\\n\\n```\\nfrom heapq import heappop, heappush\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        \\n        G = defaultdict(list)\\n        for v, w, c in edges:\\n            G[v].append((w,c))\\n        def Dijkstra(G, dist, src):\\n            heap = [(0, src)]\\n            while heap:\\n                c, v = heappop(heap)\\n                if dist[v] != float(\\'inf\\'):\\n                    continue\\n                dist[v] = c\\n                for w, cw in G[v]:\\n                    if dist[w]==float(\\'inf\\'):\\n                        heappush(heap,(c+cw,w))\\n        dist_src1 = defaultdict(lambda:float(\\'inf\\'))\\n        Dijkstra(G,dist_src1, src1)\\n        dist_src2 = defaultdict(lambda:float(\\'inf\\'))\\n        Dijkstra(G,dist_src2, src2)\\n        G = defaultdict(list)\\n        for v, w, c in edges:\\n            G[w].append((v,c))\\n        dist_dest = defaultdict(lambda:float(\\'inf\\'))\\n        Dijkstra(G,dist_dest, dest)\\n        res = min([dist_src1[i]+dist_src2[i]+dist_dest[i] for i in range(n)])\\n        return res if res != float(\\'inf\\') else -1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom heapq import heappop, heappush\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        \\n        G = defaultdict(list)\\n        for v, w, c in edges:\\n            G[v].append((w,c))\\n        def Dijkstra(G, dist, src):\\n            heap = [(0, src)]\\n            while heap:\\n                c, v = heappop(heap)\\n                if dist[v] != float(\\'inf\\'):\\n                    continue\\n                dist[v] = c\\n                for w, cw in G[v]:\\n                    if dist[w]==float(\\'inf\\'):\\n                        heappush(heap,(c+cw,w))\\n        dist_src1 = defaultdict(lambda:float(\\'inf\\'))\\n        Dijkstra(G,dist_src1, src1)\\n        dist_src2 = defaultdict(lambda:float(\\'inf\\'))\\n        Dijkstra(G,dist_src2, src2)\\n        G = defaultdict(list)\\n        for v, w, c in edges:\\n            G[w].append((v,c))\\n        dist_dest = defaultdict(lambda:float(\\'inf\\'))\\n        Dijkstra(G,dist_dest, dest)\\n        res = min([dist_src1[i]+dist_src2[i]+dist_dest[i] for i in range(n)])\\n        return res if res != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847198,
                "title": "python-3-faster-than-100",
                "content": "```\\n\\nfrom collections import defaultdict\\nfrom sys import maxsize as inf\\nfrom heapq import heapify,heappush,heappop\\n\\n\\nclass Solution:\\n    \\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        \\n        def Dj(graph,src):\\n            \\n            hep = [(0,src)]\\n            vis = defaultdict(int)\\n            \\n            while hep:\\n                \\n                wet,node = heappop(hep)\\n                \\n                if node not in vis:\\n                    \\n                    vis[node] = wet\\n                    \\n                    for u,v in graph[node]:\\n                        \\n                        heappush(hep,(v + wet,u))\\n            \\n            #return [vis[i] for i in range(n) if vis[i] else inf] \\n            return [vis.get(i,inf) for i in range(n)]\\n            \\n            #return temp\\n            \\n        \\n        G = defaultdict(list)\\n        GR = defaultdict(list)\\n        \\n        for i,j,w in edges:\\n            \\n            #G[(i,j)] = w if not G[(i,j)] else min(w,G[(i,j)])\\n            #GR[(j,i)] = w if not G[(j,i)] else min(w,G[(j,i)])\\n            \\n            G[i].append((j,w))\\n            GR[j].append((i,w))\\n            \\n        d1 = Dj(G,src1)\\n        #print(d1)\\n        d2 = Dj(G,src2)\\n        d3 = Dj(GR,dest)\\n        \\n        ans = inf\\n        \\n        for i in range(n):\\n            \\n            ans = min(ans,d1[i] + d2[i] + d3[i])\\n        \\n        return ans if ans != inf else -1\\n    \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\n\\nfrom collections import defaultdict\\nfrom sys import maxsize as inf\\nfrom heapq import heapify,heappush,heappop\\n\\n\\nclass Solution:\\n    \\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        \\n        def Dj(graph,src):\\n            \\n            hep = [(0,src)]\\n            vis = defaultdict(int)\\n            \\n            while hep:\\n                \\n                wet,node = heappop(hep)\\n                \\n                if node not in vis:\\n                    \\n                    vis[node] = wet\\n                    \\n                    for u,v in graph[node]:\\n                        \\n                        heappush(hep,(v + wet,u))\\n            \\n            #return [vis[i] for i in range(n) if vis[i] else inf] \\n            return [vis.get(i,inf) for i in range(n)]\\n            \\n            #return temp\\n            \\n        \\n        G = defaultdict(list)\\n        GR = defaultdict(list)\\n        \\n        for i,j,w in edges:\\n            \\n            #G[(i,j)] = w if not G[(i,j)] else min(w,G[(i,j)])\\n            #GR[(j,i)] = w if not G[(j,i)] else min(w,G[(j,i)])\\n            \\n            G[i].append((j,w))\\n            GR[j].append((i,w))\\n            \\n        d1 = Dj(G,src1)\\n        #print(d1)\\n        d2 = Dj(G,src2)\\n        d3 = Dj(GR,dest)\\n        \\n        ans = inf\\n        \\n        for i in range(n):\\n            \\n            ans = min(ans,d1[i] + d2[i] + d3[i])\\n        \\n        return ans if ans != inf else -1\\n    \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846788,
                "title": "python3-bfs",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/66f7e5045d1b91897d8dbb425b6af153e6802c59) for solutions of weekly 284. \\n\\n```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        trans = [[] for _ in range(n)]\\n        for u, v, w in edges: \\n            graph[u].append((v, w))\\n            trans[v].append((u, w))\\n        \\n        def bfs(x, graph): \\n            dist = [inf] * n\\n            dist[x] = 0 \\n            queue = deque([(x, 0)])\\n            while queue: \\n                u, w = queue.popleft()\\n                if dist[u] == w: \\n                    for v, ww in graph[u]: \\n                        if w+ww < dist[v]: \\n                            dist[v] = w+ww\\n                            queue.append((v, w+ww))\\n            return dist\\n        \\n        ds1 = bfs(src1, graph)\\n        ds2 = bfs(src2, graph)\\n        dd = bfs(dest, trans)\\n        \\n        ans = min(x+y+z for x, y, z in zip(ds1, ds2, dd))\\n        return ans if ans < inf else -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        trans = [[] for _ in range(n)]\\n        for u, v, w in edges: \\n            graph[u].append((v, w))\\n            trans[v].append((u, w))\\n        \\n        def bfs(x, graph): \\n            dist = [inf] * n\\n            dist[x] = 0 \\n            queue = deque([(x, 0)])\\n            while queue: \\n                u, w = queue.popleft()\\n                if dist[u] == w: \\n                    for v, ww in graph[u]: \\n                        if w+ww < dist[v]: \\n                            dist[v] = w+ww\\n                            queue.append((v, w+ww))\\n            return dist\\n        \\n        ds1 = bfs(src1, graph)\\n        ds2 = bfs(src2, graph)\\n        dd = bfs(dest, trans)\\n        \\n        ans = min(x+y+z for x, y, z in zip(ds1, ds2, dd))\\n        return ans if ans < inf else -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846758,
                "title": "java-solution-steps-commented-readable",
                "content": "```\\n    static long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        \\n        //1-Find shortest paths from src1 to all nodes.\\n        //2-Find shortest paths from src2 to all nodes.\\n        //3-Find shortest paths from dest to all nodes (with a reversed graph to avoid TLE while finding all direct/indirect neighbors of dest).\\n        //Find if there exist node such that src1 and src2 can reach to, and this node can reach dest.\\n        //If it exists, then your sum is minDist(src1 to node) + minDist(src2 to node) + minDist(node to destination).\\n        //Find minimum sum with the above criteria.\\n        \\n        List<Node> nodeList = new ArrayList<>();\\n        for(int i = 0; i < n; i++) nodeList.add(new Node());\\n        Graph a = getGraph(n), b = getGraph(n), c = getGraph(n);\\n        for(int [] edge : edges){ \\n            a.addWeightedEdge(edge[0], edge[1], edge[2]);\\n            b.addWeightedEdge(edge[0], edge[1], edge[2]);\\n            c.addWeightedEdge(edge[1], edge[0], edge[2]);\\n        }\\n        a.dijkstra(src1);\\n        b.dijkstra(src2);\\n        c.dijkstra(dest);\\n\\n       long minDistance = Long.MAX_VALUE/10;\\n       for(int i = 0; i < n; i++) {\\n           minDistance = Math.min(a.nodeList.get(i).dist + b.nodeList.get(i).dist + c.nodeList.get(i).dist, minDistance);\\n       }\\n       return minDistance == Long.MAX_VALUE/10? -1 : minDistance;\\n    }\\n    \\n    static Graph getGraph(int n) {\\n        List<Node> nodeList = new ArrayList<>();\\n        for(int i = 0; i < n; i++)\\n            nodeList.add(new Node());\\n        return new Graph(nodeList);\\n    }\\n    \\n    static class Graph{\\n        List<Node> nodeList;\\n        public Graph(List<Node> nodeList){this.nodeList = nodeList;}\\n        \\n        public void addWeightedEdge(int u, int v, int dist) {\\n            nodeList.get(u).neighbors.add(nodeList.get(v));\\n            long newDist = Math.min(nodeList.get(u).weightedEdges.getOrDefault(nodeList.get(v), (long)dist), dist);\\n            nodeList.get(u).weightedEdges.put(nodeList.get(v), newDist);\\n        }\\n        \\n        public void dijkstra(int src) {\\n            PriorityQueue<Node> pq = new PriorityQueue<>();\\n            pq.addAll(this.nodeList);\\n            this.nodeList.get(src).dist = 0;\\n            while(!pq.isEmpty()) {\\n                Node curNode = pq.poll();\\n                for(Node neighbor : curNode.neighbors) {\\n                        if(neighbor.dist > curNode.weightedEdges.get(neighbor) + curNode.dist){\\n                            neighbor.dist = curNode.dist + curNode.weightedEdges.get(neighbor);\\n                            pq.add(neighbor);\\n                        }\\n                }\\n            }\\n           \\n        }\\n    }\\n    static class Node implements Comparable<Node>{\\n        long dist;\\n        Map<Node, Long> weightedEdges;\\n        List<Node> neighbors;\\n        \\n        public Node(){\\n            this.weightedEdges = new HashMap<>();\\n            this.neighbors = new ArrayList<>();\\n            this.dist = Long.MAX_VALUE/10;\\n        }\\n        @Override\\n        public int compareTo(Node o){\\n            return (int)(this.dist - o.dist);\\n        }\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    static long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        \\n        //1-Find shortest paths from src1 to all nodes.\\n        //2-Find shortest paths from src2 to all nodes.\\n        //3-Find shortest paths from dest to all nodes (with a reversed graph to avoid TLE while finding all direct/indirect neighbors of dest).\\n        //Find if there exist node such that src1 and src2 can reach to, and this node can reach dest.\\n        //If it exists, then your sum is minDist(src1 to node) + minDist(src2 to node) + minDist(node to destination).\\n        //Find minimum sum with the above criteria.\\n        \\n        List<Node> nodeList = new ArrayList<>();\\n        for(int i = 0; i < n; i++) nodeList.add(new Node());\\n        Graph a = getGraph(n), b = getGraph(n), c = getGraph(n);\\n        for(int [] edge : edges){ \\n            a.addWeightedEdge(edge[0], edge[1], edge[2]);\\n            b.addWeightedEdge(edge[0], edge[1], edge[2]);\\n            c.addWeightedEdge(edge[1], edge[0], edge[2]);\\n        }\\n        a.dijkstra(src1);\\n        b.dijkstra(src2);\\n        c.dijkstra(dest);\\n\\n       long minDistance = Long.MAX_VALUE/10;\\n       for(int i = 0; i < n; i++) {\\n           minDistance = Math.min(a.nodeList.get(i).dist + b.nodeList.get(i).dist + c.nodeList.get(i).dist, minDistance);\\n       }\\n       return minDistance == Long.MAX_VALUE/10? -1 : minDistance;\\n    }\\n    \\n    static Graph getGraph(int n) {\\n        List<Node> nodeList = new ArrayList<>();\\n        for(int i = 0; i < n; i++)\\n            nodeList.add(new Node());\\n        return new Graph(nodeList);\\n    }\\n    \\n    static class Graph{\\n        List<Node> nodeList;\\n        public Graph(List<Node> nodeList){this.nodeList = nodeList;}\\n        \\n        public void addWeightedEdge(int u, int v, int dist) {\\n            nodeList.get(u).neighbors.add(nodeList.get(v));\\n            long newDist = Math.min(nodeList.get(u).weightedEdges.getOrDefault(nodeList.get(v), (long)dist), dist);\\n            nodeList.get(u).weightedEdges.put(nodeList.get(v), newDist);\\n        }\\n        \\n        public void dijkstra(int src) {\\n            PriorityQueue<Node> pq = new PriorityQueue<>();\\n            pq.addAll(this.nodeList);\\n            this.nodeList.get(src).dist = 0;\\n            while(!pq.isEmpty()) {\\n                Node curNode = pq.poll();\\n                for(Node neighbor : curNode.neighbors) {\\n                        if(neighbor.dist > curNode.weightedEdges.get(neighbor) + curNode.dist){\\n                            neighbor.dist = curNode.dist + curNode.weightedEdges.get(neighbor);\\n                            pq.add(neighbor);\\n                        }\\n                }\\n            }\\n           \\n        }\\n    }\\n    static class Node implements Comparable<Node>{\\n        long dist;\\n        Map<Node, Long> weightedEdges;\\n        List<Node> neighbors;\\n        \\n        public Node(){\\n            this.weightedEdges = new HashMap<>();\\n            this.neighbors = new ArrayList<>();\\n            this.dist = Long.MAX_VALUE/10;\\n        }\\n        @Override\\n        public int compareTo(Node o){\\n            return (int)(this.dist - o.dist);\\n        }\\n        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845999,
                "title": "python-easy-and-reaable-dijkstra-algorithm",
                "content": "class Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:    \\n        \\n        infinity=float(\\'inf\\')\\n        adjList=collections.defaultdict(list)\\n        reverseAdjList=collections.defaultdict(list)\\n        for u,v,w in edges:\\n            adjList[u].append((v,w))\\n            reverseAdjList[v].append((u,w))\\n        \\n        #Dijikstra Implementation\\n        def getDist(source,lis):\\n            visited=set()\\n            dist=[infinity]*n\\n            q=[(0,source)]\\n            dist[source]=0\\n            while(q):\\n                weightPar,vertex=heapq.heappop(q)\\n                if vertex in visited:\\n                    continue\\n                visited.add(vertex)\\n                for adj,weightAdj in lis[vertex]:\\n                    if dist[adj]>dist[vertex]+weightAdj:\\n                        dist[adj]=weightPar+weightAdj\\n                        heapq.heappush(q,(dist[adj],adj))\\n            print(dist)\\n            return dist\\n        \\n        \\n        dist1=getDist(src1,adjList)\\n        dist2=getDist(src2,adjList)\\n        dist3=getDist(dest,reverseAdjList)\\n        \\n        ans=infinity\\n        for i in range(n):\\n            ans=min(ans,dist1[i]+dist2[i]+dist3[i])\\n            \\n        return ans if ans < infinity else -1",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:    \\n        \\n        infinity=float(\\'inf\\')\\n        adjList=collections.defaultdict(list)\\n        reverseAdjList=collections.defaultdict(list)\\n        for u,v,w in edges:\\n            adjList[u].append((v,w))\\n            reverseAdjList[v].append((u,w))\\n        \\n        #Dijikstra Implementation\\n        def getDist(source,lis):\\n            visited=set()\\n            dist=[infinity]*n\\n            q=[(0,source)]\\n            dist[source]=0\\n            while(q):\\n                weightPar,vertex=heapq.heappop(q)\\n                if vertex in visited:\\n                    continue\\n                visited.add(vertex)\\n                for adj,weightAdj in lis[vertex]:\\n                    if dist[adj]>dist[vertex]+weightAdj:\\n                        dist[adj]=weightPar+weightAdj\\n                        heapq.heappush(q,(dist[adj],adj))\\n            print(dist)\\n            return dist\\n        \\n        \\n        dist1=getDist(src1,adjList)\\n        dist2=getDist(src2,adjList)\\n        dist3=getDist(dest,reverseAdjList)\\n        \\n        ans=infinity\\n        for i in range(n):\\n            ans=min(ans,dist1[i]+dist2[i]+dist3[i])\\n            \\n        return ans if ans < infinity else -1",
                "codeTag": "Java"
            },
            {
                "id": 1845436,
                "title": "need-some-help-plz",
                "content": "Is there anyone can help fix this out? \\n\\nIgnoring the Dijkstra\\'s Algo, it didn\\'t come out in my mind first time. \\n\\nI think we can build a graph and find all possible path from scr1 to dest and src2 to dest, and we have two flag to determine wheather these path passed src1 or src2. \\n\\nSo we got all possible path in one of three condition.\\n\\n1. from src1 to dest without passing src2.\\n2. from src2 to dest without passing src1.\\n3. from src1 or src2 to dest with passing scr2 or scr1.\\n\\nNow we only need to compute the min value of all these possible path: Math.min(condition3\\'s value, Min(condition1\\'s value) + Min(condition2\\'s value))\\n\\nIs there any problem in this way? Or maybe the code has some bugs? I couldn\\'t figure out why it didn\\'t work. (passed 64/78)\\n\\nHere\\'s my code: \\n```\\nclass Solution {\\n\\tclass Node {\\n        List<Integer> weight = new ArrayList<>();\\n        List<Integer> connected = new ArrayList<>();\\n    }\\n    \\n\\t//my result to store possible path\\n    class Result {\\n\\t\\t//passed scr1 or not\\n        boolean flag1;\\n\\t\\t//passed scr2 or not\\n        boolean flag2;\\n\\t\\t//sum of weight\\n        long value;\\n    }\\n\\t\\n\\tList<Result> rst = new ArrayList<>();\\n    \\n\\t\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        Node[] graph = buildGraph(n, edges);\\n        //doing dfs\\n        dfs(graph, src1, src2, dest, src1, false, false, 0L, new boolean[n]);\\n        dfs(graph, src1, src2, dest, src2, false, false, 0L, new boolean[n]);\\n        \\n        if(rst.size() == 0) {\\n            return -1;\\n        }\\n        //find out min value\\n        Long src1Min = Long.MAX_VALUE, src2Min = Long.MAX_VALUE, bothMin = Long.MAX_VALUE;\\n        boolean both = false, one = false, two = false;\\n        for(Result r : rst) {\\n            System.out.println(r.flag1 + \" \" + r.flag2 + \" \" + r.value);\\n            if(r.flag1 && r.flag2) {\\n                both = true;\\n                bothMin = bothMin > r.value ? r.value : bothMin;\\n            } else if(r.flag1) {\\n                one = true;\\n                src1Min = src1Min > r.value ? r.value : src1Min;\\n                //System.out.println(src1Min);\\n            } else {\\n                two = true;\\n                src2Min = src2Min > r.value ? r.value : src2Min;\\n            }\\n        }\\n        //System.out.println(bothMin + \" \" + src1Min + \" \" + src2Min);\\n\\t\\t//compute the result\\n        if(!both && (one == false || two == false)) {\\n            return -1;\\n        } else if(both) {\\n            if(one && two) return Math.min(bothMin, src1Min + src2Min);\\n            return bothMin;\\n        } else {\\n            return src1Min + src2Min;\\n        }\\n    }\\n    \\n    private void dfs(Node[] graph, int src1, int src2, int dest, int curr, boolean flag1, boolean flag2, long weight, boolean[] traveled) {\\n        if(curr == dest) {\\n            Result r = new Result();\\n            r.flag1 = flag1;\\n            r.flag2 = flag2;\\n            r.value = weight;\\n            rst.add(r);\\n            return;\\n        }\\n        if(src1 == curr) flag1 = true;\\n        if(src2 == curr) flag2 = true;\\n        if(traveled[curr]) return;\\n        \\n        Node node = graph[curr];\\n        for(int i = 0; i < node.connected.size(); i++) {\\n            int next = node.connected.get(i);\\n            int temp = node.weight.get(i);\\n            traveled[i] = true;\\n            dfs(graph, src1, src2, dest, next, flag1, flag2, weight + temp, traveled);\\n            traveled[i] = false;\\n        }\\n    }\\n    \\n    private Node[] buildGraph(int n, int[][] edges) {\\n        Node[] rst = new Node[n];\\n        for(int i = 0; i < rst.length; i++) {\\n            rst[i] = new Node();\\n        }\\n        \\n        for(int[] edge : edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int dis = edge[2];\\n            \\n            rst[from].weight.add(dis);\\n            rst[from].connected.add(to);          \\n        }\\n        \\n        return rst;\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n\\tclass Node {\\n        List<Integer> weight = new ArrayList<>();\\n        List<Integer> connected = new ArrayList<>();\\n    }\\n    \\n\\t//my result to store possible path\\n    class Result {\\n\\t\\t//passed scr1 or not\\n        boolean flag1;\\n\\t\\t//passed scr2 or not\\n        boolean flag2;\\n\\t\\t//sum of weight\\n        long value;\\n    }\\n\\t\\n\\tList<Result> rst = new ArrayList<>();\\n    \\n\\t\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        Node[] graph = buildGraph(n, edges);\\n        //doing dfs\\n        dfs(graph, src1, src2, dest, src1, false, false, 0L, new boolean[n]);\\n        dfs(graph, src1, src2, dest, src2, false, false, 0L, new boolean[n]);\\n        \\n        if(rst.size() == 0) {\\n            return -1;\\n        }\\n        //find out min value\\n        Long src1Min = Long.MAX_VALUE, src2Min = Long.MAX_VALUE, bothMin = Long.MAX_VALUE;\\n        boolean both = false, one = false, two = false;\\n        for(Result r : rst) {\\n            System.out.println(r.flag1 + \" \" + r.flag2 + \" \" + r.value);\\n            if(r.flag1 && r.flag2) {\\n                both = true;\\n                bothMin = bothMin > r.value ? r.value : bothMin;\\n            } else if(r.flag1) {\\n                one = true;\\n                src1Min = src1Min > r.value ? r.value : src1Min;\\n                //System.out.println(src1Min);\\n            } else {\\n                two = true;\\n                src2Min = src2Min > r.value ? r.value : src2Min;\\n            }\\n        }\\n        //System.out.println(bothMin + \" \" + src1Min + \" \" + src2Min);\\n\\t\\t//compute the result\\n        if(!both && (one == false || two == false)) {\\n            return -1;\\n        } else if(both) {\\n            if(one && two) return Math.min(bothMin, src1Min + src2Min);\\n            return bothMin;\\n        } else {\\n            return src1Min + src2Min;\\n        }\\n    }\\n    \\n    private void dfs(Node[] graph, int src1, int src2, int dest, int curr, boolean flag1, boolean flag2, long weight, boolean[] traveled) {\\n        if(curr == dest) {\\n            Result r = new Result();\\n            r.flag1 = flag1;\\n            r.flag2 = flag2;\\n            r.value = weight;\\n            rst.add(r);\\n            return;\\n        }\\n        if(src1 == curr) flag1 = true;\\n        if(src2 == curr) flag2 = true;\\n        if(traveled[curr]) return;\\n        \\n        Node node = graph[curr];\\n        for(int i = 0; i < node.connected.size(); i++) {\\n            int next = node.connected.get(i);\\n            int temp = node.weight.get(i);\\n            traveled[i] = true;\\n            dfs(graph, src1, src2, dest, next, flag1, flag2, weight + temp, traveled);\\n            traveled[i] = false;\\n        }\\n    }\\n    \\n    private Node[] buildGraph(int n, int[][] edges) {\\n        Node[] rst = new Node[n];\\n        for(int i = 0; i < rst.length; i++) {\\n            rst[i] = new Node();\\n        }\\n        \\n        for(int[] edge : edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int dis = edge[2];\\n            \\n            rst[from].weight.add(dis);\\n            rst[from].connected.add(to);          \\n        }\\n        \\n        return rst;\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845165,
                "title": "cpp-solution-optimised-dijkstra-accepted",
                "content": "**minimum weight sum of subgraph = minimum value for all N where    { minimum distance from source 1 to i + minimum distance from source 2 to i + minimum distance from i to destination }**\\n\\n**minimum distance between any two nodes can be found by dijkstra if we no one node is fixed.\\nHere we have three fixed nodes.**\\n\\nCPP Approach using Eager Dijkstra \\nOptimised using Map\\n**Time Complexity : O(NlogN)**\\n**Space Complexity : O(N*N)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tconst long long oo = 1e18;\\n\\t\\tvoid dijkstra(int &src, vector<vector<pair<int,long long>>>&graph,vector<long long> &dist){\\n\\t\\t\\tmap<int ,long long> pq;\\n\\t\\t\\tpq.insert({src,0});\\n\\t\\t\\tdist[src] = 0;\\n\\t\\t\\twhile(!pq.empty()){\\n\\t\\t\\t\\tint node = pq.begin()->first;\\n\\t\\t\\t\\tpq.erase(node);\\n\\t\\t\\t\\tfor(auto [nb,wt] : graph[node]){\\n\\t\\t\\t\\t\\tif(dist[nb] > dist[node]+ wt){\\n\\t\\t\\t\\t\\t\\tdist[nb] = dist[node] + wt;\\n\\t\\t\\t\\t\\t\\tif(pq.count(nb))\\n\\t\\t\\t\\t\\t\\t\\tpq.erase(nb);\\n\\t\\t\\t\\t\\t\\tpq.insert({nb,dist[nb]});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tlong long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n\\t\\t\\tvector<vector<pair<int ,long long>>> g(n+1),rg(n+1);\\n\\t\\t\\tfor(auto edge : edges){\\n\\t\\t\\t\\tg[edge[0]].push_back({edge[1],edge[2]});\\n\\t\\t\\t\\trg[edge[1]].push_back({edge[0],edge[2]});\\n\\t\\t\\t}\\n\\t\\t\\tvector<long long> di(n+1,oo),s1i(n+1,oo),s2i(n+1,oo);\\n\\t\\t\\tdijkstra(src1,g,s1i);\\n\\t\\t\\tdijkstra(src2,g,s2i);\\n\\t\\t\\tdijkstra(dest,rg,di);\\n\\t\\t\\tlong long res = oo;\\n\\t\\t\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\t\\t\\tres = min(res,s1i[i] + s2i[i] + di[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn res >= oo ?-1:res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Graph"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tconst long long oo = 1e18;\\n\\t\\tvoid dijkstra(int &src, vector<vector<pair<int,long long>>>&graph,vector<long long> &dist){\\n\\t\\t\\tmap<int ,long long> pq;\\n\\t\\t\\tpq.insert({src,0}",
                "codeTag": "Java"
            },
            {
                "id": 1844952,
                "title": "correct-time-complexity-but-still-tle-on-78th-test-case-please-help",
                "content": "Here is my whole code.\\nIts like O(2*m + 3*nlogm + n) . It should have passed according to the constraints.\\n\\nI did all the possible optimizations, like make graph and distance arrays global, still TLE.\\n\\n```\\n\\ntypedef unsigned long long int ulli;\\ntypedef long long int lli;\\ntypedef long int li;\\n\\ntypedef pair<int, int> pii;\\n\\ntypedef map<int, int> mii;\\ntypedef map<string, int> msi;\\ntypedef map<string, string> mss;\\n\\ntypedef vector<int> vi;\\ntypedef vector<long long int> vlli;\\ntypedef vector<bool> vb;\\ntypedef vector<string> vs;\\ntypedef vector<pair<int, int>> vpii;\\ntypedef vector<vector<int>> vvi;\\ntypedef vector<vector<long long int>> vvlli;\\ntypedef vector<vector<bool>> vvb;\\n\\nvector<pii> adj[100000] ;\\nvector<pii> invadj[100000] ;\\nlli distd[100000];\\nlli dists1[100000];\\nlli dists2[100000];\\n\\n\\n// v is number of vertices\\n// input refrence to a lli[] with \\'v\\' entries each intiilized to INT64_MAX\\nvoid eff_dijsktrall(int v, vector<pii> adj[], int src, lli dist[]){   \\n    assert(src < v && src >= 0) ;\\n    dist[src] = 0 ;\\n    priority_queue<pii, vector<pii>, greater<pii>> minheap;\\n    minheap.push({0, src}) ;\\n    int u,w;\\n    \\n    while(! minheap.empty())\\n    {\\n        // pop\\n        int cur = minheap.top().second ;\\n        minheap.pop();\\n        \\n        // relax and push veritces\\n        // for any adjacent of cur \\n        for(const pii& edge : adj[cur])\\n        {\\n            // can relax\\n            u = edge.first ;\\n            w = edge.second ;\\n            if(dist[u] == INT64_MAX || dist[u] > dist[cur] + w)\\n            {\\n                dist[u] = dist[cur] + w ;\\n                minheap.push({dist[u], u}) ;\\n            }\\n        }\\n    } \\n}\\n\\n\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& e, int s1, int s2, int d) {\\n        int m = e.size();\\n        //vector<vvi> adj(n, vvi());\\n        //vvi adj[n];\\n        //vector<pii> adj[n];\\n        \\n        // inverse graph\\n        //vector<vvi> invadj(n, vvi());\\n        //vvi invadj[n];\\n        //vector<pii> invadj[n] ;\\n        \\n        for(int i=0; i<n; i++){\\n            adj[i].clear();\\n            invadj[i].clear();\\n            distd[i] = INT64_MAX;\\n            dists1[i] = INT64_MAX;\\n            dists2[i] = INT64_MAX;\\n        }\\n        \\n        for(int i=0; i<m; i++){\\n            int u = e[i][0];\\n            int v = e[i][1];\\n            int w = e[i][2];\\n            \\n            adj[u].push_back({v, w});\\n            invadj[v].push_back({u, w});\\n        }\\n        \\n        \\n        eff_dijsktrall(n, invadj, d, distd) ;\\n        eff_dijsktrall(n, adj, s1, dists1) ;\\n        eff_dijsktrall(n, adj, s2, dists2) ;\\n        \\n        if(dists1[d]==INT64_MAX || dists2[d]==INT64_MAX){\\n            return -1;\\n        }\\n        \\n        lli ans = INT64_MAX;\\n        \\n        // choose meeting point\\n        for(int v=0; v<n; v++){\\n            // s1->v and s2->v and v->d\\n            lli cur = 0;\\n            if(dists1[v]==INT64_MAX || dists2[v]==INT64_MAX || distd[v]==INT64_MAX){\\n                // cant reach\\n                continue;\\n            }\\n            \\n            cur = dists1[v] + dists2[v] + distd[v] ;\\n            \\n            ans = min(ans, cur);\\n            \\n        }\\n        \\n        if(ans == INT64_MAX){\\n            ans = -1;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\ntypedef unsigned long long int ulli;\\ntypedef long long int lli;\\ntypedef long int li;\\n\\ntypedef pair<int, int> pii;\\n\\ntypedef map<int, int> mii;\\ntypedef map<string, int> msi;\\ntypedef map<string, string> mss;\\n\\ntypedef vector<int> vi;\\ntypedef vector<long long int> vlli;\\ntypedef vector<bool> vb;\\ntypedef vector<string> vs;\\ntypedef vector<pair<int, int>> vpii;\\ntypedef vector<vector<int>> vvi;\\ntypedef vector<vector<long long int>> vvlli;\\ntypedef vector<vector<bool>> vvb;\\n\\nvector<pii> adj[100000] ;\\nvector<pii> invadj[100000] ;\\nlli distd[100000];\\nlli dists1[100000];\\nlli dists2[100000];\\n\\n\\n// v is number of vertices\\n// input refrence to a lli[] with \\'v\\' entries each intiilized to INT64_MAX\\nvoid eff_dijsktrall(int v, vector<pii> adj[], int src, lli dist[]){   \\n    assert(src < v && src >= 0) ;\\n    dist[src] = 0 ;\\n    priority_queue<pii, vector<pii>, greater<pii>> minheap;\\n    minheap.push({0, src}) ;\\n    int u,w;\\n    \\n    while(! minheap.empty())\\n    {\\n        // pop\\n        int cur = minheap.top().second ;\\n        minheap.pop();\\n        \\n        // relax and push veritces\\n        // for any adjacent of cur \\n        for(const pii& edge : adj[cur])\\n        {\\n            // can relax\\n            u = edge.first ;\\n            w = edge.second ;\\n            if(dist[u] == INT64_MAX || dist[u] > dist[cur] + w)\\n            {\\n                dist[u] = dist[cur] + w ;\\n                minheap.push({dist[u], u}) ;\\n            }\\n        }\\n    } \\n}\\n\\n\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& e, int s1, int s2, int d) {\\n        int m = e.size();\\n        //vector<vvi> adj(n, vvi());\\n        //vvi adj[n];\\n        //vector<pii> adj[n];\\n        \\n        // inverse graph\\n        //vector<vvi> invadj(n, vvi());\\n        //vvi invadj[n];\\n        //vector<pii> invadj[n] ;\\n        \\n        for(int i=0; i<n; i++){\\n            adj[i].clear();\\n            invadj[i].clear();\\n            distd[i] = INT64_MAX;\\n            dists1[i] = INT64_MAX;\\n            dists2[i] = INT64_MAX;\\n        }\\n        \\n        for(int i=0; i<m; i++){\\n            int u = e[i][0];\\n            int v = e[i][1];\\n            int w = e[i][2];\\n            \\n            adj[u].push_back({v, w});\\n            invadj[v].push_back({u, w});\\n        }\\n        \\n        \\n        eff_dijsktrall(n, invadj, d, distd) ;\\n        eff_dijsktrall(n, adj, s1, dists1) ;\\n        eff_dijsktrall(n, adj, s2, dists2) ;\\n        \\n        if(dists1[d]==INT64_MAX || dists2[d]==INT64_MAX){\\n            return -1;\\n        }\\n        \\n        lli ans = INT64_MAX;\\n        \\n        // choose meeting point\\n        for(int v=0; v<n; v++){\\n            // s1->v and s2->v and v->d\\n            lli cur = 0;\\n            if(dists1[v]==INT64_MAX || dists2[v]==INT64_MAX || distd[v]==INT64_MAX){\\n                // cant reach\\n                continue;\\n            }\\n            \\n            cur = dists1[v] + dists2[v] + distd[v] ;\\n            \\n            ans = min(ans, cur);\\n            \\n        }\\n        \\n        if(ans == INT64_MAX){\\n            ans = -1;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844823,
                "title": "c-simple-no-djkstra-only-dfs-see-comments-for-explanation",
                "content": "```\\n/*\\n  Intuition: We look for intersections between paths from src1 and src2 to dest\\n             respectively and then get the shortest path from the intersection until\\n             dest. Then we compute the cost for the intersection =\\n             distFromSrc1 + distFromSrc2 + distToDest\\n             Then we select the intersection with the minimum cost, which is also the\\n             weight of the required minimum subgraph formed by src1->intersection,\\n             src2->intersection and intersection->dest\\n             NOTE: the destination is one such intersection in which case the graph is just\\n             src1->dest and src2->dest\\n*/\\n  \\nclass Solution {\\npublic:\\n  struct Edge {\\n    // The \"from\" and \"to\" of the edge\\n    int from, to;\\n    // The weight of the edge\\n    long long wt;\\n    Edge(int from, int to, long long wt) : from(from), to(to), wt(wt) {}\\n  };\\n  \\n  struct Node {\\n    // The outgoing edges from this node\\n    vector<Edge> outgoing;\\n    // The distance from src1 to this node, -1 if no path\\n    long long distFromSrc1 = -1;\\n    // The distance from src2 to this node, -1 if no path\\n    long long distFromSrc2 = -1;\\n    // The distance from this node to the destination, -1 if no path\\n    long long distToDest = -1;\\n  };\\n  \\n  // Traverses all paths from cur to dest and returns the length of the shortest one\\n  // and -1 if no such path\\n  // cur: The current node in the dfs\\n  long long distToDest(vector<Node>& graph, int cur, int src, long long dist,\\n                       int src1, int src2, int dest, vector<bool>& visited) {\\n    visited[cur] = true;\\n    auto& node = graph[cur];\\n    \\n    // Whether we are coming from src1\\n    if (src == src1) {\\n      if (node.distFromSrc1 == -1) {\\n        node.distFromSrc1 = dist;\\n      } else {\\n        node.distFromSrc1 = min(node.distFromSrc1, dist);\\n      }\\n    }\\n    \\n    // Whether we are coming from src2\\n    if (src == src2) {\\n      if (node.distFromSrc2 == -1) {\\n        node.distFromSrc2 = dist;\\n      } else {\\n        node.distFromSrc2 = min(node.distFromSrc2, dist);\\n      }\\n    }\\n    \\n    // We only need to compute the distance of this node to dest once\\n    if (node.distToDest != -1) {\\n      visited[cur] = false;\\n      return node.distToDest;\\n    }\\n    \\n    // If the current node is the destination\\n    if (cur == dest) {\\n      visited[cur] = false;\\n      node.distToDest = 0;\\n      return 0;\\n    }\\n    \\n    // Loop through all the outgoing edges to find a path to dest\\n    for (auto& edge: node.outgoing) {\\n      if (visited[edge.to]) {\\n        continue;\\n      }\\n      // Distance from \"to\" to dest\\n      long long nodeDistToDest = distToDest(graph, edge.to, src, dist + edge.wt,\\n                                             src1, src2, dest, visited);\\n      \\n      // No path from \"to\" to dest\\n      if (nodeDistToDest == -1) {\\n        continue;\\n      }\\n      long long distToDest = edge.wt + nodeDistToDest;\\n      if (node.distToDest == -1) {\\n        node.distToDest = distToDest;\\n      } else {\\n        node.distToDest = min(node.distToDest, distToDest);\\n      }\\n    }\\n    visited[cur] = false;\\n    return node.distToDest;\\n  }\\n  \\n  long long minimumWeight(int n, vector<vector<int>>& edges,int src1, int src2,\\n                          int dest) {\\n    // Build the graph\\n    vector<Node> graph(n + 1);\\n    for (auto& edge: edges) {\\n      int from = edge[0];\\n      int to = edge[1];\\n      long long wt = edge[2];\\n      graph[from].outgoing.push_back(Edge(from, to, wt));\\n    }\\n    \\n    // Records whether the node has been visited during DFS or not\\n    vector<bool> visited(n + 1, false);\\n    \\n    // Traverse from src1\\n    distToDest(graph, src1, src1, 0, src1, src2, dest, visited);\\n    // Traverse from src2\\n    distToDest(graph, src2, src2, 0, src1, src2, dest, visited);\\n    \\n    long long result = -1;\\n    for (int i = 0; i <= n; ++i) {\\n      auto& node = graph[i];\\n      \\n      // Check if this node is an intersection\\n      if (node.distFromSrc1 != -1 && node.distFromSrc2 != -1 &&\\n          node.distToDest != -1) {\\n        if (result == -1) {\\n          result = node.distFromSrc1 + node.distFromSrc2 + node.distToDest;\\n        } else {\\n          result = min(result, node.distFromSrc1 + node.distFromSrc2 +\\n                       node.distToDest);\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n  Intuition: We look for intersections between paths from src1 and src2 to dest\\n             respectively and then get the shortest path from the intersection until\\n             dest. Then we compute the cost for the intersection =\\n             distFromSrc1 + distFromSrc2 + distToDest\\n             Then we select the intersection with the minimum cost, which is also the\\n             weight of the required minimum subgraph formed by src1->intersection,\\n             src2->intersection and intersection->dest\\n             NOTE: the destination is one such intersection in which case the graph is just\\n             src1->dest and src2->dest\\n*/\\n  \\nclass Solution {\\npublic:\\n  struct Edge {\\n    // The \"from\" and \"to\" of the edge\\n    int from, to;\\n    // The weight of the edge\\n    long long wt;\\n    Edge(int from, int to, long long wt) : from(from), to(to), wt(wt) {}\\n  };\\n  \\n  struct Node {\\n    // The outgoing edges from this node\\n    vector<Edge> outgoing;\\n    // The distance from src1 to this node, -1 if no path\\n    long long distFromSrc1 = -1;\\n    // The distance from src2 to this node, -1 if no path\\n    long long distFromSrc2 = -1;\\n    // The distance from this node to the destination, -1 if no path\\n    long long distToDest = -1;\\n  };\\n  \\n  // Traverses all paths from cur to dest and returns the length of the shortest one\\n  // and -1 if no such path\\n  // cur: The current node in the dfs\\n  long long distToDest(vector<Node>& graph, int cur, int src, long long dist,\\n                       int src1, int src2, int dest, vector<bool>& visited) {\\n    visited[cur] = true;\\n    auto& node = graph[cur];\\n    \\n    // Whether we are coming from src1\\n    if (src == src1) {\\n      if (node.distFromSrc1 == -1) {\\n        node.distFromSrc1 = dist;\\n      } else {\\n        node.distFromSrc1 = min(node.distFromSrc1, dist);\\n      }\\n    }\\n    \\n    // Whether we are coming from src2\\n    if (src == src2) {\\n      if (node.distFromSrc2 == -1) {\\n        node.distFromSrc2 = dist;\\n      } else {\\n        node.distFromSrc2 = min(node.distFromSrc2, dist);\\n      }\\n    }\\n    \\n    // We only need to compute the distance of this node to dest once\\n    if (node.distToDest != -1) {\\n      visited[cur] = false;\\n      return node.distToDest;\\n    }\\n    \\n    // If the current node is the destination\\n    if (cur == dest) {\\n      visited[cur] = false;\\n      node.distToDest = 0;\\n      return 0;\\n    }\\n    \\n    // Loop through all the outgoing edges to find a path to dest\\n    for (auto& edge: node.outgoing) {\\n      if (visited[edge.to]) {\\n        continue;\\n      }\\n      // Distance from \"to\" to dest\\n      long long nodeDistToDest = distToDest(graph, edge.to, src, dist + edge.wt,\\n                                             src1, src2, dest, visited);\\n      \\n      // No path from \"to\" to dest\\n      if (nodeDistToDest == -1) {\\n        continue;\\n      }\\n      long long distToDest = edge.wt + nodeDistToDest;\\n      if (node.distToDest == -1) {\\n        node.distToDest = distToDest;\\n      } else {\\n        node.distToDest = min(node.distToDest, distToDest);\\n      }\\n    }\\n    visited[cur] = false;\\n    return node.distToDest;\\n  }\\n  \\n  long long minimumWeight(int n, vector<vector<int>>& edges,int src1, int src2,\\n                          int dest) {\\n    // Build the graph\\n    vector<Node> graph(n + 1);\\n    for (auto& edge: edges) {\\n      int from = edge[0];\\n      int to = edge[1];\\n      long long wt = edge[2];\\n      graph[from].outgoing.push_back(Edge(from, to, wt));\\n    }\\n    \\n    // Records whether the node has been visited during DFS or not\\n    vector<bool> visited(n + 1, false);\\n    \\n    // Traverse from src1\\n    distToDest(graph, src1, src1, 0, src1, src2, dest, visited);\\n    // Traverse from src2\\n    distToDest(graph, src2, src2, 0, src1, src2, dest, visited);\\n    \\n    long long result = -1;\\n    for (int i = 0; i <= n; ++i) {\\n      auto& node = graph[i];\\n      \\n      // Check if this node is an intersection\\n      if (node.distFromSrc1 != -1 && node.distFromSrc2 != -1 &&\\n          node.distToDest != -1) {\\n        if (result == -1) {\\n          result = node.distFromSrc1 + node.distFromSrc2 + node.distToDest;\\n        } else {\\n          result = min(result, node.distFromSrc1 + node.distFromSrc2 +\\n                       node.distToDest);\\n        }\\n      }\\n    }\\n    return result;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844625,
                "title": "easy-to-understand-code-dijkstra-and-simple-logic",
                "content": "Logic is simple but yet hard to come up with .\\n\\nSo basically there will a node where src1, src2 and dest will meet  let\\'s  say i . We just need to find that optimal node i such that dist(src1,i) + dist(src2,i) + dist(dest,i) is minimum.\\n\\nPS: always use long long for calculating distance to avoid overflow and unexpected results . \\n(khud ke anubhav se dia gya gyan \\uD83D\\uDE0C)\\n\\n```\\n#define ll long long\\nconst ll INF=100000000000;\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector< pair<int,int> > adj[n];\\n        vector< pair<int,int> > rev[n];\\n        for(auto e: edges){\\n            adj[e[0]].push_back({e[1],e[2]});\\n            rev[e[1]].push_back({e[0],e[2]});\\n        }\\n\\t\\t//distance of all nodes from src1\\n        vector<ll> dist1(n,INF);\\n        dijkstra(adj,src1,dist1);\\n        \\n\\t\\t//distance of all nodes from src2\\n        vector<ll> dist2(n,INF);\\n        dijkstra(adj,src2,dist2);\\n        \\n\\t\\t//distance of all nodes from dest\\n        vector<ll> dist3(n,INF);\\n        dijkstra(rev,dest,dist3);\\n        \\n        ll ans=INF;\\n        for(int i=0;i<n;i++){\\n            ans=min(ans,dist1[i]+dist2[i]+dist3[i]);\\n        }\\n        if(ans==INF)ans=-1;\\n        return ans;\\n    }\\n    void dijkstra(vector< pair<int,int> > adj[],int s,vector<ll> &dist){\\n        priority_queue< pair<ll,int> , vector< pair<ll,int> > ,greater< pair<ll,int> > > pq;\\n        pq.push({0,s});\\n        dist[s]=0;\\n        \\n        while(!pq.empty()){\\n            int u=pq.top().second;\\n            ll d=pq.top().first;\\n            pq.pop();\\n            \\n            if(d!=dist[u])continue;\\n            \\n            for(auto [v,w]: adj[u]){\\n                if(dist[v] >= d+w){\\n                    dist[v]=d+w;\\n                    pq.push({dist[v],v});\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nconst ll INF=100000000000;\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector< pair<int,int> > adj[n];\\n        vector< pair<int,int> > rev[n];\\n        for(auto e: edges){\\n            adj[e[0]].push_back({e[1],e[2]});\\n            rev[e[1]].push_back({e[0],e[2]});\\n        }\\n\\t\\t//distance of all nodes from src1\\n        vector<ll> dist1(n,INF);\\n        dijkstra(adj,src1,dist1);\\n        \\n\\t\\t//distance of all nodes from src2\\n        vector<ll> dist2(n,INF);\\n        dijkstra(adj,src2,dist2);\\n        \\n\\t\\t//distance of all nodes from dest\\n        vector<ll> dist3(n,INF);\\n        dijkstra(rev,dest,dist3);\\n        \\n        ll ans=INF;\\n        for(int i=0;i<n;i++){\\n            ans=min(ans,dist1[i]+dist2[i]+dist3[i]);\\n        }\\n        if(ans==INF)ans=-1;\\n        return ans;\\n    }\\n    void dijkstra(vector< pair<int,int> > adj[],int s,vector<ll> &dist){\\n        priority_queue< pair<ll,int> , vector< pair<ll,int> > ,greater< pair<ll,int> > > pq;\\n        pq.push({0,s});\\n        dist[s]=0;\\n        \\n        while(!pq.empty()){\\n            int u=pq.top().second;\\n            ll d=pq.top().first;\\n            pq.pop();\\n            \\n            if(d!=dist[u])continue;\\n            \\n            for(auto [v,w]: adj[u]){\\n                if(dist[v] >= d+w){\\n                    dist[v]=d+w;\\n                    pq.push({dist[v],v});\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844588,
                "title": "c-2203-minimum-weighted-subgraph-with-the-required-paths",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int, int>>> graph(n), trans(n); \\n        for (auto& edge : edges) {\\n            graph[edge[0]].push_back({edge[1], edge[2]});\\n            trans[edge[1]].push_back({edge[0], edge[2]}); \\n        } \\n        \\n        auto bfs = [&](int x, vector<vector<pair<int, int>>>& graph) {\\n            vector<long long> dist(n, -1); \\n            queue<pair<int, long long>> q; q.emplace(x, 0); \\n            dist[x] = 0; \\n            while (q.size()) {\\n                auto [u, w] = q.front(); q.pop(); \\n                if (dist[u] == w) \\n                    for (auto& [v, ww] : graph[u]) \\n                        if (dist[v] == -1 || w+ww < dist[v]) {\\n                            q.emplace(v, w+ww); \\n                            dist[v] = w+ww; \\n                        }\\n            }\\n            return dist; \\n        };\\n        \\n        vector<long long> dsrc1 = bfs(src1, graph), dsrc2 = bfs(src2, graph), ddest = bfs(dest, trans); \\n        long long ans = -1; \\n        for (int i = 0; i < n; ++i) {\\n            if (dsrc1[i] != -1 && dsrc2[i] != -1 && ddest[i] != -1 && (ans == -1 || dsrc1[i] + dsrc2[i] + ddest[i] < ans))\\n                ans = dsrc1[i] + dsrc2[i] + ddest[i]; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int, int>>> graph(n), trans(n); \\n        for (auto& edge : edges) {\\n            graph[edge[0]].push_back({edge[1], edge[2]});\\n            trans[edge[1]].push_back({edge[0], edge[2]}); \\n        } \\n        \\n        auto bfs = [&](int x, vector<vector<pair<int, int>>>& graph) {\\n            vector<long long> dist(n, -1); \\n            queue<pair<int, long long>> q; q.emplace(x, 0); \\n            dist[x] = 0; \\n            while (q.size()) {\\n                auto [u, w] = q.front(); q.pop(); \\n                if (dist[u] == w) \\n                    for (auto& [v, ww] : graph[u]) \\n                        if (dist[v] == -1 || w+ww < dist[v]) {\\n                            q.emplace(v, w+ww); \\n                            dist[v] = w+ww; \\n                        }\\n            }\\n            return dist; \\n        };\\n        \\n        vector<long long> dsrc1 = bfs(src1, graph), dsrc2 = bfs(src2, graph), ddest = bfs(dest, trans); \\n        long long ans = -1; \\n        for (int i = 0; i < n; ++i) {\\n            if (dsrc1[i] != -1 && dsrc2[i] != -1 && ddest[i] != -1 && (ans == -1 || dsrc1[i] + dsrc2[i] + ddest[i] < ans))\\n                ans = dsrc1[i] + dsrc2[i] + ddest[i]; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844531,
                "title": "c-3-times-dijkstra",
                "content": "**If you get TLE at 1 test case and 77/78 test case passed then see how to do this optimization here [Dijkstra Optimization](https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/discuss/1844680/7778-passed-and-1-TLE-Explanation-in-Dijkstra-Optimisation)**\\n\\n**Solution**\\n\\nhere I had done **Dijkstra 3 times**.\\n**First time** : store the shortest distance from node `src1` to all other nodes in array `fromSrc1To`.\\n**Second time** : store the shortest distance from node `src2` to all other nodes in array `fromSrc2To`.\\n**Third time** : store the shortest distance from node `dest` to all other nodes via Reversed Graph in array `fromDestTo`.\\n**The answer is the minimum of** `fromSrc1To[i] + fromSrc2To[i] + fromDestTo[i]` (`0 <= i < N`).\\n\\n```\\nclass Solution {\\n\\tlong MAXX = 1e10;\\npublic:\\n\\t// DIJKSTRA\\n\\tvoid Dijkstra(long src, vector<pair<long, long>> adj[], vector<long>&minDistanceFromSrcTo)\\n\\t{\\n\\t\\tpriority_queue<pair<long, long>, vector<pair<long, long>>, greater<pair<long, long>>> pq;\\n\\t\\tpq.push({0, src});\\n\\t\\tminDistanceFromSrcTo[src] = 0;\\n\\t\\tlong u, v, wt, dist;\\n\\t\\twhile (!pq.empty()) {\\n\\t\\t\\tu = pq.top().second;\\n\\t\\t\\tdist = pq.top().first;\\n\\t\\t\\tpq.pop();\\n\\t\\t\\t// below if satement is Dijkstra optimization which lead to solution of TLE\\n\\t\\t\\t// don\\'t understand go on top of solution i had pasted that link Dijkstra Optimization\\n\\t\\t\\tif (minDistanceFromSrcTo[u] < dist) continue;\\n\\t\\t\\tfor (auto it : adj[u]) {\\n\\t\\t\\t\\tv = it.first;\\n\\t\\t\\t\\twt = it.second;\\n\\t\\t\\t\\tif (minDistanceFromSrcTo[u] + wt < minDistanceFromSrcTo[v]) {\\n\\t\\t\\t\\t\\tminDistanceFromSrcTo[v] = wt + minDistanceFromSrcTo[u];\\n\\t\\t\\t\\t\\tpq.push({minDistanceFromSrcTo[v], v});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tlong minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n\\t\\tvector<pair<long, long>> adj[n], revadj[n];\\n\\t\\tfor (auto e : edges) {\\n\\t\\t\\tadj[e[0]].push_back({e[1], e[2]});\\n\\t\\t\\trevadj[e[1]].push_back({e[0], e[2]});\\n\\t\\t}\\n\\n\\t\\tvector<long>fromSrc1To(n, MAXX), fromSrc2To(n, MAXX), fromDestTo(n, MAXX);\\n\\t\\tDijkstra(src1, adj, fromSrc1To);\\n\\t\\tDijkstra(src2, adj, fromSrc2To);\\n\\t\\tDijkstra(dest, revadj, fromDestTo);\\n\\n\\t\\t// BASE CASE : not found any path from src1 to dest OR src2 to dest then return -1\\n\\t\\tif (fromSrc1To[dest] == MAXX || fromSrc2To[dest] == MAXX) return -1;\\n\\n\\t\\tlong ans = MAXX;\\n\\t\\tfor (long i = 0; i < n; i++) {\\n\\t\\t\\tans = min(ans, fromSrc1To[i] + fromSrc2To[i] + fromDestTo[i]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\tlong MAXX = 1e10;\\npublic:\\n\\t// DIJKSTRA\\n\\tvoid Dijkstra(long src, vector<pair<long, long>> adj[], vector<long>&minDistanceFromSrcTo)\\n\\t{\\n\\t\\tpriority_queue<pair<long, long>, vector<pair<long, long>>, greater<pair<long, long>>> pq;\\n\\t\\tpq.push({0, src});\\n\\t\\tminDistanceFromSrcTo[src] = 0;\\n\\t\\tlong u, v, wt, dist;\\n\\t\\twhile (!pq.empty()) {\\n\\t\\t\\tu = pq.top().second;\\n\\t\\t\\tdist = pq.top().first;\\n\\t\\t\\tpq.pop();\\n\\t\\t\\t// below if satement is Dijkstra optimization which lead to solution of TLE\\n\\t\\t\\t// don\\'t understand go on top of solution i had pasted that link Dijkstra Optimization\\n\\t\\t\\tif (minDistanceFromSrcTo[u] < dist) continue;\\n\\t\\t\\tfor (auto it : adj[u]) {\\n\\t\\t\\t\\tv = it.first;\\n\\t\\t\\t\\twt = it.second;\\n\\t\\t\\t\\tif (minDistanceFromSrcTo[u] + wt < minDistanceFromSrcTo[v]) {\\n\\t\\t\\t\\t\\tminDistanceFromSrcTo[v] = wt + minDistanceFromSrcTo[u];\\n\\t\\t\\t\\t\\tpq.push({minDistanceFromSrcTo[v], v});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tlong minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n\\t\\tvector<pair<long, long>> adj[n], revadj[n];\\n\\t\\tfor (auto e : edges) {\\n\\t\\t\\tadj[e[0]].push_back({e[1], e[2]});\\n\\t\\t\\trevadj[e[1]].push_back({e[0], e[2]});\\n\\t\\t}\\n\\n\\t\\tvector<long>fromSrc1To(n, MAXX), fromSrc2To(n, MAXX), fromDestTo(n, MAXX);\\n\\t\\tDijkstra(src1, adj, fromSrc1To);\\n\\t\\tDijkstra(src2, adj, fromSrc2To);\\n\\t\\tDijkstra(dest, revadj, fromDestTo);\\n\\n\\t\\t// BASE CASE : not found any path from src1 to dest OR src2 to dest then return -1\\n\\t\\tif (fromSrc1To[dest] == MAXX || fromSrc2To[dest] == MAXX) return -1;\\n\\n\\t\\tlong ans = MAXX;\\n\\t\\tfor (long i = 0; i < n; i++) {\\n\\t\\t\\tans = min(ans, fromSrc1To[i] + fromSrc2To[i] + fromDestTo[i]);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844358,
                "title": "how-many-got-77-78-for-3-dijkstra",
                "content": "Not sure about other programming languages but I did the same algo as everyone else,\\n\\nDijkstra from src1 on graph\\nDijkstra from src2 on graph\\nDijkstra from dest on inverse graph\\n\\nNot sure how to optimize this?\\n```\\nimport heapq\\nclass Solution:\\n    def djkstra(self, graph, source, distance):\\n        pq = []\\n        heapq.heapify(pq)\\n        heapq.heappush(pq, (0, source))\\n        while len(pq) > 0:\\n            _, source = heapq.heappop(pq)\\n            for point in graph[source]:\\n                child, edgeWeight = point\\n                if distance[child] > distance[source] + edgeWeight:\\n                    distance[child] = distance[source] + edgeWeight\\n                    heapq.heappush(pq, (distance[child], child))\\n        return\\n        \\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        graph = defaultdict(list)\\n        inverseGraph = defaultdict(list)\\n        for edge in edges:\\n            s, d, w = edge\\n            graph[s].append((d, w))\\n            inverseGraph[d].append((s, w))\\n        \\n        distanceFromSrc1 = {i: float(\"inf\") for i in range(n)}\\n        distanceFromSrc2 = {i: float(\"inf\") for i in range(n)}\\n        distanceFromDest = {i: float(\"inf\") for i in range(n)}\\n        distanceFromSrc1[src1] = 0\\n        distanceFromSrc2[src2] = 0\\n        distanceFromDest[dest] = 0\\n        \\n        self.djkstra(graph, src1, distanceFromSrc1)\\n        self.djkstra(graph, src2, distanceFromSrc2)\\n        self.djkstra(inverseGraph, dest, distanceFromDest)\\n        \\n        # print(distanceFromSrc1)\\n        # print(distanceFromSrc2)\\n        # print(distanceFromDest)\\n        \\n        totalDist = float(\"inf\")\\n        for middle in range(n):\\n            totalDist = min(totalDist, distanceFromSrc1[middle] + distanceFromSrc2[middle] + distanceFromDest[middle])\\n        if totalDist != float(\"inf\"):\\n            return totalDist\\n        return -1\\n```\\n\\nPS: Just adding a `continue`  makes it pass\\n```\\nimport heapq\\nclass Solution:\\n    def djkstra(self, graph, source, distance):\\n        pq = []\\n        heapq.heapify(pq)\\n        heapq.heappush(pq, (0, source))\\n        while len(pq) > 0:\\n            _, source = heapq.heappop(pq)\\n            # the following line prevents the TLE cause if a node has been visited before, then all its children have already been visited. \\n\\t\\t\\t# I was under the wrong impression that any node will enter the pq only once. \\n\\t\\t\\t# But I was wrong-- if edgeWeight is too high then distance[child] > distance[source] + edgeWeight \\n\\t\\t\\t# might hold and thus we will insert the child again inside the queue. \\n            if distance[source] < _:\\n                continue\\n            for point in graph[source]:\\n                child, edgeWeight = point\\n                if distance[child] > distance[source] + edgeWeight:\\n                    distance[child] = distance[source] + edgeWeight\\n                    heapq.heappush(pq, (distance[child], child))\\n        return\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def djkstra(self, graph, source, distance):\\n        pq = []\\n        heapq.heapify(pq)\\n        heapq.heappush(pq, (0, source))\\n        while len(pq) > 0:\\n            _, source = heapq.heappop(pq)\\n            for point in graph[source]:\\n                child, edgeWeight = point\\n                if distance[child] > distance[source] + edgeWeight:\\n                    distance[child] = distance[source] + edgeWeight\\n                    heapq.heappush(pq, (distance[child], child))\\n        return\\n        \\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        graph = defaultdict(list)\\n        inverseGraph = defaultdict(list)\\n        for edge in edges:\\n            s, d, w = edge\\n            graph[s].append((d, w))\\n            inverseGraph[d].append((s, w))\\n        \\n        distanceFromSrc1 = {i: float(\"inf\") for i in range(n)}\\n        distanceFromSrc2 = {i: float(\"inf\") for i in range(n)}\\n        distanceFromDest = {i: float(\"inf\") for i in range(n)}\\n        distanceFromSrc1[src1] = 0\\n        distanceFromSrc2[src2] = 0\\n        distanceFromDest[dest] = 0\\n        \\n        self.djkstra(graph, src1, distanceFromSrc1)\\n        self.djkstra(graph, src2, distanceFromSrc2)\\n        self.djkstra(inverseGraph, dest, distanceFromDest)\\n        \\n        # print(distanceFromSrc1)\\n        # print(distanceFromSrc2)\\n        # print(distanceFromDest)\\n        \\n        totalDist = float(\"inf\")\\n        for middle in range(n):\\n            totalDist = min(totalDist, distanceFromSrc1[middle] + distanceFromSrc2[middle] + distanceFromDest[middle])\\n        if totalDist != float(\"inf\"):\\n            return totalDist\\n        return -1\\n```\n```\\nimport heapq\\nclass Solution:\\n    def djkstra(self, graph, source, distance):\\n        pq = []\\n        heapq.heapify(pq)\\n        heapq.heappush(pq, (0, source))\\n        while len(pq) > 0:\\n            _, source = heapq.heappop(pq)\\n            # the following line prevents the TLE cause if a node has been visited before, then all its children have already been visited. \\n\\t\\t\\t# I was under the wrong impression that any node will enter the pq only once. \\n\\t\\t\\t# But I was wrong-- if edgeWeight is too high then distance[child] > distance[source] + edgeWeight \\n\\t\\t\\t# might hold and thus we will insert the child again inside the queue. \\n            if distance[source] < _:\\n                continue\\n            for point in graph[source]:\\n                child, edgeWeight = point\\n                if distance[child] > distance[source] + edgeWeight:\\n                    distance[child] = distance[source] + edgeWeight\\n                    heapq.heappush(pq, (distance[child], child))\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844285,
                "title": "do-dijkstra-s-three-times",
                "content": "For those who had LTE for some reason, you might be missing that there could be multiple edges between the same pair of nodes. \\nWe only need to look at the smallest value if there are more than one edge between two nodes.\\n\\nBesides that, I used Dijkstra\\'s algorithm three times as the other people are doing.\\n\\n```\\nimport heapq\\n\\nclass Graph:\\n    def __init__(self, num):\\n        self.V = num\\n        self.graph = [[] for _ in range(num)]\\n        self.dist = [float(\\'inf\\')] * num\\n\\n    def add_edge(self, a, b, weight):\\n        self.graph[a].append((b, weight))\\n\\n    def dijkstra(self, source):\\n        self.dist[source] = 0\\n        heap = [(self.dist[i], i) for i in range(self.V)]\\n        heapq.heapify(heap)\\n        while heap:\\n            cur_dist, u = heapq.heappop(heap)\\n            for ad, weight in self.graph[u]:\\n                new_dist = cur_dist + weight\\n                if new_dist < self.dist[ad]:\\n                    self.dist[ad] = new_dist\\n                    heapq.heappush(heap, (new_dist, ad))\\n\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g1, g2, g3 = Graph(n), Graph(n), Graph(n)\\n        minimum_dist_map = dict()\\n        for node_from, node_to, weight in edges:\\n            if (node_from, node_to) in minimum_dist_map:\\n                minimum_dist_map[(node_from, node_to)] = min(minimum_dist_map[(node_from, node_to)], weight)\\n            else:\\n                minimum_dist_map[(node_from, node_to)] = weight\\n        \\n        for (node_from, node_to), weight in minimum_dist_map.items():\\n            g1.add_edge(node_from, node_to, weight)\\n            g2.add_edge(node_from, node_to, weight)\\n            g3.add_edge(node_to, node_from, weight)\\n        \\n        g1.dijkstra(src1); g2.dijkstra(src2); g3.dijkstra(dest);\\n        \\n        res = min(g1.dist[mid] + g2.dist[mid] + g3.dist[mid] for mid in range(n))\\n        res = min(res, g1.dist[dest] + g2.dist[dest])\\n        \\n        return res if res != float(\\'inf\\') else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport heapq\\n\\nclass Graph:\\n    def __init__(self, num):\\n        self.V = num\\n        self.graph = [[] for _ in range(num)]\\n        self.dist = [float(\\'inf\\')] * num\\n\\n    def add_edge(self, a, b, weight):\\n        self.graph[a].append((b, weight))\\n\\n    def dijkstra(self, source):\\n        self.dist[source] = 0\\n        heap = [(self.dist[i], i) for i in range(self.V)]\\n        heapq.heapify(heap)\\n        while heap:\\n            cur_dist, u = heapq.heappop(heap)\\n            for ad, weight in self.graph[u]:\\n                new_dist = cur_dist + weight\\n                if new_dist < self.dist[ad]:\\n                    self.dist[ad] = new_dist\\n                    heapq.heappush(heap, (new_dist, ad))\\n\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g1, g2, g3 = Graph(n), Graph(n), Graph(n)\\n        minimum_dist_map = dict()\\n        for node_from, node_to, weight in edges:\\n            if (node_from, node_to) in minimum_dist_map:\\n                minimum_dist_map[(node_from, node_to)] = min(minimum_dist_map[(node_from, node_to)], weight)\\n            else:\\n                minimum_dist_map[(node_from, node_to)] = weight\\n        \\n        for (node_from, node_to), weight in minimum_dist_map.items():\\n            g1.add_edge(node_from, node_to, weight)\\n            g2.add_edge(node_from, node_to, weight)\\n            g3.add_edge(node_to, node_from, weight)\\n        \\n        g1.dijkstra(src1); g2.dijkstra(src2); g3.dijkstra(dest);\\n        \\n        res = min(g1.dist[mid] + g2.dist[mid] + g3.dist[mid] for mid in range(n))\\n        res = min(res, g1.dist[dest] + g2.dist[dest])\\n        \\n        return res if res != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844143,
                "title": "no-code-use-this-for-upsolving",
                "content": "```\\nFor each NODE in the graph:\\n    answer is minimum of itself, distance of NODE from SOURCE1 + distance of NODE from SOURCE2 + distance of NODE from DESTINATION\\n   ``` \\nEach of these can be found by dijiktras algorithm, we can reverse the edges of the graph for finding distance from DESTINATION.\\n    \\n    \\nTime Complexity - O(nlogn)\\n",
                "solutionTags": [],
                "code": "```\\nFor each NODE in the graph:\\n    answer is minimum of itself, distance of NODE from SOURCE1 + distance of NODE from SOURCE2 + distance of NODE from DESTINATION\\n   ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1844086,
                "title": "c-solution-find-share-path",
                "content": "\\n\\n1. Use bfs to get all the shortest distances from src1, src2 and dest to all nodes.\\n2. try all nodes as middle point, get the smallest result. The formula is src1_distance[i] + src2_distance[i] + dest_distance[i], src1_distance is the shortest distance from src1 to node i, src2_distance[i] and dest_distance[i] are the same meaning. note that dest_distance[i] is a share path distance.\\n    \\n```\\nclass Solution {\\npublic:\\n    int n;\\n    void bfs(int node, unordered_map<int, map<int, int> > &g, vector<long long> &dis) {\\n        priority_queue<pair<long long, int> > pq;\\n        pq.push({0, node});\\n        unordered_set<int> v;\\n        v.reserve(n);\\n        long long ans = 0, cnt = 0;\\n        while(pq.size()) {\\n            auto p = pq.top(); pq.pop();\\n            long long d = -p.first, node = p.second;\\n            if (v.count(node)) continue;\\n            dis[node] = d;\\n            v.insert(node);\\n            for(auto it : g[node]) {\\n                long long nxt = it.first, w = it.second;\\n                pq.push({-d - w, nxt});\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        unordered_map<int, map<int, int> > g, rev_g;\\n        g.reserve(n);\\n        rev_g.reserve(n);\\n        this->n = n;\\n        for(auto &e : edges) {\\n            int v = rev_g[e[1]][e[0]];\\n            if (v == 0) rev_g[e[1]][e[0]] = e[2];\\n            else rev_g[e[1]][e[0]] = min(v, e[2]);\\n\\n            int v1 = g[e[0]][e[1]];\\n            if (v1 == 0) g[e[0]][e[1]] = e[2];\\n            else g[e[0]][e[1]] = min(v1, e[2]);\\n        }\\n        vector<long long> dis1(n, -1), dis2(n, -1), dis3(n, -1);\\n        bfs(src1, g, dis1);\\n        bfs(src2, g, dis2);\\n        bfs(dest, rev_g, dis3);\\n        long long ans = 1e18;\\n        for(int i = 0; i < n; i++) {\\n            if(dis1[i] >= 0 && dis2[i] >= 0 && dis3[i] >= 0) {\\n                ans = min(ans, dis1[i] + dis2[i] + dis3[i]);\\n            }\\n        }\\n        return ans == 1e18 ? -1 : ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    void bfs(int node, unordered_map<int, map<int, int> > &g, vector<long long> &dis) {\\n        priority_queue<pair<long long, int> > pq;\\n        pq.push({0, node});\\n        unordered_set<int> v;\\n        v.reserve(n);\\n        long long ans = 0, cnt = 0;\\n        while(pq.size()) {\\n            auto p = pq.top(); pq.pop();\\n            long long d = -p.first, node = p.second;\\n            if (v.count(node)) continue;\\n            dis[node] = d;\\n            v.insert(node);\\n            for(auto it : g[node]) {\\n                long long nxt = it.first, w = it.second;\\n                pq.push({-d - w, nxt});\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        unordered_map<int, map<int, int> > g, rev_g;\\n        g.reserve(n);\\n        rev_g.reserve(n);\\n        this->n = n;\\n        for(auto &e : edges) {\\n            int v = rev_g[e[1]][e[0]];\\n            if (v == 0) rev_g[e[1]][e[0]] = e[2];\\n            else rev_g[e[1]][e[0]] = min(v, e[2]);\\n\\n            int v1 = g[e[0]][e[1]];\\n            if (v1 == 0) g[e[0]][e[1]] = e[2];\\n            else g[e[0]][e[1]] = min(v1, e[2]);\\n        }\\n        vector<long long> dis1(n, -1), dis2(n, -1), dis3(n, -1);\\n        bfs(src1, g, dis1);\\n        bfs(src2, g, dis2);\\n        bfs(dest, rev_g, dis3);\\n        long long ans = 1e18;\\n        for(int i = 0; i < n; i++) {\\n            if(dis1[i] >= 0 && dis2[i] >= 0 && dis3[i] >= 0) {\\n                ans = min(ans, dis1[i] + dis2[i] + dis3[i]);\\n            }\\n        }\\n        return ans == 1e18 ? -1 : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086292,
                "title": "dijkstra-s-algorithm-reverse-graph-approach-c-well-explained",
                "content": "## Intuition\\nTo find the minimum weight of a subgraph such that it is possible to reach the destination (`dest`) from both source nodes (`src1` and `src2`), we can use Dijkstra\\'s algorithm twice to find the minimum distances from `src1` and `src2` to all other nodes in the graph. Then, we find the minimum total distance from `src1` to `dest`, passing through a node `i`, and also from `src2` to `dest`, passing through the same node `i`. The sum of these two distances, plus the distance from `i` to `dest`, gives us the total weight of the subgraph. We repeat this process for all nodes and return the minimum weight.\\n\\n## Approach\\n1. Define a custom function `func` that performs Dijkstra\\'s algorithm to calculate the minimum distances from a given source node to all other nodes in the graph. The function returns a vector of distances.\\n2. Create two adjacency lists, `adj` and `rev_adj`, to represent the graph and its reverse.\\n3. Initialize three vectors `a`, `b`, and `c` to store the distances from `src1`, `src2`, and `dest` respectively using the `func` function.\\n4. Initialize a variable `ans` to store the minimum weight and set it to a large value (`1e18`).\\n5. Iterate through all nodes in the graph:\\n   - Check if any of the distances `a[i]`, `b[i]`, or `c[i]` is equal to `1e18`, which means that there is no path from one of the source nodes to node `i` or from node `i` to the destination.\\n   - If all three distances are valid, calculate the total weight of the subgraph by adding `a[i]`, `b[i]`, and `c[i]`.\\n   - Update `ans` with the minimum of the current `ans` and the calculated weight.\\n6. Finally, return `-1` if `ans` is still equal to `1e18`, indicating that no valid subgraph exists; otherwise, return `ans` as the minimum weight of the subgraph.\\n\\n## Time Complexity\\n- The time complexity of Dijkstra\\'s algorithm is $$O(VlogV + E)$$, where V is the number of nodes and E is the number of edges.\\n- In this solution, we run Dijkstra\\'s algorithm three times: once for `src1`, once for `src2`, and once for `dest`. Therefore, the overall time complexity is $$O(3 * (VlogV + E))$$, which simplifies to $$O(VlogV + E)$$.\\n\\n## Space Complexity\\n- The space complexity is $$O(V + E)$$ for storing the adjacency lists and vectors for distances, which is dominated by the graph\\'s size.\\n\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\n    vector<ll> func(int &n,int idx,vector<pair<ll,ll>> adj[])\\n    {\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>> pq;\\n        vector<bool> vis(n,false);\\n        vector<ll> dist(n,1e18);\\n        pq.push({0,idx});\\n        dist[idx] = 0;\\n        while(!pq.empty())\\n        {\\n            auto u = pq.top().second;\\n            pq.pop();\\n            if(vis[u])\\n                continue;\\n            vis[u] = true;\\n            for(auto v : adj[u])\\n            {\\n                ll nv = v.first,w = v.second;\\n                if(dist[u]+w<dist[nv])\\n                {\\n                    dist[nv] = dist[u]+w;\\n                    pq.push({dist[nv],nv});\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<pair<ll,ll>> adj[n];\\n        vector<pair<ll,ll>> rev_adj[n];\\n        for(auto x : edges)\\n        {\\n            adj[x[0]].push_back({x[1]*1LL,x[2]*1LL});\\n            rev_adj[x[1]].push_back({x[0]*1LL,x[2]*1LL});\\n        }\\n        vector<ll> a,b,c;\\n        a = func(n,src1,adj);\\n        b = func(n,src2,adj);\\n        c = func(n,dest,rev_adj);\\n        ll ans = 1e18;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==1e18 || b[i]==1e18 || c[i]==1e18)\\n                continue;\\n            ans = min(ans,a[i]+b[i]+c[i]);\\n        }\\n        return ans==1e18?-1:ans;\\n    }\\n};\\n```\\n![14rq5o.jpg](https://assets.leetcode.com/users/images/3d34e5cb-8f17-486d-abce-e05dead5cc89_1695589276.5272136.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Shortest Path"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\n    vector<ll> func(int &n,int idx,vector<pair<ll,ll>> adj[])\\n    {\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>> pq;\\n        vector<bool> vis(n,false);\\n        vector<ll> dist(n,1e18);\\n        pq.push({0,idx});\\n        dist[idx] = 0;\\n        while(!pq.empty())\\n        {\\n            auto u = pq.top().second;\\n            pq.pop();\\n            if(vis[u])\\n                continue;\\n            vis[u] = true;\\n            for(auto v : adj[u])\\n            {\\n                ll nv = v.first,w = v.second;\\n                if(dist[u]+w<dist[nv])\\n                {\\n                    dist[nv] = dist[u]+w;\\n                    pq.push({dist[nv],nv});\\n                }\\n            }\\n        }\\n        return dist;\\n    }\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<pair<ll,ll>> adj[n];\\n        vector<pair<ll,ll>> rev_adj[n];\\n        for(auto x : edges)\\n        {\\n            adj[x[0]].push_back({x[1]*1LL,x[2]*1LL});\\n            rev_adj[x[1]].push_back({x[0]*1LL,x[2]*1LL});\\n        }\\n        vector<ll> a,b,c;\\n        a = func(n,src1,adj);\\n        b = func(n,src2,adj);\\n        c = func(n,dest,rev_adj);\\n        ll ans = 1e18;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]==1e18 || b[i]==1e18 || c[i]==1e18)\\n                continue;\\n            ans = min(ans,a[i]+b[i]+c[i]);\\n        }\\n        return ans==1e18?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062330,
                "title": "c-dijkstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint m;\\nclass Solution {\\npublic:\\n    vector<long long> dijkstra(int src,vector<pair<int,long long>>adj[]){\\n        vector<long long>dist(m,LLONG_MAX);\\n        dist[src]=0;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({dist[src],src});\\n        while(pq.size()){\\n          auto top=pq.top();\\n          pq.pop();\\n          long long nDist=top.first;\\n          int n=top.second;\\n          if(nDist > dist[n])\\n            continue;\\n          for(auto x: adj[n]){\\n              int c=x.first;\\n             long long cd=x.second;\\n              if(cd+nDist < dist[c]){\\n                  dist[c]=cd+nDist;\\n                  pq.push({dist[c],c});\\n              }\\n          }\\n        }\\n      return dist;\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        // src1->i  adj\\n        // src2->i  adj\\n        // dest->i  inv\\n        m=n;\\n        vector<pair<int,long long>>adj[n];\\n        vector<pair<int,long long>>inv[n];\\n        for(auto &x: edges){\\n            int from=x[0];\\n            int to=x[1];\\n            long long wt=x[2];\\n            adj[from].push_back({to,wt});\\n            inv[to].push_back({from,wt});\\n        }\\n         vector<long long>dist1=dijkstra(src1,adj);\\n         vector<long long>dist2=dijkstra(src2,adj);\\n         vector<long long>dist3=dijkstra(dest,inv);\\n         long long minWeight = LLONG_MAX;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (dist1[i] != LLONG_MAX && dist2[i] != LLONG_MAX && dist3[i] != LLONG_MAX) {\\n                minWeight = min(minWeight, dist1[i] + dist2[i] + dist3[i]);\\n            }\\n        }\\n        return minWeight == LLONG_MAX ? -1 : minWeight;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint m;\\nclass Solution {\\npublic:\\n    vector<long long> dijkstra(int src,vector<pair<int,long long>>adj[]){\\n        vector<long long>dist(m,LLONG_MAX);\\n        dist[src]=0;\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>>pq;\\n        pq.push({dist[src],src});\\n        while(pq.size()){\\n          auto top=pq.top();\\n          pq.pop();\\n          long long nDist=top.first;\\n          int n=top.second;\\n          if(nDist > dist[n])\\n            continue;\\n          for(auto x: adj[n]){\\n              int c=x.first;\\n             long long cd=x.second;\\n              if(cd+nDist < dist[c]){\\n                  dist[c]=cd+nDist;\\n                  pq.push({dist[c],c});\\n              }\\n          }\\n        }\\n      return dist;\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        // src1->i  adj\\n        // src2->i  adj\\n        // dest->i  inv\\n        m=n;\\n        vector<pair<int,long long>>adj[n];\\n        vector<pair<int,long long>>inv[n];\\n        for(auto &x: edges){\\n            int from=x[0];\\n            int to=x[1];\\n            long long wt=x[2];\\n            adj[from].push_back({to,wt});\\n            inv[to].push_back({from,wt});\\n        }\\n         vector<long long>dist1=dijkstra(src1,adj);\\n         vector<long long>dist2=dijkstra(src2,adj);\\n         vector<long long>dist3=dijkstra(dest,inv);\\n         long long minWeight = LLONG_MAX;\\n\\n        for (int i = 0; i < n; ++i) {\\n            if (dist1[i] != LLONG_MAX && dist2[i] != LLONG_MAX && dist3[i] != LLONG_MAX) {\\n                minWeight = min(minWeight, dist1[i] + dist2[i] + dist3[i]);\\n            }\\n        }\\n        return minWeight == LLONG_MAX ? -1 : minWeight;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042988,
                "title": "java-clean-dijsktras-from-dest-and-both-sources",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        List<int[]>[] graph = new ArrayList[n];\\n        List<int[]>[] inGraph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n            inGraph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(new int[]{e[1], e[2]});\\n            inGraph[e[1]].add(new int[]{e[0], e[2]});\\n        }\\n\\n        Long[] distD = new Long[n];\\n        shortestPath(dest, distD, inGraph);\\n\\n        if (distD[src1] == null || distD[src2] == null) {\\n            return -1;\\n        }\\n        \\n        Long[] distSrc1 = new Long[n];\\n        shortestPath(src1, distSrc1, graph);\\n        Long[] distSrc2 = new Long[n];\\n        shortestPath(src2, distSrc2, graph);\\n\\n        long min = Long.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            if (distD[i] == null || distSrc1[i] == null || distSrc2[i] == null) {\\n                continue;\\n            }\\n            min = Math.min(min, distD[i]+distSrc1[i]+distSrc2[i]);\\n        }\\n\\n        return min;\\n    }\\n\\n    private void shortestPath(int src, Long[] distances, List<int[]>[] graph) {\\n        PriorityQueue<long[]> pq = new PriorityQueue<>((v1, v2)->Long.compare(v1[1], v2[1]));\\n        pq.add(new long[]{src, 0});\\n        while ( ! pq.isEmpty()) {\\n            long[] c = pq.poll();\\n            int u = (int)c[0];\\n            \\n            if (distances[u] != null) {\\n                continue;\\n            }\\n            distances[u] = c[1];\\n            for (int[] e : graph[u]) {\\n                if (distances[e[0]] != null) {\\n                    continue;\\n                }\\n                pq.add(new long[]{e[0], c[1]+e[1]});\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        List<int[]>[] graph = new ArrayList[n];\\n        List<int[]>[] inGraph = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            graph[i] = new ArrayList<>();\\n            inGraph[i] = new ArrayList<>();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(new int[]{e[1], e[2]});\\n            inGraph[e[1]].add(new int[]{e[0], e[2]});\\n        }\\n\\n        Long[] distD = new Long[n];\\n        shortestPath(dest, distD, inGraph);\\n\\n        if (distD[src1] == null || distD[src2] == null) {\\n            return -1;\\n        }\\n        \\n        Long[] distSrc1 = new Long[n];\\n        shortestPath(src1, distSrc1, graph);\\n        Long[] distSrc2 = new Long[n];\\n        shortestPath(src2, distSrc2, graph);\\n\\n        long min = Long.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            if (distD[i] == null || distSrc1[i] == null || distSrc2[i] == null) {\\n                continue;\\n            }\\n            min = Math.min(min, distD[i]+distSrc1[i]+distSrc2[i]);\\n        }\\n\\n        return min;\\n    }\\n\\n    private void shortestPath(int src, Long[] distances, List<int[]>[] graph) {\\n        PriorityQueue<long[]> pq = new PriorityQueue<>((v1, v2)->Long.compare(v1[1], v2[1]));\\n        pq.add(new long[]{src, 0});\\n        while ( ! pq.isEmpty()) {\\n            long[] c = pq.poll();\\n            int u = (int)c[0];\\n            \\n            if (distances[u] != null) {\\n                continue;\\n            }\\n            distances[u] = c[1];\\n            for (int[] e : graph[u]) {\\n                if (distances[e[0]] != null) {\\n                    continue;\\n                }\\n                pq.add(new long[]{e[0], c[1]+e[1]});\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040230,
                "title": "c-dijkstras-solution-intutive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe want the sum of paths from src1 and src2 to dest to be min. So, there are 3 possibilities of paths, i.e. \\n1. min dist path from src1 to src2 and then min dist path from src2 to dest\\n2. min dist path from src2 to src1 and then min dist path from src1 to dest\\n3. min dist path from src1 and src2 to an intermediate node \\'x\\' and then min dist path from \\'x\\' to dest.\\n\\nSo, apply Dijkstras 3 times. One from src1, other from src2 and third from dest(on reversing the dges of the graph).\\n\\nThen, find minimum among all three path possibilities.\\n# Complexity\\n- Time complexity:O(n+e)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n+e)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void prepare(unordered_map<int, set<pair<int, int>>> &adj, vector<vector<int>> &edges)\\n    {\\n        for(int i = 0 ; i < edges.size() ; i++)\\n        {\\n            adj[edges[i][0]].insert({edges[i][1], edges[i][2]});\\n        }\\n    }\\n    void dijkstras(int src, unordered_map<int, set<pair<int, int>>> &adj, vector<long long> &dist)\\n    {\\n        dist[src] = 0;\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, src});\\n\\n        while(!pq.empty())\\n        {\\n            pair<long long, int> t = pq.top();\\n            pq.pop();\\n            long long d = t.first;\\n            int node = t.second;\\n\\n            for(auto it: adj[node])\\n            {\\n                if(d + it.second < dist[it.first])\\n                {\\n                    dist[it.first] = d + it.second;\\n                    pq.push({d+it.second, it.first});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<int>> rev_edges;\\n        for(int i = 0 ; i < edges.size() ; i++)\\n        {\\n            rev_edges.push_back({edges[i][1], edges[i][0], edges[i][2]});\\n        }\\n\\n        unordered_map<int, set<pair<int, int>>> adj;\\n        unordered_map<int, set<pair<int, int>>> adj_rev;\\n\\n        prepare(adj, edges);\\n        prepare(adj_rev, rev_edges);\\n\\n        vector<long long> dist_s1(n, LLONG_MAX);\\n        vector<long long> dist_s2(n, LLONG_MAX);\\n        vector<long long> dist_des(n, LLONG_MAX);\\n        dijkstras(src1, adj, dist_s1);\\n        dijkstras(src2, adj, dist_s2);\\n        dijkstras(dest, adj_rev, dist_des);\\n\\n\\n        //src1 -> src2 -> dest\\n        long long path1 = LLONG_MAX;\\n        if(dist_s1[src2] != LLONG_MAX && dist_s2[dest] != LLONG_MAX)\\n            path1 = dist_s1[src2] + dist_s2[dest];\\n\\n        //src2 -> src1 -> dest\\n        long long path2 = LLONG_MAX;\\n        if(dist_s2[src1] != LLONG_MAX && dist_s1[dest] != LLONG_MAX)\\n            path2 = dist_s2[src1] + dist_s1[dest];\\n\\n\\n        // dest -> \\'x\\' -> src1 and src2 (x is any intermediate node apart from src1 and src2)\\n        long long path3 = LLONG_MAX;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(i != src1 && i != src2)\\n            {\\n                if(dist_des[i] != LLONG_MAX && dist_s1[i] != LLONG_MAX && dist_s2[i] != LLONG_MAX)\\n                {\\n                    path3 = min(path3, dist_des[i] + dist_s1[i] + dist_s2[i]);\\n                }\\n            }\\n        }\\n\\n        if(path1 != LLONG_MAX || path2 != LLONG_MAX || path3 != LLONG_MAX)\\n        {\\n            return min(path1, min(path2, path3));\\n        }\\n        else \\n            return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void prepare(unordered_map<int, set<pair<int, int>>> &adj, vector<vector<int>> &edges)\\n    {\\n        for(int i = 0 ; i < edges.size() ; i++)\\n        {\\n            adj[edges[i][0]].insert({edges[i][1], edges[i][2]});\\n        }\\n    }\\n    void dijkstras(int src, unordered_map<int, set<pair<int, int>>> &adj, vector<long long> &dist)\\n    {\\n        dist[src] = 0;\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, src});\\n\\n        while(!pq.empty())\\n        {\\n            pair<long long, int> t = pq.top();\\n            pq.pop();\\n            long long d = t.first;\\n            int node = t.second;\\n\\n            for(auto it: adj[node])\\n            {\\n                if(d + it.second < dist[it.first])\\n                {\\n                    dist[it.first] = d + it.second;\\n                    pq.push({d+it.second, it.first});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<int>> rev_edges;\\n        for(int i = 0 ; i < edges.size() ; i++)\\n        {\\n            rev_edges.push_back({edges[i][1], edges[i][0], edges[i][2]});\\n        }\\n\\n        unordered_map<int, set<pair<int, int>>> adj;\\n        unordered_map<int, set<pair<int, int>>> adj_rev;\\n\\n        prepare(adj, edges);\\n        prepare(adj_rev, rev_edges);\\n\\n        vector<long long> dist_s1(n, LLONG_MAX);\\n        vector<long long> dist_s2(n, LLONG_MAX);\\n        vector<long long> dist_des(n, LLONG_MAX);\\n        dijkstras(src1, adj, dist_s1);\\n        dijkstras(src2, adj, dist_s2);\\n        dijkstras(dest, adj_rev, dist_des);\\n\\n\\n        //src1 -> src2 -> dest\\n        long long path1 = LLONG_MAX;\\n        if(dist_s1[src2] != LLONG_MAX && dist_s2[dest] != LLONG_MAX)\\n            path1 = dist_s1[src2] + dist_s2[dest];\\n\\n        //src2 -> src1 -> dest\\n        long long path2 = LLONG_MAX;\\n        if(dist_s2[src1] != LLONG_MAX && dist_s1[dest] != LLONG_MAX)\\n            path2 = dist_s2[src1] + dist_s1[dest];\\n\\n\\n        // dest -> \\'x\\' -> src1 and src2 (x is any intermediate node apart from src1 and src2)\\n        long long path3 = LLONG_MAX;\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            if(i != src1 && i != src2)\\n            {\\n                if(dist_des[i] != LLONG_MAX && dist_s1[i] != LLONG_MAX && dist_s2[i] != LLONG_MAX)\\n                {\\n                    path3 = min(path3, dist_des[i] + dist_s1[i] + dist_s2[i]);\\n                }\\n            }\\n        }\\n\\n        if(path1 != LLONG_MAX || path2 != LLONG_MAX || path3 != LLONG_MAX)\\n        {\\n            return min(path1, min(path2, path3));\\n        }\\n        else \\n            return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944520,
                "title": "triple-dijkstra-in-python-faster-than-92",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem can be re-framed as the problem to find a meeting vertex `k` so that $$\\\\delta_{s_1, k} + \\\\delta_{s_2, k} + \\\\delta_{k, d}$$ is minimized, where $$\\\\delta_{s_1, k}$$ is the shortest distance between `src1` and `k`, $$\\\\delta_{s_2, k}$$ is the shortest distance between `src2` and `k`, and $$\\\\delta_{k, d}$$ is the shortest distance between `k` and `dest`. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTherefore, we can do the efficient Dijkstra algorithm to find the distances from `src1` and `src2` to all vertices. We can also find the distances from all vertices to `dest` by composing a graph with reversed edges. Finally, exploring each vertex as the meeting point `k` to find the minimum. Each Dijkstra algorithm spends $$O(|E| \\\\log |V|)$$ (with usual binary heap), and the last step spends $$O(|V|)$$ since all the $$\\\\delta_{s_1, k}$$, $$\\\\delta_{s_2, k}$$, and $$\\\\delta_{k, d}$$ are precomputed. \\n\\n# Complexity\\n- Time complexity: $$O(|E| \\\\log |V|)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        graph, reversed_graph = defaultdict(dict), defaultdict(dict)\\n        for u, v, w in edges:\\n            graph[u][v] = min(w, graph[u].get(v, inf))\\n            reversed_graph[v][u] = min(w, reversed_graph[v].get(u, inf))\\n        \\n        def dijkstra(g, src):\\n            dist = {}\\n            h = [(0, src)]\\n            while h:\\n                d, v = heappop(h)\\n                if v not in dist:\\n                    dist[v] = d\\n                    for u in g[v]:\\n                        if u not in dist:\\n                            heappush(h, (d+g[v][u], u))\\n            return dist\\n\\n        src1_dist = dijkstra(graph, src1)\\n        src2_dist = dijkstra(graph, src2)\\n        dest_dist = dijkstra(reversed_graph, dest)\\n        return min((src1_dist[k] + src2_dist[k] + dest_dist[k] for k in range(n) \\n                    if k in src1_dist and k in src2_dist and k in dest_dist), \\n                    default=-1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        graph, reversed_graph = defaultdict(dict), defaultdict(dict)\\n        for u, v, w in edges:\\n            graph[u][v] = min(w, graph[u].get(v, inf))\\n            reversed_graph[v][u] = min(w, reversed_graph[v].get(u, inf))\\n        \\n        def dijkstra(g, src):\\n            dist = {}\\n            h = [(0, src)]\\n            while h:\\n                d, v = heappop(h)\\n                if v not in dist:\\n                    dist[v] = d\\n                    for u in g[v]:\\n                        if u not in dist:\\n                            heappush(h, (d+g[v][u], u))\\n            return dist\\n\\n        src1_dist = dijkstra(graph, src1)\\n        src2_dist = dijkstra(graph, src2)\\n        dest_dist = dijkstra(reversed_graph, dest)\\n        return min((src1_dist[k] + src2_dist[k] + dest_dist[k] for k in range(n) \\n                    if k in src1_dist and k in src2_dist and k in dest_dist), \\n                    default=-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3901125,
                "title": "my-solution",
                "content": "```\\n/**\\n * some observations\\n * 1. the minimum weight of a subgraph of the graph descripted by the edges `edges` is\\n *    the minimum weight of the edges of the two paths,\\n *    one path is from the node `src1` to the node `dest`,\\n *    another path is from the node `scr2` to the node `dest`\\n * 2. there must exist a node `node` such that\\n *    the sum of the weights of the following three paths is minimum,\\n *    these three paths constitue the target subgraph\\n *    1). the minimum weight of the edges of the path from the node `src1` to the node `node`\\n *    2). the minimum weight of the edges of the path from the node `src2` to the node `node`\\n *    3). the minimum weight of the edges of the path from the node `node` to the node `dest`\\n *    `src1`\\n *          \\\\\\n *           `node`--`dest`\\n *          /\\n *    `src2`\\n *    please note that the node `node` could be the node `src1`,\\n *                     or the node `scr2`, or the node `dest`\\n *\\n * Time Complexity: (n + n_edges * log(n))\\n * Space Complexity: O(n + n_edges)\\n * where `n_edges` is the length of the vector `edges`\\n */\\nclass Solution {\\n public:\\n  long long minimumWeight(const int n,\\n                          const vector<vector<int>> &edges,\\n                          const int src1,\\n                          const int src2,\\n                          const int dest) {\\n    constexpr int from_i = 0;\\n    constexpr int to_i = 1;\\n    constexpr int weight_i = 2;\\n    vector<pair<int, int>> graph[n];\\n    vector<pair<int, int>> reversed_graph[n];\\n    for (const vector<int> &edge : edges) {\\n      graph[edge[from_i]].emplace_back(edge[to_i], edge[weight_i]);\\n      reversed_graph[edge[to_i]].emplace_back(edge[from_i], edge[weight_i]);\\n    }\\n    \\n    long long distances_src1[n];\\n    memset(distances_src1, -1, sizeof(distances_src1));\\n    dijkstra(graph, n, src1, distances_src1);\\n    long long distances_src2[n];\\n    memset(distances_src2, -1, sizeof(distances_src2));\\n    dijkstra(graph, n, src2, distances_src2);\\n    long long distances_dest[n];\\n    memset(distances_dest, -1, sizeof(distances_dest));\\n    dijkstra(reversed_graph, n, dest, distances_dest);\\n    \\n    long long ret = numeric_limits<long long>::max();\\n    for (int node = 0; node < n; ++node) {\\n      if (distances_src1[node] != -1 && distances_src2[node] != -1 && distances_dest[node] != -1) {\\n        ret = min(ret, distances_src1[node] + distances_src2[node] + distances_dest[node]);\\n      }\\n    }\\n    return ret == numeric_limits<long long>::max() ? -1 : ret;;\\n  }\\n  \\n private:\\n  void dijkstra(const vector<pair<int, int>> *graph, const int n, const int node, long long *distances) {\\n    distances[node] = 0LL;\\n    bool visited[n];\\n    memset(visited, 0, sizeof(visited));\\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<>> pq;\\n    pq.emplace(0LL, node);\\n    while (!pq.empty()) {\\n      const auto [distance, node] = pq.top();\\n      pq.pop();\\n      if (visited[node]) {\\n        continue;\\n      }\\n      visited[node] = true;\\n      distances[node] = distance;\\n      for (const auto [next, distance_delta] : graph[node]) {\\n        if (!visited[next]) {\\n          pq.emplace(distance + distance_delta, next);\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * some observations\\n * 1. the minimum weight of a subgraph of the graph descripted by the edges `edges` is\\n *    the minimum weight of the edges of the two paths,\\n *    one path is from the node `src1` to the node `dest`,\\n *    another path is from the node `scr2` to the node `dest`\\n * 2. there must exist a node `node` such that\\n *    the sum of the weights of the following three paths is minimum,\\n *    these three paths constitue the target subgraph\\n *    1). the minimum weight of the edges of the path from the node `src1` to the node `node`\\n *    2). the minimum weight of the edges of the path from the node `src2` to the node `node`\\n *    3). the minimum weight of the edges of the path from the node `node` to the node `dest`\\n *    `src1`\\n *          \\\\\\n *           `node`--`dest`\\n *          /\\n *    `src2`\\n *    please note that the node `node` could be the node `src1`,\\n *                     or the node `scr2`, or the node `dest`\\n *\\n * Time Complexity: (n + n_edges * log(n))\\n * Space Complexity: O(n + n_edges)\\n * where `n_edges` is the length of the vector `edges`\\n */\\nclass Solution {\\n public:\\n  long long minimumWeight(const int n,\\n                          const vector<vector<int>> &edges,\\n                          const int src1,\\n                          const int src2,\\n                          const int dest) {\\n    constexpr int from_i = 0;\\n    constexpr int to_i = 1;\\n    constexpr int weight_i = 2;\\n    vector<pair<int, int>> graph[n];\\n    vector<pair<int, int>> reversed_graph[n];\\n    for (const vector<int> &edge : edges) {\\n      graph[edge[from_i]].emplace_back(edge[to_i], edge[weight_i]);\\n      reversed_graph[edge[to_i]].emplace_back(edge[from_i], edge[weight_i]);\\n    }\\n    \\n    long long distances_src1[n];\\n    memset(distances_src1, -1, sizeof(distances_src1));\\n    dijkstra(graph, n, src1, distances_src1);\\n    long long distances_src2[n];\\n    memset(distances_src2, -1, sizeof(distances_src2));\\n    dijkstra(graph, n, src2, distances_src2);\\n    long long distances_dest[n];\\n    memset(distances_dest, -1, sizeof(distances_dest));\\n    dijkstra(reversed_graph, n, dest, distances_dest);\\n    \\n    long long ret = numeric_limits<long long>::max();\\n    for (int node = 0; node < n; ++node) {\\n      if (distances_src1[node] != -1 && distances_src2[node] != -1 && distances_dest[node] != -1) {\\n        ret = min(ret, distances_src1[node] + distances_src2[node] + distances_dest[node]);\\n      }\\n    }\\n    return ret == numeric_limits<long long>::max() ? -1 : ret;;\\n  }\\n  \\n private:\\n  void dijkstra(const vector<pair<int, int>> *graph, const int n, const int node, long long *distances) {\\n    distances[node] = 0LL;\\n    bool visited[n];\\n    memset(visited, 0, sizeof(visited));\\n    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<>> pq;\\n    pq.emplace(0LL, node);\\n    while (!pq.empty()) {\\n      const auto [distance, node] = pq.top();\\n      pq.pop();\\n      if (visited[node]) {\\n        continue;\\n      }\\n      visited[node] = true;\\n      distances[node] = distance;\\n      for (const auto [next, distance_delta] : graph[node]) {\\n        if (!visited[next]) {\\n          pq.emplace(distance + distance_delta, next);\\n        }\\n      }\\n    }\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768627,
                "title": "rust-dijkstra",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf solution exists, there must be a node u such the solution is the sum of the distances from two sources to u and the distance from u to the destination.   \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse Dijkstra\\'s algorithm to calculate the distance vectors from two sources.\\nUse Dijkstra\\'s algorithm to calculate the distance vector from each node to destination. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N Log N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn minimum_weight(n: i32, edges: Vec<Vec<i32>>, src1: i32, src2: i32, dest: i32) -> i64 {\\n        let n = n as usize;\\n        let (mut graph, mut graph_reverse) = (vec![vec![]; n], vec![vec![]; n]);\\n        for e in edges {\\n            let (u, v, w) = (e[0] as usize, e[1] as usize, e[2] as i64);\\n            graph[u].push((v, w));\\n            graph_reverse[v].push((u, w));\\n        }\\n\\n        let (mut d1, mut d2, mut d3) = (vec![i64::MAX; n], vec![i64::MAX; n], vec![i64::MAX; n]);\\n        Self::calculate(&graph, &mut d1, src1 as usize);\\n        Self::calculate(&graph, &mut d2, src2 as usize);\\n        Self::calculate(&graph_reverse, &mut d3, dest as usize);\\n\\n        let mut ret = i64::MAX;\\n        for u in 0 .. n {\\n            if d1[u] == i64::MAX || d2[u] == i64::MAX || d3[u] == i64::MAX { continue }\\n            ret = ret.min(d1[u] + d2[u] + d3[u]);\\n        } \\n        \\n        if ret == i64::MAX { -1 } else { ret } \\n    }\\n\\n    fn calculate(graph: &Vec<Vec<(usize, i64)>>, dist: &mut Vec<i64>, src: usize) {\\n        let mut pq = BinaryHeap::new();\\n        \\n        pq.push(Reverse((0i64, src)));\\n        dist[src] = 0;\\n        while let Some(Reverse((d, u))) = pq.pop() {\\n            if dist[u] < d { continue }\\n            \\n            for (v, w) in &graph[u] {\\n                let (v, w) = (*v, *w);\\n                if dist[v] <= d + w { continue }\\n                \\n                dist[v] = d + w;\\n                pq.push(Reverse((d + w, v)));\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::cmp::Reverse;\\nuse std::collections::BinaryHeap;\\n\\nimpl Solution {\\n    pub fn minimum_weight(n: i32, edges: Vec<Vec<i32>>, src1: i32, src2: i32, dest: i32) -> i64 {\\n        let n = n as usize;\\n        let (mut graph, mut graph_reverse) = (vec![vec![]; n], vec![vec![]; n]);\\n        for e in edges {\\n            let (u, v, w) = (e[0] as usize, e[1] as usize, e[2] as i64);\\n            graph[u].push((v, w));\\n            graph_reverse[v].push((u, w));\\n        }\\n\\n        let (mut d1, mut d2, mut d3) = (vec![i64::MAX; n], vec![i64::MAX; n], vec![i64::MAX; n]);\\n        Self::calculate(&graph, &mut d1, src1 as usize);\\n        Self::calculate(&graph, &mut d2, src2 as usize);\\n        Self::calculate(&graph_reverse, &mut d3, dest as usize);\\n\\n        let mut ret = i64::MAX;\\n        for u in 0 .. n {\\n            if d1[u] == i64::MAX || d2[u] == i64::MAX || d3[u] == i64::MAX { continue }\\n            ret = ret.min(d1[u] + d2[u] + d3[u]);\\n        } \\n        \\n        if ret == i64::MAX { -1 } else { ret } \\n    }\\n\\n    fn calculate(graph: &Vec<Vec<(usize, i64)>>, dist: &mut Vec<i64>, src: usize) {\\n        let mut pq = BinaryHeap::new();\\n        \\n        pq.push(Reverse((0i64, src)));\\n        dist[src] = 0;\\n        while let Some(Reverse((d, u))) = pq.pop() {\\n            if dist[u] < d { continue }\\n            \\n            for (v, w) in &graph[u] {\\n                let (v, w) = (*v, *w);\\n                if dist[v] <= d + w { continue }\\n                \\n                dist[v] = d + w;\\n                pq.push(Reverse((d + w, v)));\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3757640,
                "title": "java-beats-100",
                "content": "1. Use adjacency table to store the spase graph.\\n2. Use dijkstra to find $src1$, $src2$ and $dest$ shortest path, for $dest$ node, we need to use the backward adjacency table.\\n```\\nclass Solution {\\n    int[] heads, dests, nexts, weights;\\n    boolean[] visited;\\n    int idx;\\n    long INF = Long.MAX_VALUE / 2;\\n    int _n, _m;\\n\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        _n = n;\\n        _m = edges.length;\\n        long[] aDists = new long[n];\\n        long[] bDists = new long[n];\\n        long[] cDists = new long[n];\\n        initForwardAdjacencyTable(edges);\\n        dijkstra(aDists, src1);\\n        dijkstra(bDists, src2);\\n        initBackwardAdjacencyTable(edges);\\n        dijkstra(cDists, dest);\\n        long res = INF;\\n        for (int i = 0; i < n; i++) {\\n            if (aDists[i] == INF || bDists[i] == INF || cDists[i] == INF) continue;\\n            res = Math.min(res, aDists[i] + bDists[i] + cDists[i]);\\n        }\\n        return res == INF ? -1 : res;\\n    }\\n\\n    private void dijkstra(long[] dists, int src) {\\n        visited = new boolean[_n];\\n        Arrays.fill(dists, INF);\\n        dists[src] = 0;\\n        Arrays.fill(visited, false);\\n        PriorityQueue<long[]> pq = new PriorityQueue<>((o1, o2) -> Math.toIntExact(o1[1] - o2[1]));\\n        pq.offer(new long[]{src, dists[src]});\\n        while (!pq.isEmpty()) {\\n            long[] poll = pq.poll();\\n            int id = (int) poll[0];\\n            if (visited[id]) continue;\\n            visited[id] = true;\\n            for (int i = heads[id]; i != -1; i = nexts[i]) {\\n                int neighbour = dests[i];\\n                if (dists[neighbour] > dists[id] + weights[i]) {\\n                    dists[neighbour] = dists[id] + weights[i];\\n                    pq.offer(new long[]{neighbour, dists[neighbour]});\\n                }\\n            }\\n        }\\n    }\\n\\n    private void initForwardAdjacencyTable(int[][] edges) {\\n        heads = new int[_n];\\n        Arrays.fill(heads, -1);\\n        dests = new int[_m];\\n        nexts = new int[_m];\\n        weights = new int[_m];\\n        idx = 0;\\n        for (int[] edge : edges) {\\n            int source = edge[0];\\n            int dest = edge[1];\\n            int weight = edge[2];\\n            add(source, dest, weight);\\n        }\\n    }\\n\\n    private void initBackwardAdjacencyTable(int[][] edges) {\\n        heads = new int[_n];\\n        Arrays.fill(heads, -1);\\n        dests = new int[_m];\\n        nexts = new int[_m];\\n        weights = new int[_m];\\n        idx = 0;\\n        for (int[] edge : edges) {\\n            int dest = edge[0];\\n            int source = edge[1];\\n            int weight = edge[2];\\n            add(source, dest, weight);\\n        }\\n    }\\n\\n    private void add(int a, int b, int c) {\\n        dests[idx] = b;\\n        nexts[idx] = heads[a];\\n        heads[a] = idx;\\n        weights[idx] = c;\\n        idx++;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\n    int[] heads, dests, nexts, weights;\\n    boolean[] visited;\\n    int idx;\\n    long INF = Long.MAX_VALUE / 2;\\n    int _n, _m;\\n\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        _n = n;\\n        _m = edges.length;\\n        long[] aDists = new long[n];\\n        long[] bDists = new long[n];\\n        long[] cDists = new long[n];\\n        initForwardAdjacencyTable(edges);\\n        dijkstra(aDists, src1);\\n        dijkstra(bDists, src2);\\n        initBackwardAdjacencyTable(edges);\\n        dijkstra(cDists, dest);\\n        long res = INF;\\n        for (int i = 0; i < n; i++) {\\n            if (aDists[i] == INF || bDists[i] == INF || cDists[i] == INF) continue;\\n            res = Math.min(res, aDists[i] + bDists[i] + cDists[i]);\\n        }\\n        return res == INF ? -1 : res;\\n    }\\n\\n    private void dijkstra(long[] dists, int src) {\\n        visited = new boolean[_n];\\n        Arrays.fill(dists, INF);\\n        dists[src] = 0;\\n        Arrays.fill(visited, false);\\n        PriorityQueue<long[]> pq = new PriorityQueue<>((o1, o2) -> Math.toIntExact(o1[1] - o2[1]));\\n        pq.offer(new long[]{src, dists[src]});\\n        while (!pq.isEmpty()) {\\n            long[] poll = pq.poll();\\n            int id = (int) poll[0];\\n            if (visited[id]) continue;\\n            visited[id] = true;\\n            for (int i = heads[id]; i != -1; i = nexts[i]) {\\n                int neighbour = dests[i];\\n                if (dists[neighbour] > dists[id] + weights[i]) {\\n                    dists[neighbour] = dists[id] + weights[i];\\n                    pq.offer(new long[]{neighbour, dists[neighbour]});\\n                }\\n            }\\n        }\\n    }\\n\\n    private void initForwardAdjacencyTable(int[][] edges) {\\n        heads = new int[_n];\\n        Arrays.fill(heads, -1);\\n        dests = new int[_m];\\n        nexts = new int[_m];\\n        weights = new int[_m];\\n        idx = 0;\\n        for (int[] edge : edges) {\\n            int source = edge[0];\\n            int dest = edge[1];\\n            int weight = edge[2];\\n            add(source, dest, weight);\\n        }\\n    }\\n\\n    private void initBackwardAdjacencyTable(int[][] edges) {\\n        heads = new int[_n];\\n        Arrays.fill(heads, -1);\\n        dests = new int[_m];\\n        nexts = new int[_m];\\n        weights = new int[_m];\\n        idx = 0;\\n        for (int[] edge : edges) {\\n            int dest = edge[0];\\n            int source = edge[1];\\n            int weight = edge[2];\\n            add(source, dest, weight);\\n        }\\n    }\\n\\n    private void add(int a, int b, int c) {\\n        dests[idx] = b;\\n        nexts[idx] = heads[a];\\n        heads[a] = idx;\\n        weights[idx] = c;\\n        idx++;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3614403,
                "title": "80-beats-in-both",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport heapq\\nfrom typing import List\\nfrom collections import defaultdict\\n\\ndef dijk(s, g, n):\\n    dis = [float(\"inf\")] * n\\n    par = [-1] * n\\n    dis[s] = 0\\n    q = [(0, s)]\\n    while q:\\n        wt, t = heapq.heappop(q)\\n        if wt != dis[t]:\\n            continue\\n        for i, w in g[t]:\\n            if w + wt < dis[i]:\\n                dis[i] = w + wt\\n                heapq.heappush(q, (w + wt, i))\\n                par[i] = t\\n    return dis, par\\n\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g = defaultdict(list)\\n        gr = defaultdict(list)\\n        for x, y, w in edges:\\n            g[x].append((y, w))\\n            gr[y].append((x, w))\\n        \\n        d1, p1 = dijk(src1, g, n)\\n        d2, p2 = dijk(src2, g, n)\\n        \\n        ans = float(\"inf\")\\n        for i, w in gr[dest]:\\n            ans = min(ans, d1[i] + d2[i] + w, d1[dest] + d2[i] + w)\\n        \\n        ed = dest\\n        while ed != -1:\\n            ans = min(ans, d1[dest] + d2[ed])\\n            ed = p1[ed]\\n        \\n        ed = dest\\n        while ed != -1:\\n            ans = min(ans, d2[dest] + d1[ed])\\n            ed = p2[ed]\\n        \\n        ans = min(ans, d1[dest] + d2[dest])\\n        \\n        if ans == float(\"inf\"):\\n            ans = -1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nfrom typing import List\\nfrom collections import defaultdict\\n\\ndef dijk(s, g, n):\\n    dis = [float(\"inf\")] * n\\n    par = [-1] * n\\n    dis[s] = 0\\n    q = [(0, s)]\\n    while q:\\n        wt, t = heapq.heappop(q)\\n        if wt != dis[t]:\\n            continue\\n        for i, w in g[t]:\\n            if w + wt < dis[i]:\\n                dis[i] = w + wt\\n                heapq.heappush(q, (w + wt, i))\\n                par[i] = t\\n    return dis, par\\n\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g = defaultdict(list)\\n        gr = defaultdict(list)\\n        for x, y, w in edges:\\n            g[x].append((y, w))\\n            gr[y].append((x, w))\\n        \\n        d1, p1 = dijk(src1, g, n)\\n        d2, p2 = dijk(src2, g, n)\\n        \\n        ans = float(\"inf\")\\n        for i, w in gr[dest]:\\n            ans = min(ans, d1[i] + d2[i] + w, d1[dest] + d2[i] + w)\\n        \\n        ed = dest\\n        while ed != -1:\\n            ans = min(ans, d1[dest] + d2[ed])\\n            ed = p1[ed]\\n        \\n        ed = dest\\n        while ed != -1:\\n            ans = min(ans, d2[dest] + d1[ed])\\n            ed = p2[ed]\\n        \\n        ans = min(ans, d1[dest] + d2[dest])\\n        \\n        if ans == float(\"inf\"):\\n            ans = -1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3594851,
                "title": "c-3x-dijkstra-s-and-meet-in-the-middle",
                "content": "I had the idea to calculate the shortest path from src1 to dest and also from src2 to dest but couldn\\'t figure out how to take advantage of overlapping paths. The solution is calculate also the shortest path from dest. Then, for each `i`, we visualize all 3 nodes meeting at that node, and find the `i` where the `dist[i]` from all 3 sources are minimized.\\n# Code\\n```\\nusing ti = pair<long long, long long>;\\nclass Solution {\\npublic:\\n    void dijkstra(vector<vector<ti>>& adj, vector<long long>& ans, int src) {\\n        priority_queue< ti, vector<ti>, greater<>> pq;\\n        pq.push({ 0, src });\\n        while (!pq.empty()) {\\n            auto [w, node] = pq.top();\\n            pq.pop();\\n            if (ans[node] != -1) continue;\\n            ans[node] = w;\\n            for (auto &[nei, neiW]: adj[node]) pq.push({ w+neiW, nei });\\n        }\\n    }\\n\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<long long> time1(n, -1);\\n        vector<long long> time2(n, -1);\\n        vector<long long> time3(n, -1);\\n\\n        vector<vector<ti>> adj(n);\\n        vector<vector<ti>> adjR(n);\\n\\n        for (auto& e: edges) {\\n            adj[e[0]].push_back({ e[1], e[2] });\\n            adjR[e[1]].push_back({ e[0], e[2] });\\n        }\\n\\n        dijkstra(adj, time1, src1);\\n        dijkstra(adj, time2, src2);\\n        dijkstra(adjR, time3, dest);\\n        \\n        long long ans = LONG_LONG_MAX;\\n        for (int i = 0; i < n; i++) {\\n            if (time1[i] == -1 || time2[i] == -1 || time3[i] == -1) continue;\\n            ans = min(ans, time1[i] + time2[i] + time3[i]);\\n        }\\n\\n        return ans == LONG_LONG_MAX ? -1 : ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nusing ti = pair<long long, long long>;\\nclass Solution {\\npublic:\\n    void dijkstra(vector<vector<ti>>& adj, vector<long long>& ans, int src) {\\n        priority_queue< ti, vector<ti>, greater<>> pq;\\n        pq.push({ 0, src });\\n        while (!pq.empty()) {\\n            auto [w, node] = pq.top();\\n            pq.pop();\\n            if (ans[node] != -1) continue;\\n            ans[node] = w;\\n            for (auto &[nei, neiW]: adj[node]) pq.push({ w+neiW, nei });\\n        }\\n    }\\n\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<long long> time1(n, -1);\\n        vector<long long> time2(n, -1);\\n        vector<long long> time3(n, -1);\\n\\n        vector<vector<ti>> adj(n);\\n        vector<vector<ti>> adjR(n);\\n\\n        for (auto& e: edges) {\\n            adj[e[0]].push_back({ e[1], e[2] });\\n            adjR[e[1]].push_back({ e[0], e[2] });\\n        }\\n\\n        dijkstra(adj, time1, src1);\\n        dijkstra(adj, time2, src2);\\n        dijkstra(adjR, time3, dest);\\n        \\n        long long ans = LONG_LONG_MAX;\\n        for (int i = 0; i < n; i++) {\\n            if (time1[i] == -1 || time2[i] == -1 || time3[i] == -1) continue;\\n            ans = min(ans, time1[i] + time2[i] + time3[i]);\\n        }\\n\\n        return ans == LONG_LONG_MAX ? -1 : ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455684,
                "title": "cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<unordered_map<int,int>>e (n,unordered_map<int,int>());\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            auto itr=e[edges[i][0]].find(edges[i][1]);\\n            if(itr==e[edges[i][0]].end())\\n            {\\n                e[edges[i][0]][edges[i][1]]=edges[i][2];\\n            }\\n            else\\n            itr->second=min(itr->second,edges[i][2]);\\n        }\\n        \\n      \\n      long long weight=0;\\n      int node;\\n         multimap<long long,int> mp;\\n         mp.insert({0,src1});\\n                 vector<long long> v1(n,-1),v2=v1;\\n         while(mp.size()>0)\\n         {\\n             weight=mp.begin()->first;\\n             node=mp.begin()->second;\\n             mp.erase(mp.begin());\\n             if(v1[node]==-1)\\n             v1[node]=weight;\\n             auto itr=e[node].begin();\\n             while(itr!=e[node].end())\\n             {\\n                 if(v1[itr->first]==-1)\\n                 {\\n                     mp.insert({weight+itr->second,itr->first});\\n                 }\\n                 itr++;\\n             }\\n         }\\n                  mp.clear();\\n        mp.insert({0,src2});\\n           while(mp.size()>0)\\n         {\\n             weight=mp.begin()->first;\\n              node=mp.begin()->second;\\n             if(v2[node]==-1)\\n             v2[node]=weight;\\n           \\n             mp.erase(mp.begin());\\n             auto itr=e[node].begin();\\n              while(itr!=e[node].end())\\n             {\\n                 if(v2[itr->first]==-1)\\n                 {\\n                     mp.insert({weight+itr->second,itr->first});\\n                 }\\n                 itr++;\\n             }\\n         }\\n      \\n                         mp.clear();\\n\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            if(v1[i]!=-1 && v2[i]!=-1)\\n            mp.insert({v1[i]+v2[i],i});\\n        }\\n        vector<bool> v(n,0);\\n        while(mp.size()>0)\\n        {\\n             node=mp.begin()->second;\\n            weight=mp.begin()->first;\\n            v[node]=1;\\n            if(node==dest)\\n            return weight;\\n            mp.erase(mp.begin());\\n            auto itr=e[node].begin();\\n            while(itr!=e[node].end())\\n            {\\n                if(!v[itr->first])\\n                {\\n                    mp.insert({weight+itr->second,itr->first});\\n                }\\n                itr++;\\n            }\\n\\n        }\\n        return -1;\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<unordered_map<int,int>>e (n,unordered_map<int,int>());\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            auto itr=e[edges[i][0]].find(edges[i][1]);\\n            if(itr==e[edges[i][0]].end())\\n            {\\n                e[edges[i][0]][edges[i][1]]=edges[i][2];\\n            }\\n            else\\n            itr->second=min(itr->second,edges[i][2]);\\n        }\\n        \\n      \\n      long long weight=0;\\n      int node;\\n         multimap<long long,int> mp;\\n         mp.insert({0,src1});\\n                 vector<long long> v1(n,-1),v2=v1;\\n         while(mp.size()>0)\\n         {\\n             weight=mp.begin()->first;\\n             node=mp.begin()->second;\\n             mp.erase(mp.begin());\\n             if(v1[node]==-1)\\n             v1[node]=weight;\\n             auto itr=e[node].begin();\\n             while(itr!=e[node].end())\\n             {\\n                 if(v1[itr->first]==-1)\\n                 {\\n                     mp.insert({weight+itr->second,itr->first});\\n                 }\\n                 itr++;\\n             }\\n         }\\n                  mp.clear();\\n        mp.insert({0,src2});\\n           while(mp.size()>0)\\n         {\\n             weight=mp.begin()->first;\\n              node=mp.begin()->second;\\n             if(v2[node]==-1)\\n             v2[node]=weight;\\n           \\n             mp.erase(mp.begin());\\n             auto itr=e[node].begin();\\n              while(itr!=e[node].end())\\n             {\\n                 if(v2[itr->first]==-1)\\n                 {\\n                     mp.insert({weight+itr->second,itr->first});\\n                 }\\n                 itr++;\\n             }\\n         }\\n      \\n                         mp.clear();\\n\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            if(v1[i]!=-1 && v2[i]!=-1)\\n            mp.insert({v1[i]+v2[i],i});\\n        }\\n        vector<bool> v(n,0);\\n        while(mp.size()>0)\\n        {\\n             node=mp.begin()->second;\\n            weight=mp.begin()->first;\\n            v[node]=1;\\n            if(node==dest)\\n            return weight;\\n            mp.erase(mp.begin());\\n            auto itr=e[node].begin();\\n            while(itr!=e[node].end())\\n            {\\n                if(!v[itr->first])\\n                {\\n                    mp.insert({weight+itr->second,itr->first});\\n                }\\n                itr++;\\n            }\\n\\n        }\\n        return -1;\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306648,
                "title": "2-dijkstras-hack-me",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef dijk(s,g,n):\\n    dis=[float(\"inf\")]*n\\n    par=[-1]*n\\n    dis[s]=0\\n    q=[(0,s)]\\n    while q:\\n        wt,t=heapq.heappop(q)\\n        if wt!=dis[t]:\\n            continue\\n        for i,w in g[t]:\\n            if w+wt<dis[i]:\\n                dis[i]=w+wt\\n                heapq.heappush(q,(w+wt,i))\\n                par[i]=t\\n    return dis,par\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g=defaultdict(list)\\n        gr=defaultdict(list)\\n        for x,y,w in edges:\\n            g[x].append((y,w))\\n            gr[y].append((x,w))\\n            # print(x,y,w)\\n        d1,p1=dijk(src1,g,n)\\n        d2,p2=dijk(src2,g,n)\\n        ans=float(\"inf\")\\n        for i,w in gr[dest]:\\n            ans=min(ans,d1[i]+d2[i]+w,d1[dest]+d2[i]+w)\\n        ed=dest\\n        # print(p1)\\n        # print(p2)\\n        while ed!=-1:\\n            ans=min(ans,d1[dest]+d2[ed])\\n            # print(\"dis1\",d1[dest],d2[ed],dest,ed)\\n            ed=p1[ed]\\n        ed=dest\\n        while ed!=-1:\\n            ans=min(ans,d2[dest]+d1[ed])\\n            # print(\"dis\",d2[dest],d1[ed],dest,ed)\\n            ed=p2[ed]\\n        ans=min(ans,d1[dest]+d2[dest])\\n        # ans=min(ans,d1[src2]+d2[dest],d2[src1]+d1[dest],d1[dest]+d2[dest])\\n        if ans==float(\"inf\"):\\n            ans=-1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef dijk(s,g,n):\\n    dis=[float(\"inf\")]*n\\n    par=[-1]*n\\n    dis[s]=0\\n    q=[(0,s)]\\n    while q:\\n        wt,t=heapq.heappop(q)\\n        if wt!=dis[t]:\\n            continue\\n        for i,w in g[t]:\\n            if w+wt<dis[i]:\\n                dis[i]=w+wt\\n                heapq.heappush(q,(w+wt,i))\\n                par[i]=t\\n    return dis,par\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g=defaultdict(list)\\n        gr=defaultdict(list)\\n        for x,y,w in edges:\\n            g[x].append((y,w))\\n            gr[y].append((x,w))\\n            # print(x,y,w)\\n        d1,p1=dijk(src1,g,n)\\n        d2,p2=dijk(src2,g,n)\\n        ans=float(\"inf\")\\n        for i,w in gr[dest]:\\n            ans=min(ans,d1[i]+d2[i]+w,d1[dest]+d2[i]+w)\\n        ed=dest\\n        # print(p1)\\n        # print(p2)\\n        while ed!=-1:\\n            ans=min(ans,d1[dest]+d2[ed])\\n            # print(\"dis1\",d1[dest],d2[ed],dest,ed)\\n            ed=p1[ed]\\n        ed=dest\\n        while ed!=-1:\\n            ans=min(ans,d2[dest]+d1[ed])\\n            # print(\"dis\",d2[dest],d1[ed],dest,ed)\\n            ed=p2[ed]\\n        ans=min(ans,d1[dest]+d2[dest])\\n        # ans=min(ans,d1[src2]+d2[dest],d2[src1]+d1[dest],d1[dest]+d2[dest])\\n        if ans==float(\"inf\"):\\n            ans=-1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163442,
                "title": "could-be-faster-than-dijkstra-in-average",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf there is a subgraph comply, there should exist at least one node that, src1 and src2 both reach that node and that node reach dest. The dest is one of them.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstrat from for both src1 and src2 travel the graph to caculate the cost to reach any node that is reachable\\nstart from dest travel the reversed (reverse all edges\\' direction) graph to caculate the cost from any node\\n\\n# special note\\nThis looks like a dijkstra, but it is not. \\ndijkstra use prioritied heap queue, which has O(n*log(N)) time complexity\\nFor this problem just use a stack. as average time complexity will be O(n) though in the worst combination every single node will be recaculated when a less cost path has been found. The worst case could be O(N**2) when recaculate could happen to every single node. While I believe that will be very rare.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nE is the amount of edges\\nO(E)\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(E)\\n\\n# Code\\n```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g = defaultdict(dict)\\n        r = defaultdict(dict)\\n        for f,t,w in edges:\\n            g[f][t] = min(w, g[f].get(t,inf))\\n            r[t][f] = min(w, r[t].get(f,inf))\\n        wt = {}\\n        ws1 = {}\\n        ws2 = {}\\n        def t(s, g, w):\\n            sk = [(s,0)]\\n            while sk:\\n                s, c = sk.pop()\\n                if c < w.get(s,inf):\\n                    w[s] = c\\n                    for i, w0 in g[s].items():\\n                        sk.append((i, w0 + c))\\n            # print(s, w)\\n                        \\n        t(dest, r, wt)\\n        t(src1, g, ws1)\\n        t(src2, g, ws2)\\n        if dest not in ws1 or dest not in ws2:\\n            return -1\\n        return min (ws1[i] + ws2[i] + wt[i] for i in ws1 if i in wt and i in ws2)\\n        # return min (ws1[i] + ws2[i] + wt[i] for i in range(n) if i in ws1 and i in ws2 and i in wt)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g = defaultdict(dict)\\n        r = defaultdict(dict)\\n        for f,t,w in edges:\\n            g[f][t] = min(w, g[f].get(t,inf))\\n            r[t][f] = min(w, r[t].get(f,inf))\\n        wt = {}\\n        ws1 = {}\\n        ws2 = {}\\n        def t(s, g, w):\\n            sk = [(s,0)]\\n            while sk:\\n                s, c = sk.pop()\\n                if c < w.get(s,inf):\\n                    w[s] = c\\n                    for i, w0 in g[s].items():\\n                        sk.append((i, w0 + c))\\n            # print(s, w)\\n                        \\n        t(dest, r, wt)\\n        t(src1, g, ws1)\\n        t(src2, g, ws2)\\n        if dest not in ws1 or dest not in ws2:\\n            return -1\\n        return min (ws1[i] + ws2[i] + wt[i] for i in ws1 if i in wt and i in ws2)\\n        # return min (ws1[i] + ws2[i] + wt[i] for i in range(n) if i in ws1 and i in ws2 and i in wt)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126916,
                "title": "c",
                "content": "```\\nusing LL = long long ;\\nusing PII = pair<LL, LL> ;\\nclass Solution {\\n    int n ;\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        this->n = n ;\\n        vector<vector<PII>> forward(n) ;\\n        vector<vector<PII>> backward(n) ;\\n        for(auto e : edges){\\n            int a = e[0], b = e[1], c = e[2] ;\\n            forward[a].push_back({b, c}) ;\\n            backward[b].push_back({a, c}) ;\\n        }\\n        \\n        vector<LL> src1ToNode = dijkstra(src1, forward) ;\\n        vector<LL> str2ToNode = dijkstra(src2, forward) ;\\n        vector<LL> NodeToDest = dijkstra(dest, backward) ;\\n        LL ans = LLONG_MAX/3 ;\\n        for(int i = 0; i < n; i++){\\n            ans = min(ans, src1ToNode[i] + str2ToNode[i] + NodeToDest[i] ) ;\\n        }\\n     \\n        return (ans >= LLONG_MAX/3) ? -1 : ans ;\\n    }\\n    \\n    vector<LL> dijkstra(int src, vector<vector<PII>> & map)\\n    {\\n        vector<LL> dist(n, LLONG_MAX/3) ;\\n        priority_queue<PII, vector<PII>, greater<>> pq ;\\n        pq.push({0, src}) ;\\n        while( !pq.empty() ){\\n            auto[d, cur] = pq.top() ;\\n            pq.pop() ;\\n            if(dist[cur] == LLONG_MAX/3)\\n                dist[cur] = d ;\\n            else\\n                continue ;\\n            \\n            for(auto [nxt, weight] : map[cur])\\n            {\\n                if(dist[nxt] < LLONG_MAX/3) \\n                    continue ;\\n                pq.push({d + weight, nxt}) ;\\n            }\\n        }\\n        return dist ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing LL = long long ;\\nusing PII = pair<LL, LL> ;\\nclass Solution {\\n    int n ;\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        this->n = n ;\\n        vector<vector<PII>> forward(n) ;\\n        vector<vector<PII>> backward(n) ;\\n        for(auto e : edges){\\n            int a = e[0], b = e[1], c = e[2] ;\\n            forward[a].push_back({b, c}) ;\\n            backward[b].push_back({a, c}) ;\\n        }\\n        \\n        vector<LL> src1ToNode = dijkstra(src1, forward) ;\\n        vector<LL> str2ToNode = dijkstra(src2, forward) ;\\n        vector<LL> NodeToDest = dijkstra(dest, backward) ;\\n        LL ans = LLONG_MAX/3 ;\\n        for(int i = 0; i < n; i++){\\n            ans = min(ans, src1ToNode[i] + str2ToNode[i] + NodeToDest[i] ) ;\\n        }\\n     \\n        return (ans >= LLONG_MAX/3) ? -1 : ans ;\\n    }\\n    \\n    vector<LL> dijkstra(int src, vector<vector<PII>> & map)\\n    {\\n        vector<LL> dist(n, LLONG_MAX/3) ;\\n        priority_queue<PII, vector<PII>, greater<>> pq ;\\n        pq.push({0, src}) ;\\n        while( !pq.empty() ){\\n            auto[d, cur] = pq.top() ;\\n            pq.pop() ;\\n            if(dist[cur] == LLONG_MAX/3)\\n                dist[cur] = d ;\\n            else\\n                continue ;\\n            \\n            for(auto [nxt, weight] : map[cur])\\n            {\\n                if(dist[nxt] < LLONG_MAX/3) \\n                    continue ;\\n                pq.push({d + weight, nxt}) ;\\n            }\\n        }\\n        return dist ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032655,
                "title": "c-dijkstra-avoiding-tle-trick",
                "content": "**Note, that you should ingnore cases when minimal distance is smaller than current d in while cycle**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long minimumWeight(const int& N, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        Graph G(N), rev_G(N);\\n        static const long long inf = LONG_MAX;\\n        long long ans = inf;\\n\\n        \\n        for (const vector<int>& E : edges)\\n            G[E[0]].push_back(make_pair(E[1], E[2])), rev_G[E[1]].push_back(make_pair(E[0], E[2]));\\n\\n        vector<long long> dist1(N, inf), dist2(N, inf), dist3(N, inf);\\n        Dijkstra(G, src1, dist1);\\n        Dijkstra(G, src2, dist2);\\n        Dijkstra(rev_G, dest, dist3);\\n\\n        \\n\\n        for (int i = 0; i < N; i++)\\n            if (dist3[i] != inf && dist1[i] != inf && dist2[i] != inf)\\n                ans = min(ans, dist3[i] + dist1[i] + dist2[i]);\\n\\n        return ans == inf ? -1 : ans;\\n    }\\n\\nprivate:\\n    using Graph = vector<vector<pair<int, int> > >;\\n\\n    void Dijkstra(const Graph& G, const int& src, vector<long long>& dist)\\n    {\\n        dist[src] = 0;\\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> q;\\n        q.push(make_pair(0, src));\\n\\n        while (q.empty() == false)\\n        {\\n            auto [d, u] = q.top();\\n            q.pop();\\n\\n            if (d > dist[u]) continue; // Avoiding for getting TLE\\n            \\n            for (const pair<int, int>& E : G[u])\\n                if (dist[E.first] > E.second + d)\\n                    dist[E.first] = d + E.second,  q.push(make_pair(E.second + d, E.first));\\n        }\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Shortest Path"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumWeight(const int& N, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        Graph G(N), rev_G(N);\\n        static const long long inf = LONG_MAX;\\n        long long ans = inf;\\n\\n        \\n        for (const vector<int>& E : edges)\\n            G[E[0]].push_back(make_pair(E[1], E[2])), rev_G[E[1]].push_back(make_pair(E[0], E[2]));\\n\\n        vector<long long> dist1(N, inf), dist2(N, inf), dist3(N, inf);\\n        Dijkstra(G, src1, dist1);\\n        Dijkstra(G, src2, dist2);\\n        Dijkstra(rev_G, dest, dist3);\\n\\n        \\n\\n        for (int i = 0; i < N; i++)\\n            if (dist3[i] != inf && dist1[i] != inf && dist2[i] != inf)\\n                ans = min(ans, dist3[i] + dist1[i] + dist2[i]);\\n\\n        return ans == inf ? -1 : ans;\\n    }\\n\\nprivate:\\n    using Graph = vector<vector<pair<int, int> > >;\\n\\n    void Dijkstra(const Graph& G, const int& src, vector<long long>& dist)\\n    {\\n        dist[src] = 0;\\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> q;\\n        q.push(make_pair(0, src));\\n\\n        while (q.empty() == false)\\n        {\\n            auto [d, u] = q.top();\\n            q.pop();\\n\\n            if (d > dist[u]) continue; // Avoiding for getting TLE\\n            \\n            for (const pair<int, int>& E : G[u])\\n                if (dist[E.first] > E.second + d)\\n                    dist[E.first] = d + E.second,  q.push(make_pair(E.second + d, E.first));\\n        }\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014176,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long int\\n#define mod 1e18\\n\\nclass Solution {\\npublic:\\n    void dijkstra(int src, vector<pair<int,ll>>adj[], vector<ll>&dist) {\\n        priority_queue<pair<ll,int>, vector<pair<ll,int>>,greater<pair<ll,int>>> pq;\\n        pq.push({0, src});\\n        dist[src] = 0;\\n        while(!pq.empty()) {\\n            auto p = pq.top();\\n            pq.pop();\\n            ll dis = p.first;\\n            int u = p.second;\\n\\n            if(dis != dist[u]) continue;\\n            \\n            for(auto i: adj[u]) {\\n                int v = i.first;\\n                ll wt = i.second;\\n                if(dis + wt < dist[v]) {\\n                    dist[v] = dis + wt;\\n                    pq.push({dist[v], v});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<pair<int, ll>>adj[n+1], rev[n+1];\\n        for(auto i: edges) {\\n            int u = i[0], v = i[1], wt = i[2];\\n            adj[u].push_back({v,wt});\\n            rev[v].push_back({u,wt});\\n        }\\n        \\n        vector<ll> d1(n, mod), d2(n, mod), d3(n, mod);\\n        // dijkstra from src 1;\\n        dijkstra(src1, adj, d1);\\n        \\n        // dijkstra from src 2;\\n        dijkstra(src2, adj, d2);\\n        \\n        // dijkstra from dest\\n        dijkstra(dest, rev, d3);\\n\\n        // if(d1[src1] == mod || d2[src2] == mod) return -1;\\n\\n        ll ans = mod;\\n        for(ll i=0;i<n;i++) ans = min(ans, d1[i]+d2[i]+d3[i]);\\n\\n        return ans == mod ? -1 : ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long int\\n#define mod 1e18\\n\\nclass Solution {\\npublic:\\n    void dijkstra(int src, vector<pair<int,ll>>adj[], vector<ll>&dist) {\\n        priority_queue<pair<ll,int>, vector<pair<ll,int>>,greater<pair<ll,int>>> pq;\\n        pq.push({0, src});\\n        dist[src] = 0;\\n        while(!pq.empty()) {\\n            auto p = pq.top();\\n            pq.pop();\\n            ll dis = p.first;\\n            int u = p.second;\\n\\n            if(dis != dist[u]) continue;\\n            \\n            for(auto i: adj[u]) {\\n                int v = i.first;\\n                ll wt = i.second;\\n                if(dis + wt < dist[v]) {\\n                    dist[v] = dis + wt;\\n                    pq.push({dist[v], v});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<pair<int, ll>>adj[n+1], rev[n+1];\\n        for(auto i: edges) {\\n            int u = i[0], v = i[1], wt = i[2];\\n            adj[u].push_back({v,wt});\\n            rev[v].push_back({u,wt});\\n        }\\n        \\n        vector<ll> d1(n, mod), d2(n, mod), d3(n, mod);\\n        // dijkstra from src 1;\\n        dijkstra(src1, adj, d1);\\n        \\n        // dijkstra from src 2;\\n        dijkstra(src2, adj, d2);\\n        \\n        // dijkstra from dest\\n        dijkstra(dest, rev, d3);\\n\\n        // if(d1[src1] == mod || d2[src2] == mod) return -1;\\n\\n        ll ans = mod;\\n        for(ll i=0;i<n;i++) ans = min(ans, d1[i]+d2[i]+d3[i]);\\n\\n        return ans == mod ? -1 : ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673777,
                "title": "c-djkstra-clean",
                "content": "```\\n#define ll long long\\n#define pii pair<long long int,long long int>\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>adj[100005];\\n    vector<pair<int,int>>adj1[100005];\\n    void fun(int src,vector<ll int>&dist,bool rev)\\n    {\\n        dist[src]=0;\\n        priority_queue<pii,vector<pii>,greater<pii>>q;\\n        q.push({0,src});\\n        vector<bool>vis(dist.size());\\n        while(!q.empty())\\n        {\\n            auto val=q.top();\\n            ll int currx=val.second;\\n            ll int currw=val.first;\\n            q.pop();\\n            if(vis[currx])\\n                continue;\\n            vis[currx]=true;\\n            if(!rev)\\n            {\\n                for(auto j:adj[currx])\\n                {\\n                    if(!vis[j.first] && dist[j.first]>currw+j.second)\\n                    {\\n                        dist[j.first]=currw+j.second;\\n                        q.push({dist[j.first],j.first});\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for(auto j:adj1[currx])\\n                {\\n                    if(!vis[j.first] && dist[j.first]>currw+j.second)\\n                    {\\n                        dist[j.first]=currw+j.second;\\n                        q.push({dist[j.first],j.first});\\n                    }\\n                }              \\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        for(auto j:edges)\\n        {\\n            adj[j[0]].push_back({j[1],j[2]});\\n            adj1[j[1]].push_back({j[0],j[2]});\\n        }\\n        vector<ll int>disa(n,1e11),disb(n,1e11),disd(n,1e11);\\n        fun(src1,disa,0);\\n        fun(src2,disb,0);\\n        fun(dest,disd,1);\\n        ll int ans=1e11;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,disa[i]+disb[i]+disd[i]);\\n        }\\n        if(ans>1e10)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n#define pii pair<long long int,long long int>\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>adj[100005];\\n    vector<pair<int,int>>adj1[100005];\\n    void fun(int src,vector<ll int>&dist,bool rev)\\n    {\\n        dist[src]=0;\\n        priority_queue<pii,vector<pii>,greater<pii>>q;\\n        q.push({0,src});\\n        vector<bool>vis(dist.size());\\n        while(!q.empty())\\n        {\\n            auto val=q.top();\\n            ll int currx=val.second;\\n            ll int currw=val.first;\\n            q.pop();\\n            if(vis[currx])\\n                continue;\\n            vis[currx]=true;\\n            if(!rev)\\n            {\\n                for(auto j:adj[currx])\\n                {\\n                    if(!vis[j.first] && dist[j.first]>currw+j.second)\\n                    {\\n                        dist[j.first]=currw+j.second;\\n                        q.push({dist[j.first],j.first});\\n                    }\\n                }\\n            }\\n            else\\n            {\\n                for(auto j:adj1[currx])\\n                {\\n                    if(!vis[j.first] && dist[j.first]>currw+j.second)\\n                    {\\n                        dist[j.first]=currw+j.second;\\n                        q.push({dist[j.first],j.first});\\n                    }\\n                }              \\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        for(auto j:edges)\\n        {\\n            adj[j[0]].push_back({j[1],j[2]});\\n            adj1[j[1]].push_back({j[0],j[2]});\\n        }\\n        vector<ll int>disa(n,1e11),disb(n,1e11),disd(n,1e11);\\n        fun(src1,disa,0);\\n        fun(src2,disb,0);\\n        fun(dest,disd,1);\\n        ll int ans=1e11;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans=min(ans,disa[i]+disb[i]+disd[i]);\\n        }\\n        if(ans>1e10)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672488,
                "title": "python-simple-dijkstra-maths",
                "content": "\\n    def dijkstra(self, n, dict1, s1):\\n        visited, stack = defaultdict(int), [(0,s1)]\\n        \\n        while stack:\\n            time, node = heappop(stack)\\n            \\n            if node not in visited:\\n                visited[node] = time\\n                \\n                for neighbor in dict1[node]:\\n                    if neighbor[0] not in visited:\\n                        heappush(stack, (time + neighbor[1], neighbor[0]))\\n                    \\n        return [visited.get(i,float(\"inf\")) for i in range(n)]\\n                \\n    def minimumWeight(self, n, edges, src1, src2, dest):\\n        dict1, dict2, min_val = defaultdict(list), defaultdict(list), float(\"inf\")\\n        \\n        for i, j, k in edges:\\n            dict1[i].append((j,k))\\n            dict2[j].append((i,k))\\n            \\n        d1 = self.dijkstra(n,dict1,src1)\\n        d2 = self.dijkstra(n,dict1,src2)\\n        d3 = self.dijkstra(n,dict2,dest)\\n        \\n        \\n        for i in range(n):\\n            min_val = min(min_val, d1[i] + d2[i] + d3[i])\\n        \\n        return min_val if min_val != float(\"inf\") else -1",
                "solutionTags": [],
                "code": "\\n    def dijkstra(self, n, dict1, s1):\\n        visited, stack = defaultdict(int), [(0,s1)]\\n        \\n        while stack:\\n            time, node = heappop(stack)\\n            \\n            if node not in visited:\\n                visited[node] = time\\n                \\n                for neighbor in dict1[node]:\\n                    if neighbor[0] not in visited:\\n                        heappush(stack, (time + neighbor[1], neighbor[0]))\\n                    \\n        return [visited.get(i,float(\"inf\")) for i in range(n)]\\n                \\n    def minimumWeight(self, n, edges, src1, src2, dest):\\n        dict1, dict2, min_val = defaultdict(list), defaultdict(list), float(\"inf\")\\n        \\n        for i, j, k in edges:\\n            dict1[i].append((j,k))\\n            dict2[j].append((i,k))\\n            \\n        d1 = self.dijkstra(n,dict1,src1)\\n        d2 = self.dijkstra(n,dict1,src2)\\n        d3 = self.dijkstra(n,dict2,dest)\\n        \\n        \\n        for i in range(n):\\n            min_val = min(min_val, d1[i] + d2[i] + d3[i])\\n        \\n        return min_val if min_val != float(\"inf\") else -1",
                "codeTag": "Python3"
            },
            {
                "id": 2631031,
                "title": "c-3-dijkstra-algorithm",
                "content": "**If Helpful Please Like Or Upvoke**\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<ll> dijkstra(int& src,  vector<vector<pair<int, ll>>>&graph, int &V) {\\n        vector<ll> distanceToLastNode(V+1, 1e18);\\n    distanceToLastNode[src] = 0;\\n    priority_queue<pair<ll, int>, vector<pair<ll, int>>,greater<pair<ll, int>>> pq;\\n    pq.push({0, src});\\n      while (!pq.empty()) {\\n          int u=pq.top().second;\\n            int distance=pq.top().first;\\n            pq.pop();\\n            /* TLE Elimination */\\n            if(distance>distanceToLastNode[u])\\n                continue;\\n      for (auto next : graph[u]) {\\n        int v = next.first, dis = next.second;\\n        if (distanceToLastNode[v] > distanceToLastNode[u] + dis) {\\n          distanceToLastNode[v] = distanceToLastNode[u] +dis;\\n          pq.push({distanceToLastNode[v], v});\\n        }\\n      }\\n    }\\n        return distanceToLastNode;\\n  }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int, ll>>>adj(n+1), rev(n+1);\\n        for(auto e: edges){\\n            adj[e[0]].push_back({e[1], e[2]});\\n            rev[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        vector<ll>d1=dijkstra(src1, adj, n);\\n        vector<ll>d2=dijkstra(src2, adj, n);\\n        vector<ll>d3=dijkstra(dest, rev, n);\\n        ll ans=1e18;\\n        for(int i=0;i<n;i++){\\n            ans=min(ans, d1[i]+d2[i]+d3[i]);\\n        }\\n        if(ans==1e18)return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<ll> dijkstra(int& src,  vector<vector<pair<int, ll>>>&graph, int &V) {\\n        vector<ll> distanceToLastNode(V+1, 1e18);\\n    distanceToLastNode[src] = 0;\\n    priority_queue<pair<ll, int>, vector<pair<ll, int>>,greater<pair<ll, int>>> pq;\\n    pq.push({0, src});\\n      while (!pq.empty()) {\\n          int u=pq.top().second;\\n            int distance=pq.top().first;\\n            pq.pop();\\n            /* TLE Elimination */\\n            if(distance>distanceToLastNode[u])\\n                continue;\\n      for (auto next : graph[u]) {\\n        int v = next.first, dis = next.second;\\n        if (distanceToLastNode[v] > distanceToLastNode[u] + dis) {\\n          distanceToLastNode[v] = distanceToLastNode[u] +dis;\\n          pq.push({distanceToLastNode[v], v});\\n        }\\n      }\\n    }\\n        return distanceToLastNode;\\n  }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int, ll>>>adj(n+1), rev(n+1);\\n        for(auto e: edges){\\n            adj[e[0]].push_back({e[1], e[2]});\\n            rev[e[1]].push_back({e[0], e[2]});\\n        }\\n        \\n        vector<ll>d1=dijkstra(src1, adj, n);\\n        vector<ll>d2=dijkstra(src2, adj, n);\\n        vector<ll>d3=dijkstra(dest, rev, n);\\n        ll ans=1e18;\\n        for(int i=0;i<n;i++){\\n            ans=min(ans, d1[i]+d2[i]+d3[i]);\\n        }\\n        if(ans==1e18)return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589842,
                "title": "javascript-dijkstra-backwards-and-forwards-midpoints",
                "content": "```\\nfunction minimumWeight(n, edges, src1, src2, dest) {\\n    \\n    const list = [];\\n    const reverseList = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        list[i] = [];\\n        reverseList[i] = [];\\n    }\\n    \\n    for (const [a, b, w] of edges) {\\n        list[a].push([b, w]);\\n        reverseList[b].push([a, w]);\\n    }\\n    \\n    function bfs(node, reverse, sources) {\\n        const minPaths = new Map();\\n        const heap = new MinPriorityQueue();\\n        \\n        heap.enqueue(node, 0);\\n        \\n        while (!heap.isEmpty()) {\\n            const next = heap.dequeue();\\n            const path = minPaths.get(next.element);\\n            \\n            if (path !== undefined) continue;\\n            \\n            minPaths.set(next.element, next.priority);\\n            \\n            const adjacencies = reverse ? reverseList[next.element] : list[next.element];\\n            \\n            for (const [node, weight] of adjacencies) {\\n                if (reverse || sources.has(node)) {\\n                    heap.enqueue(node, next.priority + weight);\\n                }\\n            }\\n        }\\n        \\n        return minPaths;\\n    }\\n    \\n    const minDest = bfs(dest, true);\\n    \\n    if (!minDest.has(src1)) return -1;\\n    if (!minDest.has(src2)) return -1;\\n    \\n    const minSrc1 = bfs(src1, false, minDest);\\n    const minSrc2 = bfs(src2, false, minDest);\\n    \\n    let min = Number.MAX_SAFE_INTEGER;\\n    \\n    for (const [midpoint, pathSum] of minDest) {\\n        const path1 = minSrc1.get(midpoint);\\n        const path2 = minSrc2.get(midpoint);\\n        \\n        if (path1 === undefined || path2 === undefined) continue;\\n        \\n        const sum = path1 + path2 + minDest.get(midpoint);\\n        \\n        if (sum < min) min = sum;\\n    }\\n    \\n    return min;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction minimumWeight(n, edges, src1, src2, dest) {\\n    \\n    const list = [];\\n    const reverseList = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        list[i] = [];\\n        reverseList[i] = [];\\n    }\\n    \\n    for (const [a, b, w] of edges) {\\n        list[a].push([b, w]);\\n        reverseList[b].push([a, w]);\\n    }\\n    \\n    function bfs(node, reverse, sources) {\\n        const minPaths = new Map();\\n        const heap = new MinPriorityQueue();\\n        \\n        heap.enqueue(node, 0);\\n        \\n        while (!heap.isEmpty()) {\\n            const next = heap.dequeue();\\n            const path = minPaths.get(next.element);\\n            \\n            if (path !== undefined) continue;\\n            \\n            minPaths.set(next.element, next.priority);\\n            \\n            const adjacencies = reverse ? reverseList[next.element] : list[next.element];\\n            \\n            for (const [node, weight] of adjacencies) {\\n                if (reverse || sources.has(node)) {\\n                    heap.enqueue(node, next.priority + weight);\\n                }\\n            }\\n        }\\n        \\n        return minPaths;\\n    }\\n    \\n    const minDest = bfs(dest, true);\\n    \\n    if (!minDest.has(src1)) return -1;\\n    if (!minDest.has(src2)) return -1;\\n    \\n    const minSrc1 = bfs(src1, false, minDest);\\n    const minSrc2 = bfs(src2, false, minDest);\\n    \\n    let min = Number.MAX_SAFE_INTEGER;\\n    \\n    for (const [midpoint, pathSum] of minDest) {\\n        const path1 = minSrc1.get(midpoint);\\n        const path2 = minSrc2.get(midpoint);\\n        \\n        if (path1 === undefined || path2 === undefined) continue;\\n        \\n        const sum = path1 + path2 + minDest.get(midpoint);\\n        \\n        if (sum < min) min = sum;\\n    }\\n    \\n    return min;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2585300,
                "title": "python-dijkstra-s-algorithm-implementation",
                "content": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        e, er = defaultdict(list), defaultdict(list)\\n        for a,b,w in edges:\\n            e[a].append([b,w])\\n            er[b].append([a,w])\\n        \\n        \\n        def djiktras(adj,src):\\n            distance, heap, visited = [math.inf]*n, [[0,src]], set()\\n            distance[src] = 0\\n            \\n            while heap:\\n                d,node = heapq.heappop(heap)   \\n                if node in visited: continue\\n                visited.add(node)\\n                for nei,w in adj[node]:\\n                    if nei not in visited:\\n                        if distance[nei] > d + w:\\n                            distance[nei] = d + w\\n                            heapq.heappush(heap,[distance[nei],nei])\\n            return distance\\n        \\n        \\n        d1 = djiktras(e,src1)\\n        d2 = djiktras(e,src2)\\n        dd = djiktras(er,dest)\\n        \\n        ans = math.inf\\n        for i in range(n): ans = min(ans,d1[i] + d2[i] + dd[i])\\n        return -1 if ans >= math.inf else ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        e, er = defaultdict(list), defaultdict(list)\\n        for a,b,w in edges:\\n            e[a].append([b,w])\\n            er[b].append([a,w])\\n        \\n        \\n        def djiktras(adj,src):\\n            distance, heap, visited = [math.inf]*n, [[0,src]], set()\\n            distance[src] = 0\\n            \\n            while heap:\\n                d,node = heapq.heappop(heap)   \\n                if node in visited: continue\\n                visited.add(node)\\n                for nei,w in adj[node]:\\n                    if nei not in visited:\\n                        if distance[nei] > d + w:\\n                            distance[nei] = d + w\\n                            heapq.heappush(heap,[distance[nei],nei])\\n            return distance\\n        \\n        \\n        d1 = djiktras(e,src1)\\n        d2 = djiktras(e,src2)\\n        dd = djiktras(er,dest)\\n        \\n        ans = math.inf\\n        for i in range(n): ans = min(ans,d1[i] + d2[i] + dd[i])\\n        return -1 if ans >= math.inf else ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2552359,
                "title": "three-dijkstra-o-nlog-n-solutions-faster-than-94",
                "content": "```\\n#define pii pair<long long , long long>\\nclass Solution {\\npublic:\\n    const long long inf = LLONG_MAX;\\n    vector<vector<pii>>adjList ;\\n    vector<vector<pii>>adjList1 ;\\n    vector<long long>dijkstra(long long source , long long n){\\n        vector<long long>dis(n , inf);\\n        priority_queue<pair<long long , long long> , vector<pair<long long , long long>> , greater<pair<long long , long long>>>pq;\\n        dis[source] = 0 ;\\n        pq.push({0 , source});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            long long first = curr.first ;\\n            long long second = curr.second ;\\n            if(first > dis[second])\\n                continue;\\n            for(auto it : adjList[second]){\\n                if(dis[second] + it.first < dis[it.second]){\\n                    dis[it.second] = it.first + dis[second];\\n                    pq.push({dis[it.second] , it.second});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n     vector<long long>dijkstra1(long long source , long long n){\\n        vector<long long>dis(n , inf);\\n        priority_queue<pair<long long , long long> , vector<pair<long long , long long>> , greater<pair<long long , long long>>>pq;\\n        dis[source] = 0 ;\\n        pq.push({0 , source});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            long long first = curr.first ;\\n            long long second = curr.second ;\\n            if(first > dis[second])\\n                continue;\\n            for(auto it : adjList1[second]){\\n                if(dis[second] + it.first < dis[it.second]){\\n                    dis[it.second] = it.first + dis[second];\\n                    pq.push({dis[it.second] , it.second});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        adjList = vector<vector<pair<long long  , long long>>>(n);\\n        adjList1 = vector<vector<pair<long long , long long>>>(n);\\n        for(auto it : edges){\\n            adjList[it[0]].push_back({it[2] , it[1]});\\n            adjList1[it[1]].push_back({it[2] , it[0]});\\n        }\\n        vector<long long>dis1 = dijkstra(src1 , n);\\n        vector<long long>dis2 = dijkstra(src2 , n);\\n        vector<long long>dis3 = dijkstra1(dest , n);\\n        if(dis1[dest] == inf || dis2[dest] == inf)\\n            return -1;\\n        long long sum = inf ;\\n        for(int i = 0 ; i < n ; i++){\\n            if(dis1[i] != inf && dis2[i] != inf && dis3[i] != inf){\\n                // cout<<i<<\" \"<<dis1[i]<<\" \"<<dis2[i]<<\" \"<<dis3[i]<<endl;\\n                sum = min(sum , dis1[i] + dis2[i] + dis3[i]);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\nstatic const auto _____ = []()\\n{\\n    // fast IO code : this I understand\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}();\\n```",
                "solutionTags": [],
                "code": "```\\n#define pii pair<long long , long long>\\nclass Solution {\\npublic:\\n    const long long inf = LLONG_MAX;\\n    vector<vector<pii>>adjList ;\\n    vector<vector<pii>>adjList1 ;\\n    vector<long long>dijkstra(long long source , long long n){\\n        vector<long long>dis(n , inf);\\n        priority_queue<pair<long long , long long> , vector<pair<long long , long long>> , greater<pair<long long , long long>>>pq;\\n        dis[source] = 0 ;\\n        pq.push({0 , source});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            long long first = curr.first ;\\n            long long second = curr.second ;\\n            if(first > dis[second])\\n                continue;\\n            for(auto it : adjList[second]){\\n                if(dis[second] + it.first < dis[it.second]){\\n                    dis[it.second] = it.first + dis[second];\\n                    pq.push({dis[it.second] , it.second});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n     vector<long long>dijkstra1(long long source , long long n){\\n        vector<long long>dis(n , inf);\\n        priority_queue<pair<long long , long long> , vector<pair<long long , long long>> , greater<pair<long long , long long>>>pq;\\n        dis[source] = 0 ;\\n        pq.push({0 , source});\\n        while(!pq.empty()){\\n            auto curr = pq.top();\\n            pq.pop();\\n            long long first = curr.first ;\\n            long long second = curr.second ;\\n            if(first > dis[second])\\n                continue;\\n            for(auto it : adjList1[second]){\\n                if(dis[second] + it.first < dis[it.second]){\\n                    dis[it.second] = it.first + dis[second];\\n                    pq.push({dis[it.second] , it.second});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        adjList = vector<vector<pair<long long  , long long>>>(n);\\n        adjList1 = vector<vector<pair<long long , long long>>>(n);\\n        for(auto it : edges){\\n            adjList[it[0]].push_back({it[2] , it[1]});\\n            adjList1[it[1]].push_back({it[2] , it[0]});\\n        }\\n        vector<long long>dis1 = dijkstra(src1 , n);\\n        vector<long long>dis2 = dijkstra(src2 , n);\\n        vector<long long>dis3 = dijkstra1(dest , n);\\n        if(dis1[dest] == inf || dis2[dest] == inf)\\n            return -1;\\n        long long sum = inf ;\\n        for(int i = 0 ; i < n ; i++){\\n            if(dis1[i] != inf && dis2[i] != inf && dis3[i] != inf){\\n                // cout<<i<<\" \"<<dis1[i]<<\" \"<<dis2[i]<<\" \"<<dis3[i]<<endl;\\n                sum = min(sum , dis1[i] + dis2[i] + dis3[i]);\\n            }\\n        }\\n        return sum;\\n    }\\n};\\nstatic const auto _____ = []()\\n{\\n    // fast IO code : this I understand\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2547338,
                "title": "python-go-c-dijkstra-thrice-o-e-vlogv",
                "content": "*Python* in 2284ms beat 93%\\n\\n```python\\ndef minimumWeight(self, n, edges, src1, src2, dest):\\n    def spf(src, g):\\n        q, dist, = [(0, src)], [math.inf] * n\\n        while q:\\n            d, u = heappop(q)\\n            if dist[u] < math.inf: continue\\n            dist[u] = d\\n            for v, w in g[u]: heappush(q, (d + w, v))\\n        return dist\\n\\n    G = [[[] for _ in range(n)] for _ in range(2)]\\n    for u, v, w in edges:\\n        for i, (u, v) in enumerate([(u, v), (v, u)]):\\n            G[i][u].append((v, w))\\n    res = min(map(sum, zip(*itertools.starmap(spf, [(src1, G[0]), (src2, G[0]), (dest, G[1])]))))\\n    return res if res < math.inf else -1\\n```\\n\\n*Go* in 343ms beat 100% :)\\n\\n```go\\ntype gNode struct{ v, w int }\\ntype qNode struct {\\n\\td int64\\n\\tu int\\n}\\n\\ntype queue []*qNode\\n\\nfunc (q queue) Len() int            { return len(q) }\\nfunc (q queue) Less(i, j int) bool  { return q[i].d < q[j].d }\\nfunc (q queue) Swap(i, j int)       { q[i], q[j] = q[j], q[i] }\\nfunc (q *queue) Push(x interface{}) { *q = append(*q, x.(*qNode)) }\\nfunc (q *queue) Pop() interface{} {\\n\\ti := len(*q) - 1\\n\\tx := (*q)[i]\\n\\t*q = (*q)[:i]\\n\\treturn x\\n}\\n\\nfunc spf(src int, g [][]*gNode, dist []int64) {\\n\\tvar q queue\\n\\theap.Push(&q, &qNode{int64(0), src})\\n\\tfor q.Len() > 0 {\\n\\t\\tx := heap.Pop(&q).(*qNode)\\n\\t\\tif dist[x.u] == -1 {\\n\\t\\t\\tdist[x.u] = x.d\\n\\t\\t\\tfor _, y := range g[x.u] {\\n\\t\\t\\t\\theap.Push(&q, &qNode{x.d + int64(y.w), y.v})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc minimumWeight(n int, edges [][]int, src1 int, src2 int, dest int) int64 {\\n\\tvar (\\n\\t\\tres = int64(-1)\\n\\t\\tG   [2][][]*gNode\\n\\t\\tD   [3][]int64\\n\\t)\\n\\tfor i := range G {\\n\\t\\tG[i] = make([][]*gNode, n)\\n\\t}\\n\\tfor _, e := range edges {\\n\\t\\tu, v, w := e[0], e[1], e[2]\\n\\t\\tfor i, x := range [2][2]int{[2]int{u, v}, [2]int{v, u}} {\\n\\t\\t\\tu, v = x[0], x[1]\\n\\t\\t\\tG[i][u] = append(G[i][u], &gNode{v, w})\\n\\t\\t}\\n\\t}\\n\\tfor i := range D {\\n\\t\\tD[i] = make([]int64, n)\\n\\t\\tfor j := range D[i] {\\n\\t\\t\\tD[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\tspf(src1, G[0], D[0])\\n\\tspf(src2, G[0], D[1])\\n\\tspf(dest, G[1], D[2])\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif D[0][i] != -1 && D[1][i] != -1 && D[2][i] != -1 {\\n\\t\\t\\tif x := D[0][i] + D[1][i] + D[2][i]; res == -1 || x < res {\\n\\t\\t\\t\\tres = x\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```\\n\\n*C++* in 698ms\\n\\n```c++\\ntypedef long long ll;\\ntypedef pair<ll, int> li;\\ntypedef pair<int, int> ii;\\n\\nvoid spf(int src, vector<vector<ii>> &g, vector<ll> &dist) {\\n    priority_queue<li, vector<li>, greater<li>> q; q.push({0, src});\\n    while (!q.empty()) {\\n        auto[d, u] = q.top(); q.pop();\\n        if (dist[u] != -1) continue;\\n        dist[u] = d;\\n        for (auto[v, w] : g[u]) q.push({d + w, v});\\n    }\\n}\\n\\nlong long minimumWeight(int n, vector<vector<int>> &edges, int src1, int src2, int dest) {\\n    ll res = -1;\\n    vector<vector<ii>> G0(n), G1(n); for (auto e : edges) G0[e[0]].push_back({e[1], e[2]}), G1[e[1]].push_back({e[0], e[2]});\\n    vector<ll> D0(n, -1), D1(n, -1), D2(n, -1);\\n    spf(src1, G0, D0); spf(src2, G0, D1); spf(dest, G1, D2);\\n    for (int i = 0; i < n; ++i) if (D0[i] != -1 && D1[i] != -1 && D2[i] != -1) if (ll x = D0[i] + D1[i] + D2[i]; res == -1 || x < res) res = x;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minimumWeight(self, n, edges, src1, src2, dest):\\n    def spf(src, g):\\n        q, dist, = [(0, src)], [math.inf] * n\\n        while q:\\n            d, u = heappop(q)\\n            if dist[u] < math.inf: continue\\n            dist[u] = d\\n            for v, w in g[u]: heappush(q, (d + w, v))\\n        return dist\\n\\n    G = [[[] for _ in range(n)] for _ in range(2)]\\n    for u, v, w in edges:\\n        for i, (u, v) in enumerate([(u, v), (v, u)]):\\n            G[i][u].append((v, w))\\n    res = min(map(sum, zip(*itertools.starmap(spf, [(src1, G[0]), (src2, G[0]), (dest, G[1])]))))\\n    return res if res < math.inf else -1\\n```\n```go\\ntype gNode struct{ v, w int }\\ntype qNode struct {\\n\\td int64\\n\\tu int\\n}\\n\\ntype queue []*qNode\\n\\nfunc (q queue) Len() int            { return len(q) }\\nfunc (q queue) Less(i, j int) bool  { return q[i].d < q[j].d }\\nfunc (q queue) Swap(i, j int)       { q[i], q[j] = q[j], q[i] }\\nfunc (q *queue) Push(x interface{}) { *q = append(*q, x.(*qNode)) }\\nfunc (q *queue) Pop() interface{} {\\n\\ti := len(*q) - 1\\n\\tx := (*q)[i]\\n\\t*q = (*q)[:i]\\n\\treturn x\\n}\\n\\nfunc spf(src int, g [][]*gNode, dist []int64) {\\n\\tvar q queue\\n\\theap.Push(&q, &qNode{int64(0), src})\\n\\tfor q.Len() > 0 {\\n\\t\\tx := heap.Pop(&q).(*qNode)\\n\\t\\tif dist[x.u] == -1 {\\n\\t\\t\\tdist[x.u] = x.d\\n\\t\\t\\tfor _, y := range g[x.u] {\\n\\t\\t\\t\\theap.Push(&q, &qNode{x.d + int64(y.w), y.v})\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc minimumWeight(n int, edges [][]int, src1 int, src2 int, dest int) int64 {\\n\\tvar (\\n\\t\\tres = int64(-1)\\n\\t\\tG   [2][][]*gNode\\n\\t\\tD   [3][]int64\\n\\t)\\n\\tfor i := range G {\\n\\t\\tG[i] = make([][]*gNode, n)\\n\\t}\\n\\tfor _, e := range edges {\\n\\t\\tu, v, w := e[0], e[1], e[2]\\n\\t\\tfor i, x := range [2][2]int{[2]int{u, v}, [2]int{v, u}} {\\n\\t\\t\\tu, v = x[0], x[1]\\n\\t\\t\\tG[i][u] = append(G[i][u], &gNode{v, w})\\n\\t\\t}\\n\\t}\\n\\tfor i := range D {\\n\\t\\tD[i] = make([]int64, n)\\n\\t\\tfor j := range D[i] {\\n\\t\\t\\tD[i][j] = -1\\n\\t\\t}\\n\\t}\\n\\tspf(src1, G[0], D[0])\\n\\tspf(src2, G[0], D[1])\\n\\tspf(dest, G[1], D[2])\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tif D[0][i] != -1 && D[1][i] != -1 && D[2][i] != -1 {\\n\\t\\t\\tif x := D[0][i] + D[1][i] + D[2][i]; res == -1 || x < res {\\n\\t\\t\\t\\tres = x\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```\n```c++\\ntypedef long long ll;\\ntypedef pair<ll, int> li;\\ntypedef pair<int, int> ii;\\n\\nvoid spf(int src, vector<vector<ii>> &g, vector<ll> &dist) {\\n    priority_queue<li, vector<li>, greater<li>> q; q.push({0, src});\\n    while (!q.empty()) {\\n        auto[d, u] = q.top(); q.pop();\\n        if (dist[u] != -1) continue;\\n        dist[u] = d;\\n        for (auto[v, w] : g[u]) q.push({d + w, v});\\n    }\\n}\\n\\nlong long minimumWeight(int n, vector<vector<int>> &edges, int src1, int src2, int dest) {\\n    ll res = -1;\\n    vector<vector<ii>> G0(n), G1(n); for (auto e : edges) G0[e[0]].push_back({e[1], e[2]}), G1[e[1]].push_back({e[0], e[2]});\\n    vector<ll> D0(n, -1), D1(n, -1), D2(n, -1);\\n    spf(src1, G0, D0); spf(src2, G0, D1); spf(dest, G1, D2);\\n    for (int i = 0; i < n; ++i) if (D0[i] != -1 && D1[i] != -1 && D2[i] != -1) if (ll x = D0[i] + D1[i] + D2[i]; res == -1 || x < res) res = x;\\n    return res;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2523870,
                "title": "pyhton-dijkastra-optimization-comments",
                "content": "I got **TLE** on normal dijkastra, tried to get some small optimization online and got 1 in the link mentioned in the comments. \\n\\nPlease **upvote** if this helped you.\\n\\n```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g = [[] for _ in range(n)]\\n        revg = [[] for _ in range(n)]\\n        for i,j,k in edges:\\n            g[i].append([j,k])\\n            revg[j].append([i,k])\\n        def dijkastra(g,src):\\n            dist = [float(\"inf\") for _ in range(n)]\\n            dist[src] = 0\\n            heap = [(0,src)]\\n            while heap:\\n                d,curr = heapq.heappop(heap)\\n                #you can find the explation to optimization here\\n                #https://scholar.google.co.in/scholar?q=optimization+of+dijkstra&hl=en&as_sdt=0&as_vis=1&oi=scholart\\n                if (dist[curr] < d):\\n                    continue\\n                for nei in g[curr]:\\n                    if dist[curr]+nei[1] < dist[nei[0]]:\\n                        dist[nei[0]] = d+nei[1]\\n                        heapq.heappush(heap,(d+nei[1],nei[0]))\\n            return dist\\n        one = dijkastra(g,src1)\\n        two = dijkastra(g,src2)\\n        three = dijkastra(revg,dest)\\n        ans = float(\"inf\")\\n        for i in range(n):\\n            ans = min(ans,one[i]+two[i]+three[i])\\n        if ans == float(\"inf\"):\\n            return -1\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "I got **TLE** on normal dijkastra, tried to get some small optimization online and got 1 in the link mentioned in the comments. \\n\\nPlease **upvote** if this helped you.\\n\\n```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g = [[] for _ in range(n)]\\n        revg = [[] for _ in range(n)]\\n        for i,j,k in edges:\\n            g[i].append([j,k])\\n            revg[j].append([i,k])\\n        def dijkastra(g,src):\\n            dist = [float(\"inf\") for _ in range(n)]\\n            dist[src] = 0\\n            heap = [(0,src)]\\n            while heap:\\n                d,curr = heapq.heappop(heap)\\n                #you can find the explation to optimization here\\n                #https://scholar.google.co.in/scholar?q=optimization+of+dijkstra&hl=en&as_sdt=0&as_vis=1&oi=scholart\\n                if (dist[curr] < d):\\n                    continue\\n                for nei in g[curr]:\\n                    if dist[curr]+nei[1] < dist[nei[0]]:\\n                        dist[nei[0]] = d+nei[1]\\n                        heapq.heappush(heap,(d+nei[1],nei[0]))\\n            return dist\\n        one = dijkastra(g,src1)\\n        two = dijkastra(g,src2)\\n        three = dijkastra(revg,dest)\\n        ans = float(\"inf\")\\n        for i in range(n):\\n            ans = min(ans,one[i]+two[i]+three[i])\\n        if ans == float(\"inf\"):\\n            return -1\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2469207,
                "title": "cpp-three-dijkstra-80-i-upvote-if-you-liked-the-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<long long> Cal(vector<vector<vector<int>>>& Graph, int start, int N){\\n        vector<long long> Dis(N, LLONG_MAX);\\n        \\n        priority_queue < vector<long long>, vector<vector<long long>>, greater<vector<long long>> > Q;\\n        \\n        Q.push({0,start});\\n        Dis[start] = 0;\\n        \\n        while(!Q.empty()){\\n            vector<long long> Vec = Q.top();\\n            Q.pop();\\n            \\n            long long d = Vec[0];\\n            int node = Vec[1];\\n            \\n            if(d > Dis[node]) continue;\\n            \\n            for(int i=0;i<Graph[node].size();i++){\\n                int next = Graph[node][i][0];\\n                long long w = Graph[node][i][1];\\n                \\n                if(d+w < Dis[next]){\\n                    Dis[next] = d+w;\\n                    Q.push({Dis[next],next});\\n                }\\n            }\\n        }\\n        \\n        return Dis;\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<vector<int>>> Graph(n);\\n        vector<vector<vector<int>>> RevGraph(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            int w = edges[i][2];\\n            \\n            Graph[u].push_back({v,w});\\n            RevGraph[v].push_back({u,w});\\n        }\\n        \\n        vector<long long> Dis1 = Cal(Graph, src1, n);\\n        vector<long long> Dis2 = Cal(Graph, src2, n);\\n        vector<long long> Dis3 = Cal(RevGraph, dest, n);\\n        \\n        long long Ans = LLONG_MAX;\\n        for(int i=0;i<n;i++){\\n            if(Dis1[i]!=LLONG_MAX && Dis2[i]!=LLONG_MAX && Dis3[i]!=LLONG_MAX){\\n                Ans = min(Ans, Dis1[i]+Dis2[i]+Dis3[i]);\\n            }\\n        }\\n        \\n        if(Ans == LLONG_MAX) return -1;\\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<long long> Cal(vector<vector<vector<int>>>& Graph, int start, int N){\\n        vector<long long> Dis(N, LLONG_MAX);\\n        \\n        priority_queue < vector<long long>, vector<vector<long long>>, greater<vector<long long>> > Q;\\n        \\n        Q.push({0,start});\\n        Dis[start] = 0;\\n        \\n        while(!Q.empty()){\\n            vector<long long> Vec = Q.top();\\n            Q.pop();\\n            \\n            long long d = Vec[0];\\n            int node = Vec[1];\\n            \\n            if(d > Dis[node]) continue;\\n            \\n            for(int i=0;i<Graph[node].size();i++){\\n                int next = Graph[node][i][0];\\n                long long w = Graph[node][i][1];\\n                \\n                if(d+w < Dis[next]){\\n                    Dis[next] = d+w;\\n                    Q.push({Dis[next],next});\\n                }\\n            }\\n        }\\n        \\n        return Dis;\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<vector<int>>> Graph(n);\\n        vector<vector<vector<int>>> RevGraph(n);\\n        \\n        for(int i=0;i<edges.size();i++){\\n            int u = edges[i][0];\\n            int v = edges[i][1];\\n            int w = edges[i][2];\\n            \\n            Graph[u].push_back({v,w});\\n            RevGraph[v].push_back({u,w});\\n        }\\n        \\n        vector<long long> Dis1 = Cal(Graph, src1, n);\\n        vector<long long> Dis2 = Cal(Graph, src2, n);\\n        vector<long long> Dis3 = Cal(RevGraph, dest, n);\\n        \\n        long long Ans = LLONG_MAX;\\n        for(int i=0;i<n;i++){\\n            if(Dis1[i]!=LLONG_MAX && Dis2[i]!=LLONG_MAX && Dis3[i]!=LLONG_MAX){\\n                Ans = min(Ans, Dis1[i]+Dis2[i]+Dis3[i]);\\n            }\\n        }\\n        \\n        if(Ans == LLONG_MAX) return -1;\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429693,
                "title": "c-3-dijkstra",
                "content": "```\\ntypedef pair<long long, int> p;\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        \\n        // Create Adjacency List\\n        vector<vector<pair<int, long long>>>adj(n),rev(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            rev[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        \\n        vector<long long >dis_src1=dk(adj,src1);\\n        vector<long long >dis_src2=dk(adj,src2);\\n        vector<long long >dis_dest=dk(rev,dest);\\n        \\n        long long ans=1e18;\\n        for(int i=0;i<n;i++)\\n            ans=min(ans, dis_src1[i]+dis_src2[i]+dis_dest[i]);\\n        return ans==1e18?-1:ans;\\n    }\\n    \\n    vector<long long> dk(vector<vector<pair<int,long long>>>adj, int src){\\n        vector<long long>dis(adj.size(),1e18);\\n        \\n        // Create a Min Heap sorted on distance\\n        priority_queue<p, vector<p> ,greater<p> >pq;\\n        dis[src]=0;\\n        pq.push({0,src});\\n        \\n        while(!pq.empty()){\\n            p tmp=pq.top();\\n            pq.pop();\\n            int u=tmp.second;\\n            \\n            // To remove redundant path which are not optimal\\n            if (tmp.first != dis[u]) continue;\\n            \\n            for(int i=0;i<adj[u].size();i++){\\n                int v=adj[u][i].first;\\n                long long w=adj[u][i].second;\\n                if(dis[v] > (dis[u]+w)){\\n                    dis[v]=dis[u]+w;\\n                    pq.push({dis[v],v});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef pair<long long, int> p;\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        \\n        // Create Adjacency List\\n        vector<vector<pair<int, long long>>>adj(n),rev(n);\\n        for(int i=0;i<edges.size();i++){\\n            adj[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            rev[edges[i][1]].push_back({edges[i][0],edges[i][2]});\\n        }\\n        \\n        vector<long long >dis_src1=dk(adj,src1);\\n        vector<long long >dis_src2=dk(adj,src2);\\n        vector<long long >dis_dest=dk(rev,dest);\\n        \\n        long long ans=1e18;\\n        for(int i=0;i<n;i++)\\n            ans=min(ans, dis_src1[i]+dis_src2[i]+dis_dest[i]);\\n        return ans==1e18?-1:ans;\\n    }\\n    \\n    vector<long long> dk(vector<vector<pair<int,long long>>>adj, int src){\\n        vector<long long>dis(adj.size(),1e18);\\n        \\n        // Create a Min Heap sorted on distance\\n        priority_queue<p, vector<p> ,greater<p> >pq;\\n        dis[src]=0;\\n        pq.push({0,src});\\n        \\n        while(!pq.empty()){\\n            p tmp=pq.top();\\n            pq.pop();\\n            int u=tmp.second;\\n            \\n            // To remove redundant path which are not optimal\\n            if (tmp.first != dis[u]) continue;\\n            \\n            for(int i=0;i<adj[u].size();i++){\\n                int v=adj[u][i].first;\\n                long long w=adj[u][i].second;\\n                if(dis[v] > (dis[u]+w)){\\n                    dis[v]=dis[u]+w;\\n                    pq.push({dis[v],v});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2350975,
                "title": "c-dijsktra",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<pair<int,int>>adj[100005];\\n    vector<pair<int,int>>adj_r[100005];\\n    const long long INF=1e18;\\n    void dijkstra(int n,int s, vector<long long>&d,bool rev=false) {\\n        d.assign(n, INF);\\n        d[s] = 0;\\n        set<pair<int, int>> q;\\n        q.insert({0, s});\\n        while (!q.empty()) {\\n            int v = q.begin()->second;\\n            q.erase(q.begin());\\n            if(rev){\\n                for (auto edge : adj_r[v]) {\\n                    int to = edge.first;\\n                    int len = edge.second;\\n                    if (d[v] + len < d[to]) {\\n                        q.erase({d[to], to});\\n                        d[to] = d[v] + len;\\n                        q.insert({d[to], to});\\n                    }\\n                }\\n            }\\n            else{\\n                for (auto edge : adj[v]) {\\n                    int to = edge.first;\\n                    int len = edge.second;\\n                    if (d[v] + len < d[to]) {\\n                        q.erase({d[to], to});\\n                        d[to] = d[v] + len;\\n                        q.insert({d[to], to});\\n                    }\\n                }\\n            }\\n            \\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        for(auto x:edges){\\n            adj[x[0]].push_back({x[1],x[2]});\\n            adj_r[x[1]].push_back({x[0],x[2]});\\n        }\\n        vector<long long>d_src1,d_src2,d_dest;\\n        dijkstra(n,src1,d_src1);\\n        dijkstra(n,src2,d_src2);\\n        dijkstra(n,dest,d_dest,true);\\n        long long minn=1e18;\\n        for(int i=0;i<n;i++) minn=min(minn,d_src1[i]+d_src2[i]+d_dest[i]);\\n        if(minn==1e18) return -1;\\n        return minn;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<pair<int,int>>adj[100005];\\n    vector<pair<int,int>>adj_r[100005];\\n    const long long INF=1e18;\\n    void dijkstra(int n,int s, vector<long long>&d,bool rev=false) {\\n        d.assign(n, INF);\\n        d[s] = 0;\\n        set<pair<int, int>> q;\\n        q.insert({0, s}",
                "codeTag": "Java"
            },
            {
                "id": 2339432,
                "title": "c-three-dijkstra-explained",
                "content": "Tips:\\nIf we can find paths that can visit from src1 and src2 both to dest, there must exist those common nodes that:\\n\\n1. We can visit this node both from src1 and src2;\\n2. We can visit from this node to dest.(equal to visit from dest to this node, we use reversed graph in solution to save time)\\n3. The total path = src1->node + src2->node + node->dest. Specially, this node can be src1, src2, dest, then part 1/2/3 will be 0.\\n4. There may exist more than one common node, we need find the shorest path by checking all valid common nodes.\\n\\n```\\n        public long MinimumWeight(int n, int[][] edges, int src1, int src2, int dest)\\n        {\\n            List<int[]>[] graph = new List<int[]>[n];\\n            List<int[]>[] graphRev = new List<int[]>[n];\\n            for (int i = 0; i < n; i++)\\n            {\\n                graph[i] = new List<int[]>();\\n                graphRev[i] = new List<int[]>();//reverse graph will be used to find path from dest to other nodes\\n            }\\n            foreach (var e in edges)\\n            {\\n                graph[e[0]].Add(new int[] { e[1], e[2] });\\n                graphRev[e[1]].Add(new int[] { e[0], e[2] });\\n            }\\n            var srcArr1 = getDijkstraCostArray(graph, src1);\\n            if (srcArr1[dest] == long.MaxValue) return -1;//no possible from src1 to dest\\n            var srcArr2 = getDijkstraCostArray(graph, src2);\\n            if (srcArr2[dest] == long.MaxValue) return -1;//no possible from src2 to dest\\n            long res = long.MaxValue;\\n            var destArr = getDijkstraCostArray(graphRev, dest);\\n            for(int i = 0; i < n; i++)\\n            {\\n                if (destArr[i] == long.MaxValue || srcArr1[i] == long.MaxValue || srcArr2[i] == long.MaxValue) continue;\\n                //try every valid node as common node, total path = src1->node + src2->node + dest->node(reversed)\\n                res = Math.Min(res, destArr[i] + srcArr1[i] + srcArr2[i]);\\n            }\\n            return res;\\n        }\\n        private long[] getDijkstraCostArray(List<int[]>[] graph, int src = 0)\\n        {\\n            int n = graph.Length;\\n            long[] distance = new long[n];\\n            Array.Fill(distance, long.MaxValue);\\n            distance[src] = 0;\\n            PriorityQueue<long[], long> pq = new PriorityQueue<long[], long>();\\n            //{index, cost} sort by cost-asc, visit shortest path first, it helps to skips longer paths later\\n            pq.Enqueue(new long[] { src, 0 }, 0);\\n            while (pq.Count > 0)\\n            {\\n                long[] top = pq.Dequeue();\\n                long u = top[0];\\n                long cost = top[1];\\n                if (cost > distance[u]) continue;//not shortest, skip it\\n                foreach (var v in graph[u])\\n                {\\n                    if (distance[v[0]] > cost + v[1])\\n                    {\\n                        distance[v[0]] = cost + v[1];//shorter path found, re-visit again\\n                        pq.Enqueue(new long[] { v[0], distance[v[0]] }, distance[v[0]]);\\n                    }\\n                }\\n            }\\n            return distance;\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\n        public long MinimumWeight(int n, int[][] edges, int src1, int src2, int dest)\\n        {\\n            List<int[]>[] graph = new List<int[]>[n];\\n            List<int[]>[] graphRev = new List<int[]>[n];\\n            for (int i = 0; i < n; i++)\\n            {\\n                graph[i] = new List<int[]>();\\n                graphRev[i] = new List<int[]>();//reverse graph will be used to find path from dest to other nodes\\n            }\\n            foreach (var e in edges)\\n            {\\n                graph[e[0]].Add(new int[] { e[1], e[2] });\\n                graphRev[e[1]].Add(new int[] { e[0], e[2] });\\n            }\\n            var srcArr1 = getDijkstraCostArray(graph, src1);\\n            if (srcArr1[dest] == long.MaxValue) return -1;//no possible from src1 to dest\\n            var srcArr2 = getDijkstraCostArray(graph, src2);\\n            if (srcArr2[dest] == long.MaxValue) return -1;//no possible from src2 to dest\\n            long res = long.MaxValue;\\n            var destArr = getDijkstraCostArray(graphRev, dest);\\n            for(int i = 0; i < n; i++)\\n            {\\n                if (destArr[i] == long.MaxValue || srcArr1[i] == long.MaxValue || srcArr2[i] == long.MaxValue) continue;\\n                //try every valid node as common node, total path = src1->node + src2->node + dest->node(reversed)\\n                res = Math.Min(res, destArr[i] + srcArr1[i] + srcArr2[i]);\\n            }\\n            return res;\\n        }\\n        private long[] getDijkstraCostArray(List<int[]>[] graph, int src = 0)\\n        {\\n            int n = graph.Length;\\n            long[] distance = new long[n];\\n            Array.Fill(distance, long.MaxValue);\\n            distance[src] = 0;\\n            PriorityQueue<long[], long> pq = new PriorityQueue<long[], long>();\\n            //{index, cost} sort by cost-asc, visit shortest path first, it helps to skips longer paths later\\n            pq.Enqueue(new long[] { src, 0 }, 0);\\n            while (pq.Count > 0)\\n            {\\n                long[] top = pq.Dequeue();\\n                long u = top[0];\\n                long cost = top[1];\\n                if (cost > distance[u]) continue;//not shortest, skip it\\n                foreach (var v in graph[u])\\n                {\\n                    if (distance[v[0]] > cost + v[1])\\n                    {\\n                        distance[v[0]] = cost + v[1];//shorter path found, re-visit again\\n                        pq.Enqueue(new long[] { v[0], distance[v[0]] }, distance[v[0]]);\\n                    }\\n                }\\n            }\\n            return distance;\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2289280,
                "title": "simple-easy-short-c-solution",
                "content": "# Dijkstra thrice :)\\n1. From src1.\\n2. From src2.\\n3. From dest on the reversed graph.\\nFind the coinciding intermediate node.\\n```\\nfor(int intermediateNode = 0; intermediateNode<n; intermediateNode++)\\n    ans = min(ans, dist1[intermediateNode] + dist2[intermediateNode] + dist3[intermediateNode]);\\n```\\n**Full Implementation:**\\n```\\nclass Solution {\\npublic:\\n    vector<long long> dijkstra(int src, vector<pair<int, int>> *adj, int n){\\n        vector<long long> dist(n, 1e18);\\n        set<pair<long long, int>> pq;\\n        pq.insert({0, src});\\n        dist[src] = 0;\\n        while(!pq.empty()){\\n            auto [distSoFar, curNode] = *pq.begin();\\n            pq.erase(pq.begin());\\n            if(dist[curNode] < distSoFar)continue;\\n            for(auto [wt, nb] : adj[curNode])\\n                if(distSoFar + wt <= dist[nb]){\\n                    pq.insert({distSoFar + wt, nb});\\n                    dist[nb] = distSoFar + wt;\\n                }\\n        }\\n        return dist;\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        const long long inf = 1e18;\\n        vector<pair<int, int>> adj[n], adjRev[n];\\n        for(vector<int> edge : edges){\\n            adj[edge[0]].push_back({edge[2], edge[1]});\\n            adjRev[edge[1]].push_back({edge[2], edge[0]});\\n        }\\n        vector<long long> dist1 = dijkstra(src1, adj, n),\\n                          dist2 = dijkstra(src2, adj, n),\\n                          dist3 = dijkstra(dest, adjRev, n);\\n        long long ans = inf;\\n        for(int intermediateNode = 0; intermediateNode<n; intermediateNode++)\\n            if(dist1[intermediateNode] != inf && dist2[intermediateNode] != inf && dist3[intermediateNode] != inf)\\n                ans = min(ans, dist1[intermediateNode] + dist2[intermediateNode] + dist3[intermediateNode]);\\n        return (ans == inf ? -1 : ans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nfor(int intermediateNode = 0; intermediateNode<n; intermediateNode++)\\n    ans = min(ans, dist1[intermediateNode] + dist2[intermediateNode] + dist3[intermediateNode]);\\n```\n```\\nclass Solution {\\npublic:\\n    vector<long long> dijkstra(int src, vector<pair<int, int>> *adj, int n){\\n        vector<long long> dist(n, 1e18);\\n        set<pair<long long, int>> pq;\\n        pq.insert({0, src});\\n        dist[src] = 0;\\n        while(!pq.empty()){\\n            auto [distSoFar, curNode] = *pq.begin();\\n            pq.erase(pq.begin());\\n            if(dist[curNode] < distSoFar)continue;\\n            for(auto [wt, nb] : adj[curNode])\\n                if(distSoFar + wt <= dist[nb]){\\n                    pq.insert({distSoFar + wt, nb});\\n                    dist[nb] = distSoFar + wt;\\n                }\\n        }\\n        return dist;\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        const long long inf = 1e18;\\n        vector<pair<int, int>> adj[n], adjRev[n];\\n        for(vector<int> edge : edges){\\n            adj[edge[0]].push_back({edge[2], edge[1]});\\n            adjRev[edge[1]].push_back({edge[2], edge[0]});\\n        }\\n        vector<long long> dist1 = dijkstra(src1, adj, n),\\n                          dist2 = dijkstra(src2, adj, n),\\n                          dist3 = dijkstra(dest, adjRev, n);\\n        long long ans = inf;\\n        for(int intermediateNode = 0; intermediateNode<n; intermediateNode++)\\n            if(dist1[intermediateNode] != inf && dist2[intermediateNode] != inf && dist3[intermediateNode] != inf)\\n                ans = min(ans, dist1[intermediateNode] + dist2[intermediateNode] + dist3[intermediateNode]);\\n        return (ans == inf ? -1 : ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268129,
                "title": "dijkstra-implementation",
                "content": "class Solution {\\n    class Pair{\\n        int v;\\n        long weight;\\n        Pair(int v, long weight){\\n            this.v = v;\\n            this.weight = weight;\\n        }\\n    }\\n    long MAX = (long)1e15;\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest){ \\n        ArrayList<ArrayList<Pair>> adj, revAdj;\\n        adj = new ArrayList<>();\\n        revAdj = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++){\\n            adj.add(new ArrayList<>());\\n            revAdj.add(new ArrayList<>());\\n        }\\n        for(int[] e: edges){\\n            adj.get(e[0]).add(new Pair(e[1], e[2]));\\n            revAdj.get(e[1]).add(new Pair(e[0], e[2]));\\n        }\\n        long[] d1 = bfs(adj, n, src1);//src1 to all nodes\\n        long[] d2 = bfs(adj, n, src2);//src2 to all nodes\\n        long[] d3 = bfs(revAdj, n, dest);//dest to all nodes\\n        \\n        //Find 1 common point\\n        long res = Long.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            res = Math.min(res, d1[i] + d2[i] + d3[i]);\\n        }\\n        return res >= MAX ? -1 : res;\\n    }\\n    public long[] bfs(ArrayList<ArrayList<Pair>> adj, int n, int s){\\n        long[] dist = new long[n];\\n        Arrays.fill(dist, MAX);\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((x1, x2) -> (int)(x1.weight-x2.weight));\\n        pq.add(new Pair(s, 0));\\n        dist[s] = 0;\\n        \\n        while(!pq.isEmpty()){\\n            Pair p = pq.poll();\\n            int u = p.v;\\n            long w = p.weight;\\n            if(w > dist[u])\\n                continue;\\n            \\n            for(Pair p1: adj.get(u)){\\n                int v = p1.v;\\n                long weight = p1.weight;\\n                if(dist[v] > dist[u] + weight)\\n                {\\n                    dist[v] = dist[u] + weight;\\n                    pq.add(new Pair(v, dist[v]));\\n                }   \\n            }\\n        }\\n        return dist;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    class Pair{\\n        int v;\\n        long weight;\\n        Pair(int v, long weight){\\n            this.v = v;\\n            this.weight = weight;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2228735,
                "title": "dijkstra-easy-implementation-c",
                "content": "```\\nconst int N = 1e5+4;\\n\\nclass Solution {\\npublic:\\n    \\n    vector<long long> dijkstra(int src, vector<pair<int,int>> graph[], int n)\\n    {\\n        vector<long long> dis1(n+1, 1e18);\\n        \\n        dis1[src] = 0;\\n        set<pair<long long,int>> s;\\n        \\n        s.insert({0, src});\\n        while(!s.empty())\\n        {\\n            auto [d, node] = *s.begin();\\n            s.erase(s.begin());\\n            \\n            for(auto [to, wt] : graph[node])\\n            {\\n                if(dis1[to] > dis1[node] + wt)\\n                {\\n                    s.erase({dis1[to], to});\\n                    dis1[to] = dis1[node] + wt;\\n                    s.insert({dis1[to], to});\\n                }\\n            }\\n        }\\n        return dis1;\\n    }\\n    \\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        int m = edges.size();\\n        vector<pair<int,int>> graph[n+1], graph1[n+1];\\n        for(int i = 0; i<m; i++)\\n        {\\n            int a = edges[i][0], b = edges[i][1];\\n            int wt = edges[i][2];\\n            graph[a].push_back({b, wt});\\n            \\n            a = edges[i][0], b = edges[i][1];\\n            wt = edges[i][2];\\n            graph1[b].push_back({a, wt});\\n        }\\n        \\n        auto dis1 = dijkstra(src1, graph, n);\\n        auto dis2 = dijkstra(src2, graph, n);\\n        auto dis3 = dijkstra(dest, graph1, n);\\n        \\n        \\n        if(dis1[dest] == 1e18 || dis2[dest] == 1e18)\\n            return -1;\\n        \\n        long long ans = 1e18;\\n        \\n        \\n        // checking for each node and taking it as point of intersection.\\n        for(int i = 0; i<n; i++)\\n        {\\n            ans = min(ans, dis1[i] + dis2[i] + dis3[i]);\\n        }\\n\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nconst int N = 1e5+4;\\n\\nclass Solution {\\npublic:\\n    \\n    vector<long long> dijkstra(int src, vector<pair<int,int>> graph[], int n)\\n    {\\n        vector<long long> dis1(n+1, 1e18);\\n        \\n        dis1[src] = 0;\\n        set<pair<long long,int>> s;\\n        \\n        s.insert({0, src});\\n        while(!s.empty())\\n        {\\n            auto [d, node] = *s.begin();\\n            s.erase(s.begin());\\n            \\n            for(auto [to, wt] : graph[node])\\n            {\\n                if(dis1[to] > dis1[node] + wt)\\n                {\\n                    s.erase({dis1[to], to});\\n                    dis1[to] = dis1[node] + wt;\\n                    s.insert({dis1[to], to});\\n                }\\n            }\\n        }\\n        return dis1;\\n    }\\n    \\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        int m = edges.size();\\n        vector<pair<int,int>> graph[n+1], graph1[n+1];\\n        for(int i = 0; i<m; i++)\\n        {\\n            int a = edges[i][0], b = edges[i][1];\\n            int wt = edges[i][2];\\n            graph[a].push_back({b, wt});\\n            \\n            a = edges[i][0], b = edges[i][1];\\n            wt = edges[i][2];\\n            graph1[b].push_back({a, wt});\\n        }\\n        \\n        auto dis1 = dijkstra(src1, graph, n);\\n        auto dis2 = dijkstra(src2, graph, n);\\n        auto dis3 = dijkstra(dest, graph1, n);\\n        \\n        \\n        if(dis1[dest] == 1e18 || dis2[dest] == 1e18)\\n            return -1;\\n        \\n        long long ans = 1e18;\\n        \\n        \\n        // checking for each node and taking it as point of intersection.\\n        for(int i = 0; i<n; i++)\\n        {\\n            ans = min(ans, dis1[i] + dis2[i] + dis3[i]);\\n        }\\n\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2223422,
                "title": "concise-solution-with-only-one-dijkstra",
                "content": "*Bief explanation:* : let `d[u,msk]` represent the shortest distance to get to node `u` where there a path from nodes in `msk` to reach u, from here just run a normal dijkstra, if we can reach `u` from the other source than update the shortest distance to get to `u` by using both source by the sum of their correspond distance.\\n\\n```python\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        from heapq import heappush as push, heappop as pop \\n        \\n        def getMask(u):\\n            return (u==src1) + (u==src2) * 2\\n        \\n        d = {}\\n        q = [(0,src1,1), (0,src2,2)]\\n        g = [[] for _ in range(n)] \\n        for u,*e in edges:\\n            g[u].append(e)\\n        \\n        while q:\\n            x,u,msk = pop(q)\\n            if (u,msk) not in d:\\n                if (u, 3 ^ msk) in d :\\n                    push(q, (x + d[u, 3 ^ msk], u, 3))\\n                d[u,msk] = x\\n                for v, w in g[u]:\\n                    m = msk | getMask(v)\\n                    if (v,m) not in d:\\n                        push(q, (x+w, v, m))\\n                   \\n        return d.get((dest, 3),-1)\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        from heapq import heappush as push, heappop as pop \\n        \\n        def getMask(u):\\n            return (u==src1) + (u==src2) * 2\\n        \\n        d = {}\\n        q = [(0,src1,1), (0,src2,2)]\\n        g = [[] for _ in range(n)] \\n        for u,*e in edges:\\n            g[u].append(e)\\n        \\n        while q:\\n            x,u,msk = pop(q)\\n            if (u,msk) not in d:\\n                if (u, 3 ^ msk) in d :\\n                    push(q, (x + d[u, 3 ^ msk], u, 3))\\n                d[u,msk] = x\\n                for v, w in g[u]:\\n                    m = msk | getMask(v)\\n                    if (v,m) not in d:\\n                        push(q, (x+w, v, m))\\n                   \\n        return d.get((dest, 3),-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2214911,
                "title": "getting-tle-use-optimized-dijkstras",
                "content": "\\n  if (cost > dist1[node]) continue;    //optimized diskhtra\\n \\n",
                "solutionTags": [],
                "code": "\\n  if (cost > dist1[node]) continue;    //optimized diskhtra\\n \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2206306,
                "title": "c-dynamic-programming",
                "content": "First we reverse the graph then we do dp from each node starting from the dest with dfs, we check if src1 and src2 is reachable, if it is then update the return value to contain the lowest cost of reaching them.\\n\\nIf both of them are reachable from the current node update an external variable cost to contain the minimum cost of travelling to both of them\\ni.e cost returned by dfs for left + cost returned by dfs for right - cost at current point in dfs\\n\\n\\n```c++\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<vector<vector<int>>> G;\\n    vector<int> visited;\\n    int dest, src1, src2;\\n    ll combined_cost;\\n    unordered_map<string, pair<ll,ll>> memo;\\n    pair<ll, ll> dfs(int index, ll cost){\\n\\t\\t//DFS returns => {cost to reach src1, cost to reach src2}\\n\\t\\n        if(visited[index]) return {LLONG_MAX,LLONG_MAX};\\n        \\n        //for memoising the DFS\\n        string key = to_string(index)+\",\"+to_string(cost);\\n        if(memo.count(key)) return memo[key];\\n        pair<ll,ll> ret = {LLONG_MAX, LLONG_MAX};\\n        visited[index] = true;\\n        if(index == src1) ret.first = cost;\\n        if(index == src2) ret.second = cost;\\n        \\n        for(int i = 0;i < G[index].size();++i){\\n            auto res = dfs(G[index][i][0],G[index][i][1]+cost);\\n\\t\\t\\t\\n\\t\\t\\t//update the cost to reach src1 and src2 to be minimum\\n            ret.first = min(ret.first, res.first);\\n            ret.second = min(ret.second, res.second);\\n        }\\n        if(ret.first != LLONG_MAX && ret.second != LLONG_MAX){\\n\\t\\t\\t//if both the sources can be reached from the current node, then the current node is\\n\\t\\t\\t// a common node hence we can negate the cost to reach this point\\n            combined_cost = min(combined_cost, ret.first+ret.second-cost);\\n        }\\n        visited[index] = false;\\n        return memo[key] = ret;\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        G = vector<vector<vector<int>>>(n);\\n        combined_cost = LLONG_MAX;\\n        for(auto &i: edges){\\n            G[i[1]].push_back({i[0],i[2]});\\n        }\\n        this->dest = dest;\\n        this->src1 = src1;\\n        this->src2 = src2;\\n        visited = vector<int>(n);\\n        \\n        long long ans = LLONG_MAX;\\n        dfs(dest, 0);\\n        ans = combined_cost;\\n        return ans == LLONG_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    vector<vector<vector<int>>> G;\\n    vector<int> visited;\\n    int dest, src1, src2;\\n    ll combined_cost;\\n    unordered_map<string, pair<ll,ll>> memo;\\n    pair<ll, ll> dfs(int index, ll cost){\\n\\t\\t//DFS returns => {cost to reach src1, cost to reach src2}\\n\\t\\n        if(visited[index]) return {LLONG_MAX,LLONG_MAX};\\n        \\n        //for memoising the DFS\\n        string key = to_string(index)+\",\"+to_string(cost);\\n        if(memo.count(key)) return memo[key];\\n        pair<ll,ll> ret = {LLONG_MAX, LLONG_MAX};\\n        visited[index] = true;\\n        if(index == src1) ret.first = cost;\\n        if(index == src2) ret.second = cost;\\n        \\n        for(int i = 0;i < G[index].size();++i){\\n            auto res = dfs(G[index][i][0],G[index][i][1]+cost);\\n\\t\\t\\t\\n\\t\\t\\t//update the cost to reach src1 and src2 to be minimum\\n            ret.first = min(ret.first, res.first);\\n            ret.second = min(ret.second, res.second);\\n        }\\n        if(ret.first != LLONG_MAX && ret.second != LLONG_MAX){\\n\\t\\t\\t//if both the sources can be reached from the current node, then the current node is\\n\\t\\t\\t// a common node hence we can negate the cost to reach this point\\n            combined_cost = min(combined_cost, ret.first+ret.second-cost);\\n        }\\n        visited[index] = false;\\n        return memo[key] = ret;\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        G = vector<vector<vector<int>>>(n);\\n        combined_cost = LLONG_MAX;\\n        for(auto &i: edges){\\n            G[i[1]].push_back({i[0],i[2]});\\n        }\\n        this->dest = dest;\\n        this->src1 = src1;\\n        this->src2 = src2;\\n        visited = vector<int>(n);\\n        \\n        long long ans = LLONG_MAX;\\n        dfs(dest, 0);\\n        ans = combined_cost;\\n        return ans == LLONG_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193309,
                "title": "java-dijkstra-x-3-common-node",
                "content": "- There will always be a common node. it may be a random node or it may be the dest node. It doesn\\'t matter. \\n- because our goal is to minimize the distance from src1, src2, and dest to that common node, we run Dijkstra from src1, src2, and dest nodes.\\n- In the end, we take the best of `(src1Dist[i]+src2Dist[i]+destDist[i])`\\n\\n```Java\\nclass Solution {\\n    long INF = (long)1e11;\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        List<int[]>[] map = new ArrayList[n];\\n        List<int[]>[] reverseMap = new ArrayList[n];\\n        Arrays.setAll(map, o -> new ArrayList<>());\\n        Arrays.setAll(reverseMap, o -> new ArrayList<>());\\n        for (int[] e : edges){\\n            map[e[0]].add(new int[]{e[1], e[2]});\\n            reverseMap[e[1]].add(new int[]{e[0], e[2]});\\n        }\\n\\n        long[] destDist = dijkstra(n, dest, reverseMap);\\n        long[] src1Dist = dijkstra(n ,src1, map);\\n        long[] src2Dist = dijkstra(n, src2, map);\\n        long ans = INF;\\n        for (int i = 0 ; i < n; i++){\\n            ans = Math.min(ans, destDist[i]+src1Dist[i]+src2Dist[i]);\\n        }\\n\\n        return ans==INF? -1:ans;\\n    }\\n\\n    private long[] dijkstra(int n, int src, List<int[]>[] map){\\n        long[] dist = new long[n];\\n        Arrays.fill(dist, INF);\\n        dist[src] = 0;\\n        PriorityQueue<long[]> minheap = new PriorityQueue<>(Comparator.comparingLong(o -> o[0]));\\n        minheap.offer(new long[]{0L, src});\\n\\n        while(!minheap.isEmpty()){\\n            long[] top = minheap.poll();\\n            long d = top[0];\\n            int cur = (int)top[1];\\n            if (d != dist[cur]){\\n                continue;\\n            }\\n            for (int[] e : map[cur]){\\n                long nd = e[1] + d;\\n                int next = e[0];\\n                if (nd < dist[next]){\\n                    dist[next] = nd;\\n                    minheap.offer(new long[]{nd, next});\\n                }\\n            }\\n        }\\n\\n        return dist;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    long INF = (long)1e11;\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        List<int[]>[] map = new ArrayList[n];\\n        List<int[]>[] reverseMap = new ArrayList[n];\\n        Arrays.setAll(map, o -> new ArrayList<>());\\n        Arrays.setAll(reverseMap, o -> new ArrayList<>());\\n        for (int[] e : edges){\\n            map[e[0]].add(new int[]{e[1], e[2]});\\n            reverseMap[e[1]].add(new int[]{e[0], e[2]});\\n        }\\n\\n        long[] destDist = dijkstra(n, dest, reverseMap);\\n        long[] src1Dist = dijkstra(n ,src1, map);\\n        long[] src2Dist = dijkstra(n, src2, map);\\n        long ans = INF;\\n        for (int i = 0 ; i < n; i++){\\n            ans = Math.min(ans, destDist[i]+src1Dist[i]+src2Dist[i]);\\n        }\\n\\n        return ans==INF? -1:ans;\\n    }\\n\\n    private long[] dijkstra(int n, int src, List<int[]>[] map){\\n        long[] dist = new long[n];\\n        Arrays.fill(dist, INF);\\n        dist[src] = 0;\\n        PriorityQueue<long[]> minheap = new PriorityQueue<>(Comparator.comparingLong(o -> o[0]));\\n        minheap.offer(new long[]{0L, src});\\n\\n        while(!minheap.isEmpty()){\\n            long[] top = minheap.poll();\\n            long d = top[0];\\n            int cur = (int)top[1];\\n            if (d != dist[cur]){\\n                continue;\\n            }\\n            for (int[] e : map[cur]){\\n                long nd = e[1] + d;\\n                int next = e[0];\\n                if (nd < dist[next]){\\n                    dist[next] = nd;\\n                    minheap.offer(new long[]{nd, next});\\n                }\\n            }\\n        }\\n\\n        return dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192574,
                "title": "c",
                "content": "```\\n#define pp pair<long long,long long>\\nclass Solution {\\npublic:\\n    void shortestPath(vector<vector<pp>>g,vector<long long>&dist,int start){\\n        priority_queue<pp,vector<pp>,greater<pp>>pq;\\n        pq.push({0,start});\\n        while(!pq.empty()){\\n            auto [wt,u]=pq.top();\\n            pq.pop();\\n            if(dist[u]!=wt)continue;\\n            for(auto [uu,wt2]:g[u]){\\n                // cout<<u<<\" \"<<uu<<\" \";\\n                if(dist[uu]>dist[u]+wt2){\\n                    dist[uu]=dist[u]+wt2;\\n                    pq.push({dist[uu],uu});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n         vector<vector<pp>>g(n),g1(n);\\n        //let n1 be the point where src1 and src2 meets\\n        for(auto edge:edges){\\n            g[edge[0]].push_back({edge[1],edge[2]});\\n            //g1 an opposite graph to get the dest to n1(where src1 and src2 meets)\\n            g1[edge[1]].push_back({edge[0],edge[2]});\\n        }\\n        \\n        vector<long long>dista(n,LONG_MAX),distb(n,LONG_MAX),distn(n,LONG_MAX);\\n        dista[src1]=distb[src2]=distn[dest]=0;\\n        shortestPath(g,dista,src1);\\n        shortestPath(g,distb,src2);\\n        shortestPath(g1,distn,dest);\\n        long long ans=LONG_MAX;\\n        for(int i=0;i<n;i++){\\n            if(dista[i]==LONG_MAX||distb[i]==LONG_MAX||distn[i]==LONG_MAX)continue;\\n            ans=min(ans,dista[i]+distb[i]+distn[i]);\\n        }\\n        return ans==LONG_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pp pair<long long,long long>\\nclass Solution {\\npublic:\\n    void shortestPath(vector<vector<pp>>g,vector<long long>&dist,int start){\\n        priority_queue<pp,vector<pp>,greater<pp>>pq;\\n        pq.push({0,start});\\n        while(!pq.empty()){\\n            auto [wt,u]=pq.top();\\n            pq.pop();\\n            if(dist[u]!=wt)continue;\\n            for(auto [uu,wt2]:g[u]){\\n                // cout<<u<<\" \"<<uu<<\" \";\\n                if(dist[uu]>dist[u]+wt2){\\n                    dist[uu]=dist[u]+wt2;\\n                    pq.push({dist[uu],uu});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n         vector<vector<pp>>g(n),g1(n);\\n        //let n1 be the point where src1 and src2 meets\\n        for(auto edge:edges){\\n            g[edge[0]].push_back({edge[1],edge[2]});\\n            //g1 an opposite graph to get the dest to n1(where src1 and src2 meets)\\n            g1[edge[1]].push_back({edge[0],edge[2]});\\n        }\\n        \\n        vector<long long>dista(n,LONG_MAX),distb(n,LONG_MAX),distn(n,LONG_MAX);\\n        dista[src1]=distb[src2]=distn[dest]=0;\\n        shortestPath(g,dista,src1);\\n        shortestPath(g,distb,src2);\\n        shortestPath(g1,distn,dest);\\n        long long ans=LONG_MAX;\\n        for(int i=0;i<n;i++){\\n            if(dista[i]==LONG_MAX||distb[i]==LONG_MAX||distn[i]==LONG_MAX)continue;\\n            ans=min(ans,dista[i]+distb[i]+distn[i]);\\n        }\\n        return ans==LONG_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2175996,
                "title": "just-run-dijkstra-algo-3-times-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<int> xr(n, 0);\\n        vector<int> reachable;\\n        unordered_map<int, vector<pair<int,int>>> graph, revGraph;//<node-><node, dist>>\\n        vector<unsigned long long> dist1(n, LLONG_MAX), dist2(n, LLONG_MAX), dist3(n, LLONG_MAX);\\n        auto comp=[](const pair<int,unsigned long long> &a, const pair<int,unsigned long long> &b){\\n            return a.second>b.second;\\n        };\\n        priority_queue<pair<int,unsigned long long>, vector<pair<int,unsigned long long>>, decltype(comp)> pq(comp);//<node, dist>\\n        for(auto &e: edges){\\n            int a=e[0], b=e[1], dist=e[2];\\n            graph[a].push_back({b, dist});\\n            revGraph[b].push_back({a, dist});            \\n        }\\n        dist1[src1]=0;\\n        pq.push({src1,0});\\n        while(!pq.empty()){\\n            auto [node, d]=pq.top();\\n            pq.pop(); \\n            if (dist1[node] != d)\\n                continue;\\n            for(auto [child, childDist]: graph[node]){\\n                if(d+childDist<dist1[child]){ \\n                    dist1[child]=d+childDist;\\n                    pq.push({child, dist1[child]});\\n                }\\n            }\\n        }\\n        dist2[src2]=0;\\n        pq.push({src2, 0});\\n        while(!pq.empty()){\\n            auto [node, d]=pq.top();\\n            pq.pop(); \\n            if (dist2[node] != d)\\n                continue;\\n            for(auto [child, childDist]: graph[node]){\\n                if(d+childDist<dist2[child]){ \\n                    dist2[child]=d+childDist;\\n                    pq.push({child, dist2[child]});\\n                }\\n            }\\n        }\\n        dist3[dest]=0;\\n        pq.push({dest, 0});\\n        while(!pq.empty()){\\n            auto [node, d]=pq.top();\\n            if(dist1[node]!=LLONG_MAX && dist1[node]!=LLONG_MAX)\\n                reachable.push_back(node);\\n            pq.pop();\\n            if (dist3[node] != d)\\n                continue;\\n            for(auto [child, childDist]: revGraph[node]){\\n                if(d+childDist<dist3[child]){ \\n                    dist3[child]=d+childDist;\\n                    pq.push({child, dist3[child]});\\n                }\\n            }\\n        }\\n        unsigned long long ans=ULLONG_MAX;\\n        for(auto &i: reachable){\\n            if(dist1[i]==LLONG_MAX || dist2[i]==LLONG_MAX || dist3[i]==LLONG_MAX)\\n                continue;\\n            ans=min(ans, (unsigned long long)dist1[i]+(unsigned long long)dist2[i]+(unsigned long long)dist3[i]);\\n        }\\n        return ans!=ULLONG_MAX?ans:-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<int> xr(n, 0);\\n        vector<int> reachable;\\n        unordered_map<int, vector<pair<int,int>>> graph, revGraph;//<node-><node, dist>>\\n        vector<unsigned long long> dist1(n, LLONG_MAX), dist2(n, LLONG_MAX), dist3(n, LLONG_MAX);\\n        auto comp=[](const pair<int,unsigned long long> &a, const pair<int,unsigned long long> &b){\\n            return a.second>b.second;\\n        };\\n        priority_queue<pair<int,unsigned long long>, vector<pair<int,unsigned long long>>, decltype(comp)> pq(comp);//<node, dist>\\n        for(auto &e: edges){\\n            int a=e[0], b=e[1], dist=e[2];\\n            graph[a].push_back({b, dist});\\n            revGraph[b].push_back({a, dist});            \\n        }\\n        dist1[src1]=0;\\n        pq.push({src1,0});\\n        while(!pq.empty()){\\n            auto [node, d]=pq.top();\\n            pq.pop(); \\n            if (dist1[node] != d)\\n                continue;\\n            for(auto [child, childDist]: graph[node]){\\n                if(d+childDist<dist1[child]){ \\n                    dist1[child]=d+childDist;\\n                    pq.push({child, dist1[child]});\\n                }\\n            }\\n        }\\n        dist2[src2]=0;\\n        pq.push({src2, 0});\\n        while(!pq.empty()){\\n            auto [node, d]=pq.top();\\n            pq.pop(); \\n            if (dist2[node] != d)\\n                continue;\\n            for(auto [child, childDist]: graph[node]){\\n                if(d+childDist<dist2[child]){ \\n                    dist2[child]=d+childDist;\\n                    pq.push({child, dist2[child]});\\n                }\\n            }\\n        }\\n        dist3[dest]=0;\\n        pq.push({dest, 0});\\n        while(!pq.empty()){\\n            auto [node, d]=pq.top();\\n            if(dist1[node]!=LLONG_MAX && dist1[node]!=LLONG_MAX)\\n                reachable.push_back(node);\\n            pq.pop();\\n            if (dist3[node] != d)\\n                continue;\\n            for(auto [child, childDist]: revGraph[node]){\\n                if(d+childDist<dist3[child]){ \\n                    dist3[child]=d+childDist;\\n                    pq.push({child, dist3[child]});\\n                }\\n            }\\n        }\\n        unsigned long long ans=ULLONG_MAX;\\n        for(auto &i: reachable){\\n            if(dist1[i]==LLONG_MAX || dist2[i]==LLONG_MAX || dist3[i]==LLONG_MAX)\\n                continue;\\n            ans=min(ans, (unsigned long long)dist1[i]+(unsigned long long)dist2[i]+(unsigned long long)dist3[i]);\\n        }\\n        return ans!=ULLONG_MAX?ans:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2083318,
                "title": "python-clean-documented-solution",
                "content": "```\\nfrom collections import defaultdict\\nfrom heapq import heappop, heappush\\nfrom math import inf, isfinite\\nfrom operator import itemgetter\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        \"\"\"\\n        let i be a node in graph, so 0 <= i < n.\\n        we find that \"i\" such that distance from \"src1\" to \"i\" + distance from \"src2\" to\\n        \"i\" + distance from \"i\" to \"dest\" is minimum\\n\\n        :param n: number of nodes\\n        :param edges: graph edges\\n        :param src1:\\n        :param src2:\\n        :param dest:\\n        :return:\\n        \"\"\"\\n        g = self.create_directed_graph(edges)\\n        distances_from_src1 = self.dijkstra(g, src1, n)\\n        distances_from_src2 = self.dijkstra(g, src2, n)\\n\\n        # reversing the edges as we need distance from any other node to \"dest\"\\n        rev_g = self.create_directed_graph(edges, reverse=True)\\n        distances_to_dest = self.dijkstra(rev_g, dest, n)\\n\\n        output = min(\\n            src1_to_i + src2_to_i + i_to_dest for src1_to_i, src2_to_i, i_to_dest in\\n            zip(distances_from_src1, distances_from_src2, distances_to_dest)\\n        )\\n\\n        return output if isfinite(output) else -1\\n\\n    @staticmethod\\n    def create_directed_graph(edges: List[List[int]], reverse=False):\\n        \"\"\"\\n        :param edges: weighted edges of graph\\n        :param reverse: if True then graph is constructed by reversing the edges\\n        :return: constructed graph from edges\\n        \"\"\"\\n        uvw = itemgetter(0, 1, 2) if not reverse else itemgetter(1, 0, 2)\\n        g = defaultdict(list)\\n\\n        for u, v, w in map(uvw, edges):\\n            g[u].append((v, w))\\n\\n        return g\\n\\n    @staticmethod\\n    def dijkstra(g: defaultdict, src: int, nodes: int) -> List[float]:\\n        \"\"\"\\n        :param g: graph\\n        :param src: source node\\n        :param nodes: number of nodes\\n        :return: distance from u to all other nodes in graph\\n        \"\"\"\\n        distances = [inf] * nodes  # distance from \"src\"\\n        distances[src] = 0\\n\\n        pq = [(0, src)]\\n\\n        # creating a bool array \"popped\" which represents if a node has been popped from \"pq\"\\n        # note that: theoretically \"popped\" is not required, only for runtime optimization\\n        popped = [False] * nodes\\n\\n        while pq:\\n            d_u, u = heappop(pq)\\n\\n            if popped[u]:\\n                # u has been explored earlier with optimal distance to it from\\n                continue\\n\\n            popped[u] = True\\n\\n            for v, d_uv in g[u]:\\n                if distances[v] > (d_v := d_u + d_uv):\\n                    # so, there is a path to v through u which is smaller\\n                    distances[v] = d_v\\n                    heappush(pq, (d_v, v))\\n\\n        return distances\\n```",
                "solutionTags": [
                    "Python",
                    "Graph"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom heapq import heappop, heappush\\nfrom math import inf, isfinite\\nfrom operator import itemgetter\\nfrom typing import List\\n\\n\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        \"\"\"\\n        let i be a node in graph, so 0 <= i < n.\\n        we find that \"i\" such that distance from \"src1\" to \"i\" + distance from \"src2\" to\\n        \"i\" + distance from \"i\" to \"dest\" is minimum\\n\\n        :param n: number of nodes\\n        :param edges: graph edges\\n        :param src1:\\n        :param src2:\\n        :param dest:\\n        :return:\\n        \"\"\"\\n        g = self.create_directed_graph(edges)\\n        distances_from_src1 = self.dijkstra(g, src1, n)\\n        distances_from_src2 = self.dijkstra(g, src2, n)\\n\\n        # reversing the edges as we need distance from any other node to \"dest\"\\n        rev_g = self.create_directed_graph(edges, reverse=True)\\n        distances_to_dest = self.dijkstra(rev_g, dest, n)\\n\\n        output = min(\\n            src1_to_i + src2_to_i + i_to_dest for src1_to_i, src2_to_i, i_to_dest in\\n            zip(distances_from_src1, distances_from_src2, distances_to_dest)\\n        )\\n\\n        return output if isfinite(output) else -1\\n\\n    @staticmethod\\n    def create_directed_graph(edges: List[List[int]], reverse=False):\\n        \"\"\"\\n        :param edges: weighted edges of graph\\n        :param reverse: if True then graph is constructed by reversing the edges\\n        :return: constructed graph from edges\\n        \"\"\"\\n        uvw = itemgetter(0, 1, 2) if not reverse else itemgetter(1, 0, 2)\\n        g = defaultdict(list)\\n\\n        for u, v, w in map(uvw, edges):\\n            g[u].append((v, w))\\n\\n        return g\\n\\n    @staticmethod\\n    def dijkstra(g: defaultdict, src: int, nodes: int) -> List[float]:\\n        \"\"\"\\n        :param g: graph\\n        :param src: source node\\n        :param nodes: number of nodes\\n        :return: distance from u to all other nodes in graph\\n        \"\"\"\\n        distances = [inf] * nodes  # distance from \"src\"\\n        distances[src] = 0\\n\\n        pq = [(0, src)]\\n\\n        # creating a bool array \"popped\" which represents if a node has been popped from \"pq\"\\n        # note that: theoretically \"popped\" is not required, only for runtime optimization\\n        popped = [False] * nodes\\n\\n        while pq:\\n            d_u, u = heappop(pq)\\n\\n            if popped[u]:\\n                # u has been explored earlier with optimal distance to it from\\n                continue\\n\\n            popped[u] = True\\n\\n            for v, d_uv in g[u]:\\n                if distances[v] > (d_v := d_u + d_uv):\\n                    # so, there is a path to v through u which is smaller\\n                    distances[v] = d_v\\n                    heappush(pq, (d_v, v))\\n\\n        return distances\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2036211,
                "title": "java-solution-dijkstra-algorithm-with-reversed-graph",
                "content": "```\\nclass Solution {\\n    Long maxValue = Long.MAX_VALUE;\\n    class Vertex\\n    {\\n        public int value;\\n        public long weight;\\n        \\n        public Vertex(int node, long cost)\\n        {\\n            value = node;\\n            weight = cost;\\n        }\\n    }\\n    \\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        Map<Integer, List<Vertex>> graph = new HashMap();\\n        Map<Integer, List<Vertex>> reversedGraph = new HashMap();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            graph.putIfAbsent(i, new ArrayList());\\n            reversedGraph.putIfAbsent(i, new ArrayList());\\n        }\\n        \\n        for(int i = 0; i < edges.length; i++)\\n        {\\n            int src = edges[i][0], destination = edges[i][1], cost = edges[i][2];\\n            graph.get(src).add(new Vertex(destination, cost));\\n            reversedGraph.get(destination).add(new Vertex(src, cost));\\n        } \\n        \\n        Map<Integer, Map<Integer, Long>> distanceMap = new HashMap();\\n        distanceMap.put(src1, djikstra(src1, graph, n));\\n        distanceMap.put(src2, djikstra(src2, graph, n));\\n        distanceMap.put(dest, djikstra(dest, reversedGraph, n));\\n        \\n        long result = maxValue;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            long first = distanceMap.get(src1).get(i);\\n            long second = distanceMap.get(src2).get(i);\\n            long third = distanceMap.get(dest).get(i);\\n            if(first != maxValue && second != maxValue && third != maxValue)\\n            {\\n                result = Math.min(result, first + second + third);\\n            }\\n        }\\n        \\n        if(result != maxValue)\\n        {\\n            return result;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    Map<Integer, Long> djikstra(int src, Map<Integer, List<Vertex>> graph, int n)\\n    {\\n        Map<Integer, Long> distanceMap = new HashMap();\\n        for(int i = 0; i < n; i++)\\n        {\\n           distanceMap.put(i, Long.MAX_VALUE); \\n        }\\n        \\n        Queue<Vertex> queue = new PriorityQueue<Vertex>((a, b) -> Long.compare(a.weight, b.weight));\\n        queue.offer(new Vertex(src, 0));\\n        distanceMap.put(src, 0l);\\n        \\n        while(!queue.isEmpty())\\n        {\\n            Vertex top = queue.poll();\\n            \\n            if(top.weight > distanceMap.get(top.value))\\n            {\\n                continue;\\n            }\\n            \\n            for(Vertex neighbour : graph.get(top.value))\\n            {\\n                if(distanceMap.get(neighbour.value) > distanceMap.get(top.value) + neighbour.weight)\\n                {\\n                    distanceMap.put(neighbour.value, distanceMap.get(top.value) + neighbour.weight);\\n                    queue.offer(new Vertex(neighbour.value, distanceMap.get(neighbour.value)));\\n                }\\n            }\\n        }\\n        \\n        return distanceMap;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Long maxValue = Long.MAX_VALUE;\\n    class Vertex\\n    {\\n        public int value;\\n        public long weight;\\n        \\n        public Vertex(int node, long cost)\\n        {\\n            value = node;\\n            weight = cost;\\n        }\\n    }\\n    \\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        Map<Integer, List<Vertex>> graph = new HashMap();\\n        Map<Integer, List<Vertex>> reversedGraph = new HashMap();\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            graph.putIfAbsent(i, new ArrayList());\\n            reversedGraph.putIfAbsent(i, new ArrayList());\\n        }\\n        \\n        for(int i = 0; i < edges.length; i++)\\n        {\\n            int src = edges[i][0], destination = edges[i][1], cost = edges[i][2];\\n            graph.get(src).add(new Vertex(destination, cost));\\n            reversedGraph.get(destination).add(new Vertex(src, cost));\\n        } \\n        \\n        Map<Integer, Map<Integer, Long>> distanceMap = new HashMap();\\n        distanceMap.put(src1, djikstra(src1, graph, n));\\n        distanceMap.put(src2, djikstra(src2, graph, n));\\n        distanceMap.put(dest, djikstra(dest, reversedGraph, n));\\n        \\n        long result = maxValue;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            long first = distanceMap.get(src1).get(i);\\n            long second = distanceMap.get(src2).get(i);\\n            long third = distanceMap.get(dest).get(i);\\n            if(first != maxValue && second != maxValue && third != maxValue)\\n            {\\n                result = Math.min(result, first + second + third);\\n            }\\n        }\\n        \\n        if(result != maxValue)\\n        {\\n            return result;\\n        }\\n        \\n        return -1;\\n    }\\n    \\n    Map<Integer, Long> djikstra(int src, Map<Integer, List<Vertex>> graph, int n)\\n    {\\n        Map<Integer, Long> distanceMap = new HashMap();\\n        for(int i = 0; i < n; i++)\\n        {\\n           distanceMap.put(i, Long.MAX_VALUE); \\n        }\\n        \\n        Queue<Vertex> queue = new PriorityQueue<Vertex>((a, b) -> Long.compare(a.weight, b.weight));\\n        queue.offer(new Vertex(src, 0));\\n        distanceMap.put(src, 0l);\\n        \\n        while(!queue.isEmpty())\\n        {\\n            Vertex top = queue.poll();\\n            \\n            if(top.weight > distanceMap.get(top.value))\\n            {\\n                continue;\\n            }\\n            \\n            for(Vertex neighbour : graph.get(top.value))\\n            {\\n                if(distanceMap.get(neighbour.value) > distanceMap.get(top.value) + neighbour.weight)\\n                {\\n                    distanceMap.put(neighbour.value, distanceMap.get(top.value) + neighbour.weight);\\n                    queue.offer(new Vertex(neighbour.value, distanceMap.get(neighbour.value)));\\n                }\\n            }\\n        }\\n        \\n        return distanceMap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2014448,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    using ll=long long;\\n    void find(vector<vector<pair<ll,ll>>>&dp,vector<ll>&dis,ll x,int n)\\n    {\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>pq;\\n        pq.push({0ll,x});\\n        vector<int>vis(n,0);\\n        dis[x]=0ll;\\n        while(pq.size())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            ll cost=temp.first;\\n            ll node=temp.second;\\n            if(vis[node])\\n            {\\n                continue;\\n            }\\n            vis[node]=1;\\n            for(auto &it:dp[node])\\n            {\\n                if(dis[it.first]>dis[node]+it.second)\\n                {\\n                    dis[it.first]=dis[node]+it.second;\\n                    pq.push({dis[it.first],it.first});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& nums, int src1, int src2, int dest)\\n    {\\n        vector<vector<pair<ll,ll>>>dp1(n);\\n        vector<vector<pair<ll,ll>>>dp2(n);\\n        for(auto it:nums)\\n        {\\n            dp1[it[0]].push_back({it[1],it[2]});\\n            dp2[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<ll>dis1(n,1e18),dis2(n,1e18),dis3(n,1e18);\\n        find(dp1,dis1,src1,n);\\n        find(dp1,dis2,src2,n);\\n        find(dp2,dis3,dest,n);\\n        ll ans=1e18;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            if(dis1[i]==1e18||dis2[i]==1e18||dis3[i]==1e18)\\n            {\\n                continue;\\n            }\\n            ans=min(ans,dis1[i]+dis2[i]+dis3[i]);\\n        }\\n        return ans==1e18?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using ll=long long;\\n    void find(vector<vector<pair<ll,ll>>>&dp,vector<ll>&dis,ll x,int n)\\n    {\\n        priority_queue<pair<ll,ll>,vector<pair<ll,ll>>,greater<pair<ll,ll>>>pq;\\n        pq.push({0ll,x});\\n        vector<int>vis(n,0);\\n        dis[x]=0ll;\\n        while(pq.size())\\n        {\\n            auto temp=pq.top();\\n            pq.pop();\\n            ll cost=temp.first;\\n            ll node=temp.second;\\n            if(vis[node])\\n            {\\n                continue;\\n            }\\n            vis[node]=1;\\n            for(auto &it:dp[node])\\n            {\\n                if(dis[it.first]>dis[node]+it.second)\\n                {\\n                    dis[it.first]=dis[node]+it.second;\\n                    pq.push({dis[it.first],it.first});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& nums, int src1, int src2, int dest)\\n    {\\n        vector<vector<pair<ll,ll>>>dp1(n);\\n        vector<vector<pair<ll,ll>>>dp2(n);\\n        for(auto it:nums)\\n        {\\n            dp1[it[0]].push_back({it[1],it[2]});\\n            dp2[it[1]].push_back({it[0],it[2]});\\n        }\\n        vector<ll>dis1(n,1e18),dis2(n,1e18),dis3(n,1e18);\\n        find(dp1,dis1,src1,n);\\n        find(dp1,dis2,src2,n);\\n        find(dp2,dis3,dest,n);\\n        ll ans=1e18;\\n        for(int i=0;i<n;i++)\\n        {\\n            \\n            if(dis1[i]==1e18||dis2[i]==1e18||dis3[i]==1e18)\\n            {\\n                continue;\\n            }\\n            ans=min(ans,dis1[i]+dis2[i]+dis3[i]);\\n        }\\n        return ans==1e18?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1954072,
                "title": "find-the-optimal-meet-point-of-the-independent-paths",
                "content": "```\\n    using ll = long long;\\n    \\n    void label_dist(vector<unordered_map<int,ll>>& graph, vector<ll>& d, int src) {\\n        priority_queue<array<ll,2>, vector<array<ll,2>>, greater<array<ll, 2>>> pq;\\n        pq.push({0, src});\\n        while(!pq.empty()) {\\n            auto [dist, node] = pq.top(); pq.pop();\\n            if (d[node] <= dist)\\n                continue;\\n            d[node] = dist;\\n            for (auto [neighbor, weight] : graph[node])\\n                pq.push({weight + dist, neighbor});\\n        }\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<unordered_map<int,ll>> graph(n);\\n        vector<unordered_map<int,ll>> rgraph(n);\\n        for (auto& e : edges) {\\n            graph[e[0]][e[1]] = e[2];\\n            rgraph[e[1]][e[0]] = e[2];\\n        }\\n        for (auto& e : edges) {\\n            graph[e[0]][e[1]] = min(graph[e[0]][e[1]], (ll)e[2]);\\n            rgraph[e[1]][e[0]] = min(graph[e[0]][e[1]], (ll)e[2]);\\n        }\\n        vector<ll> ds1(n, LLONG_MAX);\\n        vector<ll> ds2(n, LLONG_MAX);\\n        vector<ll> dd (n, LLONG_MAX);\\n        \\n        label_dist(graph, ds1, src1);\\n        label_dist(graph, ds2, src2);\\n        label_dist(rgraph, dd, dest);\\n        long long ans{LLONG_MAX};\\n        for (int i = 0; i < n; ++i) {\\n            if (ds1[i] != LLONG_MAX && ds2[i] != LLONG_MAX && dd[i] != LLONG_MAX)\\n                ans = min(ans, ds1[i] + ds2[i] + dd[i]);\\n        }\\n        return ans == LLONG_MAX ? -1 : ans;\\n        \\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    using ll = long long;\\n    \\n    void label_dist(vector<unordered_map<int,ll>>& graph, vector<ll>& d, int src) {\\n        priority_queue<array<ll,2>, vector<array<ll,2>>, greater<array<ll, 2>>> pq;\\n        pq.push({0, src});\\n        while(!pq.empty()) {\\n            auto [dist, node] = pq.top(); pq.pop();\\n            if (d[node] <= dist)\\n                continue;\\n            d[node] = dist;\\n            for (auto [neighbor, weight] : graph[node])\\n                pq.push({weight + dist, neighbor});\\n        }\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<unordered_map<int,ll>> graph(n);\\n        vector<unordered_map<int,ll>> rgraph(n);\\n        for (auto& e : edges) {\\n            graph[e[0]][e[1]] = e[2];\\n            rgraph[e[1]][e[0]] = e[2];\\n        }\\n        for (auto& e : edges) {\\n            graph[e[0]][e[1]] = min(graph[e[0]][e[1]], (ll)e[2]);\\n            rgraph[e[1]][e[0]] = min(graph[e[0]][e[1]], (ll)e[2]);\\n        }\\n        vector<ll> ds1(n, LLONG_MAX);\\n        vector<ll> ds2(n, LLONG_MAX);\\n        vector<ll> dd (n, LLONG_MAX);\\n        \\n        label_dist(graph, ds1, src1);\\n        label_dist(graph, ds2, src2);\\n        label_dist(rgraph, dd, dest);\\n        long long ans{LLONG_MAX};\\n        for (int i = 0; i < n; ++i) {\\n            if (ds1[i] != LLONG_MAX && ds2[i] != LLONG_MAX && dd[i] != LLONG_MAX)\\n                ans = min(ans, ds1[i] + ds2[i] + dd[i]);\\n        }\\n        return ans == LLONG_MAX ? -1 : ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1885045,
                "title": "c-3-dijkstra-solution",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    void print(vector<long> &dist){\\n        for(long &x:dist)\\n            cout<<x<<\" \";\\n        cout<<endl;\\n    }\\n    vector<long> bfs(int n,vector<vector<pair<int,int>>> &graph,int src){\\n        vector<long> distance(n,1e11);\\n        vector<bool> visited(n);\\n        priority_queue<pair<int,int>> pq;\\n        pq.push({0,src});\\n        distance[src]=0;\\n        visited[src]=true;\\n        while(!pq.empty()){\\n            auto [ww,u]=pq.top();\\n            pq.pop();\\n            if(distance[u]<ww)\\n                continue;\\n            for(auto [v,w]:graph[u]){\\n                if(distance[v]>distance[u]+w){\\n                    distance[v]=distance[u]+w;\\n                    pq.push({distance[v],v});\\n                    visited[v]=true;\\n                }\\n            }\\n        }\\n        return distance;\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int,int>>> graph(n),inverted_graph(n);\\n        for(auto &edge:edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            int w=edge[2];\\n            graph[u].push_back({v,w});\\n            inverted_graph[v].push_back({u,w});\\n        }\\n        auto distance_src1=bfs(n,graph,src1);\\n        auto distance_src2=bfs(n,graph,src2);\\n        auto distance_dest=bfs(n,inverted_graph,dest);\\n        // print(distance_src1);\\n        // print(distance_src2);\\n        // print(distance_dest);\\n        long ans=1e11;\\n        for(int i=0;i<n;i++){\\n            ans=min({ans,distance_src1[i]+distance_src2[i]+distance_dest[i]});\\n        }\\n        if(ans>=1e11)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void print(vector<long> &dist){\\n        for(long &x:dist)\\n            cout<<x<<\" \";\\n        cout<<endl;\\n    }\\n    vector<long> bfs(int n,vector<vector<pair<int,int>>> &graph,int src){\\n        vector<long> distance(n,1e11);\\n        vector<bool> visited(n);\\n        priority_queue<pair<int,int>> pq;\\n        pq.push({0,src});\\n        distance[src]=0;\\n        visited[src]=true;\\n        while(!pq.empty()){\\n            auto [ww,u]=pq.top();\\n            pq.pop();\\n            if(distance[u]<ww)\\n                continue;\\n            for(auto [v,w]:graph[u]){\\n                if(distance[v]>distance[u]+w){\\n                    distance[v]=distance[u]+w;\\n                    pq.push({distance[v],v});\\n                    visited[v]=true;\\n                }\\n            }\\n        }\\n        return distance;\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int,int>>> graph(n),inverted_graph(n);\\n        for(auto &edge:edges){\\n            int u=edge[0];\\n            int v=edge[1];\\n            int w=edge[2];\\n            graph[u].push_back({v,w});\\n            inverted_graph[v].push_back({u,w});\\n        }\\n        auto distance_src1=bfs(n,graph,src1);\\n        auto distance_src2=bfs(n,graph,src2);\\n        auto distance_dest=bfs(n,inverted_graph,dest);\\n        // print(distance_src1);\\n        // print(distance_src2);\\n        // print(distance_dest);\\n        long ans=1e11;\\n        for(int i=0;i<n;i++){\\n            ans=min({ans,distance_src1[i]+distance_src2[i]+distance_dest[i]});\\n        }\\n        if(ans>=1e11)\\n            return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1883954,
                "title": "c-3-dijkstra",
                "content": "For this question, essentially you need find SSSP (single source shortest path) from src1, src2 and dest(in reverse graph). Then find a intermediate vertex v satisfy \\n```\\nmin(dis(src1, v) + dis(src2, v) + dis(dest, v)) (v in G)\\n```\\nHere we use dijkstra to find the SSSP value.\\nImplementation:\\n```\\n#define ll long long \\n#define pii pair<int, int> \\n#define pll pair<long long, int> \\nconst ll INF = (ll)1e18;\\n\\nclass Solution {\\npublic:\\n    inline vector<ll> dijkstra(vector<vector<pii>> &graph, int &source) {\\n        int n = graph.size();\\n        vector<ll> dist(n, INF);\\n        priority_queue<pll, vector<pll>, greater<>> que;\\n        que.push({0, source});\\n        while (!que.empty()) {\\n            auto &front = que.top();\\n            if (dist[front.second] < INF) {\\n                que.pop();\\n                continue;\\n            }\\n            dist[front.second] = front.first;\\n            ll dis = front.first;\\n            for (auto &p : graph[front.second]) {\\n                if (dis + p.second < dist[p.first]) {\\n                    que.push({dis + p.second, p.first});\\n                }\\n            }\\n            que.pop();\\n        }\\n        return dist;\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pii>> g(n);\\n        vector<vector<pii>> revG(n);\\n        for (auto &edge : edges) {\\n            g[edge[0]].push_back({edge[1], edge[2]});\\n            revG[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        vector<ll> dist1 = dijkstra(g, src1);\\n        vector<ll> dist2 = dijkstra(g, src2);\\n        vector<ll> dist3 = dijkstra(revG, dest);\\n        ll mi = INF;\\n        for (int i = 0; i < n; ++i) {\\n            mi = min(mi, dist1[i] + dist2[i] + dist3[i]);\\n        }\\n        return mi == INF ? -1 : mi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nmin(dis(src1, v) + dis(src2, v) + dis(dest, v)) (v in G)\\n```\n```\\n#define ll long long \\n#define pii pair<int, int> \\n#define pll pair<long long, int> \\nconst ll INF = (ll)1e18;\\n\\nclass Solution {\\npublic:\\n    inline vector<ll> dijkstra(vector<vector<pii>> &graph, int &source) {\\n        int n = graph.size();\\n        vector<ll> dist(n, INF);\\n        priority_queue<pll, vector<pll>, greater<>> que;\\n        que.push({0, source});\\n        while (!que.empty()) {\\n            auto &front = que.top();\\n            if (dist[front.second] < INF) {\\n                que.pop();\\n                continue;\\n            }\\n            dist[front.second] = front.first;\\n            ll dis = front.first;\\n            for (auto &p : graph[front.second]) {\\n                if (dis + p.second < dist[p.first]) {\\n                    que.push({dis + p.second, p.first});\\n                }\\n            }\\n            que.pop();\\n        }\\n        return dist;\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pii>> g(n);\\n        vector<vector<pii>> revG(n);\\n        for (auto &edge : edges) {\\n            g[edge[0]].push_back({edge[1], edge[2]});\\n            revG[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        vector<ll> dist1 = dijkstra(g, src1);\\n        vector<ll> dist2 = dijkstra(g, src2);\\n        vector<ll> dist3 = dijkstra(revG, dest);\\n        ll mi = INF;\\n        for (int i = 0; i < n; ++i) {\\n            mi = min(mi, dist1[i] + dist2[i] + dist3[i]);\\n        }\\n        return mi == INF ? -1 : mi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877793,
                "title": "straightforward-once-you-thought-of-it-solution",
                "content": "Use dijstra to record distance of any point to start1, start2, and end point, since we\\'re assuming that random point is where the 2 paths to the end would converge.\\n\\nFind minimum total distance.\\n\\n```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        #record distance from a, from b, to end, at every single point. compute.\\n        \\n        \\n        graph = collections.defaultdict(set)\\n        \\n        backgraph = collections.defaultdict(set)\\n        for a, b, c in edges:\\n            graph[a].add((b, c))\\n            backgraph[b].add((a, c))\\n        \\n        \\n        \\n        \\n        \\n        #distance to end\\n        h = [[0, dest]] #[distance from start]\\n        \\n        costToEnd = [float(\\'inf\\')] * n\\n        \\n        while h != []:\\n            currtime = h[0][0]\\n            currnode = h[0][1]\\n            heappop(h)\\n\\n            #process this arrival time\\n\\n\\n            if costToEnd[currnode] <= currtime:\\n                #this is a slower time or an already processed time!\\n                #not processed.\\n                continue\\n\\n            elif costToEnd[currnode] > currtime: #this is a superior time\\n                costToEnd[currnode] = currtime\\n\\n\\n            #put incoming nodes into cost\\n\\n            for node, time in backgraph[currnode]:\\n                newtime = currtime + time\\n                heappush(h, [newtime, node, currnode])\\n        \\n        # print(costToEnd)\\n        \\n        def distFrom(src):\\n            #dist to src1\\n            h = [[0, src]]\\n\\n\\n            cost = [float(\\'inf\\')] * n\\n\\n            while h != []:\\n                currtime = h[0][0]\\n                currnode = h[0][1]\\n                heappop(h)\\n\\n                #process this arrival time\\n\\n\\n                if cost[currnode] <= currtime:\\n                    #this is a slower time or an already processed time!\\n                    #not processed.\\n                    continue\\n\\n                elif cost[currnode] > currtime: #this is a superior time\\n                    cost[currnode] = currtime\\n\\n\\n                #put incoming nodes into cost\\n\\n                for node, time in graph[currnode]:\\n                    newtime = currtime + time\\n                    heappush(h, [newtime, node, currnode])\\n\\n\\n            return cost\\n        \\n        d1 = distFrom(src1)\\n        d2 = distFrom(src2)\\n        \\n        # print(d1)\\n        # print(d2)\\n        \\n        \\n        r = inf\\n        for i in range(n):\\n            r = min(r, d1[i] + d2[i] + costToEnd[i])\\n        \\n        \\n        \\n        \\n        if r == inf: return -1\\n        return r\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        #record distance from a, from b, to end, at every single point. compute.\\n        \\n        \\n        graph = collections.defaultdict(set)\\n        \\n        backgraph = collections.defaultdict(set)\\n        for a, b, c in edges:\\n            graph[a].add((b, c))\\n            backgraph[b].add((a, c))\\n        \\n        \\n        \\n        \\n        \\n        #distance to end\\n        h = [[0, dest]] #[distance from start]\\n        \\n        costToEnd = [float(\\'inf\\')] * n\\n        \\n        while h != []:\\n            currtime = h[0][0]\\n            currnode = h[0][1]\\n            heappop(h)\\n\\n            #process this arrival time\\n\\n\\n            if costToEnd[currnode] <= currtime:\\n                #this is a slower time or an already processed time!\\n                #not processed.\\n                continue\\n\\n            elif costToEnd[currnode] > currtime: #this is a superior time\\n                costToEnd[currnode] = currtime\\n\\n\\n            #put incoming nodes into cost\\n\\n            for node, time in backgraph[currnode]:\\n                newtime = currtime + time\\n                heappush(h, [newtime, node, currnode])\\n        \\n        # print(costToEnd)\\n        \\n        def distFrom(src):\\n            #dist to src1\\n            h = [[0, src]]\\n\\n\\n            cost = [float(\\'inf\\')] * n\\n\\n            while h != []:\\n                currtime = h[0][0]\\n                currnode = h[0][1]\\n                heappop(h)\\n\\n                #process this arrival time\\n\\n\\n                if cost[currnode] <= currtime:\\n                    #this is a slower time or an already processed time!\\n                    #not processed.\\n                    continue\\n\\n                elif cost[currnode] > currtime: #this is a superior time\\n                    cost[currnode] = currtime\\n\\n\\n                #put incoming nodes into cost\\n\\n                for node, time in graph[currnode]:\\n                    newtime = currtime + time\\n                    heappush(h, [newtime, node, currnode])\\n\\n\\n            return cost\\n        \\n        d1 = distFrom(src1)\\n        d2 = distFrom(src2)\\n        \\n        # print(d1)\\n        # print(d2)\\n        \\n        \\n        r = inf\\n        for i in range(n):\\n            r = min(r, d1[i] + d2[i] + costToEnd[i])\\n        \\n        \\n        \\n        \\n        if r == inf: return -1\\n        return r\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875771,
                "title": "c-solution",
                "content": "```\\nvoid src1todest (int* havebeen, int now, int dest, int* now_place, int** edges, int edgesSize, long long weight, long long** src_to_x_w, int* mon, int count, long long* x_to_end_w){\\n    if (havebeen[now] > 0){\\n        return;\\n    }\\n    if (now == dest){\\n        for (int i = 0 ; i < count ; i++){\\n            if (x_to_end_w[mon[i]] == 0 || x_to_end_w[mon[i]] > weight - src_to_x_w[0][mon[i]]) {\\n                x_to_end_w[mon[i]] = weight - src_to_x_w[0][mon[i]];\\n            } \\n        }\\n    }\\n    if (src_to_x_w[0][now] == 0 || src_to_x_w[0][now] > weight){\\n        src_to_x_w[0][now] = weight;\\n    } else {\\n        return;\\n    }\\n    \\n    if (now == dest){\\n        return;\\n    }\\n    havebeen[now]++;\\n    mon[count] = now;\\n    \\n    for (int i = now_place[now] ; i < edgesSize && edges[i][0] == now ; i++){\\n        if (i == now_place[now] || edges[i][1] != edges[i-1][1]){\\n            src1todest(havebeen, edges[i][1], dest, now_place, edges, edgesSize, weight+edges[i][2], src_to_x_w, mon, count+1, x_to_end_w);\\n        }\\n    }\\n    havebeen[now]--;\\n    return;\\n}\\n\\n\\n\\nvoid src2toEnd(int* havebeen, int now, int End, int* now_place, int** edges, int edgesSize, long long weight, long long** src_to_x_w, long long* x_to_end_w, long long* ans, int src1, int src2){\\n    if (havebeen[now] > 0){\\n        return;\\n    }\\n    if (src_to_x_w[1][now] == 0 || src_to_x_w[1][now] > weight){\\n        src_to_x_w[1][now] = weight;\\n        if (x_to_end_w[now] != 0){\\n            long long w = src_to_x_w[0][now] < src_to_x_w[0][End] ? weight+x_to_end_w[now]+src_to_x_w[0][now] : weight+x_to_end_w[now]+src_to_x_w[0][End];\\n            if (*ans == -1 || *ans > w){\\n                *ans = w;\\n            }\\n        }\\n    } else {\\n        return;\\n    }\\n    \\n    if (now == End){\\n        long long w;\\n        if (havebeen[src1] == 0){\\n            if (src_to_x_w[0][src2] > 0) {\\n                w = weight + src_to_x_w[0][src2];\\n            } else {\\n                w = weight + src_to_x_w[0][End];\\n            }\\n        } else {\\n            w = src_to_x_w[1][src1] + src_to_x_w[0][End];\\n        }\\n        if (*ans == -1 || *ans > w){\\n            *ans = w;\\n        }\\n        return;\\n    }\\n    \\n    \\n    havebeen[now]++;\\n    for (int i = now_place[now] ; i < edgesSize && edges[i][0] == now ; i++){\\n        if (i == now_place[now] || edges[i][1] != edges[i-1][1]){\\n            src2toEnd(havebeen, edges[i][1], End, now_place, edges, edgesSize, weight+edges[i][2], src_to_x_w, x_to_end_w, ans, src1, src2);\\n        }\\n    }\\n    havebeen[now]--;\\n    return;\\n}\\n\\n\\nint comp(const void** a, const void** b){\\n    if ((*(int**)a)[0] == (*(int**)b)[0]){\\n        if ((*(int**)a)[1] == (*(int**)b)[1]){\\n            return (*(int**)a)[2] - (*(int**)b)[2];\\n        }\\n        return (*(int**)a)[1] - (*(int**)b)[1];\\n    }\\n    return (*(int**)a)[0] - (*(int**)b)[0];\\n}\\n\\n\\nlong long minimumWeight(int n, int** edges, int edgesSize, int* edgesColSize, int src1, int src2, int dest){\\n    if (edgesSize == 0){\\n        return -1;\\n    }\\n    qsort(edges,edgesSize,sizeof(int*),comp);\\n    \\n    int now_place[100000] = {0};\\n    \\n    long long** src_to_x_w = malloc(sizeof(long long*)*2);\\n    for (int i = 0 ; i < 2 ; i++){\\n        src_to_x_w[i] = calloc(n,sizeof(long long));\\n    }\\n    \\n    long long x_to_end_w[100000] = {0};\\n    \\n    int a = 0;\\n    while (edges[a][0] == edges[0][0]){\\n        a++;\\n    }\\n    for (int i = a ; i < edgesSize ; i++){\\n        if (now_place[edges[i][0]] == 0){\\n            now_place[edges[i][0]] = i;\\n        }\\n    }\\n    \\n    int havebeen[100000] = {0};\\n    int mon[100000] = {0};\\n    long long ans = -1;\\n    src1todest (havebeen, src1, dest, now_place, edges, edgesSize, 0, src_to_x_w, mon, 0, x_to_end_w);\\n    if (x_to_end_w[src1] == 0){\\n        return -1;\\n    }\\n    src2toEnd(havebeen, src2, dest, now_place, edges, edgesSize, 0, src_to_x_w, x_to_end_w, &ans, src1, src2);\\n   \\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid src1todest (int* havebeen, int now, int dest, int* now_place, int** edges, int edgesSize, long long weight, long long** src_to_x_w, int* mon, int count, long long* x_to_end_w){\\n    if (havebeen[now] > 0){\\n        return;\\n    }\\n    if (now == dest){\\n        for (int i = 0 ; i < count ; i++){\\n            if (x_to_end_w[mon[i]] == 0 || x_to_end_w[mon[i]] > weight - src_to_x_w[0][mon[i]]) {\\n                x_to_end_w[mon[i]] = weight - src_to_x_w[0][mon[i]];\\n            } \\n        }\\n    }\\n    if (src_to_x_w[0][now] == 0 || src_to_x_w[0][now] > weight){\\n        src_to_x_w[0][now] = weight;\\n    } else {\\n        return;\\n    }\\n    \\n    if (now == dest){\\n        return;\\n    }\\n    havebeen[now]++;\\n    mon[count] = now;\\n    \\n    for (int i = now_place[now] ; i < edgesSize && edges[i][0] == now ; i++){\\n        if (i == now_place[now] || edges[i][1] != edges[i-1][1]){\\n            src1todest(havebeen, edges[i][1], dest, now_place, edges, edgesSize, weight+edges[i][2], src_to_x_w, mon, count+1, x_to_end_w);\\n        }\\n    }\\n    havebeen[now]--;\\n    return;\\n}\\n\\n\\n\\nvoid src2toEnd(int* havebeen, int now, int End, int* now_place, int** edges, int edgesSize, long long weight, long long** src_to_x_w, long long* x_to_end_w, long long* ans, int src1, int src2){\\n    if (havebeen[now] > 0){\\n        return;\\n    }\\n    if (src_to_x_w[1][now] == 0 || src_to_x_w[1][now] > weight){\\n        src_to_x_w[1][now] = weight;\\n        if (x_to_end_w[now] != 0){\\n            long long w = src_to_x_w[0][now] < src_to_x_w[0][End] ? weight+x_to_end_w[now]+src_to_x_w[0][now] : weight+x_to_end_w[now]+src_to_x_w[0][End];\\n            if (*ans == -1 || *ans > w){\\n                *ans = w;\\n            }\\n        }\\n    } else {\\n        return;\\n    }\\n    \\n    if (now == End){\\n        long long w;\\n        if (havebeen[src1] == 0){\\n            if (src_to_x_w[0][src2] > 0) {\\n                w = weight + src_to_x_w[0][src2];\\n            } else {\\n                w = weight + src_to_x_w[0][End];\\n            }\\n        } else {\\n            w = src_to_x_w[1][src1] + src_to_x_w[0][End];\\n        }\\n        if (*ans == -1 || *ans > w){\\n            *ans = w;\\n        }\\n        return;\\n    }\\n    \\n    \\n    havebeen[now]++;\\n    for (int i = now_place[now] ; i < edgesSize && edges[i][0] == now ; i++){\\n        if (i == now_place[now] || edges[i][1] != edges[i-1][1]){\\n            src2toEnd(havebeen, edges[i][1], End, now_place, edges, edgesSize, weight+edges[i][2], src_to_x_w, x_to_end_w, ans, src1, src2);\\n        }\\n    }\\n    havebeen[now]--;\\n    return;\\n}\\n\\n\\nint comp(const void** a, const void** b){\\n    if ((*(int**)a)[0] == (*(int**)b)[0]){\\n        if ((*(int**)a)[1] == (*(int**)b)[1]){\\n            return (*(int**)a)[2] - (*(int**)b)[2];\\n        }\\n        return (*(int**)a)[1] - (*(int**)b)[1];\\n    }\\n    return (*(int**)a)[0] - (*(int**)b)[0];\\n}\\n\\n\\nlong long minimumWeight(int n, int** edges, int edgesSize, int* edgesColSize, int src1, int src2, int dest){\\n    if (edgesSize == 0){\\n        return -1;\\n    }\\n    qsort(edges,edgesSize,sizeof(int*),comp);\\n    \\n    int now_place[100000] = {0};\\n    \\n    long long** src_to_x_w = malloc(sizeof(long long*)*2);\\n    for (int i = 0 ; i < 2 ; i++){\\n        src_to_x_w[i] = calloc(n,sizeof(long long));\\n    }\\n    \\n    long long x_to_end_w[100000] = {0};\\n    \\n    int a = 0;\\n    while (edges[a][0] == edges[0][0]){\\n        a++;\\n    }\\n    for (int i = a ; i < edgesSize ; i++){\\n        if (now_place[edges[i][0]] == 0){\\n            now_place[edges[i][0]] = i;\\n        }\\n    }\\n    \\n    int havebeen[100000] = {0};\\n    int mon[100000] = {0};\\n    long long ans = -1;\\n    src1todest (havebeen, src1, dest, now_place, edges, edgesSize, 0, src_to_x_w, mon, 0, x_to_end_w);\\n    if (x_to_end_w[src1] == 0){\\n        return -1;\\n    }\\n    src2toEnd(havebeen, src2, dest, now_place, edges, edgesSize, 0, src_to_x_w, x_to_end_w, &ans, src1, src2);\\n   \\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1868278,
                "title": "1-dijkstra-solution-with-99-6-tc-100-sc",
                "content": "```\\n\\tpublic long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        List<int[]>[] graph = new List[n];\\n        long[][] weight = new long[3][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                weight[j][i] = Long.MAX_VALUE;\\n            }\\n            graph[i] = new ArrayList();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(new int[] {e[1], e[2]});\\n        }\\n        \\n        Queue<Node> queue = new PriorityQueue(new Comparator<Node>() {\\n            public int compare(Node node1, Node node2) {\\n                return Long.compare(node1.weight, node2.weight);\\n            }\\n        });\\n        queue.offer(new Node(0, src1, 0));\\n        weight[0][src1] = 0;\\n        queue.offer(new Node(1, src2, 0));\\n        weight[1][src2] = 0;\\n        while (!queue.isEmpty()) {\\n            Node curr = queue.poll();\\n            if (curr.weight > weight[curr.index][curr.vertex] || curr.weight > weight[2][curr.vertex]) {\\n                continue;\\n            }\\n            if (curr.vertex == dest && curr.index == 2) {\\n                return curr.weight;\\n            }\\n            for (int[] next : graph[curr.vertex]) {\\n                if (curr.index == 2 && weight[curr.index][next[0]] > curr.weight + next[1]) {\\n                    weight[curr.index][next[0]] = curr.weight + next[1];\\n                    queue.offer(new Node(curr.index, next[0], weight[curr.index][next[0]]));\\n                } else if (weight[curr.index][next[0]] > curr.weight + next[1]) {\\n                    weight[curr.index][next[0]] = curr.weight + next[1];\\n                    queue.offer(new Node(curr.index, next[0], weight[curr.index][next[0]]));\\n                    if (weight[curr.index ^ 1][next[0]] != Long.MAX_VALUE && weight[curr.index][next[0]] + weight[curr.index ^ 1][next[0]] < weight[2][next[0]]) {\\n                        weight[2][next[0]] = weight[curr.index][next[0]] + weight[curr.index ^ 1][next[0]];\\n                        queue.offer(new Node(2, next[0], weight[2][next[0]]));\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    class Node {\\n        int index;\\n        int vertex;\\n        long weight;\\n        \\n        Node(int index, int vertex, long weight) {\\n            this.index = index;\\n            this.vertex = vertex;\\n            this.weight = weight;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\tpublic long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        List<int[]>[] graph = new List[n];\\n        long[][] weight = new long[3][n];\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < 3; j++) {\\n                weight[j][i] = Long.MAX_VALUE;\\n            }\\n            graph[i] = new ArrayList();\\n        }\\n        for (int[] e : edges) {\\n            graph[e[0]].add(new int[] {e[1], e[2]});\\n        }\\n        \\n        Queue<Node> queue = new PriorityQueue(new Comparator<Node>() {\\n            public int compare(Node node1, Node node2) {\\n                return Long.compare(node1.weight, node2.weight);\\n            }\\n        });\\n        queue.offer(new Node(0, src1, 0));\\n        weight[0][src1] = 0;\\n        queue.offer(new Node(1, src2, 0));\\n        weight[1][src2] = 0;\\n        while (!queue.isEmpty()) {\\n            Node curr = queue.poll();\\n            if (curr.weight > weight[curr.index][curr.vertex] || curr.weight > weight[2][curr.vertex]) {\\n                continue;\\n            }\\n            if (curr.vertex == dest && curr.index == 2) {\\n                return curr.weight;\\n            }\\n            for (int[] next : graph[curr.vertex]) {\\n                if (curr.index == 2 && weight[curr.index][next[0]] > curr.weight + next[1]) {\\n                    weight[curr.index][next[0]] = curr.weight + next[1];\\n                    queue.offer(new Node(curr.index, next[0], weight[curr.index][next[0]]));\\n                } else if (weight[curr.index][next[0]] > curr.weight + next[1]) {\\n                    weight[curr.index][next[0]] = curr.weight + next[1];\\n                    queue.offer(new Node(curr.index, next[0], weight[curr.index][next[0]]));\\n                    if (weight[curr.index ^ 1][next[0]] != Long.MAX_VALUE && weight[curr.index][next[0]] + weight[curr.index ^ 1][next[0]] < weight[2][next[0]]) {\\n                        weight[2][next[0]] = weight[curr.index][next[0]] + weight[curr.index ^ 1][next[0]];\\n                        queue.offer(new Node(2, next[0], weight[2][next[0]]));\\n                    }\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n    \\n    class Node {\\n        int index;\\n        int vertex;\\n        long weight;\\n        \\n        Node(int index, int vertex, long weight) {\\n            this.index = index;\\n            this.vertex = vertex;\\n            this.weight = weight;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857744,
                "title": "c-solution-using-dijkstras",
                "content": "```\\nclass Solution {\\npublic:\\n    const long long INF = 1e16 + 7;\\n    vector<long long> distance(int u, vector<vector<pair<int, int>>>& edge) {\\n        int n = edge.size();\\n        vector<long long> dist(n, INF);\\n        vector<int> mark(n);\\n        dist[u] = 0;\\n        set<pair<long long, int>> st;\\n        for (int i = 0; i < n; i++) {\\n            st.insert({dist[i], i});\\n        }\\n        while (!st.empty()) {\\n            auto [d, node] = *st.begin();\\n            st.erase(st.begin());\\n            mark[node] = true;\\n            for (auto [child, w] : edge[node]) {\\n                if (!mark[child]) {\\n                    if (dist[child] > dist[node] + w) {\\n                        st.erase(make_pair(dist[child], child));\\n                        dist[child] = dist[node] + w;\\n                        st.insert({dist[child], child});\\n                    }\\n                }\\n            }\\n        }\\n        return dist;\\n        \\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int, int>>> edge(n);\\n        vector<vector<pair<int, int>>> revEdge(n);\\n        for (vector<int>& e : edges) {\\n            edge[e[0]].emplace_back(e[1], e[2]);\\n            revEdge[e[1]].emplace_back(e[0], e[2]);\\n        }\\n        long long sol = INF;\\n        vector<long long> dist1 = distance(src1, edge);\\n        vector<long long> dist2 = distance(src2, edge);\\n        vector<long long> dist3 = distance(dest, revEdge);\\n        for (int i = 0; i < n; i++) {\\n            sol = min(sol, dist1[i] + dist2[i] + dist3[i]);\\n        }\\n        return sol >= INF ? -1 : sol;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    const long long INF = 1e16 + 7;\\n    vector<long long> distance(int u, vector<vector<pair<int, int>>>& edge) {\\n        int n = edge.size();\\n        vector<long long> dist(n, INF);\\n        vector<int> mark(n);\\n        dist[u] = 0;\\n        set<pair<long long, int>> st;\\n        for (int i = 0; i < n; i++) {\\n            st.insert({dist[i], i});\\n        }\\n        while (!st.empty()) {\\n            auto [d, node] = *st.begin();\\n            st.erase(st.begin());\\n            mark[node] = true;\\n            for (auto [child, w] : edge[node]) {\\n                if (!mark[child]) {\\n                    if (dist[child] > dist[node] + w) {\\n                        st.erase(make_pair(dist[child], child));\\n                        dist[child] = dist[node] + w;\\n                        st.insert({dist[child], child});\\n                    }\\n                }\\n            }\\n        }\\n        return dist;\\n        \\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int, int>>> edge(n);\\n        vector<vector<pair<int, int>>> revEdge(n);\\n        for (vector<int>& e : edges) {\\n            edge[e[0]].emplace_back(e[1], e[2]);\\n            revEdge[e[1]].emplace_back(e[0], e[2]);\\n        }\\n        long long sol = INF;\\n        vector<long long> dist1 = distance(src1, edge);\\n        vector<long long> dist2 = distance(src2, edge);\\n        vector<long long> dist3 = distance(dest, revEdge);\\n        for (int i = 0; i < n; i++) {\\n            sol = min(sol, dist1[i] + dist2[i] + dist3[i]);\\n        }\\n        return sol >= INF ? -1 : sol;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852665,
                "title": "c-explained-commented-code-dijkstra-s-algorithm-using-set-3-times-dijkstra-applied",
                "content": "```\\n//Applying Dijkstra algorithm three times\\n//1. First Dijkstra algorthm by taking src1 as source node and finding out the shortest distance of every node from src1 in the given graph\\n//2. Second Dijkstra alogorithm by taking src2 as source node and finding out the shortest distance of every node from src2 in the given graph\\n//3. Third Dijkstra alogorithm by taking dest as source node and finding out the shortest distance of every node from dest in the new graph formed by reversing the directions of the directed edges\\n\\n//And now to find out the shortest distance of src1 and src2 from dest\\n//By considering that path from src1 and src2 may meet at some common node and then reach dest\\n//There might be a case where there is no common node and paths from sr1 and src2 are completley independant of each other so in this the common node would only be dest itself\\n//By considering all the combinations of taking this x node we try to find out what would the total distance from src1 to x + src2 to x + dest to x will look and if it is smaller than what we have already formed we will update our min len variable\\n\\n//there might be a case when there is no route to reach dest to src1 or src2 or both in that case we will return -1\\n\\n//else we will return the min len\\n\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    void dijkstra(vector<ll> &dist, int src, list<pair<int, int>> *l) {\\n        set<pair<ll, ll>> s;\\n        s.insert({dist[src], src});\\n        \\n        while(!s.empty()) {\\n            auto it = s.begin();\\n            pair<ll, ll> w_n = *it;\\n            s.erase(s.begin());\\n            ll node = w_n.second;\\n            ll d = w_n.first;\\n            for(auto p: l[node]) {\\n               if(dist[p.first] > d + p.second) {\\n                   auto it = s.find({dist[p.first], p.first});\\n                    if(it != s.end()) s.erase(it);\\n                    dist[p.first] = d + p.second;\\n                    s.insert({dist[p.first], p.first});\\n                }\\n            }\\n        }\\n        return;\\n    \\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        \\n        long long max_val = 10000000000;\\n        \\n        vector<ll> dist1(n, max_val);\\n        vector<ll> dist2(n, max_val);\\n        vector<ll> dist3(n, max_val);\\n         \\n        list<pair<int, int>> *l = new list<pair<int, int>>[n];\\n        list<pair<int, int>> *dd = new list<pair<int, int>>[n];\\n        \\n        for(int i = 0; i < edges.size(); i++) {\\n            l[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            dd[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n        dist1[src1] = 0;\\n        dist2[src2] = 0;\\n        dist3[dest] = 0;\\n        \\n        dijkstra(dist1, src1, l);\\n        dijkstra(dist2, src2, l);\\n        dijkstra(dist3, dest, dd);\\n        \\n        long long  min_len = LLONG_MAX;\\n        \\n        if(dist3[src1] == max_val || dist3[src2] == max_val) return -1;\\n        \\n        for(int i = 0; i < n; i++) {\\n            long long len = dist1[i] + dist2[i] + dist3[i];\\n            min_len = min(min_len, len); \\n        }\\n        \\n        return min_len;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Applying Dijkstra algorithm three times\\n//1. First Dijkstra algorthm by taking src1 as source node and finding out the shortest distance of every node from src1 in the given graph\\n//2. Second Dijkstra alogorithm by taking src2 as source node and finding out the shortest distance of every node from src2 in the given graph\\n//3. Third Dijkstra alogorithm by taking dest as source node and finding out the shortest distance of every node from dest in the new graph formed by reversing the directions of the directed edges\\n\\n//And now to find out the shortest distance of src1 and src2 from dest\\n//By considering that path from src1 and src2 may meet at some common node and then reach dest\\n//There might be a case where there is no common node and paths from sr1 and src2 are completley independant of each other so in this the common node would only be dest itself\\n//By considering all the combinations of taking this x node we try to find out what would the total distance from src1 to x + src2 to x + dest to x will look and if it is smaller than what we have already formed we will update our min len variable\\n\\n//there might be a case when there is no route to reach dest to src1 or src2 or both in that case we will return -1\\n\\n//else we will return the min len\\n\\nusing ll = long long;\\nclass Solution {\\npublic:\\n    void dijkstra(vector<ll> &dist, int src, list<pair<int, int>> *l) {\\n        set<pair<ll, ll>> s;\\n        s.insert({dist[src], src});\\n        \\n        while(!s.empty()) {\\n            auto it = s.begin();\\n            pair<ll, ll> w_n = *it;\\n            s.erase(s.begin());\\n            ll node = w_n.second;\\n            ll d = w_n.first;\\n            for(auto p: l[node]) {\\n               if(dist[p.first] > d + p.second) {\\n                   auto it = s.find({dist[p.first], p.first});\\n                    if(it != s.end()) s.erase(it);\\n                    dist[p.first] = d + p.second;\\n                    s.insert({dist[p.first], p.first});\\n                }\\n            }\\n        }\\n        return;\\n    \\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        \\n        long long max_val = 10000000000;\\n        \\n        vector<ll> dist1(n, max_val);\\n        vector<ll> dist2(n, max_val);\\n        vector<ll> dist3(n, max_val);\\n         \\n        list<pair<int, int>> *l = new list<pair<int, int>>[n];\\n        list<pair<int, int>> *dd = new list<pair<int, int>>[n];\\n        \\n        for(int i = 0; i < edges.size(); i++) {\\n            l[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            dd[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n        dist1[src1] = 0;\\n        dist2[src2] = 0;\\n        dist3[dest] = 0;\\n        \\n        dijkstra(dist1, src1, l);\\n        dijkstra(dist2, src2, l);\\n        dijkstra(dist3, dest, dd);\\n        \\n        long long  min_len = LLONG_MAX;\\n        \\n        if(dist3[src1] == max_val || dist3[src2] == max_val) return -1;\\n        \\n        for(int i = 0; i < n; i++) {\\n            long long len = dist1[i] + dist2[i] + dist3[i];\\n            min_len = min(min_len, len); \\n        }\\n        \\n        return min_len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852639,
                "title": "python-3-bfs-with-comments",
                "content": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g = defaultdict(lambda: defaultdict(lambda: float(\\'inf\\')))\\n        for u, v, w in edges:\\n            g[u][v] = min(g[u][v], w)\\n            \\n        # first to calculate the optimal solution for distance from src node to other node\\n        def helper(start):\\n            vis1 = defaultdict(lambda: float(\\'inf\\'), {start: 0})\\n            q = [(0, start)]\\n            while q:\\n                s1, node1 = heappop(q)\\n                if node1 == dest:\\n                    continue\\n                for nei1 in g[node1]:\\n                    w1 = g[node1][nei1]\\n                    if vis1[nei1] <= s1 + w1: continue\\n                    vis1[nei1] = s1 + w1\\n                    heappush(q, (s1 + w1, nei1))\\n            return vis1\\n        \\n        vis1, vis2 = helper(src1), helper(src2)              \\n        # can\\'t reach destination               \\n        if dest not in vis1 or dest not in vis2: return -1        \\n        # distance after collided node\\n        def rest(start, vis):        \\n            q = [(0, start, 0)] # distance, current node, already collide with path from other source node\\n            tmp = defaultdict(lambda: float(\\'inf\\'), {(start, 0): 0})\\n            if start in vis: \\n                heappush(q, (vis[start], start, 1))\\n                tmp[start, 1] = vis[start]            \\n            while q:\\n                s2, node2, reached = heappop(q)\\n                if node2 == dest and reached: #not only need to reach dest but also need to collide with path from other source node\\n                    return s2\\n                for nei2 in g[node2]:\\n                    w2 = g[node2][nei2]\\n                    #if not collide before then check for collision\\n                    if not reached and nei2 in vis:\\n                        if tmp[(nei2, 1)] <= s2 + w2 + vis[dest]: continue\\n                        tmp[(nei2, 1)] = s2 + w2 + vis[nei2]\\n                        heappush(q, (s2 + w2 + vis[nei2], nei2, 1))\\n                    # otherwise goes for the rest path\\n                    else:\\n                        if tmp[(nei2, reached)] <= s2 + w2: continue\\n                        tmp[(nei2, reached)] = s2 + w2\\n                        heappush(q, (s2 + w2, nei2, reached))        \\n        return min(rest(src1, vis2), rest(src2, vis1))\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "class Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g = defaultdict(lambda: defaultdict(lambda: float(\\'inf\\')))\\n        for u, v, w in edges:\\n            g[u][v] = min(g[u][v], w)\\n            \\n        # first to calculate the optimal solution for distance from src node to other node\\n        def helper(start):\\n            vis1 = defaultdict(lambda: float(\\'inf\\'), {start: 0}",
                "codeTag": "Java"
            },
            {
                "id": 1852194,
                "title": "c-priority-queue-3-dijkstra",
                "content": "```\\n/*           [src1] --------->[middle]<------[dest]\\n                              |\\n             [src2]-----------^\\n             \\n            we find mimimum cost by letting every node as middle node\\n            \\n            BIG Q : why we need reverse graph ?\\n            Ans   : Because we want to know minimum cost from middle to destination.\\n                    if we did\\'t reverse graph then we have to call dijkstra from each node\\n                    and it is not good for time as well as memory\\n                    \\n                    By reversing the graph by one call dijkstra from dest to all other node we are\\n                    able to find minimum cost to reach that node\\n*/\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nusing ll = long long;\\nconst long long inf = 1e12;\\nconst int mx = 1e5;\\n\\nclass Solution {\\nprivate:\\n    void dijkstra(vector<vector<pair<ll, ll>>> &a, int s, vector<ll> &d, vector<int> &vis) {\\n        d[s] = 0;\\n        priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;\\n        pq.push({0, s});\\n\\n        while (!pq.empty()) {\\n            ll ver = pq.top().second;\\n            ll wt = pq.top().first;\\n            pq.pop();\\n\\n            if (vis[ver]) continue;\\n            vis[ver] = 1;\\n\\n            for (auto u : a[ver]) {\\n                ll to = u.first;\\n                ll w = u.second;\\n\\n                if (d[ver] + w < d[to]) {\\n                    d[to] = d[ver] + w;\\n                    pq.push({d[to], to});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        // Create adjacency matrix for the given graph\\n        if(edges.size() == 0) return -1;\\n        \\n        vector<vector<pair<ll, ll>>> adj(n), rev(n);\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            adj[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            rev[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n\\n        // d1 : from src1 to other node\\n        vector<ll> d1(n, inf);\\n        vector<int> vis(n, 0);\\n\\n        dijkstra(adj, src1, d1, vis);\\n        \\n        // d2 : from src2 to other node\\n        vector<ll> d2(n, inf);\\n        vis.assign(n, 0);\\n        dijkstra(adj, src2, d2, vis);\\n \\n        // from dest to other vertex (reversing the edges) \\n        vector<ll> d3(n, inf);\\n        vis.assign(n, 0);\\n        dijkstra(rev, dest, d3, vis);\\n    \\n\\n        ll ans = inf;\\n\\n        for (ll i = 0; i < n; i++) {\\n            ans = min(ans, d1[i] + d2[i] + d3[i]);\\n        }\\n        // means there is no way we reach to the dest from src1 or src2\\n        if (ans == inf) ans = -1;\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\n/*           [src1] --------->[middle]<------[dest]\\n                              |\\n             [src2]-----------^\\n             \\n            we find mimimum cost by letting every node as middle node\\n            \\n            BIG Q : why we need reverse graph ?\\n            Ans   : Because we want to know minimum cost from middle to destination.\\n                    if we did\\'t reverse graph then we have to call dijkstra from each node\\n                    and it is not good for time as well as memory\\n                    \\n                    By reversing the graph by one call dijkstra from dest to all other node we are\\n                    able to find minimum cost to reach that node\\n*/\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nusing ll = long long;\\nconst long long inf = 1e12;\\nconst int mx = 1e5;\\n\\nclass Solution {\\nprivate:\\n    void dijkstra(vector<vector<pair<ll, ll>>> &a, int s, vector<ll> &d, vector<int> &vis) {\\n        d[s] = 0;\\n        priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;\\n        pq.push({0, s});\\n\\n        while (!pq.empty()) {\\n            ll ver = pq.top().second;\\n            ll wt = pq.top().first;\\n            pq.pop();\\n\\n            if (vis[ver]) continue;\\n            vis[ver] = 1;\\n\\n            for (auto u : a[ver]) {\\n                ll to = u.first;\\n                ll w = u.second;\\n\\n                if (d[ver] + w < d[to]) {\\n                    d[to] = d[ver] + w;\\n                    pq.push({d[to], to});\\n                }\\n            }\\n        }\\n    }\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        // Create adjacency matrix for the given graph\\n        if(edges.size() == 0) return -1;\\n        \\n        vector<vector<pair<ll, ll>>> adj(n), rev(n);\\n\\n        for (int i = 0; i < edges.size(); i++) {\\n            adj[edges[i][0]].push_back({edges[i][1], edges[i][2]});\\n            rev[edges[i][1]].push_back({edges[i][0], edges[i][2]});\\n        }\\n\\n        // d1 : from src1 to other node\\n        vector<ll> d1(n, inf);\\n        vector<int> vis(n, 0);\\n\\n        dijkstra(adj, src1, d1, vis);\\n        \\n        // d2 : from src2 to other node\\n        vector<ll> d2(n, inf);\\n        vis.assign(n, 0);\\n        dijkstra(adj, src2, d2, vis);\\n \\n        // from dest to other vertex (reversing the edges) \\n        vector<ll> d3(n, inf);\\n        vis.assign(n, 0);\\n        dijkstra(rev, dest, d3, vis);\\n    \\n\\n        ll ans = inf;\\n\\n        for (ll i = 0; i < n; i++) {\\n            ans = min(ans, d1[i] + d2[i] + d3[i]);\\n        }\\n        // means there is no way we reach to the dest from src1 or src2\\n        if (ans == inf) ans = -1;\\n        \\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1851180,
                "title": "my-java-solution-involving-dijkstras-and-reversal-of-graph-with-comments",
                "content": "```\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        // reverse the graph\\n        // find the shortest distance from the current destination to all the cities\\n        // List<List<Pair>> reverseGraph = buildReverseGraph(edges, n);\\n        // List<List<Pair>> graph = buildNormalGraph(edges, n);\\n        List<List<Pair>> reverseGraph = new ArrayList<>();\\n        List<List<Pair>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            reverseGraph.add(new ArrayList<>());\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int [] edge : edges) {\\n            reverseGraph.get(edge[1]).add(new Pair(edge[0], edge[2]));\\n            graph.get(edge[0]).add(new Pair(edge[1], edge[2]));\\n        }\\n        // do dijkstra on src1, src2 on normal graph and for the dest, on the reverse graph\\n        long [] distanceFromSrc1 = new long [n];\\n        long [] distanceFromSrc2 = new long [n];\\n        long [] distanceFromDestination = new long [n];\\n        Arrays.fill(distanceFromSrc1, Long.MAX_VALUE);\\n        Arrays.fill(distanceFromSrc2, Long.MAX_VALUE);\\n        Arrays.fill(distanceFromDestination, Long.MAX_VALUE);\\n        distanceFromSrc1[src1] = 0l;\\n        distanceFromSrc2[src2] = 0l;\\n        distanceFromDestination[dest] = 0l;\\n        // do djiktra from the destination to all the cities and fill the distance array\\n        dijkstra(graph, distanceFromSrc1, src1);\\n        dijkstra(graph, distanceFromSrc2, src2);\\n        dijkstra(reverseGraph, distanceFromDestination, dest);\\n        // now we have all the distance array\\n        // avoiding the unreachable condition, take the min of dsrc1 + dsrc2 + ddest1\\n        long result = Long.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            if (distanceFromSrc1[i] == Long.MAX_VALUE || distanceFromSrc2[i] == Long.MAX_VALUE || distanceFromDestination[i] == Long.MAX_VALUE) {\\n                continue;\\n            }\\n            result = Math.min(result, distanceFromSrc1[i] + distanceFromSrc2[i] + distanceFromDestination[i]);\\n        }\\n        return result == Long.MAX_VALUE ? -1 : result;\\n    }\\n    \\n    public void dijkstra(List<List<Pair>> graph, long [] distance, int dest) {\\n        // we need minheap for dijkstra\\n        PriorityQueue<Pair> minHeap = new PriorityQueue<>((pair1, pair2) -> Long.compare(pair1.weight, pair2.weight));\\n        minHeap.offer(new Pair(dest, 0));\\n        while (!minHeap.isEmpty()) {\\n            Pair currentPair = minHeap.poll();\\n            int node = currentPair.node;\\n            long weight = currentPair.weight;\\n            if (weight > distance[node]) {\\n                continue;\\n            } // this one line will get rid of TLE\\n            List<Pair> children = graph.get(node);\\n            for (Pair child : children) {\\n                if (distance[node] + child.weight < distance[child.node]) {\\n                    distance[child.node] = distance[node] + child.weight;\\n                    minHeap.offer(new Pair(child.node, distance[child.node]));\\n                }\\n            }\\n        }\\n    }\\n    \\n    public List<List<Pair>> buildReverseGraph(int [][] edges, int n) {\\n        List<List<Pair>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int [] edge : edges) {\\n            graph.get(edge[1]).add(new Pair(edge[0], edge[2]));\\n        }\\n        return graph;\\n    }\\n    \\n    public List<List<Pair>> buildNormalGraph(int [][] edges, int n) {\\n        List<List<Pair>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int [] edge : edges) {\\n            graph.get(edge[0]).add(new Pair(edge[1], edge[2]));\\n        }\\n        return graph;\\n    }\\n}\\n\\nclass Pair {\\n    int node;\\n    long weight;\\n    public Pair(int node, long weight) {\\n        this.node = node;\\n        this.weight = weight;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        // reverse the graph\\n        // find the shortest distance from the current destination to all the cities\\n        // List<List<Pair>> reverseGraph = buildReverseGraph(edges, n);\\n        // List<List<Pair>> graph = buildNormalGraph(edges, n);\\n        List<List<Pair>> reverseGraph = new ArrayList<>();\\n        List<List<Pair>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            reverseGraph.add(new ArrayList<>());\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int [] edge : edges) {\\n            reverseGraph.get(edge[1]).add(new Pair(edge[0], edge[2]));\\n            graph.get(edge[0]).add(new Pair(edge[1], edge[2]));\\n        }\\n        // do dijkstra on src1, src2 on normal graph and for the dest, on the reverse graph\\n        long [] distanceFromSrc1 = new long [n];\\n        long [] distanceFromSrc2 = new long [n];\\n        long [] distanceFromDestination = new long [n];\\n        Arrays.fill(distanceFromSrc1, Long.MAX_VALUE);\\n        Arrays.fill(distanceFromSrc2, Long.MAX_VALUE);\\n        Arrays.fill(distanceFromDestination, Long.MAX_VALUE);\\n        distanceFromSrc1[src1] = 0l;\\n        distanceFromSrc2[src2] = 0l;\\n        distanceFromDestination[dest] = 0l;\\n        // do djiktra from the destination to all the cities and fill the distance array\\n        dijkstra(graph, distanceFromSrc1, src1);\\n        dijkstra(graph, distanceFromSrc2, src2);\\n        dijkstra(reverseGraph, distanceFromDestination, dest);\\n        // now we have all the distance array\\n        // avoiding the unreachable condition, take the min of dsrc1 + dsrc2 + ddest1\\n        long result = Long.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            if (distanceFromSrc1[i] == Long.MAX_VALUE || distanceFromSrc2[i] == Long.MAX_VALUE || distanceFromDestination[i] == Long.MAX_VALUE) {\\n                continue;\\n            }\\n            result = Math.min(result, distanceFromSrc1[i] + distanceFromSrc2[i] + distanceFromDestination[i]);\\n        }\\n        return result == Long.MAX_VALUE ? -1 : result;\\n    }\\n    \\n    public void dijkstra(List<List<Pair>> graph, long [] distance, int dest) {\\n        // we need minheap for dijkstra\\n        PriorityQueue<Pair> minHeap = new PriorityQueue<>((pair1, pair2) -> Long.compare(pair1.weight, pair2.weight));\\n        minHeap.offer(new Pair(dest, 0));\\n        while (!minHeap.isEmpty()) {\\n            Pair currentPair = minHeap.poll();\\n            int node = currentPair.node;\\n            long weight = currentPair.weight;\\n            if (weight > distance[node]) {\\n                continue;\\n            } // this one line will get rid of TLE\\n            List<Pair> children = graph.get(node);\\n            for (Pair child : children) {\\n                if (distance[node] + child.weight < distance[child.node]) {\\n                    distance[child.node] = distance[node] + child.weight;\\n                    minHeap.offer(new Pair(child.node, distance[child.node]));\\n                }\\n            }\\n        }\\n    }\\n    \\n    public List<List<Pair>> buildReverseGraph(int [][] edges, int n) {\\n        List<List<Pair>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int [] edge : edges) {\\n            graph.get(edge[1]).add(new Pair(edge[0], edge[2]));\\n        }\\n        return graph;\\n    }\\n    \\n    public List<List<Pair>> buildNormalGraph(int [][] edges, int n) {\\n        List<List<Pair>> graph = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for (int [] edge : edges) {\\n            graph.get(edge[0]).add(new Pair(edge[1], edge[2]));\\n        }\\n        return graph;\\n    }\\n}\\n\\nclass Pair {\\n    int node;\\n    long weight;\\n    public Pair(int node, long weight) {\\n        this.node = node;\\n        this.weight = weight;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850655,
                "title": "java-3-time-dijkstra-with-comments",
                "content": "```\\n\\nclass Solution {\\n    int n;\\n    \\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        this.n = n;\\n        // Dijkstra will find shortest path for all nodes in graph\\n        // do Dijkstra for src1, src2 and dest, then find the node with shortest distance to all 3 nodes\\n        List<int[]>[] graph = new ArrayList[n];\\n        // for dest to be able to reach others since this is a directed graph\\n        List<int[]>[] reverseGraph = new ArrayList[n];\\n        \\n        for(int[] edge: edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int cost = edge[2];\\n            \\n            if(graph[from] == null) graph[from] = new ArrayList<int[]>();\\n            graph[from].add(new int[]{to, cost});\\n            \\n            if(reverseGraph[to] == null) reverseGraph[to] = new ArrayList<int[]>();\\n            reverseGraph[to].add(new int[]{from, cost});\\n        }\\n        \\n        Long[] dist1 = dijkstra(graph, src1);\\n        Long[] dist2 = dijkstra(graph, src2);\\n        Long[] dist3 = dijkstra(reverseGraph, dest);\\n        \\n        Long minLen = null;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(dist1[i] != null && dist2[i] != null && dist3[i] != null) {\\n                long sum = dist1[i] + dist2[i] + dist3[i];\\n                if(minLen == null) minLen = sum;\\n                minLen = Math.min(minLen, sum);\\n            }\\n        }\\n        \\n        return minLen == null ? -1: minLen;\\n    }\\n    \\n    class NodeDist{\\n        int node;\\n        long dist;\\n        \\n        NodeDist(int node, long dist) {\\n            this.node = node;\\n            this.dist = dist;\\n        }\\n    }\\n    \\n    \\n    private Long[] dijkstra(List<int[]>[] graph, int start) {\\n        Long[] allDist = new Long[n];\\n        //item[0] stores node, item[1] stores distance from start\\n        PriorityQueue<NodeDist> q = new PriorityQueue<NodeDist>((a,b)->{\\n            long res = a.dist-b.dist;\\n            if(res < 0) return -1;\\n            return 1;\\n        });\\n        q.offer(new NodeDist(start, 0));\\n        \\n        while(!q.isEmpty()) {\\n            NodeDist cur = q.poll();\\n            int node = cur.node;\\n            long dist = cur.dist;\\n            \\n            if(allDist[node] != null && allDist[node] < dist) continue;\\n            allDist[node] = dist;\\n            \\n            List<int[]> adjNodes = graph[node];\\n            if(adjNodes == null) continue;\\n            \\n            for(int[] adjNode: adjNodes) {\\n                int newNode = adjNode[0];\\n                int newNodeCost = adjNode[1];\\n                \\n                long newDist = dist + newNodeCost;\\n                \\n                if(allDist[newNode] == null || newDist < allDist[newNode]) {\\n                    allDist[newNode] = newDist;\\n                    q.offer(new NodeDist(newNode, newDist));\\n                }\\n            }\\n        }\\n        \\n        return allDist;\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    int n;\\n    \\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        this.n = n;\\n        // Dijkstra will find shortest path for all nodes in graph\\n        // do Dijkstra for src1, src2 and dest, then find the node with shortest distance to all 3 nodes\\n        List<int[]>[] graph = new ArrayList[n];\\n        // for dest to be able to reach others since this is a directed graph\\n        List<int[]>[] reverseGraph = new ArrayList[n];\\n        \\n        for(int[] edge: edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int cost = edge[2];\\n            \\n            if(graph[from] == null) graph[from] = new ArrayList<int[]>();\\n            graph[from].add(new int[]{to, cost});\\n            \\n            if(reverseGraph[to] == null) reverseGraph[to] = new ArrayList<int[]>();\\n            reverseGraph[to].add(new int[]{from, cost});\\n        }\\n        \\n        Long[] dist1 = dijkstra(graph, src1);\\n        Long[] dist2 = dijkstra(graph, src2);\\n        Long[] dist3 = dijkstra(reverseGraph, dest);\\n        \\n        Long minLen = null;\\n        \\n        for(int i = 0; i < n; i++) {\\n            if(dist1[i] != null && dist2[i] != null && dist3[i] != null) {\\n                long sum = dist1[i] + dist2[i] + dist3[i];\\n                if(minLen == null) minLen = sum;\\n                minLen = Math.min(minLen, sum);\\n            }\\n        }\\n        \\n        return minLen == null ? -1: minLen;\\n    }\\n    \\n    class NodeDist{\\n        int node;\\n        long dist;\\n        \\n        NodeDist(int node, long dist) {\\n            this.node = node;\\n            this.dist = dist;\\n        }\\n    }\\n    \\n    \\n    private Long[] dijkstra(List<int[]>[] graph, int start) {\\n        Long[] allDist = new Long[n];\\n        //item[0] stores node, item[1] stores distance from start\\n        PriorityQueue<NodeDist> q = new PriorityQueue<NodeDist>((a,b)->{\\n            long res = a.dist-b.dist;\\n            if(res < 0) return -1;\\n            return 1;\\n        });\\n        q.offer(new NodeDist(start, 0));\\n        \\n        while(!q.isEmpty()) {\\n            NodeDist cur = q.poll();\\n            int node = cur.node;\\n            long dist = cur.dist;\\n            \\n            if(allDist[node] != null && allDist[node] < dist) continue;\\n            allDist[node] = dist;\\n            \\n            List<int[]> adjNodes = graph[node];\\n            if(adjNodes == null) continue;\\n            \\n            for(int[] adjNode: adjNodes) {\\n                int newNode = adjNode[0];\\n                int newNodeCost = adjNode[1];\\n                \\n                long newDist = dist + newNodeCost;\\n                \\n                if(allDist[newNode] == null || newDist < allDist[newNode]) {\\n                    allDist[newNode] = newDist;\\n                    q.offer(new NodeDist(newNode, newDist));\\n                }\\n            }\\n        }\\n        \\n        return allDist;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850430,
                "title": "c-simple-and-short-3-dijsktras",
                "content": "```\\nvoid dijsktra(int src, vector<long> &d, vector<vector<pair<int, int>>> &adj) {\\n        priority_queue<pair<long, int>, vector<pair<long, int>>, greater<pair<long, int>> > pq;\\n        d[src] = 0;\\n        pq.push({0, src});\\n        \\n        while(!pq.empty()) {\\n            int node = pq.top().second;\\n            long dist = pq.top().first;\\n            pq.pop();\\n            if(dist > d[node]) continue;\\n            for(auto &it : adj[node]) {\\n                int v = it.first;\\n                long w = it.second;\\n                if(dist + w < d[v]) {\\n                    d[v] = dist + w;\\n                    pq.push({d[v], v});\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int, int>>> adj(n), radj(n);\\n        for(auto& it : edges) {\\n            int u = it[0], v = it[1], w = it[2];\\n            adj[u].push_back({v, w});\\n            radj[v].push_back({u, w});\\n            // adj[u].push_back(w);\\n        }\\n        vector<long > da(n, LONG_MAX), db(n, LONG_MAX), dd(n, LONG_MAX);\\n        dijsktra(src1, da, adj);\\n        dijsktra(src2, db, adj);\\n        dijsktra(dest, dd, radj);\\n        \\n        long ans = LONG_MAX;\\n        for(int i = 0; i < n; i++) {\\n            if(da[i] == LONG_MAX or db[i] == LONG_MAX or dd[i] == LONG_MAX) continue;\\n            // cout << da[i] + db[i] + dd[i] << endl;\\n            ans = min(ans, da[i] + db[i] + dd[i]);\\n        }\\n        return ans == LONG_MAX ? -1 : ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid dijsktra(int src, vector<long> &d, vector<vector<pair<int, int>>> &adj) {\\n        priority_queue<pair<long, int>, vector<pair<long, int>>, greater<pair<long, int>> > pq;\\n        d[src] = 0;\\n        pq.push({0, src});\\n        \\n        while(!pq.empty()) {\\n            int node = pq.top().second;\\n            long dist = pq.top().first;\\n            pq.pop();\\n            if(dist > d[node]) continue;\\n            for(auto &it : adj[node]) {\\n                int v = it.first;\\n                long w = it.second;\\n                if(dist + w < d[v]) {\\n                    d[v] = dist + w;\\n                    pq.push({d[v], v});\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int, int>>> adj(n), radj(n);\\n        for(auto& it : edges) {\\n            int u = it[0], v = it[1], w = it[2];\\n            adj[u].push_back({v, w});\\n            radj[v].push_back({u, w});\\n            // adj[u].push_back(w);\\n        }\\n        vector<long > da(n, LONG_MAX), db(n, LONG_MAX), dd(n, LONG_MAX);\\n        dijsktra(src1, da, adj);\\n        dijsktra(src2, db, adj);\\n        dijsktra(dest, dd, radj);\\n        \\n        long ans = LONG_MAX;\\n        for(int i = 0; i < n; i++) {\\n            if(da[i] == LONG_MAX or db[i] == LONG_MAX or dd[i] == LONG_MAX) continue;\\n            // cout << da[i] + db[i] + dd[i] << endl;\\n            ans = min(ans, da[i] + db[i] + dd[i]);\\n        }\\n        return ans == LONG_MAX ? -1 : ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 1850335,
                "title": "c-700-ms-83-61-134-9-mb-88-10-dijkstra-o-nlogn",
                "content": "My idea is as follows:\\n- Consider a certain node on a given graph\\n- Calculate each distance from the node to `src1`, `src2`, `dest`.\\n- Find the minimum sum over the above distance.\\n\\nFirst, make a graph. In my code, the graph is denoted by `vector<vector<std::pair<int, int>>>`.\\nIt is known that the minimum distance from the given point `s` to other point `v` can be acquired using\\nDijkstra algorithm. The complexity is O(n log n), where n is the number of nodes.\\n\\nTo calculate the distance from a given node to `dest`, the graph has to be flipped.\\nThen, the desired distance (each distance from `dest` to a node) can be calculated with this flipped graph.\\nThe complexity is O(n log n).\\n\\nFinally, the minimum distance is easily found.\\nThe complexity is O(n log n).\\n\\n\\n\\n```c++\\nusing p = std::pair<int, int>;\\nusing ll = long long int;\\nclass Solution {\\npublic:\\n    static constexpr ll INF = (ll)(1e10 + 1);\\n    vector<vector<p>> G;\\n    vector<vector<p>> reverseG;\\n    \\n    void set_graph(int n, vector<vector<int>>& edges){\\n        G.assign(n, vector<p>());\\n        reverseG.assign(n, vector<p>());\\n        for(int i=0;i<edges.size();i++){\\n            G[edges[i][0]].emplace_back(edges[i][1], edges[i][2]);\\n            reverseG[edges[i][1]].emplace_back(edges[i][0], edges[i][2]);\\n        }\\n    }\\n    \\n    void dijkstra(int s, vector<vector<p>>& G, vector<ll>& d){\\n        int n = d.size();\\n        std::priority_queue<p, std::vector<p>, std::greater<p>> que;\\n        d.assign(n, INF);\\n        d[s] = 0;\\n        que.push(p(0,s));\\n\\n        while(que.size() > 0){\\n           p item = que.top();\\n           que.pop();\\n           int v = item.second;\\n           if(d[v] < item.first)\\n              continue;\\n           for(int i=0;i<G[v].size();i++){\\n              p e = G[v][i];\\n              if(d[e.first] > d[v] + e.second){\\n\\t            d[e.first] = d[v] + e.second;\\n                que.push(p(d[e.first], e.first));\\n              }\\n           }\\n       }\\n    }\\n    \\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        set_graph(n, edges);\\n        vector<ll> dsrc1(n);\\n        vector<ll> dsrc2(n);\\n        vector<ll> ddest(n);\\n        dijkstra(src1, G, dsrc1);\\n        dijkstra(src2, G, dsrc2);\\n        dijkstra(dest, reverseG, ddest);\\n        ll res = INF;\\n        for(int i=0;i<n;i++){\\n            ll length = dsrc1[i] + dsrc2[i] + ddest[i];\\n            if(res > length)\\n                res = length;\\n        }\\n        if(res == INF)\\n            res = -1;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nusing p = std::pair<int, int>;\\nusing ll = long long int;\\nclass Solution {\\npublic:\\n    static constexpr ll INF = (ll)(1e10 + 1);\\n    vector<vector<p>> G;\\n    vector<vector<p>> reverseG;\\n    \\n    void set_graph(int n, vector<vector<int>>& edges){\\n        G.assign(n, vector<p>());\\n        reverseG.assign(n, vector<p>());\\n        for(int i=0;i<edges.size();i++){\\n            G[edges[i][0]].emplace_back(edges[i][1], edges[i][2]);\\n            reverseG[edges[i][1]].emplace_back(edges[i][0], edges[i][2]);\\n        }\\n    }\\n    \\n    void dijkstra(int s, vector<vector<p>>& G, vector<ll>& d){\\n        int n = d.size();\\n        std::priority_queue<p, std::vector<p>, std::greater<p>> que;\\n        d.assign(n, INF);\\n        d[s] = 0;\\n        que.push(p(0,s));\\n\\n        while(que.size() > 0){\\n           p item = que.top();\\n           que.pop();\\n           int v = item.second;\\n           if(d[v] < item.first)\\n              continue;\\n           for(int i=0;i<G[v].size();i++){\\n              p e = G[v][i];\\n              if(d[e.first] > d[v] + e.second){\\n\\t            d[e.first] = d[v] + e.second;\\n                que.push(p(d[e.first], e.first));\\n              }\\n           }\\n       }\\n    }\\n    \\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        set_graph(n, edges);\\n        vector<ll> dsrc1(n);\\n        vector<ll> dsrc2(n);\\n        vector<ll> ddest(n);\\n        dijkstra(src1, G, dsrc1);\\n        dijkstra(src2, G, dsrc2);\\n        dijkstra(dest, reverseG, ddest);\\n        ll res = INF;\\n        for(int i=0;i<n;i++){\\n            ll length = dsrc1[i] + dsrc2[i] + ddest[i];\\n            if(res > length)\\n                res = length;\\n        }\\n        if(res == INF)\\n            res = -1;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850170,
                "title": "java-3-dijkstra",
                "content": "```java\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        // build graphs.\\n        Map<Integer, Integer>[] g1 = new Map[n], g2 = new Map[n];\\n        for (int[] edge: edges) {\\n            int s1 = edge[0], s2 = edge[1], w = edge[2];\\n            if (g1[s1] == null) {\\n                g1[s1] = new HashMap<Integer, Integer>();\\n            }\\n            // the test cases contain repeated edges with diff weights -.-\\n            g1[s1].put(s2, Math.min(w, g1[s1].getOrDefault(s2, Integer.MAX_VALUE)));\\n            \\n            if (g2[s2] == null) {\\n                g2[s2] = new HashMap<Integer, Integer>();\\n            }\\n            g2[s2].put(s1, Math.min(w, g2[s2].getOrDefault(s1, Integer.MAX_VALUE)));\\n        }\\n        \\n        // perform dijkstra to get the shortest distance to every other node.\\n        Long[] dist1 = dijkstra(g1, src1);\\n        Long[] dist2 = dijkstra(g1, src2);\\n        Long[] dist3 = dijkstra(g2, dest);\\n\\n        // find min of sum(dist1, dist2, dist3) on each node\\n        Long res = null;\\n        for (int i = 0; i < n; i += 1) {\\n            if (dist1[i] != null && dist2[i] != null && dist3[i] != null) {\\n                long sum = dist1[i] + dist2[i] + dist3[i];\\n                if (res == null || res > sum) {\\n                    res = sum;\\n                }\\n            }\\n        }\\n        return res == null ? -1 : res;\\n    }\\n    \\n    Long[] dijkstra(Map<Integer, Integer>[] graph, int start) {\\n        Long[] res = new Long[graph.length];\\n        // [dist, weight]\\n        PriorityQueue<State> q = new PriorityQueue<State>((a, b) -> Long.compare(a.w, b.w));\\n        q.offer(new State(start, 0L));\\n        while (!q.isEmpty()) {\\n            State cur = q.poll();\\n            if (res[cur.id] != null) continue;\\n            res[cur.id] = (long)cur.w;\\n            \\n            if (graph[cur.id] != null) {\\n                for (int next: graph[cur.id].keySet()) {\\n                    if (res[next] == null) {\\n                        q.offer(new State(next, cur.w + graph[cur.id].get(next)));\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\nclass State {\\n    long w;\\n    int id;\\n    \\n    State(int id, long w) {\\n        this.id = id;\\n        this.w = w;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        // build graphs.\\n        Map<Integer, Integer>[] g1 = new Map[n], g2 = new Map[n];\\n        for (int[] edge: edges) {\\n            int s1 = edge[0], s2 = edge[1], w = edge[2];\\n            if (g1[s1] == null) {\\n                g1[s1] = new HashMap<Integer, Integer>();\\n            }\\n            // the test cases contain repeated edges with diff weights -.-\\n            g1[s1].put(s2, Math.min(w, g1[s1].getOrDefault(s2, Integer.MAX_VALUE)));\\n            \\n            if (g2[s2] == null) {\\n                g2[s2] = new HashMap<Integer, Integer>();\\n            }\\n            g2[s2].put(s1, Math.min(w, g2[s2].getOrDefault(s1, Integer.MAX_VALUE)));\\n        }\\n        \\n        // perform dijkstra to get the shortest distance to every other node.\\n        Long[] dist1 = dijkstra(g1, src1);\\n        Long[] dist2 = dijkstra(g1, src2);\\n        Long[] dist3 = dijkstra(g2, dest);\\n\\n        // find min of sum(dist1, dist2, dist3) on each node\\n        Long res = null;\\n        for (int i = 0; i < n; i += 1) {\\n            if (dist1[i] != null && dist2[i] != null && dist3[i] != null) {\\n                long sum = dist1[i] + dist2[i] + dist3[i];\\n                if (res == null || res > sum) {\\n                    res = sum;\\n                }\\n            }\\n        }\\n        return res == null ? -1 : res;\\n    }\\n    \\n    Long[] dijkstra(Map<Integer, Integer>[] graph, int start) {\\n        Long[] res = new Long[graph.length];\\n        // [dist, weight]\\n        PriorityQueue<State> q = new PriorityQueue<State>((a, b) -> Long.compare(a.w, b.w));\\n        q.offer(new State(start, 0L));\\n        while (!q.isEmpty()) {\\n            State cur = q.poll();\\n            if (res[cur.id] != null) continue;\\n            res[cur.id] = (long)cur.w;\\n            \\n            if (graph[cur.id] != null) {\\n                for (int next: graph[cur.id].keySet()) {\\n                    if (res[next] == null) {\\n                        q.offer(new State(next, cur.w + graph[cur.id].get(next)));\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\nclass State {\\n    long w;\\n    int id;\\n    \\n    State(int id, long w) {\\n        this.id = id;\\n        this.w = w;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849996,
                "title": "simple-dfs-back-tracking-beats-all-in-time",
                "content": "We can simply use DFS to find all the paths from *src1* to *dest*. And then for each of the paths(or `subgraph`s), run dijkstra for src2.\\n\\nWe just need to be careful about loops in this directed graph. To do that use used the `expanded_count` array.\\n\\nAlso we did limit the branching using our minimum `result` to beat all the posted solution in time. In that way it is `depth-limited search`.\\n\\nAdding little bit of sorting makes the algorithm converge faster,\\n\\n```\\n        edges.sort(key=itemgetter(2),reverse=True)\\n```\\n\\n```\\n\\n\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        edges.sort(key=itemgetter(2),reverse=True)\\n        \\n        streams = [[] for _ in range(n)]\\n        for eid,(u,v,w) in enumerate(edges):\\n            streams[v].append((w,u,eid))\\n\\n        # apply dijkstra\\n        # now starting from dest, try to form the subgraphs\\n        def dijkstra(subgraph, target_src):\\n            shortest = dict()\\n            shortest[dest] = (0,-1)\\n            expanded = set()\\n            subs = [(0,dest)]\\n            while subs:\\n                cost,v = heappop(subs)\\n                if v in expanded:\\n                    continue\\n                expanded.add(v)\\n                if target_src in expanded:\\n                    break\\n                for w,u,eid in streams[v]:\\n                    if eid in subgraph:\\n                        w = 0\\n                    if u not in shortest or shortest[u][0] > (w+cost):\\n                        shortest[u] = (w+cost,eid)\\n                        heappush(subs,(w+cost,u))\\n            # calculate total cost\\n            if target_src in shortest:\\n                return shortest[target_src][0]\\n            return None\\n\\n        cost11,cost22=dijkstra(set(), src1),dijkstra(set(),src2)\\n        if cost11 is None or cost22 is None:\\n            return -1\\n        result = cost11+cost22\\n        expanded_count = [0]*(n+1)\\n        # explore all edges\\n        EXPLORED,EXPANDED = 0,1\\n        stack = [[0,-1,-1,EXPLORED,None]]\\n        while stack:\\n            cost1,parent_eid,grand_parent,status,parent_vertices = stack[-1]\\n            #print(\\'peid\\', parent_eid)\\n            curr = edges[parent_eid][0] if parent_eid >= 0 else dest\\n            #print(\"Reached, curr\", curr)\\n            if curr == src1:\\n                # reconstruct path\\n                gp = grand_parent\\n                peid = parent_eid\\n                path = {peid}\\n                while gp != -1:\\n                    pcost,peid,gp,unused,pset = stack[gp]\\n                    if pset is not None:\\n                        path |= pset\\n                        break\\n                    path.add(peid)\\n                stack.pop() # Backtrack\\n                #print(\\'Emit path\\', path)\\n                cost2 = dijkstra(path,src2)\\n                result = min(result,cost1+cost2) # relax\\n                if grand_parent != -1:\\n                    if stack[grand_parent][-1] is None:\\n                        path.remove(parent_eid)\\n                        stack[grand_parent][-1] = path\\n            elif status == EXPLORED:\\n                expanded_count[curr] += 1\\n                stack[-1][3] = EXPANDED # mark expanded\\n                idx = len(stack)-1\\n                for w,u,eid in streams[curr]:\\n                    if expanded_count[u] > 0:\\n                        #print(\"Detected loop\")\\n                        continue # avoid loop\\n                    if result < (cost1+w):\\n                        continue # pruning \\n                    stack.append([cost1+w,eid,idx,EXPLORED,None])\\n            elif status == EXPANDED:\\n                # Backtrack\\n                expanded_count[curr] -= 1\\n                path = parent_vertices\\n                if path is not None and grand_parent != -1:\\n                    if stack[grand_parent][-1] is None:\\n                        path.remove(parent_eid)\\n                        stack[grand_parent][-1] = path\\n                stack.pop()\\n\\n                    \\n        return result if result is not None else -1\\n```",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\n        edges.sort(key=itemgetter(2),reverse=True)\\n```\n```\\n\\n\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        edges.sort(key=itemgetter(2),reverse=True)\\n        \\n        streams = [[] for _ in range(n)]\\n        for eid,(u,v,w) in enumerate(edges):\\n            streams[v].append((w,u,eid))\\n\\n        # apply dijkstra\\n        # now starting from dest, try to form the subgraphs\\n        def dijkstra(subgraph, target_src):\\n            shortest = dict()\\n            shortest[dest] = (0,-1)\\n            expanded = set()\\n            subs = [(0,dest)]\\n            while subs:\\n                cost,v = heappop(subs)\\n                if v in expanded:\\n                    continue\\n                expanded.add(v)\\n                if target_src in expanded:\\n                    break\\n                for w,u,eid in streams[v]:\\n                    if eid in subgraph:\\n                        w = 0\\n                    if u not in shortest or shortest[u][0] > (w+cost):\\n                        shortest[u] = (w+cost,eid)\\n                        heappush(subs,(w+cost,u))\\n            # calculate total cost\\n            if target_src in shortest:\\n                return shortest[target_src][0]\\n            return None\\n\\n        cost11,cost22=dijkstra(set(), src1),dijkstra(set(),src2)\\n        if cost11 is None or cost22 is None:\\n            return -1\\n        result = cost11+cost22\\n        expanded_count = [0]*(n+1)\\n        # explore all edges\\n        EXPLORED,EXPANDED = 0,1\\n        stack = [[0,-1,-1,EXPLORED,None]]\\n        while stack:\\n            cost1,parent_eid,grand_parent,status,parent_vertices = stack[-1]\\n            #print(\\'peid\\', parent_eid)\\n            curr = edges[parent_eid][0] if parent_eid >= 0 else dest\\n            #print(\"Reached, curr\", curr)\\n            if curr == src1:\\n                # reconstruct path\\n                gp = grand_parent\\n                peid = parent_eid\\n                path = {peid}\\n                while gp != -1:\\n                    pcost,peid,gp,unused,pset = stack[gp]\\n                    if pset is not None:\\n                        path |= pset\\n                        break\\n                    path.add(peid)\\n                stack.pop() # Backtrack\\n                #print(\\'Emit path\\', path)\\n                cost2 = dijkstra(path,src2)\\n                result = min(result,cost1+cost2) # relax\\n                if grand_parent != -1:\\n                    if stack[grand_parent][-1] is None:\\n                        path.remove(parent_eid)\\n                        stack[grand_parent][-1] = path\\n            elif status == EXPLORED:\\n                expanded_count[curr] += 1\\n                stack[-1][3] = EXPANDED # mark expanded\\n                idx = len(stack)-1\\n                for w,u,eid in streams[curr]:\\n                    if expanded_count[u] > 0:\\n                        #print(\"Detected loop\")\\n                        continue # avoid loop\\n                    if result < (cost1+w):\\n                        continue # pruning \\n                    stack.append([cost1+w,eid,idx,EXPLORED,None])\\n            elif status == EXPANDED:\\n                # Backtrack\\n                expanded_count[curr] -= 1\\n                path = parent_vertices\\n                if path is not None and grand_parent != -1:\\n                    if stack[grand_parent][-1] is None:\\n                        path.remove(parent_eid)\\n                        stack[grand_parent][-1] = path\\n                stack.pop()\\n\\n                    \\n        return result if result is not None else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849835,
                "title": "python-looking-for-feedback-77-explained",
                "content": "Any feasible subgraph shape:\\n- reachable from src1\\n- reachable from src2\\n- can reach dest\\n\\nFor the optinal solution, it happens that the cost of this subgraph is equal to the sum of the three parts (in other words, sum of the three parts is the upper bound of cost of each subgraph)\\n\\nTo find the optimal, you just need to find all the upperbounds and choose the smallest one.\\n\\n\\n\\nConstruct 2 distance maps:\\n1. minimum distance from src1 to current node (d1);\\n2. minimum distance from src2 to current node (d2);\\n3. minimum distance from current node to dest (dd);\\n\\nTo construct each distance maps, we just traverse the whole graph (as in function \"calc\")\\n\\nTo find the optinal answer, one need to check every distance maps and find the min of (d1 + d2 + dd)\\n\\n\\n```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        from collections import defaultdict\\n        \\n        em = defaultdict(list)\\n        rm = defaultdict(list)\\n        for o,d,c in edges:\\n            em[o].append([d,c])\\n            rm[d].append([o,c])\\n        \\n        def calc(edge_map, src):\\n            # helper function to compute distances from src\\n            dis_map = [-1]*n\\n            dis_map[src] = 0\\n            \\n            stack = [src]\\n            \\n            while stack:\\n                node = stack[0]\\n                stack.pop(0)\\n                visited = set([src])\\n                \\n                for next_node, cost in edge_map[node]:\\n                    if dis_map[next_node] == -1 or dis_map[next_node] > dis_map[node] + cost:\\n                        dis_map[next_node] = dis_map[node] + cost\\n                        if next_node not in visited:\\n                            stack.append(next_node)\\n                            visited.add(next_node)\\n            return dis_map\\n        \\n        d1 = calc(em, src1)\\n        d2 = calc(em, src2)\\n        dd = calc(rm, dest)\\n        \\n        if d1[dest] == -1 or d2[dest] == -1:\\n            return -1\\n        ans = d1[dest] + d2[dest]\\n        for node in range(0, n):\\n            if d1[node] == -1 or d2[node]==-1 or dd[node]==-1:\\n                continue\\n            ans = min(ans, d1[node]+d2[node]+dd[node])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        from collections import defaultdict\\n        \\n        em = defaultdict(list)\\n        rm = defaultdict(list)\\n        for o,d,c in edges:\\n            em[o].append([d,c])\\n            rm[d].append([o,c])\\n        \\n        def calc(edge_map, src):\\n            # helper function to compute distances from src\\n            dis_map = [-1]*n\\n            dis_map[src] = 0\\n            \\n            stack = [src]\\n            \\n            while stack:\\n                node = stack[0]\\n                stack.pop(0)\\n                visited = set([src])\\n                \\n                for next_node, cost in edge_map[node]:\\n                    if dis_map[next_node] == -1 or dis_map[next_node] > dis_map[node] + cost:\\n                        dis_map[next_node] = dis_map[node] + cost\\n                        if next_node not in visited:\\n                            stack.append(next_node)\\n                            visited.add(next_node)\\n            return dis_map\\n        \\n        d1 = calc(em, src1)\\n        d2 = calc(em, src2)\\n        dd = calc(rm, dest)\\n        \\n        if d1[dest] == -1 or d2[dest] == -1:\\n            return -1\\n        ans = d1[dest] + d2[dest]\\n        for node in range(0, n):\\n            if d1[node] == -1 or d2[node]==-1 or dd[node]==-1:\\n                continue\\n            ans = min(ans, d1[node]+d2[node]+dd[node])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849675,
                "title": "1-single-dijkstras-is-all-you-need",
                "content": "Passed all test cases, but happy to have some comments here if there\\'s any better ways to simplify the code logic!\\n\\n\\n```\\nclass Solution {\\n    public long INFINITY = Long.MAX_VALUE;\\n    class Node {\\n        public int id;\\n        public long fromS1, fromS2, fromS1S2;\\n        public List<Node> toList;\\n        public List<Integer> weights;\\n        public Node(int id) {\\n            this.id=id;\\n            fromS1=fromS2=fromS1S2=INFINITY;\\n            this.toList=new ArrayList<>();\\n            this.weights=new ArrayList<>();\\n        }\\n        public void add(Node n, int weight) {\\n            this.toList.add(n);\\n            this.weights.add(weight);\\n        }\\n        public boolean updateDist(Node pNode, int weight) { // pNode->curNode\\n            boolean isAnyUpdate=false;\\n            if(pNode.fromS1!=INFINITY && this.fromS1>pNode.fromS1+weight){\\n                this.fromS1 = pNode.fromS1+weight;\\n                isAnyUpdate = true;\\n            } \\n            if(pNode.fromS2!=INFINITY&&this.fromS2>pNode.fromS2+weight) {\\n                this.fromS2 = pNode.fromS2+weight;\\n                isAnyUpdate = true;\\n            }\\n            if(pNode.fromS1S2!=INFINITY && this.fromS1S2> pNode.fromS1S2+weight) {\\n                this.fromS1S2 = pNode.fromS1S2+weight;\\n                isAnyUpdate = true;\\n            }\\n            if(this.fromS1!=INFINITY&&this.fromS2!=INFINITY && this.fromS1S2 > this.fromS1+this.fromS2) {\\n                this.fromS1S2 = this.fromS1+this.fromS2;\\n                isAnyUpdate = true;\\n            }\\n            return isAnyUpdate;\\n        }\\n    }\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        Node[] nodes = new Node[n];\\n        for(int i=0; i<n; i++) nodes[i] = new Node(i);\\n        nodes[src1].fromS1=0;\\n        nodes[src2].fromS2=0;\\n        Arrays.sort(edges, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b) {\\n                if(a[0]!=b[0]) return a[0]-b[0];\\n                if(a[1]!=b[1]) return a[1]-b[1];\\n                if(a[2]!=b[2]) return a[2]-b[2];\\n                return -1;\\n            }\\n        });\\n        Set<String> set = new HashSet<>();\\n        for(int[]edge:edges){\\n            if(set.contains(edge[0]+\"_\"+edge[1]))continue;\\n            nodes[edge[0]].add(nodes[edge[1]], edge[2]);\\n            set.add(edge[0]+\"_\"+edge[1]);\\n        }\\n        LinkedList<Node> queue = new LinkedList<>();\\n        queue.add(nodes[src1]);\\n        queue.add(nodes[src2]);\\n        boolean isAnyUpdate = true;\\n        while(isAnyUpdate) {\\n            isAnyUpdate = false;\\n            int curSize = queue.size();\\n            while(curSize--!=0) {\\n                Node node = queue.poll();\\n                for(int i = 0; i<node.toList.size(); i++) {\\n                    queue.offer(node.toList.get(i));\\n                    if(node.toList.get(i).updateDist(node, node.weights.get(i))){\\n                        isAnyUpdate=true;\\n                    }\\n                }\\n            }\\n        }\\n        return nodes[dest].fromS1S2==INFINITY?-1:nodes[dest].fromS1S2;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long INFINITY = Long.MAX_VALUE;\\n    class Node {\\n        public int id;\\n        public long fromS1, fromS2, fromS1S2;\\n        public List<Node> toList;\\n        public List<Integer> weights;\\n        public Node(int id) {\\n            this.id=id;\\n            fromS1=fromS2=fromS1S2=INFINITY;\\n            this.toList=new ArrayList<>();\\n            this.weights=new ArrayList<>();\\n        }\\n        public void add(Node n, int weight) {\\n            this.toList.add(n);\\n            this.weights.add(weight);\\n        }\\n        public boolean updateDist(Node pNode, int weight) { // pNode->curNode\\n            boolean isAnyUpdate=false;\\n            if(pNode.fromS1!=INFINITY && this.fromS1>pNode.fromS1+weight){\\n                this.fromS1 = pNode.fromS1+weight;\\n                isAnyUpdate = true;\\n            } \\n            if(pNode.fromS2!=INFINITY&&this.fromS2>pNode.fromS2+weight) {\\n                this.fromS2 = pNode.fromS2+weight;\\n                isAnyUpdate = true;\\n            }\\n            if(pNode.fromS1S2!=INFINITY && this.fromS1S2> pNode.fromS1S2+weight) {\\n                this.fromS1S2 = pNode.fromS1S2+weight;\\n                isAnyUpdate = true;\\n            }\\n            if(this.fromS1!=INFINITY&&this.fromS2!=INFINITY && this.fromS1S2 > this.fromS1+this.fromS2) {\\n                this.fromS1S2 = this.fromS1+this.fromS2;\\n                isAnyUpdate = true;\\n            }\\n            return isAnyUpdate;\\n        }\\n    }\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        Node[] nodes = new Node[n];\\n        for(int i=0; i<n; i++) nodes[i] = new Node(i);\\n        nodes[src1].fromS1=0;\\n        nodes[src2].fromS2=0;\\n        Arrays.sort(edges, new Comparator<int[]>(){\\n            public int compare(int[] a, int[] b) {\\n                if(a[0]!=b[0]) return a[0]-b[0];\\n                if(a[1]!=b[1]) return a[1]-b[1];\\n                if(a[2]!=b[2]) return a[2]-b[2];\\n                return -1;\\n            }\\n        });\\n        Set<String> set = new HashSet<>();\\n        for(int[]edge:edges){\\n            if(set.contains(edge[0]+\"_\"+edge[1]))continue;\\n            nodes[edge[0]].add(nodes[edge[1]], edge[2]);\\n            set.add(edge[0]+\"_\"+edge[1]);\\n        }\\n        LinkedList<Node> queue = new LinkedList<>();\\n        queue.add(nodes[src1]);\\n        queue.add(nodes[src2]);\\n        boolean isAnyUpdate = true;\\n        while(isAnyUpdate) {\\n            isAnyUpdate = false;\\n            int curSize = queue.size();\\n            while(curSize--!=0) {\\n                Node node = queue.poll();\\n                for(int i = 0; i<node.toList.size(); i++) {\\n                    queue.offer(node.toList.get(i));\\n                    if(node.toList.get(i).updateDist(node, node.weights.get(i))){\\n                        isAnyUpdate=true;\\n                    }\\n                }\\n            }\\n        }\\n        return nodes[dest].fromS1S2==INFINITY?-1:nodes[dest].fromS1S2;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849646,
                "title": "three-dijkstras-with-minheap-readable-code-c",
                "content": "Algorithm explained\\n*Using Dijkstras*\\n**1: shortest path from src1 to all other nodes**\\n**2: shortest path from src2 to all other nodes**\\n**3: shortest path from dest to all other nodes with reversed adjacency list**\\n**4: take the minimum value from steps 1-3. e.g 1[i]+2[i] + 3[i]**\\n\\n\\nMinHeap has decrease key functionality which operates at O(logn) (this is achieved by have an accompanied map with indexes)\\n\\n\\nThere is room for improvement but I thought I would post this in case someone wants to see what\\'s happening under the hood\\n\\n```\\npublic class Solution\\n    {\\n        public long MinimumWeight(int n, int[][] edges, int src1, int src2, int dest)\\n        {\\n\\n            //convert edges into adjacency matrix\\n            //O(n) time\\n            List<List<Node>> adjList = new List<List<Node>>();\\n            List<List<Node>> reversedGraph = new List<List<Node>>();\\n            for(int x = 0; x < n; x++)\\n            {\\n                adjList.Add(new List<Node>());\\n                reversedGraph.Add(new List<Node>());\\n            }\\n            for (int x = 0; x < edges.Length; x++)\\n            {\\n                int src = edges[x][0];\\n                int des = edges[x][1];\\n                int weight = edges[x][2];\\n\\n                reversedGraph[des].Add(new Node(src, weight));\\n                adjList[src].Add(new Node(des, weight));\\n            }\\n            //find shortest path from src1 to all\\n            long[] src1ToAll = shortestPath(src1, n, adjList);\\n            //find shortest path from src2 to all\\n            long[] src2ToAll = shortestPath(src2, n, adjList);\\n\\n            //find shortest path from dest to all on reversed graph\\n            long[] destToAll = shortestPath(dest, n, reversedGraph);\\n\\n            long minTotal = long.MaxValue;\\n            for (int x = 0; x < n; x++)\\n            {\\n                if(src1ToAll[x] == long.MaxValue || src2ToAll[x] == long.MaxValue || destToAll[x] == long.MaxValue)\\n                {\\n                    continue;\\n                }\\n\\n                long total = src1ToAll[x] + src2ToAll[x] + destToAll[x];\\n                if (total < minTotal)\\n                    minTotal = total;\\n            }\\n\\n            if (minTotal == long.MaxValue)\\n                return -1;\\n            return minTotal;\\n            \\n\\n\\n        }\\n\\n        //dikjstra\\'s\\n        public long[] shortestPath(int src, int n, List<List<Node>> adjList)\\n        {\\n            Node[] nodeValues = new Node[n];\\n\\n            MinHeap<Node> heap = new MinHeap<Node>();\\n\\n            for (int x = 0; x < nodeValues.Length; x++)\\n            {\\n                nodeValues[x] = new Node(x, long.MaxValue);\\n                heap.Add(nodeValues[x]);\\n            }\\n\\n            nodeValues[src].Value = 0;\\n            heap.DecreaseKey(nodeValues[src], nodeValues[src]);\\n\\n            while (heap.Count > 0)\\n            {\\n\\n                Node smallest = heap.RemoveMin();\\n                if (smallest.Value == long.MaxValue)\\n                    break;\\n                foreach (var node in adjList[smallest.NodeIndex])\\n                {\\n                    if (nodeValues[node.NodeIndex].Value > nodeValues[smallest.NodeIndex].Value + node.Value)\\n                    {\\n                        nodeValues[node.NodeIndex].Value = nodeValues[smallest.NodeIndex].Value + node.Value;\\n                        heap.DecreaseKey(nodeValues[node.NodeIndex], nodeValues[node.NodeIndex]);\\n                    }\\n                }\\n            }\\n            long[] distances = new long[n];\\n            for(int x = 0; x < n; x++)\\n            {\\n                if (x == src)\\n                    distances[x] = 0;\\n                else\\n                    distances[x] = nodeValues[x].Value;\\n            }\\n\\n            return distances;\\n\\n        }\\n\\n\\n        public class Node : IComparable<Node>\\n        {\\n            public int NodeIndex;\\n            public long Value;\\n\\n            public Node(int node, long value)\\n            {\\n                NodeIndex = node;\\n                Value = value;\\n            }\\n            public int CompareTo(Node other)\\n            {\\n                return Value.CompareTo(other.Value);\\n            }\\n\\n            public override string ToString()\\n            {\\n                return $\"Index: {NodeIndex}, Value: {Value}\";\\n            }\\n        }\\n    }\\n\\n    /// <summary>\\n    /// min heap that includes the decrease key operation that is needed for dijkstras algo\\n    /// </summary>\\n    /// <typeparam name=\"T\"></typeparam>\\n    public class MinHeap<T> where T : IComparable<T>\\n    {\\n        private List<T> array = new List<T>();\\n\\n        private Dictionary<T, int> map = new Dictionary<T, int>();\\n\\n        /// <summary>\\n        /// swaps the two elements and updates the maps with the new indexes\\n        /// </summary>\\n        /// <param name=\"index1\"></param>\\n        /// <param name=\"index2\"></param>\\n        private void Swap(int index1, int index2)\\n        {\\n            T tmp = array[index1];\\n            array[index1] = array[index2];\\n            array[index2] = tmp;\\n\\n            //update dictionary values\\n            //values MUST always be present in dictionary\\n            map[tmp] = index2;\\n            map[array[index1]] = index1;\\n        }\\n\\n        /// <summary>\\n        /// O(logn)\\n        /// </summary>\\n        /// <param name=\"element\"></param>\\n        public void Add(T element)\\n        {\\n            array.Add(element);\\n            int n = array.Count - 1;\\n            //add the new element to the map\\n            map.Add(element, n);\\n            //we need to bubble this element as far as we can to the top\\n            while (n > 0 && array[n].CompareTo(array[n / 2]) == -1) //as long as the element above it in the tree is greater than this element we just added\\n            {\\n                //perform a swap of the two elements\\n                Swap(n, n / 2);\\n                n = n / 2;\\n            }\\n        }\\n\\n        /// <summary>\\n        /// O(1)\\n        /// </summary>\\n        /// <returns></returns>\\n        public T Peek()\\n        {\\n            return array[0];\\n        }\\n\\n        public int Count\\n        {\\n            get\\n            {\\n                return array.Count;\\n            }\\n        }\\n\\n        /// <summary>\\n        /// O(logn) assumes that the new key is less than the old key\\n        /// </summary>\\n        /// <param name=\"key\"></param>\\n        /// <param name=\"newKey\"></param>\\n        public void DecreaseKey(T key, T newKey)\\n        {\\n            if (!map.ContainsKey(key))\\n                throw new Exception($\"No key to decrease for key {key}\");\\n            int index = map[key];\\n            //remove the key from the map\\n            map.Remove(key);\\n\\n            array[index] = newKey;\\n\\n            map.Add(newKey, index);\\n            int c = index;\\n            while (c > 0 && array[c].CompareTo(array[c / 2]) == -1)\\n            {\\n                Swap(c, c / 2);\\n                c = c / 2;\\n            }\\n\\n\\n        }\\n        /// <summary>\\n        /// O(logn)\\n        /// </summary>\\n        /// <returns></returns>\\n        public T RemoveMin()\\n        {\\n            T retrieved = array[0];\\n            //remove the retrieved element from the map\\n            map.Remove(retrieved);\\n\\n            //place the last element in the tree at the top and bubble down\\n            array[0] = array[array.Count - 1];\\n            map[array[0]] = 0;\\n            array.RemoveAt(array.Count - 1);\\n\\n            int n = 0;\\n\\n            while (n < array.Count)\\n            {\\n                int min = n;\\n                //the node to the bottom right of the current node\\n                int botLeft = 2 * n + 1;\\n                //the node to the bottom left of the current node\\n                int botRight = 2 * n + 2;\\n                //if the bot left is less than the current min node then we assign this as the new min node \\n                if (botLeft < array.Count && array[botLeft].CompareTo(array[min]) == -1)\\n                {\\n                    min = botLeft;\\n                }\\n                //if the bot right is less than the current min node then we assign this as the new min node\\n                if (botRight < array.Count && array[botRight].CompareTo(array[min]) == -1)\\n                {\\n                    min = botRight;\\n                }\\n                //if the node at top is the smallest than we are finished\\n                if (min == n)\\n                    break;\\n\\n                //perform a swap with the min node and the node above it\\n                Swap(n, min);\\n                n = min;\\n            }\\n\\n            return retrieved;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Shortest Path"
                ],
                "code": "```\\npublic class Solution\\n    {\\n        public long MinimumWeight(int n, int[][] edges, int src1, int src2, int dest)\\n        {\\n\\n            //convert edges into adjacency matrix\\n            //O(n) time\\n            List<List<Node>> adjList = new List<List<Node>>();\\n            List<List<Node>> reversedGraph = new List<List<Node>>();\\n            for(int x = 0; x < n; x++)\\n            {\\n                adjList.Add(new List<Node>());\\n                reversedGraph.Add(new List<Node>());\\n            }\\n            for (int x = 0; x < edges.Length; x++)\\n            {\\n                int src = edges[x][0];\\n                int des = edges[x][1];\\n                int weight = edges[x][2];\\n\\n                reversedGraph[des].Add(new Node(src, weight));\\n                adjList[src].Add(new Node(des, weight));\\n            }\\n            //find shortest path from src1 to all\\n            long[] src1ToAll = shortestPath(src1, n, adjList);\\n            //find shortest path from src2 to all\\n            long[] src2ToAll = shortestPath(src2, n, adjList);\\n\\n            //find shortest path from dest to all on reversed graph\\n            long[] destToAll = shortestPath(dest, n, reversedGraph);\\n\\n            long minTotal = long.MaxValue;\\n            for (int x = 0; x < n; x++)\\n            {\\n                if(src1ToAll[x] == long.MaxValue || src2ToAll[x] == long.MaxValue || destToAll[x] == long.MaxValue)\\n                {\\n                    continue;\\n                }\\n\\n                long total = src1ToAll[x] + src2ToAll[x] + destToAll[x];\\n                if (total < minTotal)\\n                    minTotal = total;\\n            }\\n\\n            if (minTotal == long.MaxValue)\\n                return -1;\\n            return minTotal;\\n            \\n\\n\\n        }\\n\\n        //dikjstra\\'s\\n        public long[] shortestPath(int src, int n, List<List<Node>> adjList)\\n        {\\n            Node[] nodeValues = new Node[n];\\n\\n            MinHeap<Node> heap = new MinHeap<Node>();\\n\\n            for (int x = 0; x < nodeValues.Length; x++)\\n            {\\n                nodeValues[x] = new Node(x, long.MaxValue);\\n                heap.Add(nodeValues[x]);\\n            }\\n\\n            nodeValues[src].Value = 0;\\n            heap.DecreaseKey(nodeValues[src], nodeValues[src]);\\n\\n            while (heap.Count > 0)\\n            {\\n\\n                Node smallest = heap.RemoveMin();\\n                if (smallest.Value == long.MaxValue)\\n                    break;\\n                foreach (var node in adjList[smallest.NodeIndex])\\n                {\\n                    if (nodeValues[node.NodeIndex].Value > nodeValues[smallest.NodeIndex].Value + node.Value)\\n                    {\\n                        nodeValues[node.NodeIndex].Value = nodeValues[smallest.NodeIndex].Value + node.Value;\\n                        heap.DecreaseKey(nodeValues[node.NodeIndex], nodeValues[node.NodeIndex]);\\n                    }\\n                }\\n            }\\n            long[] distances = new long[n];\\n            for(int x = 0; x < n; x++)\\n            {\\n                if (x == src)\\n                    distances[x] = 0;\\n                else\\n                    distances[x] = nodeValues[x].Value;\\n            }\\n\\n            return distances;\\n\\n        }\\n\\n\\n        public class Node : IComparable<Node>\\n        {\\n            public int NodeIndex;\\n            public long Value;\\n\\n            public Node(int node, long value)\\n            {\\n                NodeIndex = node;\\n                Value = value;\\n            }\\n            public int CompareTo(Node other)\\n            {\\n                return Value.CompareTo(other.Value);\\n            }\\n\\n            public override string ToString()\\n            {\\n                return $\"Index: {NodeIndex}, Value: {Value}\";\\n            }\\n        }\\n    }\\n\\n    /// <summary>\\n    /// min heap that includes the decrease key operation that is needed for dijkstras algo\\n    /// </summary>\\n    /// <typeparam name=\"T\"></typeparam>\\n    public class MinHeap<T> where T : IComparable<T>\\n    {\\n        private List<T> array = new List<T>();\\n\\n        private Dictionary<T, int> map = new Dictionary<T, int>();\\n\\n        /// <summary>\\n        /// swaps the two elements and updates the maps with the new indexes\\n        /// </summary>\\n        /// <param name=\"index1\"></param>\\n        /// <param name=\"index2\"></param>\\n        private void Swap(int index1, int index2)\\n        {\\n            T tmp = array[index1];\\n            array[index1] = array[index2];\\n            array[index2] = tmp;\\n\\n            //update dictionary values\\n            //values MUST always be present in dictionary\\n            map[tmp] = index2;\\n            map[array[index1]] = index1;\\n        }\\n\\n        /// <summary>\\n        /// O(logn)\\n        /// </summary>\\n        /// <param name=\"element\"></param>\\n        public void Add(T element)\\n        {\\n            array.Add(element);\\n            int n = array.Count - 1;\\n            //add the new element to the map\\n            map.Add(element, n);\\n            //we need to bubble this element as far as we can to the top\\n            while (n > 0 && array[n].CompareTo(array[n / 2]) == -1) //as long as the element above it in the tree is greater than this element we just added\\n            {\\n                //perform a swap of the two elements\\n                Swap(n, n / 2);\\n                n = n / 2;\\n            }\\n        }\\n\\n        /// <summary>\\n        /// O(1)\\n        /// </summary>\\n        /// <returns></returns>\\n        public T Peek()\\n        {\\n            return array[0];\\n        }\\n\\n        public int Count\\n        {\\n            get\\n            {\\n                return array.Count;\\n            }\\n        }\\n\\n        /// <summary>\\n        /// O(logn) assumes that the new key is less than the old key\\n        /// </summary>\\n        /// <param name=\"key\"></param>\\n        /// <param name=\"newKey\"></param>\\n        public void DecreaseKey(T key, T newKey)\\n        {\\n            if (!map.ContainsKey(key))\\n                throw new Exception($\"No key to decrease for key {key}\");\\n            int index = map[key];\\n            //remove the key from the map\\n            map.Remove(key);\\n\\n            array[index] = newKey;\\n\\n            map.Add(newKey, index);\\n            int c = index;\\n            while (c > 0 && array[c].CompareTo(array[c / 2]) == -1)\\n            {\\n                Swap(c, c / 2);\\n                c = c / 2;\\n            }\\n\\n\\n        }\\n        /// <summary>\\n        /// O(logn)\\n        /// </summary>\\n        /// <returns></returns>\\n        public T RemoveMin()\\n        {\\n            T retrieved = array[0];\\n            //remove the retrieved element from the map\\n            map.Remove(retrieved);\\n\\n            //place the last element in the tree at the top and bubble down\\n            array[0] = array[array.Count - 1];\\n            map[array[0]] = 0;\\n            array.RemoveAt(array.Count - 1);\\n\\n            int n = 0;\\n\\n            while (n < array.Count)\\n            {\\n                int min = n;\\n                //the node to the bottom right of the current node\\n                int botLeft = 2 * n + 1;\\n                //the node to the bottom left of the current node\\n                int botRight = 2 * n + 2;\\n                //if the bot left is less than the current min node then we assign this as the new min node \\n                if (botLeft < array.Count && array[botLeft].CompareTo(array[min]) == -1)\\n                {\\n                    min = botLeft;\\n                }\\n                //if the bot right is less than the current min node then we assign this as the new min node\\n                if (botRight < array.Count && array[botRight].CompareTo(array[min]) == -1)\\n                {\\n                    min = botRight;\\n                }\\n                //if the node at top is the smallest than we are finished\\n                if (min == n)\\n                    break;\\n\\n                //perform a swap with the min node and the node above it\\n                Swap(n, min);\\n                n = min;\\n            }\\n\\n            return retrieved;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849129,
                "title": "my-idea-solution-explanation",
                "content": "My idea:\\n\\nThe brute force solution is to find the all possible edge subsets `s1` from `dst` to `src1`\\nand all possible edge subsets `s2` from `dst` to `src2`, then merge the two subsets ...\\n\\nBut we cant just hope this solution passed. To reduce the high time complexity problem,\\nwe can use dynamic programming.\\n\\nFor dynamic programming, we may want to cache the information of edges.\\nIn this problem, each edges has 4 states:\\n\\n* unused\\n* used in path `src1 -> dst`\\n* used in path `src2 -> dst`\\n* shared in path `src1 -> dst` and path `src2 -> dst`\\n\\nLets begin from the easy case. let `e[i]` denote the `i`-th edge, `f(e[i][0], e[i][1], state)` denote the\\nglobal minimum weigh for edge `e[i][0] -> e[i][1]` with state `state`. Then, if\\n\\n* `state == unused, f(e[i][0], e[i][1], state) = -1` means unreachable\\n* `state == both_used`, `f(e[i][0], e[i][1], state)` equals `min_weight_e[i][1]_to_dst + min_weigh_src1&src2_to_e[i][0]`\\n\\nWhats `min_weigh_src1&src2_to_e[i][0]`? It looks complex. Lets suppose the `e[i]` is the first shared edge, then\\n\\n`min_weigh_src1&src2_to_e[i][0] = min_path(src1, e[i][0]) + min_path(src2, e[i][1])`.\\n\\nWhats `min_weight_e[i][1]_to_dst`? If `e[i]` is the first shared edge, then all subsequent edges\\nshould be also shared. then\\n\\n`min_weight_e[i][1]_to_dst = min_path(e[i][1], dst)`\\n\\nok, we can interupt our dp solution. The global min weights is the sum\\n\\n`min_path(e[i][1], dst) + min_path(src1, e[i][0]) + min_path(src2, e[i][0])` for the first shared edge\\n`e[i]` that is `e[i][0] -> e[i][1]`.\\n\\nWe dont know which one is the first. But we can try each edge as if it is the first edge,\\nif it isnt, the result dont effect the final result as it isnt the min one.\\nwe can use dijkstra algorithm to find the min path.\\n\\nIn my code, I search the start node of the shared edges for simplify the logic.\\nThe dijkstra algorithm is optimized for this problem.\\n\\nFinally, Rust code\\n\\n```rust\\ntype Graph = Vec<Vec<(usize, i32)>>;\\n\\nimpl Solution {\\n    pub fn minimum_weight(n: i32, edges: Vec<Vec<i32>>, src1: i32, src2: i32, dest: i32) -> i64 {\\n        let n = n as usize;\\n\\n        let (graph, rev_graph) = Solution::preprocess(n, &edges);\\n\\n        let from_src1 = Solution::dijkstra(src1 as usize, n, &graph);\\n        let from_src2 = Solution::dijkstra(src2 as usize, n, &graph);\\n        let to_dest = Solution::dijkstra(dest as usize, n, &rev_graph);\\n\\n        (0..n)\\n            .filter(|&i| from_src1[i] != -1 && from_src2[i] != -1 && to_dest[i] != -1)\\n            .map(|i| from_src1[i] + from_src2[i] + to_dest[i])\\n            .min()\\n            .unwrap_or(-1)\\n    }\\n\\n    fn preprocess(n: usize, edges: &Vec<Vec<i32>>) -> (Graph, Graph) {\\n        let mut graph = vec![vec![]; n];\\n        let mut rev_graph = vec![vec![]; n];\\n        for e in edges {\\n            let e0 = e[0] as usize;\\n            let e1 = e[1] as usize;\\n\\n            graph[e0].push((e1, e[2]));\\n            rev_graph[e1].push((e0, e[2]));\\n        }\\n        (graph, rev_graph)\\n    }\\n\\n    fn dijkstra(src: usize, n: usize, graph: &Graph) -> Vec<i64> {\\n        let mut dist = vec![-1; n];\\n        let mut to_visit = std::collections::BinaryHeap::new();\\n\\n        to_visit.push(MinPath { node: src, dist: 0 });\\n\\n        while let Some(MinPath { node, dist: mydist }) = to_visit.pop() {\\n            if dist[node] != -1 {\\n                continue;\\n            }\\n            dist[node] = mydist;\\n            for &(adj, w) in &graph[node] {\\n                if dist[adj] == -1 {\\n                    to_visit.push(MinPath {\\n                        node: adj,\\n                        dist: dist[node] + w as i64,\\n                    });\\n                }\\n            }\\n        }\\n\\n        dist\\n    }\\n}\\n\\n#[derive(Eq, Ord)]\\nstruct MinPath {\\n    node: usize,\\n    dist: i64,\\n}\\n\\nimpl PartialEq for MinPath {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.dist == other.dist\\n    }\\n}\\n\\nimpl PartialOrd for MinPath {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        other.dist.partial_cmp(&self.dist)\\n    }\\n}\\n```\\n\\nTell me if you cant understand.",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\ntype Graph = Vec<Vec<(usize, i32)>>;\\n\\nimpl Solution {\\n    pub fn minimum_weight(n: i32, edges: Vec<Vec<i32>>, src1: i32, src2: i32, dest: i32) -> i64 {\\n        let n = n as usize;\\n\\n        let (graph, rev_graph) = Solution::preprocess(n, &edges);\\n\\n        let from_src1 = Solution::dijkstra(src1 as usize, n, &graph);\\n        let from_src2 = Solution::dijkstra(src2 as usize, n, &graph);\\n        let to_dest = Solution::dijkstra(dest as usize, n, &rev_graph);\\n\\n        (0..n)\\n            .filter(|&i| from_src1[i] != -1 && from_src2[i] != -1 && to_dest[i] != -1)\\n            .map(|i| from_src1[i] + from_src2[i] + to_dest[i])\\n            .min()\\n            .unwrap_or(-1)\\n    }\\n\\n    fn preprocess(n: usize, edges: &Vec<Vec<i32>>) -> (Graph, Graph) {\\n        let mut graph = vec![vec![]; n];\\n        let mut rev_graph = vec![vec![]; n];\\n        for e in edges {\\n            let e0 = e[0] as usize;\\n            let e1 = e[1] as usize;\\n\\n            graph[e0].push((e1, e[2]));\\n            rev_graph[e1].push((e0, e[2]));\\n        }\\n        (graph, rev_graph)\\n    }\\n\\n    fn dijkstra(src: usize, n: usize, graph: &Graph) -> Vec<i64> {\\n        let mut dist = vec![-1; n];\\n        let mut to_visit = std::collections::BinaryHeap::new();\\n\\n        to_visit.push(MinPath { node: src, dist: 0 });\\n\\n        while let Some(MinPath { node, dist: mydist }) = to_visit.pop() {\\n            if dist[node] != -1 {\\n                continue;\\n            }\\n            dist[node] = mydist;\\n            for &(adj, w) in &graph[node] {\\n                if dist[adj] == -1 {\\n                    to_visit.push(MinPath {\\n                        node: adj,\\n                        dist: dist[node] + w as i64,\\n                    });\\n                }\\n            }\\n        }\\n\\n        dist\\n    }\\n}\\n\\n#[derive(Eq, Ord)]\\nstruct MinPath {\\n    node: usize,\\n    dist: i64,\\n}\\n\\nimpl PartialEq for MinPath {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.dist == other.dist\\n    }\\n}\\n\\nimpl PartialOrd for MinPath {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        other.dist.partial_cmp(&self.dist)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1848391,
                "title": "c-easy-solution-with-dijkastras",
                "content": "1.find sortest distance from scr1 to all nodes and store in vector dest.\\n2.find sortest distance from scr2 to all nodes and store in vector dest2.\\n3.Reverse the direction of nodes and store in edge2 \\n4.find sortest distance from dest to all nodes and store in vector dest3.\\n5.Then find minimum of dest[i]+dest2[i]+dest[i], here i is the common node.\\n\\nTime Complexity - 3N*logN + N\\n\\n\\n`````\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<long long,long long>>> edge(n);\\n        for(auto it:edges){\\n            edge[it[0]].push_back(make_pair(it[1],it[2]));\\n        }\\n        \\n        vector<long long> vis(n,0);        \\n        queue<long long> q;\\n        q.push(src1);\\n        vector<long long> dist(n,-1);\\n        dist[src1]=0;\\n        \\n        while(!q.empty()){\\n            long long from=q.front();\\n            if(vis[from]){\\n               q.pop();\\n                continue;\\n            }\\n            vis[from]=1;\\n            auto it=edge[q.front()];\\n            q.pop();\\n            long long len=it.size();\\n            for(long long i=0;i<len;i++){\\n                if(dist[it[i].first]==-1){\\n                    dist[it[i].first]=dist[from]+it[i].second;\\n                }\\n                else{\\n                    dist[it[i].first]=min(dist[it[i].first],dist[from]+it[i].second);\\n                }\\n                q.push(it[i].first);\\n            }\\n        }\\n        \\n        \\n        vector<long long> vis2(n,0);        \\n        queue<long long> q2;\\n        q2.push(src2);\\n        vector<long long> dist2(n,-1);\\n        dist2[src2]=0;\\n        \\n        while(!q2.empty()){\\n            long long from=q2.front();\\n            if(vis2[from]){\\n               q2.pop();\\n                continue;\\n            }\\n            vis2[from]=1;\\n            auto it=edge[q2.front()];\\n            q2.pop();\\n            long long len=it.size();\\n            for(long long i=0;i<len;i++){\\n                if(dist2[it[i].first]==-1){\\n                    dist2[it[i].first]=dist2[from]+it[i].second;\\n                }\\n                else{\\n                    dist2[it[i].first]=min(dist2[it[i].first],dist2[from]+it[i].second);\\n                }\\n                q2.push(it[i].first);\\n            }\\n        }\\n        \\n        vector<vector<pair<long long,long long>>> edge2(n);\\n        for(auto it:edges){\\n            edge2[it[1]].push_back(make_pair(it[0],it[2]));\\n        }\\n        \\n        \\n        vector<long long> vis3(n,0);        \\n        queue<long long> q3;\\n        q3.push(dest);\\n        vector<long long> dist3(n,-1);\\n        dist3[dest]=0;\\n        \\n        while(!q3.empty()){\\n            long long from=q3.front();\\n            if(vis3[from]){\\n               q3.pop();\\n                continue;\\n            }\\n            vis3[from]=1;\\n            auto it=edge2[q3.front()];\\n            q3.pop();\\n            long long len=it.size();\\n            for(long long i=0;i<len;i++){\\n                if(dist3[it[i].first]==-1){\\n                    dist3[it[i].first]=dist3[from]+it[i].second;\\n                }\\n                else{\\n                    dist3[it[i].first]=min(dist3[it[i].first],dist3[from]+it[i].second);\\n                }\\n                q3.push(it[i].first);\\n            }\\n        }\\n        \\n        long long mini=10000000000;\\n        for(long long i=0;i<n;i++){\\n            if(dist[i]==-1 || dist2[i]==-1 || dist3[i]==-1){\\n                continue;\\n            }\\n                \\n            long long path_dist=dist[i]+dist2[i]+dist3[i];\\n            mini=min(path_dist,mini);\\n        }\\n\\n        if(mini==10000000000){\\n            return -1;\\n        }\\n        \\n        return mini;\\n    }\\n};\\n`````",
                "solutionTags": [
                    "Graph"
                ],
                "code": "`````\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<long long,long long>>> edge(n);\\n        for(auto it:edges){\\n            edge[it[0]].push_back(make_pair(it[1],it[2]));\\n        }\\n        \\n        vector<long long> vis(n,0);        \\n        queue<long long> q;\\n        q.push(src1);\\n        vector<long long> dist(n,-1);\\n        dist[src1]=0;\\n        \\n        while(!q.empty()){\\n            long long from=q.front();\\n            if(vis[from]){\\n               q.pop();\\n                continue;\\n            }\\n            vis[from]=1;\\n            auto it=edge[q.front()];\\n            q.pop();\\n            long long len=it.size();\\n            for(long long i=0;i<len;i++){\\n                if(dist[it[i].first]==-1){\\n                    dist[it[i].first]=dist[from]+it[i].second;\\n                }\\n                else{\\n                    dist[it[i].first]=min(dist[it[i].first],dist[from]+it[i].second);\\n                }\\n                q.push(it[i].first);\\n            }\\n        }\\n        \\n        \\n        vector<long long> vis2(n,0);        \\n        queue<long long> q2;\\n        q2.push(src2);\\n        vector<long long> dist2(n,-1);\\n        dist2[src2]=0;\\n        \\n        while(!q2.empty()){\\n            long long from=q2.front();\\n            if(vis2[from]){\\n               q2.pop();\\n                continue;\\n            }\\n            vis2[from]=1;\\n            auto it=edge[q2.front()];\\n            q2.pop();\\n            long long len=it.size();\\n            for(long long i=0;i<len;i++){\\n                if(dist2[it[i].first]==-1){\\n                    dist2[it[i].first]=dist2[from]+it[i].second;\\n                }\\n                else{\\n                    dist2[it[i].first]=min(dist2[it[i].first],dist2[from]+it[i].second);\\n                }\\n                q2.push(it[i].first);\\n            }\\n        }\\n        \\n        vector<vector<pair<long long,long long>>> edge2(n);\\n        for(auto it:edges){\\n            edge2[it[1]].push_back(make_pair(it[0],it[2]));\\n        }\\n        \\n        \\n        vector<long long> vis3(n,0);        \\n        queue<long long> q3;\\n        q3.push(dest);\\n        vector<long long> dist3(n,-1);\\n        dist3[dest]=0;\\n        \\n        while(!q3.empty()){\\n            long long from=q3.front();\\n            if(vis3[from]){\\n               q3.pop();\\n                continue;\\n            }\\n            vis3[from]=1;\\n            auto it=edge2[q3.front()];\\n            q3.pop();\\n            long long len=it.size();\\n            for(long long i=0;i<len;i++){\\n                if(dist3[it[i].first]==-1){\\n                    dist3[it[i].first]=dist3[from]+it[i].second;\\n                }\\n                else{\\n                    dist3[it[i].first]=min(dist3[it[i].first],dist3[from]+it[i].second);\\n                }\\n                q3.push(it[i].first);\\n            }\\n        }\\n        \\n        long long mini=10000000000;\\n        for(long long i=0;i<n;i++){\\n            if(dist[i]==-1 || dist2[i]==-1 || dist3[i]==-1){\\n                continue;\\n            }\\n                \\n            long long path_dist=dist[i]+dist2[i]+dist3[i];\\n            mini=min(path_dist,mini);\\n        }\\n\\n        if(mini==10000000000){\\n            return -1;\\n        }\\n        \\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1848213,
                "title": "can-anyone-please-help-with-long-overflow",
                "content": "```\\nunordered_map<int,vector<vector<int>>>m;\\n    unordered_map<int,vector<vector<int>>>revm;\\n    \\n    int findMin(int n, vector<long long>w, vector<int>v) {\\n        int minm = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(!v[i] and (minm == -1 or w[minm] > w[i])) minm = i;\\n        }\\n        return minm;\\n    }\\n    \\n    void dijkstra(int src, int n, vector<long long>&w, vector<int>&v, unordered_map<int,vector<vector<int>>>g) {\\n        for(int i = 0; i < n; i++) {\\n            int index = findMin(n,w,v);\\n            v[index] = 1;\\n            for(auto x : g[index]) {\\n                if(!v[x[0]]) w[x[0]] = min(w[x[0]], w[index]+(long long)x[1]);\\n            }\\n        }\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        for(auto x : edges) {\\n            m[x[0]].push_back({x[1],x[2]});\\n            revm[x[1]].push_back({x[0],x[2]});\\n        }\\n        vector<long long>w1(n,LONG_MAX), w2(n,LONG_MAX), w3(n,LONG_MAX);\\n        vector<int>v1(n,0), v2(n,0), v3(n,0);\\n        w1[src1] = 0, w2[src2] = 0, w3[dest] = 0;\\n\\n        dijkstra(src1,n,w1,v1,m);\\n        dijkstra(src2,n,w2,v2,m);\\n        dijkstra(dest,n,w3,v3,revm);\\n\\n        long long res = LONG_MAX;\\n        for(int i = 0; i < n; i++) {\\n            if(w1[i] != LONG_MAX and w2[i] != LONG_MAX and w3[i] != LONG_MAX) \\n                res = min(res, w1[i]+w2[i]+w3[i]);\\n        }\\n        \\n        return res == LONG_MAX ? -1 : res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nunordered_map<int,vector<vector<int>>>m;\\n    unordered_map<int,vector<vector<int>>>revm;\\n    \\n    int findMin(int n, vector<long long>w, vector<int>v) {\\n        int minm = -1;\\n        for(int i = 0; i < n; i++) {\\n            if(!v[i] and (minm == -1 or w[minm] > w[i])) minm = i;\\n        }\\n        return minm;\\n    }\\n    \\n    void dijkstra(int src, int n, vector<long long>&w, vector<int>&v, unordered_map<int,vector<vector<int>>>g) {\\n        for(int i = 0; i < n; i++) {\\n            int index = findMin(n,w,v);\\n            v[index] = 1;\\n            for(auto x : g[index]) {\\n                if(!v[x[0]]) w[x[0]] = min(w[x[0]], w[index]+(long long)x[1]);\\n            }\\n        }\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        for(auto x : edges) {\\n            m[x[0]].push_back({x[1],x[2]});\\n            revm[x[1]].push_back({x[0],x[2]});\\n        }\\n        vector<long long>w1(n,LONG_MAX), w2(n,LONG_MAX), w3(n,LONG_MAX);\\n        vector<int>v1(n,0), v2(n,0), v3(n,0);\\n        w1[src1] = 0, w2[src2] = 0, w3[dest] = 0;\\n\\n        dijkstra(src1,n,w1,v1,m);\\n        dijkstra(src2,n,w2,v2,m);\\n        dijkstra(dest,n,w3,v3,revm);\\n\\n        long long res = LONG_MAX;\\n        for(int i = 0; i < n; i++) {\\n            if(w1[i] != LONG_MAX and w2[i] != LONG_MAX and w3[i] != LONG_MAX) \\n                res = min(res, w1[i]+w2[i]+w3[i]);\\n        }\\n        \\n        return res == LONG_MAX ? -1 : res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1847933,
                "title": "anyone-please-see-why-this-giving-me-tle-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> dijkstra(int n, vector<vector<pair<int, int>>> &adj, int s)\\n    {\\n        vector<long long> weight(n, LLONG_MAX);\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, s});\\n        weight[s] = 0;\\n        while(!pq.empty()){\\n            long long prevDis = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            for(auto &it : adj[node]){\\n                int adjNode = it.first;\\n                int adjDis = it.second;\\n                if(weight[adjNode] > prevDis + adjDis){\\n                    weight[adjNode] = prevDis + adjDis;\\n                    pq.push({prevDis + adjDis, adjNode});\\n                }\\n            }\\n        }\\n        return weight;\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int, int>>> adj(n);\\n        vector<vector<pair<int, int>>> adjReverse(n);\\n        for(auto it : edges){\\n            adj[it[0]].push_back({it[1], it[2]});  // norrmal adjacency list\\n            adjReverse[it[1]].push_back({it[0], it[2]});  // reversed adjacency list\\n        }\\n        \\n        vector<long long> d1 = dijkstra(n, adj, src1);\\n        vector<long long> d2 = dijkstra(n, adj, src2);\\n        vector<long long> d3 = dijkstra(n, adjReverse, dest);\\n        \\n        long long minDis = LLONG_MAX;\\n        for(int i = 0; i < n; i++){\\n            if(d1[i] == LLONG_MAX || d2[i] == LLONG_MAX || d3[i] == LLONG_MAX) continue;\\n            minDis = min(minDis, d1[i] + d2[i] + d3[i]);\\n        }\\n        if(minDis == LLONG_MAX) return -1;\\n        return minDis;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> dijkstra(int n, vector<vector<pair<int, int>>> &adj, int s)\\n    {\\n        vector<long long> weight(n, LLONG_MAX);\\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0, s});\\n        weight[s] = 0;\\n        while(!pq.empty()){\\n            long long prevDis = pq.top().first;\\n            int node = pq.top().second;\\n            pq.pop();\\n            for(auto &it : adj[node]){\\n                int adjNode = it.first;\\n                int adjDis = it.second;\\n                if(weight[adjNode] > prevDis + adjDis){\\n                    weight[adjNode] = prevDis + adjDis;\\n                    pq.push({prevDis + adjDis, adjNode});\\n                }\\n            }\\n        }\\n        return weight;\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int, int>>> adj(n);\\n        vector<vector<pair<int, int>>> adjReverse(n);\\n        for(auto it : edges){\\n            adj[it[0]].push_back({it[1], it[2]});  // norrmal adjacency list\\n            adjReverse[it[1]].push_back({it[0], it[2]});  // reversed adjacency list\\n        }\\n        \\n        vector<long long> d1 = dijkstra(n, adj, src1);\\n        vector<long long> d2 = dijkstra(n, adj, src2);\\n        vector<long long> d3 = dijkstra(n, adjReverse, dest);\\n        \\n        long long minDis = LLONG_MAX;\\n        for(int i = 0; i < n; i++){\\n            if(d1[i] == LLONG_MAX || d2[i] == LLONG_MAX || d3[i] == LLONG_MAX) continue;\\n            minDis = min(minDis, d1[i] + d2[i] + d3[i]);\\n        }\\n        if(minDis == LLONG_MAX) return -1;\\n        return minDis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847808,
                "title": "go-three-dijkstras",
                "content": "Go version of that solution:\\nhttps://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/discuss/1844095/Three-Dijkstras\\n\\n```\\nfunc minimumWeight(n int, edges [][]int, src1 int, src2 int, dest int) int64 {\\n\\tmaxVal, res := 10000000000, math.MaxInt64\\n\\tgraph, reversedGraph := make([][][2]int, n), make([][][2]int, n)\\n\\tcommonDist, src1Dist, src2Dist := makeSlice(n, maxVal), makeSlice(n, maxVal), makeSlice(n, maxVal)\\n\\tcommonDist[dest], src1Dist[src1], src2Dist[src2] = 0, 0, 0\\n\\n\\tfor _, e := range edges {\\n\\t\\tfrom, to, weight := e[0], e[1], e[2]\\n\\n\\t\\tgraph[from] = append(graph[from], [2]int{to, weight})\\n\\t\\treversedGraph[to] = append(reversedGraph[to], [2]int{from, weight})\\n\\t}\\n\\n\\tbfs(dest, reversedGraph, commonDist)\\n\\tbfs(src1, graph, src1Dist)\\n\\tbfs(src2, graph, src2Dist)\\n\\n\\tif commonDist[src1] == maxVal || commonDist[src2] == maxVal {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tres = min(res, commonDist[i]+src1Dist[i]+src2Dist[i])\\n\\t}\\n\\n\\treturn int64(res)\\n}\\n\\nfunc bfs(st int, al [][][2]int, visited []int) {\\n\\tpriorityQ := minHeap{}\\n\\theap.Push(&priorityQ, [2]int{0, st})\\n\\n\\tfor len(priorityQ) != 0 {\\n\\t\\ttop := heap.Pop(&priorityQ).([2]int)\\n\\t\\tdist, i := top[0], top[1]\\n\\n\\t\\tif visited[i] != dist {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tfor _, edge := range al[i] {\\n\\t\\t\\tj, w := edge[0], edge[1]\\n\\t\\t\\tif visited[j] > dist+w {\\n\\t\\t\\t\\tvisited[j] = dist + w\\n\\t\\t\\t\\theap.Push(&priorityQ, [2]int{visited[j], j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n}\\n\\ntype minHeap [][2]int\\n\\nfunc (h minHeap) Len() int            { return len(h) }\\nfunc (h minHeap) Less(i, j int) bool  { return h[i][0] < h[j][0] }\\nfunc (h minHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *minHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) }\\nfunc (h *minHeap) Pop() (v interface{}) {\\n\\t*h, v = (*h)[:len(*h)-1], (*h)[len(*h)-1]\\n\\treturn\\n}\\n\\nfunc makeSlice(length, val int) []int {\\n\\tres := make([]int, length)\\n\\tfor i := range res {\\n\\t\\tres[i] = val\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Graph"
                ],
                "code": "```\\nfunc minimumWeight(n int, edges [][]int, src1 int, src2 int, dest int) int64 {\\n\\tmaxVal, res := 10000000000, math.MaxInt64\\n\\tgraph, reversedGraph := make([][][2]int, n), make([][][2]int, n)\\n\\tcommonDist, src1Dist, src2Dist := makeSlice(n, maxVal), makeSlice(n, maxVal), makeSlice(n, maxVal)\\n\\tcommonDist[dest], src1Dist[src1], src2Dist[src2] = 0, 0, 0\\n\\n\\tfor _, e := range edges {\\n\\t\\tfrom, to, weight := e[0], e[1], e[2]\\n\\n\\t\\tgraph[from] = append(graph[from], [2]int{to, weight})\\n\\t\\treversedGraph[to] = append(reversedGraph[to], [2]int{from, weight})\\n\\t}\\n\\n\\tbfs(dest, reversedGraph, commonDist)\\n\\tbfs(src1, graph, src1Dist)\\n\\tbfs(src2, graph, src2Dist)\\n\\n\\tif commonDist[src1] == maxVal || commonDist[src2] == maxVal {\\n\\t\\treturn -1\\n\\t}\\n\\n\\tfor i := 0; i < n; i++ {\\n\\t\\tres = min(res, commonDist[i]+src1Dist[i]+src2Dist[i])\\n\\t}\\n\\n\\treturn int64(res)\\n}\\n\\nfunc bfs(st int, al [][][2]int, visited []int) {\\n\\tpriorityQ := minHeap{}\\n\\theap.Push(&priorityQ, [2]int{0, st})\\n\\n\\tfor len(priorityQ) != 0 {\\n\\t\\ttop := heap.Pop(&priorityQ).([2]int)\\n\\t\\tdist, i := top[0], top[1]\\n\\n\\t\\tif visited[i] != dist {\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\tfor _, edge := range al[i] {\\n\\t\\t\\tj, w := edge[0], edge[1]\\n\\t\\t\\tif visited[j] > dist+w {\\n\\t\\t\\t\\tvisited[j] = dist + w\\n\\t\\t\\t\\theap.Push(&priorityQ, [2]int{visited[j], j})\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n}\\n\\ntype minHeap [][2]int\\n\\nfunc (h minHeap) Len() int            { return len(h) }\\nfunc (h minHeap) Less(i, j int) bool  { return h[i][0] < h[j][0] }\\nfunc (h minHeap) Swap(i, j int)       { h[i], h[j] = h[j], h[i] }\\nfunc (h *minHeap) Push(x interface{}) { *h = append(*h, x.([2]int)) }\\nfunc (h *minHeap) Pop() (v interface{}) {\\n\\t*h, v = (*h)[:len(*h)-1], (*h)[len(*h)-1]\\n\\treturn\\n}\\n\\nfunc makeSlice(length, val int) []int {\\n\\tres := make([]int, length)\\n\\tfor i := range res {\\n\\t\\tres[i] = val\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc min(a, b int) int {\\n\\tif a < b {\\n\\t\\treturn a\\n\\t}\\n\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1847790,
                "title": "please-help-with-tle-cpp",
                "content": "Can someone point out why am I getting TLE even after applying optimization\\n\\n```\\nclass Solution {\\npublic:\\n    void dijkistra (vector<vector<int>>& graph, int src, int dest, vector<long long>& distance) {\\n        priority_queue<pair<long long,int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0,src});\\n        int c = 0;\\n        \\n        while(pq.size()) {\\n            pair<int,int> f = pq.top();\\n            pq.pop();\\n            \\n            // node already computed\\n            if (distance[f.second] != LLONG_MAX) continue;\\n            \\n            distance[f.second] = f.first;\\n            c++;\\n            \\n            for (int i = 0; i < graph[f.second].size(); i+=2) {\\n                long long nbr = graph[f.second][i], dist = graph[f.second][i+1];\\n                // if not computed\\n                if (distance[nbr] == LLONG_MAX) pq.push({dist+f.first, nbr});\\n            }\\n        }\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<int>> graph(n), reversedGraph(n);\\n        for (vector<int>& a : edges) {\\n            int from = a[0], to = a[1], dist = a[2];\\n            graph[from].push_back(to);\\n            graph[from].push_back(dist);\\n            \\n            reversedGraph[to].push_back(from);\\n            reversedGraph[to].push_back(dist);\\n        }\\n        \\n        vector<long long> dSrc1(n, LLONG_MAX), dSrc2(n, LLONG_MAX);\\n        \\n        dijkistra(graph, src1, dest, dSrc1);\\n        dijkistra(graph, src2, dest, dSrc2);\\n        long long minDistance = LLONG_MAX;\\n        for (int i = 0; i < n; i++) {\\n            vector<long long> dDest(n, LLONG_MAX);\\n            dijkistra(reversedGraph, dest, i , dDest);\\n            if (dSrc1[i] == LLONG_MAX || dSrc2[i] == LLONG_MAX || dDest[i] == LLONG_MAX) continue;\\n            minDistance = min(minDistance, dSrc1[i]+dSrc2[i]+dDest[i]);\\n        }\\n        \\n        if (minDistance == LLONG_MAX) return -1;\\n        \\n        return minDistance;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dijkistra (vector<vector<int>>& graph, int src, int dest, vector<long long>& distance) {\\n        priority_queue<pair<long long,int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;\\n        pq.push({0,src});\\n        int c = 0;\\n        \\n        while(pq.size()) {\\n            pair<int,int> f = pq.top();\\n            pq.pop();\\n            \\n            // node already computed\\n            if (distance[f.second] != LLONG_MAX) continue;\\n            \\n            distance[f.second] = f.first;\\n            c++;\\n            \\n            for (int i = 0; i < graph[f.second].size(); i+=2) {\\n                long long nbr = graph[f.second][i], dist = graph[f.second][i+1];\\n                // if not computed\\n                if (distance[nbr] == LLONG_MAX) pq.push({dist+f.first, nbr});\\n            }\\n        }\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<int>> graph(n), reversedGraph(n);\\n        for (vector<int>& a : edges) {\\n            int from = a[0], to = a[1], dist = a[2];\\n            graph[from].push_back(to);\\n            graph[from].push_back(dist);\\n            \\n            reversedGraph[to].push_back(from);\\n            reversedGraph[to].push_back(dist);\\n        }\\n        \\n        vector<long long> dSrc1(n, LLONG_MAX), dSrc2(n, LLONG_MAX);\\n        \\n        dijkistra(graph, src1, dest, dSrc1);\\n        dijkistra(graph, src2, dest, dSrc2);\\n        long long minDistance = LLONG_MAX;\\n        for (int i = 0; i < n; i++) {\\n            vector<long long> dDest(n, LLONG_MAX);\\n            dijkistra(reversedGraph, dest, i , dDest);\\n            if (dSrc1[i] == LLONG_MAX || dSrc2[i] == LLONG_MAX || dDest[i] == LLONG_MAX) continue;\\n            minDistance = min(minDistance, dSrc1[i]+dSrc2[i]+dDest[i]);\\n        }\\n        \\n        if (minDistance == LLONG_MAX) return -1;\\n        \\n        return minDistance;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847330,
                "title": "brute-force-passes-76-78-tests-and-3-djikstra-s",
                "content": "I couldn\\'t think of any other soln during the contest and applied brute force i.e. build all paths from src1 to dest and src2 to dest and then compare all src1-dest paths with src2-dest paths and return the one that has least cost\\n\\n```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        (self.graph, self.path_cost) = self.build_graph(edges)\\n        src1_paths = self.find_paths(src1, dest, self.graph)\\n        src2_paths = self.find_paths(src2, dest, self.graph)\\n        \\n        result = 10000000000\\n        for p1 in src1_paths:\\n            for p2 in src2_paths:\\n                result = min(result, self.calc_path_cost(p1, p2))\\n        return -1 if result == 10000000000 else result\\n    \\n    def build_graph(self, edges):\\n        self.graph = {}\\n        self.path_cost = {}\\n        for edge in edges:\\n            if edge[0] not in self.graph:\\n                self.graph[edge[0]] = []\\n            self.graph[edge[0]].append(edge[1])\\n            \\n            if (edge[0], edge[1]) not in self.path_cost:\\n                self.path_cost[(edge[0], edge[1])] = edge[2]\\n            else:\\n                self.path_cost[(edge[0], edge[1])] = min(edge[2], self.path_cost[(edge[0], edge[1])])\\n            \\n        return (self.graph, self.path_cost)\\n    \\n    def find_paths(self, src, dest, graph):\\n        q = [[src, (1<<src), [src]]]\\n        result = []\\n        while q:\\n            item = q.pop(0)\\n            nd = item[0]\\n            visited = item[1]\\n            path = item[2]\\n            \\n            if nd == dest:\\n                result.append(path)\\n            \\n            if nd not in self.graph:\\n                continue\\n            \\n            for nb in self.graph[nd]:\\n                if (1<<nb) & visited:\\n                    continue\\n                new_path = copy.copy(path)\\n                new_path.append(nb)\\n                q.append([nb, (1<<nb) | visited, new_path])\\n        return result\\n    \\n    def calc_path_cost(self, p1, p2):\\n        cost = 0\\n        \\n        N = len(p1)\\n        visited = set()\\n        for i in range(1, N):\\n            edge = (p1[i-1], p1[i])\\n            cost += self.path_cost[edge]\\n            visited.add(edge)\\n            \\n        N = len(p2)\\n        for i in range(1, N):\\n            edge = (p2[i-1], p2[i])\\n            if edge in visited:\\n                continue\\n            cost += self.path_cost[edge]\\n        return cost\\n```\\n\\nDjikstra\\'s:\\n```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        (graph, path_cost, rev_graph, rev_path_cost) = self.build_graph(edges)\\n        result = 10000000000\\n        \\n        src1_nd_costs = self.djikstra(src1, graph, path_cost, n)\\n        src2_nd_costs = self.djikstra(src2, graph, path_cost, n)\\n        dest_nd_costs = self.djikstra(dest, rev_graph, rev_path_cost, n)\\n        for i in range(n):\\n            cst = src1_nd_costs[i] + src2_nd_costs[i] + dest_nd_costs[i]\\n            result = min(result, cst)\\n        return -1 if result == 10000000000 else result\\n    \\n    def build_graph(self, edges):\\n        graph = {}\\n        path_cost = {}\\n        rev_graph = {}\\n        rev_path_cost = {}\\n        \\n        for edge in edges:\\n            if edge[0] not in graph:\\n                graph[edge[0]] = []\\n            graph[edge[0]].append(edge[1])\\n            \\n            if edge[1] not in rev_graph:\\n                rev_graph[edge[1]] = []\\n            rev_graph[edge[1]].append(edge[0])\\n            \\n            if (edge[0], edge[1]) not in path_cost:\\n                path_cost[(edge[0], edge[1])] = edge[2]\\n            else:\\n                path_cost[(edge[0], edge[1])] = min(edge[2], path_cost[(edge[0], edge[1])])\\n                \\n            if (edge[1], edge[0]) not in rev_path_cost:\\n                rev_path_cost[(edge[1], edge[0])] = edge[2]\\n            else:\\n                rev_path_cost[(edge[1], edge[0])] = min(edge[2], rev_path_cost[(edge[1], edge[0])])\\n            \\n        return (graph, path_cost, rev_graph, rev_path_cost)\\n    \\n    def djikstra(self, src, graph, path_cost, n):\\n        q = []\\n        \\n        heapq.heappush(q, [0, src])\\n        result = [10000000000 for _ in range(n)]\\n        seen = set()\\n        while q:\\n            item = q.pop(0)\\n            cost = item[0]\\n            nd = item[1]\\n            result[nd] = min(result[nd], cost)\\n            \\n            if nd in seen:\\n                continue\\n            seen.add(nd)\\n            \\n            if nd not in graph:\\n                continue\\n            \\n            for nb in graph[nd]:\\n                heapq.heappush(q, [cost + path_cost[(nd, nb)], nb])\\n        return result\\n   ```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        (self.graph, self.path_cost) = self.build_graph(edges)\\n        src1_paths = self.find_paths(src1, dest, self.graph)\\n        src2_paths = self.find_paths(src2, dest, self.graph)\\n        \\n        result = 10000000000\\n        for p1 in src1_paths:\\n            for p2 in src2_paths:\\n                result = min(result, self.calc_path_cost(p1, p2))\\n        return -1 if result == 10000000000 else result\\n    \\n    def build_graph(self, edges):\\n        self.graph = {}\\n        self.path_cost = {}\\n        for edge in edges:\\n            if edge[0] not in self.graph:\\n                self.graph[edge[0]] = []\\n            self.graph[edge[0]].append(edge[1])\\n            \\n            if (edge[0], edge[1]) not in self.path_cost:\\n                self.path_cost[(edge[0], edge[1])] = edge[2]\\n            else:\\n                self.path_cost[(edge[0], edge[1])] = min(edge[2], self.path_cost[(edge[0], edge[1])])\\n            \\n        return (self.graph, self.path_cost)\\n    \\n    def find_paths(self, src, dest, graph):\\n        q = [[src, (1<<src), [src]]]\\n        result = []\\n        while q:\\n            item = q.pop(0)\\n            nd = item[0]\\n            visited = item[1]\\n            path = item[2]\\n            \\n            if nd == dest:\\n                result.append(path)\\n            \\n            if nd not in self.graph:\\n                continue\\n            \\n            for nb in self.graph[nd]:\\n                if (1<<nb) & visited:\\n                    continue\\n                new_path = copy.copy(path)\\n                new_path.append(nb)\\n                q.append([nb, (1<<nb) | visited, new_path])\\n        return result\\n    \\n    def calc_path_cost(self, p1, p2):\\n        cost = 0\\n        \\n        N = len(p1)\\n        visited = set()\\n        for i in range(1, N):\\n            edge = (p1[i-1], p1[i])\\n            cost += self.path_cost[edge]\\n            visited.add(edge)\\n            \\n        N = len(p2)\\n        for i in range(1, N):\\n            edge = (p2[i-1], p2[i])\\n            if edge in visited:\\n                continue\\n            cost += self.path_cost[edge]\\n        return cost\\n```\n```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        (graph, path_cost, rev_graph, rev_path_cost) = self.build_graph(edges)\\n        result = 10000000000\\n        \\n        src1_nd_costs = self.djikstra(src1, graph, path_cost, n)\\n        src2_nd_costs = self.djikstra(src2, graph, path_cost, n)\\n        dest_nd_costs = self.djikstra(dest, rev_graph, rev_path_cost, n)\\n        for i in range(n):\\n            cst = src1_nd_costs[i] + src2_nd_costs[i] + dest_nd_costs[i]\\n            result = min(result, cst)\\n        return -1 if result == 10000000000 else result\\n    \\n    def build_graph(self, edges):\\n        graph = {}\\n        path_cost = {}\\n        rev_graph = {}\\n        rev_path_cost = {}\\n        \\n        for edge in edges:\\n            if edge[0] not in graph:\\n                graph[edge[0]] = []\\n            graph[edge[0]].append(edge[1])\\n            \\n            if edge[1] not in rev_graph:\\n                rev_graph[edge[1]] = []\\n            rev_graph[edge[1]].append(edge[0])\\n            \\n            if (edge[0], edge[1]) not in path_cost:\\n                path_cost[(edge[0], edge[1])] = edge[2]\\n            else:\\n                path_cost[(edge[0], edge[1])] = min(edge[2], path_cost[(edge[0], edge[1])])\\n                \\n            if (edge[1], edge[0]) not in rev_path_cost:\\n                rev_path_cost[(edge[1], edge[0])] = edge[2]\\n            else:\\n                rev_path_cost[(edge[1], edge[0])] = min(edge[2], rev_path_cost[(edge[1], edge[0])])\\n            \\n        return (graph, path_cost, rev_graph, rev_path_cost)\\n    \\n    def djikstra(self, src, graph, path_cost, n):\\n        q = []\\n        \\n        heapq.heappush(q, [0, src])\\n        result = [10000000000 for _ in range(n)]\\n        seen = set()\\n        while q:\\n            item = q.pop(0)\\n            cost = item[0]\\n            nd = item[1]\\n            result[nd] = min(result[nd], cost)\\n            \\n            if nd in seen:\\n                continue\\n            seen.add(nd)\\n            \\n            if nd not in graph:\\n                continue\\n            \\n            for nb in graph[nd]:\\n                heapq.heappush(q, [cost + path_cost[(nd, nb)], nb])\\n        return result\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 1846877,
                "title": "python-spfa-weekly-contest284",
                "content": "# spfa\\n\\nSimilar as other posts, we use spfa 3 times. Respectively get distance dictionary for src1 to other nodes, src2 to other nodes and other notes to dest.\\nAt the end, we can get the min distance by min(fromSrc1[point] + fromSrc2[point] + toDist[point]) for every points.\\n```\\nimport collections\\nclass Solution(object):\\n    def minimumWeight(self, n, edges, src1, src2, dest):\\n        edgesDist = {}\\n        reverseEdgesDist = {}\\n        for _from, _to, weight in edges:\\n            if _from not in edgesDist:\\n                edgesDist[_from] = []\\n            if _to not in reverseEdgesDist:\\n                reverseEdgesDist[_to] = []\\n            edgesDist[_from].append((_to, weight))\\n            reverseEdgesDist[_to].append((_from, weight))\\n\\n        fromSrc1 = self.spfa(edgesDist, src1)\\n        fromSrc2 = self.spfa(edgesDist, src2)\\n        toDist = self.spfa(reverseEdgesDist, dest)\\n        result = float(\\'inf\\')\\n        for point in toDist:\\n            if point in fromSrc1 and point in fromSrc2:\\n                result = min(result, fromSrc1[point] + fromSrc2[point] + toDist[point])\\n\\n        return -1 if result == float(\\'inf\\') else result\\n\\n    def spfa(self, edgesDist, src):\\n        distance = {src: 0}\\n        queue = collections.deque([src])\\n        visited = {src}\\n        while queue:\\n            currNode = queue.popleft()\\n            visited.discard(currNode)\\n            if currNode in edgesDist:\\n                for nextNode, weight in edgesDist[currNode]:\\n                    if nextNode not in distance or distance[nextNode] > distance[currNode] + weight:\\n                        distance[nextNode] = distance[currNode] + weight\\n                        if nextNode in visited:\\n                            continue\\n                        queue.append(nextNode)\\n                        visited.add(nextNode)\\n\\n        return distance\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution(object):\\n    def minimumWeight(self, n, edges, src1, src2, dest):\\n        edgesDist = {}\\n        reverseEdgesDist = {}\\n        for _from, _to, weight in edges:\\n            if _from not in edgesDist:\\n                edgesDist[_from] = []\\n            if _to not in reverseEdgesDist:\\n                reverseEdgesDist[_to] = []\\n            edgesDist[_from].append((_to, weight))\\n            reverseEdgesDist[_to].append((_from, weight))\\n\\n        fromSrc1 = self.spfa(edgesDist, src1)\\n        fromSrc2 = self.spfa(edgesDist, src2)\\n        toDist = self.spfa(reverseEdgesDist, dest)\\n        result = float(\\'inf\\')\\n        for point in toDist:\\n            if point in fromSrc1 and point in fromSrc2:\\n                result = min(result, fromSrc1[point] + fromSrc2[point] + toDist[point])\\n\\n        return -1 if result == float(\\'inf\\') else result\\n\\n    def spfa(self, edgesDist, src):\\n        distance = {src: 0}\\n        queue = collections.deque([src])\\n        visited = {src}\\n        while queue:\\n            currNode = queue.popleft()\\n            visited.discard(currNode)\\n            if currNode in edgesDist:\\n                for nextNode, weight in edgesDist[currNode]:\\n                    if nextNode not in distance or distance[nextNode] > distance[currNode] + weight:\\n                        distance[nextNode] = distance[currNode] + weight\\n                        if nextNode in visited:\\n                            continue\\n                        queue.append(nextNode)\\n                        visited.add(nextNode)\\n\\n        return distance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846824,
                "title": "java-solution-dijkstra-s-algo-3",
                "content": "```\\n// Consider all as the common points and scale the common point that give minimum distance\\nclass Solution {\\n  ArrayList<int[]>[] nextG, preG;\\n    \\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        makeGraph(n, edges);\\n        \\n        long[] src1To = new long[n], src2To = new long[n], toDest = new long[n];\\n        Arrays.fill(src1To, -1);\\n        Arrays.fill(src2To, -1);\\n        Arrays.fill(toDest, -1);\\n        \\n        shortestPath(src1, src1To, nextG); // Calling Dijkstra\\'s Algo from source 1 to destination\\n        shortestPath(src2, src2To, nextG); // Calling Dijkstra\\'s Algo from source 2 to destination\\n        shortestPath(dest, toDest, preG); // Calling Dijkstra\\'s Algo from destination to source\\n        \\n        long res = -1;\\n        for (int i = 0; i < n; i++) {\\n            long d1 = src1To[i], d2 = src2To[i], d3 = toDest[i];\\n            if (d1 >= 0 && d2 >= 0 && d3 >= 0) {\\n                long d = d1 + d2 + d3;\\n                if (res == -1 || d < res) {\\n                    res = d;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // Building 2 Graphs one from source to destination and one from destination to source\\n    private void makeGraph(int n, int[][] edges) {\\n        nextG = new ArrayList[n];\\n        preG = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            nextG[i] = new ArrayList<int[]>();\\n            preG[i] = new ArrayList<int[]>();\\n        }\\n       \\n        for (int[] edge : edges) {\\n            int from = edge[0], to = edge[1], weight = edge[2];\\n            nextG[from].add(new int[] {to, weight});\\n            preG[to].add(new int[] {from, weight});\\n        }\\n    }\\n    \\n    // Dijkstra\\'s Algo\\n    private void shortestPath(int src, long[] srcTo, ArrayList<int[]>[] graph) {\\n        PriorityQueue<long[]> heap = new PriorityQueue<>((a, b) -> (a[1] == b[1] ? 0 : (a[1] < b[1] ? -1 : 1)));\\n        for (int[] next : graph[src]) {\\n            heap.offer(new long[] {next[0], next[1]});\\n        }\\n        \\n        srcTo[src] = 0;\\n        \\n        while (!heap.isEmpty()) {\\n            long[] node = heap.poll();\\n            long to = node[0], dist = node[1];\\n            if (srcTo[(int) to] != -1 && srcTo[(int) to] <= dist) continue;\\n            srcTo[(int) to] = dist;\\n            for (int[] next : graph[(int) to]) {\\n                heap.offer(new long[] {next[0], dist + next[1]});\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Consider all as the common points and scale the common point that give minimum distance\\nclass Solution {\\n  ArrayList<int[]>[] nextG, preG;\\n    \\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        makeGraph(n, edges);\\n        \\n        long[] src1To = new long[n], src2To = new long[n], toDest = new long[n];\\n        Arrays.fill(src1To, -1);\\n        Arrays.fill(src2To, -1);\\n        Arrays.fill(toDest, -1);\\n        \\n        shortestPath(src1, src1To, nextG); // Calling Dijkstra\\'s Algo from source 1 to destination\\n        shortestPath(src2, src2To, nextG); // Calling Dijkstra\\'s Algo from source 2 to destination\\n        shortestPath(dest, toDest, preG); // Calling Dijkstra\\'s Algo from destination to source\\n        \\n        long res = -1;\\n        for (int i = 0; i < n; i++) {\\n            long d1 = src1To[i], d2 = src2To[i], d3 = toDest[i];\\n            if (d1 >= 0 && d2 >= 0 && d3 >= 0) {\\n                long d = d1 + d2 + d3;\\n                if (res == -1 || d < res) {\\n                    res = d;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    // Building 2 Graphs one from source to destination and one from destination to source\\n    private void makeGraph(int n, int[][] edges) {\\n        nextG = new ArrayList[n];\\n        preG = new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            nextG[i] = new ArrayList<int[]>();\\n            preG[i] = new ArrayList<int[]>();\\n        }\\n       \\n        for (int[] edge : edges) {\\n            int from = edge[0], to = edge[1], weight = edge[2];\\n            nextG[from].add(new int[] {to, weight});\\n            preG[to].add(new int[] {from, weight});\\n        }\\n    }\\n    \\n    // Dijkstra\\'s Algo\\n    private void shortestPath(int src, long[] srcTo, ArrayList<int[]>[] graph) {\\n        PriorityQueue<long[]> heap = new PriorityQueue<>((a, b) -> (a[1] == b[1] ? 0 : (a[1] < b[1] ? -1 : 1)));\\n        for (int[] next : graph[src]) {\\n            heap.offer(new long[] {next[0], next[1]});\\n        }\\n        \\n        srcTo[src] = 0;\\n        \\n        while (!heap.isEmpty()) {\\n            long[] node = heap.poll();\\n            long to = node[0], dist = node[1];\\n            if (srcTo[(int) to] != -1 && srcTo[(int) to] <= dist) continue;\\n            srcTo[(int) to] = dist;\\n            for (int[] next : graph[(int) to]) {\\n                heap.offer(new long[] {next[0], dist + next[1]});\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846511,
                "title": "java-dijkstra-x3",
                "content": "Run Dijkstra algorithm 3 times:\\n- from each of the two sources (on original graph)\\n- from destination (on graph with inverted edges)\\n- take the minimum of the sum of distances to the 3 points across all nodes\\n\\nThe Dijkstra implementation is left as an exercise to the reader :-)\\n\\n```\\npublic long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n\\t// graph and inverted graph\\n\\tList<long[]>[] g= new ArrayList[n], ig= new ArrayList[n];\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tg[i]= new ArrayList<>();\\n\\t\\tig[i]= new ArrayList<>();\\n\\t}\\n\\tfor(int[] e:edges){\\n\\t\\tint u= e[0], v= e[1], w= e[2];\\n\\t\\tg[u].add(new long[]{v, w});\\n\\t\\tig[v].add(new long[]{u, w});\\n\\t}\\n\\tlong[] dist1= dijkstraPQ(n, g, src1);\\n\\tlong[] dist2= dijkstraPQ(n, g, src2);\\n\\tlong[] dist3= dijkstraPQ(n, ig, dest);\\n\\tlong ans= INF;\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tans= Math.min(ans, dist1[i]+dist2[i]+dist3[i]);\\n\\t}\\n\\treturn ans>=INF ? -1 : ans;\\n}",
                "solutionTags": [],
                "code": "Run Dijkstra algorithm 3 times:\\n- from each of the two sources (on original graph)\\n- from destination (on graph with inverted edges)\\n- take the minimum of the sum of distances to the 3 points across all nodes\\n\\nThe Dijkstra implementation is left as an exercise to the reader :-)\\n\\n```\\npublic long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n\\t// graph and inverted graph\\n\\tList<long[]>[] g= new ArrayList[n], ig= new ArrayList[n];\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tg[i]= new ArrayList<>();\\n\\t\\tig[i]= new ArrayList<>();\\n\\t}\\n\\tfor(int[] e:edges){\\n\\t\\tint u= e[0], v= e[1], w= e[2];\\n\\t\\tg[u].add(new long[]{v, w});\\n\\t\\tig[v].add(new long[]{u, w});\\n\\t}\\n\\tlong[] dist1= dijkstraPQ(n, g, src1);\\n\\tlong[] dist2= dijkstraPQ(n, g, src2);\\n\\tlong[] dist3= dijkstraPQ(n, ig, dest);\\n\\tlong ans= INF;\\n\\tfor(int i=0; i<n; i++){\\n\\t\\tans= Math.min(ans, dist1[i]+dist2[i]+dist3[i]);\\n\\t}\\n\\treturn ans>=INF ? -1 : ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1846504,
                "title": "go-golang-time-o-n-log-n-3-355-ms-100-space-o-n-5-31-1-mb-100",
                "content": "Thanks to this original solution, [Three Dijkstras](https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/discuss/1844095/Three-Dijkstras), that explained the logic.\\nMore about [Dijkstra\\'s algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm).\\n\\n## Priority Queue\\n```\\nconst MAX = int64(10000000000)\\n\\ntype pair struct {\\n    key int64\\n    value int\\n}\\n\\ntype Item struct {\\n\\tvalue pair\\n\\tpriority int\\n\\tindex int\\n}\\n\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n    if pq[i] == nil || pq[j] == nil {\\n        return false\\n    }\\n    return pq[i].priority > pq[j].priority\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n    if pq[i] != nil && pq[j] != nil {\\n        pq[i], pq[j] = pq[j], pq[i]\\n        pq[i].index = i\\n        pq[j].index = j\\n    }\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil\\n    if item != nil {\\n        item.index = -1\\n    }\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\nfunc (pq *PriorityQueue) update(item *Item, value pair, priority int) {\\n\\titem.value = value\\n\\titem.priority = priority\\n\\theap.Fix(pq, item.index)\\n}\\n\\nfunc min(a, b int64) int64 {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc dijkstras(node int, g [][]pair, visited *[]int64) {\\n    pq := make(PriorityQueue, len(*visited))\\n    pq[0] = &Item{ value: pair{0, node} }\\n    heap.Init(&pq)\\n    \\n    for pq.Len() > 0 {\\n        item := heap.Pop(&pq).(*Item)\\n        if item != nil {\\n            if (*visited)[item.value.value] == item.value.key {\\n                for _, c := range g[item.value.value] {\\n                    if (*visited)[c.key] > item.value.key + int64(c.value) {\\n                        (*visited)[c.key] = item.value.key + int64(c.value)\\n                        heap.Push(&pq, &Item{ value: pair{(*visited)[int(c.key)], int(c.key)} })\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nfunc minimumWeight(n int, edges [][]int, src1 int, src2 int, dest int) int64 {\\n    result := MAX\\n    g, rg := make([][]pair, n), make([][]pair, n)\\n    l1, l2, ld := make([]int64, n), make([]int64, n), make([]int64, n)\\n    for i := 0; i < n; i++ {\\n        l1[i], l2[i], ld[i] = MAX, MAX, MAX\\n    }\\n    l1[src1], l2[src2], ld[dest] = 0, 0, 0\\n    \\n    for _, edge := range edges {\\n        g[edge[0]] = append(g[edge[0]], pair{int64(edge[1]), edge[2]})\\n        rg[edge[1]] = append(rg[edge[1]], pair{int64(edge[0]), edge[2]})\\n    }\\n    \\n    dijkstras(src1, g, &l1)\\n    dijkstras(src2, g, &l2)\\n    dijkstras(dest, rg, &ld)\\n    \\n    if ld[src1] == MAX || ld[src2] == MAX {\\n        return -1\\n    }\\n    for i := 0; i < n; i++ {\\n        result = min(result, ld[i] + l1[i] + l2[i])\\n    }\\n    return result\\n}\\n```\\n\\n## Queue\\nI prefer Queue instead of Priority Queue because of its simplicity. But it took longer. Time: 387 ms | Space: 36.2 MB.\\n```\\nconst MAX = int64(10000000000)\\n\\ntype pair struct {\\n    key int64\\n    value int\\n}\\n\\nfunc min(a, b int64) int64 {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc dijkstras(node int, g [][]pair, visited *[]int64) {\\n    queue := []pair{ pair{0, node} }\\n    \\n    for len(queue) > 0 {\\n        item := queue[0]\\n        queue = queue[1:]\\n        if (*visited)[item.value] == item.key {\\n            for _, c := range g[item.value] {\\n                if (*visited)[c.key] > item.key + int64(c.value) {\\n                    (*visited)[c.key] = item.key + int64(c.value)\\n                    queue = append(queue, pair{(*visited)[int(c.key)], int(c.key)})\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nfunc minimumWeight(n int, edges [][]int, src1 int, src2 int, dest int) int64 {\\n    result := MAX\\n    g, rg := make([][]pair, n), make([][]pair, n)\\n    l1, l2, ld := make([]int64, n), make([]int64, n), make([]int64, n)\\n    for i := 0; i < n; i++ {\\n        l1[i], l2[i], ld[i] = MAX, MAX, MAX\\n    }\\n    l1[src1], l2[src2], ld[dest] = 0, 0, 0\\n    \\n    for _, edge := range edges {\\n        g[edge[0]] = append(g[edge[0]], pair{int64(edge[1]), edge[2]})\\n        rg[edge[1]] = append(rg[edge[1]], pair{int64(edge[0]), edge[2]})\\n    }\\n    \\n    dijkstras(src1, g, &l1)\\n    dijkstras(src2, g, &l2)\\n    dijkstras(dest, rg, &ld)\\n    \\n    if ld[src1] == MAX || ld[src2] == MAX {\\n        return -1\\n    }\\n    for i := 0; i < n; i++ {\\n        result = min(result, ld[i] + l1[i] + l2[i])\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nconst MAX = int64(10000000000)\\n\\ntype pair struct {\\n    key int64\\n    value int\\n}\\n\\ntype Item struct {\\n\\tvalue pair\\n\\tpriority int\\n\\tindex int\\n}\\n\\ntype PriorityQueue []*Item\\n\\nfunc (pq PriorityQueue) Len() int { return len(pq) }\\n\\nfunc (pq PriorityQueue) Less(i, j int) bool {\\n    if pq[i] == nil || pq[j] == nil {\\n        return false\\n    }\\n    return pq[i].priority > pq[j].priority\\n}\\n\\nfunc (pq PriorityQueue) Swap(i, j int) {\\n    if pq[i] != nil && pq[j] != nil {\\n        pq[i], pq[j] = pq[j], pq[i]\\n        pq[i].index = i\\n        pq[j].index = j\\n    }\\n}\\n\\nfunc (pq *PriorityQueue) Push(x interface{}) {\\n\\tn := len(*pq)\\n\\titem := x.(*Item)\\n\\titem.index = n\\n\\t*pq = append(*pq, item)\\n}\\n\\nfunc (pq *PriorityQueue) Pop() interface{} {\\n\\told := *pq\\n\\tn := len(old)\\n\\titem := old[n-1]\\n\\told[n-1] = nil\\n    if item != nil {\\n        item.index = -1\\n    }\\n\\t*pq = old[0 : n-1]\\n\\treturn item\\n}\\n\\nfunc (pq *PriorityQueue) update(item *Item, value pair, priority int) {\\n\\titem.value = value\\n\\titem.priority = priority\\n\\theap.Fix(pq, item.index)\\n}\\n\\nfunc min(a, b int64) int64 {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc dijkstras(node int, g [][]pair, visited *[]int64) {\\n    pq := make(PriorityQueue, len(*visited))\\n    pq[0] = &Item{ value: pair{0, node} }\\n    heap.Init(&pq)\\n    \\n    for pq.Len() > 0 {\\n        item := heap.Pop(&pq).(*Item)\\n        if item != nil {\\n            if (*visited)[item.value.value] == item.value.key {\\n                for _, c := range g[item.value.value] {\\n                    if (*visited)[c.key] > item.value.key + int64(c.value) {\\n                        (*visited)[c.key] = item.value.key + int64(c.value)\\n                        heap.Push(&pq, &Item{ value: pair{(*visited)[int(c.key)], int(c.key)} })\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nfunc minimumWeight(n int, edges [][]int, src1 int, src2 int, dest int) int64 {\\n    result := MAX\\n    g, rg := make([][]pair, n), make([][]pair, n)\\n    l1, l2, ld := make([]int64, n), make([]int64, n), make([]int64, n)\\n    for i := 0; i < n; i++ {\\n        l1[i], l2[i], ld[i] = MAX, MAX, MAX\\n    }\\n    l1[src1], l2[src2], ld[dest] = 0, 0, 0\\n    \\n    for _, edge := range edges {\\n        g[edge[0]] = append(g[edge[0]], pair{int64(edge[1]), edge[2]})\\n        rg[edge[1]] = append(rg[edge[1]], pair{int64(edge[0]), edge[2]})\\n    }\\n    \\n    dijkstras(src1, g, &l1)\\n    dijkstras(src2, g, &l2)\\n    dijkstras(dest, rg, &ld)\\n    \\n    if ld[src1] == MAX || ld[src2] == MAX {\\n        return -1\\n    }\\n    for i := 0; i < n; i++ {\\n        result = min(result, ld[i] + l1[i] + l2[i])\\n    }\\n    return result\\n}\\n```\n```\\nconst MAX = int64(10000000000)\\n\\ntype pair struct {\\n    key int64\\n    value int\\n}\\n\\nfunc min(a, b int64) int64 {\\n    if a < b {\\n        return a\\n    }\\n    return b\\n}\\n\\nfunc dijkstras(node int, g [][]pair, visited *[]int64) {\\n    queue := []pair{ pair{0, node} }\\n    \\n    for len(queue) > 0 {\\n        item := queue[0]\\n        queue = queue[1:]\\n        if (*visited)[item.value] == item.key {\\n            for _, c := range g[item.value] {\\n                if (*visited)[c.key] > item.key + int64(c.value) {\\n                    (*visited)[c.key] = item.key + int64(c.value)\\n                    queue = append(queue, pair{(*visited)[int(c.key)], int(c.key)})\\n                }\\n            }\\n        }\\n    }\\n}\\n\\nfunc minimumWeight(n int, edges [][]int, src1 int, src2 int, dest int) int64 {\\n    result := MAX\\n    g, rg := make([][]pair, n), make([][]pair, n)\\n    l1, l2, ld := make([]int64, n), make([]int64, n), make([]int64, n)\\n    for i := 0; i < n; i++ {\\n        l1[i], l2[i], ld[i] = MAX, MAX, MAX\\n    }\\n    l1[src1], l2[src2], ld[dest] = 0, 0, 0\\n    \\n    for _, edge := range edges {\\n        g[edge[0]] = append(g[edge[0]], pair{int64(edge[1]), edge[2]})\\n        rg[edge[1]] = append(rg[edge[1]], pair{int64(edge[0]), edge[2]})\\n    }\\n    \\n    dijkstras(src1, g, &l1)\\n    dijkstras(src2, g, &l2)\\n    dijkstras(dest, rg, &ld)\\n    \\n    if ld[src1] == MAX || ld[src2] == MAX {\\n        return -1\\n    }\\n    for i := 0; i < n; i++ {\\n        result = min(result, ld[i] + l1[i] + l2[i])\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1846304,
                "title": "swift-3-dijkstra-bisect-instead-of-heap-accepted",
                "content": "Swift doesn\\'t have Heap. I am using much easier binary search instead of heap.\\nEven through binary search is O(logn) and Array insert worst case  is O(n). But in most cases Array insert is not worst case.\\nSo even [fact binary search + Array insert] is O(n), it is able to pass most leetcode heap problems.\\n\\n```\\nclass Solution {\\n    func minimumWeight(_ n: Int, _ edges: [[Int]], _ src1: Int, _ src2: Int, _ dest: Int) -> Int {\\n        var G1 = Array(repeating: [(Int,Int)](), count: n), G2 = G1\\n        for v in edges\\n        {\\n            G1[v[0]].append((v[1], v[2]))\\n            G2[v[1]].append((v[0], v[2]))\\n        }\\n        let distance1 = dijkstra(G1, src1), distance2 = dijkstra(G1, src2), distance3 = dijkstra(G2, dest)\\n        var res = Int.max\\n        for (d1, (d2, d3)) in zip(distance1, zip(distance2, distance3)) where d1 != -1 && d2 != -1 && d3 != -1\\n        {\\n            res = min(res, d1+d2+d3)\\n        }\\n        return res == Int.max ? -1 : res\\n    }\\n    \\n    private func dijkstra(_ graph: [[(Int,Int)]], _ K: Int) -> [Int]\\n    {\\n        var res = Array(repeating: -1, count: graph.count), stack = [(K,0)]\\n        while let v = stack.popLast(), res[v.0] == -1\\n        {\\n            res[v.0] = v.1\\n            for (i, w) in graph[v.0]\\n            {\\n                maxSorted(&stack, (i, w+v.1))\\n            }\\n        }\\n        return res\\n    }\\n    \\n    private func maxSorted(_ arr: inout [(Int,Int)], _ x: (Int,Int))\\n    {\\n        var l = 0, r = arr.count\\n        while l < r\\n        {\\n            let m = (l+r)/2\\n            if arr[m].1 > x.1\\n            {\\n                l = m + 1\\n            }\\n            else\\n            {\\n                r = m\\n            }\\n        }\\n        arr.insert(x, at: l)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minimumWeight(_ n: Int, _ edges: [[Int]], _ src1: Int, _ src2: Int, _ dest: Int) -> Int {\\n        var G1 = Array(repeating: [(Int,Int)](), count: n), G2 = G1\\n        for v in edges\\n        {\\n            G1[v[0]].append((v[1], v[2]))\\n            G2[v[1]].append((v[0], v[2]))\\n        }\\n        let distance1 = dijkstra(G1, src1), distance2 = dijkstra(G1, src2), distance3 = dijkstra(G2, dest)\\n        var res = Int.max\\n        for (d1, (d2, d3)) in zip(distance1, zip(distance2, distance3)) where d1 != -1 && d2 != -1 && d3 != -1\\n        {\\n            res = min(res, d1+d2+d3)\\n        }\\n        return res == Int.max ? -1 : res\\n    }\\n    \\n    private func dijkstra(_ graph: [[(Int,Int)]], _ K: Int) -> [Int]\\n    {\\n        var res = Array(repeating: -1, count: graph.count), stack = [(K,0)]\\n        while let v = stack.popLast(), res[v.0] == -1\\n        {\\n            res[v.0] = v.1\\n            for (i, w) in graph[v.0]\\n            {\\n                maxSorted(&stack, (i, w+v.1))\\n            }\\n        }\\n        return res\\n    }\\n    \\n    private func maxSorted(_ arr: inout [(Int,Int)], _ x: (Int,Int))\\n    {\\n        var l = 0, r = arr.count\\n        while l < r\\n        {\\n            let m = (l+r)/2\\n            if arr[m].1 > x.1\\n            {\\n                l = m + 1\\n            }\\n            else\\n            {\\n                r = m\\n            }\\n        }\\n        arr.insert(x, at: l)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846034,
                "title": "c-dijikstras-easy-explanation-beginner-friendly-comments",
                "content": "```\\nIntuition : Find common shortest Middle Point from scr1 and scr2 through which dest is accessible.\\n```\\n**TC : O(ElogE) + O(V)**\\n**SC: O(E) + O(E)**\\n```\\n/*\\nFind Shortest distance from src1 to x (let\\'say)\\nFind Shortest distance from scr2 to x\\nFind the path from dest to x... reversed graph.\\n\\nHere we simply use dijkstra to find the all shortest distance to all other nodes from src1, scr2, dest (in reversed graph).\\n\\nNow, we will check for ith node, if src1[i] + src2[i] + dest[i] // for ith as middle point. if there path exist then it must be less than INF, we consider it as our answer, then pick the best minimum answer.\\n*/\\n```\\n```\\n#define ll long long\\nconst ll INF = 1000000000000000000;\\n\\nvector<pair<ll, ll>> adj[100005], adj2[100005];\\nll V; // total nodes \\n\\n// Normal Dijkstra : Returing distance array....\\nvector<ll> dijkstra(int src, bool origin) {\\n    priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;\\n    vector<ll> dist(V, INF);\\n    \\n    // {dist, node}\\n    pq.push({0, src});\\n    dist[src] = 0;\\n\\n    while(!pq.empty()){\\n        ll node = pq.top().second;\\n        ll nodeDist = pq.top().first;\\n        pq.pop(); \\n\\n        if(nodeDist > dist[node]) continue;\\n        // For Original Graph\\n        if(origin){\\n            for(auto it : adj[node]){\\n                ll next = it.first;\\n                ll weight = it.second;\\n                if(nodeDist + weight < dist[next]){\\n                    dist[next] = weight + nodeDist;\\n                    pq.push({dist[next], next});\\n                }\\n            }\\n        }else{ // For Reversed Graph\\n            for(auto it : adj2[node]){\\n                ll next = it.first;\\n                ll weight = it.second;\\n                if(nodeDist + weight < dist[next]){\\n                    dist[next] = weight + nodeDist;\\n                    pq.push({dist[next], next});\\n                }\\n            }\\n        }\\n    }\\n    return dist;\\n}\\n\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        V = n; // setting nodes\\n\\t\\t\\n        // Clearing Both Graphs\\n        for (int i=0; i<V; i++) {\\n            adj[i].clear(); \\n            adj2[i].clear();\\n        }\\n        \\n        for (vector<int> &i : edges) {\\n            adj[i[0]].push_back({i[1], i[2]}); // Original\\n            adj2[i[1]].push_back({i[0], i[2]});// Reversed\\n        }\\n\\n        vector<ll> a = dijkstra(src1, true), b = dijkstra(src2, true), c = dijkstra(dest, false);\\n        ll res = INF;\\n        for (int i=0; i<V; i++) {\\n            if(a[i] == INF || b[i] == INF || c[i] == INF) continue; // Path is not possible\\n            ll cur = a[i]+b[i]+c[i];\\n            res = min(res, cur); // picking the best available path\\n        }\\n        return (res == INF) ? -1 : res;\\n    }\\n};\\n```\\n**Doubt\\'s & Queries are most Welcome : )  \\uD83C\\uDF3B**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nIntuition : Find common shortest Middle Point from scr1 and scr2 through which dest is accessible.\\n```\n```\\n/*\\nFind Shortest distance from src1 to x (let\\'say)\\nFind Shortest distance from scr2 to x\\nFind the path from dest to x... reversed graph.\\n\\nHere we simply use dijkstra to find the all shortest distance to all other nodes from src1, scr2, dest (in reversed graph).\\n\\nNow, we will check for ith node, if src1[i] + src2[i] + dest[i] // for ith as middle point. if there path exist then it must be less than INF, we consider it as our answer, then pick the best minimum answer.\\n*/\\n```\n```\\n#define ll long long\\nconst ll INF = 1000000000000000000;\\n\\nvector<pair<ll, ll>> adj[100005], adj2[100005];\\nll V; // total nodes \\n\\n// Normal Dijkstra : Returing distance array....\\nvector<ll> dijkstra(int src, bool origin) {\\n    priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;\\n    vector<ll> dist(V, INF);\\n    \\n    // {dist, node}\\n    pq.push({0, src});\\n    dist[src] = 0;\\n\\n    while(!pq.empty()){\\n        ll node = pq.top().second;\\n        ll nodeDist = pq.top().first;\\n        pq.pop(); \\n\\n        if(nodeDist > dist[node]) continue;\\n        // For Original Graph\\n        if(origin){\\n            for(auto it : adj[node]){\\n                ll next = it.first;\\n                ll weight = it.second;\\n                if(nodeDist + weight < dist[next]){\\n                    dist[next] = weight + nodeDist;\\n                    pq.push({dist[next], next});\\n                }\\n            }\\n        }else{ // For Reversed Graph\\n            for(auto it : adj2[node]){\\n                ll next = it.first;\\n                ll weight = it.second;\\n                if(nodeDist + weight < dist[next]){\\n                    dist[next] = weight + nodeDist;\\n                    pq.push({dist[next], next});\\n                }\\n            }\\n        }\\n    }\\n    return dist;\\n}\\n\\nclass Solution {\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        V = n; // setting nodes\\n\\t\\t\\n        // Clearing Both Graphs\\n        for (int i=0; i<V; i++) {\\n            adj[i].clear(); \\n            adj2[i].clear();\\n        }\\n        \\n        for (vector<int> &i : edges) {\\n            adj[i[0]].push_back({i[1], i[2]}); // Original\\n            adj2[i[1]].push_back({i[0], i[2]});// Reversed\\n        }\\n\\n        vector<ll> a = dijkstra(src1, true), b = dijkstra(src2, true), c = dijkstra(dest, false);\\n        ll res = INF;\\n        for (int i=0; i<V; i++) {\\n            if(a[i] == INF || b[i] == INF || c[i] == INF) continue; // Path is not possible\\n            ll cur = a[i]+b[i]+c[i];\\n            res = min(res, cur); // picking the best available path\\n        }\\n        return (res == INF) ? -1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845983,
                "title": "simple-solution-in-java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        /* \\n            For finding the minmum weighted subgraph, there will be a node from the src1 and src2,\\n            after which the path from that node to the destination will be same \\n        */\\n        \\n        HashMap<Integer, List<Edge>> map = new HashMap<>();\\n        HashMap<Integer, List<Edge>> revMap = new HashMap<>();\\n        for(int[] e : edges){\\n            map.computeIfAbsent(e[0], k -> new ArrayList<>()).add(new Edge(e[1], e[2]));\\n            revMap.computeIfAbsent(e[1], k -> new ArrayList<>()).add(new Edge(e[0], e[2]));\\n        }\\n        \\n        \\n        long[] dis1 = new long[n]; // From src1\\n        long[] dis2 = new long[n]; // From src2 \\n        long[] dis3 = new long[n]; // From dest\\n        \\n        findShortestDistance(src1, dis1, map);\\n        findShortestDistance(src2, dis2, map);\\n        findShortestDistance(dest, dis3, revMap);\\n        \\n        long ans = Long.MAX_VALUE;\\n        \\n        for(int i=0; i<n; i++){\\n            if(dis1[i] != Long.MAX_VALUE && dis2[i] != Long.MAX_VALUE && dis3[i] != Long.MAX_VALUE){\\n                long t = dis1[i] + dis2[i] + dis3[i];\\n                ans = Math.min(ans, t);\\n            }\\n        }\\n        \\n        return ans == Long.MAX_VALUE ? -1 : ans;\\n    }\\n    \\n    // Dijikstra\\n    private void findShortestDistance(int source, long[] dist, HashMap<Integer, List<Edge>> map){\\n        Arrays.fill(dist, Long.MAX_VALUE);\\n        dist[source] = 0;\\n        \\n        // Min Heap\\n        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> Long.compare(a.weight, b.weight));\\n        pq.offer(new Edge(source, 0));\\n        \\n        \\n        while(!pq.isEmpty()){\\n            Edge ed = pq.poll();\\n            \\n            if(ed.weight > dist[ed.node]) continue;\\n            \\n            // Check if there are neighbors\\n            if(!map.containsKey(ed.node)) continue;\\n            \\n            for(Edge neigh : map.get(ed.node)){\\n                if(dist[ed.node] + neigh.weight < dist[neigh.node]){\\n                    dist[neigh.node] = dist[ed.node] + neigh.weight;\\n                    pq.offer(new Edge(neigh.node, dist[neigh.node]));\\n                }\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n    private class Edge{\\n        public int node;\\n        public long weight;\\n        \\n        public Edge(int node, long weight){\\n            this.node = node;\\n            this.weight = weight;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        /* \\n            For finding the minmum weighted subgraph, there will be a node from the src1 and src2,\\n            after which the path from that node to the destination will be same \\n        */\\n        \\n        HashMap<Integer, List<Edge>> map = new HashMap<>();\\n        HashMap<Integer, List<Edge>> revMap = new HashMap<>();\\n        for(int[] e : edges){\\n            map.computeIfAbsent(e[0], k -> new ArrayList<>()).add(new Edge(e[1], e[2]));\\n            revMap.computeIfAbsent(e[1], k -> new ArrayList<>()).add(new Edge(e[0], e[2]));\\n        }\\n        \\n        \\n        long[] dis1 = new long[n]; // From src1\\n        long[] dis2 = new long[n]; // From src2 \\n        long[] dis3 = new long[n]; // From dest\\n        \\n        findShortestDistance(src1, dis1, map);\\n        findShortestDistance(src2, dis2, map);\\n        findShortestDistance(dest, dis3, revMap);\\n        \\n        long ans = Long.MAX_VALUE;\\n        \\n        for(int i=0; i<n; i++){\\n            if(dis1[i] != Long.MAX_VALUE && dis2[i] != Long.MAX_VALUE && dis3[i] != Long.MAX_VALUE){\\n                long t = dis1[i] + dis2[i] + dis3[i];\\n                ans = Math.min(ans, t);\\n            }\\n        }\\n        \\n        return ans == Long.MAX_VALUE ? -1 : ans;\\n    }\\n    \\n    // Dijikstra\\n    private void findShortestDistance(int source, long[] dist, HashMap<Integer, List<Edge>> map){\\n        Arrays.fill(dist, Long.MAX_VALUE);\\n        dist[source] = 0;\\n        \\n        // Min Heap\\n        PriorityQueue<Edge> pq = new PriorityQueue<>((a, b) -> Long.compare(a.weight, b.weight));\\n        pq.offer(new Edge(source, 0));\\n        \\n        \\n        while(!pq.isEmpty()){\\n            Edge ed = pq.poll();\\n            \\n            if(ed.weight > dist[ed.node]) continue;\\n            \\n            // Check if there are neighbors\\n            if(!map.containsKey(ed.node)) continue;\\n            \\n            for(Edge neigh : map.get(ed.node)){\\n                if(dist[ed.node] + neigh.weight < dist[neigh.node]){\\n                    dist[neigh.node] = dist[ed.node] + neigh.weight;\\n                    pq.offer(new Edge(neigh.node, dist[neigh.node]));\\n                }\\n            }\\n        }\\n        \\n        return;\\n    }\\n    \\n    private class Edge{\\n        public int node;\\n        public long weight;\\n        \\n        public Edge(int node, long weight){\\n            this.node = node;\\n            this.weight = weight;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845956,
                "title": "java-clean-code",
                "content": "```java\\nclass Solution {\\n  private static final long INF = Long.MAX_VALUE >> 1;\\n\\n  public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n    List<int[]>[] graph = new List[n];\\n    List<int[]>[] revGraph = new List[n];\\n    for (int i = 0; i < n; i++) {\\n      graph[i] = new ArrayList<>();\\n      revGraph[i] = new ArrayList<>();\\n    }\\n    for (var edge : edges) {\\n      int u = edge[0], v = edge[1], w = edge[2];\\n      graph[u].add(new int[] {v, w});\\n      revGraph[v].add(new int[] {u, w});\\n    }\\n\\n    long[] dist1 = dijkstra(graph, src1);\\n    long[] dist2 = dijkstra(graph, src2);\\n    long[] dist3 = dijkstra(revGraph, dest);\\n\\n    long ans = INF;\\n\\n    for (int i = 0; i < n; i++) {\\n      if (dist1[i] == INF || dist2[i] == INF || dist3[i] == INF) continue;\\n\\n      ans = Math.min(ans, dist1[i] + dist2[i] + dist3[i]);\\n    }\\n\\n    return ans == INF ? -1 : ans;\\n  }\\n\\n  private long[] dijkstra(List<int[]>[] graph, int start) {\\n    int n = graph.length;\\n\\n    // [node(int), dist(long)]\\n    Queue<long[]> queue = new PriorityQueue<>((a, b) -> Long.compare(a[1], b[1]));\\n    long[] dist = new long[n];\\n    Arrays.fill(dist, INF);\\n\\n    dist[start] = 0;\\n    queue.add(new long[] {start, dist[start]});\\n\\n    while (!queue.isEmpty()) {\\n      long[] curr = queue.poll();\\n      int u = (int) curr[0];\\n      long d = curr[1];\\n\\n      if (d != dist[u]) continue;\\n\\n      for (int[] next : graph[u]) {\\n        int v = next[0], w = next[1];\\n\\n        if (dist[u] + w < dist[v]) {\\n          dist[v] = dist[u] + w;\\n          queue.add(new long[] {v, dist[v]});\\n        }\\n      }\\n    }\\n\\n    return dist;\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n  private static final long INF = Long.MAX_VALUE >> 1;\\n\\n  public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n    List<int[]>[] graph = new List[n];\\n    List<int[]>[] revGraph = new List[n];\\n    for (int i = 0; i < n; i++) {\\n      graph[i] = new ArrayList<>();\\n      revGraph[i] = new ArrayList<>();\\n    }\\n    for (var edge : edges) {\\n      int u = edge[0], v = edge[1], w = edge[2];\\n      graph[u].add(new int[] {v, w});\\n      revGraph[v].add(new int[] {u, w});\\n    }\\n\\n    long[] dist1 = dijkstra(graph, src1);\\n    long[] dist2 = dijkstra(graph, src2);\\n    long[] dist3 = dijkstra(revGraph, dest);\\n\\n    long ans = INF;\\n\\n    for (int i = 0; i < n; i++) {\\n      if (dist1[i] == INF || dist2[i] == INF || dist3[i] == INF) continue;\\n\\n      ans = Math.min(ans, dist1[i] + dist2[i] + dist3[i]);\\n    }\\n\\n    return ans == INF ? -1 : ans;\\n  }\\n\\n  private long[] dijkstra(List<int[]>[] graph, int start) {\\n    int n = graph.length;\\n\\n    // [node(int), dist(long)]\\n    Queue<long[]> queue = new PriorityQueue<>((a, b) -> Long.compare(a[1], b[1]));\\n    long[] dist = new long[n];\\n    Arrays.fill(dist, INF);\\n\\n    dist[start] = 0;\\n    queue.add(new long[] {start, dist[start]});\\n\\n    while (!queue.isEmpty()) {\\n      long[] curr = queue.poll();\\n      int u = (int) curr[0];\\n      long d = curr[1];\\n\\n      if (d != dist[u]) continue;\\n\\n      for (int[] next : graph[u]) {\\n        int v = next[0], w = next[1];\\n\\n        if (dist[u] + w < dist[v]) {\\n          dist[v] = dist[u] + w;\\n          queue.add(new long[] {v, dist[v]});\\n        }\\n      }\\n    }\\n\\n    return dist;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845594,
                "title": "c-dijkstra-solution",
                "content": "Runtime: 763 ms, faster than 57.14% of C++ online submissions for Minimum Weighted Subgraph With the Required Paths.\\nMemory Usage: 139.7 MB, less than 57.14% of C++ online submissions for Minimum Weighted Subgraph With the Required Paths.\\n\\n\\n```\\nStore all nodes distance from both source and destination using Dijkstra algo.\\nLoop through all nodes and get the minimum sum of distance of each node\\'s distance\\nfrom both source and destination.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // Dijkstra algo to get all node\\'s minimum distance from start node\\n    void Dijksrta(int start, vector<vector<pair<int,int>>>&graph, vector<long long>& dist)\\n    {\\n        dist[start] = 0;\\n        priority_queue<pair<long long, int>,vector<pair<long long, int>>,greater<pair<long long, int>>>pQ;\\n        pQ.push({dist[start],start});\\n        \\n        long long cost;\\n        int node;\\n        while(!pQ.empty())\\n        {\\n            cost = pQ.top().first;\\n            node = pQ.top().second;\\n            pQ.pop();\\n            \\n            if(dist[node]<cost)continue;\\n            \\n            for(int i=0;i<graph[node].size();i++)\\n            {\\n                if(dist[graph[node][i].first]>(long long)graph[node][i].second+cost)\\n                {\\n                    dist[graph[node][i].first] = (long long)graph[node][i].second+cost;\\n                    pQ.push({dist[graph[node][i].first],graph[node][i].first});\\n                }\\n            }\\n        }\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        \\n        // distance vector of both source and destiantion\\n        vector<long long>ds1(n,LLONG_MAX);\\n        vector<long long>ds2(n,LLONG_MAX);\\n        vector<long long>dd(n,LLONG_MAX);\\n        \\n        // create graph and reverse graph\\n        vector<vector<pair<int,int>>>graph(n);\\n        vector<vector<pair<int,int>>>revgraph(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            graph[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            revgraph[edges[i][1]].push_back({edges[i][0],edges[i][2]});            \\n        }\\n\\n        // run Dijkstra for both source and destination\\n        Dijksrta(src1,graph,ds1);\\n        Dijksrta(src2,graph,ds2);\\n        Dijksrta(dest,revgraph,dd);\\n        \\n        // return -1 if any source to destination is not possible\\n        if(ds1[dest]==LLONG_MAX || ds2[dest]==LLONG_MAX) return -1;\\n        \\n        // loop through all node\\'s distance from both source and destination\\n        long long res = LLONG_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ds1[i]==LLONG_MAX || ds2[i]==LLONG_MAX || dd[i]==LLONG_MAX)continue;\\n            res = min(res,ds1[i]+ds2[i]+dd[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nStore all nodes distance from both source and destination using Dijkstra algo.\\nLoop through all nodes and get the minimum sum of distance of each node\\'s distance\\nfrom both source and destination.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // Dijkstra algo to get all node\\'s minimum distance from start node\\n    void Dijksrta(int start, vector<vector<pair<int,int>>>&graph, vector<long long>& dist)\\n    {\\n        dist[start] = 0;\\n        priority_queue<pair<long long, int>,vector<pair<long long, int>>,greater<pair<long long, int>>>pQ;\\n        pQ.push({dist[start],start});\\n        \\n        long long cost;\\n        int node;\\n        while(!pQ.empty())\\n        {\\n            cost = pQ.top().first;\\n            node = pQ.top().second;\\n            pQ.pop();\\n            \\n            if(dist[node]<cost)continue;\\n            \\n            for(int i=0;i<graph[node].size();i++)\\n            {\\n                if(dist[graph[node][i].first]>(long long)graph[node][i].second+cost)\\n                {\\n                    dist[graph[node][i].first] = (long long)graph[node][i].second+cost;\\n                    pQ.push({dist[graph[node][i].first],graph[node][i].first});\\n                }\\n            }\\n        }\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        \\n        // distance vector of both source and destiantion\\n        vector<long long>ds1(n,LLONG_MAX);\\n        vector<long long>ds2(n,LLONG_MAX);\\n        vector<long long>dd(n,LLONG_MAX);\\n        \\n        // create graph and reverse graph\\n        vector<vector<pair<int,int>>>graph(n);\\n        vector<vector<pair<int,int>>>revgraph(n);\\n        for(int i=0;i<edges.size();i++)\\n        {\\n            graph[edges[i][0]].push_back({edges[i][1],edges[i][2]});\\n            revgraph[edges[i][1]].push_back({edges[i][0],edges[i][2]});            \\n        }\\n\\n        // run Dijkstra for both source and destination\\n        Dijksrta(src1,graph,ds1);\\n        Dijksrta(src2,graph,ds2);\\n        Dijksrta(dest,revgraph,dd);\\n        \\n        // return -1 if any source to destination is not possible\\n        if(ds1[dest]==LLONG_MAX || ds2[dest]==LLONG_MAX) return -1;\\n        \\n        // loop through all node\\'s distance from both source and destination\\n        long long res = LLONG_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(ds1[i]==LLONG_MAX || ds2[i]==LLONG_MAX || dd[i]==LLONG_MAX)continue;\\n            res = min(res,ds1[i]+ds2[i]+dd[i]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845553,
                "title": "javascript-dijkstra-1363ms",
                "content": "```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packDGCost = (g, ig, edges) => {\\n    for (const [u, v, cost] of edges) {\\n        g[u].push([v, cost]);\\n        ig[v].push([u, cost]);\\n    }\\n};\\n\\nconst minimumWeight = (n, edges, src1, src2, dest) => {\\n    let g = initializeGraph(n), ig = initializeGraph(n);\\n    packDGCost(g, ig, edges);\\n\\t/*\\n        src1 -> x\\n        src2 -> x\\n        x -> dest  find smallest distance from all nodes to the destination, run Dijkstra in reverse from the destination\\n     */\\n    let d1 = dijkstra(g, src1), d2 = dijkstra(g, src2), d3 = dijkstra(ig, dest), res = Number.MAX_SAFE_INTEGER;\\n    for (let i = 0; i < n; i++) res = Math.min(res, d1[i] + d2[i] + d3[i]);\\n    return res == Number.MAX_SAFE_INTEGER ? -1 : res;\\n};\\n\\nconst dijkstra = (g, start) => { // store the shortest distance from startNode to all other nodes\\n    let n = g.length, dis = Array(n).fill(Number.MAX_SAFE_INTEGER);\\n    let pq = new MinPriorityQueue({\\n        compare: (x, y) => {\\n            if (x[0] != y[0]) return x[0] - y[0];\\n            return x[1] - y[1];\\n        }\\n    });\\n    dis[start] = 0;\\n    pq.enqueue([start, 0]);\\n    while (pq.size()) {\\n        let [cur, d] = pq.dequeue();\\n        if (d > dis[cur]) continue; // larger distance, no need to find the route to next node\\n        for (const [child, cost] of g[cur]) {\\n            let toChildCost = d + cost;\\n            if (toChildCost < dis[child]) { // each time total wight/cost to current child is smaller, updated it\\n                dis[child] = toChildCost;\\n                pq.enqueue([child, toChildCost]);\\n            }\\n        }\\n    }\\n    return dis;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst initializeGraph = (n) => { let g = []; for (let i = 0; i < n; i++) { g.push([]); } return g; };\\nconst packDGCost = (g, ig, edges) => {\\n    for (const [u, v, cost] of edges) {\\n        g[u].push([v, cost]);\\n        ig[v].push([u, cost]);\\n    }\\n};\\n\\nconst minimumWeight = (n, edges, src1, src2, dest) => {\\n    let g = initializeGraph(n), ig = initializeGraph(n);\\n    packDGCost(g, ig, edges);\\n\\t/*\\n        src1 -> x\\n        src2 -> x\\n        x -> dest  find smallest distance from all nodes to the destination, run Dijkstra in reverse from the destination\\n     */\\n    let d1 = dijkstra(g, src1), d2 = dijkstra(g, src2), d3 = dijkstra(ig, dest), res = Number.MAX_SAFE_INTEGER;\\n    for (let i = 0; i < n; i++) res = Math.min(res, d1[i] + d2[i] + d3[i]);\\n    return res == Number.MAX_SAFE_INTEGER ? -1 : res;\\n};\\n\\nconst dijkstra = (g, start) => { // store the shortest distance from startNode to all other nodes\\n    let n = g.length, dis = Array(n).fill(Number.MAX_SAFE_INTEGER);\\n    let pq = new MinPriorityQueue({\\n        compare: (x, y) => {\\n            if (x[0] != y[0]) return x[0] - y[0];\\n            return x[1] - y[1];\\n        }\\n    });\\n    dis[start] = 0;\\n    pq.enqueue([start, 0]);\\n    while (pq.size()) {\\n        let [cur, d] = pq.dequeue();\\n        if (d > dis[cur]) continue; // larger distance, no need to find the route to next node\\n        for (const [child, cost] of g[cur]) {\\n            let toChildCost = d + cost;\\n            if (toChildCost < dis[child]) { // each time total wight/cost to current child is smaller, updated it\\n                dis[child] = toChildCost;\\n                pq.enqueue([child, toChildCost]);\\n            }\\n        }\\n    }\\n    return dis;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1845502,
                "title": "c-dijkstra-explained",
                "content": "There is a simple logic behind this problem. It is based on concept of single source shortest path. So you can simply solve this using dijkstra algorithm. \\n\\nI am using 3 vectors : \\n`d1[] -> distance of each node from src1`\\n`d2[] -> distance of each node from src2`\\n`d3[] -> distance of each node from dest`\\n\\nNow , let us suppose that there is a node **i** which lies in the shortest path from **src1 -> dest** and also **src2 -> dest** . Then the final answer will be : \\n**distance from src1-> i + distance from src2->i + distance from i->dest**\\n\\n`ans = d1[i] + d2[i] + d3[i] ` \\nWe have to take the minimum for each node **i** from `0 to n-1`\\n\\nPlease have a look at the code for understanding:\\n\\n```\\n#define lli long long\\nclass Solution {\\npublic:\\n    const lli INF = (lli)1e16;\\n    vector<pair<int,lli>> g[100005];   //graph as adjacency list for fast runtime\\n    \\n    \\n    //Dijkstra algorithm for calculating distance from src to each node \\n    vector<lli> dk(int src , int n) {\\n        \\n        vector<lli> d(n+1,INF);\\n        d[src] = 0;\\n        \\n        vector<bool> vis(n,false);\\n        \\n        priority_queue< pair<lli,int>, vector<pair<lli,int>> , greater<pair<lli,int>>> q;\\n        q.push({0,src});\\n        \\n        while(!q.empty()) {\\n            auto p = q.top(); q.pop();\\n            lli wt = p.first;\\n            int v = p.second;\\n            \\n            if(vis[v]) continue;\\n            \\n            vis[v] = true;\\n            for(auto ch:g[v]) {\\n                if(!vis[ch.first] && wt+ch.second < d[ch.first])  {\\n                    d[ch.first] = wt+ch.second;\\n                    q.push({d[ch.first] , ch.first});\\n                }\\n            }\\n        }\\n        return d;\\n        \\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        for(auto v:edges) g[v[0]].push_back({v[1],v[2]});\\n        vector<lli> d1 = dk(src1,n);    //distance from src1 to each node\\n        vector<lli> d2 = dk(src2,n);    //distance from src2 to each node\\n        \\n        //Graph reversal for calculating d3[]\\n        for(auto &v:g) v.clear();\\n        for(auto v:edges) g[v[1]].push_back({v[0],v[2]});\\n        \\n        vector<lli> d3 = dk(dest,n);    //distance from dest to each node\\n        \\n        \\n        if(d1[dest]==INF || d2[dest]==INF) return -1;   \\n        \\n        \\n        lli ans = d1[dest] + d2[dest];\\n        for(int i=0; i<n; i++) {\\n            ans = min(ans,d1[i] + d2[i] + d3[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define lli long long\\nclass Solution {\\npublic:\\n    const lli INF = (lli)1e16;\\n    vector<pair<int,lli>> g[100005];   //graph as adjacency list for fast runtime\\n    \\n    \\n    //Dijkstra algorithm for calculating distance from src to each node \\n    vector<lli> dk(int src , int n) {\\n        \\n        vector<lli> d(n+1,INF);\\n        d[src] = 0;\\n        \\n        vector<bool> vis(n,false);\\n        \\n        priority_queue< pair<lli,int>, vector<pair<lli,int>> , greater<pair<lli,int>>> q;\\n        q.push({0,src});\\n        \\n        while(!q.empty()) {\\n            auto p = q.top(); q.pop();\\n            lli wt = p.first;\\n            int v = p.second;\\n            \\n            if(vis[v]) continue;\\n            \\n            vis[v] = true;\\n            for(auto ch:g[v]) {\\n                if(!vis[ch.first] && wt+ch.second < d[ch.first])  {\\n                    d[ch.first] = wt+ch.second;\\n                    q.push({d[ch.first] , ch.first});\\n                }\\n            }\\n        }\\n        return d;\\n        \\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        for(auto v:edges) g[v[0]].push_back({v[1],v[2]});\\n        vector<lli> d1 = dk(src1,n);    //distance from src1 to each node\\n        vector<lli> d2 = dk(src2,n);    //distance from src2 to each node\\n        \\n        //Graph reversal for calculating d3[]\\n        for(auto &v:g) v.clear();\\n        for(auto v:edges) g[v[1]].push_back({v[0],v[2]});\\n        \\n        vector<lli> d3 = dk(dest,n);    //distance from dest to each node\\n        \\n        \\n        if(d1[dest]==INF || d2[dest]==INF) return -1;   \\n        \\n        \\n        lli ans = d1[dest] + d2[dest];\\n        for(int i=0; i<n; i++) {\\n            ans = min(ans,d1[i] + d2[i] + d3[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845370,
                "title": "java-easy-to-understand-dijkstra-important",
                "content": "```\\nclass Solution \\n{\\n    class Pair\\n    {\\n        int v;\\n        long weight;\\n        Pair(int v, long weight)\\n        {\\n            this.v = v;\\n            this.weight = weight;\\n        }\\n    }\\n    \\n    long MAX = (long)1e15;\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) \\n    {\\n        ArrayList<ArrayList<Pair>> adj, revAdj;\\n        adj = new ArrayList<>();\\n        revAdj = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n            revAdj.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] e: edges)\\n        {\\n            adj.get(e[0]).add(new Pair(e[1], e[2]));\\n            revAdj.get(e[1]).add(new Pair(e[0], e[2]));\\n        }\\n        long[] d1 = bfs(adj, n, src1);//src1 to all nodes\\n        long[] d2 = bfs(adj, n, src2);//src2 to all nodes\\n        long[] d3 = bfs(revAdj, n, dest);//dest to all nodes\\n        \\n        //Find 1 common point\\n        long res = Long.MAX_VALUE;\\n        for(int i=0;i<n;i++)\\n        {\\n            res = Math.min(res, d1[i] + d2[i] + d3[i]);\\n        }\\n        return res >= MAX ? -1 : res;\\n    }\\n    \\n    public long[] bfs(ArrayList<ArrayList<Pair>> adj, int n, int s)\\n    {\\n        long[] dist = new long[n];\\n        Arrays.fill(dist, MAX);\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((x1, x2) -> (int)(x1.weight-x2.weight));\\n        pq.add(new Pair(s, 0));\\n        dist[s] = 0;\\n        \\n        while(!pq.isEmpty())\\n        {\\n            Pair p = pq.poll();\\n            int u = p.v;\\n            long w = p.weight;\\n            if(w > dist[u])\\n                continue;\\n            \\n            for(Pair p1: adj.get(u))\\n            {\\n                int v = p1.v;\\n                long weight = p1.weight;\\n                if(dist[v] > dist[u] + weight)\\n                {\\n                    dist[v] = dist[u] + weight;\\n                    pq.add(new Pair(v, dist[v]));\\n                }   \\n            }\\n        }\\n        return dist;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nclass Solution \\n{\\n    class Pair\\n    {\\n        int v;\\n        long weight;\\n        Pair(int v, long weight)\\n        {\\n            this.v = v;\\n            this.weight = weight;\\n        }\\n    }\\n    \\n    long MAX = (long)1e15;\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) \\n    {\\n        ArrayList<ArrayList<Pair>> adj, revAdj;\\n        adj = new ArrayList<>();\\n        revAdj = new ArrayList<>();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            adj.add(new ArrayList<>());\\n            revAdj.add(new ArrayList<>());\\n        }\\n        \\n        for(int[] e: edges)\\n        {\\n            adj.get(e[0]).add(new Pair(e[1], e[2]));\\n            revAdj.get(e[1]).add(new Pair(e[0], e[2]));\\n        }\\n        long[] d1 = bfs(adj, n, src1);//src1 to all nodes\\n        long[] d2 = bfs(adj, n, src2);//src2 to all nodes\\n        long[] d3 = bfs(revAdj, n, dest);//dest to all nodes\\n        \\n        //Find 1 common point\\n        long res = Long.MAX_VALUE;\\n        for(int i=0;i<n;i++)\\n        {\\n            res = Math.min(res, d1[i] + d2[i] + d3[i]);\\n        }\\n        return res >= MAX ? -1 : res;\\n    }\\n    \\n    public long[] bfs(ArrayList<ArrayList<Pair>> adj, int n, int s)\\n    {\\n        long[] dist = new long[n];\\n        Arrays.fill(dist, MAX);\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((x1, x2) -> (int)(x1.weight-x2.weight));\\n        pq.add(new Pair(s, 0));\\n        dist[s] = 0;\\n        \\n        while(!pq.isEmpty())\\n        {\\n            Pair p = pq.poll();\\n            int u = p.v;\\n            long w = p.weight;\\n            if(w > dist[u])\\n                continue;\\n            \\n            for(Pair p1: adj.get(u))\\n            {\\n                int v = p1.v;\\n                long weight = p1.weight;\\n                if(dist[v] > dist[u] + weight)\\n                {\\n                    dist[v] = dist[u] + weight;\\n                    pq.add(new Pair(v, dist[v]));\\n                }   \\n            }\\n        }\\n        return dist;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845231,
                "title": "java-dijkstra",
                "content": "```\\n\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        int node = 0, nextNode = 0, weight = 0;\\n        int[] current = null;\\n        long[] firstCost = new long[n], secondCost = new long[n], cost = new long[n];\\n        Set<int[]> neighbours = null;\\n        Map<Integer, Set<int[]>> graph = new HashMap<>();\\n        PriorityQueue<int[]> queue = new PriorityQueue<>(new Comparator<>() {\\n            public int compare(int[] left1, int[] right1) {\\n                int left = left1[0];\\n                int right = right1[0];\\n                boolean firstReachedLeft = (left1[1] == 1), secondReachedLeft = (left1[2] == 1), firstReachedRight = (right1[1] == 1), secondReachedRight = (right1[2] == 1);\\n                if((firstReachedLeft && secondReachedLeft) && (firstReachedRight && secondReachedRight)) {\\n                    if(cost[left] < cost[right]) {\\n                        return -1;\\n                    }\\n                    if(cost[left] > cost[right]) {\\n                        return 1;\\n                    }\\n                    return 0;\\n                }\\n                if(firstReachedLeft && secondReachedLeft) {\\n                    return -1;\\n                }\\n                if(firstReachedRight && secondReachedRight) {\\n                    return 1;\\n                }\\n                if(firstReachedLeft && firstReachedRight) {\\n                    if(firstCost[left] < firstCost[right]) {\\n                        return -1;\\n                    }\\n                    if(firstCost[left] > firstCost[right]) {\\n                        return 1;\\n                    }\\n                    return 0;\\n                }\\n                if(secondReachedLeft && secondReachedRight) {\\n                    if(secondCost[left] < secondCost[right]) {\\n                        return -1;\\n                    }\\n                    if(secondCost[left] > secondCost[right]) {\\n                        return 1;\\n                    }\\n                    return 0;\\n                }\\n                if(firstReachedLeft) {\\n                    if(firstCost[left] < secondCost[right]) {\\n                        return -1;\\n                    }\\n                    if(firstCost[left] > secondCost[right]) {\\n                        return 1;\\n                    }\\n                    return 0;\\n                }\\n                if(secondCost[left] < firstCost[right]) {\\n                    return -1;\\n                }\\n                if(secondCost[left] > firstCost[right]) {\\n                    return 1;\\n                }\\n                return 0;\\n            }\\n        });\\n        Arrays.fill(firstCost, Long.MAX_VALUE);\\n        Arrays.fill(secondCost, Long.MAX_VALUE);\\n        Arrays.fill(cost, Long.MAX_VALUE);\\n        for(int[] edge : edges) {\\n            neighbours = graph.getOrDefault(edge[0], new HashSet<>());\\n            neighbours.add(new int[] {edge[1], edge[2]});\\n            graph.put(edge[0], neighbours);\\n        }\\n        firstCost[src1] = 0;\\n        secondCost[src2] = 0;\\n        queue.add(new int[] {src1, 1, 0});\\n        queue.add(new int[] {src2, 0, 1});\\n        while(!queue.isEmpty()) {\\n            current = queue.poll();\\n            node = current[0];\\n            if(graph.containsKey(node)) {\\n                for(int[] next : graph.get(node)) {\\n                    nextNode = next[0];\\n                    weight = next[1];\\n                    if(current[1] == 1 && current[2] == 1) {\\n                        if(cost[nextNode] > (cost[node] + weight)) {\\n                            cost[nextNode] = (cost[node] + weight);\\n                            queue.add(new int[] {nextNode, 1, 1});\\n                        }\\n                    } else if(current[1] == 1) {\\n                        if(firstCost[nextNode] > (firstCost[node] + weight)) {\\n                            firstCost[nextNode] = (firstCost[node] + weight);\\n                            queue.add(new int[] {nextNode, 1, 0});\\n                        }\\n                        if(secondCost[node] != Long.MAX_VALUE) {\\n                            if(cost[nextNode] > (firstCost[node] + secondCost[node] + weight)) {\\n                                cost[nextNode] = (firstCost[node] + secondCost[node] + weight);\\n                                queue.add(new int[] {nextNode, 1, 1});\\n                            }\\n                        }\\n                    } else {\\n                        if(secondCost[nextNode] > (secondCost[node] + weight)) {\\n                            secondCost[nextNode] = (secondCost[node] + weight);\\n                            queue.add(new int[] {nextNode, 0, 1});\\n                        }\\n                        if(firstCost[node] != Long.MAX_VALUE) {\\n                            if(cost[nextNode] > (firstCost[node] + secondCost[node] + weight)) {\\n                                cost[nextNode] = (firstCost[node] + secondCost[node] + weight);\\n                                queue.add(new int[] {nextNode, 1, 1});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(firstCost[dest] == Long.MAX_VALUE || secondCost[dest] == Long.MAX_VALUE) {\\n            return -1;\\n        }\\n        return Math.min((firstCost[dest] + secondCost[dest]), cost[dest]);\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        int node = 0, nextNode = 0, weight = 0;\\n        int[] current = null;\\n        long[] firstCost = new long[n], secondCost = new long[n], cost = new long[n];\\n        Set<int[]> neighbours = null;\\n        Map<Integer, Set<int[]>> graph = new HashMap<>();\\n        PriorityQueue<int[]> queue = new PriorityQueue<>(new Comparator<>() {\\n            public int compare(int[] left1, int[] right1) {\\n                int left = left1[0];\\n                int right = right1[0];\\n                boolean firstReachedLeft = (left1[1] == 1), secondReachedLeft = (left1[2] == 1), firstReachedRight = (right1[1] == 1), secondReachedRight = (right1[2] == 1);\\n                if((firstReachedLeft && secondReachedLeft) && (firstReachedRight && secondReachedRight)) {\\n                    if(cost[left] < cost[right]) {\\n                        return -1;\\n                    }\\n                    if(cost[left] > cost[right]) {\\n                        return 1;\\n                    }\\n                    return 0;\\n                }\\n                if(firstReachedLeft && secondReachedLeft) {\\n                    return -1;\\n                }\\n                if(firstReachedRight && secondReachedRight) {\\n                    return 1;\\n                }\\n                if(firstReachedLeft && firstReachedRight) {\\n                    if(firstCost[left] < firstCost[right]) {\\n                        return -1;\\n                    }\\n                    if(firstCost[left] > firstCost[right]) {\\n                        return 1;\\n                    }\\n                    return 0;\\n                }\\n                if(secondReachedLeft && secondReachedRight) {\\n                    if(secondCost[left] < secondCost[right]) {\\n                        return -1;\\n                    }\\n                    if(secondCost[left] > secondCost[right]) {\\n                        return 1;\\n                    }\\n                    return 0;\\n                }\\n                if(firstReachedLeft) {\\n                    if(firstCost[left] < secondCost[right]) {\\n                        return -1;\\n                    }\\n                    if(firstCost[left] > secondCost[right]) {\\n                        return 1;\\n                    }\\n                    return 0;\\n                }\\n                if(secondCost[left] < firstCost[right]) {\\n                    return -1;\\n                }\\n                if(secondCost[left] > firstCost[right]) {\\n                    return 1;\\n                }\\n                return 0;\\n            }\\n        });\\n        Arrays.fill(firstCost, Long.MAX_VALUE);\\n        Arrays.fill(secondCost, Long.MAX_VALUE);\\n        Arrays.fill(cost, Long.MAX_VALUE);\\n        for(int[] edge : edges) {\\n            neighbours = graph.getOrDefault(edge[0], new HashSet<>());\\n            neighbours.add(new int[] {edge[1], edge[2]});\\n            graph.put(edge[0], neighbours);\\n        }\\n        firstCost[src1] = 0;\\n        secondCost[src2] = 0;\\n        queue.add(new int[] {src1, 1, 0});\\n        queue.add(new int[] {src2, 0, 1});\\n        while(!queue.isEmpty()) {\\n            current = queue.poll();\\n            node = current[0];\\n            if(graph.containsKey(node)) {\\n                for(int[] next : graph.get(node)) {\\n                    nextNode = next[0];\\n                    weight = next[1];\\n                    if(current[1] == 1 && current[2] == 1) {\\n                        if(cost[nextNode] > (cost[node] + weight)) {\\n                            cost[nextNode] = (cost[node] + weight);\\n                            queue.add(new int[] {nextNode, 1, 1});\\n                        }\\n                    } else if(current[1] == 1) {\\n                        if(firstCost[nextNode] > (firstCost[node] + weight)) {\\n                            firstCost[nextNode] = (firstCost[node] + weight);\\n                            queue.add(new int[] {nextNode, 1, 0});\\n                        }\\n                        if(secondCost[node] != Long.MAX_VALUE) {\\n                            if(cost[nextNode] > (firstCost[node] + secondCost[node] + weight)) {\\n                                cost[nextNode] = (firstCost[node] + secondCost[node] + weight);\\n                                queue.add(new int[] {nextNode, 1, 1});\\n                            }\\n                        }\\n                    } else {\\n                        if(secondCost[nextNode] > (secondCost[node] + weight)) {\\n                            secondCost[nextNode] = (secondCost[node] + weight);\\n                            queue.add(new int[] {nextNode, 0, 1});\\n                        }\\n                        if(firstCost[node] != Long.MAX_VALUE) {\\n                            if(cost[nextNode] > (firstCost[node] + secondCost[node] + weight)) {\\n                                cost[nextNode] = (firstCost[node] + secondCost[node] + weight);\\n                                queue.add(new int[] {nextNode, 1, 1});\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if(firstCost[dest] == Long.MAX_VALUE || secondCost[dest] == Long.MAX_VALUE) {\\n            return -1;\\n        }\\n        return Math.min((firstCost[dest] + secondCost[dest]), cost[dest]);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845171,
                "title": "c-dijkstra",
                "content": "```\\nclass Solution {\\n    vector<long long> dij(int n, vector<vector<pair<int,int>>>&graph,int source) {\\n        vector<long long>dist(n,LLONG_MAX); \\n        dist[source] = 0; \\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>> , greater<pair<long long, long long>>>pq; \\n        pq.push({source, 0}); \\n        while (!pq.empty()) {\\n            auto [node, di] = pq.top(); pq.pop(); \\n            if (dist[node] < di ) continue; \\n            for (auto [child, cost] : graph[node]) {\\n                if (dist[child] > dist[node] + cost) {\\n                    dist[child] = dist[node] + cost; \\n                    pq.push({child, dist[child]}); \\n                }\\n            }\\n        }\\n        return dist; \\n    }\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int,int>>>graph(n), reverse_graph(n); \\n        for (auto&itr:edges) {\\n            graph[itr[0]].push_back({itr[1], itr[2]}); \\n            reverse_graph[itr[1]].push_back({itr[0],itr[2]}); \\n        }\\n        vector<long long>fromS1 = dij(n,graph, src1); \\n        vector<long long>fromS2 = dij(n,graph, src2); \\n        vector<long long>fromDest = dij(n,reverse_graph, dest); \\n        long long ans {LLONG_MAX}; \\n        for (int i=0; i<n; ++i) {\\n            if (fromS1[i]==LLONG_MAX || fromS2[i] == LLONG_MAX || fromDest[i] == LLONG_MAX) continue; \\n            ans = min(ans , fromS1[i] + fromS2[i] + fromDest[i]); \\n        }\\n        return ans == LLONG_MAX ? -1 : ans; \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    vector<long long> dij(int n, vector<vector<pair<int,int>>>&graph,int source) {\\n        vector<long long>dist(n,LLONG_MAX); \\n        dist[source] = 0; \\n        priority_queue<pair<long long, long long>, vector<pair<long long, long long>> , greater<pair<long long, long long>>>pq; \\n        pq.push({source, 0}); \\n        while (!pq.empty()) {\\n            auto [node, di] = pq.top(); pq.pop(); \\n            if (dist[node] < di ) continue; \\n            for (auto [child, cost] : graph[node]) {\\n                if (dist[child] > dist[node] + cost) {\\n                    dist[child] = dist[node] + cost; \\n                    pq.push({child, dist[child]}); \\n                }\\n            }\\n        }\\n        return dist; \\n    }\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int,int>>>graph(n), reverse_graph(n); \\n        for (auto&itr:edges) {\\n            graph[itr[0]].push_back({itr[1], itr[2]}); \\n            reverse_graph[itr[1]].push_back({itr[0],itr[2]}); \\n        }\\n        vector<long long>fromS1 = dij(n,graph, src1); \\n        vector<long long>fromS2 = dij(n,graph, src2); \\n        vector<long long>fromDest = dij(n,reverse_graph, dest); \\n        long long ans {LLONG_MAX}; \\n        for (int i=0; i<n; ++i) {\\n            if (fromS1[i]==LLONG_MAX || fromS2[i] == LLONG_MAX || fromDest[i] == LLONG_MAX) continue; \\n            ans = min(ans , fromS1[i] + fromS2[i] + fromDest[i]); \\n        }\\n        return ans == LLONG_MAX ? -1 : ans; \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845120,
                "title": "c-hard-problem-made-easy-to-understand-dijkstra-s-solution",
                "content": "Gist of the solution is to find that starting common node `common`, which came in paths from (`src1` to `dest`) and (`src2` to `dest`), and also minimizes the distance between (`src1` to `dest`) and (`src2` to `dest`).\\n\\nTo achive this objective we can apply Dijkstra\\'s Algorithm 3 times for:\\n1. Finding single source shortest path from `src1`, using the given `graph`.\\n2. Finding single source shortest path from `src2`, using the given `graph`.\\n3. Finding single source shortest path from `dest`, using the given reverse of given graph, `revGraph`.\\n\\n**Why using `revGraph`?**\\nSo that we can find the distance of `dest` to all nodes, and then can use those distances to find `common` using `dist = destToAll[common] + src1ToAll[common] + src2ToAll[common]` and then minimizing the distance for all possible `common` (for all nodes `0` to `n`) using:\\n```\\nfor (int common = 0; common < n; common++) {\\n\\tif (destToAll[common] != -1 && src1ToAll[common] != -1 && src2ToAll[common] != -1)\\n\\t\\tdist = min(dist, destToAll[common] + src1ToAll[common] + src2ToAll[common]);\\n}\\n```\\n\\n\\n**Code**\\n\\n```\\n/* \\n\\tTopic: Graph (Dijkstra) \\n\\tDifficulty: H\\n\\tTime: O(n+elog(n)) \\n\\tSpace: O(n)\\n*/\\n\\n\\ntypedef long long ll;\\nclass Solution {\\n    vector<ll> dijkstra(int n, vector<pair<int, int>> *graph, int src) {\\n        vector<ll> distance(n, -1);\\n        set<pair<ll, ll>> q;\\n        distance[src] = 0;\\n        q.insert({0, src});\\n        while (!q.empty()) {\\n            ll dist = q.begin()->first;\\n            int node = q.begin()->second;\\n            q.erase(q.begin());\\n            for (auto nbr : graph[node]) {\\n                if (distance[nbr.first] == -1) {\\n                    distance[nbr.first] = dist + nbr.second;\\n                    q.insert({distance[nbr.first], nbr.first});\\n                } else if (distance[nbr.first] > dist + nbr.second) {\\n                    q.erase({distance[nbr.first], nbr.first});\\n                    distance[nbr.first] = dist + nbr.second;\\n                    q.insert({distance[nbr.first], nbr.first});\\n                }\\n            }\\n        }\\n\\n        return distance;\\n    }\\n\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>> &edges, int src1, int src2, int dest) {\\n        vector<pair<int, int>> graph[n];\\n        vector<pair<int, int>> revGraph[n];\\n        for (auto edge : edges) {\\n            graph[edge[0]].push_back({edge[1], edge[2]});\\n            revGraph[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        auto src1ToAll = dijkstra(n, graph, src1);\\n        auto src2ToAll = dijkstra(n, graph, src2);\\n        auto destToAll = dijkstra(n, revGraph, dest);\\n        if (destToAll[src1] == -1 || destToAll[src2] == -1) return -1;\\n        ll dist = LLONG_MAX;\\n        for (int common = 0; common < n; common++) {\\n            if (destToAll[common] != -1 && src1ToAll[common] != -1 && src2ToAll[common] != -1)\\n                dist = min(dist, destToAll[common] + src1ToAll[common] + src2ToAll[common]);\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nfor (int common = 0; common < n; common++) {\\n\\tif (destToAll[common] != -1 && src1ToAll[common] != -1 && src2ToAll[common] != -1)\\n\\t\\tdist = min(dist, destToAll[common] + src1ToAll[common] + src2ToAll[common]);\\n}\\n```\n```\\n/* \\n\\tTopic: Graph (Dijkstra) \\n\\tDifficulty: H\\n\\tTime: O(n+elog(n)) \\n\\tSpace: O(n)\\n*/\\n\\n\\ntypedef long long ll;\\nclass Solution {\\n    vector<ll> dijkstra(int n, vector<pair<int, int>> *graph, int src) {\\n        vector<ll> distance(n, -1);\\n        set<pair<ll, ll>> q;\\n        distance[src] = 0;\\n        q.insert({0, src});\\n        while (!q.empty()) {\\n            ll dist = q.begin()->first;\\n            int node = q.begin()->second;\\n            q.erase(q.begin());\\n            for (auto nbr : graph[node]) {\\n                if (distance[nbr.first] == -1) {\\n                    distance[nbr.first] = dist + nbr.second;\\n                    q.insert({distance[nbr.first], nbr.first});\\n                } else if (distance[nbr.first] > dist + nbr.second) {\\n                    q.erase({distance[nbr.first], nbr.first});\\n                    distance[nbr.first] = dist + nbr.second;\\n                    q.insert({distance[nbr.first], nbr.first});\\n                }\\n            }\\n        }\\n\\n        return distance;\\n    }\\n\\npublic:\\n    long long minimumWeight(int n, vector<vector<int>> &edges, int src1, int src2, int dest) {\\n        vector<pair<int, int>> graph[n];\\n        vector<pair<int, int>> revGraph[n];\\n        for (auto edge : edges) {\\n            graph[edge[0]].push_back({edge[1], edge[2]});\\n            revGraph[edge[1]].push_back({edge[0], edge[2]});\\n        }\\n        auto src1ToAll = dijkstra(n, graph, src1);\\n        auto src2ToAll = dijkstra(n, graph, src2);\\n        auto destToAll = dijkstra(n, revGraph, dest);\\n        if (destToAll[src1] == -1 || destToAll[src2] == -1) return -1;\\n        ll dist = LLONG_MAX;\\n        for (int common = 0; common < n; common++) {\\n            if (destToAll[common] != -1 && src1ToAll[common] != -1 && src2ToAll[common] != -1)\\n                dist = min(dist, destToAll[common] + src1ToAll[common] + src2ToAll[common]);\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845087,
                "title": "easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        goAble = defaultdict(list)\\n        comeAble = defaultdict(list)\\n        \\n        for edge in edges:\\n            from_, to_, cost_ = edge\\n            goAble[from_].append([to_, cost_])\\n            comeAble[to_].append([from_, cost_])\\n        \\n\\t\\t# Find the nodes where we can reach dest if we start from src 1 / src 2\\n        reachable_from_src1 = self.find_reachable(src1, goAble)\\n        reachable_from_src2 = self.find_reachable(src2, goAble)\\n        \\n\\t\\t# If for either src1 or src2, we are unable to reach the destination, give up!\\n        if dest not in reachable_from_src1 or dest not in reachable_from_src2:\\n            return -1\\n        \\n\\t\\t# Find the lowest code to go to each node if we start from src 1 / src 2\\n        cost_from_src1 = self.find_cost(src1, goAble, len(reachable_from_src1))\\n        cost_from_src2 = self.find_cost(src2, goAble, len(reachable_from_src2))\\n        \\n\\t\\t# Find the nodes that can reach the dest\\n        comeable_from_dest = self.find_reachable(dest, comeAble)\\n\\t\\t# For each of the nodes that can reach the dest, what\\'s the lowest cost for doing so\\n        cost_from_dest = self.find_cost(dest, comeAble, len(comeable_from_dest))\\n\\n        res = float(\\'inf\\')\\n        for i in range(n):\\n            if i not in reachable_from_src1 or i not in reachable_from_src2 or i not in comeable_from_dest:\\n                continue\\n            res = min(res, cost_from_src1[i] + cost_from_src2[i] + cost_from_dest[i])\\n        \\n        return res\\n        \\n    def find_reachable(self, src, goAble):\\n        q = deque([src])\\n        seen = set()\\n        seen.add(src)\\n        \\n        while q:\\n            _ = q.popleft()\\n            \\n            for nextNode, travelCost in goAble[_]:\\n                if nextNode not in seen:\\n                    q.append(nextNode)\\n                    seen.add(nextNode)\\n        \\n        return seen\\n        \\n    \\n    def find_cost(self, src, goAble, numReachable):\\n        q = [[0, src]]\\n        seen = set()\\n        min_cost = dict()\\n        min_cost[src] = 0\\n        while q:\\n            cost, _ = heapq.heappop(q)\\n            seen.add(_)\\n            \\n            if len(seen) == numReachable:\\n                return min_cost\\n            for nextNode, travelCost in goAble[_]:\\n                if nextNode in seen:\\n                    continue\\n                if nextNode not in min_cost:\\n                    min_cost[nextNode] = cost + travelCost\\n                else:\\n                    min_cost[nextNode] = min(min_cost[nextNode], cost + travelCost)\\n                \\n                heapq.heappush(q, [cost + travelCost, nextNode])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        goAble = defaultdict(list)\\n        comeAble = defaultdict(list)\\n        \\n        for edge in edges:\\n            from_, to_, cost_ = edge\\n            goAble[from_].append([to_, cost_])\\n            comeAble[to_].append([from_, cost_])\\n        \\n\\t\\t# Find the nodes where we can reach dest if we start from src 1 / src 2\\n        reachable_from_src1 = self.find_reachable(src1, goAble)\\n        reachable_from_src2 = self.find_reachable(src2, goAble)\\n        \\n\\t\\t# If for either src1 or src2, we are unable to reach the destination, give up!\\n        if dest not in reachable_from_src1 or dest not in reachable_from_src2:\\n            return -1\\n        \\n\\t\\t# Find the lowest code to go to each node if we start from src 1 / src 2\\n        cost_from_src1 = self.find_cost(src1, goAble, len(reachable_from_src1))\\n        cost_from_src2 = self.find_cost(src2, goAble, len(reachable_from_src2))\\n        \\n\\t\\t# Find the nodes that can reach the dest\\n        comeable_from_dest = self.find_reachable(dest, comeAble)\\n\\t\\t# For each of the nodes that can reach the dest, what\\'s the lowest cost for doing so\\n        cost_from_dest = self.find_cost(dest, comeAble, len(comeable_from_dest))\\n\\n        res = float(\\'inf\\')\\n        for i in range(n):\\n            if i not in reachable_from_src1 or i not in reachable_from_src2 or i not in comeable_from_dest:\\n                continue\\n            res = min(res, cost_from_src1[i] + cost_from_src2[i] + cost_from_dest[i])\\n        \\n        return res\\n        \\n    def find_reachable(self, src, goAble):\\n        q = deque([src])\\n        seen = set()\\n        seen.add(src)\\n        \\n        while q:\\n            _ = q.popleft()\\n            \\n            for nextNode, travelCost in goAble[_]:\\n                if nextNode not in seen:\\n                    q.append(nextNode)\\n                    seen.add(nextNode)\\n        \\n        return seen\\n        \\n    \\n    def find_cost(self, src, goAble, numReachable):\\n        q = [[0, src]]\\n        seen = set()\\n        min_cost = dict()\\n        min_cost[src] = 0\\n        while q:\\n            cost, _ = heapq.heappop(q)\\n            seen.add(_)\\n            \\n            if len(seen) == numReachable:\\n                return min_cost\\n            for nextNode, travelCost in goAble[_]:\\n                if nextNode in seen:\\n                    continue\\n                if nextNode not in min_cost:\\n                    min_cost[nextNode] = cost + travelCost\\n                else:\\n                    min_cost[nextNode] = min(min_cost[nextNode], cost + travelCost)\\n                \\n                heapq.heappush(q, [cost + travelCost, nextNode])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1845000,
                "title": "python3-dijkstra-3-times",
                "content": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g = defaultdict(set)\\n        rg = defaultdict(set)\\n        inf = float(\"inf\")\\n        rw = defaultdict(lambda: inf)\\n        w = defaultdict(lambda: inf)\\n        for u,v,wei in edges:\\n            g[u].add(v)\\n            rg[v].add(u)\\n            w[(u,v)] = min(w[(u,v)], wei)\\n            rw[(v,u)] = min(rw[(v,u)], wei)\\n        def dijk(g,n,w,start):\\n            st = [0 for i in range(n+1)]\\n            d = collections.defaultdict(lambda: inf)\\n            d[start] = 0\\n            q = []\\n            heapq.heappush(q,[0,start])\\n\\n            while q:\\n                curd,t = heapq.heappop(q)\\n                d[t] = min(d[t], curd)\\n                if st[t]: continue\\n                for nei in g[t]:\\n                    if d[t] + w[(t,nei)] < d[nei]:\\n                        d[nei] = d[t] + w[(t,nei)]\\n                        heapq.heappush(q,[d[nei],nei])\\n                st[t] = 1\\n            return d\\n        m1 = dijk(g,n,w,src1)\\n        m2 = dijk(g,n,w,src2)\\n        m3 = dijk(rg,n,rw,dest)\\n        res = inf\\n        for i in range(n):\\n            res = min(res, m1[i] + m2[i] + m3[i])\\n        return res if res != inf else -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        g = defaultdict(set)\\n        rg = defaultdict(set)\\n        inf = float(\"inf\")\\n        rw = defaultdict(lambda: inf)\\n        w = defaultdict(lambda: inf)\\n        for u,v,wei in edges:\\n            g[u].add(v)\\n            rg[v].add(u)\\n            w[(u,v)] = min(w[(u,v)], wei)\\n            rw[(v,u)] = min(rw[(v,u)], wei)\\n        def dijk(g,n,w,start):\\n            st = [0 for i in range(n+1)]\\n            d = collections.defaultdict(lambda: inf)\\n            d[start] = 0\\n            q = []\\n            heapq.heappush(q,[0,start])\\n\\n            while q:\\n                curd,t = heapq.heappop(q)\\n                d[t] = min(d[t], curd)\\n                if st[t]: continue\\n                for nei in g[t]:\\n                    if d[t] + w[(t,nei)] < d[nei]:\\n                        d[nei] = d[t] + w[(t,nei)]\\n                        heapq.heappush(q,[d[nei],nei])\\n                st[t] = 1\\n            return d\\n        m1 = dijk(g,n,w,src1)\\n        m2 = dijk(g,n,w,src2)\\n        m3 = dijk(rg,n,rw,dest)\\n        res = inf\\n        for i in range(n):\\n            res = min(res, m1[i] + m2[i] + m3[i])\\n        return res if res != inf else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844939,
                "title": "c-commented-code",
                "content": "```\\n#define pp pair<long long,long long>\\nclass Solution {\\npublic:\\n    void shortestPath(vector<vector<pp>>g,vector<long long>&dist,int start){\\n        priority_queue<pp,vector<pp>,greater<pp>>pq;\\n        pq.push({0,start});\\n        while(!pq.empty()){\\n            auto [wt,u]=pq.top();\\n            pq.pop();\\n            if(dist[u]!=wt)continue;\\n            for(auto [uu,wt2]:g[u]){\\n                // cout<<u<<\" \"<<uu<<\" \";\\n                if(dist[uu]>dist[u]+wt2){\\n                    dist[uu]=dist[u]+wt2;\\n                    pq.push({dist[uu],uu});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n         vector<vector<pp>>g(n),g1(n);\\n        //let n1 be the point where src1 and src2 meets\\n        for(auto edge:edges){\\n            g[edge[0]].push_back({edge[1],edge[2]});\\n            //g1 an opposite graph to get the dest to n1(where src1 and src2 meets)\\n            g1[edge[1]].push_back({edge[0],edge[2]});\\n        }\\n        \\n        vector<long long>dista(n,LONG_MAX),distb(n,LONG_MAX),distn(n,LONG_MAX);\\n        dista[src1]=distb[src2]=distn[dest]=0;\\n        shortestPath(g,dista,src1);\\n        shortestPath(g,distb,src2);\\n        shortestPath(g1,distn,dest);\\n        long long ans=LONG_MAX;\\n        for(int i=0;i<n;i++){\\n            if(dista[i]==LONG_MAX||distb[i]==LONG_MAX||distn[i]==LONG_MAX)continue;\\n            ans=min(ans,dista[i]+distb[i]+distn[i]);\\n        }\\n        return ans==LONG_MAX?-1:ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define pp pair<long long,long long>\\nclass Solution {\\npublic:\\n    void shortestPath(vector<vector<pp>>g,vector<long long>&dist,int start){\\n        priority_queue<pp,vector<pp>,greater<pp>>pq;\\n        pq.push({0,start});\\n        while(!pq.empty()){\\n            auto [wt,u]=pq.top();\\n            pq.pop();\\n            if(dist[u]!=wt)continue;\\n            for(auto [uu,wt2]:g[u]){\\n                // cout<<u<<\" \"<<uu<<\" \";\\n                if(dist[uu]>dist[u]+wt2){\\n                    dist[uu]=dist[u]+wt2;\\n                    pq.push({dist[uu],uu});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n         vector<vector<pp>>g(n),g1(n);\\n        //let n1 be the point where src1 and src2 meets\\n        for(auto edge:edges){\\n            g[edge[0]].push_back({edge[1],edge[2]});\\n            //g1 an opposite graph to get the dest to n1(where src1 and src2 meets)\\n            g1[edge[1]].push_back({edge[0],edge[2]});\\n        }\\n        \\n        vector<long long>dista(n,LONG_MAX),distb(n,LONG_MAX),distn(n,LONG_MAX);\\n        dista[src1]=distb[src2]=distn[dest]=0;\\n        shortestPath(g,dista,src1);\\n        shortestPath(g,distb,src2);\\n        shortestPath(g1,distn,dest);\\n        long long ans=LONG_MAX;\\n        for(int i=0;i<n;i++){\\n            if(dista[i]==LONG_MAX||distb[i]==LONG_MAX||distn[i]==LONG_MAX)continue;\\n            ans=min(ans,dista[i]+distb[i]+distn[i]);\\n        }\\n        return ans==LONG_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1844890,
                "title": "java-python-fast-and-clean-dijkstra-3-times",
                "content": "#### Intuition\\n\\nNothing but 3 times of Dijkstra.\\nThe optimal subgraph is just to find a convergence node (can be any node including src1, src2 and dest), then compute the cost of:\\n\\n```\\nsrc1\\n    \\\\\\n     node --- dest\\n    /\\nsrc2\\n```\\n\\nNote: The reason I hate Java and C/C++ is that you have to deal with the f annoying data type (int/long)\\n\\n#### Java\\n\\n```java\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        List<int[]>[] graph = new List[n];\\n        List<int[]>[] graphReverse = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int i = 0; i < n; i++) graphReverse[i] = new ArrayList<>();\\n        for (int[] edge : edges) {\\n            // data decomposite: from; to; cost\\n            int f = edge[0], t = edge[1], c = edge[2];\\n            graph[f].add(new int[] {t, c});\\n            graphReverse[t].add(new int[] {f, c});\\n        }\\n        // node -> [dist, ind]\\n        Queue<long[]> queue = new PriorityQueue<>((a, b) -> Long.compare(a[0], b[0]));\\n        // table 1\\n        long[] distToDestTable = new long[n];\\n        Arrays.fill(distToDestTable, Long.MAX_VALUE);\\n        distToDestTable[dest] = 0;\\n        queue.offer(new long[] {0, dest});\\n        while (!queue.isEmpty()) {\\n            long[] node = queue.poll();\\n            long d = node[0];\\n            int ind = (int)node[1];\\n            if (d > distToDestTable[ind]) continue;\\n            for (int[] edge : graphReverse[ind]) {\\n                int n_ind = edge[0], c = edge[1];\\n                long n_d = d + c;\\n                if (n_d < distToDestTable[n_ind]) {\\n                    distToDestTable[n_ind] = n_d;\\n                    queue.offer(new long[] {n_d, n_ind});\\n                }\\n            }\\n        }\\n        // table 2\\n        long[] distFromSrc1Table = new long[n];\\n        Arrays.fill(distFromSrc1Table, Long.MAX_VALUE);\\n        distFromSrc1Table[src1] = 0;\\n        queue.offer(new long[] {0, src1});\\n        while (!queue.isEmpty()) {\\n            long[] node = queue.poll();\\n            long d = node[0];\\n            int ind = (int)node[1];\\n            if (d > distFromSrc1Table[ind]) continue;\\n            for (int[] edge : graph[ind]) {\\n                int n_ind = edge[0], c = edge[1];\\n                long n_d = d + c;\\n                if (n_d < distFromSrc1Table[n_ind]) {\\n                    distFromSrc1Table[n_ind] = n_d;\\n                    queue.offer(new long[] {n_d, n_ind});\\n                }\\n            }\\n        }\\n        // table 3\\n        long[] distFromSrc2Table = new long[n];\\n        Arrays.fill(distFromSrc2Table, Long.MAX_VALUE);\\n        distFromSrc2Table[src2] = 0;\\n        queue.offer(new long[] {0, src2});\\n        while (!queue.isEmpty()) {\\n            long[] node = queue.poll();\\n            long d = node[0];\\n            int ind = (int)node[1];\\n            if (d > distFromSrc2Table[ind]) continue;\\n            for (int[] edge : graph[ind]) {\\n                int n_ind = edge[0], c = edge[1];\\n                long n_d = d + c;\\n                if (n_d < distFromSrc2Table[n_ind]) {\\n                    distFromSrc2Table[n_ind] = n_d;\\n                    queue.offer(new long[] {n_d, n_ind});\\n                }\\n            }\\n        }\\n        // compute\\n        long res = Long.MAX_VALUE;\\n        for (int node = 0; node < n; node++) {\\n            if (distToDestTable[node] < Long.MAX_VALUE && distFromSrc1Table[node] < Long.MAX_VALUE && distFromSrc2Table[node] < Long.MAX_VALUE) {\\n                res = Math.min(res, (long)distToDestTable[node] + distFromSrc1Table[node] + distFromSrc2Table[node]);\\n            }\\n        }\\n        return res == Long.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```\\n\\n#### Python\\n\\n```python\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        graphReverse = [[] for _ in range(n)]\\n        for f, t, c in edges:\\n            graph[f].append([t, c])\\n            graphReverse[t].append([f, c])\\n        # table1\\n        distToDestTable = [float(\\'inf\\')] * n\\n        distToDestTable[dest] = 0\\n        queue = [(0, dest)]\\n        while queue:\\n            d, ni = heapq.heappop(queue)\\n            if d > distToDestTable[ni]: continue\\n            for node, c in graphReverse[ni]:\\n                nd = d + c\\n                if nd < distToDestTable[node]:\\n                    heapq.heappush(queue, (nd, node))\\n                    distToDestTable[node] = nd\\n        # table2\\n        distFromSrc1Table = [float(\\'inf\\')] * n\\n        distFromSrc1Table[src1] = 0\\n        queue = [(0, src1)]\\n        while queue:\\n            d, ni = heapq.heappop(queue)\\n            if d > distFromSrc1Table[ni]: continue\\n            for node, c in graph[ni]:\\n                nd = d + c\\n                if nd < distFromSrc1Table[node]:\\n                    heapq.heappush(queue, (nd, node))\\n                    distFromSrc1Table[node] = nd\\n        # table3\\n        distFromSrc2Table = [float(\\'inf\\')] * n\\n        distFromSrc2Table[src2] = 0\\n        queue = [(0, src2)]\\n        while queue:\\n            d, ni = heapq.heappop(queue)\\n            if d > distFromSrc2Table[ni]: continue\\n            for node, c in graph[ni]:\\n                nd = d + c\\n                if nd < distFromSrc2Table[node]:\\n                    heapq.heappush(queue, (nd, node))\\n                    distFromSrc2Table[node] = nd\\n        res = float(\\'inf\\')\\n        for node in range(n):\\n            res = min(res, distFromSrc1Table[node] + distFromSrc2Table[node] + distToDestTable[node])\\n        return res if res < float(\\'inf\\') else -1\\n```",
                "solutionTags": [],
                "code": "```\\nsrc1\\n    \\\\\\n     node --- dest\\n    /\\nsrc2\\n```\n```java\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        List<int[]>[] graph = new List[n];\\n        List<int[]>[] graphReverse = new List[n];\\n        for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\\n        for (int i = 0; i < n; i++) graphReverse[i] = new ArrayList<>();\\n        for (int[] edge : edges) {\\n            // data decomposite: from; to; cost\\n            int f = edge[0], t = edge[1], c = edge[2];\\n            graph[f].add(new int[] {t, c});\\n            graphReverse[t].add(new int[] {f, c});\\n        }\\n        // node -> [dist, ind]\\n        Queue<long[]> queue = new PriorityQueue<>((a, b) -> Long.compare(a[0], b[0]));\\n        // table 1\\n        long[] distToDestTable = new long[n];\\n        Arrays.fill(distToDestTable, Long.MAX_VALUE);\\n        distToDestTable[dest] = 0;\\n        queue.offer(new long[] {0, dest});\\n        while (!queue.isEmpty()) {\\n            long[] node = queue.poll();\\n            long d = node[0];\\n            int ind = (int)node[1];\\n            if (d > distToDestTable[ind]) continue;\\n            for (int[] edge : graphReverse[ind]) {\\n                int n_ind = edge[0], c = edge[1];\\n                long n_d = d + c;\\n                if (n_d < distToDestTable[n_ind]) {\\n                    distToDestTable[n_ind] = n_d;\\n                    queue.offer(new long[] {n_d, n_ind});\\n                }\\n            }\\n        }\\n        // table 2\\n        long[] distFromSrc1Table = new long[n];\\n        Arrays.fill(distFromSrc1Table, Long.MAX_VALUE);\\n        distFromSrc1Table[src1] = 0;\\n        queue.offer(new long[] {0, src1});\\n        while (!queue.isEmpty()) {\\n            long[] node = queue.poll();\\n            long d = node[0];\\n            int ind = (int)node[1];\\n            if (d > distFromSrc1Table[ind]) continue;\\n            for (int[] edge : graph[ind]) {\\n                int n_ind = edge[0], c = edge[1];\\n                long n_d = d + c;\\n                if (n_d < distFromSrc1Table[n_ind]) {\\n                    distFromSrc1Table[n_ind] = n_d;\\n                    queue.offer(new long[] {n_d, n_ind});\\n                }\\n            }\\n        }\\n        // table 3\\n        long[] distFromSrc2Table = new long[n];\\n        Arrays.fill(distFromSrc2Table, Long.MAX_VALUE);\\n        distFromSrc2Table[src2] = 0;\\n        queue.offer(new long[] {0, src2});\\n        while (!queue.isEmpty()) {\\n            long[] node = queue.poll();\\n            long d = node[0];\\n            int ind = (int)node[1];\\n            if (d > distFromSrc2Table[ind]) continue;\\n            for (int[] edge : graph[ind]) {\\n                int n_ind = edge[0], c = edge[1];\\n                long n_d = d + c;\\n                if (n_d < distFromSrc2Table[n_ind]) {\\n                    distFromSrc2Table[n_ind] = n_d;\\n                    queue.offer(new long[] {n_d, n_ind});\\n                }\\n            }\\n        }\\n        // compute\\n        long res = Long.MAX_VALUE;\\n        for (int node = 0; node < n; node++) {\\n            if (distToDestTable[node] < Long.MAX_VALUE && distFromSrc1Table[node] < Long.MAX_VALUE && distFromSrc2Table[node] < Long.MAX_VALUE) {\\n                res = Math.min(res, (long)distToDestTable[node] + distFromSrc1Table[node] + distFromSrc2Table[node]);\\n            }\\n        }\\n        return res == Long.MAX_VALUE ? -1 : res;\\n    }\\n}\\n```\n```python\\nclass Solution:\\n    def minimumWeight(self, n: int, edges: List[List[int]], src1: int, src2: int, dest: int) -> int:\\n        graph = [[] for _ in range(n)]\\n        graphReverse = [[] for _ in range(n)]\\n        for f, t, c in edges:\\n            graph[f].append([t, c])\\n            graphReverse[t].append([f, c])\\n        # table1\\n        distToDestTable = [float(\\'inf\\')] * n\\n        distToDestTable[dest] = 0\\n        queue = [(0, dest)]\\n        while queue:\\n            d, ni = heapq.heappop(queue)\\n            if d > distToDestTable[ni]: continue\\n            for node, c in graphReverse[ni]:\\n                nd = d + c\\n                if nd < distToDestTable[node]:\\n                    heapq.heappush(queue, (nd, node))\\n                    distToDestTable[node] = nd\\n        # table2\\n        distFromSrc1Table = [float(\\'inf\\')] * n\\n        distFromSrc1Table[src1] = 0\\n        queue = [(0, src1)]\\n        while queue:\\n            d, ni = heapq.heappop(queue)\\n            if d > distFromSrc1Table[ni]: continue\\n            for node, c in graph[ni]:\\n                nd = d + c\\n                if nd < distFromSrc1Table[node]:\\n                    heapq.heappush(queue, (nd, node))\\n                    distFromSrc1Table[node] = nd\\n        # table3\\n        distFromSrc2Table = [float(\\'inf\\')] * n\\n        distFromSrc2Table[src2] = 0\\n        queue = [(0, src2)]\\n        while queue:\\n            d, ni = heapq.heappop(queue)\\n            if d > distFromSrc2Table[ni]: continue\\n            for node, c in graph[ni]:\\n                nd = d + c\\n                if nd < distFromSrc2Table[node]:\\n                    heapq.heappush(queue, (nd, node))\\n                    distFromSrc2Table[node] = nd\\n        res = float(\\'inf\\')\\n        for node in range(n):\\n            res = min(res, distFromSrc1Table[node] + distFromSrc2Table[node] + distToDestTable[node])\\n        return res if res < float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844887,
                "title": "c-dijkstra",
                "content": "**Idea**\\nFind a point `pt` where 0<=pt<=n-1, such that  `distance[ src1 --> pt ] + distance[ src2 --> pt ] + distance[ pt --> distination ]` is min. To find min_distance[ src1 --> pt ] and min_distance[ src2 --> pt ] is pretty simple, we can directly apply **dijkstra algo** for `src1` and `src2` separately. Now main challenge is to find out the distance from `pt` to `destination`, because pt is not fixed. \\nHow about we find distance from `destination` to all other nodes?  This will solve our problem to find distance from `pt` to `destination`. To do this, we just need to reverse the graph without changing the weights. And then apply **dijkstra algo**.\\nBuild 3 DPs :\\n1. dp = source node is destination (reverse graph)\\n1. dp1 = source node is src1\\n1. dp2 = source node is src2\\n\\nand apply dijkstra.\\n\\nTo find min weighted subgraph, iterate for all i, and find min of `dp[i]+dp1[i]+dp2[i]`.\\n```\\nclass node{\\npublic:\\n    int c,v;\\n    node(){c=0,v=0;}\\n    node(int x,int y) {v=x,c=y;}\\n};\\nclass Solution {\\npublic:\\n    long long inf = LLONG_MAX;\\n    long long ans = inf;\\n    void dijkstra(int n, vector<vector<node>> &nums,vector<long long> &dp,int root){\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>> q;\\n        q.push({0,root}); dp[root] = 0;\\n        while(!q.empty()){\\n            auto p = q.top(); q.pop();\\n            long long d = p.first;\\n            int in = p.second;\\n            if(dp[in]<d) continue;\\n            for(int i=0; i<nums[in].size();++i){\\n                int j = nums[in][i].v, c = nums[in][i].c;\\n                if(dp[j]>d+c){\\n                    dp[j] = (long long)d+c;\\n                    q.push({dp[j],j});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& arr, int src1, int src2, int d) {\\n        vector<vector<node>> nums(n),nums2(n);\\n        for(int i = 0; i<arr.size();++i){\\n            nums[arr[i][0]].push_back(node(arr[i][1],arr[i][2]));\\n        }\\n         for(int i = 0; i<arr.size();++i){\\n            nums2[arr[i][1]].push_back(node(arr[i][0],arr[i][2]));\\n        }\\n        vector<long long> dp(n,inf);\\n        vector<long long> dp1(n,inf);\\n        vector<long long> dp2(n,inf);\\n        dijkstra (n,nums2,dp,d);\\n        dijkstra (n,nums,dp1,src1);\\n        dijkstra (n,nums,dp2,src2);\\n        long long re = inf;\\n        for(int i = 0; i<n;++i){\\n            long long k1 = dp[i];\\n            long long k2 = dp1[i];\\n            long long k3 = dp2[i];\\n            if(k1==inf ||k2==inf|| k3==inf) continue;\\n            else re=min(re,k1+k2+k3);\\n        }\\n        if(re==inf) re = -1;\\n        return re;\\n    }\\n};\\n```\\n**upvote if it helps**",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass node{\\npublic:\\n    int c,v;\\n    node(){c=0,v=0;}\\n    node(int x,int y) {v=x,c=y;}\\n};\\nclass Solution {\\npublic:\\n    long long inf = LLONG_MAX;\\n    long long ans = inf;\\n    void dijkstra(int n, vector<vector<node>> &nums,vector<long long> &dp,int root){\\n        priority_queue<pair<long long,int>,vector<pair<long long,int>>,greater<pair<long long,int>>> q;\\n        q.push({0,root}); dp[root] = 0;\\n        while(!q.empty()){\\n            auto p = q.top(); q.pop();\\n            long long d = p.first;\\n            int in = p.second;\\n            if(dp[in]<d) continue;\\n            for(int i=0; i<nums[in].size();++i){\\n                int j = nums[in][i].v, c = nums[in][i].c;\\n                if(dp[j]>d+c){\\n                    dp[j] = (long long)d+c;\\n                    q.push({dp[j],j});\\n                }\\n            }\\n        }\\n    }\\n    long long minimumWeight(int n, vector<vector<int>>& arr, int src1, int src2, int d) {\\n        vector<vector<node>> nums(n),nums2(n);\\n        for(int i = 0; i<arr.size();++i){\\n            nums[arr[i][0]].push_back(node(arr[i][1],arr[i][2]));\\n        }\\n         for(int i = 0; i<arr.size();++i){\\n            nums2[arr[i][1]].push_back(node(arr[i][0],arr[i][2]));\\n        }\\n        vector<long long> dp(n,inf);\\n        vector<long long> dp1(n,inf);\\n        vector<long long> dp2(n,inf);\\n        dijkstra (n,nums2,dp,d);\\n        dijkstra (n,nums,dp1,src1);\\n        dijkstra (n,nums,dp2,src2);\\n        long long re = inf;\\n        for(int i = 0; i<n;++i){\\n            long long k1 = dp[i];\\n            long long k2 = dp1[i];\\n            long long k3 = dp2[i];\\n            if(k1==inf ||k2==inf|| k3==inf) continue;\\n            else re=min(re,k1+k2+k3);\\n        }\\n        if(re==inf) re = -1;\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844774,
                "title": "apply-dijkstra-s-algo-3-times",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    const ll mx = 1e18;\\n    \\n    vector<ll> dijkstra(ll src, ll n , vector<pair<ll,ll>>adj[]){\\n        vector<ll>dis(n,mx);\\n        dis[src]=0;\\n        priority_queue<pair<ll,ll>, vector<pair<ll,ll>> , greater<pair<ll,ll>> >q;\\n        q.push({0,src});\\n        while(q.size()>0){\\n            ll a= q.top().first; // distance\\n            ll b =q.top().second; // node\\n            q.pop();\\n            \\n            if (a != dis[b]) continue; // must , otherwise give TLE\\n            \\n            vector<pair<ll,ll>>:: iterator j;\\n            \\n            for(auto j:adj[b]){\\n                if(dis[j.first]> dis[b]+ j.second){\\n                    dis[j.first]= dis[b]+j.second;\\n                    q.push({dis[j.first] ,j.first});\\n                }\\n            }\\n        }\\n        \\n        return dis;\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<pair<ll,ll>>adj[n];\\n        vector<pair<ll,ll>>reversed[n];\\n        \\n        for(int i=0;i<edges.size();i++){\\n            int u =edges[i][0] , v=edges[i][1] , w=edges[i][2];\\n            adj[u].push_back({v,w});\\n            reversed[v].push_back({u,w});\\n        }\\n        \\n        vector<ll>src1v = dijkstra(src1,n,adj); \\n        vector<ll>src2v = dijkstra(src2,n,adj);\\n        \\n        // here need distance from each vertex to dest , so we used reversed vector;\\n        vector<ll>destv = dijkstra(dest,n,reversed);;\\n        \\n        ll c = mx;\\n        for(int i=0;i<n;i++){\\n                //ll temp =dijkstra(src1,i ,n , adj) + dijkstra(src2,i ,n , adj) \\n                //         + dijkstra(i,dest ,n , adj);\\n                ll temp = src1v[i]+src2v[i]+destv[i];\\n                c=min(c,temp);\\n        }\\n         \\n        if(c>=mx)\\n            c=-1;\\n        \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    const ll mx = 1e18;\\n    \\n    vector<ll> dijkstra(ll src, ll n , vector<pair<ll,ll>>adj[]){\\n        vector<ll>dis(n,mx);\\n        dis[src]=0;\\n        priority_queue<pair<ll,ll>, vector<pair<ll,ll>> , greater<pair<ll,ll>> >q;\\n        q.push({0,src});\\n        while(q.size()>0){\\n            ll a= q.top().first; // distance\\n            ll b =q.top().second; // node\\n            q.pop();\\n            \\n            if (a != dis[b]) continue; // must , otherwise give TLE\\n            \\n            vector<pair<ll,ll>>:: iterator j;\\n            \\n            for(auto j:adj[b]){\\n                if(dis[j.first]> dis[b]+ j.second){\\n                    dis[j.first]= dis[b]+j.second;\\n                    q.push({dis[j.first] ,j.first});\\n                }\\n            }\\n        }\\n        \\n        return dis;\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<pair<ll,ll>>adj[n];\\n        vector<pair<ll,ll>>reversed[n];\\n        \\n        for(int i=0;i<edges.size();i++){\\n            int u =edges[i][0] , v=edges[i][1] , w=edges[i][2];\\n            adj[u].push_back({v,w});\\n            reversed[v].push_back({u,w});\\n        }\\n        \\n        vector<ll>src1v = dijkstra(src1,n,adj); \\n        vector<ll>src2v = dijkstra(src2,n,adj);\\n        \\n        // here need distance from each vertex to dest , so we used reversed vector;\\n        vector<ll>destv = dijkstra(dest,n,reversed);;\\n        \\n        ll c = mx;\\n        for(int i=0;i<n;i++){\\n                //ll temp =dijkstra(src1,i ,n , adj) + dijkstra(src2,i ,n , adj) \\n                //         + dijkstra(i,dest ,n , adj);\\n                ll temp = src1v[i]+src2v[i]+destv[i];\\n                c=min(c,temp);\\n        }\\n         \\n        if(c>=mx)\\n            c=-1;\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844629,
                "title": "dijkstra-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/c194f6b5-5fec-4126-b7f5-7e55c4a6ed10_1647148118.429926.png)\\n```\\nclass Solution {\\n    ArrayList<int[]>[] forwardGraph, backGraph;\\n    \\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        forwardGraph = new ArrayList[n];\\n        backGraph= new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            forwardGraph[i] = new ArrayList<int[]>();\\n            backGraph[i] = new ArrayList<int[]>();\\n        }\\n        for (int[] e:  edges){\\n            int from = e[0];\\n            int to = e[1];\\n            int w = e[2];\\n            forwardGraph[from].add(new int[]{to, w});\\n            backGraph[to].add(new int[]{from, w});\\n        }\\n       \\n        long[] path1 = new long[n]; //from src1 to all nodes\\n        long[] path2 = new long[n]; //from src2 to all nodes\\n        long[] path3 = new long[n]; //from dest to all nodes\\n        runShortest(path1, src1, forwardGraph);\\n        runShortest(path2, src2, forwardGraph);\\n        runShortest(path3, dest, backGraph);\\n        \\n        long result = -1;\\n        for (int i = 0; i < n; i++) {\\n            long c1 = path1[i];\\n            long c2 = path2[i];\\n            long c3 = path3[i];\\n            if (c1 != -1 && c2 != -1 && c3 != -1) {\\n                long c = c1 + c2 + c3;\\n                if (result == -1 ||  c < result) {\\n                    result = c;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public void runShortest(long[] distance, int source, ArrayList<int[]>[] AdjList) {\\n        PriorityQueue<long[]> q = new PriorityQueue<long[]>(Comparator.comparingLong(a->a[1]));\\n        for (int[] next : AdjList[source]) {\\n            q.offer(new long[]{next[0], next[1]});\\n        }\\n        Arrays.fill(distance, -1);\\n        distance[source] = 0;\\n        while (!q.isEmpty()) {\\n            long[] curr = q.poll();\\n            int currNode = (int) curr[0];\\n            long currDistance = curr[1];\\n            if (distance[currNode] != -1 && distance[currNode] <= currDistance) continue;\\n            distance[currNode]  = currDistance;\\n            for (int[] next: AdjList[currNode]) {\\n                int nextNode = next[0];\\n                int weight = next[1];\\n                q.add(new long[]{(long)nextNode, currDistance + weight});\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    ArrayList<int[]>[] forwardGraph, backGraph;\\n    \\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        forwardGraph = new ArrayList[n];\\n        backGraph= new ArrayList[n];\\n        for (int i = 0; i < n; i++) {\\n            forwardGraph[i] = new ArrayList<int[]>();\\n            backGraph[i] = new ArrayList<int[]>();\\n        }\\n        for (int[] e:  edges){\\n            int from = e[0];\\n            int to = e[1];\\n            int w = e[2];\\n            forwardGraph[from].add(new int[]{to, w});\\n            backGraph[to].add(new int[]{from, w});\\n        }\\n       \\n        long[] path1 = new long[n]; //from src1 to all nodes\\n        long[] path2 = new long[n]; //from src2 to all nodes\\n        long[] path3 = new long[n]; //from dest to all nodes\\n        runShortest(path1, src1, forwardGraph);\\n        runShortest(path2, src2, forwardGraph);\\n        runShortest(path3, dest, backGraph);\\n        \\n        long result = -1;\\n        for (int i = 0; i < n; i++) {\\n            long c1 = path1[i];\\n            long c2 = path2[i];\\n            long c3 = path3[i];\\n            if (c1 != -1 && c2 != -1 && c3 != -1) {\\n                long c = c1 + c2 + c3;\\n                if (result == -1 ||  c < result) {\\n                    result = c;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public void runShortest(long[] distance, int source, ArrayList<int[]>[] AdjList) {\\n        PriorityQueue<long[]> q = new PriorityQueue<long[]>(Comparator.comparingLong(a->a[1]));\\n        for (int[] next : AdjList[source]) {\\n            q.offer(new long[]{next[0], next[1]});\\n        }\\n        Arrays.fill(distance, -1);\\n        distance[source] = 0;\\n        while (!q.isEmpty()) {\\n            long[] curr = q.poll();\\n            int currNode = (int) curr[0];\\n            long currDistance = curr[1];\\n            if (distance[currNode] != -1 && distance[currNode] <= currDistance) continue;\\n            distance[currNode]  = currDistance;\\n            for (int[] next: AdjList[currNode]) {\\n                int nextNode = next[0];\\n                int weight = next[1];\\n                q.add(new long[]{(long)nextNode, currDistance + weight});\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844618,
                "title": "java-dijkstra-3",
                "content": "```\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        \\n        Map<Integer, Set<Path>> map = new HashMap<>();\\n        Map<Integer, Set<Path>> reverseMap = new HashMap<>();\\n        \\n        for (int[] edge: edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int weight = edge[2];\\n            \\n            if (!map.containsKey(from)) {\\n                map.put(from, new HashSet<>());\\n            }\\n            \\n            if (!reverseMap.containsKey(to)) {\\n                reverseMap.put(to, new HashSet<>());\\n            }\\n            \\n            map.get(from).add(new Path(from, to, weight));\\n            reverseMap.get(to).add(new Path(to, from, weight));\\n        }\\n        \\n        Map<Integer, Long> srcDistanceMap1 = new HashMap<>();\\n        Map<Integer, Long> srcDistanceMap2 = new HashMap<>();\\n        Map<Integer, Long> dstDistanceMap = new HashMap<>();\\n        \\n        search(map, src1, srcDistanceMap1);\\n        search(map, src2, srcDistanceMap2);\\n        search(reverseMap, dest, dstDistanceMap);\\n        \\n        if (!srcDistanceMap1.containsKey(dest) || !srcDistanceMap2.containsKey(dest)) {\\n            return -1;\\n        }\\n        \\n        long res = Long.MAX_VALUE;\\n        \\n        for (int node: dstDistanceMap.keySet()) {\\n            if (!srcDistanceMap1.containsKey(node) || !srcDistanceMap2.containsKey(node)) {\\n                continue;\\n            }\\n            \\n            res = Math.min(res, dstDistanceMap.get(node) + srcDistanceMap1.get(node) + srcDistanceMap2.get(node));\\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void search(Map<Integer, Set<Path>> map, int src, Map<Integer, Long> distanceMap) {\\n        distanceMap.put(src, 0L);\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(src);\\n        \\n        PriorityQueue<Path> pq = new PriorityQueue<>((p1, p2) -> {\\n            return (int)((distanceMap.get(p1.from) + p1.weight) - (distanceMap.get(p2.from) + p2.weight));\\n        });\\n        \\n        for (Path path: map.getOrDefault(src, new HashSet<>())) {\\n            pq.add(path);\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            Path cur = pq.poll();\\n            \\n            if (visited.contains(cur.to)) {\\n                continue;\\n            }\\n            visited.add(cur.to);\\n            \\n            distanceMap.put(cur.to, distanceMap.get(cur.from) + cur.weight);\\n            \\n            for (Path path: map.getOrDefault(cur.to, new HashSet<>())) {\\n                pq.add(path);\\n            }\\n        }\\n        \\n    }\\n    \\n    class Path {\\n        int from;\\n        int to;\\n        long weight;\\n        \\n        public Path(int from, int to, long weight) {\\n            this.from = from;\\n            this.to = to;\\n            this.weight = weight;\\n        }\\n        \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long minimumWeight(int n, int[][] edges, int src1, int src2, int dest) {\\n        \\n        Map<Integer, Set<Path>> map = new HashMap<>();\\n        Map<Integer, Set<Path>> reverseMap = new HashMap<>();\\n        \\n        for (int[] edge: edges) {\\n            int from = edge[0];\\n            int to = edge[1];\\n            int weight = edge[2];\\n            \\n            if (!map.containsKey(from)) {\\n                map.put(from, new HashSet<>());\\n            }\\n            \\n            if (!reverseMap.containsKey(to)) {\\n                reverseMap.put(to, new HashSet<>());\\n            }\\n            \\n            map.get(from).add(new Path(from, to, weight));\\n            reverseMap.get(to).add(new Path(to, from, weight));\\n        }\\n        \\n        Map<Integer, Long> srcDistanceMap1 = new HashMap<>();\\n        Map<Integer, Long> srcDistanceMap2 = new HashMap<>();\\n        Map<Integer, Long> dstDistanceMap = new HashMap<>();\\n        \\n        search(map, src1, srcDistanceMap1);\\n        search(map, src2, srcDistanceMap2);\\n        search(reverseMap, dest, dstDistanceMap);\\n        \\n        if (!srcDistanceMap1.containsKey(dest) || !srcDistanceMap2.containsKey(dest)) {\\n            return -1;\\n        }\\n        \\n        long res = Long.MAX_VALUE;\\n        \\n        for (int node: dstDistanceMap.keySet()) {\\n            if (!srcDistanceMap1.containsKey(node) || !srcDistanceMap2.containsKey(node)) {\\n                continue;\\n            }\\n            \\n            res = Math.min(res, dstDistanceMap.get(node) + srcDistanceMap1.get(node) + srcDistanceMap2.get(node));\\n            \\n        }\\n        \\n        return res;\\n    }\\n    \\n    private void search(Map<Integer, Set<Path>> map, int src, Map<Integer, Long> distanceMap) {\\n        distanceMap.put(src, 0L);\\n        \\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(src);\\n        \\n        PriorityQueue<Path> pq = new PriorityQueue<>((p1, p2) -> {\\n            return (int)((distanceMap.get(p1.from) + p1.weight) - (distanceMap.get(p2.from) + p2.weight));\\n        });\\n        \\n        for (Path path: map.getOrDefault(src, new HashSet<>())) {\\n            pq.add(path);\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            Path cur = pq.poll();\\n            \\n            if (visited.contains(cur.to)) {\\n                continue;\\n            }\\n            visited.add(cur.to);\\n            \\n            distanceMap.put(cur.to, distanceMap.get(cur.from) + cur.weight);\\n            \\n            for (Path path: map.getOrDefault(cur.to, new HashSet<>())) {\\n                pq.add(path);\\n            }\\n        }\\n        \\n    }\\n    \\n    class Path {\\n        int from;\\n        int to;\\n        long weight;\\n        \\n        public Path(int from, int to, long weight) {\\n            this.from = from;\\n            this.to = to;\\n            this.weight = weight;\\n        }\\n        \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1844606,
                "title": "c-3-x-dijkstra-with-forward-backward-connection",
                "content": "This problem requires a simple twist of shortest path approach.\\nThe critical point is to resolve shared edges between ```src1 -> dest``` and ```src2 -> dest```.\\nThe shared edges could be resolved from backward Dijkstra from ```dest -> other vertices```.\\nFirst, get min distance arrays from three Dijkstra algorithm:\\n\\t1. (backward) ```dest -> other vertices```\\n\\t2. (forward) ```src1 -> other vertices```\\n\\t3. (forward) ```src2 -> other vertices```\\nThen, traverse all vertices ```vi``` to get minimum distance of ```(src1 -> vi) + (src2 -> vi) + (vi -> dest)```.\\nThis guarantees to find the best ```vi``` from which ```src1``` and ```src2``` share edges of ```vi -> dest```.\\nNote that ```vi``` could be one of ```src1```, ```src2``` or ```dest```.\\n\\n```\\nclass Solution {\\npublic:\\n    void dijkstra(vector<vector<pair<int, int>>>& adj, int n, int src, vector<long>& dist){\\n        priority_queue<pair<long, int>, vector<pair<long, int>>, greater<pair<long, int>>> pq;\\n        pq.push({0, src});\\n        dist[src] = 0;\\n        \\n        while(!pq.empty()){\\n            long cost = pq.top().first;\\n            int vi = pq.top().second;\\n            pq.pop();\\n            if(cost > dist[vi])\\n                continue;\\n            for(int i=0; i<adj[vi].size(); i++){\\n                int ni = adj[vi][i].first;\\n                int ncost = adj[vi][i].second;\\n                if(dist[ni] > cost+ncost){\\n                    dist[ni] = cost+ncost;\\n                    pq.push({dist[ni], ni});\\n                }\\n            }\\n        }\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int,int>>> adj(n, vector<pair<int,int>>()), badj(n, vector<pair<int,int>>());\\n        for(auto& e: edges){\\n            adj[e[0]].push_back({e[1], e[2]}); // forward connection\\n            badj[e[1]].push_back({e[0], e[2]}); // backward connection\\n        }\\n        \\n        // dest -> vertices\\n        vector<long> dist(n, LONG_MAX);\\n        dijkstra(badj, n, dest, dist);\\n        \\n        // src1 -> vertices\\n        vector<long> dist1(n, LONG_MAX);\\n        dijkstra(adj, n, src1, dist1);\\n        \\n        // src2 -> vertices\\n        vector<long> dist2(n, LONG_MAX);\\n        dijkstra(adj, n, src2, dist2);\\n        \\n        long ret = LONG_MAX;\\n        for(int i=0; i<n; i++){\\n            if(dist1[i] != LONG_MAX && dist2[i] != LONG_MAX && dist[i] != LONG_MAX){\\n                ret = min(ret, dist1[i] + dist2[i] + dist[i]);\\n            }\\n        }\\n            \\n        return (ret == LONG_MAX)? -1:ret;\\n    }\\n};\\n```\\n\\nTime Complexity : ```O(|E+V| * log|V|)```\\nSpace Complexity : ```O(|E+V|)```",
                "solutionTags": [
                    "C"
                ],
                "code": "```src1 -> dest```\n```src2 -> dest```\n```dest -> other vertices```\n```dest -> other vertices```\n```src1 -> other vertices```\n```src2 -> other vertices```\n```vi```\n```(src1 -> vi) + (src2 -> vi) + (vi -> dest)```\n```vi```\n```src1```\n```src2```\n```vi -> dest```\n```vi```\n```src1```\n```src2```\n```dest```\n```\\nclass Solution {\\npublic:\\n    void dijkstra(vector<vector<pair<int, int>>>& adj, int n, int src, vector<long>& dist){\\n        priority_queue<pair<long, int>, vector<pair<long, int>>, greater<pair<long, int>>> pq;\\n        pq.push({0, src});\\n        dist[src] = 0;\\n        \\n        while(!pq.empty()){\\n            long cost = pq.top().first;\\n            int vi = pq.top().second;\\n            pq.pop();\\n            if(cost > dist[vi])\\n                continue;\\n            for(int i=0; i<adj[vi].size(); i++){\\n                int ni = adj[vi][i].first;\\n                int ncost = adj[vi][i].second;\\n                if(dist[ni] > cost+ncost){\\n                    dist[ni] = cost+ncost;\\n                    pq.push({dist[ni], ni});\\n                }\\n            }\\n        }\\n    }\\n    \\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {\\n        vector<vector<pair<int,int>>> adj(n, vector<pair<int,int>>()), badj(n, vector<pair<int,int>>());\\n        for(auto& e: edges){\\n            adj[e[0]].push_back({e[1], e[2]}); // forward connection\\n            badj[e[1]].push_back({e[0], e[2]}); // backward connection\\n        }\\n        \\n        // dest -> vertices\\n        vector<long> dist(n, LONG_MAX);\\n        dijkstra(badj, n, dest, dist);\\n        \\n        // src1 -> vertices\\n        vector<long> dist1(n, LONG_MAX);\\n        dijkstra(adj, n, src1, dist1);\\n        \\n        // src2 -> vertices\\n        vector<long> dist2(n, LONG_MAX);\\n        dijkstra(adj, n, src2, dist2);\\n        \\n        long ret = LONG_MAX;\\n        for(int i=0; i<n; i++){\\n            if(dist1[i] != LONG_MAX && dist2[i] != LONG_MAX && dist[i] != LONG_MAX){\\n                ret = min(ret, dist1[i] + dist2[i] + dist[i]);\\n            }\\n        }\\n            \\n        return (ret == LONG_MAX)? -1:ret;\\n    }\\n};\\n```\n```O(|E+V| * log|V|)```\n```O(|E+V|)```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1811828,
                "content": [
                    {
                        "username": "MdoingIt",
                        "content": "can we apply multi source dijktras here?"
                    },
                    {
                        "username": "zhhackk",
                        "content": "how?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Substring of One Repeating Character",
        "question_content": "<p>You are given a <strong>0-indexed</strong> string <code>s</code>. You are also given a <strong>0-indexed</strong> string <code>queryCharacters</code> of length <code>k</code> and a <strong>0-indexed</strong> array of integer <strong>indices</strong> <code>queryIndices</code> of length <code>k</code>, both of which are used to describe <code>k</code> queries.</p>\n\n<p>The <code>i<sup>th</sup></code> query updates the character in <code>s</code> at index <code>queryIndices[i]</code> to the character <code>queryCharacters[i]</code>.</p>\n\n<p>Return <em>an array</em> <code>lengths</code> <em>of length </em><code>k</code><em> where</em> <code>lengths[i]</code> <em>is the <strong>length</strong> of the <strong>longest substring</strong> of </em><code>s</code><em> consisting of <strong>only one repeating</strong> character <strong>after</strong> the</em> <code>i<sup>th</sup></code> <em>query</em><em> is performed.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;babacc&quot;, queryCharacters = &quot;bcb&quot;, queryIndices = [1,3,3]\n<strong>Output:</strong> [3,3,4]\n<strong>Explanation:</strong> \n- 1<sup>st</sup> query updates s = &quot;<u>b<strong>b</strong>b</u>acc&quot;. The longest substring consisting of one repeating character is &quot;bbb&quot; with length 3.\n- 2<sup>nd</sup> query updates s = &quot;bbb<u><strong>c</strong>cc</u>&quot;. \n  The longest substring consisting of one repeating character can be &quot;bbb&quot; or &quot;ccc&quot; with length 3.\n- 3<sup>rd</sup> query updates s = &quot;<u>bbb<strong>b</strong></u>cc&quot;. The longest substring consisting of one repeating character is &quot;bbbb&quot; with length 4.\nThus, we return [3,3,4].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abyzz&quot;, queryCharacters = &quot;aa&quot;, queryIndices = [2,1]\n<strong>Output:</strong> [2,3]\n<strong>Explanation:</strong>\n- 1<sup>st</sup> query updates s = &quot;ab<strong>a</strong><u>zz</u>&quot;. The longest substring consisting of one repeating character is &quot;zz&quot; with length 2.\n- 2<sup>nd</sup> query updates s = &quot;<u>a<strong>a</strong>a</u>zz&quot;. The longest substring consisting of one repeating character is &quot;aaa&quot; with length 3.\nThus, we return [2,3].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n\t<li><code>k == queryCharacters.length == queryIndices.length</code></li>\n\t<li><code>1 &lt;= k &lt;= 10<sup>5</sup></code></li>\n\t<li><code>queryCharacters</code> consists of lowercase English letters.</li>\n\t<li><code>0 &lt;= queryIndices[i] &lt; s.length</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1867713,
                "title": "c-segment-tree",
                "content": "#### Prerequisite: Construction of segment tree\\nContruction and updating characters in segment tree is easy ( standard problem ), but keeping the record of longest substring with one repeating is hard. To do this, we will need 5 parameter.\\nlet a segement be from index `l` to `h`, then the five parameters are:\\n1. longest substring in segment `l` to `h`\\n1. leftmost character of segment `l` to `h`\\n1. rightmost character of segment `l` to `h`\\n1. index of rightend of contiguous characters of segment `l` to `h` from left side  \\n1. index of leftend of contiguous characters of segment `l` to `h` from right side\\n\\n### For example,\\nfor a string `s` = \"**abssefgth**\", we have segement from` l = 2` to` h = 8` ( **ssefgth** ). Then the five parameter are:\\n1. longest substring in segment is **2**\\n1. leftmost character of segment is **s**\\n1. rightmost character of segment is **h**\\n1. index of rightend of contiguous characters of segment is **3** ( \"ss\" => 2 to 3)\\n1. index of rightend of contiguous characters of segment is **8** ( \"h\" => 8 to 8)\\n\\nTo store these values, following arrays are defined:\\n* `nums` to store the longest substring in segment\\n* `lc` to store leftmost character of segment \\n* `rc` to store rightmost character of segment `l` to `h` \\n* `left` to store index of rightend of contiguous characters of segment `l` to `h` from **left** side.\\n* `right` to store index of contiguous characters of segment `l` to `h` from **right** side\\n\\n**Idea to find longest substring in segment**:\\nAssuming we have done calculation for both *left* and *right* child of a segment, calculation for *parent* is as follows:\\nfor example, *parent*  = \"**smmh**\", then the *leftchild* = \"**sm**\", *rightchild* = \"**mh**\",\\nthe index of segment from `l` to `h` is `in` and left child segment is from `l` to `m` and right child segment is from `m+1` to `h` , where ` m = (l+h)/2`\\n* leftmost character of segment is the leftmost character of left child.\\n* rightmost character of segment is the rightmost character of right child.\\n* Atfirst, ``left[in] = left[left_child]`` and ``right[in] = right[left_child]``, where *leftchild* and *rightchild* are the index of segment of left and right child\\n* Now suppose, if rightmost char of left child == leftmost char of right child and also left[left_child] == m (end of segment of left child), then new left[in] = left[right_child]. similarly, if right[right_child] == m+1 (start of the segement of right child), the new value right[in] = right[left_child]\\n* Now, longest substring can be, from `l` to `left[in]`, or from `right[in]` to `h`, or from `right[left_child]` to `left[right_child]` if rightmost char of left child == leftmost char of right child. Or it can be max of longest substring of *leftchild* and *rightchild*.\\n\\nRest of the operations are given in the code below:\\n```\\nclass sgtree{\\npublic:\\n    vector<int> nums,left,right;\\n    vector<char> lc,rc; int n;\\n    sgtree(string &s){\\n        n = s.size();\\n        nums = vector<int>(4*n+5,0);\\n        left = vector<int>(4*n+5,-1);\\n        right = vector<int>(4*n+5,-1);\\n        lc = vector<char>(4*n+5,\\'*\\');\\n        rc = vector<char>(4*n+5,\\'*\\');\\n        build(0,s,0,n-1);\\n    }\\n    void build(int in, string &s,int l,int h){\\n        if(l>h) return;\\n        if(l==h){\\n            lc[in] = rc[in] = s[l];\\n            left[in] = l,right[in] = l; nums[in] = 1;\\n            return;\\n        }\\n        int m = (l+h)/2;\\n        build(2*in+1,s,l,m); build(2*in+2,s,m+1,h); \\n        merge(in,l,m,h);\\n    }\\n    void merge(int in,int l,int m,int h){\\n        int lt = in*2+1, rt = in*2+2, max_ = 0;\\n        lc[in] = lc[lt]; rc[in] = rc[rt];\\n        left[in] = left[lt];\\n        right[in] = right[rt]; \\n        if(rc[lt]==lc[rt]){ \\n            if(left[lt]==m) left[in] = left[rt];\\n        }\\n        if(lc[rt]==rc[lt]){ \\n            if(right[rt]==m+1) right[in] = right[lt]; \\n        }\\n        if(rc[lt]==lc[rt]) max_ = left[rt]-right[lt]+1;\\n        \\n        max_ = max(max_,left[in]-l+1);\\n        max_ = max(max_,h-right[in]+1);\\n        nums[in] = max(max_,max(nums[lt],nums[rt]));\\n    }\\n    int update(int in,int l,int h,int j,char ch){\\n        if(l>h) return 0;\\n        if(l==h){\\n            lc[in] = rc[in] = ch;\\n            left[in] = l,right[in] = l; nums[in] = 1;\\n            return 1;\\n        }\\n        int m = (l+h)/2;\\n        if(j>=l && j<=m) update(2*in+1,l,m,j,ch);\\n        else update(2*in+2,m+1,h,j,ch); \\n        merge(in,l,m,h);\\n        return nums[in];\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string q, vector<int>& in) {\\n        sgtree node(s);\\n        vector<int> re(q.size(),0);\\n        for(int i = 0; i<q.size();++i){\\n            re[i] = node.update(0,0,s.size()-1,in[i],q[i]);\\n        }\\n        return re;\\n    }\\n};\\n```\\n**Time: O(nlogn)**\\n***Upvote*** if it helps",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass sgtree{\\npublic:\\n    vector<int> nums,left,right;\\n    vector<char> lc,rc; int n;\\n    sgtree(string &s){\\n        n = s.size();\\n        nums = vector<int>(4*n+5,0);\\n        left = vector<int>(4*n+5,-1);\\n        right = vector<int>(4*n+5,-1);\\n        lc = vector<char>(4*n+5,\\'*\\');\\n        rc = vector<char>(4*n+5,\\'*\\');\\n        build(0,s,0,n-1);\\n    }\\n    void build(int in, string &s,int l,int h){\\n        if(l>h) return;\\n        if(l==h){\\n            lc[in] = rc[in] = s[l];\\n            left[in] = l,right[in] = l; nums[in] = 1;\\n            return;\\n        }\\n        int m = (l+h)/2;\\n        build(2*in+1,s,l,m); build(2*in+2,s,m+1,h); \\n        merge(in,l,m,h);\\n    }\\n    void merge(int in,int l,int m,int h){\\n        int lt = in*2+1, rt = in*2+2, max_ = 0;\\n        lc[in] = lc[lt]; rc[in] = rc[rt];\\n        left[in] = left[lt];\\n        right[in] = right[rt]; \\n        if(rc[lt]==lc[rt]){ \\n            if(left[lt]==m) left[in] = left[rt];\\n        }\\n        if(lc[rt]==rc[lt]){ \\n            if(right[rt]==m+1) right[in] = right[lt]; \\n        }\\n        if(rc[lt]==lc[rt]) max_ = left[rt]-right[lt]+1;\\n        \\n        max_ = max(max_,left[in]-l+1);\\n        max_ = max(max_,h-right[in]+1);\\n        nums[in] = max(max_,max(nums[lt],nums[rt]));\\n    }\\n    int update(int in,int l,int h,int j,char ch){\\n        if(l>h) return 0;\\n        if(l==h){\\n            lc[in] = rc[in] = ch;\\n            left[in] = l,right[in] = l; nums[in] = 1;\\n            return 1;\\n        }\\n        int m = (l+h)/2;\\n        if(j>=l && j<=m) update(2*in+1,l,m,j,ch);\\n        else update(2*in+2,m+1,h,j,ch); \\n        merge(in,l,m,h);\\n        return nums[in];\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string q, vector<int>& in) {\\n        sgtree node(s);\\n        vector<int> re(q.size(),0);\\n        for(int i = 0; i<q.size();++i){\\n            re[i] = node.update(0,0,s.size()-1,in[i],q[i]);\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879490,
                "title": "segment-tree",
                "content": "#### Quick Refresher\\nSegment tree is a logarithmic data structure that operates on a fixed-size array. Leaves of the segment tree are elements of the array, and non-leaf nodes hold some value of interest (sum, average, etc.) for the underlying segments.\\n\\nSince updates and queries affect log(n) nodes, those operations have O(log n) complexity.\\n\\nSegment tree can be implemented using an array of `2 * n` size. You will need to know the index of the current node (root\\'s index is zero), and left and right positions of the current segment. The left child index is `i * 2 + 1`, and the right child - `i * 2 + 2`. We also adjust left and right positions for the children. When left and right are equal - we\\'ve reached the leaf node.\\n\\n> Note that the size of the array `n` needs to be extended to be the power of 2.\\n\\n#### Implementation\\nIt is quite interesting on how to apply a segment tree to this problem. To find out the longest substring, we need to track repeating characters on the left (prefix), suffix, and max length. This is how the segment tree looks like for `abbbbcc ` string:\\n![image](https://assets.leetcode.com/users/images/ae6a906f-5500-42e3-9817-b0e642805d5c_1648128284.57093.png)\\n\\nFor this problem, we do not need to query longest substring for an arbitrary range - only for the entire string. So, we only need the `st_set` operation. \\n\\nThe `st_set` first reaches the leaf node and sets the new characer, and then goes back and updates non-leaf nodes using the `merge` function.\\n\\n**C++**\\n```cpp\\nstruct node {\\n    char lc = 0, rc = 0;\\n    int pref = 0, suf = 0, longest = 0, sz = 1;\\n    void merge(node &l, node &r) {\\n        longest = max(l.longest, r.longest);\\n        if (l.rc == r.lc)\\n            longest = max(longest, l.suf + r.pref);\\n        sz = l.sz + r.sz;\\n        lc = l.lc;\\n        rc = r.rc;\\n        pref = l.pref + (l.pref == l.sz && l.lc == r.lc ? r.pref : 0);\\n        suf = r.suf + (r.suf == r.sz && r.rc == l.rc ? l.suf : 0);\\n    } \\n};\\nint st_set(vector<node>& st, int pos, char ch, int i, int l, int r) {\\n    if (l <= pos && pos <= r) {\\n        if (l != r) {\\n            auto m = l + (r - l) / 2, li = 2 * i + 1, ri = 2 * i + 2;\\n            st_set(st, pos, ch, li, l, m);\\n            st_set(st, pos, ch, ri, m + 1, r);\\n            st[i].merge(st[li], st[ri]);\\n        }\\n        else {\\n            st[i].lc = st[i].rc = ch;\\n            st[i].suf = st[i].pref = st[i].longest = 1;\\n        }\\n    }\\n    return st[i].longest;\\n}    \\nvector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n    vector<int> res;\\n    int powOf2 = 1, sz = s.size();\\n    while (powOf2 < sz) \\n        powOf2 <<= 1;\\n    vector<node> st(powOf2 * 2);\\n    for (int i = 0; i < s.size(); ++i)\\n        st_set(st, i, s[i], 0, 0, powOf2 - 1);\\n    for (int j = 0; j < queryCharacters.size(); ++j)\\n        res.push_back(st_set(st, queryIndices[j], queryCharacters[j], 0, 0, powOf2 - 1));\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstruct node {\\n    char lc = 0, rc = 0;\\n    int pref = 0, suf = 0, longest = 0, sz = 1;\\n    void merge(node &l, node &r) {\\n        longest = max(l.longest, r.longest);\\n        if (l.rc == r.lc)\\n            longest = max(longest, l.suf + r.pref);\\n        sz = l.sz + r.sz;\\n        lc = l.lc;\\n        rc = r.rc;\\n        pref = l.pref + (l.pref == l.sz && l.lc == r.lc ? r.pref : 0);\\n        suf = r.suf + (r.suf == r.sz && r.rc == l.rc ? l.suf : 0);\\n    } \\n};\\nint st_set(vector<node>& st, int pos, char ch, int i, int l, int r) {\\n    if (l <= pos && pos <= r) {\\n        if (l != r) {\\n            auto m = l + (r - l) / 2, li = 2 * i + 1, ri = 2 * i + 2;\\n            st_set(st, pos, ch, li, l, m);\\n            st_set(st, pos, ch, ri, m + 1, r);\\n            st[i].merge(st[li], st[ri]);\\n        }\\n        else {\\n            st[i].lc = st[i].rc = ch;\\n            st[i].suf = st[i].pref = st[i].longest = 1;\\n        }\\n    }\\n    return st[i].longest;\\n}    \\nvector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n    vector<int> res;\\n    int powOf2 = 1, sz = s.size();\\n    while (powOf2 < sz) \\n        powOf2 <<= 1;\\n    vector<node> st(powOf2 * 2);\\n    for (int i = 0; i < s.size(); ++i)\\n        st_set(st, i, s[i], 0, 0, powOf2 - 1);\\n    for (int j = 0; j < queryCharacters.size(); ++j)\\n        res.push_back(st_set(st, queryIndices[j], queryCharacters[j], 0, 0, powOf2 - 1));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1865794,
                "title": "java-storing-spans-in-a-treemap",
                "content": "High level idea:\\n1. Store the span of each letter in a TreeMap\\n2. Also use a second TreeMap to record the frequency of each span length\\n2. On each query, update both TreeMaps\\n```\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        char[] arr = s.toCharArray();\\n        int m = arr.length, n = queryIndices.length;\\n        int[] output = new int[n];\\n        TreeMap<Integer, Integer> lengths = new TreeMap<>(), spans = new TreeMap<>();\\n        // Stores spans of each letter in the TreeMap\\n        for (int i = 0, j = 1; j <= m; j++) if (j == m || arr[i] != arr[j]) {\\n            lengths.put(j - i, lengths.getOrDefault(j - i, 0) + 1);\\n            spans.put(i, j - 1);\\n            i = j;\\n        }\\n        // Update spans on each query and find the max length\\n        for (int i = 0; i < queryIndices.length; i++) {\\n            int j = queryIndices[i];\\n            if (arr[j] != queryCharacters.charAt(i)) {\\n                // Remove the spans that has the character to be updated\\n                int l = spans.floorKey(j), r = spans.remove(l), length = r - l + 1;\\n                if (lengths.get(length) == 1) lengths.remove(length);\\n                else lengths.put(length, lengths.get(length) - 1);\\n                // if the character is going to be different from its neighbors, break the span\\n                if (l < j) {\\n                    spans.put(l, j - 1);\\n                    lengths.put(j - l, lengths.getOrDefault(j - l, 0) + 1);\\n                }\\n                if (r > j) {\\n                    spans.put(j + 1, r);\\n                    lengths.put(r - j, lengths.getOrDefault(r - j, 0) + 1);\\n                }\\n                arr[j] = queryCharacters.charAt(i);\\n                l = j;\\n                r = j;\\n                // if the character is going to be same as its neighbors, merge the spans\\n                if (j > 0 && arr[j] == arr[j - 1]) {\\n                    l = spans.floorKey(j);\\n                    length = spans.remove(l) - l + 1;\\n                    if (lengths.get(length) == 1) lengths.remove(length);\\n                    else lengths.put(length, lengths.get(length) - 1);\\n                }\\n                if (j < m - 1 && arr[j] == arr[j + 1]) {\\n                    int key = spans.ceilingKey(j);\\n                    r = spans.remove(key);\\n                    length = r - key + 1;\\n                    if (lengths.get(length) == 1) lengths.remove(length);\\n                    else lengths.put(length, lengths.get(length) - 1);\\n                }\\n                spans.put(l, r);\\n                lengths.put(r - l + 1, lengths.getOrDefault(r - l + 1, 0) + 1);\\n            }\\n            output[i] = lengths.lastKey();\\n        }\\n        return output;\\n    }\\n```\\nTime complexity: O(nlogn)\\nSpace complexity: O(n)",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        char[] arr = s.toCharArray();\\n        int m = arr.length, n = queryIndices.length;\\n        int[] output = new int[n];\\n        TreeMap<Integer, Integer> lengths = new TreeMap<>(), spans = new TreeMap<>();\\n        // Stores spans of each letter in the TreeMap\\n        for (int i = 0, j = 1; j <= m; j++) if (j == m || arr[i] != arr[j]) {\\n            lengths.put(j - i, lengths.getOrDefault(j - i, 0) + 1);\\n            spans.put(i, j - 1);\\n            i = j;\\n        }\\n        // Update spans on each query and find the max length\\n        for (int i = 0; i < queryIndices.length; i++) {\\n            int j = queryIndices[i];\\n            if (arr[j] != queryCharacters.charAt(i)) {\\n                // Remove the spans that has the character to be updated\\n                int l = spans.floorKey(j), r = spans.remove(l), length = r - l + 1;\\n                if (lengths.get(length) == 1) lengths.remove(length);\\n                else lengths.put(length, lengths.get(length) - 1);\\n                // if the character is going to be different from its neighbors, break the span\\n                if (l < j) {\\n                    spans.put(l, j - 1);\\n                    lengths.put(j - l, lengths.getOrDefault(j - l, 0) + 1);\\n                }\\n                if (r > j) {\\n                    spans.put(j + 1, r);\\n                    lengths.put(r - j, lengths.getOrDefault(r - j, 0) + 1);\\n                }\\n                arr[j] = queryCharacters.charAt(i);\\n                l = j;\\n                r = j;\\n                // if the character is going to be same as its neighbors, merge the spans\\n                if (j > 0 && arr[j] == arr[j - 1]) {\\n                    l = spans.floorKey(j);\\n                    length = spans.remove(l) - l + 1;\\n                    if (lengths.get(length) == 1) lengths.remove(length);\\n                    else lengths.put(length, lengths.get(length) - 1);\\n                }\\n                if (j < m - 1 && arr[j] == arr[j + 1]) {\\n                    int key = spans.ceilingKey(j);\\n                    r = spans.remove(key);\\n                    length = r - key + 1;\\n                    if (lengths.get(length) == 1) lengths.remove(length);\\n                    else lengths.put(length, lengths.get(length) - 1);\\n                }\\n                spans.put(l, r);\\n                lengths.put(r - l + 1, lengths.getOrDefault(r - l + 1, 0) + 1);\\n            }\\n            output[i] = lengths.lastKey();\\n        }\\n        return output;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1867964,
                "title": "c-very-easy-to-understand-maintain-intervals-in-ordered-set-map",
                "content": "Basically, we store the same-character intervals as pairs in an ordered set. (For python you can use SortedList).\\n\\nOn an update, we split the interval containing that character, and then try to merge the neighboring intervals, keeping track of the length of the frequencies in an ordered map (or multiset, but multiset is much slower). \\n\\nThe time complexity per query is O(log N).\\nThe total time complexity is O(N log N + Q log N).\\nSpace complexity is O(N).\\n\\n```\\nclass Solution {\\npublic:\\n    using iv = array<int, 3>;\\n    // each interval will track [L, R, char]\\n\\n    set<iv> ivals;  // intervals\\n    map<int,int> lens;  // length frequencies\\n\\n    void cnt(int l) {\\n        // cnt(x)  adds a length x\\n        // cnt(-x) removes a length x\\n        int m = (l<0) ? -1 : 1;\\n        l = abs(l);\\n        if ( (lens[l] += m) <= 0 )\\n            lens.erase(l);\\n    }\\n    void add(iv t) {  // add new interval\\n        ivals.insert(t);\\n        cnt(t[1] - t[0] + 1);\\n    }\\n    void del(iv t) {  // erase existing interval\\n        ivals.erase(t);\\n        cnt( -(t[1]-t[0]+1) );\\n    }\\n\\n    inline set<iv>::iterator split(int i, iv m, char ch) {\\n        // split the interval containing index i\\n        // into (up to 3) new intervals\\n        // return the iterator to the new interval containing i\\n        del(m);\\n        if (m[0] < i)\\n            add( {m[0], i-1, m[2]} );\\n        if (m[1] > i)\\n            add( {i+1, m[1], m[2]} );\\n        cnt(1);\\n        auto res = ivals.insert( {i, i, ch} );\\n        return res.first;   // returns the iterator of the inserted interval\\n    }\\n\\n    template<class IT>\\n    void merge(IT it) {  // merge `it` with neighboring intervals\\n        iv m = *it;\\n        iv l = *prev(it);\\n        iv r = *next(it);\\n\\n        del(m);\\n        int nl = m[0], nr = m[1];  // bounds of new interval\\n\\n        if (l[2] == m[2])  // merge with left\\n            del(l),\\n            nl = l[0];\\n\\n        if (m[2] == r[2])  // merge with right\\n            del(r),\\n            nr = r[1];\\n\\n        add( {nl, nr, m[2]} );\\n    }\\n\\n    void upd(int i, char ch) {  // process a query\\n        auto it = ivals.lower_bound( {i,i,0} );\\n        iv m = *it;\\n        if (m[0] > i) m = *(--it);  // take previous \\n        if (ch == m[2]) return;\\n\\n        // here, m is the interval that contains i\\n        it = split(i, m, ch);\\n        merge(it);\\n    }\\n\\n    vector<int> longestRepeating(string S, string qc, vector<int>& qi) {\\n        int N = S.size();\\n        int Q = qc.size();\\n        S = \"?\" + S + \"?\";  // add some dummy characters to eliminate edge cases\\n\\n        int st = 1;\\n        char prev = S[1];\\n        add( {0,  0,  0} );  // some dummy intervals to eliminate edge cases\\n        add( {N+1,N+1,0} );  // significantly easier implementation this way\\n        for (int i = 2; i <= N+1; ++i) {\\n            if (S[i] == prev) continue;\\n            add( {st, i-1, prev} );\\n            prev = S[i];\\n            st = i;\\n        }\\n\\n        vector<int> ans(Q);\\n        for (int i = 0; i < Q; ++i) {\\n            upd( qi[i]+1, qc[i] );\\n            ans[i] = lens.rbegin()->first;  // take the max length\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    using iv = array<int, 3>;\\n    // each interval will track [L, R, char]\\n\\n    set<iv> ivals;  // intervals\\n    map<int,int> lens;  // length frequencies\\n\\n    void cnt(int l) {\\n        // cnt(x)  adds a length x\\n        // cnt(-x) removes a length x\\n        int m = (l<0) ? -1 : 1;\\n        l = abs(l);\\n        if ( (lens[l] += m) <= 0 )\\n            lens.erase(l);\\n    }\\n    void add(iv t) {  // add new interval\\n        ivals.insert(t);\\n        cnt(t[1] - t[0] + 1);\\n    }\\n    void del(iv t) {  // erase existing interval\\n        ivals.erase(t);\\n        cnt( -(t[1]-t[0]+1) );\\n    }\\n\\n    inline set<iv>::iterator split(int i, iv m, char ch) {\\n        // split the interval containing index i\\n        // into (up to 3) new intervals\\n        // return the iterator to the new interval containing i\\n        del(m);\\n        if (m[0] < i)\\n            add( {m[0], i-1, m[2]} );\\n        if (m[1] > i)\\n            add( {i+1, m[1], m[2]} );\\n        cnt(1);\\n        auto res = ivals.insert( {i, i, ch} );\\n        return res.first;   // returns the iterator of the inserted interval\\n    }\\n\\n    template<class IT>\\n    void merge(IT it) {  // merge `it` with neighboring intervals\\n        iv m = *it;\\n        iv l = *prev(it);\\n        iv r = *next(it);\\n\\n        del(m);\\n        int nl = m[0], nr = m[1];  // bounds of new interval\\n\\n        if (l[2] == m[2])  // merge with left\\n            del(l),\\n            nl = l[0];\\n\\n        if (m[2] == r[2])  // merge with right\\n            del(r),\\n            nr = r[1];\\n\\n        add( {nl, nr, m[2]} );\\n    }\\n\\n    void upd(int i, char ch) {  // process a query\\n        auto it = ivals.lower_bound( {i,i,0} );\\n        iv m = *it;\\n        if (m[0] > i) m = *(--it);  // take previous \\n        if (ch == m[2]) return;\\n\\n        // here, m is the interval that contains i\\n        it = split(i, m, ch);\\n        merge(it);\\n    }\\n\\n    vector<int> longestRepeating(string S, string qc, vector<int>& qi) {\\n        int N = S.size();\\n        int Q = qc.size();\\n        S = \"?\" + S + \"?\";  // add some dummy characters to eliminate edge cases\\n\\n        int st = 1;\\n        char prev = S[1];\\n        add( {0,  0,  0} );  // some dummy intervals to eliminate edge cases\\n        add( {N+1,N+1,0} );  // significantly easier implementation this way\\n        for (int i = 2; i <= N+1; ++i) {\\n            if (S[i] == prev) continue;\\n            add( {st, i-1, prev} );\\n            prev = S[i];\\n            st = i;\\n        }\\n\\n        vector<int> ans(Q);\\n        for (int i = 0; i < Q; ++i) {\\n            upd( qi[i]+1, qc[i] );\\n            ans[i] = lens.rbegin()->first;  // take the max length\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877448,
                "title": "merge-intervals-using-map",
                "content": "Using a segment tree seems natural here, though good luck implementing it if you haven\\'t practiced that data structure recently.\\n\\nInstead, we can solve this problem by merging (and breaking) intervals. \\n\\n> Also check this [segment tree-based solution](https://leetcode.com/problems/longest-substring-of-one-repeating-character/discuss/1879490/Segment-Tree).\\n\\n**C++**\\nWe use a hash map to track the start of intervals (with repeating characters), and its length. We also use a multiset to store all lengths in the sorted order (so we know the longest one).\\n\\nTo simplify coding (and debugging), it\\'s good to encapsulate interval operations into `insert`, `erase`, and `replace` functions.\\n\\nIt is important to first check that the new character is different from the current one. That way, we know that we need to break the interval that covers this character index.\\n\\n```cpp\\nvector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n    map<int, int> m;\\n    multiset<int> sizes;\\n    vector<int> res;\\n    auto insert = [&](int i, int sz) { \\n        sizes.insert(sz);\\n        return m.insert({i, sz}).first;\\n    };\\n    auto replace = [&](auto p, int new_sz) {\\n        sizes.erase(sizes.find(p->second));\\n        sizes.insert(new_sz);\\n        p->second = new_sz;\\n    };\\n    auto erase = [&](auto p) {\\n        sizes.erase(sizes.find(p->second));\\n        m.erase(p);\\n    };    \\n    auto p = end(m);\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (i == 0 || s[i - 1] != s[i])\\n            p = m.insert({i, 1}).first;\\n        else\\n            ++p->second;\\n    }\\n    for (auto [i, size] : m)\\n        sizes.insert(size);\\n    for (int j = 0; j < queryCharacters.size(); ++j) {\\n        char ch = queryCharacters[j];\\n        int i = queryIndices[j];\\n        if (ch != s[i]) {   \\n            s[i] = ch;\\n            auto p = m.lower_bound(i);\\n            if (i > 0 && (p == end(m) || p->first > i)) { // break left\\n                p = insert(i, prev(p)->second - (i - prev(p)->first));\\n                replace(prev(p), i - prev(p)->first);\\n            }      \\n            if (p->second > 1) { // break right\\n                insert(i + 1, p->second - 1);\\n                replace(p, 1);\\n            }\\n            if (i < s.size() - 1 && ch == s[i + 1]) { // join right\\n                replace(p, next(p)->second + 1);\\n                erase(next(p));\\n            }\\n            if (i > 0 && s[i - 1] == ch) { // join left\\n                replace(prev(p), prev(p)->second + p->second);\\n                erase(p);\\n            }                \\n        }\\n        res.push_back(*rbegin(sizes));\\n    };\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n    map<int, int> m;\\n    multiset<int> sizes;\\n    vector<int> res;\\n    auto insert = [&](int i, int sz) { \\n        sizes.insert(sz);\\n        return m.insert({i, sz}).first;\\n    };\\n    auto replace = [&](auto p, int new_sz) {\\n        sizes.erase(sizes.find(p->second));\\n        sizes.insert(new_sz);\\n        p->second = new_sz;\\n    };\\n    auto erase = [&](auto p) {\\n        sizes.erase(sizes.find(p->second));\\n        m.erase(p);\\n    };    \\n    auto p = end(m);\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (i == 0 || s[i - 1] != s[i])\\n            p = m.insert({i, 1}).first;\\n        else\\n            ++p->second;\\n    }\\n    for (auto [i, size] : m)\\n        sizes.insert(size);\\n    for (int j = 0; j < queryCharacters.size(); ++j) {\\n        char ch = queryCharacters[j];\\n        int i = queryIndices[j];\\n        if (ch != s[i]) {   \\n            s[i] = ch;\\n            auto p = m.lower_bound(i);\\n            if (i > 0 && (p == end(m) || p->first > i)) { // break left\\n                p = insert(i, prev(p)->second - (i - prev(p)->first));\\n                replace(prev(p), i - prev(p)->first);\\n            }      \\n            if (p->second > 1) { // break right\\n                insert(i + 1, p->second - 1);\\n                replace(p, 1);\\n            }\\n            if (i < s.size() - 1 && ch == s[i + 1]) { // join right\\n                replace(p, next(p)->second + 1);\\n                erase(next(p));\\n            }\\n            if (i > 0 && s[i - 1] == ch) { // join left\\n                replace(prev(p), prev(p)->second + p->second);\\n                erase(p);\\n            }                \\n        }\\n        res.push_back(*rbegin(sizes));\\n    };\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1866110,
                "title": "java-clean-segment-tree-solution",
                "content": "```\\nclass Node{\\n    int max;\\n    int prefSt,prefEnd;\\n    int suffSt,suffEnd;\\n    Node(int max,int prefSt,int prefEnd,int suffSt,int suffEnd){\\n        this.max=max;\\n        this.prefSt=prefSt;\\n        this.prefEnd=prefEnd;\\n        this.suffSt=suffSt;\\n        this.suffEnd=suffEnd;\\n    }\\n}\\n\\nclass SegmentTree{\\n    Node [] tree;\\n    StringBuilder s;\\n    SegmentTree(String s){\\n        this.s=new StringBuilder();\\n        this.s.append(s);\\n        tree=new Node[4*s.length()];\\n        build(0,0,s.length()-1);\\n    }\\n    \\n    Node merge(Node left,Node right,int tl,int tm,int tr){\\n        int max=Integer.max(left.max,right.max);\\n        int prefSt=left.prefSt;\\n        int prefEnd=left.prefEnd;\\n        int suffSt=right.suffSt;\\n        int suffEnd=right.suffEnd;\\n        \\n        if(s.charAt(tm)==s.charAt(tm+1)){\\n            max=Integer.max(max,right.prefEnd-left.suffSt+1);\\n            if(left.prefEnd-left.prefSt+1==tm-tl+1)\\n                prefEnd=right.prefEnd;\\n            if(right.suffEnd-right.suffSt+1==tr-tm)\\n                suffSt=left.suffSt;\\n        }\\n        \\n        return new Node(max,prefSt,prefEnd,suffSt,suffEnd);\\n    }\\n    \\n    void build(int pos,int tl,int tr){\\n        if(tl==tr){\\n            tree[pos]=new Node(1,tl,tl,tr,tr);\\n        }else{\\n            int tm=tl+(tr-tl)/2;\\n            build(2*pos+1,tl,tm);\\n            build(2*pos+2,tm+1,tr);\\n            \\n            tree[pos]=merge(tree[2*pos+1],tree[2*pos+2],tl,tm,tr);\\n        }\\n    }\\n    \\n    void update(int pos,int tl,int tr,int idx,char ch){\\n        if(tl==tr){\\n            tree[pos]=new Node(1,tl,tl,tr,tr);\\n            s.setCharAt(idx,ch);\\n            // System.out.println(pos);\\n        }\\n        else{\\n            int tm=tl+(tr-tl)/2;\\n            if(idx<=tm)\\n                update(2*pos+1,tl,tm,idx,ch);\\n            else\\n                update(2*pos+2,tm+1,tr,idx,ch);\\n            tree[pos]=merge(tree[2*pos+1],tree[2*pos+2],tl,tm,tr);\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        int k=queryIndices.length;\\n        SegmentTree tree=new SegmentTree(s);\\n        for(int i=0;i<k;i++){\\n            tree.update(0,0,s.length()-1,queryIndices[i],queryCharacters.charAt(i));\\n            queryIndices[i]=tree.tree[0].max;\\n        }\\n        return queryIndices;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Node{\\n    int max;\\n    int prefSt,prefEnd;\\n    int suffSt,suffEnd;\\n    Node(int max,int prefSt,int prefEnd,int suffSt,int suffEnd){\\n        this.max=max;\\n        this.prefSt=prefSt;\\n        this.prefEnd=prefEnd;\\n        this.suffSt=suffSt;\\n        this.suffEnd=suffEnd;\\n    }\\n}\\n\\nclass SegmentTree{\\n    Node [] tree;\\n    StringBuilder s;\\n    SegmentTree(String s){\\n        this.s=new StringBuilder();\\n        this.s.append(s);\\n        tree=new Node[4*s.length()];\\n        build(0,0,s.length()-1);\\n    }\\n    \\n    Node merge(Node left,Node right,int tl,int tm,int tr){\\n        int max=Integer.max(left.max,right.max);\\n        int prefSt=left.prefSt;\\n        int prefEnd=left.prefEnd;\\n        int suffSt=right.suffSt;\\n        int suffEnd=right.suffEnd;\\n        \\n        if(s.charAt(tm)==s.charAt(tm+1)){\\n            max=Integer.max(max,right.prefEnd-left.suffSt+1);\\n            if(left.prefEnd-left.prefSt+1==tm-tl+1)\\n                prefEnd=right.prefEnd;\\n            if(right.suffEnd-right.suffSt+1==tr-tm)\\n                suffSt=left.suffSt;\\n        }\\n        \\n        return new Node(max,prefSt,prefEnd,suffSt,suffEnd);\\n    }\\n    \\n    void build(int pos,int tl,int tr){\\n        if(tl==tr){\\n            tree[pos]=new Node(1,tl,tl,tr,tr);\\n        }else{\\n            int tm=tl+(tr-tl)/2;\\n            build(2*pos+1,tl,tm);\\n            build(2*pos+2,tm+1,tr);\\n            \\n            tree[pos]=merge(tree[2*pos+1],tree[2*pos+2],tl,tm,tr);\\n        }\\n    }\\n    \\n    void update(int pos,int tl,int tr,int idx,char ch){\\n        if(tl==tr){\\n            tree[pos]=new Node(1,tl,tl,tr,tr);\\n            s.setCharAt(idx,ch);\\n            // System.out.println(pos);\\n        }\\n        else{\\n            int tm=tl+(tr-tl)/2;\\n            if(idx<=tm)\\n                update(2*pos+1,tl,tm,idx,ch);\\n            else\\n                update(2*pos+2,tm+1,tr,idx,ch);\\n            tree[pos]=merge(tree[2*pos+1],tree[2*pos+2],tl,tm,tr);\\n        }\\n    }\\n}\\n\\nclass Solution {\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        int k=queryIndices.length;\\n        SegmentTree tree=new SegmentTree(s);\\n        for(int i=0;i<k;i++){\\n            tree.update(0,0,s.length()-1,queryIndices[i],queryCharacters.charAt(i));\\n            queryIndices[i]=tree.tree[0].max;\\n        }\\n        return queryIndices;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865692,
                "title": "python-solution-now-ac-updated",
                "content": "This is my contest solution, which in fact follows official leetcode hints, however it gives TLE.\\n\\nSo, the idea is to use segment tree, where for each segment we keep the following information:\\n(longest repating substring, longest repeating suffix, longest repeating prefix, length of segment, left symbol of segment, right symbol of segment)\\n\\nThen we can update these `6` values when we merge segments.\\n\\n\\n#### Complexity\\nIt is `O(n log n + m log n)`, where `n = len(s)` and `m` is number of queries.\\n\\n#### Code\\n```python\\nclass SegmentTree:\\n    def __init__(self, n, arr):\\n        self.size = 1\\n        ZERO = (0, 0, 0, 0, 0, 0)\\n        while self.size < n:\\n            self.size *= 2\\n        self.T = [ZERO] * (2 * self.size - 1)\\n        self.arr = arr\\n        self.ZERO = ZERO  # neutral element\\n\\n    def combine(self, a, b):\\n        f1, s1, e1, L1, r1, l1 = a\\n        f2, s2, e2, L2, r2, l2 = b\\n        f = max(f1, f2)\\n        if r1 == l2: f = max(f, e1 + s2)\\n        e = e2 + e1 if (e2 == L2 and r1 == l2) else e2\\n        s = s1 + s2 if (e1 == L1 and r1 == l2) else s1\\n        L = L1 + L2\\n        r = r2\\n        l = l1\\n        return (f, s, e, L, r, l)\\n\\n    def one_element(self, x):\\n        return 1, 1, 1, 1, x, x\\n\\n    def _build(self, x, lx, rx):\\n        if rx - lx == 1:\\n            if lx < len(self.arr):\\n                self.T[x] = self.one_element(self.arr[lx])\\n        else:\\n            mx = (lx + rx) // 2\\n            self._build(2 * x + 1, lx, mx)\\n            self._build(2 * x + 2, mx, rx)\\n            self.T[x] = self.combine(self.T[2 * x + 1], self.T[2 * x + 2])\\n\\n    def build(self):\\n        self._build(0, 0, self.size)\\n\\n    def _set(self, i, v, x, lx, rx):\\n        if rx - lx == 1:\\n            self.T[x] = self.one_element(v)\\n            return\\n        mx = (lx + rx) // 2\\n        if i < mx:\\n            self._set(i, v, 2 * x + 1, lx, mx)\\n        else:\\n            self._set(i, v, 2 * x + 2, mx, rx)\\n        self.T[x] = self.combine(self.T[2 * x + 1], self.T[2 * x + 2])\\n\\n    def set(self, i, v):\\n        self._set(i, v, 0, 0, self.size)\\n\\n    def _calc(self, l, r, x, lx, rx):\\n        if l >= rx or lx >= r:\\n            return self.ZERO\\n        if lx >= l and rx <= r:\\n            return self.T[x]\\n        mx = (lx + rx) // 2\\n        s1 = self._calc(l, r, 2 * x + 1, lx, mx)\\n        s2 = self._calc(l, r, 2 * x + 2, mx, rx)\\n        return self.combine(s1, s2)\\n\\n    def calc(self, l, r):\\n        return self._calc(l, r, 0, 0, self.size)\\n\\nclass Solution:\\n    def longestRepeating(self, s, Q1, Q2):\\n        n = len(s)\\n        m = len(Q1)\\n        ans = []\\n        STree = SegmentTree(n, s)\\n        STree.build()\\n        for i in range(m):\\n            STree.set(Q2[i], Q1[i])\\n            ans += [STree.calc(0, n)[0]]\\n        return ans\\n```\\n\\n#### Solution 2\\nIs it possible to make this problem with segment tree? Yes, but for this you need to optimize it, one of the possible ways is the following:\\n1. Use iterative tree instead of recursive. Notice that in this case we need to be careful with the order of operations on segments, it is not commutative!\\n2. Make use that we always have queries in range `[0, n)`, it means that we can compute once partition we have and then when we have query, just evaluate merge of these segments.\\n\\n#### Complexity\\nStill the same, but optimized.\\n\\n#### Code\\n```python\\nclass SegmentTree:\\n    def __init__(self, n, F):\\n        self.N = n\\n        self.F = F\\n        self.sums = [(0,0,0,0,0,0) for i in range(2*n)]\\n        self.dp = list(range(2*n))\\n        for i in range(n-1, -1, -1): self.dp[i] = self.dp[2*i]\\n            \\n        L, R = self.N, 2*self.N - 1\\n        parts = []\\n        while L <= R:\\n            if L & 1:\\n                parts += [(self.dp[L], L)]\\n                L += 1\\n            if R & 1 == 0:\\n                parts += [(self.dp[R], R)]\\n                R -= 1\\n            L//=2; R//=2\\n                \\n        parts.sort()\\n        self.d = [j for i, j in parts]\\n        \\n    def update(self, index, val):\\n        idx = index + self.N\\n        self.sums[idx] = (1, 1, 1, 1, val, val)\\n        while idx > 1:\\n            idx //= 2\\n            self.sums[idx] = self.F(self.sums[2*idx], self.sums[2*idx+1])\\n            \\n    def query(self):\\n        ans = (0, 0, 0, 0, 0, 0)\\n        for x in self.d:\\n            ans = self.F(ans, self.sums[x])\\n        return ans\\n\\nclass Solution:\\n    def longestRepeating(self, s, Q1, Q2):\\n        def FN(a, b):\\n            if a == (0, 0, 0, 0, 0, 0): return b\\n            if b == (0, 0, 0, 0, 0, 0): return a\\n            f1, s1, e1, L1, r1, l1 = a\\n            f2, s2, e2, L2, r2, l2 = b\\n            if r1 == l2:\\n                return max(f1, f2, e1 + s2), s1+s2*(e1==L1), e2+e1*(e2==L2), L1 + L2, r2, l1\\n            else:\\n                return max(f1, f2), s1, e2, L1 + L2, r2, l1\\n\\n        n = len(s)\\n        m = len(Q1)\\n        ans = []\\n        STree = SegmentTree(n, FN)\\n        for i in range(n):\\n            STree.update(i, s[i])\\n        for i in range(m):\\n            STree.update(Q2[i], Q1[i])\\n            ans += [STree.query()[0]]\\n        return ans\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```python\\nclass SegmentTree:\\n    def __init__(self, n, arr):\\n        self.size = 1\\n        ZERO = (0, 0, 0, 0, 0, 0)\\n        while self.size < n:\\n            self.size *= 2\\n        self.T = [ZERO] * (2 * self.size - 1)\\n        self.arr = arr\\n        self.ZERO = ZERO  # neutral element\\n\\n    def combine(self, a, b):\\n        f1, s1, e1, L1, r1, l1 = a\\n        f2, s2, e2, L2, r2, l2 = b\\n        f = max(f1, f2)\\n        if r1 == l2: f = max(f, e1 + s2)\\n        e = e2 + e1 if (e2 == L2 and r1 == l2) else e2\\n        s = s1 + s2 if (e1 == L1 and r1 == l2) else s1\\n        L = L1 + L2\\n        r = r2\\n        l = l1\\n        return (f, s, e, L, r, l)\\n\\n    def one_element(self, x):\\n        return 1, 1, 1, 1, x, x\\n\\n    def _build(self, x, lx, rx):\\n        if rx - lx == 1:\\n            if lx < len(self.arr):\\n                self.T[x] = self.one_element(self.arr[lx])\\n        else:\\n            mx = (lx + rx) // 2\\n            self._build(2 * x + 1, lx, mx)\\n            self._build(2 * x + 2, mx, rx)\\n            self.T[x] = self.combine(self.T[2 * x + 1], self.T[2 * x + 2])\\n\\n    def build(self):\\n        self._build(0, 0, self.size)\\n\\n    def _set(self, i, v, x, lx, rx):\\n        if rx - lx == 1:\\n            self.T[x] = self.one_element(v)\\n            return\\n        mx = (lx + rx) // 2\\n        if i < mx:\\n            self._set(i, v, 2 * x + 1, lx, mx)\\n        else:\\n            self._set(i, v, 2 * x + 2, mx, rx)\\n        self.T[x] = self.combine(self.T[2 * x + 1], self.T[2 * x + 2])\\n\\n    def set(self, i, v):\\n        self._set(i, v, 0, 0, self.size)\\n\\n    def _calc(self, l, r, x, lx, rx):\\n        if l >= rx or lx >= r:\\n            return self.ZERO\\n        if lx >= l and rx <= r:\\n            return self.T[x]\\n        mx = (lx + rx) // 2\\n        s1 = self._calc(l, r, 2 * x + 1, lx, mx)\\n        s2 = self._calc(l, r, 2 * x + 2, mx, rx)\\n        return self.combine(s1, s2)\\n\\n    def calc(self, l, r):\\n        return self._calc(l, r, 0, 0, self.size)\\n\\nclass Solution:\\n    def longestRepeating(self, s, Q1, Q2):\\n        n = len(s)\\n        m = len(Q1)\\n        ans = []\\n        STree = SegmentTree(n, s)\\n        STree.build()\\n        for i in range(m):\\n            STree.set(Q2[i], Q1[i])\\n            ans += [STree.calc(0, n)[0]]\\n        return ans\\n```\n```python\\nclass SegmentTree:\\n    def __init__(self, n, F):\\n        self.N = n\\n        self.F = F\\n        self.sums = [(0,0,0,0,0,0) for i in range(2*n)]\\n        self.dp = list(range(2*n))\\n        for i in range(n-1, -1, -1): self.dp[i] = self.dp[2*i]\\n            \\n        L, R = self.N, 2*self.N - 1\\n        parts = []\\n        while L <= R:\\n            if L & 1:\\n                parts += [(self.dp[L], L)]\\n                L += 1\\n            if R & 1 == 0:\\n                parts += [(self.dp[R], R)]\\n                R -= 1\\n            L//=2; R//=2\\n                \\n        parts.sort()\\n        self.d = [j for i, j in parts]\\n        \\n    def update(self, index, val):\\n        idx = index + self.N\\n        self.sums[idx] = (1, 1, 1, 1, val, val)\\n        while idx > 1:\\n            idx //= 2\\n            self.sums[idx] = self.F(self.sums[2*idx], self.sums[2*idx+1])\\n            \\n    def query(self):\\n        ans = (0, 0, 0, 0, 0, 0)\\n        for x in self.d:\\n            ans = self.F(ans, self.sums[x])\\n        return ans\\n\\nclass Solution:\\n    def longestRepeating(self, s, Q1, Q2):\\n        def FN(a, b):\\n            if a == (0, 0, 0, 0, 0, 0): return b\\n            if b == (0, 0, 0, 0, 0, 0): return a\\n            f1, s1, e1, L1, r1, l1 = a\\n            f2, s2, e2, L2, r2, l2 = b\\n            if r1 == l2:\\n                return max(f1, f2, e1 + s2), s1+s2*(e1==L1), e2+e1*(e2==L2), L1 + L2, r2, l1\\n            else:\\n                return max(f1, f2), s1, e2, L1 + L2, r2, l1\\n\\n        n = len(s)\\n        m = len(Q1)\\n        ans = []\\n        STree = SegmentTree(n, FN)\\n        for i in range(n):\\n            STree.update(i, s[i])\\n        for i in range(m):\\n            STree.update(Q2[i], Q1[i])\\n            ans += [STree.query()[0]]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865727,
                "title": "python-sortedlist-solution",
                "content": "Keep track of both substrings of one repeating character and their lengths in `SortedList`. We can then find the substring that covers the query index, the one to the left, and the one to the right in O(logn) time. The rest is just tedious bookkeeping of substring split and merge. One pitfall to avoid is that both `add` and `remove` change the index of the elements in `SortedList`, so I defer those calls until I am done with the index.\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        sl = SortedList()\\n        length = SortedList()\\n        curr = 0\\n        for char, it in itertools.groupby(s):\\n            c = sum(1 for _ in it)\\n            length.add(c)\\n            sl.add((curr, curr + c, char))\\n            curr += c\\n        ans = []\\n        for char, i in zip(queryCharacters, queryIndices):\\n            t = (i, math.inf, \\'a\\')\\n            index = sl.bisect_right(t) - 1\\n            to_remove = [sl[index]]\\n            to_add = []\\n            left, right, original_char = to_remove[0]\\n            if original_char != char:\\n                length.remove(right - left)\\n                if right - left > 1:\\n                    if i == left:\\n                        left += 1\\n                        to_add.append((left, right, original_char))\\n                        length.add(right - left)\\n                    elif i == right - 1:\\n                        right -= 1\\n                        to_add.append((left, right, original_char))\\n                        length.add(right - left)\\n                    else:\\n                        to_add.append((left, i, original_char))\\n                        length.add(i - left)\\n                        to_add.append((i + 1, right, original_char))\\n                        length.add(right - (i + 1))\\n                \\n                l, r = i, i + 1\\n                if index - 1 >= 0 and sl[index - 1][1:3] == (i, char):\\n                    l, old_r, _ = sl[index - 1]\\n                    to_remove.append(sl[index - 1])\\n                    length.remove(old_r - l)\\n                if index + 1 < len(sl) and sl[index + 1][0] == i + 1 and sl[index + 1][2] == char:\\n                    old_l, r, old_length = sl[index + 1]\\n                    to_remove.append(sl[index + 1])\\n                    length.remove(r - old_l)\\n                length.add(r - l)\\n                sl.add((l, r, char))\\n                for t in to_remove:\\n                    sl.remove(t)\\n                sl.update(to_add)\\n            # print(sl)\\n            # print(length)\\n            ans.append(length[-1])\\n\\n        return ans\\n```\\nSadly, I finished this 5 min. after the contest \\uD83D\\uDE41",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        sl = SortedList()\\n        length = SortedList()\\n        curr = 0\\n        for char, it in itertools.groupby(s):\\n            c = sum(1 for _ in it)\\n            length.add(c)\\n            sl.add((curr, curr + c, char))\\n            curr += c\\n        ans = []\\n        for char, i in zip(queryCharacters, queryIndices):\\n            t = (i, math.inf, \\'a\\')\\n            index = sl.bisect_right(t) - 1\\n            to_remove = [sl[index]]\\n            to_add = []\\n            left, right, original_char = to_remove[0]\\n            if original_char != char:\\n                length.remove(right - left)\\n                if right - left > 1:\\n                    if i == left:\\n                        left += 1\\n                        to_add.append((left, right, original_char))\\n                        length.add(right - left)\\n                    elif i == right - 1:\\n                        right -= 1\\n                        to_add.append((left, right, original_char))\\n                        length.add(right - left)\\n                    else:\\n                        to_add.append((left, i, original_char))\\n                        length.add(i - left)\\n                        to_add.append((i + 1, right, original_char))\\n                        length.add(right - (i + 1))\\n                \\n                l, r = i, i + 1\\n                if index - 1 >= 0 and sl[index - 1][1:3] == (i, char):\\n                    l, old_r, _ = sl[index - 1]\\n                    to_remove.append(sl[index - 1])\\n                    length.remove(old_r - l)\\n                if index + 1 < len(sl) and sl[index + 1][0] == i + 1 and sl[index + 1][2] == char:\\n                    old_l, r, old_length = sl[index + 1]\\n                    to_remove.append(sl[index + 1])\\n                    length.remove(r - old_l)\\n                length.add(r - l)\\n                sl.add((l, r, char))\\n                for t in to_remove:\\n                    sl.remove(t)\\n                sl.update(to_add)\\n            # print(sl)\\n            # print(length)\\n            ans.append(length[-1])\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866248,
                "title": "python-segment-tree",
                "content": "If anyone is struggling with getting TLE using `Python` + `Segment Tree`. I think this might help.\\n\\nThe basic idea is the same. We need to keep tracking the 6 values in each segments.\\n\\n1. longest repating character (noted as `lc`)\\n2. length of the above character (noted as `ll`)\\n3. longest repeating prefix character (noted as `pc`)\\n4. length of the above character (noted as `pl`)\\n5. longest repeating suffix character (noted as `sc`)\\n6. length of the above character (noted as `sl`)\\n\\nBelow is my code. It\\'s not very elegant, but can pass the questions without getting TLE.\\n\\n```\\nclass SegmentTree:\\n    def __init__(self, data):\\n        self.nodes = [None] * 4 * len(data) #node: (value, left_node_index, right_node_index)\\n        self.data = data\\n        self._build_tree(0, 0, len(data)-1)\\n\\n    def _left(self, index):\\n        return (index + 1) * 2 - 1\\n\\n    def _right(self, index):\\n        return (index + 1) * 2\\n\\n    def _build_tree(self, node_index, left_data_index, right_data_index):\\n        value = None\\n        if left_data_index == right_data_index:\\n            # (longest c, longest len, prefix c, prefix len, suffix c, suffix len)\\n            value = (\\n                self.data[left_data_index],\\n                1,\\n                self.data[left_data_index],\\n                1,\\n                self.data[left_data_index],\\n                1)\\n        else:\\n            left_node_index = self._left(node_index)\\n            right_node_index = self._right(node_index)\\n\\n            mid_data_index = (left_data_index + right_data_index) // 2\\n            (left_lc, left_ll, left_pc, left_pl, left_sc, left_sl) = self._build_tree(left_node_index, left_data_index, mid_data_index)\\n            (right_lc, right_ll, right_pc, right_pl, right_sc, right_sl) = self._build_tree(right_node_index, mid_data_index + 1, right_data_index)\\n            \\n            lc = ll = None\\n            if left_ll > right_ll:\\n                lc = left_lc\\n                ll = left_ll\\n            else:\\n                lc = right_lc\\n                ll = right_ll\\n            if left_sc == right_pc and left_sl + right_pl > ll:\\n                ll = left_sl + right_pl\\n                lc = left_sc\\n\\n            pc = left_pc\\n            pl = left_pl\\n            if left_pl == (mid_data_index - left_data_index + 1) and left_pc == right_pc:\\n                pl = left_pl + right_pl\\n\\n            sc = right_sc\\n            sl = right_sl\\n            if right_sl == (right_data_index - mid_data_index) and left_sc == right_sc:\\n                sl = left_sl + right_sl\\n    \\n            value = (lc, ll, pc, pl, sc, sl)\\n\\n        self.nodes[node_index] = value\\n        return value\\n\\n    def _update(self, node_index, data_index, update_value, left_data_index, right_data_index):\\n        value = self.nodes[node_index]\\n        mid_data_index = (left_data_index + right_data_index) // 2\\n        left_node_index = self._left(node_index)\\n        right_node_index = self._right(node_index)\\n\\n        new_value = None\\n        if left_data_index == right_data_index:\\n            new_value = (\\n                update_value,\\n                1,\\n                update_value,\\n                1,\\n                update_value,\\n                1)\\n        else:\\n            left_value = right_value = None\\n            if data_index <= mid_data_index:\\n                left_value = self._update(left_node_index, data_index, update_value, left_data_index, mid_data_index)\\n                right_value = self.nodes[right_node_index]\\n            else:\\n                left_value = self.nodes[left_node_index]\\n                right_value = self._update(right_node_index, data_index, update_value, mid_data_index + 1, right_data_index)\\n            (left_lc, left_ll, left_pc, left_pl, left_sc, left_sl) = left_value\\n            (right_lc, right_ll, right_pc, right_pl, right_sc, right_sl) = right_value\\n            \\n            lc = ll = None\\n            if left_ll > right_ll:\\n                lc = left_lc\\n                ll = left_ll\\n            else:\\n                lc = right_lc\\n                ll = right_ll\\n            if left_sc == right_pc and left_sl + right_pl > ll:\\n                ll = left_sl + right_pl\\n                lc = left_sc\\n\\n            pc = left_pc\\n            pl = left_pl\\n            if left_pl == (mid_data_index - left_data_index + 1) and left_pc == right_pc:\\n                pl = left_pl + right_pl\\n\\n            sc = right_sc\\n            sl = right_sl\\n            if right_sl == (right_data_index - mid_data_index) and left_sc == right_sc:\\n                sl = left_sl + right_sl\\n    \\n            new_value = (lc, ll, pc, pl, sc, sl)\\n        self.nodes[node_index] = new_value\\n        return new_value\\n\\n    def update(self, data_index, update_value):\\n        self.data[data_index] = update_value\\n        return self._update(0, data_index, update_value, 0, len(self.data)-1)\\n\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        st = SegmentTree(list(s))\\n        M = len(queryCharacters)\\n        ans = [0] * M\\n        for i in range(M):\\n            c = queryCharacters[i]\\n            p = queryIndices[i]\\n            st.update(p, c)\\n            ans[i] = st.nodes[0][1]\\n        return ans\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass SegmentTree:\\n    def __init__(self, data):\\n        self.nodes = [None] * 4 * len(data) #node: (value, left_node_index, right_node_index)\\n        self.data = data\\n        self._build_tree(0, 0, len(data)-1)\\n\\n    def _left(self, index):\\n        return (index + 1) * 2 - 1\\n\\n    def _right(self, index):\\n        return (index + 1) * 2\\n\\n    def _build_tree(self, node_index, left_data_index, right_data_index):\\n        value = None\\n        if left_data_index == right_data_index:\\n            # (longest c, longest len, prefix c, prefix len, suffix c, suffix len)\\n            value = (\\n                self.data[left_data_index],\\n                1,\\n                self.data[left_data_index],\\n                1,\\n                self.data[left_data_index],\\n                1)\\n        else:\\n            left_node_index = self._left(node_index)\\n            right_node_index = self._right(node_index)\\n\\n            mid_data_index = (left_data_index + right_data_index) // 2\\n            (left_lc, left_ll, left_pc, left_pl, left_sc, left_sl) = self._build_tree(left_node_index, left_data_index, mid_data_index)\\n            (right_lc, right_ll, right_pc, right_pl, right_sc, right_sl) = self._build_tree(right_node_index, mid_data_index + 1, right_data_index)\\n            \\n            lc = ll = None\\n            if left_ll > right_ll:\\n                lc = left_lc\\n                ll = left_ll\\n            else:\\n                lc = right_lc\\n                ll = right_ll\\n            if left_sc == right_pc and left_sl + right_pl > ll:\\n                ll = left_sl + right_pl\\n                lc = left_sc\\n\\n            pc = left_pc\\n            pl = left_pl\\n            if left_pl == (mid_data_index - left_data_index + 1) and left_pc == right_pc:\\n                pl = left_pl + right_pl\\n\\n            sc = right_sc\\n            sl = right_sl\\n            if right_sl == (right_data_index - mid_data_index) and left_sc == right_sc:\\n                sl = left_sl + right_sl\\n    \\n            value = (lc, ll, pc, pl, sc, sl)\\n\\n        self.nodes[node_index] = value\\n        return value\\n\\n    def _update(self, node_index, data_index, update_value, left_data_index, right_data_index):\\n        value = self.nodes[node_index]\\n        mid_data_index = (left_data_index + right_data_index) // 2\\n        left_node_index = self._left(node_index)\\n        right_node_index = self._right(node_index)\\n\\n        new_value = None\\n        if left_data_index == right_data_index:\\n            new_value = (\\n                update_value,\\n                1,\\n                update_value,\\n                1,\\n                update_value,\\n                1)\\n        else:\\n            left_value = right_value = None\\n            if data_index <= mid_data_index:\\n                left_value = self._update(left_node_index, data_index, update_value, left_data_index, mid_data_index)\\n                right_value = self.nodes[right_node_index]\\n            else:\\n                left_value = self.nodes[left_node_index]\\n                right_value = self._update(right_node_index, data_index, update_value, mid_data_index + 1, right_data_index)\\n            (left_lc, left_ll, left_pc, left_pl, left_sc, left_sl) = left_value\\n            (right_lc, right_ll, right_pc, right_pl, right_sc, right_sl) = right_value\\n            \\n            lc = ll = None\\n            if left_ll > right_ll:\\n                lc = left_lc\\n                ll = left_ll\\n            else:\\n                lc = right_lc\\n                ll = right_ll\\n            if left_sc == right_pc and left_sl + right_pl > ll:\\n                ll = left_sl + right_pl\\n                lc = left_sc\\n\\n            pc = left_pc\\n            pl = left_pl\\n            if left_pl == (mid_data_index - left_data_index + 1) and left_pc == right_pc:\\n                pl = left_pl + right_pl\\n\\n            sc = right_sc\\n            sl = right_sl\\n            if right_sl == (right_data_index - mid_data_index) and left_sc == right_sc:\\n                sl = left_sl + right_sl\\n    \\n            new_value = (lc, ll, pc, pl, sc, sl)\\n        self.nodes[node_index] = new_value\\n        return new_value\\n\\n    def update(self, data_index, update_value):\\n        self.data[data_index] = update_value\\n        return self._update(0, data_index, update_value, 0, len(self.data)-1)\\n\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        st = SegmentTree(list(s))\\n        M = len(queryCharacters)\\n        ans = [0] * M\\n        for i in range(M):\\n            c = queryCharacters[i]\\n            p = queryIndices[i]\\n            st.update(p, c)\\n            ans[i] = st.nodes[0][1]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865584,
                "title": "c-segmenttree-o-nlogn",
                "content": "Another very typical range-merging problem. One possible solution is to use a segment tree. But I am too lazy to explain everything right now--the Google Kickstart round A starts very soon! XD\\n\\nSo I am going to paste my solution here, please feel free to use it if you need. Maybe I\\'ll get back and explain some details tomorrow.\\n``` c++\\nclass segmentTree {\\n   public:\\n    vector<char> lchar, rchar;\\n    vector<int> lmax, rmax, _max;\\n\\n    // 0-based\\n    segmentTree(string& a)\\n        : lchar(vector<char>((a.size() + 5) << 2)),\\n          rchar(vector<char>((a.size() + 5) << 2)),\\n          lmax(vector<int>((a.size() + 5) << 2)),\\n          rmax(vector<int>((a.size() + 5) << 2)),\\n          _max(vector<int>((a.size() + 5) << 2)) {\\n        build(0, a, 0, a.size() - 1);\\n    }\\n\\n    int lc(int o) { return 2 * o + 1; }\\n    int rc(int o) { return 2 * o + 2; }\\n\\n    void build(int o, string& a, int l, int r) {\\n        if (l == r) {\\n            lchar[o] = rchar[o] = a[l];\\n            lmax[o] = rmax[o] = _max[o] = 1;\\n        } else {\\n            int mid = (l + r) >> 1;\\n            build(lc(o), a, l, mid);\\n            build(rc(o), a, mid + 1, r);\\n            pushUp(o, l, r);\\n        }\\n    }\\n\\n    void pushUp(int o, int l, int r) {\\n        lchar[o] = lchar[lc(o)];\\n        rchar[o] = rchar[rc(o)];\\n        lmax[o] = lmax[lc(o)];\\n        rmax[o] = rmax[rc(o)];\\n        _max[o] = max(_max[lc(o)], _max[rc(o)]);\\n        int mid = (l + r) >> 1;\\n        if (rchar[lc(o)] == lchar[rc(o)]) {\\n            if (lmax[o] == mid - l + 1) lmax[o] += lmax[rc(o)];\\n            if (rmax[o] == r - (mid + 1) + 1) rmax[o] += rmax[lc(o)];\\n            _max[o] = max(_max[o], rmax[lc(o)] + lmax[rc(o)]);\\n        }\\n    }\\n\\n    void update(int o, int l, int r, int q, char k) {\\n        if (r < q || q < l) return;\\n        if (q <= l && r <= q) {\\n            lchar[o] = rchar[o] = k;\\n            lmax[o] = rmax[o] = _max[o] = 1;\\n            return;\\n        }\\n        int mid = (l + r) >> 1;\\n        update(lc(o), l, mid, q, k);\\n        update(rc(o), mid + 1, r, q, k);\\n        pushUp(o, l, r);\\n    }\\n};\\n\\nclass Solution {\\n   public:\\n    vector<int> longestRepeating(string s, string queryCharacters,\\n                                 vector<int>& queryIndices) {\\n        segmentTree st(s);\\n        int n = s.size();\\n        int q = queryCharacters.size();\\n        vector<int> res(q);\\n        for (int i = 0; i < q; i++) {\\n            st.update(0, 0, n - 1, queryIndices[i], queryCharacters[i]);\\n            res[i] = st._max[0];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "``` c++\\nclass segmentTree {\\n   public:\\n    vector<char> lchar, rchar;\\n    vector<int> lmax, rmax, _max;\\n\\n    // 0-based\\n    segmentTree(string& a)\\n        : lchar(vector<char>((a.size() + 5) << 2)),\\n          rchar(vector<char>((a.size() + 5) << 2)),\\n          lmax(vector<int>((a.size() + 5) << 2)),\\n          rmax(vector<int>((a.size() + 5) << 2)),\\n          _max(vector<int>((a.size() + 5) << 2)) {\\n        build(0, a, 0, a.size() - 1);\\n    }\\n\\n    int lc(int o) { return 2 * o + 1; }\\n    int rc(int o) { return 2 * o + 2; }\\n\\n    void build(int o, string& a, int l, int r) {\\n        if (l == r) {\\n            lchar[o] = rchar[o] = a[l];\\n            lmax[o] = rmax[o] = _max[o] = 1;\\n        } else {\\n            int mid = (l + r) >> 1;\\n            build(lc(o), a, l, mid);\\n            build(rc(o), a, mid + 1, r);\\n            pushUp(o, l, r);\\n        }\\n    }\\n\\n    void pushUp(int o, int l, int r) {\\n        lchar[o] = lchar[lc(o)];\\n        rchar[o] = rchar[rc(o)];\\n        lmax[o] = lmax[lc(o)];\\n        rmax[o] = rmax[rc(o)];\\n        _max[o] = max(_max[lc(o)], _max[rc(o)]);\\n        int mid = (l + r) >> 1;\\n        if (rchar[lc(o)] == lchar[rc(o)]) {\\n            if (lmax[o] == mid - l + 1) lmax[o] += lmax[rc(o)];\\n            if (rmax[o] == r - (mid + 1) + 1) rmax[o] += rmax[lc(o)];\\n            _max[o] = max(_max[o], rmax[lc(o)] + lmax[rc(o)]);\\n        }\\n    }\\n\\n    void update(int o, int l, int r, int q, char k) {\\n        if (r < q || q < l) return;\\n        if (q <= l && r <= q) {\\n            lchar[o] = rchar[o] = k;\\n            lmax[o] = rmax[o] = _max[o] = 1;\\n            return;\\n        }\\n        int mid = (l + r) >> 1;\\n        update(lc(o), l, mid, q, k);\\n        update(rc(o), mid + 1, r, q, k);\\n        pushUp(o, l, r);\\n    }\\n};\\n\\nclass Solution {\\n   public:\\n    vector<int> longestRepeating(string s, string queryCharacters,\\n                                 vector<int>& queryIndices) {\\n        segmentTree st(s);\\n        int n = s.size();\\n        int q = queryCharacters.size();\\n        vector<int> res(q);\\n        for (int i = 0; i < q; i++) {\\n            st.update(0, 0, n - 1, queryIndices[i], queryCharacters[i]);\\n            res[i] = st._max[0];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050693,
                "title": "c-segment-tree-clean-code",
                "content": "```\\nclass Solution {\\nprivate:\\n    struct Node {\\n        int max, size;\\n        int prefix_size, suffix_size;\\n        char prefix_char, suffix_char;\\n        Node(char ch) {\\n            max = size = 1;\\n            prefix_size = suffix_size = 1;\\n            prefix_char = suffix_char = ch;\\n        }\\n    };\\n    \\n    // segment tree\\n    string a;\\n    vector<Node> tree;\\n    \\n    Node merge_node(Node left, Node right) {\\n        Node ans(\\'a\\');\\n\\n        // merge prefix\\n        ans.prefix_size = left.prefix_size;\\n        if(left.prefix_size == left.size && left.prefix_char == right.prefix_char)\\n            ans.prefix_size = left.prefix_size + right.prefix_size;\\n        ans.prefix_char = left.prefix_char;\\n        \\n        // merge suffix\\n        ans.suffix_size = right.suffix_size;\\n        if(right.suffix_size == right.size && right.suffix_char == left.suffix_char)\\n            ans.suffix_size = right.suffix_size + left.suffix_size;\\n        ans.suffix_char = right.suffix_char;\\n        \\n        // size of this segment node\\n        ans.size = left.size + right.size;\\n        \\n        // max size\\n        int tmp = max(ans.suffix_size, ans.prefix_size);\\n        if(left.suffix_char == right.prefix_char)\\n            tmp = max(tmp, left.suffix_size + right.prefix_size);\\n        ans.max = max({left.max, right.max, tmp});\\n        \\n        return ans;\\n    }\\n    \\n    Node buildST(int i, int l, int r) {\\n        if(l == r) {\\n            Node node(a[l]);\\n            tree[i] = node;\\n            return tree[i];\\n        }\\n\\n        int mid = (l + r) / 2;\\n        Node left = buildST(2*i+1, l, mid);\\n        Node right = buildST(2*i+2, mid+1, r);\\n     \\n        return tree[i] = merge_node(left, right);\\n    }\\n    \\n    void update(int i, int sl, int sr, int pos, char ch) {\\n        if(sl == sr) { \\n            //update in the leaf node of the tree\\n            Node node(ch);\\n            tree[i] = node;\\n            return;\\n        }\\n\\n        int mid = (sl + sr) / 2;\\n        if(pos <= mid) \\n            update(2*i+1, sl, mid, pos, ch);\\n        else \\n            update(2*i+2, mid+1, sr, pos, ch);\\n\\n        //update intermediate nodes after returning the value of the leaf node\\n        tree[i] = merge_node(tree[2*i+1], tree[2*i+2]);      \\n    }\\n    \\n    \\npublic:\\n    vector<int> longestRepeating(string s, string qchars, vector<int>& qIndices) {\\n        int N = s.length();\\n        a = s;\\n        \\n        Node dummy(\\'a\\');\\n        tree.resize(4*N+5, dummy);\\n        \\n        // build segment tree\\n        // 0 indexing segment tree\\n        buildST(0, 0, N-1);\\n        \\n        // for(int i = 0; i < tree.size(); i++)\\n        //     cout << tree[i].max << endl;\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < qIndices.size(); i++) {\\n            int pos = qIndices[i];\\n            char ch = qchars[i];\\n            update(0, 0, N-1, pos, ch);\\n            \\n            // root of segment tree contains max count\\n            ans.push_back(tree[0].max);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    struct Node {\\n        int max, size;\\n        int prefix_size, suffix_size;\\n        char prefix_char, suffix_char;\\n        Node(char ch) {\\n            max = size = 1;\\n            prefix_size = suffix_size = 1;\\n            prefix_char = suffix_char = ch;\\n        }\\n    };\\n    \\n    // segment tree\\n    string a;\\n    vector<Node> tree;\\n    \\n    Node merge_node(Node left, Node right) {\\n        Node ans(\\'a\\');\\n\\n        // merge prefix\\n        ans.prefix_size = left.prefix_size;\\n        if(left.prefix_size == left.size && left.prefix_char == right.prefix_char)\\n            ans.prefix_size = left.prefix_size + right.prefix_size;\\n        ans.prefix_char = left.prefix_char;\\n        \\n        // merge suffix\\n        ans.suffix_size = right.suffix_size;\\n        if(right.suffix_size == right.size && right.suffix_char == left.suffix_char)\\n            ans.suffix_size = right.suffix_size + left.suffix_size;\\n        ans.suffix_char = right.suffix_char;\\n        \\n        // size of this segment node\\n        ans.size = left.size + right.size;\\n        \\n        // max size\\n        int tmp = max(ans.suffix_size, ans.prefix_size);\\n        if(left.suffix_char == right.prefix_char)\\n            tmp = max(tmp, left.suffix_size + right.prefix_size);\\n        ans.max = max({left.max, right.max, tmp});\\n        \\n        return ans;\\n    }\\n    \\n    Node buildST(int i, int l, int r) {\\n        if(l == r) {\\n            Node node(a[l]);\\n            tree[i] = node;\\n            return tree[i];\\n        }\\n\\n        int mid = (l + r) / 2;\\n        Node left = buildST(2*i+1, l, mid);\\n        Node right = buildST(2*i+2, mid+1, r);\\n     \\n        return tree[i] = merge_node(left, right);\\n    }\\n    \\n    void update(int i, int sl, int sr, int pos, char ch) {\\n        if(sl == sr) { \\n            //update in the leaf node of the tree\\n            Node node(ch);\\n            tree[i] = node;\\n            return;\\n        }\\n\\n        int mid = (sl + sr) / 2;\\n        if(pos <= mid) \\n            update(2*i+1, sl, mid, pos, ch);\\n        else \\n            update(2*i+2, mid+1, sr, pos, ch);\\n\\n        //update intermediate nodes after returning the value of the leaf node\\n        tree[i] = merge_node(tree[2*i+1], tree[2*i+2]);      \\n    }\\n    \\n    \\npublic:\\n    vector<int> longestRepeating(string s, string qchars, vector<int>& qIndices) {\\n        int N = s.length();\\n        a = s;\\n        \\n        Node dummy(\\'a\\');\\n        tree.resize(4*N+5, dummy);\\n        \\n        // build segment tree\\n        // 0 indexing segment tree\\n        buildST(0, 0, N-1);\\n        \\n        // for(int i = 0; i < tree.size(); i++)\\n        //     cout << tree[i].max << endl;\\n        \\n        vector<int> ans;\\n        for(int i = 0; i < qIndices.size(); i++) {\\n            int pos = qIndices[i];\\n            char ch = qchars[i];\\n            update(0, 0, N-1, pos, ch);\\n            \\n            // root of segment tree contains max count\\n            ans.push_back(tree[0].max);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1984589,
                "title": "java-segment-tree",
                "content": "```\\nclass Solution {\\n    class TreeNode {\\n        //range\\n        int start;\\n        int end;\\n        \\n        //conti left char\\n        char leftChar;\\n        int leftCharLen;\\n        \\n        //conti right char\\n        char rightChar;\\n        int rightCharLen;\\n        \\n        int max;\\n        \\n        TreeNode left;\\n        TreeNode right;\\n        \\n        TreeNode(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n            left = null;\\n            right = null;\\n        }\\n    }\\n\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        char[] sChar = s.toCharArray();\\n        char[] qChar = queryCharacters.toCharArray();\\n        \\n        TreeNode root = buildTree(sChar, 0, sChar.length - 1);\\n        \\n        int[] result = new int[qChar.length];\\n        \\n        for (int i = 0; i < qChar.length; i++) {\\n            updateTree(root, queryIndices[i], qChar[i]);\\n            result[i] = root.max;\\n        }\\n        return result;\\n    }\\n    \\n    private TreeNode buildTree(char[] s, int from, int to) {\\n        if (from > to) return null;\\n        TreeNode root = new TreeNode(from, to);\\n        if (from == to) {\\n            root.max = 1;\\n            root.rightChar = root.leftChar = s[from];\\n            root.leftCharLen = root.rightCharLen = 1;\\n            return root;\\n        }\\n        \\n        int middle = from + (to - from) / 2;\\n        \\n        root.left = buildTree(s, from, middle);\\n        root.right = buildTree(s, middle + 1, to);\\n        \\n        updateNode(root);\\n        return root;\\n        \\n    }\\n    \\n    private void updateTree(TreeNode root, int index, char c) {\\n        if (root == null || root.start > index || root.end < index) {\\n            return;\\n        }\\n        if (root.start == index && root.end == index) {\\n            root.leftChar = root.rightChar = c;\\n            return;\\n        }\\n        updateTree(root.left, index, c);\\n        updateTree(root.right, index, c);\\n        \\n        updateNode(root);\\n        \\n    }\\n    \\n    private void updateNode(TreeNode root) {\\n        if (root == null) return;\\n        root.leftChar = root.left.leftChar;\\n        root.leftCharLen = root.left.leftCharLen;\\n        root.rightChar = root.right.rightChar;\\n        root.rightCharLen = root.right.rightCharLen;\\n        root.max = Math.max(root.left.max, root.right.max);\\n        if (root.left.rightChar == root.right.leftChar) {\\n            int len = root.left.rightCharLen + root.right.leftCharLen;\\n            if (root.left.leftChar == root.left.rightChar && root.left.leftCharLen == root.left.end - root.left.start + 1) {\\n                root.leftCharLen = len;\\n            }\\n            if (root.right.leftChar == root.right.rightChar && root.right.leftCharLen == root.right.end - root.right.start + 1) {\\n                root.rightCharLen = len;\\n            }\\n            root.max = Math.max(root.max, len);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    class TreeNode {\\n        //range\\n        int start;\\n        int end;\\n        \\n        //conti left char\\n        char leftChar;\\n        int leftCharLen;\\n        \\n        //conti right char\\n        char rightChar;\\n        int rightCharLen;\\n        \\n        int max;\\n        \\n        TreeNode left;\\n        TreeNode right;\\n        \\n        TreeNode(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n            left = null;\\n            right = null;\\n        }\\n    }\\n\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        char[] sChar = s.toCharArray();\\n        char[] qChar = queryCharacters.toCharArray();\\n        \\n        TreeNode root = buildTree(sChar, 0, sChar.length - 1);\\n        \\n        int[] result = new int[qChar.length];\\n        \\n        for (int i = 0; i < qChar.length; i++) {\\n            updateTree(root, queryIndices[i], qChar[i]);\\n            result[i] = root.max;\\n        }\\n        return result;\\n    }\\n    \\n    private TreeNode buildTree(char[] s, int from, int to) {\\n        if (from > to) return null;\\n        TreeNode root = new TreeNode(from, to);\\n        if (from == to) {\\n            root.max = 1;\\n            root.rightChar = root.leftChar = s[from];\\n            root.leftCharLen = root.rightCharLen = 1;\\n            return root;\\n        }\\n        \\n        int middle = from + (to - from) / 2;\\n        \\n        root.left = buildTree(s, from, middle);\\n        root.right = buildTree(s, middle + 1, to);\\n        \\n        updateNode(root);\\n        return root;\\n        \\n    }\\n    \\n    private void updateTree(TreeNode root, int index, char c) {\\n        if (root == null || root.start > index || root.end < index) {\\n            return;\\n        }\\n        if (root.start == index && root.end == index) {\\n            root.leftChar = root.rightChar = c;\\n            return;\\n        }\\n        updateTree(root.left, index, c);\\n        updateTree(root.right, index, c);\\n        \\n        updateNode(root);\\n        \\n    }\\n    \\n    private void updateNode(TreeNode root) {\\n        if (root == null) return;\\n        root.leftChar = root.left.leftChar;\\n        root.leftCharLen = root.left.leftCharLen;\\n        root.rightChar = root.right.rightChar;\\n        root.rightCharLen = root.right.rightCharLen;\\n        root.max = Math.max(root.left.max, root.right.max);\\n        if (root.left.rightChar == root.right.leftChar) {\\n            int len = root.left.rightCharLen + root.right.leftCharLen;\\n            if (root.left.leftChar == root.left.rightChar && root.left.leftCharLen == root.left.end - root.left.start + 1) {\\n                root.leftCharLen = len;\\n            }\\n            if (root.right.leftChar == root.right.rightChar && root.right.leftCharLen == root.right.end - root.right.start + 1) {\\n                root.rightCharLen = len;\\n            }\\n            root.max = Math.max(root.max, len);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1929683,
                "title": "c-track-intervals-and-substring-lengths-using-sets",
                "content": "This problem requires one to modify and track the substring lengths efficiently. One idea is to make use of an ordered set (`std::set`) to track the left end of all intervals (add, delete, find target intervals), and another one (`std::multiset` or `std::map`) to track the lengths of all intervals.\\n\\nWe first store the intervals and lengths of the intervals to the sets. Then for each update, say, at index `i`, we first find the target interval `[a, b)` that contains `i`, split and merge the target and neighboring intervals, and update the length data and get the largest one after the current operation.\\n\\nThe initialization step is rather simple: we simply find all left ends of each substring and its length, and insert into the sets:\\n```\\n[Initialization]\\n       s  =  b  a  a  a  c  c\\nleft_end  :  0  1        4     6\\n\\nlength: 1,2,3\\n```\\nNote that by adding an end index (in this example, `6`), we can get the length of an interval with `*next(it) - *it` without suffering from edge cases.\\n\\nThe trickiest part of the implementation is the update step. For simplicity, we divide an update operation into the following parts:\\n1. Find the target interval `[a, b)` that contains the query index `i` (`a = *prev(intervals.upper_bound(i))`) and split the interval to parts: `left: [a, i), self: [i, i+1), right: [i+1,b)`, where `left` and `right` do not appear every time. Update the length data as well.\\n2. Merge `self` and the neighboring intervals if possible. Get the largest length afterwards.\\n\\nContinuing the above example, the following shows how each step is performed:\\n```\\n[Query]\\n   query  =              a\\n       s  =  b  a  a  a  c  c\\nleft_end  :  0  1        4     6\\n\\nlength: 1,2,3\\n\\n[Split]\\n   query  =              a\\n       s  =  b  a  a  a  a  c\\nleft_end  :  0  1        4  5  6\\n\\nlength: 1,1,1,3\\n\\n[Merge]\\n   query  =              a\\n       s  =  b  a  a  a  a  c\\nleft_end  :  0  1           5  6\\n\\nlength: 1,1,4\\n\\n=> largestLength = 4\\n```\\n\\nThe following is the C++ code for such solution. Given that the length of string is `n` and `q` queries are performed, the time complexity is `O(n log n + q log n)`, as we need `O(n log n)` time for initialization, and each query requires to insert/delete/find the elements to/from the ordered sets for a constant number of times, which is `O(log n)` time. The space complexity is `O(n)` for at most `n` intervals.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        multiset<int> ls; // ordered set of lengths of all intervals at present\\n        set<int> ins; // ordered set representing the left-ends of intervals\\n        int n = s.length();\\n        ins.insert(n); // allow us to get length of current interval by *next(it) - *it for all cases\\n        \\n        // initialize the ordered sets with the original string\\n        for (int i = 0, j = 1; i < n;) {\\n            while (j < n && s[j] == s[j-1]) ++j;\\n            ins.insert(i);\\n            ls.insert(j-i);\\n            i = j++;\\n        }\\n        \\n        // update the string and track the length of the longest substring \\n        // by merging/splitting intervals\\n        vector<int> ans;\\n        for (int i = 0; i < queryIndices.size(); ++i) {\\n            // If the querying character does not change the string:\\n            // do nothing for the sets\\n            if (queryCharacters[i] == s[queryIndices[i]]) {\\n                ans.push_back(*ls.rbegin());\\n                continue;\\n            }\\n            \\n            // update the ordered sets\\n            // 1. split the involved interval to parts: (left), self, (right)\\n            //    ins = 0     3     6\\n            //    s   = b b b c c c\\n            //  query :       b\\n            // => ins = 0     3 4   6  \\n            // => s   = b b b b c c\\n            \\n            // find the left-end of the target interval\\n            auto it = prev(ins.upper_bound(queryIndices[i])); // old/left interval\\n            int oldl = *next(it) - *it; // old interval length\\n            ls.erase(ls.find(oldl));\\n             \\n            ins.insert(queryIndices[i]); // self interval \\n            ins.insert(queryIndices[i] + 1); // right interval\\n            if (*it != queryIndices[i]) ls.insert(queryIndices[i] - *it); // left interval length\\n            ls.insert(1); // self interval length\\n            if (oldl - (queryIndices[i] - *it + 1)) ls.insert(oldl - (queryIndices[i] - *it + 1) ); //right interval length\\n            \\n            s[queryIndices[i]] = queryCharacters[i];\\n\\n            // 2. merge the adjacent intervals if the characters are identical\\n            //    ins = 0     3 4   6  \\n            //    s   = b b b b c c\\n            // => ins = 0       4   6\\n            \\n            it = ins.find(queryIndices[i]); // self interval\\n            // merge self and right\\n            if (queryIndices[i] + 1 < n && s[queryIndices[i]] == s[queryIndices[i] + 1]) {\\n                ls.erase(ls.find(*next(it, 2) - *next(it)));\\n                ls.erase(ls.find(1));\\n                ins.erase(next(it));\\n                ls.insert(*next(it) - *it);\\n            } \\n            // merge left and self\\n            if (it != ins.begin() && s[queryIndices[i]] == s[queryIndices[i] - 1]) {\\n                ls.erase(ls.find(*next(it) - *it) );\\n                ls.erase(ls.find(*it - *prev(it)) );\\n                ls.insert(*next(it) - *prev(it));\\n                ins.erase(it);\\n            }\\n            ans.push_back(*ls.rbegin());\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n[Initialization]\\n       s  =  b  a  a  a  c  c\\nleft_end  :  0  1        4     6\\n\\nlength: 1,2,3\\n```\n```\\n[Query]\\n   query  =              a\\n       s  =  b  a  a  a  c  c\\nleft_end  :  0  1        4     6\\n\\nlength: 1,2,3\\n\\n[Split]\\n   query  =              a\\n       s  =  b  a  a  a  a  c\\nleft_end  :  0  1        4  5  6\\n\\nlength: 1,1,1,3\\n\\n[Merge]\\n   query  =              a\\n       s  =  b  a  a  a  a  c\\nleft_end  :  0  1           5  6\\n\\nlength: 1,1,4\\n\\n=> largestLength = 4\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        multiset<int> ls; // ordered set of lengths of all intervals at present\\n        set<int> ins; // ordered set representing the left-ends of intervals\\n        int n = s.length();\\n        ins.insert(n); // allow us to get length of current interval by *next(it) - *it for all cases\\n        \\n        // initialize the ordered sets with the original string\\n        for (int i = 0, j = 1; i < n;) {\\n            while (j < n && s[j] == s[j-1]) ++j;\\n            ins.insert(i);\\n            ls.insert(j-i);\\n            i = j++;\\n        }\\n        \\n        // update the string and track the length of the longest substring \\n        // by merging/splitting intervals\\n        vector<int> ans;\\n        for (int i = 0; i < queryIndices.size(); ++i) {\\n            // If the querying character does not change the string:\\n            // do nothing for the sets\\n            if (queryCharacters[i] == s[queryIndices[i]]) {\\n                ans.push_back(*ls.rbegin());\\n                continue;\\n            }\\n            \\n            // update the ordered sets\\n            // 1. split the involved interval to parts: (left), self, (right)\\n            //    ins = 0     3     6\\n            //    s   = b b b c c c\\n            //  query :       b\\n            // => ins = 0     3 4   6  \\n            // => s   = b b b b c c\\n            \\n            // find the left-end of the target interval\\n            auto it = prev(ins.upper_bound(queryIndices[i])); // old/left interval\\n            int oldl = *next(it) - *it; // old interval length\\n            ls.erase(ls.find(oldl));\\n             \\n            ins.insert(queryIndices[i]); // self interval \\n            ins.insert(queryIndices[i] + 1); // right interval\\n            if (*it != queryIndices[i]) ls.insert(queryIndices[i] - *it); // left interval length\\n            ls.insert(1); // self interval length\\n            if (oldl - (queryIndices[i] - *it + 1)) ls.insert(oldl - (queryIndices[i] - *it + 1) ); //right interval length\\n            \\n            s[queryIndices[i]] = queryCharacters[i];\\n\\n            // 2. merge the adjacent intervals if the characters are identical\\n            //    ins = 0     3 4   6  \\n            //    s   = b b b b c c\\n            // => ins = 0       4   6\\n            \\n            it = ins.find(queryIndices[i]); // self interval\\n            // merge self and right\\n            if (queryIndices[i] + 1 < n && s[queryIndices[i]] == s[queryIndices[i] + 1]) {\\n                ls.erase(ls.find(*next(it, 2) - *next(it)));\\n                ls.erase(ls.find(1));\\n                ins.erase(next(it));\\n                ls.insert(*next(it) - *it);\\n            } \\n            // merge left and self\\n            if (it != ins.begin() && s[queryIndices[i]] == s[queryIndices[i] - 1]) {\\n                ls.erase(ls.find(*next(it) - *it) );\\n                ls.erase(ls.find(*it - *prev(it)) );\\n                ls.insert(*next(it) - *prev(it));\\n                ins.erase(it);\\n            }\\n            ans.push_back(*ls.rbegin());\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1871687,
                "title": "java-segment-tree",
                "content": "My **Segment Tree** solution below - it follows hints in the problem description.\\nCompare with my much more complex (and slower) [**TreeMap / TreeSet solution**](https://leetcode.com/problems/longest-substring-of-one-repeating-character/discuss/1867684/Java-or-O(n-log-n-%2B-k-log-n)-or-TreeSet-%2B-TreeMap-(no-segment-tree)-or-intervals-of-same-characters).\\nGood segment tree learning materials: https://cp-algorithms.com/data_structures/segment_tree.html\\n```\\nclass Solution {\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        int n= s.length(), k= queryIndices.length;\\n        SegmentTree st= new SegmentTree(s);\\n        int[] ans= new int[k];\\n        for(int i=0; i<k; i++){\\n            st.update(queryIndices[i], queryCharacters.charAt(i));\\n            ans[i]= st.rangeQuery(0, n-1).maxLen;\\n        }\\n        return ans;\\n    }\\n\\n    static class SegmentTree {\\n        int n;      // size of the original array\\n        char[] A;   // original array\\n        Node[] st;  // segment tree array\\n\\n        public SegmentTree(String s){\\n            this.A= s.toCharArray();\\n            this.n= A.length;\\n            this.st= new Node[4*n];\\n            build(1, 0, n-1);   // build recursively top-down (p==1 index of the tree root (top) node)\\n        }\\n    \\n        public Node rangeQuery(int i, int j){\\n            return rangeQuery(1, 0, n-1, i, j);      // traverse segment tree from the root\\n        }\\n    \\n        public void update(int i, char val){         // update single element\\'s value\\n            update(1, 0, n-1, i, i, val);\\n        }\\n\\n        static class Node{         // represents a substring of original string\\n            int maxLen;            // max length of same character in node\\'s string\\n            boolean mono;          // true if node\\'s string consists of the same character\\n            char cPref, cSuff;     // character of the prefix / suffix\\n            int lenPref, lenSuff;  // length of prefix / suffix\\n    \\n            Node(char c, int len){\\n                this.mono= true;\\n                this.cPref= this.cSuff= c;\\n                this.maxLen= this.lenPref= this.lenSuff= len;\\n            }\\n    \\n            Node(int maxLen, char cPref, int lenPref, char cSuff, int lenSuff){\\n                this.mono= false;\\n                this.maxLen= maxLen;\\n                this.cPref= cPref;\\n                this.lenPref= lenPref;\\n                this.cSuff= cSuff;\\n                this.lenSuff= lenSuff;\\n            }\\n\\t\\t\\t\\n            static Node merge(Node l, Node r){\\n                if(l==null) return r;\\n                if(r==null) return l;\\n                if(l.cSuff!=r.cPref) return new Node(Math.max(l.maxLen, r.maxLen), l.cPref, l.lenPref, r.cSuff, r.lenSuff);\\n                if(l.mono && r.mono) return new Node(l.cPref, l.maxLen + r.maxLen);\\n                if(l.mono)           return new Node(Math.max(l.maxLen+r.lenPref, r.maxLen), l.cPref, l.maxLen+r.lenPref, r.cSuff, r.lenSuff);\\n                if(r.mono)           return new Node(Math.max(l.maxLen, l.lenSuff+r.maxLen), l.cPref, l.lenPref, r.cSuff, l.lenSuff+r.maxLen);\\n                return new Node(Math.max(l.lenSuff+r.lenPref, Math.max(l.maxLen, r.maxLen)), l.cPref, l.lenPref, r.cSuff, r.lenSuff);\\n            }  \\t\\n        }\\n\\n        void build(int p, int L, int R){\\n            if(L==R){\\n                st[p]= new Node(A[L], 1);\\n            }else{\\n                int m= (L+R)/2, lp= (p<<1), rp= lp+1;\\n                build(lp, L, m);\\n                build(rp, m+1, R);\\n                st[p]= Node.merge(st[lp], st[rp]); \\n            }\\n        }        \\n        \\n        void update(int p, int L, int R, int i, int j, char val){\\n            if(i>j) return;\\n            if((L>=i) && (R<=j)){\\n                st[p]= new Node(A[i]= val, 1);\\n            }else{\\n                int m= (L+R)/2, lp= p*2, rp= lp+1;\\n                update(lp, L, m, i, Math.min(m,j), val);\\n                update(rp, m+1, R, Math.max(i,m+1), j, val);\\n                st[p]= Node.merge(st[lp], st[rp]);\\n            }\\n        }\\n\\n        Node rangeQuery(int p, int L, int R, int i, int j){\\n            if(i>j) return null;\\n            if((L>=i) && (R<=j)) return st[p];        // found the segment\\n            int m= (L+R)/2, lp= p*2, rp= lp+1;\\n            return Node.merge(rangeQuery(lp, L, m, i, Math.min(m,j)),\\n                              rangeQuery(rp, m+1, R, Math.max(i, m+1), j));\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Tree"
                ],
                "code": "class Solution {\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        int n= s.length(), k= queryIndices.length;\\n        SegmentTree st= new SegmentTree(s);\\n        int[] ans= new int[k];\\n        for(int i=0; i<k; i++){\\n            st.update(queryIndices[i], queryCharacters.charAt(i));\\n            ans[i]= st.rangeQuery(0, n-1).maxLen;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1869499,
                "title": "c-segment-tree-with-lazy-propagation-intuitive-explanation",
                "content": "Look at the problem again. \\nWhat would happen If you replace a character at a particular position: either\\n1. Nothing to change, or\\n2. split a substring of repeating character into two or three substrings, or\\n3. increase 1 to the lenth of left substring or right substring. Or merge left and right substring into a substring of repeating characters.\\n\\nLet us assume that we know the range of the substring at each position in which the current character belongs to. For example, \\'aabbdbb\\', we know[[0,1], [0, 1], [2,3],[2,3],[4,4],[5,6],[5,6]]. \\nSo, when we change at any position, we just need to know the ranges at current position as well as its left & right position.  After that, we have to update the ranges at all positions which are affected by the change we made. \\n\\nFrom this intuition, we can think of a segment tree which node contains the range. Then we need to do point-query followed by updating the positions using range-update with lazy propagation.\\n\\nI am too lazy to clean my codes. Feel free to share your clean & concise codes.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    const int mxn = 1e5 +1;\\n    struct segtree\\n    {\\n        bool lazy_flag = false;\\n        int left_index, right_index, mxvalue = 0;\\n        segtree()\\n        {\\n            lazy_flag = false;\\n            left_index = -1;\\n            right_index = -1;\\n            mxvalue = 0;\\n        }\\n    } tree[4*100000+4];\\n    \\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        int l = 0, r = 0;\\n        memset(tree, 0, sizeof(tree));\\n        while( r < s.size())\\n        {\\n            if(s[l]==s[r]) r++;\\n            else\\n            {\\n                update(1, 0, s.size()-1, l, r-1, {l, r-1});\\n                l = r;\\n            }\\n        }\\n        update(1, 0, s.size()-1, l, r-1, {l, r-1});\\n        vector<int> ans;\\n   \\n        for(int i = 0; i < queryIndices.size(); i++)\\n        {\\n\\n            if(s[queryIndices[i]] == queryCharacters[i]) ans.push_back(tree[1].mxvalue);\\n            else\\n            {\\n                pair<int, int> pp = point_query(1, 0, s.size()-1, queryIndices[i]);\\n\\n                if(pp.first == pp.second)\\n                {\\n                    int ret = 0;\\n                    if(queryIndices[i]-1 >= 0 && s[queryIndices[i]-1] == queryCharacters[i] && queryIndices[i]+1 < s.size() && s[queryIndices[i]+1] == queryCharacters[i] )\\n                    {\\n                        \\n                        pair<int, int> pp1 = point_query(1, 0, s.size()-1, queryIndices[i]-1);\\n                        pair<int, int> pp2 = point_query(1, 0, s.size()-1, queryIndices[i]+1);\\n                        \\n                        ret = max(ret, update(1, 0, s.size()-1, pp1.first, pp2.second, {pp1.first, pp2.second}));\\n\\n                    }\\n                    else if( queryIndices[i]-1 >= 0 && s[queryIndices[i]-1] == queryCharacters[i])\\n                    {\\n                       \\n                        pair<int, int> pp = point_query(1, 0, s.size()-1, queryIndices[i]-1);\\n                        \\n                        ret = max(ret, update(1, 0, s.size()-1, pp.first, queryIndices[i], {pp.first, queryIndices[i]}));\\n     \\n                    }\\n                    else if(queryIndices[i]+1 < s.size() && s[queryIndices[i]+1] == queryCharacters[i])\\n                    {\\n                        \\n                        pair<int, int> pp = point_query(1, 0, s.size()-1, queryIndices[i]+1);\\n                       \\n                        ret = max(ret, update(1, 0, s.size()-1,queryIndices[i], pp.second, {queryIndices[i], pp.second}));\\n                    }\\n                    else\\n                    {\\n                        ret = max(ret, update(1, 0, s.size()-1,queryIndices[i], queryIndices[i], {queryIndices[i], queryIndices[i]}));\\n                    }\\n                    ans.push_back(ret);\\n                }\\n                else\\n                {\\n                    update(1, 0, s.size()-1, pp.first, queryIndices[i]-1, {pp.first, queryIndices[i]-1});\\n                    update(1, 0, s.size()-1,queryIndices[i], queryIndices[i], {queryIndices[i], queryIndices[i]});\\n                    int ret = update(1, 0, s.size()-1, queryIndices[i]+ 1, pp.second, {queryIndices[i]+1, pp.second});\\n                    \\n                    if( queryIndices[i]-1 >= 0 && s[queryIndices[i]-1] == queryCharacters[i])\\n                    {\\n                      \\n                        pair<int, int> pp = point_query(1, 0, s.size()-1, queryIndices[i]-1);\\n            \\n                        ret = max(ret, update(1, 0, s.size()-1, pp.first, queryIndices[i], {pp.first, queryIndices[i]}));\\n                        \\n                    }\\n                    else if(queryIndices[i]+1 < s.size() && s[queryIndices[i]+1] == queryCharacters[i])\\n                    {\\n                        pair<int, int> pp = point_query(1, 0, s.size()-1, queryIndices[i]+1);\\n                        ret = max(ret, update(1, 0, s.size()-1,queryIndices[i], pp.second, {queryIndices[i], pp.second}));\\n                    }\\n                    else\\n                    {\\n                        ret = max(ret, update(1, 0, s.size()-1,queryIndices[i], queryIndices[i], {queryIndices[i], queryIndices[i]}));\\n                    }\\n                    ans.push_back(ret);  \\n                }\\n                \\n            }\\n            s[queryIndices[i]] = queryCharacters[i];\\n        }\\n        return ans;\\n        \\n        \\n    }\\n    void updateChild(int node, pair<int, int> val)\\n    {\\n        tree[node*2].left_index = val.first;\\n        tree[node*2].right_index = val.second;\\n        tree[node*2].lazy_flag = true;\\n        tree[node*2].mxvalue = val.second - val.first + 1;\\n        \\n        tree[node*2+1].left_index = val.first;\\n        tree[node*2+1].right_index = val.second;\\n        tree[node*2+1].lazy_flag = true;\\n        tree[node*2+1].mxvalue = val.second - val.first + 1;\\n        tree[node].lazy_flag = false;\\n        return;\\n    }\\n    int update(int node, int beg, int end, int l, int r, pair<int, int> val)\\n    {\\n\\n        if(l > r) return 0;\\n        if(beg==l && end==r)\\n        {\\n            tree[node].lazy_flag = true;\\n            tree[node].left_index= val.first, tree[node].right_index = val.second;\\n            tree[node].mxvalue = tree[node].right_index - tree[node].left_index + 1;\\n            return tree[node].mxvalue;\\n        }\\n        if(tree[node].lazy_flag)\\n        {\\n            updateChild(node, val);\\n        }\\n        int mid = (beg+end)/2;\\n        int lret = update(node*2, beg, mid, l, min(mid, r), val);\\n        int rret = update(node*2+1, mid+1, end, max(l, mid+1), r, val);\\n        tree[node].mxvalue = max(tree[node*2].mxvalue, tree[node*2+1].mxvalue);\\n        tree[node].lazy_flag = false;\\n        return tree[node].mxvalue;\\n    }\\n    \\n    pair<int, int> point_query(int node, int beg, int end, int ind)\\n    {\\n\\n        if(beg==ind && end==ind) return {tree[node].left_index, tree[node].right_index};\\n        int mid = (beg+end) >> 1;\\n        if(tree[node].lazy_flag)\\n        {\\n            updateChild(node, {tree[node].left_index, tree[node].right_index});\\n        }\\n        if(ind <= mid) return point_query(node*2, beg, mid, ind);\\n        else return point_query(node*2 + 1, mid+1, end, ind);\\n    }\\n    \\n    \\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mxn = 1e5 +1;\\n    struct segtree\\n    {\\n        bool lazy_flag = false;\\n        int left_index, right_index, mxvalue = 0;\\n        segtree()\\n        {\\n            lazy_flag = false;\\n            left_index = -1;\\n            right_index = -1;\\n            mxvalue = 0;\\n        }\\n    } tree[4*100000+4];\\n    \\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        int l = 0, r = 0;\\n        memset(tree, 0, sizeof(tree));\\n        while( r < s.size())\\n        {\\n            if(s[l]==s[r]) r++;\\n            else\\n            {\\n                update(1, 0, s.size()-1, l, r-1, {l, r-1});\\n                l = r;\\n            }\\n        }\\n        update(1, 0, s.size()-1, l, r-1, {l, r-1});\\n        vector<int> ans;\\n   \\n        for(int i = 0; i < queryIndices.size(); i++)\\n        {\\n\\n            if(s[queryIndices[i]] == queryCharacters[i]) ans.push_back(tree[1].mxvalue);\\n            else\\n            {\\n                pair<int, int> pp = point_query(1, 0, s.size()-1, queryIndices[i]);\\n\\n                if(pp.first == pp.second)\\n                {\\n                    int ret = 0;\\n                    if(queryIndices[i]-1 >= 0 && s[queryIndices[i]-1] == queryCharacters[i] && queryIndices[i]+1 < s.size() && s[queryIndices[i]+1] == queryCharacters[i] )\\n                    {\\n                        \\n                        pair<int, int> pp1 = point_query(1, 0, s.size()-1, queryIndices[i]-1);\\n                        pair<int, int> pp2 = point_query(1, 0, s.size()-1, queryIndices[i]+1);\\n                        \\n                        ret = max(ret, update(1, 0, s.size()-1, pp1.first, pp2.second, {pp1.first, pp2.second}));\\n\\n                    }\\n                    else if( queryIndices[i]-1 >= 0 && s[queryIndices[i]-1] == queryCharacters[i])\\n                    {\\n                       \\n                        pair<int, int> pp = point_query(1, 0, s.size()-1, queryIndices[i]-1);\\n                        \\n                        ret = max(ret, update(1, 0, s.size()-1, pp.first, queryIndices[i], {pp.first, queryIndices[i]}));\\n     \\n                    }\\n                    else if(queryIndices[i]+1 < s.size() && s[queryIndices[i]+1] == queryCharacters[i])\\n                    {\\n                        \\n                        pair<int, int> pp = point_query(1, 0, s.size()-1, queryIndices[i]+1);\\n                       \\n                        ret = max(ret, update(1, 0, s.size()-1,queryIndices[i], pp.second, {queryIndices[i], pp.second}));\\n                    }\\n                    else\\n                    {\\n                        ret = max(ret, update(1, 0, s.size()-1,queryIndices[i], queryIndices[i], {queryIndices[i], queryIndices[i]}));\\n                    }\\n                    ans.push_back(ret);\\n                }\\n                else\\n                {\\n                    update(1, 0, s.size()-1, pp.first, queryIndices[i]-1, {pp.first, queryIndices[i]-1});\\n                    update(1, 0, s.size()-1,queryIndices[i], queryIndices[i], {queryIndices[i], queryIndices[i]});\\n                    int ret = update(1, 0, s.size()-1, queryIndices[i]+ 1, pp.second, {queryIndices[i]+1, pp.second});\\n                    \\n                    if( queryIndices[i]-1 >= 0 && s[queryIndices[i]-1] == queryCharacters[i])\\n                    {\\n                      \\n                        pair<int, int> pp = point_query(1, 0, s.size()-1, queryIndices[i]-1);\\n            \\n                        ret = max(ret, update(1, 0, s.size()-1, pp.first, queryIndices[i], {pp.first, queryIndices[i]}));\\n                        \\n                    }\\n                    else if(queryIndices[i]+1 < s.size() && s[queryIndices[i]+1] == queryCharacters[i])\\n                    {\\n                        pair<int, int> pp = point_query(1, 0, s.size()-1, queryIndices[i]+1);\\n                        ret = max(ret, update(1, 0, s.size()-1,queryIndices[i], pp.second, {queryIndices[i], pp.second}));\\n                    }\\n                    else\\n                    {\\n                        ret = max(ret, update(1, 0, s.size()-1,queryIndices[i], queryIndices[i], {queryIndices[i], queryIndices[i]}));\\n                    }\\n                    ans.push_back(ret);  \\n                }\\n                \\n            }\\n            s[queryIndices[i]] = queryCharacters[i];\\n        }\\n        return ans;\\n        \\n        \\n    }\\n    void updateChild(int node, pair<int, int> val)\\n    {\\n        tree[node*2].left_index = val.first;\\n        tree[node*2].right_index = val.second;\\n        tree[node*2].lazy_flag = true;\\n        tree[node*2].mxvalue = val.second - val.first + 1;\\n        \\n        tree[node*2+1].left_index = val.first;\\n        tree[node*2+1].right_index = val.second;\\n        tree[node*2+1].lazy_flag = true;\\n        tree[node*2+1].mxvalue = val.second - val.first + 1;\\n        tree[node].lazy_flag = false;\\n        return;\\n    }\\n    int update(int node, int beg, int end, int l, int r, pair<int, int> val)\\n    {\\n\\n        if(l > r) return 0;\\n        if(beg==l && end==r)\\n        {\\n            tree[node].lazy_flag = true;\\n            tree[node].left_index= val.first, tree[node].right_index = val.second;\\n            tree[node].mxvalue = tree[node].right_index - tree[node].left_index + 1;\\n            return tree[node].mxvalue;\\n        }\\n        if(tree[node].lazy_flag)\\n        {\\n            updateChild(node, val);\\n        }\\n        int mid = (beg+end)/2;\\n        int lret = update(node*2, beg, mid, l, min(mid, r), val);\\n        int rret = update(node*2+1, mid+1, end, max(l, mid+1), r, val);\\n        tree[node].mxvalue = max(tree[node*2].mxvalue, tree[node*2+1].mxvalue);\\n        tree[node].lazy_flag = false;\\n        return tree[node].mxvalue;\\n    }\\n    \\n    pair<int, int> point_query(int node, int beg, int end, int ind)\\n    {\\n\\n        if(beg==ind && end==ind) return {tree[node].left_index, tree[node].right_index};\\n        int mid = (beg+end) >> 1;\\n        if(tree[node].lazy_flag)\\n        {\\n            updateChild(node, {tree[node].left_index, tree[node].right_index});\\n        }\\n        if(ind <= mid) return point_query(node*2, beg, mid, ind);\\n        else return point_query(node*2 + 1, mid+1, end, ind);\\n    }\\n    \\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866767,
                "title": "c-segment-tree-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> t; //best, llen, rlen;\\n    void combine(int tl, int tm, int tr, vector<int> const& a, vector<int> const& b, vector<int> &c, string const& s){\\n        if(s[tm] == s[tm+1]){\\n            c[0] = max({a[0], b[0], a[2] + b[1]});\\n            if(a[1] == tm-tl+1) c[1] = a[1] + b[1];\\n            else c[1] = a[1];\\n            if(b[2] == tr-tm) c[2] = a[2] + b[2];\\n            else c[2] = b[2];\\n        }\\n        \\n        else{\\n            c[0] = max({a[0], b[0]});\\n            c[1] = a[1];\\n            c[2] = b[2];\\n        }\\n    }\\n    \\n    void build(string &s, int v, int tl, int tr){\\n        if(tl == tr) t[v] = vector<int>({1, 1, 1});\\n        else{\\n            int tm = (tl + tr)/2;\\n            build(s, v*2, tl, tm);\\n            build(s, v*2+1, tm+1, tr);\\n            \\n            combine(tl, tm, tr, t[v*2], t[v*2+1], t[v], s);\\n        }\\n        \\n        // cout << tl << \\' \\' << tr << \\' \\' << t[v][0] << \\'\\\\n\\';\\n    }\\n    \\n    inline int query(){\\n        return t[1][0];\\n    }\\n    \\n    void update(int v, int tl, int tr, int pos, string &s){\\n        if(tl == tr) return;\\n        int tm = (tl+tr)/2;\\n        if(pos <= tm) update(v*2, tl, tm, pos, s);\\n        else update(v*2+1, tm+1, tr, pos, s);\\n        \\n        combine(tl, tm, tr, t[v*2], t[v*2+1], t[v], s);\\n    }\\n    \\n    vector<int> longestRepeating(string s, string qC, vector<int>& qI) {\\n        \\n        int n = s.length();\\n        t = vector<vector<int>>(4*(n+10)+2, vector<int>(3));//best, llen, rlen;\\n        \\n        build(s, 1, 0, n-1);\\n        int m = qC.size();\\n        \\n        vector<int> ans;\\n        for(int i=0; i<m; i++){\\n            s[qI[i]] = qC[i];\\n            update(1, 0, n-1, qI[i], s);\\n            ans.push_back(query());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> t; //best, llen, rlen;\\n    void combine(int tl, int tm, int tr, vector<int> const& a, vector<int> const& b, vector<int> &c, string const& s){\\n        if(s[tm] == s[tm+1]){\\n            c[0] = max({a[0], b[0], a[2] + b[1]});\\n            if(a[1] == tm-tl+1) c[1] = a[1] + b[1];\\n            else c[1] = a[1];\\n            if(b[2] == tr-tm) c[2] = a[2] + b[2];\\n            else c[2] = b[2];\\n        }\\n        \\n        else{\\n            c[0] = max({a[0], b[0]});\\n            c[1] = a[1];\\n            c[2] = b[2];\\n        }\\n    }\\n    \\n    void build(string &s, int v, int tl, int tr){\\n        if(tl == tr) t[v] = vector<int>({1, 1, 1});\\n        else{\\n            int tm = (tl + tr)/2;\\n            build(s, v*2, tl, tm);\\n            build(s, v*2+1, tm+1, tr);\\n            \\n            combine(tl, tm, tr, t[v*2], t[v*2+1], t[v], s);\\n        }\\n        \\n        // cout << tl << \\' \\' << tr << \\' \\' << t[v][0] << \\'\\\\n\\';\\n    }\\n    \\n    inline int query(){\\n        return t[1][0];\\n    }\\n    \\n    void update(int v, int tl, int tr, int pos, string &s){\\n        if(tl == tr) return;\\n        int tm = (tl+tr)/2;\\n        if(pos <= tm) update(v*2, tl, tm, pos, s);\\n        else update(v*2+1, tm+1, tr, pos, s);\\n        \\n        combine(tl, tm, tr, t[v*2], t[v*2+1], t[v], s);\\n    }\\n    \\n    vector<int> longestRepeating(string s, string qC, vector<int>& qI) {\\n        \\n        int n = s.length();\\n        t = vector<vector<int>>(4*(n+10)+2, vector<int>(3));//best, llen, rlen;\\n        \\n        build(s, 1, 0, n-1);\\n        int m = qC.size();\\n        \\n        vector<int> ans;\\n        for(int i=0; i<m; i++){\\n            s[qI[i]] = qC[i];\\n            update(1, 0, n-1, qI[i], s);\\n            ans.push_back(query());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1866030,
                "title": "c-bottom-up-segment-tree",
                "content": "```cpp\\n#define FOR(i, a, b) for (long i = (a); i < (b); i++)\\n#define REP(i, n) for (long i = 0; i < (n); i++)\\n#define ROF(i, a, b) for (long i = (b); --i >= (a); )\\n\\nclass Solution {\\n  int nn;\\n  string s;\\n  struct Seg {int lc, mc, rc; };\\n  vector<Seg> seg;\\n\\n  void mconcat(int i, int k) {\\n    int p = i>>1;\\n    i &= ~1;\\n    seg[p].lc = seg[i].lc;\\n    seg[p].rc = seg[i^1].rc;\\n    seg[p].mc = max(seg[i].mc, seg[i^1].mc);\\n    int mid = (i^1)*k-nn;\\n    if (s[mid-1] == s[mid]) {\\n      if (seg[p].lc == k) seg[p].lc += seg[i^1].lc;\\n      if (seg[p].rc == k) seg[p].rc += seg[i].rc;\\n      seg[p].mc = max(seg[p].mc, seg[i].rc+seg[i^1].lc);\\n    }\\n  }\\npublic:\\n  vector<int> longestRepeating(string s_, string modc, vector<int>& modi) {\\n    int n = s_.size(), ln = n == 1 ? 0 : 32-__builtin_clz(n-1);\\n    nn = 1 << ln;\\n    vector<int> ret(modc.size());\\n    seg.resize(2*nn);\\n    s = move(s_);\\n    s.resize(nn);\\n    FOR(i, nn, nn+n)\\n      seg[i].lc = seg[i].mc = seg[i].rc = 1;\\n    if (nn > 1) {\\n      for (int i = nn; i < nn+n; i += 2) mconcat(i, 1);\\n      ROF(i, 2, nn) mconcat(i, 1 << __builtin_clz(i)-__builtin_clz(nn));\\n    }\\n    REP(i, modc.size()) {\\n      s[modi[i]] = modc[i];\\n      int x = nn+modi[i];\\n      for (int k = 1; x > 1; x >>= 1, k <<= 1)\\n        mconcat(x, k);\\n      ret[i] = seg[1].mc;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n#define FOR(i, a, b) for (long i = (a); i < (b); i++)\\n#define REP(i, n) for (long i = 0; i < (n); i++)\\n#define ROF(i, a, b) for (long i = (b); --i >= (a); )\\n\\nclass Solution {\\n  int nn;\\n  string s;\\n  struct Seg {int lc, mc, rc; };\\n  vector<Seg> seg;\\n\\n  void mconcat(int i, int k) {\\n    int p = i>>1;\\n    i &= ~1;\\n    seg[p].lc = seg[i].lc;\\n    seg[p].rc = seg[i^1].rc;\\n    seg[p].mc = max(seg[i].mc, seg[i^1].mc);\\n    int mid = (i^1)*k-nn;\\n    if (s[mid-1] == s[mid]) {\\n      if (seg[p].lc == k) seg[p].lc += seg[i^1].lc;\\n      if (seg[p].rc == k) seg[p].rc += seg[i].rc;\\n      seg[p].mc = max(seg[p].mc, seg[i].rc+seg[i^1].lc);\\n    }\\n  }\\npublic:\\n  vector<int> longestRepeating(string s_, string modc, vector<int>& modi) {\\n    int n = s_.size(), ln = n == 1 ? 0 : 32-__builtin_clz(n-1);\\n    nn = 1 << ln;\\n    vector<int> ret(modc.size());\\n    seg.resize(2*nn);\\n    s = move(s_);\\n    s.resize(nn);\\n    FOR(i, nn, nn+n)\\n      seg[i].lc = seg[i].mc = seg[i].rc = 1;\\n    if (nn > 1) {\\n      for (int i = nn; i < nn+n; i += 2) mconcat(i, 1);\\n      ROF(i, 2, nn) mconcat(i, 1 << __builtin_clz(i)-__builtin_clz(nn));\\n    }\\n    REP(i, modc.size()) {\\n      s[modi[i]] = modc[i];\\n      int x = nn+modi[i];\\n      for (int k = 1; x > 1; x >>= 1, k <<= 1)\\n        mconcat(x, k);\\n      ret[i] = seg[1].mc;\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865695,
                "title": "c-segment-tree-solution-using-atcoder-library",
                "content": "We maintain the left character, right character, left length, right length, middle length, interval length of each interval. With this information, we can easily merge intervals and do range queries.\\nFor more information on how to use segment tree in atcoder library, read [here](https://github.com/atcoder/ac-library/blob/master/document_en/segtree.md).\\n```\\nnamespace internal {\\n\\n// @param n `0 <= n`\\n// @return minimum non-negative `x` s.t. `n <= 2**x`\\nint ceil_pow2(int n) {\\n    int x = 0;\\n    while((1U << x) < (unsigned int)(n))\\n    \\tx++;\\n    return x;\\n}\\n\\n} // namespace internal\\n\\n// Source: ac-library/atcoder/segtree.hpp\\ntemplate<class T, T (*unit)(), T (*op)(T, T)>\\nclass segtree {\\npublic:\\n\\tsegtree() : segtree(0) {}\\n\\n\\tsegtree(int _n) : segtree(std::vector<T>(_n, unit())) {}\\n\\t\\n\\tsegtree(const std::vector<T>& arr): n(int(arr.size())) {\\n\\t\\tlog = internal::ceil_pow2(n);\\n\\t\\tsize = 1 << log;\\n\\t\\tst.resize(size << 1, unit());\\n\\t\\tfor(int i = 0; i < n; ++i)\\n\\t\\t\\tst[size + i] = arr[i];\\n\\t\\tfor(int i = size - 1; i; --i)\\n\\t\\t\\tupdate(i);\\n\\t}\\n\\t\\n\\tvoid set(int p, T val) {\\n\\t\\tassert(0 <= p && p < n);\\n\\t\\tp += size;\\n\\t\\tst[p] = val;\\n\\t\\tfor(int i = 1; i <= log; ++i)\\n\\t\\t\\tupdate(p >> i);\\n\\t}\\n\\n\\tinline T get(int p) const {\\n\\t\\tassert(0 <= p && p < n);\\n\\t\\treturn st[p + size];\\n\\t}\\n\\n\\tinline T operator[](int p) const {\\n\\t\\treturn get(p);\\n\\t}\\n\\t\\n\\tT prod(int l, int r) const {\\n\\t\\tassert(0 <= l && l <= r && r <= n);\\n\\t\\tT ans_left = unit(), ans_right = unit();\\n\\t\\tl += size;\\n\\t\\tr += size;\\n\\t\\twhile(l < r) {\\n\\t\\t\\tif(l & 1)\\n\\t\\t\\t\\tans_left = op(ans_left, st[l++]);\\n\\t\\t\\tif(r & 1)\\n\\t\\t\\t\\tans_right = op(st[--r], ans_right);\\n\\t\\t\\tl >>= 1;\\n\\t\\t\\tr >>= 1;\\n\\t\\t}\\n\\t\\treturn op(ans_left, ans_right);\\n\\t}\\n\\n\\tinline T all_prod() const { return st[1]; }\\n\\n\\ttemplate<bool (*f)(T)> int max_right(int l) const {\\n\\t\\treturn max_right(l, [](T x) { return f(x); });\\n\\t}\\n\\n\\ttemplate<class F> int max_right(int l, F f) const {\\n\\t\\tassert(0 <= l && l <= n);\\n\\t\\tassert(f(unit()));\\n\\t\\tif(l == n)\\n\\t\\t\\treturn n;\\n\\t\\tl += size;\\n\\t\\tT sm = unit();\\n\\t\\tdo {\\n\\t\\t\\twhile(l & 1 ^ 1)\\n\\t\\t\\t\\tl >>= 1;\\n\\t\\t\\tif(!f(op(sm, st[l]))) {\\n\\t\\t\\t\\twhile(l < size) {\\n\\t\\t\\t\\t\\tl <<= 1;\\n\\t\\t\\t\\t\\tif(f(op(sm, st[l]))) {\\n\\t\\t\\t\\t\\t\\tsm = op(sm, st[l]);\\n\\t\\t\\t\\t\\t\\tl++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn l - size;\\n\\t\\t\\t}\\n\\t\\t\\tsm = op(sm, st[l]);\\n\\t\\t\\tl++;\\n\\t\\t} while((l & -l) != l);\\n\\t\\treturn n;\\n\\t}\\n\\n\\ttemplate<bool (*f)(T)> int min_left(int r) const {\\n\\t\\treturn min_left(r, [](T x) { return f(x); });\\n\\t}\\n\\n\\ttemplate<class F> int min_left(int r, F f) const {\\n\\t\\tassert(0 <= r && r <= n);\\n\\t\\tassert(f(unit()));\\n\\t\\tif(r == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tr += size;\\n\\t\\tT sm = unit();\\n\\t\\tdo {\\n\\t\\t\\tr--;\\n\\t\\t\\twhile(r > 1 && (r & 1))\\n\\t\\t\\t\\tr >>= 1;\\n\\t\\t\\tif(!f(op(st[r], sm))) {\\n\\t\\t\\t\\twhile(r < size) {\\n\\t\\t\\t\\t\\tr = r << 1 | 1;\\n\\t\\t\\t\\t\\tif(f(op(st[r], sm))) {\\n\\t\\t\\t\\t\\t\\tsm = op(st[r], sm);\\n\\t\\t\\t\\t\\t\\tr--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn r + 1 - size;\\n\\t\\t\\t}\\n\\t\\t\\tsm = op(st[r], sm);\\n\\t\\t} while((r & -r) != r);\\n\\t\\treturn 0;\\n\\t}\\n\\t\\nprivate:\\n\\tint n, size, log;\\n\\tstd::vector<T> st;\\n\\n\\tinline void update(int v) { st[v] = op(st[v << 1], st[v << 1 | 1]); }\\n};\\n\\nstruct S {\\n    char left_char, right_char;\\n    int left_len, mid_len, right_len, size;\\n};\\n\\nS e() {\\n    return S{\\'\\\\0\\', \\'\\\\0\\', 0, 0, 0, 0};\\n}\\n\\nS op(S a, S b) {\\n    S res;\\n    res.left_char = a.left_char;\\n    res.left_len = a.left_len;\\n    if(a.left_len == a.size && a.left_char == b.left_char) {\\n        res.left_len += b.left_len;\\n    }\\n    res.right_char = b.right_char;\\n    res.right_len = b.right_len;\\n    if(b.right_len == b.size && b.right_char == a.right_char) {\\n        res.right_len += a.right_len;\\n    }\\n    res.size = a.size + b.size;\\n    res.mid_len = max(a.mid_len, b.mid_len);\\n    if(a.right_char == b.left_char) {\\n        res.mid_len = max(res.mid_len, a.right_len + b.left_len);\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {\\n        const int n = (int) s.size();\\n        const int q = (int) qc.size();\\n        segtree<S, e, op> seg(n);\\n        for(int i = 0; i < n; ++i) {\\n            seg.set(i, S{s[i], s[i], 1, 0, 1, 1});\\n        }\\n        vector<int> ans(q);\\n        for(int i = 0; i < q; ++i) {\\n            char c = qc[i];\\n            int index = qi[i];\\n            seg.set(index, S{c, c, 1, 0, 1, 1});\\n            S res = seg.all_prod();\\n            ans[i] = max({res.left_len, res.mid_len, res.right_len});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nnamespace internal {\\n\\n// @param n `0 <= n`\\n// @return minimum non-negative `x` s.t. `n <= 2**x`\\nint ceil_pow2(int n) {\\n    int x = 0;\\n    while((1U << x) < (unsigned int)(n))\\n    \\tx++;\\n    return x;\\n}\\n\\n} // namespace internal\\n\\n// Source: ac-library/atcoder/segtree.hpp\\ntemplate<class T, T (*unit)(), T (*op)(T, T)>\\nclass segtree {\\npublic:\\n\\tsegtree() : segtree(0) {}\\n\\n\\tsegtree(int _n) : segtree(std::vector<T>(_n, unit())) {}\\n\\t\\n\\tsegtree(const std::vector<T>& arr): n(int(arr.size())) {\\n\\t\\tlog = internal::ceil_pow2(n);\\n\\t\\tsize = 1 << log;\\n\\t\\tst.resize(size << 1, unit());\\n\\t\\tfor(int i = 0; i < n; ++i)\\n\\t\\t\\tst[size + i] = arr[i];\\n\\t\\tfor(int i = size - 1; i; --i)\\n\\t\\t\\tupdate(i);\\n\\t}\\n\\t\\n\\tvoid set(int p, T val) {\\n\\t\\tassert(0 <= p && p < n);\\n\\t\\tp += size;\\n\\t\\tst[p] = val;\\n\\t\\tfor(int i = 1; i <= log; ++i)\\n\\t\\t\\tupdate(p >> i);\\n\\t}\\n\\n\\tinline T get(int p) const {\\n\\t\\tassert(0 <= p && p < n);\\n\\t\\treturn st[p + size];\\n\\t}\\n\\n\\tinline T operator[](int p) const {\\n\\t\\treturn get(p);\\n\\t}\\n\\t\\n\\tT prod(int l, int r) const {\\n\\t\\tassert(0 <= l && l <= r && r <= n);\\n\\t\\tT ans_left = unit(), ans_right = unit();\\n\\t\\tl += size;\\n\\t\\tr += size;\\n\\t\\twhile(l < r) {\\n\\t\\t\\tif(l & 1)\\n\\t\\t\\t\\tans_left = op(ans_left, st[l++]);\\n\\t\\t\\tif(r & 1)\\n\\t\\t\\t\\tans_right = op(st[--r], ans_right);\\n\\t\\t\\tl >>= 1;\\n\\t\\t\\tr >>= 1;\\n\\t\\t}\\n\\t\\treturn op(ans_left, ans_right);\\n\\t}\\n\\n\\tinline T all_prod() const { return st[1]; }\\n\\n\\ttemplate<bool (*f)(T)> int max_right(int l) const {\\n\\t\\treturn max_right(l, [](T x) { return f(x); });\\n\\t}\\n\\n\\ttemplate<class F> int max_right(int l, F f) const {\\n\\t\\tassert(0 <= l && l <= n);\\n\\t\\tassert(f(unit()));\\n\\t\\tif(l == n)\\n\\t\\t\\treturn n;\\n\\t\\tl += size;\\n\\t\\tT sm = unit();\\n\\t\\tdo {\\n\\t\\t\\twhile(l & 1 ^ 1)\\n\\t\\t\\t\\tl >>= 1;\\n\\t\\t\\tif(!f(op(sm, st[l]))) {\\n\\t\\t\\t\\twhile(l < size) {\\n\\t\\t\\t\\t\\tl <<= 1;\\n\\t\\t\\t\\t\\tif(f(op(sm, st[l]))) {\\n\\t\\t\\t\\t\\t\\tsm = op(sm, st[l]);\\n\\t\\t\\t\\t\\t\\tl++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn l - size;\\n\\t\\t\\t}\\n\\t\\t\\tsm = op(sm, st[l]);\\n\\t\\t\\tl++;\\n\\t\\t} while((l & -l) != l);\\n\\t\\treturn n;\\n\\t}\\n\\n\\ttemplate<bool (*f)(T)> int min_left(int r) const {\\n\\t\\treturn min_left(r, [](T x) { return f(x); });\\n\\t}\\n\\n\\ttemplate<class F> int min_left(int r, F f) const {\\n\\t\\tassert(0 <= r && r <= n);\\n\\t\\tassert(f(unit()));\\n\\t\\tif(r == 0)\\n\\t\\t\\treturn 0;\\n\\t\\tr += size;\\n\\t\\tT sm = unit();\\n\\t\\tdo {\\n\\t\\t\\tr--;\\n\\t\\t\\twhile(r > 1 && (r & 1))\\n\\t\\t\\t\\tr >>= 1;\\n\\t\\t\\tif(!f(op(st[r], sm))) {\\n\\t\\t\\t\\twhile(r < size) {\\n\\t\\t\\t\\t\\tr = r << 1 | 1;\\n\\t\\t\\t\\t\\tif(f(op(st[r], sm))) {\\n\\t\\t\\t\\t\\t\\tsm = op(st[r], sm);\\n\\t\\t\\t\\t\\t\\tr--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn r + 1 - size;\\n\\t\\t\\t}\\n\\t\\t\\tsm = op(st[r], sm);\\n\\t\\t} while((r & -r) != r);\\n\\t\\treturn 0;\\n\\t}\\n\\t\\nprivate:\\n\\tint n, size, log;\\n\\tstd::vector<T> st;\\n\\n\\tinline void update(int v) { st[v] = op(st[v << 1], st[v << 1 | 1]); }\\n};\\n\\nstruct S {\\n    char left_char, right_char;\\n    int left_len, mid_len, right_len, size;\\n};\\n\\nS e() {\\n    return S{\\'\\\\0\\', \\'\\\\0\\', 0, 0, 0, 0};\\n}\\n\\nS op(S a, S b) {\\n    S res;\\n    res.left_char = a.left_char;\\n    res.left_len = a.left_len;\\n    if(a.left_len == a.size && a.left_char == b.left_char) {\\n        res.left_len += b.left_len;\\n    }\\n    res.right_char = b.right_char;\\n    res.right_len = b.right_len;\\n    if(b.right_len == b.size && b.right_char == a.right_char) {\\n        res.right_len += a.right_len;\\n    }\\n    res.size = a.size + b.size;\\n    res.mid_len = max(a.mid_len, b.mid_len);\\n    if(a.right_char == b.left_char) {\\n        res.mid_len = max(res.mid_len, a.right_len + b.left_len);\\n    }\\n    return res;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {\\n        const int n = (int) s.size();\\n        const int q = (int) qc.size();\\n        segtree<S, e, op> seg(n);\\n        for(int i = 0; i < n; ++i) {\\n            seg.set(i, S{s[i], s[i], 1, 0, 1, 1});\\n        }\\n        vector<int> ans(q);\\n        for(int i = 0; i < q; ++i) {\\n            char c = qc[i];\\n            int index = qi[i];\\n            seg.set(index, S{c, c, 1, 0, 1, 1});\\n            S res = seg.all_prod();\\n            ans[i] = max({res.left_len, res.mid_len, res.right_len});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1983561,
                "title": "python-iterative-segment-tree",
                "content": "this is my AC segment tree solution, very frustrated.\\n\\nI\\'ve tried\\n- iterative segment tree, natually it should be faster than recursive one.\\n- optimize the query lists, reusing previous result on the same consecutive query\\n- early exit when change is not needed.\\n- `__slots__` to cut the object initialization time.....\\n\\nafter that, still got TLE many times on the last testcase.\\nI think for python, segment tree is not a good solution candidate for this problem\\n\\n\\n```python\\nclass SegNode:\\n    __slots__ = (\\'lc\\', \\'rc\\', \\'prefix\\', \\'sufix\\', \\'sz\\', \\'longest\\')\\n    \\n    def __init__(self):\\n        self.lc = \"\"\\n        self.rc = \"\"\\n        self.prefix = 0\\n        self.sufix = 0\\n        self.sz = 1\\n        self.longest = 0\\n\\t\\t\\n    def __eq__(self, other):\\n        return (\\n            self.lc == other.rc\\n            and self.rc == other.rc\\n            and self.prefix == other.prefix\\n            and self.sufix == other.sufix\\n            and self.sz == other.sz\\n            and self.longest == other.longest\\n        )\\n\\n    def merge(self, lchild: \"SegNode\", rchild: \"SegNode\"):\\n        self.longest = max(lchild.longest, rchild.longest)\\n        if lchild.rc == rchild.lc:\\n            self.longest = max(self.longest, lchild.sufix + rchild.prefix)\\n        self.sz = lchild.sz + rchild.sz\\n        self.lc = lchild.lc\\n        self.rc = rchild.rc\\n        self.prefix = lchild.prefix\\n        if lchild.prefix == lchild.sz and lchild.lc == rchild.lc:\\n            self.prefix += rchild.prefix\\n        self.sufix = rchild.sufix\\n        if rchild.sufix == rchild.sz and rchild.rc == lchild.rc:\\n            self.sufix += lchild.sufix\\n\\n\\nclass SegmentTree:\\n    __slots__ = (\\'bs\\', \\'nodes\\')\\n    def _calculate_bs(self, n: int) -> int:\\n        po2 = 1\\n        while po2 < n:\\n            po2 <<= 1\\n        return po2\\n\\n    def __init__(self, s: str):\\n        self.bs = self._calculate_bs(len(s))\\n        self.nodes = [SegNode() for _ in range(self.bs << 1)]\\n        self._build(s)\\n\\n    def _build(self, s: str):\\n        for i in range(len(s)):\\n            node = self.nodes[self.bs + i]\\n            node.lc = node.rc = s[i]\\n            node.prefix = node.sufix = node.longest = 1\\n\\n        for i in range(self.bs - 1, 0, -1):\\n            lchild = i << 1\\n            self.nodes[i].merge(self.nodes[lchild], self.nodes[lchild + 1])\\n\\n    def update(self, i: int, c: str):\\n        i += self.bs\\n        node = self.nodes[i]\\n        if c == node.lc:\\n            return self.nodes[1].longest\\n        node.lc = node.rc = c\\n        node.prefix = node.sufix = node.longest = 1\\n\\n        while i > 1:\\n            i >>= 1\\n            lchild = i << 1\\n            new_node = SegNode()\\n            new_node.merge(self.nodes[lchild], self.nodes[lchild + 1])\\n            if new_node != self.nodes[i]:\\n                self.nodes[i] = new_node\\n            else:\\n                break\\n\\n        return self.nodes[1].longest\\n\\n\\nclass Solution:\\n    def longestRepeating(\\n        self, s: str, queryCharacters: str, queryIndices: List[int]\\n    ) -> List[int]:\\n        sgt = SegmentTree(s)\\n        ret = [0] * len(queryIndices)\\n        pq = None\\n        longest = 0\\n        for i in range(len(queryIndices)):\\n            cq = (queryIndices[i], queryCharacters[i])\\n            if not pq or cq != pq:\\n                longest = sgt.update(*cq)\\n            ret[i] = longest\\n            pq = cq\\n        return ret\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```python\\nclass SegNode:\\n    __slots__ = (\\'lc\\', \\'rc\\', \\'prefix\\', \\'sufix\\', \\'sz\\', \\'longest\\')\\n    \\n    def __init__(self):\\n        self.lc = \"\"\\n        self.rc = \"\"\\n        self.prefix = 0\\n        self.sufix = 0\\n        self.sz = 1\\n        self.longest = 0\\n\\t\\t\\n    def __eq__(self, other):\\n        return (\\n            self.lc == other.rc\\n            and self.rc == other.rc\\n            and self.prefix == other.prefix\\n            and self.sufix == other.sufix\\n            and self.sz == other.sz\\n            and self.longest == other.longest\\n        )\\n\\n    def merge(self, lchild: \"SegNode\", rchild: \"SegNode\"):\\n        self.longest = max(lchild.longest, rchild.longest)\\n        if lchild.rc == rchild.lc:\\n            self.longest = max(self.longest, lchild.sufix + rchild.prefix)\\n        self.sz = lchild.sz + rchild.sz\\n        self.lc = lchild.lc\\n        self.rc = rchild.rc\\n        self.prefix = lchild.prefix\\n        if lchild.prefix == lchild.sz and lchild.lc == rchild.lc:\\n            self.prefix += rchild.prefix\\n        self.sufix = rchild.sufix\\n        if rchild.sufix == rchild.sz and rchild.rc == lchild.rc:\\n            self.sufix += lchild.sufix\\n\\n\\nclass SegmentTree:\\n    __slots__ = (\\'bs\\', \\'nodes\\')\\n    def _calculate_bs(self, n: int) -> int:\\n        po2 = 1\\n        while po2 < n:\\n            po2 <<= 1\\n        return po2\\n\\n    def __init__(self, s: str):\\n        self.bs = self._calculate_bs(len(s))\\n        self.nodes = [SegNode() for _ in range(self.bs << 1)]\\n        self._build(s)\\n\\n    def _build(self, s: str):\\n        for i in range(len(s)):\\n            node = self.nodes[self.bs + i]\\n            node.lc = node.rc = s[i]\\n            node.prefix = node.sufix = node.longest = 1\\n\\n        for i in range(self.bs - 1, 0, -1):\\n            lchild = i << 1\\n            self.nodes[i].merge(self.nodes[lchild], self.nodes[lchild + 1])\\n\\n    def update(self, i: int, c: str):\\n        i += self.bs\\n        node = self.nodes[i]\\n        if c == node.lc:\\n            return self.nodes[1].longest\\n        node.lc = node.rc = c\\n        node.prefix = node.sufix = node.longest = 1\\n\\n        while i > 1:\\n            i >>= 1\\n            lchild = i << 1\\n            new_node = SegNode()\\n            new_node.merge(self.nodes[lchild], self.nodes[lchild + 1])\\n            if new_node != self.nodes[i]:\\n                self.nodes[i] = new_node\\n            else:\\n                break\\n\\n        return self.nodes[1].longest\\n\\n\\nclass Solution:\\n    def longestRepeating(\\n        self, s: str, queryCharacters: str, queryIndices: List[int]\\n    ) -> List[int]:\\n        sgt = SegmentTree(s)\\n        ret = [0] * len(queryIndices)\\n        pq = None\\n        longest = 0\\n        for i in range(len(queryIndices)):\\n            cq = (queryIndices[i], queryCharacters[i])\\n            if not pq or cq != pq:\\n                longest = sgt.update(*cq)\\n            ret[i] = longest\\n            pq = cq\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919606,
                "title": "segment-tree-c",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tclass node{\\n\\t\\t\\tpublic :\\n\\t\\t\\tchar lprec;\\n\\t\\t\\tchar lsufc;\\n\\t\\t\\tint lprefix;\\n\\t\\t\\tint lsuffix;\\n\\t\\t\\tint lsubstr;\\n\\t\\t\\tnode(){\\n\\t\\t\\t\\tlprefix = 0;\\n\\t\\t\\t\\tlsuffix = 0;\\n\\t\\t\\t\\tlsubstr = 0;\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tvoid buildtree(vector<node> &segtree, int s, int e, int tidx, string &str){\\n\\t\\t\\tif(s == e){\\n\\t\\t\\t\\tnode newnode;\\n\\t\\t\\t\\tnewnode.lprec = newnode.lsufc = str[s];\\n\\t\\t\\t\\tnewnode.lprefix = newnode.lsuffix = newnode.lsubstr = 1;\\n\\t\\t\\t\\tsegtree[tidx] = newnode;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tint mid = (s + e)/2;\\n\\t\\t\\tbuildtree(segtree, s, mid, 2*tidx+1, str);\\n\\t\\t\\tbuildtree(segtree, mid+1, e, 2*tidx + 2, str);\\n\\t\\t\\tnode lans = segtree[2*tidx+1];\\n\\t\\t\\tnode rans = segtree[2*tidx+2];\\n\\t\\t\\tnode nn;\\n\\t\\t\\tif(lans.lsubstr > rans.lsubstr){\\n\\t\\t\\t\\tnn.lsubstr = lans.lsubstr;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tnn.lsubstr = rans.lsubstr;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(lans.lsufc == rans.lprec){\\n\\t\\t\\t\\tif(lans.lsuffix + rans.lprefix > nn.lsubstr){\\n\\t\\t\\t\\t\\tnn.lsubstr = lans.lsuffix + rans.lprefix;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint len = mid - s +1;\\n\\t\\t\\tnn.lprec = lans.lprec;\\n\\t\\t\\tif(len == lans.lprefix){\\n\\t\\t\\t\\tif(rans.lprec == lans.lprec){\\n\\t\\t\\t\\t\\tnn.lprefix = lans.lprefix + rans.lprefix;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tnn.lprefix = lans.lprefix;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tnn.lprefix = lans.lprefix;\\n\\t\\t\\t}\\n\\t\\t\\tlen = e - (mid + 1) + 1;\\n\\n\\t\\t\\tnn.lsufc = rans.lsufc;\\n\\t\\t\\tif(len == rans.lsuffix){\\n\\t\\t\\t\\tif(rans.lsufc == lans.lsufc){\\n\\t\\t\\t\\t\\tnn.lsuffix = rans.lsuffix + lans.lsuffix;\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tnn.lsuffix = rans.lsuffix;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tnn.lsuffix = rans.lsuffix;\\n\\t\\t\\t}\\n\\n\\t\\t\\tsegtree[tidx] = nn;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\t\\tvoid update(vector<node> &segtree, int s, int e, int tidx, char value, int index){\\n\\t\\t\\tif(s>index || e < index) return;\\n\\t\\t\\tif(s == e){\\n\\t\\t\\t\\tsegtree[tidx].lprec = segtree[tidx].lsufc = value;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tint mid = (s + e)/2;\\n\\t\\t\\tupdate(segtree, s, mid, 2*tidx+1, value , index);\\n\\t\\t\\tupdate(segtree, mid+1, e, 2*tidx + 2, value , index);\\n\\n\\t\\t\\tnode lans = segtree[2*tidx+1];\\n\\t\\t\\tnode rans = segtree[2*tidx+2];\\n\\t\\t\\tnode nn;\\n\\t\\t\\tif(lans.lsubstr > rans.lsubstr){\\n\\t\\t\\t\\tnn.lsubstr = lans.lsubstr;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tnn.lsubstr = rans.lsubstr;\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(lans.lsufc == rans.lprec){\\n\\t\\t\\t\\tif(lans.lsuffix + rans.lprefix > nn.lsubstr){\\n\\t\\t\\t\\t\\tnn.lsubstr = lans.lsuffix + rans.lprefix;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tint len = mid - s +1;\\n\\t\\t\\tnn.lprec = lans.lprec;\\n\\t\\t\\tif(len == lans.lprefix){\\n\\t\\t\\t\\tif(rans.lprec == lans.lprec){\\n\\t\\t\\t\\t\\tnn.lprefix = lans.lprefix + rans.lprefix;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tnn.lprefix = lans.lprefix;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tnn.lprefix = lans.lprefix;\\n\\t\\t\\t}\\n\\t\\t\\tlen = e - (mid + 1) + 1;\\n\\n\\t\\t\\tnn.lsufc = rans.lsufc;\\n\\t\\t\\tif(len == rans.lsuffix){\\n\\t\\t\\t\\tif(rans.lsufc == lans.lsufc){\\n\\t\\t\\t\\t\\tnn.lsuffix = rans.lsuffix + lans.lsuffix;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tnn.lsuffix = rans.lsuffix;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tnn.lsuffix = rans.lsuffix;\\n\\t\\t\\t}\\n\\t\\t\\tsegtree[tidx] = nn;\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\n\\t\\tvector<int> longestRepeating(string s, string qc, vector<int>& qi) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tvector<node> segtree(4*n);\\n\\t\\t\\tbuildtree(segtree, 0, n-1, 0, s);\\n\\t\\t\\tvector<int> ans;\\n\\t\\t\\tfor(int i=0; i<qc.size(); i++){\\n\\t\\t\\t\\tupdate(segtree, 0, n-1, 0, qc[i], qi[i]);\\n\\n\\t\\t\\t\\tans.push_back(segtree[0].lsubstr);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tclass node{\\n\\t\\t\\tpublic :\\n\\t\\t\\tchar lprec;\\n\\t\\t\\tchar lsufc;\\n\\t\\t\\tint lprefix;\\n\\t\\t\\tint lsuffix;\\n\\t\\t\\tint lsubstr;\\n\\t\\t\\tnode(){\\n\\t\\t\\t\\tlprefix = 0;\\n\\t\\t\\t\\tlsuffix = 0;\\n\\t\\t\\t\\tlsubstr = 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1912173,
                "title": "python-segment-tree",
                "content": "Refer to the top voted [discuss](http://leetcode.com/problems/longest-substring-of-one-repeating-character/discuss/1865692/Python-solution-now-AC-updated)\\nAccepted but not too good. \\nJust to share with python coders.\\n\\n```\\nclass Node:\\n    def __init__(self, L: int, R: int):\\n        self.L, self.R = L, R\\n        self.charL, self.charR = \\'\\', \\'\\'\\n        self.leftSon, self.rightSon = None, None\\n        self.prefix, self.suffix = 0, 0\\n        self.maxSubstr = 0\\n        \\nclass Solution:\\n    def BuildTree(self, l: int, r: int) -> Node:\\n        node = Node(l, r)\\n        if l == r:\\n            node.charL, node.charR = self.s[l], self.s[r]\\n            node.maxSubstr, node.prefix, node.suffix = 1, l, r\\n        else:\\n            mid = (l + r) // 2\\n            node.leftSon = self.BuildTree(l, mid)\\n            node.rightSon = self.BuildTree(mid+1, r)\\n            \\n            node.prefix, node.suffix = node.leftSon.prefix, node.rightSon.suffix\\n            node.maxSubstr = max(node.leftSon.maxSubstr, node.rightSon.maxSubstr)\\n            node.charL, node.charR = node.leftSon.charL, node.rightSon.charR\\n            \\n            if node.leftSon.charR == node.rightSon.charL:\\n                node.maxSubstr = max(node.rightSon.prefix - node.leftSon.suffix + 1, node.maxSubstr)\\n                if node.prefix == mid:\\n                    node.prefix = node.rightSon.prefix\\n                if node.suffix == mid + 1:\\n                    node.suffix = node.leftSon.suffix\\n        return node\\n    \\n    def Update(self, node: Node, idx: int, c: str):\\n        if node.L == node.R:\\n            node.charL = node.charR = c\\n            return\\n        mid = (node.L + node.R) // 2\\n        if idx > mid:\\n            self.Update(node.rightSon, idx, c)\\n            node.charR = node.rightSon.charR\\n        else:\\n            self.Update(node.leftSon, idx, c)\\n            node.charL = node.leftSon.charL\\n        \\n        node.prefix, node.suffix = node.leftSon.prefix, node.rightSon.suffix\\n        node.maxSubstr = max(node.leftSon.maxSubstr, node.rightSon.maxSubstr)\\n\\n        if node.leftSon.charR == node.rightSon.charL:\\n            node.maxSubstr = max(node.rightSon.prefix - node.leftSon.suffix + 1, node.maxSubstr)\\n            if node.prefix == mid:\\n                node.prefix = node.rightSon.prefix\\n            if node.suffix == mid + 1:\\n                node.suffix = node.leftSon.suffix\\n        return\\n    \\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        self.s = list(s)\\n        root = self.BuildTree(0, len(s)-1)\\n        answer = []\\n        for i in range(len(queryIndices)):\\n            self.s[queryIndices[i]] = queryCharacters[i]\\n            self.Update(root, queryIndices[i], queryCharacters[i])\\n            answer.append(root.maxSubstr)\\n        return answer\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self, L: int, R: int):\\n        self.L, self.R = L, R\\n        self.charL, self.charR = \\'\\', \\'\\'\\n        self.leftSon, self.rightSon = None, None\\n        self.prefix, self.suffix = 0, 0\\n        self.maxSubstr = 0\\n        \\nclass Solution:\\n    def BuildTree(self, l: int, r: int) -> Node:\\n        node = Node(l, r)\\n        if l == r:\\n            node.charL, node.charR = self.s[l], self.s[r]\\n            node.maxSubstr, node.prefix, node.suffix = 1, l, r\\n        else:\\n            mid = (l + r) // 2\\n            node.leftSon = self.BuildTree(l, mid)\\n            node.rightSon = self.BuildTree(mid+1, r)\\n            \\n            node.prefix, node.suffix = node.leftSon.prefix, node.rightSon.suffix\\n            node.maxSubstr = max(node.leftSon.maxSubstr, node.rightSon.maxSubstr)\\n            node.charL, node.charR = node.leftSon.charL, node.rightSon.charR\\n            \\n            if node.leftSon.charR == node.rightSon.charL:\\n                node.maxSubstr = max(node.rightSon.prefix - node.leftSon.suffix + 1, node.maxSubstr)\\n                if node.prefix == mid:\\n                    node.prefix = node.rightSon.prefix\\n                if node.suffix == mid + 1:\\n                    node.suffix = node.leftSon.suffix\\n        return node\\n    \\n    def Update(self, node: Node, idx: int, c: str):\\n        if node.L == node.R:\\n            node.charL = node.charR = c\\n            return\\n        mid = (node.L + node.R) // 2\\n        if idx > mid:\\n            self.Update(node.rightSon, idx, c)\\n            node.charR = node.rightSon.charR\\n        else:\\n            self.Update(node.leftSon, idx, c)\\n            node.charL = node.leftSon.charL\\n        \\n        node.prefix, node.suffix = node.leftSon.prefix, node.rightSon.suffix\\n        node.maxSubstr = max(node.leftSon.maxSubstr, node.rightSon.maxSubstr)\\n\\n        if node.leftSon.charR == node.rightSon.charL:\\n            node.maxSubstr = max(node.rightSon.prefix - node.leftSon.suffix + 1, node.maxSubstr)\\n            if node.prefix == mid:\\n                node.prefix = node.rightSon.prefix\\n            if node.suffix == mid + 1:\\n                node.suffix = node.leftSon.suffix\\n        return\\n    \\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        self.s = list(s)\\n        root = self.BuildTree(0, len(s)-1)\\n        answer = []\\n        for i in range(len(queryIndices)):\\n            self.s[queryIndices[i]] = queryCharacters[i]\\n            self.Update(root, queryIndices[i], queryCharacters[i])\\n            answer.append(root.maxSubstr)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904981,
                "title": "typescript-segment-tree-solution-beats-100",
                "content": "```\\nclass SegmentNode{\\n    leftIndex: number\\n    rightIndex: number\\n    leftMostPrefix: number\\n    rightMostPrefix: number\\n    maxEqual: number\\n    leftNode: SegmentNode | null\\n    rightNode: SegmentNode | null\\n    \\n    constructor(leftIndex: number, rightIndex: number){\\n        this.leftIndex = leftIndex\\n        this.rightIndex = rightIndex\\n        this.leftMostPrefix = 1\\n        this.rightMostPrefix = 1\\n        this.maxEqual = 1\\n        this.leftNode = null\\n        this.rightNode = null\\n    }\\n}\\n\\nclass SegmentTree{\\n    _s: string[]\\n    _root: SegmentNode | null\\n    constructor(s: string){\\n        this._s = Array.from(s)\\n        this._root = this.buildTree(0, s.length)\\n    }\\n    \\n    buildTree(\\n        leftIndex: number = 0,\\n        rightIndex: number = this._s.length,\\n    ): SegmentNode| null{\\n        if(leftIndex === rightIndex) return null\\n        const root = new SegmentNode(leftIndex, rightIndex)\\n        if(leftIndex + 1 === rightIndex){\\n            return root\\n        }\\n        \\n        const mid = Math.floor((leftIndex + rightIndex) / 2)\\n        \\n        root.leftNode = this.buildTree(leftIndex, mid)\\n        root.rightNode = this.buildTree(mid, rightIndex)\\n        this.setPrefix(root)\\n        return root\\n    }\\n\\n    setPrefix(root: SegmentNode) {\\n        if(root.leftIndex + 1 === root.rightIndex){\\n            return\\n        }\\n        \\n        const mid = root.rightNode.leftIndex\\n        \\n        root.leftMostPrefix = root.leftNode.leftMostPrefix\\n        root.rightMostPrefix = root.rightNode.rightMostPrefix\\n        \\n        if(this._s[mid-1] === this._s[mid]){\\n            if(root.leftNode.leftMostPrefix === mid - root.leftIndex)\\n                root.leftMostPrefix += root.rightNode.leftMostPrefix\\n\\n            if(root.rightNode.rightMostPrefix === root.rightIndex - mid)\\n                root.rightMostPrefix += root.leftNode.rightMostPrefix\\n        }\\n        \\n        root.maxEqual = Math.max(\\n            root.leftNode.maxEqual,\\n            root.rightNode.maxEqual,\\n            root.leftMostPrefix,\\n            root.rightMostPrefix\\n        )\\n        \\n        if(this._s[mid-1] === this._s[mid]){\\n            root.maxEqual = Math.max(\\n                root.maxEqual,\\n                root.rightNode.leftMostPrefix + root.leftNode.rightMostPrefix\\n            )\\n        }\\n    }\\n\\n    applyQeury(char: string, index: number, root: SegmentNode = this._root){\\n        if(!root) return\\n        \\n        if(root.leftIndex + 1 === root.rightIndex){\\n            this._s[root.leftIndex] = char\\n            return\\n        }\\n        \\n        const mid = Math.floor(\\n            (root.leftIndex + root.rightIndex) / 2\\n        )\\n        \\n        if(index < mid){\\n            this.applyQeury(char, index, root.leftNode)\\n        }else{\\n            this.applyQeury(char, index, root.rightNode)\\n        }\\n        this.setPrefix(root)\\n    }\\n\\n    maxEqual(): number{\\n        return this._root?.maxEqual\\n    }\\n    \\n}\\n\\nfunction longestRepeating(s: string, queryCharacters: string, queryIndices: number[]): number[] {\\n    const tree = new SegmentTree(s)\\n    const res = []\\n    for(let i = 0; i < queryCharacters.length; ++i){\\n        tree.applyQeury(queryCharacters[i], queryIndices[i])\\n        res.push(tree.maxEqual())\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass SegmentNode{\\n    leftIndex: number\\n    rightIndex: number\\n    leftMostPrefix: number\\n    rightMostPrefix: number\\n    maxEqual: number\\n    leftNode: SegmentNode | null\\n    rightNode: SegmentNode | null\\n    \\n    constructor(leftIndex: number, rightIndex: number){\\n        this.leftIndex = leftIndex\\n        this.rightIndex = rightIndex\\n        this.leftMostPrefix = 1\\n        this.rightMostPrefix = 1\\n        this.maxEqual = 1\\n        this.leftNode = null\\n        this.rightNode = null\\n    }\\n}\\n\\nclass SegmentTree{\\n    _s: string[]\\n    _root: SegmentNode | null\\n    constructor(s: string){\\n        this._s = Array.from(s)\\n        this._root = this.buildTree(0, s.length)\\n    }\\n    \\n    buildTree(\\n        leftIndex: number = 0,\\n        rightIndex: number = this._s.length,\\n    ): SegmentNode| null{\\n        if(leftIndex === rightIndex) return null\\n        const root = new SegmentNode(leftIndex, rightIndex)\\n        if(leftIndex + 1 === rightIndex){\\n            return root\\n        }\\n        \\n        const mid = Math.floor((leftIndex + rightIndex) / 2)\\n        \\n        root.leftNode = this.buildTree(leftIndex, mid)\\n        root.rightNode = this.buildTree(mid, rightIndex)\\n        this.setPrefix(root)\\n        return root\\n    }\\n\\n    setPrefix(root: SegmentNode) {\\n        if(root.leftIndex + 1 === root.rightIndex){\\n            return\\n        }\\n        \\n        const mid = root.rightNode.leftIndex\\n        \\n        root.leftMostPrefix = root.leftNode.leftMostPrefix\\n        root.rightMostPrefix = root.rightNode.rightMostPrefix\\n        \\n        if(this._s[mid-1] === this._s[mid]){\\n            if(root.leftNode.leftMostPrefix === mid - root.leftIndex)\\n                root.leftMostPrefix += root.rightNode.leftMostPrefix\\n\\n            if(root.rightNode.rightMostPrefix === root.rightIndex - mid)\\n                root.rightMostPrefix += root.leftNode.rightMostPrefix\\n        }\\n        \\n        root.maxEqual = Math.max(\\n            root.leftNode.maxEqual,\\n            root.rightNode.maxEqual,\\n            root.leftMostPrefix,\\n            root.rightMostPrefix\\n        )\\n        \\n        if(this._s[mid-1] === this._s[mid]){\\n            root.maxEqual = Math.max(\\n                root.maxEqual,\\n                root.rightNode.leftMostPrefix + root.leftNode.rightMostPrefix\\n            )\\n        }\\n    }\\n\\n    applyQeury(char: string, index: number, root: SegmentNode = this._root){\\n        if(!root) return\\n        \\n        if(root.leftIndex + 1 === root.rightIndex){\\n            this._s[root.leftIndex] = char\\n            return\\n        }\\n        \\n        const mid = Math.floor(\\n            (root.leftIndex + root.rightIndex) / 2\\n        )\\n        \\n        if(index < mid){\\n            this.applyQeury(char, index, root.leftNode)\\n        }else{\\n            this.applyQeury(char, index, root.rightNode)\\n        }\\n        this.setPrefix(root)\\n    }\\n\\n    maxEqual(): number{\\n        return this._root?.maxEqual\\n    }\\n    \\n}\\n\\nfunction longestRepeating(s: string, queryCharacters: string, queryIndices: number[]): number[] {\\n    const tree = new SegmentTree(s)\\n    const res = []\\n    for(let i = 0; i < queryCharacters.length; ++i){\\n        tree.applyQeury(queryCharacters[i], queryIndices[i])\\n        res.push(tree.maxEqual())\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887921,
                "title": "javascript-segment-tree-solution-beats-100",
                "content": "Not that clean and have some duplicate code in two functions, just show js idea here :)\\n\\n```js\\nvar Node = function (leftChar, leftLen, rightChar, rightLen, maxLen, left, right, len, l, r) {\\n    this.leftChar = leftChar;\\n    this.leftLen = leftLen;\\n    this.rightChar = rightChar;\\n    this.rightLen = rightLen;\\n    this.maxLen = maxLen;\\n    this.left = left;\\n    this.right = right;\\n    this.len = len;\\n    this.l = l;\\n    this.r = r;\\n}\\n\\nvar build = function (s, l, r) {\\n    if (l > r) return null;\\n    if (l === r) return new Node(s[l], 1, s[r], 1, 1, null, null, 1, l, r);\\n    var mid = Math.floor((r + l) / 2);\\n    var root = new Node();\\n    var left = build(s, l, mid, root);\\n    var right = build(s, mid + 1, r, root);\\n\\n    if (left) {\\n        root.leftChar = left.leftChar;\\n        if (left.leftLen === left.len && left.leftChar === right.leftChar) {\\n            root.leftLen = left.len + right.leftLen;\\n        } else {\\n            root.leftLen = left.leftLen;\\n        }\\n    }\\n    if (right) {\\n        root.rightChar = right.rightChar;\\n        if (right.rightLen === right.len && right.rightChar === left.rightChar) {\\n            root.rightLen = right.len + left.rightLen;\\n        } else {\\n            root.rightLen = right.rightLen;\\n        }\\n    }\\n    var midLen = 0;\\n    if (left && right && left.rightChar === right.leftChar) midLen = left.rightLen + right.leftLen;\\n    root.maxLen = Math.max(left ? left.maxLen : 0, right ? right.maxLen : 0, midLen);\\n\\n    root.left = left;\\n    root.right = right;\\n    root.len = r - l + 1;\\n    root.l = l;\\n    root.r = r;\\n\\n    return root;\\n}\\n\\nvar update = function (root, idx, char) {\\n    if (!root) return 0;\\n    if (root.len === 1) {\\n        root.leftChar = root.rightChar = char;\\n        return 1;\\n    }\\n    var mid = Math.floor((root.r + root.l) / 2);\\n    if (idx <= mid) update(root.left, idx, char);\\n    else update(root.right, idx, char);\\n\\n    var left = root.left;\\n    var right = root.right;\\n\\n\\t// copied from the build function, actually do the same thing as build\\n    if (left) {\\n        root.leftChar = left.leftChar;\\n        if (left.leftLen === left.len && left.leftChar === right.leftChar) {\\n            root.leftLen = left.len + right.leftLen;\\n        } else {\\n            root.leftLen = left.leftLen;\\n        }\\n    }\\n    if (right) {\\n        root.rightChar = right.rightChar;\\n        if (right.rightLen === right.len && right.rightChar === left.rightChar) {\\n            root.rightLen = right.len + left.rightLen;\\n        } else {\\n            root.rightLen = right.rightLen;\\n        }\\n    }\\n    var midLen = 0;\\n    if (left && right && left.rightChar === right.leftChar) midLen = left.rightLen + right.leftLen;\\n    root.maxLen = Math.max(left ? left.maxLen : 0, right ? right.maxLen : 0, midLen);\\n\\n    return root.maxLen;\\n}\\n\\n/**\\n * @param {string} s\\n * @param {string} queryCharacters\\n * @param {number[]} queryIndices\\n * @return {number[]}\\n */\\nvar longestRepeating = function (s, queryCharacters, queryIndices) {\\n    var root = build(s, 0, s.length - 1);\\n    var ans = [];\\n    for (var i = 0; i < queryCharacters.length; i++) {\\n        ans.push(update(root, queryIndices[i], queryCharacters[i]));\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "```js\\nvar Node = function (leftChar, leftLen, rightChar, rightLen, maxLen, left, right, len, l, r) {\\n    this.leftChar = leftChar;\\n    this.leftLen = leftLen;\\n    this.rightChar = rightChar;\\n    this.rightLen = rightLen;\\n    this.maxLen = maxLen;\\n    this.left = left;\\n    this.right = right;\\n    this.len = len;\\n    this.l = l;\\n    this.r = r;\\n}\\n\\nvar build = function (s, l, r) {\\n    if (l > r) return null;\\n    if (l === r) return new Node(s[l], 1, s[r], 1, 1, null, null, 1, l, r);\\n    var mid = Math.floor((r + l) / 2);\\n    var root = new Node();\\n    var left = build(s, l, mid, root);\\n    var right = build(s, mid + 1, r, root);\\n\\n    if (left) {\\n        root.leftChar = left.leftChar;\\n        if (left.leftLen === left.len && left.leftChar === right.leftChar) {\\n            root.leftLen = left.len + right.leftLen;\\n        } else {\\n            root.leftLen = left.leftLen;\\n        }\\n    }\\n    if (right) {\\n        root.rightChar = right.rightChar;\\n        if (right.rightLen === right.len && right.rightChar === left.rightChar) {\\n            root.rightLen = right.len + left.rightLen;\\n        } else {\\n            root.rightLen = right.rightLen;\\n        }\\n    }\\n    var midLen = 0;\\n    if (left && right && left.rightChar === right.leftChar) midLen = left.rightLen + right.leftLen;\\n    root.maxLen = Math.max(left ? left.maxLen : 0, right ? right.maxLen : 0, midLen);\\n\\n    root.left = left;\\n    root.right = right;\\n    root.len = r - l + 1;\\n    root.l = l;\\n    root.r = r;\\n\\n    return root;\\n}\\n\\nvar update = function (root, idx, char) {\\n    if (!root) return 0;\\n    if (root.len === 1) {\\n        root.leftChar = root.rightChar = char;\\n        return 1;\\n    }\\n    var mid = Math.floor((root.r + root.l) / 2);\\n    if (idx <= mid) update(root.left, idx, char);\\n    else update(root.right, idx, char);\\n\\n    var left = root.left;\\n    var right = root.right;\\n\\n\\t// copied from the build function, actually do the same thing as build\\n    if (left) {\\n        root.leftChar = left.leftChar;\\n        if (left.leftLen === left.len && left.leftChar === right.leftChar) {\\n            root.leftLen = left.len + right.leftLen;\\n        } else {\\n            root.leftLen = left.leftLen;\\n        }\\n    }\\n    if (right) {\\n        root.rightChar = right.rightChar;\\n        if (right.rightLen === right.len && right.rightChar === left.rightChar) {\\n            root.rightLen = right.len + left.rightLen;\\n        } else {\\n            root.rightLen = right.rightLen;\\n        }\\n    }\\n    var midLen = 0;\\n    if (left && right && left.rightChar === right.leftChar) midLen = left.rightLen + right.leftLen;\\n    root.maxLen = Math.max(left ? left.maxLen : 0, right ? right.maxLen : 0, midLen);\\n\\n    return root.maxLen;\\n}\\n\\n/**\\n * @param {string} s\\n * @param {string} queryCharacters\\n * @param {number[]} queryIndices\\n * @return {number[]}\\n */\\nvar longestRepeating = function (s, queryCharacters, queryIndices) {\\n    var root = build(s, 0, s.length - 1);\\n    var ans = [];\\n    for (var i = 0; i < queryCharacters.length; i++) {\\n        ans.push(update(root, queryIndices[i], queryCharacters[i]));\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1887477,
                "title": "why-is-my-segment-tree-solution-so-slow",
                "content": "It passes sometimes but sometimes it TLEs on the last case\\n```\\nclass Solution {\\npublic:\\n  vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n    SegmentTree* tr = new SegmentTree;\\n    int n = s.size();\\n    int numQueries = queryIndices.size();\\n    for (int i = 0; i < n; ++i) {\\n      tr = tr->update(s[i], i);\\n    }\\n    vector<int> result;\\n    for (int q = 0; q < numQueries; ++q) {\\n      char qC = queryCharacters[q];\\n      int qI = queryIndices[q];\\n      tr = tr->update(qC, qI);\\n      result.push_back(tr->longestRepeating);\\n    }\\n    delete tr;\\n    return result;\\n  }\\n  \\nprivate:\\n  struct RepeatingCharInfo {\\n    char c = \\'\\\\0\\';\\n    int start = -1;\\n    int freq = 0;\\n    RepeatingCharInfo() {}\\n    RepeatingCharInfo(char c, int start, int freq) : c(c), start(start), freq(freq) {}\\n    \\n    bool operator==(const RepeatingCharInfo& other) {\\n      return c == other.c && start == other.start && freq == other.freq;\\n    }\\n  };\\n\\n  struct SegmentTree {\\n    SegmentTree* left = nullptr;\\n    SegmentTree* right = nullptr;\\n    int start = 0;\\n    int length = 1;\\n    int longestRepeating = 1;\\n    RepeatingCharInfo leftRepeatingChar;\\n    RepeatingCharInfo rightRepeatingChar;\\n\\n    SegmentTree() {}\\n    SegmentTree(int start) : start(start) {}\\n    SegmentTree(int start, int length) : start(start), length(length) {}\\n    SegmentTree(int start, int length, SegmentTree* left, SegmentTree* right) : SegmentTree(start, length) {\\n      this->left = left;\\n      this->right = right;\\n    }\\n    \\n    ~SegmentTree() {\\n      delete left;\\n      delete right;\\n    }\\n\\n    SegmentTree* update(char c, int idx) {\\n      if (start == idx && length == 1) {\\n        leftRepeatingChar.c = c;\\n        leftRepeatingChar.start = start;\\n        leftRepeatingChar.freq = 1;\\n        rightRepeatingChar.c = c;\\n        rightRepeatingChar.start = start;\\n        rightRepeatingChar.freq = 1;\\n        return this;\\n      }\\n      int end = start + length;\\n      if (idx < start) {\\n        auto parent = new SegmentTree(start, 2 * length, nullptr, this);\\n        parent->update(c, idx);\\n        return parent;\\n      }\\n      if (idx >= end) {\\n        auto parent = new SegmentTree(start, 2 * length, this, nullptr);\\n        parent->update(c, idx);\\n        return parent;\\n      }\\n      int mid = (start + end) / 2;\\n      if (idx < mid) {\\n        if (left == nullptr) {\\n          left = new SegmentTree(start, length / 2);\\n        }\\n        left->update(c, idx);\\n      } else {\\n        if (right == nullptr) {\\n          right = new SegmentTree(mid, length / 2);\\n        }\\n        right->update(c, idx);\\n      }\\n      updateLongestRepeating(idx);\\n      return this;\\n    }\\n\\n    void updateLongestRepeating(int idx) {\\n      longestRepeating = 0;\\n      \\n      if (left && right) {\\n        leftRepeatingChar = left->leftRepeatingChar;\\n        rightRepeatingChar = right->rightRepeatingChar;\\n        \\n        if (left->leftRepeatingChar == left->rightRepeatingChar &&\\n           right->leftRepeatingChar.c == left->rightRepeatingChar.c) {\\n          leftRepeatingChar.freq += right->leftRepeatingChar.freq;\\n        }\\n        \\n        if (right->leftRepeatingChar == right->rightRepeatingChar &&\\n           left->rightRepeatingChar.c == right->leftRepeatingChar.c) {\\n          rightRepeatingChar.freq += left->rightRepeatingChar.freq;\\n          rightRepeatingChar.start = left->rightRepeatingChar.start;\\n        }\\n        \\n        longestRepeating = max(left->longestRepeating, right->longestRepeating);\\n        if (left->rightRepeatingChar.c == right->leftRepeatingChar.c) {\\n          longestRepeating = max(longestRepeating,\\n                                 left->rightRepeatingChar.freq + right->leftRepeatingChar.freq);\\n        }\\n        \\n      } else if (left) {\\n        leftRepeatingChar = left->leftRepeatingChar;\\n        rightRepeatingChar = left->leftRepeatingChar;\\n        longestRepeating = left->longestRepeating;\\n      } else if (right) {\\n        leftRepeatingChar = right->rightRepeatingChar;\\n        rightRepeatingChar = right->rightRepeatingChar;\\n        longestRepeating = right->longestRepeating;\\n      }\\n      \\n    }\\n  };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n    SegmentTree* tr = new SegmentTree;\\n    int n = s.size();\\n    int numQueries = queryIndices.size();\\n    for (int i = 0; i < n; ++i) {\\n      tr = tr->update(s[i], i);\\n    }\\n    vector<int> result;\\n    for (int q = 0; q < numQueries; ++q) {\\n      char qC = queryCharacters[q];\\n      int qI = queryIndices[q];\\n      tr = tr->update(qC, qI);\\n      result.push_back(tr->longestRepeating);\\n    }\\n    delete tr;\\n    return result;\\n  }\\n  \\nprivate:\\n  struct RepeatingCharInfo {\\n    char c = \\'\\\\0\\';\\n    int start = -1;\\n    int freq = 0;\\n    RepeatingCharInfo() {}\\n    RepeatingCharInfo(char c, int start, int freq) : c(c), start(start), freq(freq) {}\\n    \\n    bool operator==(const RepeatingCharInfo& other) {\\n      return c == other.c && start == other.start && freq == other.freq;\\n    }\\n  };\\n\\n  struct SegmentTree {\\n    SegmentTree* left = nullptr;\\n    SegmentTree* right = nullptr;\\n    int start = 0;\\n    int length = 1;\\n    int longestRepeating = 1;\\n    RepeatingCharInfo leftRepeatingChar;\\n    RepeatingCharInfo rightRepeatingChar;\\n\\n    SegmentTree() {}\\n    SegmentTree(int start) : start(start) {}\\n    SegmentTree(int start, int length) : start(start), length(length) {}\\n    SegmentTree(int start, int length, SegmentTree* left, SegmentTree* right) : SegmentTree(start, length) {\\n      this->left = left;\\n      this->right = right;\\n    }\\n    \\n    ~SegmentTree() {\\n      delete left;\\n      delete right;\\n    }\\n\\n    SegmentTree* update(char c, int idx) {\\n      if (start == idx && length == 1) {\\n        leftRepeatingChar.c = c;\\n        leftRepeatingChar.start = start;\\n        leftRepeatingChar.freq = 1;\\n        rightRepeatingChar.c = c;\\n        rightRepeatingChar.start = start;\\n        rightRepeatingChar.freq = 1;\\n        return this;\\n      }\\n      int end = start + length;\\n      if (idx < start) {\\n        auto parent = new SegmentTree(start, 2 * length, nullptr, this);\\n        parent->update(c, idx);\\n        return parent;\\n      }\\n      if (idx >= end) {\\n        auto parent = new SegmentTree(start, 2 * length, this, nullptr);\\n        parent->update(c, idx);\\n        return parent;\\n      }\\n      int mid = (start + end) / 2;\\n      if (idx < mid) {\\n        if (left == nullptr) {\\n          left = new SegmentTree(start, length / 2);\\n        }\\n        left->update(c, idx);\\n      } else {\\n        if (right == nullptr) {\\n          right = new SegmentTree(mid, length / 2);\\n        }\\n        right->update(c, idx);\\n      }\\n      updateLongestRepeating(idx);\\n      return this;\\n    }\\n\\n    void updateLongestRepeating(int idx) {\\n      longestRepeating = 0;\\n      \\n      if (left && right) {\\n        leftRepeatingChar = left->leftRepeatingChar;\\n        rightRepeatingChar = right->rightRepeatingChar;\\n        \\n        if (left->leftRepeatingChar == left->rightRepeatingChar &&\\n           right->leftRepeatingChar.c == left->rightRepeatingChar.c) {\\n          leftRepeatingChar.freq += right->leftRepeatingChar.freq;\\n        }\\n        \\n        if (right->leftRepeatingChar == right->rightRepeatingChar &&\\n           left->rightRepeatingChar.c == right->leftRepeatingChar.c) {\\n          rightRepeatingChar.freq += left->rightRepeatingChar.freq;\\n          rightRepeatingChar.start = left->rightRepeatingChar.start;\\n        }\\n        \\n        longestRepeating = max(left->longestRepeating, right->longestRepeating);\\n        if (left->rightRepeatingChar.c == right->leftRepeatingChar.c) {\\n          longestRepeating = max(longestRepeating,\\n                                 left->rightRepeatingChar.freq + right->leftRepeatingChar.freq);\\n        }\\n        \\n      } else if (left) {\\n        leftRepeatingChar = left->leftRepeatingChar;\\n        rightRepeatingChar = left->leftRepeatingChar;\\n        longestRepeating = left->longestRepeating;\\n      } else if (right) {\\n        leftRepeatingChar = right->rightRepeatingChar;\\n        rightRepeatingChar = right->rightRepeatingChar;\\n        longestRepeating = right->longestRepeating;\\n      }\\n      \\n    }\\n  };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875835,
                "title": "c-clean-code-easy-explanation-with-comments",
                "content": "Here\\'s one way to solve this problem using the Segment Tree data structure. This problem simply boils down to:\\n* What informations should be stored in each node of the segment tree?\\n* How to merge two different nodes of the tree & update stored information?\\n\\nExplanation is commented along with relevant code snippet below:\\n\\n```C++\\n\\n// TODO: What information do we store in each node of the segment tree?\\n\\n// We\\'re going to store 5 info at each node of the segment tree\\n// 1. startIdx - starting index of this substring\\n// 2. endIdx - ending index of this substring\\n// 3. prefixLen - prefix length with one repeating character of this substring\\n// 4. suffixLen - suffix length with one repeating character of this substring\\n// 5. maxLen - desired answer for this substring i.e. maximum substring length with one repeating character\\nstruct Node {\\n  int maxLen;\\n  int startIdx, endIdx;\\n  int prefixLen, suffixLen;\\n  Node(): maxLen(0), startIdx(0), endIdx(0), prefixLen(0), suffixLen(0) {}\\n} segmentTree[4 * N];\\n\\n```\\n\\n```C++\\n// TODO: How to combine two nodes & update result?\\n// We need to handle two cases:\\n// 1. if the last character from the left subarray is same as the first character of the right subarray\\n// 2. if the last character from the left subarray is NOT same as the first character the right subarray\\n  \\n// Case 1: if the last character from left subarray is same as the first character of the right subarray\\nif (s[l.endIdx] == s[r.startIdx]) {\\n  curNode.maxLen = max({l.maxLen, r.maxLen, l.suffixLen + r.prefixLen});\\n\\n  // if all the characters from the left subarray are same, extend the prefixLen\\n  if (l.prefixLen == l.endIdx - l.startIdx + 1) {\\n\\t curNode.prefixLen = l.prefixLen + r.prefixLen;\\n  } else {\\n\\t curNode.prefixLen = l.prefixLen;\\n  }\\n\\n  // if all the characters from the right subarray are same, extend the suffixLen\\n  if (r.suffixLen == r.endIdx - r.startIdx + 1) {\\n    curNode.suffixLen = r.suffixLen + l.suffixLen;\\n  } else {\\n    curNode.suffixLen = r.suffixLen;\\n  }\\n} \\n\\n// Case 2: if the last character from left subarray is NOT same as the first character of the right subarray\\ncurNode.maxLen = max(l.maxLen, r.maxLen);\\ncurNode.prefixLen = l.prefixLen;\\ncurNode.suffixLen = r.suffixLen;\\n\\t\\n// In either case, update the startIdx & endIdx accordingly\\ncurNode.startIdx = l.startIdx;\\ncurNode.endIdx = r.endIdx;\\n  \\n```\\n& the rests should be trivial if someone is familiar with solving problems with segment tree. Here\\'s the complete solution: \\n\\n```C++\\nconst int N = 1e5 + 5;\\n\\nstruct Node {\\n  int maxLen;\\n  int startIdx, endIdx;\\n  int prefixLen, suffixLen;\\n  Node(): maxLen(0), startIdx(0), endIdx(0), prefixLen(0), suffixLen(0) {}\\n} segmentTree[4 * N];\\n\\n\\nNode combine(Node &l, Node &r, string &s) {\\n  Node curNode = Node();\\n\\n  if (s[l.endIdx] == s[r.startIdx]) {\\n    curNode.maxLen = max({l.maxLen, r.maxLen, l.suffixLen + r.prefixLen});\\n\\n    if (l.prefixLen == l.endIdx - l.startIdx + 1) {\\n      curNode.prefixLen = l.prefixLen + r.prefixLen;\\n    } else {\\n      curNode.prefixLen = l.prefixLen;\\n    }\\n\\n    if (r.suffixLen == r.endIdx - r.startIdx + 1) {\\n      curNode.suffixLen = r.suffixLen + l.suffixLen;\\n    } else {\\n      curNode.suffixLen = r.suffixLen;\\n    }\\n\\n\\n  } else {\\n    curNode.maxLen = max(l.maxLen, r.maxLen);\\n    curNode.prefixLen = l.prefixLen;\\n    curNode.suffixLen = r.suffixLen;\\n  }\\n\\n  curNode.startIdx = l.startIdx;\\n  curNode.endIdx = r.endIdx;\\n\\n  return curNode;\\n}\\n\\nvoid build(int node, int b, int e, string & s) {\\n  if (b > e) {\\n    return;\\n  }\\n\\n  if (b == e) {\\n    segmentTree[node].maxLen = 1;\\n    segmentTree[node].startIdx = b, segmentTree[node].endIdx = b;\\n    segmentTree[node].prefixLen = 1, segmentTree[node].suffixLen = 1;\\n    return;\\n  }\\n\\n  int l = node << 1, r = l | 1, m = (b + e) >> 1;\\n\\n  build(l, b, m, s);\\n  build(r, m + 1, e, s);\\n\\n  segmentTree[node] = combine(segmentTree[l], segmentTree[r], s);\\n}\\n\\nvoid update(int node, int b, int e, int pos, char ch, string & s) {\\n  if (pos > e || pos < b || b > e) {\\n    return;\\n  }\\n\\n  if (pos == b && b == e) {\\n    s[pos] = ch;\\n    segmentTree[node].maxLen = 1;\\n    segmentTree[node].startIdx = b, segmentTree[node].endIdx = b;\\n    segmentTree[node].prefixLen = 1, segmentTree[node].suffixLen = 1;\\n    return;\\n  }\\n\\n  int l = node << 1, r = l | 1, m = (b + e) >> 1;\\n\\n  if (pos <= m) {\\n    update(l, b, m, pos, ch, s);\\n  } else {\\n    update(r, m + 1, e, pos, ch, s);\\n  }\\n\\n  segmentTree[node] = combine(segmentTree[l], segmentTree[r], s);\\n}\\n\\nclass Solution {\\n  public:\\n    vector <int> longestRepeating(string s, string queryCharacters, vector <int> &queryIndices) {\\n      int len = s.size();\\n\\n      build(1, 0, len - 1, s);\\n\\n      vector <int> ans;\\n      for (int i = 0; i < (int)queryCharacters.size(); i++) {\\n        update(1, 0, len - 1, queryIndices[i], queryCharacters[i], s);\\n        ans.push_back(segmentTree[1].maxLen);\\n      }\\n\\n      return ans;\\n    }\\n};\\n```\\n\\n**Runtime:** `O(NlgN)`\\nPS: may be I\\'ll add more words & few images with better explanation.",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```C++\\n\\n// TODO: What information do we store in each node of the segment tree?\\n\\n// We\\'re going to store 5 info at each node of the segment tree\\n// 1. startIdx - starting index of this substring\\n// 2. endIdx - ending index of this substring\\n// 3. prefixLen - prefix length with one repeating character of this substring\\n// 4. suffixLen - suffix length with one repeating character of this substring\\n// 5. maxLen - desired answer for this substring i.e. maximum substring length with one repeating character\\nstruct Node {\\n  int maxLen;\\n  int startIdx, endIdx;\\n  int prefixLen, suffixLen;\\n  Node(): maxLen(0), startIdx(0), endIdx(0), prefixLen(0), suffixLen(0) {}\\n} segmentTree[4 * N];\\n\\n```\n```C++\\n// TODO: How to combine two nodes & update result?\\n// We need to handle two cases:\\n// 1. if the last character from the left subarray is same as the first character of the right subarray\\n// 2. if the last character from the left subarray is NOT same as the first character the right subarray\\n  \\n// Case 1: if the last character from left subarray is same as the first character of the right subarray\\nif (s[l.endIdx] == s[r.startIdx]) {\\n  curNode.maxLen = max({l.maxLen, r.maxLen, l.suffixLen + r.prefixLen});\\n\\n  // if all the characters from the left subarray are same, extend the prefixLen\\n  if (l.prefixLen == l.endIdx - l.startIdx + 1) {\\n\\t curNode.prefixLen = l.prefixLen + r.prefixLen;\\n  } else {\\n\\t curNode.prefixLen = l.prefixLen;\\n  }\\n\\n  // if all the characters from the right subarray are same, extend the suffixLen\\n  if (r.suffixLen == r.endIdx - r.startIdx + 1) {\\n    curNode.suffixLen = r.suffixLen + l.suffixLen;\\n  } else {\\n    curNode.suffixLen = r.suffixLen;\\n  }\\n} \\n\\n// Case 2: if the last character from left subarray is NOT same as the first character of the right subarray\\ncurNode.maxLen = max(l.maxLen, r.maxLen);\\ncurNode.prefixLen = l.prefixLen;\\ncurNode.suffixLen = r.suffixLen;\\n\\t\\n// In either case, update the startIdx & endIdx accordingly\\ncurNode.startIdx = l.startIdx;\\ncurNode.endIdx = r.endIdx;\\n  \\n```\n```C++\\nconst int N = 1e5 + 5;\\n\\nstruct Node {\\n  int maxLen;\\n  int startIdx, endIdx;\\n  int prefixLen, suffixLen;\\n  Node(): maxLen(0), startIdx(0), endIdx(0), prefixLen(0), suffixLen(0) {}\\n} segmentTree[4 * N];\\n\\n\\nNode combine(Node &l, Node &r, string &s) {\\n  Node curNode = Node();\\n\\n  if (s[l.endIdx] == s[r.startIdx]) {\\n    curNode.maxLen = max({l.maxLen, r.maxLen, l.suffixLen + r.prefixLen});\\n\\n    if (l.prefixLen == l.endIdx - l.startIdx + 1) {\\n      curNode.prefixLen = l.prefixLen + r.prefixLen;\\n    } else {\\n      curNode.prefixLen = l.prefixLen;\\n    }\\n\\n    if (r.suffixLen == r.endIdx - r.startIdx + 1) {\\n      curNode.suffixLen = r.suffixLen + l.suffixLen;\\n    } else {\\n      curNode.suffixLen = r.suffixLen;\\n    }\\n\\n\\n  } else {\\n    curNode.maxLen = max(l.maxLen, r.maxLen);\\n    curNode.prefixLen = l.prefixLen;\\n    curNode.suffixLen = r.suffixLen;\\n  }\\n\\n  curNode.startIdx = l.startIdx;\\n  curNode.endIdx = r.endIdx;\\n\\n  return curNode;\\n}\\n\\nvoid build(int node, int b, int e, string & s) {\\n  if (b > e) {\\n    return;\\n  }\\n\\n  if (b == e) {\\n    segmentTree[node].maxLen = 1;\\n    segmentTree[node].startIdx = b, segmentTree[node].endIdx = b;\\n    segmentTree[node].prefixLen = 1, segmentTree[node].suffixLen = 1;\\n    return;\\n  }\\n\\n  int l = node << 1, r = l | 1, m = (b + e) >> 1;\\n\\n  build(l, b, m, s);\\n  build(r, m + 1, e, s);\\n\\n  segmentTree[node] = combine(segmentTree[l], segmentTree[r], s);\\n}\\n\\nvoid update(int node, int b, int e, int pos, char ch, string & s) {\\n  if (pos > e || pos < b || b > e) {\\n    return;\\n  }\\n\\n  if (pos == b && b == e) {\\n    s[pos] = ch;\\n    segmentTree[node].maxLen = 1;\\n    segmentTree[node].startIdx = b, segmentTree[node].endIdx = b;\\n    segmentTree[node].prefixLen = 1, segmentTree[node].suffixLen = 1;\\n    return;\\n  }\\n\\n  int l = node << 1, r = l | 1, m = (b + e) >> 1;\\n\\n  if (pos <= m) {\\n    update(l, b, m, pos, ch, s);\\n  } else {\\n    update(r, m + 1, e, pos, ch, s);\\n  }\\n\\n  segmentTree[node] = combine(segmentTree[l], segmentTree[r], s);\\n}\\n\\nclass Solution {\\n  public:\\n    vector <int> longestRepeating(string s, string queryCharacters, vector <int> &queryIndices) {\\n      int len = s.size();\\n\\n      build(1, 0, len - 1, s);\\n\\n      vector <int> ans;\\n      for (int i = 0; i < (int)queryCharacters.size(); i++) {\\n        update(1, 0, len - 1, queryIndices[i], queryCharacters[i], s);\\n        ans.push_back(segmentTree[1].maxLen);\\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1870441,
                "title": "python3-solution-with-simple-types-index-list-counter-no-segment-tree",
                "content": "Keep indices of left segment and counts of segment span after each query operation.\\nSentinel makes logic simpler.\\n\\n```\\nfrom bisect import bisect_right\\nfrom collections import Counter\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        idx = [i for i,(x,y) in enumerate(zip(\\'_\\' + s, s + \\'_\\')) if x != y]\\n        idx, deg = [-1] + idx, Counter(y - x for x,y in zip(idx, idx[1:]))\\n        res, s, best = [], list(s + \\'_\\'), max(deg)\\n        for i,x in zip(queryIndices, queryCharacters):\\n            s[i], k = x, bisect_right(idx, i) - 1\\n            old, idx0 = idx[k-1:k+3], [idx[k], i, i+1, idx[k+1]]\\n            idx0 = [y for x,y in zip(old[:1] + idx0, idx0) if s[x] != s[y] ]\\n            fix = [y - x for x,y in zip(old[:1] + idx0, idx0 + old[3:])]\\n            idx[k:k+2], best0 = idx0, max(fix)\\n            deg.update(fix)\\n\\t\\t\\tfor x,y in zip(old, old[1:]):\\n\\t\\t\\t\\ty -= x\\n\\t\\t\\t\\tif deg[y] == 1:\\n\\t\\t\\t\\t\\tdeg.pop(y)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdeg[y] -= 1\\n            if best <= best0:\\n                best = best0\\n\\t\\t\\telif not deg[best]:\\n\\t\\t\\t\\tbest = max(deg)\\n            res.append(best)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom bisect import bisect_right\\nfrom collections import Counter\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        idx = [i for i,(x,y) in enumerate(zip(\\'_\\' + s, s + \\'_\\')) if x != y]\\n        idx, deg = [-1] + idx, Counter(y - x for x,y in zip(idx, idx[1:]))\\n        res, s, best = [], list(s + \\'_\\'), max(deg)\\n        for i,x in zip(queryIndices, queryCharacters):\\n            s[i], k = x, bisect_right(idx, i) - 1\\n            old, idx0 = idx[k-1:k+3], [idx[k], i, i+1, idx[k+1]]\\n            idx0 = [y for x,y in zip(old[:1] + idx0, idx0) if s[x] != s[y] ]\\n            fix = [y - x for x,y in zip(old[:1] + idx0, idx0 + old[3:])]\\n            idx[k:k+2], best0 = idx0, max(fix)\\n            deg.update(fix)\\n\\t\\t\\tfor x,y in zip(old, old[1:]):\\n\\t\\t\\t\\ty -= x\\n\\t\\t\\t\\tif deg[y] == 1:\\n\\t\\t\\t\\t\\tdeg.pop(y)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tdeg[y] -= 1\\n            if best <= best0:\\n                best = best0\\n\\t\\t\\telif not deg[best]:\\n\\t\\t\\t\\tbest = max(deg)\\n            res.append(best)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867958,
                "title": "segment-tree",
                "content": "Idea :\\n 1. we will have 26 segtree (for 26 characters)\\n 2. segtree node for [L, H] need to save extra info : max prefix matching char \\'c\\', maxsuffix matcing char \\'c\\'.\\n 3. using those info we can easily insert or remove a char \\'c\\' and calculate max contiguous segment of that char.\\n```\\n #define MAX 450000\\nstruct state {\\n    int pref;\\n    int suf;\\n    int val;\\n    int l;\\n    int h;\\n};\\n\\nclass segtree {\\n    private :\\n        state tree[MAX];\\n        int n;\\n    public :\\n        segtree(int n, string s, char ch) {\\n            this->n = n;\\n            make_tree(1, 0, n-1, s, ch);\\n        }\\n         \\n    void make_tree(int idx, int low, int high, const string& s, const char& ch) {\\n        //cout << low << \" \" << high << endl;\\n        if (low == high){\\n            if (s[low] == ch) {\\n                tree[idx].pref = 1;\\n                tree[idx].suf = 1;\\n                tree[idx].val = 1;\\n                tree[idx].l = low;\\n                tree[idx].h = high;\\n            } else {\\n                tree[idx].pref = 0;\\n                tree[idx].suf = 0;\\n                tree[idx].val = 0;\\n                tree[idx].l = low;\\n                tree[idx].h = high;\\n            }\\n            return;\\n        }\\n        int mid =  low + (high - low) / 2;\\n        make_tree(2*idx, low, mid, s, ch);\\n        make_tree(2*idx + 1, mid+1, high, s, ch);\\n        tree[idx].val = max(tree[2*idx].val, tree[2*idx + 1].val);\\n        tree[idx].val = max(tree[idx].val, tree[2*idx].suf + tree[2*idx+1].pref);\\n        tree[idx].l = low;\\n        tree[idx].h = high;\\n        if (tree[idx].val == (high - low + 1)) {\\n            tree[idx].pref = tree[idx].val;\\n            tree[idx].suf = tree[idx].val;\\n        } else {\\n            if (tree[2*idx].pref == (tree[2*idx].h - tree[2*idx].l + 1)) {\\n                tree[idx].pref = tree[2*idx].pref + tree[2*idx+1].pref;\\n            } else {\\n                tree[idx].pref = tree[2*idx].pref;    \\n            }\\n            if (tree[2*idx+1].suf == (tree[2*idx+1].h - tree[2*idx+1].l + 1)) {\\n                tree[idx].suf = tree[2*idx+1].suf + tree[2*idx].suf;\\n            } else {\\n                tree[idx].suf = tree[2*idx+1].suf;    \\n            }\\n            //tree[idx].pref = tree[2*idx].pref;\\n            //tree[idx].suf = tree[2*idx + 1].suf;\\n        }\\n        \\n    }\\n    void update_it(int idx) {\\n        this->update(1, 0, n-1, idx);\\n    }\\n    void remove_it(int idx) {\\n        this->remove(1, 0, n-1, idx);\\n    }\\n    void remove(int idx, int low , int high, const int& index) {\\n        if (low == high && low == index){\\n            tree[idx].pref = 0;\\n            tree[idx].suf = 0;\\n            tree[idx].val = 0;\\n            return;\\n        }\\n        int mid =  low + (high - low) / 2;\\n        if (index <= mid)\\n            remove(2*idx, low, mid, index);\\n        else\\n            remove(2*idx + 1, mid+1, high, index);\\n        \\n        tree[idx].val = max(tree[2*idx].val, tree[2*idx + 1].val);\\n        tree[idx].val = max(tree[idx].val, tree[2*idx].suf + tree[2*idx+1].pref);\\n        tree[idx].l = low;\\n        tree[idx].h = high;\\n        if (tree[idx].val == (high - low + 1)) {\\n            tree[idx].pref = tree[idx].val;\\n            tree[idx].suf = tree[idx].val;\\n        } else {\\n            if (tree[2*idx].pref == (tree[2*idx].h - tree[2*idx].l + 1)) {\\n                tree[idx].pref = tree[2*idx].pref + tree[2*idx+1].pref;\\n            } else {\\n                tree[idx].pref = tree[2*idx].pref;    \\n            }\\n            if (tree[2*idx+1].suf == (tree[2*idx+1].h - tree[2*idx+1].l + 1)) {\\n                tree[idx].suf = tree[2*idx+1].suf + tree[2*idx].suf;\\n            } else {\\n                tree[idx].suf = tree[2*idx+1].suf;    \\n            }\\n            //tree[idx].pref = tree[2*idx].pref;\\n            //tree[idx].suf = tree[2*idx + 1].suf;\\n        }\\n    }\\n    void update(int idx, int low , int high, const int& index) {\\n        if (low == high && low == index){\\n            tree[idx].pref = 1;\\n            tree[idx].suf = 1;\\n            tree[idx].val = 1;\\n            return;\\n        }\\n        int mid =  low + (high - low) / 2;\\n        if (index <= mid)\\n            update(2*idx, low, mid, index);\\n        else\\n            update(2*idx + 1, mid+1, high, index);\\n        \\n        tree[idx].val = max(tree[2*idx].val, tree[2*idx + 1].val);\\n        tree[idx].val = max(tree[idx].val, tree[2*idx].suf + tree[2*idx+1].pref);\\n        tree[idx].l = low;\\n        tree[idx].h = high;\\n        if (tree[idx].val == (high - low + 1)) {\\n            tree[idx].pref = tree[idx].val;\\n            tree[idx].suf = tree[idx].val;\\n        } else {\\n            if (tree[2*idx].pref == (tree[2*idx].h - tree[2*idx].l + 1)) {\\n                tree[idx].pref = tree[2*idx].pref + tree[2*idx+1].pref;\\n            } else {\\n                tree[idx].pref = tree[2*idx].pref;    \\n            }\\n            if (tree[2*idx+1].suf == (tree[2*idx+1].h - tree[2*idx+1].l + 1)) {\\n                tree[idx].suf = tree[2*idx+1].suf + tree[2*idx].suf;\\n            } else {\\n                tree[idx].suf = tree[2*idx+1].suf;    \\n            }\\n            //tree[idx].pref = tree[2*idx].pref;\\n            //tree[idx].suf = tree[2*idx + 1].suf;\\n        }\\n    }\\n    int query() {\\n        return tree[1].val;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        unordered_map<char, segtree*> segtrees;\\n        for(int i=0;i<s.size();i++) {\\n            if (segtrees.find(s[i]) == segtrees.end()) {\\n                segtree* seg = new segtree(s.size(), s, s[i]);\\n                //cout << seg->query() << endl;\\n                segtrees[s[i]] = seg;\\n            }\\n        }\\n        vector<int> Res;\\n        for(int i=0;i<queryCharacters.size();i++) {\\n            char ch = queryCharacters[i];\\n            int idx = queryIndices[i];\\n            segtrees[s[idx]]->remove_it(idx);\\n            if (segtrees.find(ch) == segtrees.end()) {\\n                segtree* seg = new segtree(s.size(), s, ch);\\n                segtrees[ch] = seg;\\n            }\\n            segtree* seg = segtrees[ch];\\n            seg->update_it(idx);\\n            s[idx] = ch;\\n            int res = 0;\\n            for (auto& s : segtrees) {\\n                res = max(res, s.second->query());\\n            }   \\n            Res.push_back(res);\\n        }\\n        return Res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n #define MAX 450000\\nstruct state {\\n    int pref;\\n    int suf;\\n    int val;\\n    int l;\\n    int h;\\n};\\n\\nclass segtree {\\n    private :\\n        state tree[MAX];\\n        int n;\\n    public :\\n        segtree(int n, string s, char ch) {\\n            this->n = n;\\n            make_tree(1, 0, n-1, s, ch);\\n        }\\n         \\n    void make_tree(int idx, int low, int high, const string& s, const char& ch) {\\n        //cout << low << \" \" << high << endl;\\n        if (low == high){\\n            if (s[low] == ch) {\\n                tree[idx].pref = 1;\\n                tree[idx].suf = 1;\\n                tree[idx].val = 1;\\n                tree[idx].l = low;\\n                tree[idx].h = high;\\n            } else {\\n                tree[idx].pref = 0;\\n                tree[idx].suf = 0;\\n                tree[idx].val = 0;\\n                tree[idx].l = low;\\n                tree[idx].h = high;\\n            }\\n            return;\\n        }\\n        int mid =  low + (high - low) / 2;\\n        make_tree(2*idx, low, mid, s, ch);\\n        make_tree(2*idx + 1, mid+1, high, s, ch);\\n        tree[idx].val = max(tree[2*idx].val, tree[2*idx + 1].val);\\n        tree[idx].val = max(tree[idx].val, tree[2*idx].suf + tree[2*idx+1].pref);\\n        tree[idx].l = low;\\n        tree[idx].h = high;\\n        if (tree[idx].val == (high - low + 1)) {\\n            tree[idx].pref = tree[idx].val;\\n            tree[idx].suf = tree[idx].val;\\n        } else {\\n            if (tree[2*idx].pref == (tree[2*idx].h - tree[2*idx].l + 1)) {\\n                tree[idx].pref = tree[2*idx].pref + tree[2*idx+1].pref;\\n            } else {\\n                tree[idx].pref = tree[2*idx].pref;    \\n            }\\n            if (tree[2*idx+1].suf == (tree[2*idx+1].h - tree[2*idx+1].l + 1)) {\\n                tree[idx].suf = tree[2*idx+1].suf + tree[2*idx].suf;\\n            } else {\\n                tree[idx].suf = tree[2*idx+1].suf;    \\n            }\\n            //tree[idx].pref = tree[2*idx].pref;\\n            //tree[idx].suf = tree[2*idx + 1].suf;\\n        }\\n        \\n    }\\n    void update_it(int idx) {\\n        this->update(1, 0, n-1, idx);\\n    }\\n    void remove_it(int idx) {\\n        this->remove(1, 0, n-1, idx);\\n    }\\n    void remove(int idx, int low , int high, const int& index) {\\n        if (low == high && low == index){\\n            tree[idx].pref = 0;\\n            tree[idx].suf = 0;\\n            tree[idx].val = 0;\\n            return;\\n        }\\n        int mid =  low + (high - low) / 2;\\n        if (index <= mid)\\n            remove(2*idx, low, mid, index);\\n        else\\n            remove(2*idx + 1, mid+1, high, index);\\n        \\n        tree[idx].val = max(tree[2*idx].val, tree[2*idx + 1].val);\\n        tree[idx].val = max(tree[idx].val, tree[2*idx].suf + tree[2*idx+1].pref);\\n        tree[idx].l = low;\\n        tree[idx].h = high;\\n        if (tree[idx].val == (high - low + 1)) {\\n            tree[idx].pref = tree[idx].val;\\n            tree[idx].suf = tree[idx].val;\\n        } else {\\n            if (tree[2*idx].pref == (tree[2*idx].h - tree[2*idx].l + 1)) {\\n                tree[idx].pref = tree[2*idx].pref + tree[2*idx+1].pref;\\n            } else {\\n                tree[idx].pref = tree[2*idx].pref;    \\n            }\\n            if (tree[2*idx+1].suf == (tree[2*idx+1].h - tree[2*idx+1].l + 1)) {\\n                tree[idx].suf = tree[2*idx+1].suf + tree[2*idx].suf;\\n            } else {\\n                tree[idx].suf = tree[2*idx+1].suf;    \\n            }\\n            //tree[idx].pref = tree[2*idx].pref;\\n            //tree[idx].suf = tree[2*idx + 1].suf;\\n        }\\n    }\\n    void update(int idx, int low , int high, const int& index) {\\n        if (low == high && low == index){\\n            tree[idx].pref = 1;\\n            tree[idx].suf = 1;\\n            tree[idx].val = 1;\\n            return;\\n        }\\n        int mid =  low + (high - low) / 2;\\n        if (index <= mid)\\n            update(2*idx, low, mid, index);\\n        else\\n            update(2*idx + 1, mid+1, high, index);\\n        \\n        tree[idx].val = max(tree[2*idx].val, tree[2*idx + 1].val);\\n        tree[idx].val = max(tree[idx].val, tree[2*idx].suf + tree[2*idx+1].pref);\\n        tree[idx].l = low;\\n        tree[idx].h = high;\\n        if (tree[idx].val == (high - low + 1)) {\\n            tree[idx].pref = tree[idx].val;\\n            tree[idx].suf = tree[idx].val;\\n        } else {\\n            if (tree[2*idx].pref == (tree[2*idx].h - tree[2*idx].l + 1)) {\\n                tree[idx].pref = tree[2*idx].pref + tree[2*idx+1].pref;\\n            } else {\\n                tree[idx].pref = tree[2*idx].pref;    \\n            }\\n            if (tree[2*idx+1].suf == (tree[2*idx+1].h - tree[2*idx+1].l + 1)) {\\n                tree[idx].suf = tree[2*idx+1].suf + tree[2*idx].suf;\\n            } else {\\n                tree[idx].suf = tree[2*idx+1].suf;    \\n            }\\n            //tree[idx].pref = tree[2*idx].pref;\\n            //tree[idx].suf = tree[2*idx + 1].suf;\\n        }\\n    }\\n    int query() {\\n        return tree[1].val;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        unordered_map<char, segtree*> segtrees;\\n        for(int i=0;i<s.size();i++) {\\n            if (segtrees.find(s[i]) == segtrees.end()) {\\n                segtree* seg = new segtree(s.size(), s, s[i]);\\n                //cout << seg->query() << endl;\\n                segtrees[s[i]] = seg;\\n            }\\n        }\\n        vector<int> Res;\\n        for(int i=0;i<queryCharacters.size();i++) {\\n            char ch = queryCharacters[i];\\n            int idx = queryIndices[i];\\n            segtrees[s[idx]]->remove_it(idx);\\n            if (segtrees.find(ch) == segtrees.end()) {\\n                segtree* seg = new segtree(s.size(), s, ch);\\n                segtrees[ch] = seg;\\n            }\\n            segtree* seg = segtrees[ch];\\n            seg->update_it(idx);\\n            s[idx] = ch;\\n            int res = 0;\\n            for (auto& s : segtrees) {\\n                res = max(res, s.second->query());\\n            }   \\n            Res.push_back(res);\\n        }\\n        return Res;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1867682,
                "title": "python-3-sortedlist-needs-optimization-with-comments",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        \\n        s = list(s)\\n        loc = defaultdict(lambda: SortedList()) # segment offsets (start, end) stored by character\\n        max_len = SortedList() # segment length stored by character\\n\\n        i = 0\\n        while i < len(s):\\n            j = i\\n            while j < len(s) and s[i] == s[j]:\\n                j += 1\\n            loc[s[i]].add((i, j-1))\\n            max_len.add(j - i)\\n            i = j\\n            \\n        # helper function to remove segment\\n        def del_seg(w, old_l, old_r):\\n            loc[w].remove((old_l, old_r))\\n            max_len.remove(old_r - old_l + 1)\\n        \\n        # helper function to add segment\\n        def add_seg(w, new_l, new_r):\\n            loc[w].add((new_l, new_r))\\n            max_len.add(new_r - new_l + 1)\\n\\n        ans = [0] * len(queryIndices)\\n        for k in range(len(queryIndices)):\\n            old, new = s[queryIndices[k]], queryCharacters[k]\\n            s[queryIndices[k]] = new\\n            pos = (queryIndices[k], queryIndices[k])\\n\\n            # old segment delete\\n            if pos in loc[old]:\\n                del_seg(old, *pos)\\n            else:\\n                l1 = bisect.bisect_left(loc[old], pos)\\n                if l1 == 0:\\n                    old_pos = loc[old][l1]\\n                    l, r = old_pos\\n                    del_seg(old, *old_pos)\\n                    add_seg(old, l + 1, r)\\n                elif l1 == len(loc[old]):\\n                    old_pos = loc[old][l1-1]\\n                    l, r = old_pos\\n                    del_seg(old, *old_pos)\\n                    if pos[0] == r:\\n                        add_seg(old, l, r-1)\\n                    else:\\n                        add_seg(old, l, pos[0]-1)\\n                        add_seg(old, pos[0] + 1, r)\\n                else:\\n                    a, b = loc[old][l1 - 1]\\n                    c, d = loc[old][l1]\\n                    if pos[0] == b:\\n                        del_seg(old, a, b)\\n                        add_seg(old, a, b-1)\\n                    elif pos[0] == c:\\n                        del_seg(old, c, d)\\n                        add_seg(old, c+1, d)\\n                    elif pos[0] < b:\\n                        del_seg(old, a, b)\\n                        add_seg(old, a, pos[0]-1)\\n                        add_seg(old, pos[0]+1, b)\\n                    elif pos[0] > c:\\n                        del_seg(old, c, d)\\n                        add_seg(old, c, pos[0]-1)\\n                        add_seg(old, pos[0]+1, d)\\n\\n            # new segment insert\\n            if not loc[new]:\\n                add_seg(new, *pos)\\n                ans[k] = max_len[-1]\\n                continue\\n            l2 = bisect.bisect_left(loc[new], pos)\\n            if l2 == 0:\\n                l, r = loc[new][l2]\\n                if l - pos[0] > 1:\\n                    add_seg(new, *pos)\\n                else:\\n                    del_seg(new, l, r)\\n                    add_seg(new, pos[0], r)\\n\\n            elif l2 == len(loc[new]):\\n                l, r = loc[new][l2 - 1]\\n                if pos[0] - r > 1:\\n                    add_seg(new, *pos)\\n                else:\\n                    del_seg(new, l, r)\\n                    add_seg(new, l, pos[0])\\n            else:\\n                a, b = loc[new][l2 - 1]\\n                c, d = loc[new][l2]\\n                if pos[0] - b == 1 and c - pos[0] == 1:\\n                    del_seg(new, a, b)\\n                    del_seg(new, c, d)\\n                    add_seg(new, a, d)\\n                elif pos[0] - b == 1:\\n                    del_seg(new, a, b)\\n                    add_seg(new, a, pos[0])\\n                elif c - pos[0] == 1:\\n                    del_seg(new, c, d)\\n                    add_seg(new, pos[0], d)\\n                else:\\n                    add_seg(new, *pos)\\n            ans[k] = max_len[-1]\\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        \\n        s = list(s)\\n        loc = defaultdict(lambda: SortedList()) # segment offsets (start, end) stored by character\\n        max_len = SortedList() # segment length stored by character\\n\\n        i = 0\\n        while i < len(s):\\n            j = i\\n            while j < len(s) and s[i] == s[j]:\\n                j += 1\\n            loc[s[i]].add((i, j-1))\\n            max_len.add(j - i)\\n            i = j\\n            \\n        # helper function to remove segment\\n        def del_seg(w, old_l, old_r):\\n            loc[w].remove((old_l, old_r))\\n            max_len.remove(old_r - old_l + 1)\\n        \\n        # helper function to add segment\\n        def add_seg(w, new_l, new_r):\\n            loc[w].add((new_l, new_r))\\n            max_len.add(new_r - new_l + 1)\\n\\n        ans = [0] * len(queryIndices)\\n        for k in range(len(queryIndices)):\\n            old, new = s[queryIndices[k]], queryCharacters[k]\\n            s[queryIndices[k]] = new\\n            pos = (queryIndices[k], queryIndices[k])\\n\\n            # old segment delete\\n            if pos in loc[old]:\\n                del_seg(old, *pos)\\n            else:\\n                l1 = bisect.bisect_left(loc[old], pos)\\n                if l1 == 0:\\n                    old_pos = loc[old][l1]\\n                    l, r = old_pos\\n                    del_seg(old, *old_pos)\\n                    add_seg(old, l + 1, r)\\n                elif l1 == len(loc[old]):\\n                    old_pos = loc[old][l1-1]\\n                    l, r = old_pos\\n                    del_seg(old, *old_pos)\\n                    if pos[0] == r:\\n                        add_seg(old, l, r-1)\\n                    else:\\n                        add_seg(old, l, pos[0]-1)\\n                        add_seg(old, pos[0] + 1, r)\\n                else:\\n                    a, b = loc[old][l1 - 1]\\n                    c, d = loc[old][l1]\\n                    if pos[0] == b:\\n                        del_seg(old, a, b)\\n                        add_seg(old, a, b-1)\\n                    elif pos[0] == c:\\n                        del_seg(old, c, d)\\n                        add_seg(old, c+1, d)\\n                    elif pos[0] < b:\\n                        del_seg(old, a, b)\\n                        add_seg(old, a, pos[0]-1)\\n                        add_seg(old, pos[0]+1, b)\\n                    elif pos[0] > c:\\n                        del_seg(old, c, d)\\n                        add_seg(old, c, pos[0]-1)\\n                        add_seg(old, pos[0]+1, d)\\n\\n            # new segment insert\\n            if not loc[new]:\\n                add_seg(new, *pos)\\n                ans[k] = max_len[-1]\\n                continue\\n            l2 = bisect.bisect_left(loc[new], pos)\\n            if l2 == 0:\\n                l, r = loc[new][l2]\\n                if l - pos[0] > 1:\\n                    add_seg(new, *pos)\\n                else:\\n                    del_seg(new, l, r)\\n                    add_seg(new, pos[0], r)\\n\\n            elif l2 == len(loc[new]):\\n                l, r = loc[new][l2 - 1]\\n                if pos[0] - r > 1:\\n                    add_seg(new, *pos)\\n                else:\\n                    del_seg(new, l, r)\\n                    add_seg(new, l, pos[0])\\n            else:\\n                a, b = loc[new][l2 - 1]\\n                c, d = loc[new][l2]\\n                if pos[0] - b == 1 and c - pos[0] == 1:\\n                    del_seg(new, a, b)\\n                    del_seg(new, c, d)\\n                    add_seg(new, a, d)\\n                elif pos[0] - b == 1:\\n                    del_seg(new, a, b)\\n                    add_seg(new, a, pos[0])\\n                elif c - pos[0] == 1:\\n                    del_seg(new, c, d)\\n                    add_seg(new, pos[0], d)\\n                else:\\n                    add_seg(new, *pos)\\n            ans[k] = max_len[-1]\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1866090,
                "title": "c-segment-merge-split",
                "content": "```\\nclass Solution {\\n    struct Record {\\n        int idx;\\n        int len;\\n    };\\npublic:\\n    vector<int> longestRepeating(string s, string query_chars, vector<int>& query_inds) {\\n        // Add sentinels to ensure there\\'s always `prev` and `next` segments.\\n        s = \"^\" + s + \"$\";\\n        \\n        std::map<int, Record> records_ord;\\n        std::multiset<int> segment_lens;\\n        \\n        // Build initial segments.\\n        {\\n            int i = 0;\\n            while (i < s.size()) {\\n                int j = i;\\n                for (; j < s.size(); ++j) {\\n                    if (s[j] != s[i]) {\\n                        break;\\n                    }\\n                }\\n                records_ord.insert({\\n                    i, Record{.idx = i, .len = j - i}\\n                });\\n                segment_lens.insert(j - i);\\n                i = j;\\n            }\\n        }\\n        \\n        std::vector<int> tbl_max_segment_lens(query_chars.size(), 0);\\n        for (int pos = 0; pos < query_chars.size(); ++pos) {\\n            const char ch = query_chars[pos];\\n            // Shifted by one due for sentinel.\\n            const int idx = query_inds[pos] + 1;\\n            if (ch == s[idx]) {\\n                tbl_max_segment_lens[pos] = *segment_lens.rbegin();\\n                continue;\\n            }\\n            s[idx] = ch;\\n            \\n            // Find the segment that includes this query.\\n            const auto it = std::prev(records_ord.upper_bound(idx));\\n            const int i = it->second.idx, j = it->second.idx + it->second.len - 1;\\n            assert((i <= idx) && (idx <= j));\\n            segment_lens.erase(segment_lens.find(it->second.len)); \\n\\t\\t\\t\\n\\t\\t\\t// Find adjacent segments.\\n            const auto it_prev = std::prev(it), it_next = std::next(it);\\n            records_ord.erase(it);                        \\n            \\n            Record curr {.idx = idx, .len = 1};\\n\\n            // Merge or split left.\\n            if ((i == idx) && (s[it_prev->second.idx] == ch)) {\\n                curr.len += it_prev->second.len;\\n                curr.idx = it_prev->second.idx;\\n                segment_lens.erase(segment_lens.find(it_prev->second.len));\\n                records_ord.erase(it_prev);                \\n            } else if (i < idx) {\\n                records_ord.insert({i, Record{.idx = i, .len = idx - i}});\\n                segment_lens.insert(idx - i);                \\n            }\\n            \\n            // Merge or split right.\\n            if ((j == idx) && (s[it_next->second.idx] == ch)) {\\n                curr.len += it_next->second.len;\\n                segment_lens.erase(segment_lens.find(it_next->second.len));\\n                records_ord.erase(it_next);\\n            } else if (idx < j) {\\n                records_ord.insert({idx + 1, Record{.idx = idx + 1, .len = j - idx}});\\n                segment_lens.insert(j - idx);                \\n            }\\n\\n            records_ord.insert({curr.idx, curr});\\n            segment_lens.insert(curr.len);\\n            \\n            tbl_max_segment_lens[pos] = *segment_lens.rbegin();\\n        }\\n        return tbl_max_segment_lens;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    struct Record {\\n        int idx;\\n        int len;\\n    };\\npublic:\\n    vector<int> longestRepeating(string s, string query_chars, vector<int>& query_inds) {\\n        // Add sentinels to ensure there\\'s always `prev` and `next` segments.\\n        s = \"^\" + s + \"$\";\\n        \\n        std::map<int, Record> records_ord;\\n        std::multiset<int> segment_lens;\\n        \\n        // Build initial segments.\\n        {\\n            int i = 0;\\n            while (i < s.size()) {\\n                int j = i;\\n                for (; j < s.size(); ++j) {\\n                    if (s[j] != s[i]) {\\n                        break;\\n                    }\\n                }\\n                records_ord.insert({\\n                    i, Record{.idx = i, .len = j - i}\\n                });\\n                segment_lens.insert(j - i);\\n                i = j;\\n            }\\n        }\\n        \\n        std::vector<int> tbl_max_segment_lens(query_chars.size(), 0);\\n        for (int pos = 0; pos < query_chars.size(); ++pos) {\\n            const char ch = query_chars[pos];\\n            // Shifted by one due for sentinel.\\n            const int idx = query_inds[pos] + 1;\\n            if (ch == s[idx]) {\\n                tbl_max_segment_lens[pos] = *segment_lens.rbegin();\\n                continue;\\n            }\\n            s[idx] = ch;\\n            \\n            // Find the segment that includes this query.\\n            const auto it = std::prev(records_ord.upper_bound(idx));\\n            const int i = it->second.idx, j = it->second.idx + it->second.len - 1;\\n            assert((i <= idx) && (idx <= j));\\n            segment_lens.erase(segment_lens.find(it->second.len)); \\n\\t\\t\\t\\n\\t\\t\\t// Find adjacent segments.\\n            const auto it_prev = std::prev(it), it_next = std::next(it);\\n            records_ord.erase(it);                        \\n            \\n            Record curr {.idx = idx, .len = 1};\\n\\n            // Merge or split left.\\n            if ((i == idx) && (s[it_prev->second.idx] == ch)) {\\n                curr.len += it_prev->second.len;\\n                curr.idx = it_prev->second.idx;\\n                segment_lens.erase(segment_lens.find(it_prev->second.len));\\n                records_ord.erase(it_prev);                \\n            } else if (i < idx) {\\n                records_ord.insert({i, Record{.idx = i, .len = idx - i}});\\n                segment_lens.insert(idx - i);                \\n            }\\n            \\n            // Merge or split right.\\n            if ((j == idx) && (s[it_next->second.idx] == ch)) {\\n                curr.len += it_next->second.len;\\n                segment_lens.erase(segment_lens.find(it_next->second.len));\\n                records_ord.erase(it_next);\\n            } else if (idx < j) {\\n                records_ord.insert({idx + 1, Record{.idx = idx + 1, .len = j - idx}});\\n                segment_lens.insert(j - idx);                \\n            }\\n\\n            records_ord.insert({curr.idx, curr});\\n            segment_lens.insert(curr.len);\\n            \\n            tbl_max_segment_lens[pos] = *segment_lens.rbegin();\\n        }\\n        return tbl_max_segment_lens;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865949,
                "title": "c-o-n-logn-using-set-for-segments-and-multisets-for-each-character",
                "content": "I will use a set which will store indices and lengths of same character string. In simple terms it will store segments of our string where one segment only contains 1 character.\\nFor example if the string is `babacc`\\nThen the set will store\\n{(0, 1), (1, 1), (2, 1), (3, 1), (4, 2)}\\nThis will allow us to quickly search the query index in logn time and then we can also modify the set by inserting new elements.\\nAs a result, we gain binary search speeds and the ability to insert new items also in O(logn) time.\\n\\nWhen the program runs we the following results in between\\ns: bbbacc\\nset st - `0: 3, 3: 1, 4: 2`\\ns: bbbccc\\nset st - `0: 3, 3: 3`\\ns: bbbbcc\\nset st - `0: 4, 4: 2`\\n\\nWe\\'ll also require multiset to keep track of the lengths of substrings with just one character (i.e. lengths of segments).\\nWe\\'ll need one multiset for each character and a total of 26 multisets.\\nSo, vec[ch] = multiset containing lengths of all segments containing character ch\\nThen, in (26 * logn) time = O(logn) time, we can find the maximum length of a segment.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        // Formation of initial set\\n        int n = s.size();\\n        vector<pair<char, int>> compressed;\\n        compressed.push_back({s[0], 1});\\n        for (int i = 1; i < n; i++) {\\n            if (compressed.back().first == s[i]) {\\n                compressed.back().second += 1;\\n            } else {\\n                compressed.push_back({s[i], 1});\\n            }\\n        }\\n\\n        set<pair<int, int>> st;\\n        int cur_i = 0;\\n        for (auto [ch, f]: compressed) {\\n            st.insert({cur_i, f});\\n            cur_i += f;\\n        }\\n        \\n        // One multiset for each character\\n\\t\\t// vec[ch] will store lengths of all segments with containing character ch\\n        vector<multiset<int>> vec(26);\\n        for (auto [i, len]: st) {\\n            vec[s[i] - \\'a\\'].insert(len);\\n        }\\n\\t\\t  \\n        vector<int> ans;\\n        int k = queryCharacters.size();\\n        for (int j = 0; j < k; j++) {\\n            char q_ch = queryCharacters[j];\\n            int q_i = queryIndices[j];\\n            \\n            auto it = st.upper_bound({q_i, INT_MAX});\\n            assert(it != st.begin());\\n            it--;\\n            \\n            auto [i, len] = *it;\\n            \\n            vector<pair<int, int>> to_remove;\\n            vector<pair<int, int>> to_push;\\n            \\n            if (q_ch == s[q_i]) {\\n                // do nothing\\n            } else {\\n                // break the continuos elements\\n                to_remove.push_back(*it);\\n                \\n                if (len == 1 && i > 0 && q_ch == s[i - 1] && i + len < n && q_ch == s[i + len]) {\\n                    // Merge 3 segments\\n                    auto it2 = prev(it);\\n                    auto it3 = next(it);\\n                    to_push.push_back({it2->first, it2->second + 1 + it3->second});\\n\\n                    to_remove.push_back(*it2);\\n                    to_remove.push_back(*it3);\\n                } else if (q_i == i && i > 0 && q_ch == s[i - 1]) {\\n                    // Merge 2 segments and insert 1 new segment\\n                    auto it2 = prev(it);\\n                    to_remove.push_back(*it2);\\n                    to_push.push_back({it2->first, it2->second + 1});\\n                    \\n                    to_push.push_back({i + 1, len - 1});\\n                } else if (q_i == i + len - 1 && i + len < n && q_ch == s[i + len]) {\\n                    // Merge 2 segments and insert 1 new segment\\n                    auto it2 = next(it);\\n                    assert(it2->first - 1 == q_i);\\n                    to_remove.push_back(*it2);\\n                    to_push.push_back({it2->first - 1, it2->second + 1});\\n                    \\n                    to_push.push_back({i, len - 1});\\n                } else {\\n                    // Insert 3 new segments\\n                    to_push.push_back({i, q_i - i});\\n                    to_push.push_back({q_i, 1});\\n                    to_push.push_back({q_i + 1, len - 1 - (q_i - i)});\\n                }\\n            }\\n            \\n\\t\\t\\t// Removing segments\\n            for (auto [i2, len2]: to_remove) {\\n                st.erase({i2, len2});\\n                auto it4 = vec[s[i2] - \\'a\\'].find(len2);\\n                vec[s[i2] - \\'a\\'].erase(it4);\\n            }\\n            \\n            s[q_i] = q_ch;\\n\\n\\t\\t\\t// Inserting all new segments\\n            for (auto [i2, len2]: to_push) {\\n                if (len2 > 0) {\\n                    st.insert({i2, len2});\\n                    vec[s[i2] - \\'a\\'].insert(len2);\\n                }\\n            }\\n            \\n\\t\\t\\t// For debug\\n            // cout << s << endl;\\n            // cout << st.size() << endl;\\n            // for (auto [z, z2]: st) {\\n            //     cout << z << \": \" << z2 << \", \";\\n            // }\\n            // cout << endl;\\n\\n\\t\\t\\t// Find the segment with max length\\n            int temp_ans = 0;\\n            for (int x = 0; x < 26; x++) {\\n                if (vec[x].size() > 0) {\\n                    auto it3 = prev(vec[x].end());\\n                    temp_ans = max(temp_ans, *it3);\\n                }\\n            }\\n            ans.push_back(temp_ans);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        // Formation of initial set\\n        int n = s.size();\\n        vector<pair<char, int>> compressed;\\n        compressed.push_back({s[0], 1});\\n        for (int i = 1; i < n; i++) {\\n            if (compressed.back().first == s[i]) {\\n                compressed.back().second += 1;\\n            } else {\\n                compressed.push_back({s[i], 1});\\n            }\\n        }\\n\\n        set<pair<int, int>> st;\\n        int cur_i = 0;\\n        for (auto [ch, f]: compressed) {\\n            st.insert({cur_i, f});\\n            cur_i += f;\\n        }\\n        \\n        // One multiset for each character\\n\\t\\t// vec[ch] will store lengths of all segments with containing character ch\\n        vector<multiset<int>> vec(26);\\n        for (auto [i, len]: st) {\\n            vec[s[i] - \\'a\\'].insert(len);\\n        }\\n\\t\\t  \\n        vector<int> ans;\\n        int k = queryCharacters.size();\\n        for (int j = 0; j < k; j++) {\\n            char q_ch = queryCharacters[j];\\n            int q_i = queryIndices[j];\\n            \\n            auto it = st.upper_bound({q_i, INT_MAX});\\n            assert(it != st.begin());\\n            it--;\\n            \\n            auto [i, len] = *it;\\n            \\n            vector<pair<int, int>> to_remove;\\n            vector<pair<int, int>> to_push;\\n            \\n            if (q_ch == s[q_i]) {\\n                // do nothing\\n            } else {\\n                // break the continuos elements\\n                to_remove.push_back(*it);\\n                \\n                if (len == 1 && i > 0 && q_ch == s[i - 1] && i + len < n && q_ch == s[i + len]) {\\n                    // Merge 3 segments\\n                    auto it2 = prev(it);\\n                    auto it3 = next(it);\\n                    to_push.push_back({it2->first, it2->second + 1 + it3->second});\\n\\n                    to_remove.push_back(*it2);\\n                    to_remove.push_back(*it3);\\n                } else if (q_i == i && i > 0 && q_ch == s[i - 1]) {\\n                    // Merge 2 segments and insert 1 new segment\\n                    auto it2 = prev(it);\\n                    to_remove.push_back(*it2);\\n                    to_push.push_back({it2->first, it2->second + 1});\\n                    \\n                    to_push.push_back({i + 1, len - 1});\\n                } else if (q_i == i + len - 1 && i + len < n && q_ch == s[i + len]) {\\n                    // Merge 2 segments and insert 1 new segment\\n                    auto it2 = next(it);\\n                    assert(it2->first - 1 == q_i);\\n                    to_remove.push_back(*it2);\\n                    to_push.push_back({it2->first - 1, it2->second + 1});\\n                    \\n                    to_push.push_back({i, len - 1});\\n                } else {\\n                    // Insert 3 new segments\\n                    to_push.push_back({i, q_i - i});\\n                    to_push.push_back({q_i, 1});\\n                    to_push.push_back({q_i + 1, len - 1 - (q_i - i)});\\n                }\\n            }\\n            \\n\\t\\t\\t// Removing segments\\n            for (auto [i2, len2]: to_remove) {\\n                st.erase({i2, len2});\\n                auto it4 = vec[s[i2] - \\'a\\'].find(len2);\\n                vec[s[i2] - \\'a\\'].erase(it4);\\n            }\\n            \\n            s[q_i] = q_ch;\\n\\n\\t\\t\\t// Inserting all new segments\\n            for (auto [i2, len2]: to_push) {\\n                if (len2 > 0) {\\n                    st.insert({i2, len2});\\n                    vec[s[i2] - \\'a\\'].insert(len2);\\n                }\\n            }\\n            \\n\\t\\t\\t// For debug\\n            // cout << s << endl;\\n            // cout << st.size() << endl;\\n            // for (auto [z, z2]: st) {\\n            //     cout << z << \": \" << z2 << \", \";\\n            // }\\n            // cout << endl;\\n\\n\\t\\t\\t// Find the segment with max length\\n            int temp_ans = 0;\\n            for (int x = 0; x < 26; x++) {\\n                if (vec[x].size() > 0) {\\n                    auto it3 = prev(vec[x].end());\\n                    temp_ans = max(temp_ans, *it3);\\n                }\\n            }\\n            ans.push_back(temp_ans);\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1865650,
                "title": "java-treemap-split-and-merge",
                "content": "Idea :\\n1. Split and merge the treemap while maintaining the size of each segment\\n2. We will use an additional hashMap to maintaining the size of each segment. Use heap to get the maximum length\\n\\n```\\nclass Solution {\\n    TreeMap<Integer, int[]> tree = new TreeMap<>();\\n    Map<Integer, Integer> f = new HashMap<>();\\n    PriorityQueue<Integer>pq=new PriorityQueue<>((a, b)->{\\n        return b - a;\\n    });\\n    public int[] longestRepeating(String s, String t, int[] q) {\\n        tree.put(-1, new int[]{0, -1});\\n        tree.put(10000000, new int[]{0, -1});\\n        int k = q.length;\\n        int res[] = new int[k];\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            int j = i;\\n            while(j < s.length() && s.charAt(i) == s.charAt(j)) {\\n                j++;\\n            }\\n            int c = s.charAt(i) - \\'a\\';\\n            tree.put(i, new int[]{j - 1, c});\\n            int size = (j - 1) - (i) + 1;\\n            pq.add(size);\\n            add(f,size);\\n            i = j - 1;\\n        }\\n        \\n        char a[] = s.toCharArray();\\n        for(int i = 0; i < t.length(); i++) {\\n            int index = q[i];\\n            if(a[index] != t.charAt(i)) {\\n                a[index] = t.charAt(i);\\n                int val = a[index] - \\'a\\';\\n                update(index, val);\\n            }\\n            \\n            while(pq.size() > 0 && !f.containsKey(pq.peek())) {\\n                pq.poll();\\n            }\\n            res[i] = pq.peek();\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void update(int index, int val) {\\n        Integer ceil = tree.floorKey(index);\\n        int pair[] = tree.get(ceil);\\n        int size = (pair[0] - ceil + 1);\\n        tree.remove(ceil);\\n        del(f,size);\\n        \\n        int l1 = ceil, r1 = index - 1;\\n        if(l1 <= r1) {\\n            tree.put(l1, new int[]{r1, pair[1]});\\n            add(f, r1 - l1 + 1);\\n            pq.add(r1 - l1 + 1);\\n        }\\n        int l2 = index + 1, r2 = pair[0];\\n        if(l2 <= r2) {\\n            tree.put(l2, new int[]{r2, pair[1]});\\n            add(f, r2 - l2 + 1);\\n            pq.add(r2 - l2 + 1);\\n        }\\n        \\n        pq.add(1);\\n        add(f, 1);\\n        tree.put(index, new int[]{index, val});\\n        \\n        //merge\\n        pair = tree.get(index);\\n        Integer low = tree.lowerKey(index);\\n        Integer high = tree.higherKey(index);\\n        \\n        int pair1[] = tree.get(low);\\n        int pair2[] = tree.get(high);\\n\\n        if(pair[1] == pair1[1] && pair[1] == pair2[1]) {\\n            int s1 = 1;\\n            int s2 = pair1[0] - low + 1;\\n            int s3 = pair2[0] - high  + 1;\\n            del(f,s1);del(f,s2);del(f,s3);\\n            tree.remove(low);tree.remove(high);tree.remove(index);\\n            tree.put(low, new int[]{pair2[0], pair[1]});\\n            int s = pair2[0] - low + 1;\\n            add(f, s);\\n            pq.add(s);\\n        }\\n        else if(pair[1] == pair1[1]) {\\n            int s1 = 1;\\n            int s2 = pair1[0] - low + 1;\\n            del(f,s1);del(f,s2);\\n            tree.remove(low);tree.remove(index);\\n            tree.put(low, new int[]{index, pair[1]});\\n            int s = index - low + 1;\\n            add(f, s);\\n            pq.add(s);\\n        }\\n        else if(pair[1] == pair2[1]) {\\n            int s1 = 1;\\n            int s2 = pair2[0] - high  + 1;\\n            del(f,s1);del(f,s2);\\n            tree.remove(high);tree.remove(index);\\n            tree.put(index, new int[]{pair2[0], pair[1]});\\n            int s = pair2[0] - index + 1;\\n            add(f, s);\\n            pq.add(s);\\n        }   \\n    }\\n    \\n    public void add(Map<Integer, Integer> f, int key) {\\n        Integer cnt = f.get(key);\\n        if(cnt == null) {\\n            f.put(key, 1);\\n        } else {\\n            f.put(key, cnt + 1);\\n        }\\n    }\\n\\n    public void del(Map<Integer, Integer> f, int key) {\\n        Integer cnt = f.get(key);\\n        if(cnt == 1) {\\n            f.remove(key);\\n        } else {\\n            f.put(key, cnt - 1);\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    TreeMap<Integer, int[]> tree = new TreeMap<>();\\n    Map<Integer, Integer> f = new HashMap<>();\\n    PriorityQueue<Integer>pq=new PriorityQueue<>((a, b)->{\\n        return b - a;\\n    });\\n    public int[] longestRepeating(String s, String t, int[] q) {\\n        tree.put(-1, new int[]{0, -1});\\n        tree.put(10000000, new int[]{0, -1});\\n        int k = q.length;\\n        int res[] = new int[k];\\n        \\n        for(int i = 0; i < s.length(); i++) {\\n            int j = i;\\n            while(j < s.length() && s.charAt(i) == s.charAt(j)) {\\n                j++;\\n            }\\n            int c = s.charAt(i) - \\'a\\';\\n            tree.put(i, new int[]{j - 1, c});\\n            int size = (j - 1) - (i) + 1;\\n            pq.add(size);\\n            add(f,size);\\n            i = j - 1;\\n        }\\n        \\n        char a[] = s.toCharArray();\\n        for(int i = 0; i < t.length(); i++) {\\n            int index = q[i];\\n            if(a[index] != t.charAt(i)) {\\n                a[index] = t.charAt(i);\\n                int val = a[index] - \\'a\\';\\n                update(index, val);\\n            }\\n            \\n            while(pq.size() > 0 && !f.containsKey(pq.peek())) {\\n                pq.poll();\\n            }\\n            res[i] = pq.peek();\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public void update(int index, int val) {\\n        Integer ceil = tree.floorKey(index);\\n        int pair[] = tree.get(ceil);\\n        int size = (pair[0] - ceil + 1);\\n        tree.remove(ceil);\\n        del(f,size);\\n        \\n        int l1 = ceil, r1 = index - 1;\\n        if(l1 <= r1) {\\n            tree.put(l1, new int[]{r1, pair[1]});\\n            add(f, r1 - l1 + 1);\\n            pq.add(r1 - l1 + 1);\\n        }\\n        int l2 = index + 1, r2 = pair[0];\\n        if(l2 <= r2) {\\n            tree.put(l2, new int[]{r2, pair[1]});\\n            add(f, r2 - l2 + 1);\\n            pq.add(r2 - l2 + 1);\\n        }\\n        \\n        pq.add(1);\\n        add(f, 1);\\n        tree.put(index, new int[]{index, val});\\n        \\n        //merge\\n        pair = tree.get(index);\\n        Integer low = tree.lowerKey(index);\\n        Integer high = tree.higherKey(index);\\n        \\n        int pair1[] = tree.get(low);\\n        int pair2[] = tree.get(high);\\n\\n        if(pair[1] == pair1[1] && pair[1] == pair2[1]) {\\n            int s1 = 1;\\n            int s2 = pair1[0] - low + 1;\\n            int s3 = pair2[0] - high  + 1;\\n            del(f,s1);del(f,s2);del(f,s3);\\n            tree.remove(low);tree.remove(high);tree.remove(index);\\n            tree.put(low, new int[]{pair2[0], pair[1]});\\n            int s = pair2[0] - low + 1;\\n            add(f, s);\\n            pq.add(s);\\n        }\\n        else if(pair[1] == pair1[1]) {\\n            int s1 = 1;\\n            int s2 = pair1[0] - low + 1;\\n            del(f,s1);del(f,s2);\\n            tree.remove(low);tree.remove(index);\\n            tree.put(low, new int[]{index, pair[1]});\\n            int s = index - low + 1;\\n            add(f, s);\\n            pq.add(s);\\n        }\\n        else if(pair[1] == pair2[1]) {\\n            int s1 = 1;\\n            int s2 = pair2[0] - high  + 1;\\n            del(f,s1);del(f,s2);\\n            tree.remove(high);tree.remove(index);\\n            tree.put(index, new int[]{pair2[0], pair[1]});\\n            int s = pair2[0] - index + 1;\\n            add(f, s);\\n            pq.add(s);\\n        }   \\n    }\\n    \\n    public void add(Map<Integer, Integer> f, int key) {\\n        Integer cnt = f.get(key);\\n        if(cnt == null) {\\n            f.put(key, 1);\\n        } else {\\n            f.put(key, cnt + 1);\\n        }\\n    }\\n\\n    public void del(Map<Integer, Integer> f, int key) {\\n        Integer cnt = f.get(key);\\n        if(cnt == 1) {\\n            f.remove(key);\\n        } else {\\n            f.put(key, cnt - 1);\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865562,
                "title": "segment-tree-solution",
                "content": "Using Segment tree\\nEvery node we record left_continue,right_continue,left_char,right_char,max_continue_len\\n\\nleft_continue => the len of only one repeating prefix string from left\\nright_continue => the len of only one repeating suffix string from right\\nleft_char => the left char of this node\\nright_char => the right char of this node\\nmax_continue_len => the max len of only one repeating substring in this node\\n\\nWhen we merge two node, we update current node\\'s max len of only one repeating substring by it left node and right node\\n\\nLater we check if left node right char is same with right node left char\\nIf they are same then we try update max len of only one repeating substring, left_continue and right_continue\\n\\n```cpp\\nclass Solution {\\npublic:\\n    static const int maxn=1e5+10;\\n    int n;\\n    string s;\\n    struct Node\\n    {\\n        char left,right;\\n        int left_conti,right_conti,len,mx;\\n    }seg[maxn<<2];\\n    void pushup(int cur)\\n    {\\n        int left=cur<<1,right=cur<<1|1;\\n        seg[cur].len=seg[left].len+seg[right].len;\\n        seg[cur].mx=max(seg[left].mx,seg[right].mx);\\n        seg[cur].left=seg[left].left;\\n        seg[cur].right=seg[right].right;\\n        seg[cur].left_conti=seg[left].left_conti;\\n        seg[cur].right_conti=seg[right].right_conti;\\n        if(seg[left].right==seg[right].left)\\n        {\\n            seg[cur].mx=max(seg[left].right_conti+seg[right].left_conti,seg[cur].mx);\\n            if(seg[cur].mx==seg[cur].len)seg[cur].left_conti=seg[cur].right_conti=seg[cur].len;\\n            else\\n            {\\n                if(seg[left].left_conti==seg[left].len)seg[cur].left_conti+=seg[right].left_conti;\\n                if(seg[right].right_conti==seg[right].len)seg[cur].right_conti+=seg[left].right_conti;\\n            }\\n        }\\n        return;\\n    }\\n    void init(int cur,int l,int r)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur].left=seg[cur].right=s[l];\\n            seg[cur].left_conti=seg[cur].right_conti=seg[cur].len=seg[cur].mx=1;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        init(cur<<1,l,mid);\\n        init(cur<<1|1,mid,r);\\n        pushup(cur);\\n        return;\\n    }\\n    void update(int cur,int l,int r,int pos,char c)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur].left=seg[cur].right=c;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        if(pos<mid)update(cur<<1,l,mid,pos,c);\\n        else update(cur<<1|1,mid,r,pos,c);\\n        pushup(cur);\\n        return;\\n    }\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) \\n    {\\n        this->s=s;\\n        n=queryCharacters.size();\\n        init(1,0,s.size());\\n        vector<int>res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            update(1,0,s.size(),queryIndices[i],queryCharacters[i]);\\n            res[i]=seg[1].mx;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    static const int maxn=1e5+10;\\n    int n;\\n    string s;\\n    struct Node\\n    {\\n        char left,right;\\n        int left_conti,right_conti,len,mx;\\n    }seg[maxn<<2];\\n    void pushup(int cur)\\n    {\\n        int left=cur<<1,right=cur<<1|1;\\n        seg[cur].len=seg[left].len+seg[right].len;\\n        seg[cur].mx=max(seg[left].mx,seg[right].mx);\\n        seg[cur].left=seg[left].left;\\n        seg[cur].right=seg[right].right;\\n        seg[cur].left_conti=seg[left].left_conti;\\n        seg[cur].right_conti=seg[right].right_conti;\\n        if(seg[left].right==seg[right].left)\\n        {\\n            seg[cur].mx=max(seg[left].right_conti+seg[right].left_conti,seg[cur].mx);\\n            if(seg[cur].mx==seg[cur].len)seg[cur].left_conti=seg[cur].right_conti=seg[cur].len;\\n            else\\n            {\\n                if(seg[left].left_conti==seg[left].len)seg[cur].left_conti+=seg[right].left_conti;\\n                if(seg[right].right_conti==seg[right].len)seg[cur].right_conti+=seg[left].right_conti;\\n            }\\n        }\\n        return;\\n    }\\n    void init(int cur,int l,int r)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur].left=seg[cur].right=s[l];\\n            seg[cur].left_conti=seg[cur].right_conti=seg[cur].len=seg[cur].mx=1;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        init(cur<<1,l,mid);\\n        init(cur<<1|1,mid,r);\\n        pushup(cur);\\n        return;\\n    }\\n    void update(int cur,int l,int r,int pos,char c)\\n    {\\n        if(l+1==r)\\n        {\\n            seg[cur].left=seg[cur].right=c;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        if(pos<mid)update(cur<<1,l,mid,pos,c);\\n        else update(cur<<1|1,mid,r,pos,c);\\n        pushup(cur);\\n        return;\\n    }\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) \\n    {\\n        this->s=s;\\n        n=queryCharacters.size();\\n        init(1,0,s.size());\\n        vector<int>res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            update(1,0,s.size(),queryIndices[i],queryCharacters[i]);\\n            res[i]=seg[1].mx;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094915,
                "title": "java-segment-tree-clean",
                "content": "# Code\\n```\\nclass Solution {\\n    \\n    class SegmentTree {\\n\\n        class Node {\\n            char lch, rch;\\n            int lcnt, rcnt, max;\\n            Node (char lchar, int lcount, char rchar, int rcount, int m) {\\n                lch = lchar;\\n                lcnt = lcount;\\n                rch = rchar;\\n                rcnt = rcount;\\n                max = m;\\n            }\\n        }\\n\\n        Node[] tree;\\n        \\n        SegmentTree(String s) {\\n            tree = new Node[s.length()*4];\\n            build(0, 0, s.length()-1, s);\\n        }\\n\\n        public int getMax() {\\n            return tree[0].max;\\n        }\\n\\n        public void update(int i, int l, int r, char c, int indx) {\\n        \\n            if (l == r) {\\n                tree[i] = new Node(c, 1, c, 1, 1);\\n                return;\\n            }\\n\\n            int lchild = i*2+1;\\n            int rchild = i*2+2;\\n            int mid = (l+r)/2;\\n\\n            if (indx <= mid) {\\n                update(lchild, l, mid, c, indx);\\n            } else {\\n                update(rchild, mid+1, r, c, indx);\\n            }\\n\\n            tree[i] = merge(tree[lchild], mid-l+1, tree[rchild], r-mid);\\n\\n        }\\n\\n        private void build(int i, int l, int r, String s) {\\n            if (l == r) {\\n                tree[i] = new Node(s.charAt(l), 1, s.charAt(l), 1, 1);\\n\\n                return;\\n            }\\n            int lchild = i*2+1;\\n            int rchild = i*2+2;\\n            int mid = (l+r)/2;\\n            build(lchild, l, mid, s);\\n            build(rchild, mid+1, r, s);\\n\\n            tree[i] = merge(tree[lchild], mid-l+1, tree[rchild], r-mid);\\n\\n        }\\n\\n        private Node merge(Node lnode, int lsize, Node rnode, int rsize) {\\n            int max = Math.max(lnode.max, rnode.max);\\n            char lch = lnode.lch;\\n            char rch = rnode.rch;\\n            \\n            int lcnt = lnode.lcnt;\\n            int rcnt = rnode.rcnt;\\n        \\n            if (lnode.rch == rnode.lch) {\\n                max = Math.max(max, lnode.rcnt+rnode.lcnt);\\n                if (lnode.lch == lnode.rch && lnode.lcnt == lsize) {\\n                    lcnt += rnode.lcnt;\\n                }\\n                if (rnode.rch == rnode.lch && rnode.rcnt == rsize) {\\n                    rcnt += lnode.rcnt;\\n                }\\n            }\\n            \\n            return new Node(lch, lcnt, rch, rcnt, max);\\n        }\\n    }\\n\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        SegmentTree st = new SegmentTree(s);\\n        \\n        int[] res = new int[queryCharacters.length()];\\n        for (int i = 0; i < queryCharacters.length(); i++) {\\n            st.update(0, 0, s.length()-1, queryCharacters.charAt(i), queryIndices[i]);\\n            res[i] = st.getMax();\\n        }\\n\\n        return res;\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    class SegmentTree {\\n\\n        class Node {\\n            char lch, rch;\\n            int lcnt, rcnt, max;\\n            Node (char lchar, int lcount, char rchar, int rcount, int m) {\\n                lch = lchar;\\n                lcnt = lcount;\\n                rch = rchar;\\n                rcnt = rcount;\\n                max = m;\\n            }\\n        }\\n\\n        Node[] tree;\\n        \\n        SegmentTree(String s) {\\n            tree = new Node[s.length()*4];\\n            build(0, 0, s.length()-1, s);\\n        }\\n\\n        public int getMax() {\\n            return tree[0].max;\\n        }\\n\\n        public void update(int i, int l, int r, char c, int indx) {\\n        \\n            if (l == r) {\\n                tree[i] = new Node(c, 1, c, 1, 1);\\n                return;\\n            }\\n\\n            int lchild = i*2+1;\\n            int rchild = i*2+2;\\n            int mid = (l+r)/2;\\n\\n            if (indx <= mid) {\\n                update(lchild, l, mid, c, indx);\\n            } else {\\n                update(rchild, mid+1, r, c, indx);\\n            }\\n\\n            tree[i] = merge(tree[lchild], mid-l+1, tree[rchild], r-mid);\\n\\n        }\\n\\n        private void build(int i, int l, int r, String s) {\\n            if (l == r) {\\n                tree[i] = new Node(s.charAt(l), 1, s.charAt(l), 1, 1);\\n\\n                return;\\n            }\\n            int lchild = i*2+1;\\n            int rchild = i*2+2;\\n            int mid = (l+r)/2;\\n            build(lchild, l, mid, s);\\n            build(rchild, mid+1, r, s);\\n\\n            tree[i] = merge(tree[lchild], mid-l+1, tree[rchild], r-mid);\\n\\n        }\\n\\n        private Node merge(Node lnode, int lsize, Node rnode, int rsize) {\\n            int max = Math.max(lnode.max, rnode.max);\\n            char lch = lnode.lch;\\n            char rch = rnode.rch;\\n            \\n            int lcnt = lnode.lcnt;\\n            int rcnt = rnode.rcnt;\\n        \\n            if (lnode.rch == rnode.lch) {\\n                max = Math.max(max, lnode.rcnt+rnode.lcnt);\\n                if (lnode.lch == lnode.rch && lnode.lcnt == lsize) {\\n                    lcnt += rnode.lcnt;\\n                }\\n                if (rnode.rch == rnode.lch && rnode.rcnt == rsize) {\\n                    rcnt += lnode.rcnt;\\n                }\\n            }\\n            \\n            return new Node(lch, lcnt, rch, rcnt, max);\\n        }\\n    }\\n\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        SegmentTree st = new SegmentTree(s);\\n        \\n        int[] res = new int[queryCharacters.length()];\\n        for (int i = 0; i < queryCharacters.length(); i++) {\\n            st.update(0, 0, s.length()-1, queryCharacters.charAt(i), queryIndices[i]);\\n            res[i] = st.getMax();\\n        }\\n\\n        return res;\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094705,
                "title": "c-use-set-to-maintain-ranges",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {\\n        map<int, int> lcnt;\\n        set<pair<int, int>> ranges;\\n        int m = s.length();\\n        for (int i = 0; i < m; ) {\\n            int j = i + 1;\\n            while (j < m && s[j] == s[i]) {\\n                ++j;\\n            }\\n            ++lcnt[j - i];\\n            ranges.emplace(i, j - 1);\\n            i = j;\\n        }\\n        vector<int> res;\\n        int k = qi.size();\\n        for (int i = 0; i < k; ++i) {\\n            char c = qc[i];\\n            int idx = qi[i];\\n            if (c != s[idx]) {\\n                auto range = *prev(ranges.upper_bound({ idx, INT_MAX }));\\n                removeRange(lcnt, ranges, range);\\n                addRange(lcnt, ranges, { idx, idx });\\n                if (range.first < idx) {\\n                    addRange(lcnt, ranges, { range.first, idx - 1 });\\n                }\\n                if (idx < range.second) {\\n                    addRange(lcnt, ranges, { idx + 1, range.second });\\n                }\\n                if (idx > 0 && s[idx - 1] == c) {\\n                    removeRange(lcnt, ranges, { idx, idx });\\n                    auto it = prev(ranges.upper_bound({ idx - 1, INT_MAX }));\\n                    addRange(lcnt, ranges, { it->first, idx });\\n                    removeRange(lcnt, ranges, *it);\\n                }\\n                if (idx + 1 < m && s[idx + 1] == c) {\\n                    auto it1 = prev(ranges.upper_bound({ idx, INT_MAX }));\\n                    auto it2 = prev(ranges.upper_bound({ idx + 1, INT_MAX }));\\n                    addRange(lcnt, ranges, { it1->first, it2->second });\\n                    removeRange(lcnt, ranges, *it1);\\n                    removeRange(lcnt, ranges, *it2);\\n                }\\n            }\\n            s[idx] = c;\\n            res.push_back(rbegin(lcnt)->first);\\n        }\\n        return res;\\n    }\\nprivate:\\n    void addRange(map<int, int>& lcnt, set<pair<int, int>>& ranges, const pair<int, int>& range) {\\n        ++lcnt[range.second - range.first + 1];\\n        ranges.insert(range);\\n    }\\n\\n    void removeRange(map<int, int>& lcnt, set<pair<int, int>>& ranges, const pair<int, int>& range) {\\n        int l = range.second - range.first + 1;\\n        auto it = lcnt.find(l);\\n        if (--it->second == 0) {\\n            lcnt.erase(it);\\n        }\\n        ranges.erase(range);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {\\n        map<int, int> lcnt;\\n        set<pair<int, int>> ranges;\\n        int m = s.length();\\n        for (int i = 0; i < m; ) {\\n            int j = i + 1;\\n            while (j < m && s[j] == s[i]) {\\n                ++j;\\n            }\\n            ++lcnt[j - i];\\n            ranges.emplace(i, j - 1);\\n            i = j;\\n        }\\n        vector<int> res;\\n        int k = qi.size();\\n        for (int i = 0; i < k; ++i) {\\n            char c = qc[i];\\n            int idx = qi[i];\\n            if (c != s[idx]) {\\n                auto range = *prev(ranges.upper_bound({ idx, INT_MAX }));\\n                removeRange(lcnt, ranges, range);\\n                addRange(lcnt, ranges, { idx, idx });\\n                if (range.first < idx) {\\n                    addRange(lcnt, ranges, { range.first, idx - 1 });\\n                }\\n                if (idx < range.second) {\\n                    addRange(lcnt, ranges, { idx + 1, range.second });\\n                }\\n                if (idx > 0 && s[idx - 1] == c) {\\n                    removeRange(lcnt, ranges, { idx, idx });\\n                    auto it = prev(ranges.upper_bound({ idx - 1, INT_MAX }));\\n                    addRange(lcnt, ranges, { it->first, idx });\\n                    removeRange(lcnt, ranges, *it);\\n                }\\n                if (idx + 1 < m && s[idx + 1] == c) {\\n                    auto it1 = prev(ranges.upper_bound({ idx, INT_MAX }));\\n                    auto it2 = prev(ranges.upper_bound({ idx + 1, INT_MAX }));\\n                    addRange(lcnt, ranges, { it1->first, it2->second });\\n                    removeRange(lcnt, ranges, *it1);\\n                    removeRange(lcnt, ranges, *it2);\\n                }\\n            }\\n            s[idx] = c;\\n            res.push_back(rbegin(lcnt)->first);\\n        }\\n        return res;\\n    }\\nprivate:\\n    void addRange(map<int, int>& lcnt, set<pair<int, int>>& ranges, const pair<int, int>& range) {\\n        ++lcnt[range.second - range.first + 1];\\n        ranges.insert(range);\\n    }\\n\\n    void removeRange(map<int, int>& lcnt, set<pair<int, int>>& ranges, const pair<int, int>& range) {\\n        int l = range.second - range.first + 1;\\n        auto it = lcnt.find(l);\\n        if (--it->second == 0) {\\n            lcnt.erase(it);\\n        }\\n        ranges.erase(range);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942511,
                "title": "segment-tree-95-ms",
                "content": "# Complexity\\n- Time complexity:\\nO(n + k * log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n  class SegmentNode {\\n    private int singleCharPrefLen;\\n    private int singleCharSufLen;\\n    private int maxLen;\\n    private String prefixChar;\\n    private String suffixChar;\\n\\n    SegmentNode(int pl, int sl, int maxLen, String prefChar, String sufChar) {\\n      this.singleCharPrefLen = pl;\\n      this.singleCharSufLen = sl;\\n      this.maxLen = maxLen;\\n      this.prefixChar = prefChar;\\n      this.suffixChar = sufChar;\\n    }\\n\\n    SegmentNode() {\\n    }\\n  }\\n\\n  private void mergeSegments(SegmentNode s1, int l1, SegmentNode s2, int l2, SegmentNode t) {\\n    t.maxLen = Math.max(s1.maxLen, s2.maxLen);\\n    t.singleCharPrefLen = s1.singleCharPrefLen;\\n    t.singleCharSufLen = s2.singleCharSufLen;\\n    t.prefixChar = s1.prefixChar;\\n    t.suffixChar = s2.suffixChar;\\n    if (s1.suffixChar.equals(s2.prefixChar)) {\\n      t.maxLen = Math.max(t.maxLen, s1.singleCharSufLen + s2.singleCharPrefLen);\\n      t.singleCharPrefLen += s1.singleCharPrefLen == l1 ? s2.singleCharPrefLen : 0;\\n      t.singleCharSufLen += s2.singleCharSufLen == l2 ? s1.singleCharSufLen : 0;\\n    }\\n  }\\n\\n  private void build(String s, SegmentNode[] segTree, int rangeLeft, int rangeRight, int vertex) {\\n    if (rangeLeft == rangeRight) {\\n      segTree[vertex] = new SegmentNode(1, 1, 1, s.substring(rangeLeft, rangeLeft + 1),\\n          s.substring(rangeLeft, rangeLeft + 1));\\n      return;\\n    }\\n\\n    int lc = 2 * vertex + 1;\\n    int rc = 2 * vertex + 2;\\n\\n    int mid = rangeLeft + (rangeRight - rangeLeft) / 2;\\n\\n    this.build(s, segTree, rangeLeft, mid, lc);\\n    this.build(s, segTree, mid + 1, rangeRight, rc);\\n\\n    segTree[vertex] = new SegmentNode();\\n    this.mergeSegments(segTree[lc], mid - rangeLeft + 1, segTree[rc], rangeRight - mid, segTree[vertex]);\\n  }\\n\\n  private void update(SegmentNode[] segTree, int rangeLeft, int rangeRight, int vertex, int index, String val) {\\n    if (rangeLeft == rangeRight && rangeLeft == index) {\\n      segTree[vertex].prefixChar = segTree[vertex].suffixChar = val;\\n      return;\\n    }\\n\\n    int lc = 2 * vertex + 1;\\n    int rc = 2 * vertex + 2;\\n    int mid = rangeLeft + (rangeRight - rangeLeft) / 2;\\n    if (index <= mid) {\\n      this.update(segTree, rangeLeft, mid, lc, index, val);\\n    } else {\\n      this.update(segTree, mid + 1, rangeRight, rc, index, val);\\n    }\\n\\n    this.mergeSegments(segTree[lc], mid - rangeLeft + 1, segTree[rc], rangeRight - mid, segTree[vertex]);\\n  }\\n\\n  public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n    int[] result = new int[queryIndices.length];\\n    SegmentNode[] segTree = new SegmentNode[4 * s.length()];\\n    this.build(s, segTree, 0, s.length() - 1, 0);\\n\\n    for (int i = 0; i < queryIndices.length; i++) {\\n      this.update(segTree, 0, s.length() - 1, 0, queryIndices[i], queryCharacters.substring(i, i + 1));\\n      result[i] = segTree[0].maxLen;\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Segment Tree"
                ],
                "code": "```\\nclass Solution {\\n  class SegmentNode {\\n    private int singleCharPrefLen;\\n    private int singleCharSufLen;\\n    private int maxLen;\\n    private String prefixChar;\\n    private String suffixChar;\\n\\n    SegmentNode(int pl, int sl, int maxLen, String prefChar, String sufChar) {\\n      this.singleCharPrefLen = pl;\\n      this.singleCharSufLen = sl;\\n      this.maxLen = maxLen;\\n      this.prefixChar = prefChar;\\n      this.suffixChar = sufChar;\\n    }\\n\\n    SegmentNode() {\\n    }\\n  }\\n\\n  private void mergeSegments(SegmentNode s1, int l1, SegmentNode s2, int l2, SegmentNode t) {\\n    t.maxLen = Math.max(s1.maxLen, s2.maxLen);\\n    t.singleCharPrefLen = s1.singleCharPrefLen;\\n    t.singleCharSufLen = s2.singleCharSufLen;\\n    t.prefixChar = s1.prefixChar;\\n    t.suffixChar = s2.suffixChar;\\n    if (s1.suffixChar.equals(s2.prefixChar)) {\\n      t.maxLen = Math.max(t.maxLen, s1.singleCharSufLen + s2.singleCharPrefLen);\\n      t.singleCharPrefLen += s1.singleCharPrefLen == l1 ? s2.singleCharPrefLen : 0;\\n      t.singleCharSufLen += s2.singleCharSufLen == l2 ? s1.singleCharSufLen : 0;\\n    }\\n  }\\n\\n  private void build(String s, SegmentNode[] segTree, int rangeLeft, int rangeRight, int vertex) {\\n    if (rangeLeft == rangeRight) {\\n      segTree[vertex] = new SegmentNode(1, 1, 1, s.substring(rangeLeft, rangeLeft + 1),\\n          s.substring(rangeLeft, rangeLeft + 1));\\n      return;\\n    }\\n\\n    int lc = 2 * vertex + 1;\\n    int rc = 2 * vertex + 2;\\n\\n    int mid = rangeLeft + (rangeRight - rangeLeft) / 2;\\n\\n    this.build(s, segTree, rangeLeft, mid, lc);\\n    this.build(s, segTree, mid + 1, rangeRight, rc);\\n\\n    segTree[vertex] = new SegmentNode();\\n    this.mergeSegments(segTree[lc], mid - rangeLeft + 1, segTree[rc], rangeRight - mid, segTree[vertex]);\\n  }\\n\\n  private void update(SegmentNode[] segTree, int rangeLeft, int rangeRight, int vertex, int index, String val) {\\n    if (rangeLeft == rangeRight && rangeLeft == index) {\\n      segTree[vertex].prefixChar = segTree[vertex].suffixChar = val;\\n      return;\\n    }\\n\\n    int lc = 2 * vertex + 1;\\n    int rc = 2 * vertex + 2;\\n    int mid = rangeLeft + (rangeRight - rangeLeft) / 2;\\n    if (index <= mid) {\\n      this.update(segTree, rangeLeft, mid, lc, index, val);\\n    } else {\\n      this.update(segTree, mid + 1, rangeRight, rc, index, val);\\n    }\\n\\n    this.mergeSegments(segTree[lc], mid - rangeLeft + 1, segTree[rc], rangeRight - mid, segTree[vertex]);\\n  }\\n\\n  public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n    int[] result = new int[queryIndices.length];\\n    SegmentNode[] segTree = new SegmentNode[4 * s.length()];\\n    this.build(s, segTree, 0, s.length() - 1, 0);\\n\\n    for (int i = 0; i < queryIndices.length; i++) {\\n      this.update(segTree, 0, s.length() - 1, 0, queryIndices[i], queryCharacters.substring(i, i + 1));\\n      result[i] = segTree[0].maxLen;\\n    }\\n\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908805,
                "title": "java-segment-tree-modular",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    class SegNode {\\n        int subStringLen;\\n        int leftPrefix;\\n        int rightSuffix;\\n\\n        public SegNode(int a, int b,int c){\\n            subStringLen = a;\\n            leftPrefix = b;\\n            rightSuffix = c;\\n        }\\n    }\\n\\n    public void combine(int node, SegNode[] tree, int l, int mid, int r, char[] inp){\\n        int localMinima = (inp[mid] == inp[mid+1]) ?tree[2*node+1].rightSuffix +tree[2*node+2].leftPrefix: 0;\\n        tree[node].subStringLen = Math.max(Math.max(tree[2*node+1].subStringLen , tree[2*node+2].subStringLen), localMinima);\\n        \\n        tree[node].leftPrefix = tree[2*node+1].leftPrefix;\\n        if(tree[2*node+1].leftPrefix == (mid-l+1) && inp[mid] == inp[mid+1] ){\\n            tree[node].leftPrefix += tree[2*node+2].leftPrefix;\\n        }\\n\\n          tree[node].rightSuffix = tree[2*node+2].rightSuffix;\\n        if(tree[2*node+2].rightSuffix == (r-mid) &&  inp[mid] == inp[mid+1] ){\\n            tree[node].rightSuffix += tree[2*node+1].rightSuffix;\\n        }\\n\\n    }\\n\\n    public void buildTree(char[] s, int node, int l, int r, SegNode[] tree){\\n        if(l==r){\\n            tree[node] = new SegNode(1,1,1);\\n            return;\\n        }\\n        int mid = (l+r) / 2 ;\\n         buildTree(s, 2*node+1, l, mid, tree);\\n         buildTree(s, 2*node+2, mid+1, r, tree);\\n         tree[node] = new SegNode(0,0,0);\\n         combine(node, tree, l,mid,r,s);\\n    }\\n\\n    public void update(char[] s, int node, int l, int r, int id, char val,  SegNode[] tree){\\n        if(l == r){\\n            s[id] = val;\\n            return;\\n        }\\n         int mid = (l+r) / 2 ;\\n         if(l<=id && id<=mid){\\n             update(s, 2*node+1, l, mid, id, val, tree);\\n\\n         }else{\\n               update(s, 2*node+2, mid+1, r, id, val, tree);\\n         }\\n           combine(node, tree, l,mid,r,s);\\n\\n    }\\n\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        int n = s.length();\\n        char[] inp = s.toCharArray();\\n        SegNode[] tree = new SegNode[4*n+1];\\n        buildTree(inp, 0, 0,n-1, tree);\\n        int[] ans = new int[queryIndices.length];\\n        for(int  i =0 ;i< queryIndices.length;i++ ){\\n            update(inp, 0, 0,n-1, queryIndices[i], queryCharacters.charAt(i), tree );\\n            ans[i] = tree[0].subStringLen;\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    class SegNode {\\n        int subStringLen;\\n        int leftPrefix;\\n        int rightSuffix;\\n\\n        public SegNode(int a, int b,int c){\\n            subStringLen = a;\\n            leftPrefix = b;\\n            rightSuffix = c;\\n        }\\n    }\\n\\n    public void combine(int node, SegNode[] tree, int l, int mid, int r, char[] inp){\\n        int localMinima = (inp[mid] == inp[mid+1]) ?tree[2*node+1].rightSuffix +tree[2*node+2].leftPrefix: 0;\\n        tree[node].subStringLen = Math.max(Math.max(tree[2*node+1].subStringLen , tree[2*node+2].subStringLen), localMinima);\\n        \\n        tree[node].leftPrefix = tree[2*node+1].leftPrefix;\\n        if(tree[2*node+1].leftPrefix == (mid-l+1) && inp[mid] == inp[mid+1] ){\\n            tree[node].leftPrefix += tree[2*node+2].leftPrefix;\\n        }\\n\\n          tree[node].rightSuffix = tree[2*node+2].rightSuffix;\\n        if(tree[2*node+2].rightSuffix == (r-mid) &&  inp[mid] == inp[mid+1] ){\\n            tree[node].rightSuffix += tree[2*node+1].rightSuffix;\\n        }\\n\\n    }\\n\\n    public void buildTree(char[] s, int node, int l, int r, SegNode[] tree){\\n        if(l==r){\\n            tree[node] = new SegNode(1,1,1);\\n            return;\\n        }\\n        int mid = (l+r) / 2 ;\\n         buildTree(s, 2*node+1, l, mid, tree);\\n         buildTree(s, 2*node+2, mid+1, r, tree);\\n         tree[node] = new SegNode(0,0,0);\\n         combine(node, tree, l,mid,r,s);\\n    }\\n\\n    public void update(char[] s, int node, int l, int r, int id, char val,  SegNode[] tree){\\n        if(l == r){\\n            s[id] = val;\\n            return;\\n        }\\n         int mid = (l+r) / 2 ;\\n         if(l<=id && id<=mid){\\n             update(s, 2*node+1, l, mid, id, val, tree);\\n\\n         }else{\\n               update(s, 2*node+2, mid+1, r, id, val, tree);\\n         }\\n           combine(node, tree, l,mid,r,s);\\n\\n    }\\n\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        int n = s.length();\\n        char[] inp = s.toCharArray();\\n        SegNode[] tree = new SegNode[4*n+1];\\n        buildTree(inp, 0, 0,n-1, tree);\\n        int[] ans = new int[queryIndices.length];\\n        for(int  i =0 ;i< queryIndices.length;i++ ){\\n            update(inp, 0, 0,n-1, queryIndices[i], queryCharacters.charAt(i), tree );\\n            ans[i] = tree[0].subStringLen;\\n        }\\n        return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880360,
                "title": "beats-100-easiest-merge-function-with-only-three-variables-c",
                "content": "```\\nclass Solution {\\n    int seg[400001][5]; \\n\\t//seg[i][0] -max length of segment in this node range, 1=lpre,\\n\\t//seg[i][1] -maximum prefix length of this segment with same character,\\n\\t//seg[i][1] -maximum suffix length of this segment with same character,\\n\\t\\n    string s;  // take input string as global\\n\\t\\n\\t//normal build\\n    void build(int i, int l, int r){\\n        if(l>r)return;\\n        if(l==r){\\n            seg[i][0]=1;seg[i][1]=1,seg[i][2]=1; return;\\n        }\\n        int m=(l+r)/2;\\n        build(2*i+1,l,m); build(2*i+2,m+1,r);\\n        merge(i,l,r); // merge both built child\\'s results to this i\\'th node of segment tree\\n    }\\n    \\n    void merge(int i, int l, int r){\\n        int cl=2*i+1,cr=2*i+2; // left and right child segment node index\\n        int m=(l+r)/2;\\n        int cur=max(seg[cl][0],seg[cr][0]); \\n        \\n\\t\\t//initialise prefix and suffix of current node with same as prefix of left child and suffix of right child\\n        seg[i][1]=seg[cl][1];\\n        seg[i][2]=seg[cr][2];\\n        // if  rightmost char of left child segment ==leftmost char of right child segment\\n        if(s[m]==s[m+1]){\\n            cur=max(cur, seg[cl][2]+seg[cr][1]);\\n            //left= ( l to m)   ,  right= (m+1 to r)\\n            if(seg[cl][1]==(m-l+1)){\\n              seg[i][1]+=seg[cr][1];\\n            }\\n            if(seg[cr][2]==(r-(m+1)+1)){\\n              seg[i][2]+=seg[cl][2];\\n            }\\n        }\\n        seg[i][0]=cur; // store maximum of all repeating lengths\\n        \\n    }\\n    \\n    int update(int i, int l, int r, int ind,char c){\\n            if(ind>r or ind<l or l>r)return 0;\\n            if(l==r and ind==l){\\n                s[ind]=c;\\n                seg[i][0]=1;seg[i][1]=1,seg[i][2]=1; return seg[i][0];\\n            }\\n\\t\\t\\t\\n            int m=(l+r)/2;\\n            update(2*i+1,l,m,ind,c); update(2*i+2,m+1,r,ind,c);\\n        \\n            merge(i,l,r);\\n            return seg[i][0];\\n    }\\n    \\npublic:\\n    vector<int> longestRepeating(string str, string q, vector<int>& qi) {\\n     \\n        s=str; int n=s.size();\\n        vector<int>ans(q.size(),1);\\n        build(0,0,n-1);\\n        for(int i=0;i<q.size();i++){\\n            int j=qi[i];\\n            char c=q[i];\\n            ans[i]=update(0,0,n-1,j,c);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n    int seg[400001][5]; \\n\\t//seg[i][0] -max length of segment in this node range, 1=lpre,\\n\\t//seg[i][1] -maximum prefix length of this segment with same character,\\n\\t//seg[i][1] -maximum suffix length of this segment with same character,\\n\\t\\n    string s;  // take input string as global\\n\\t\\n\\t//normal build\\n    void build(int i, int l, int r){\\n        if(l>r)return;\\n        if(l==r){\\n            seg[i][0]=1;seg[i][1]=1,seg[i][2]=1; return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3797012,
                "title": "cpp-solution-using-segment-trees-concept",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstring v;\\nstruct node{\\n    int val,start,end,start_len,end_len;\\n    node*left,*right;\\n    node(){\\n        left=NULL,right=NULL;\\n    }\\n};\\nvoid create(node *root,int start,int end){\\n    if(start==end){\\n        root->val=1;\\n        root->start=start,root->end=end;\\n        root->start_len=1,root->end_len=1;\\n        return ;\\n    }\\n    node *left=new node(),*right=new node();\\n    int mid=(start+end)/2;\\n    create(left,start,mid);\\n    create(right,mid+1,end);\\n    root->left=left,root->right=right;\\n    if(v[root->left->end]==v[root->right->start])\\n    {\\n        int new_len=left->end_len+right->start_len;\\n        root->val=max(left->val,max(right->val,new_len));\\n        if(left->start_len==left->end-left->start+1)\\n        root->start_len=new_len;\\n        else\\n        root->start_len=left->start_len;\\n        if(right->end_len==right->end-right->start+1)\\n        root->end_len=new_len;\\n        else\\n        root->end_len=right->end_len;\\n        root->start=left->start;\\n        root->end=right->end;\\n    }\\n    else\\n    {\\n        root->val=max(left->val,right->val);\\n        root->start=left->start,root->end=right->end;\\n        root->start_len=left->start_len,root->end_len=right->end_len;\\n    }\\n    return;\\n    \\n}\\nint ind;\\nvoid add(node *root,int start,int end){\\n    if(start==end)\\n        return;\\n    int mid=(start+end)/2;\\n    if(ind>mid)\\n    add(root->right,mid+1,end);\\n    else\\n    add(root->left,start,mid);\\n       if(v[root->left->end]==v[root->right->start])\\n    {\\n        int new_len=root->left->end_len+root->right->start_len;\\n        root->val=max(root->left->val,max(root->right->val,new_len));\\n        if(root->left->start_len==root->left->end-root->left->start+1)\\n        root->start_len=new_len;\\n        else\\n        root->start_len=root->left->start_len;\\n        if(root->right->end_len==root->right->end-root->right->start+1)\\n        root->end_len=new_len;\\n        else\\n        root->end_len=root->right->end_len;\\n        root->start=root->left->start;\\n        root->end=root->right->end;\\n    }\\n    else\\n    {\\n        root->val=max(root->left->val,root->right->val);\\n        root->start=root->left->start,root->end=root->right->end;\\n        root->start_len=root->left->start_len,root->end_len=root->right->end_len;\\n    }\\n    return;\\n    \\n}\\n    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {\\n       node *root=new node();\\n       v=s;\\n       create(root,0,s.size()-1);\\n       vector<int> res;\\n       for(int i=0;i<qi.size();i++){\\n           v[qi[i]]=qc[i];\\n           ind=qi[i];\\n           add(root,0,s.size()-1);\\n           res.push_back(root->val);\\n       }\\n       return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring v;\\nstruct node{\\n    int val,start,end,start_len,end_len;\\n    node*left,*right;\\n    node(){\\n        left=NULL,right=NULL;\\n    }\\n};\\nvoid create(node *root,int start,int end){\\n    if(start==end){\\n        root->val=1;\\n        root->start=start,root->end=end;\\n        root->start_len=1,root->end_len=1;\\n        return ;\\n    }\\n    node *left=new node(),*right=new node();\\n    int mid=(start+end)/2;\\n    create(left,start,mid);\\n    create(right,mid+1,end);\\n    root->left=left,root->right=right;\\n    if(v[root->left->end]==v[root->right->start])\\n    {\\n        int new_len=left->end_len+right->start_len;\\n        root->val=max(left->val,max(right->val,new_len));\\n        if(left->start_len==left->end-left->start+1)\\n        root->start_len=new_len;\\n        else\\n        root->start_len=left->start_len;\\n        if(right->end_len==right->end-right->start+1)\\n        root->end_len=new_len;\\n        else\\n        root->end_len=right->end_len;\\n        root->start=left->start;\\n        root->end=right->end;\\n    }\\n    else\\n    {\\n        root->val=max(left->val,right->val);\\n        root->start=left->start,root->end=right->end;\\n        root->start_len=left->start_len,root->end_len=right->end_len;\\n    }\\n    return;\\n    \\n}\\nint ind;\\nvoid add(node *root,int start,int end){\\n    if(start==end)\\n        return;\\n    int mid=(start+end)/2;\\n    if(ind>mid)\\n    add(root->right,mid+1,end);\\n    else\\n    add(root->left,start,mid);\\n       if(v[root->left->end]==v[root->right->start])\\n    {\\n        int new_len=root->left->end_len+root->right->start_len;\\n        root->val=max(root->left->val,max(root->right->val,new_len));\\n        if(root->left->start_len==root->left->end-root->left->start+1)\\n        root->start_len=new_len;\\n        else\\n        root->start_len=root->left->start_len;\\n        if(root->right->end_len==root->right->end-root->right->start+1)\\n        root->end_len=new_len;\\n        else\\n        root->end_len=root->right->end_len;\\n        root->start=root->left->start;\\n        root->end=root->right->end;\\n    }\\n    else\\n    {\\n        root->val=max(root->left->val,root->right->val);\\n        root->start=root->left->start,root->end=root->right->end;\\n        root->start_len=root->left->start_len,root->end_len=root->right->end_len;\\n    }\\n    return;\\n    \\n}\\n    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {\\n       node *root=new node();\\n       v=s;\\n       create(root,0,s.size()-1);\\n       vector<int> res;\\n       for(int i=0;i<qi.size();i++){\\n           v[qi[i]]=qc[i];\\n           ind=qi[i];\\n           add(root,0,s.size()-1);\\n           res.push_back(root->val);\\n       }\\n       return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3760126,
                "title": "java-one-treemap-with-range-one-treemap-with-length",
                "content": "1.  A TreeMap for recording ranges\\n2.  Another TreeMap for recording lengths\\n3.  The replacement may happen at head, middle or end, we insert the range first, than replace the character.\\n4.  If the character is as same as it\\'s neighbor, merging to a new range and put the new length\\n5.  The result will be the largest key in` lenMap`\\n\\n```\\n\\tprivate TreeMap<Integer, Integer> rangeMap;\\n    private TreeMap<Integer, Integer> lenMap;\\n    \\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        rangeMap = new TreeMap<Integer, Integer>();\\n        lenMap = new TreeMap<Integer, Integer>();\\n        int n = s.length();\\n        char[] sChar = s.toCharArray();\\n        \\n        for (int start = 0; start < n; start++){\\n            // find every same characters\\' range and length\\n            int end = start;\\n            while (end < n && sChar[end] == sChar[start]){\\n                end++;\\n            }\\n            lenMap.put(end-start, lenMap.getOrDefault(end-start, 0) + 1);\\n            rangeMap.put(start, end-1);\\n            start = end - 1;       \\n        }\\n        \\n        int k = queryCharacters.length();\\n        int[] result = new int[k];\\n        char[] changeChar = queryCharacters.toCharArray();\\n        \\n        for (int i = 0; i < k; i++){\\n            int idx = queryIndices[i];\\n            if (sChar[idx] != changeChar[i]){\\n                // insert range first, merge range later\\n                insert(idx);\\n                sChar[idx] = changeChar[i];\\n                mergeRight(idx, sChar);\\n                mergeLeft(idx, sChar);\\n            }\\n            \\n            // result will be the largest length\\n            result[i] = lenMap.lastKey();\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void removeInterval(int start){\\n        int end = rangeMap.get(start);\\n        rangeMap.remove(start);\\n        int remain = lenMap.get(end-start+1) - 1;\\n        if(remain == 0){\\n            lenMap.remove(end-start+1);\\n        }else{\\n            lenMap.put(end-start+1, remain);\\n        }\\n    }\\n    \\n    private void addInterval(int start, int end){\\n        rangeMap.put(start, end);\\n        lenMap.put(end-start+1, lenMap.getOrDefault(end-start+1, 0) + 1);\\n    }\\n    \\n    private void insert(int idx){\\n        int from = rangeMap.floorKey(idx);\\n        int to = rangeMap.get(from);\\n        \\n        if (from == to && to == idx) {\\n            // affect only one character\\n            return;\\n        }\\n        \\n        removeInterval(from);\\n        \\n        if (from == idx){\\n            // the change is at head\\n            addInterval(from, from);\\n            addInterval(from + 1, to);\\n        } else if (to == idx){\\n            // the change is at end\\n            addInterval(to, to);\\n            addInterval(from, to-1);\\n        } else {\\n            // the change is at middle\\n            addInterval(from, idx-1);\\n            addInterval(idx, idx);\\n            addInterval(idx+1, to);\\n        }\\n    }\\n    \\n    private void mergeRight(int idx, char[] sChar){\\n        int n = sChar.length;\\n        if (idx == n - 1) {\\n            return;\\n        }\\n        if (sChar[idx] != sChar[idx+1]) {\\n            return;\\n        }\\n        \\n        int from = rangeMap.floorKey(idx+1);\\n        int to = rangeMap.get(from);\\n        \\n\\t\\tremoveInterval(from);\\n        removeInterval(idx);\\n        \\n        addInterval(idx, to);\\n    }\\n    \\n    private void mergeLeft(int idx, char[] sChar){\\n        int n = sChar.length;\\n        if (idx == 0) {\\n            return;\\n        }\\n        if (sChar[idx] != sChar[idx-1]) {\\n            return;\\n        }\\n        \\n        int from = rangeMap.floorKey(idx-1);\\n        int to = rangeMap.get(idx);\\n        \\n        removeInterval(from);\\n        removeInterval(idx);\\n\\n        addInterval(from, to);\\n    }\\n```\\n\\nTime complexity: **O(nlogn)**\\nSpace complexity: **O(n)**",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n\\tprivate TreeMap<Integer, Integer> rangeMap;\\n    private TreeMap<Integer, Integer> lenMap;\\n    \\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        rangeMap = new TreeMap<Integer, Integer>();\\n        lenMap = new TreeMap<Integer, Integer>();\\n        int n = s.length();\\n        char[] sChar = s.toCharArray();\\n        \\n        for (int start = 0; start < n; start++){\\n            // find every same characters\\' range and length\\n            int end = start;\\n            while (end < n && sChar[end] == sChar[start]){\\n                end++;\\n            }\\n            lenMap.put(end-start, lenMap.getOrDefault(end-start, 0) + 1);\\n            rangeMap.put(start, end-1);\\n            start = end - 1;       \\n        }\\n        \\n        int k = queryCharacters.length();\\n        int[] result = new int[k];\\n        char[] changeChar = queryCharacters.toCharArray();\\n        \\n        for (int i = 0; i < k; i++){\\n            int idx = queryIndices[i];\\n            if (sChar[idx] != changeChar[i]){\\n                // insert range first, merge range later\\n                insert(idx);\\n                sChar[idx] = changeChar[i];\\n                mergeRight(idx, sChar);\\n                mergeLeft(idx, sChar);\\n            }\\n            \\n            // result will be the largest length\\n            result[i] = lenMap.lastKey();\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void removeInterval(int start){\\n        int end = rangeMap.get(start);\\n        rangeMap.remove(start);\\n        int remain = lenMap.get(end-start+1) - 1;\\n        if(remain == 0){\\n            lenMap.remove(end-start+1);\\n        }else{\\n            lenMap.put(end-start+1, remain);\\n        }\\n    }\\n    \\n    private void addInterval(int start, int end){\\n        rangeMap.put(start, end);\\n        lenMap.put(end-start+1, lenMap.getOrDefault(end-start+1, 0) + 1);\\n    }\\n    \\n    private void insert(int idx){\\n        int from = rangeMap.floorKey(idx);\\n        int to = rangeMap.get(from);\\n        \\n        if (from == to && to == idx) {\\n            // affect only one character\\n            return;\\n        }\\n        \\n        removeInterval(from);\\n        \\n        if (from == idx){\\n            // the change is at head\\n            addInterval(from, from);\\n            addInterval(from + 1, to);\\n        } else if (to == idx){\\n            // the change is at end\\n            addInterval(to, to);\\n            addInterval(from, to-1);\\n        } else {\\n            // the change is at middle\\n            addInterval(from, idx-1);\\n            addInterval(idx, idx);\\n            addInterval(idx+1, to);\\n        }\\n    }\\n    \\n    private void mergeRight(int idx, char[] sChar){\\n        int n = sChar.length;\\n        if (idx == n - 1) {\\n            return;\\n        }\\n        if (sChar[idx] != sChar[idx+1]) {\\n            return;\\n        }\\n        \\n        int from = rangeMap.floorKey(idx+1);\\n        int to = rangeMap.get(from);\\n        \\n\\t\\tremoveInterval(from);\\n        removeInterval(idx);\\n        \\n        addInterval(idx, to);\\n    }\\n    \\n    private void mergeLeft(int idx, char[] sChar){\\n        int n = sChar.length;\\n        if (idx == 0) {\\n            return;\\n        }\\n        if (sChar[idx] != sChar[idx-1]) {\\n            return;\\n        }\\n        \\n        int from = rangeMap.floorKey(idx-1);\\n        int to = rangeMap.get(idx);\\n        \\n        removeInterval(from);\\n        removeInterval(idx);\\n\\n        addInterval(from, to);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3633049,
                "title": "c-code-using-segment-tree",
                "content": "\\n# Code\\n```\\nclass Block{\\npublic:\\n    int ans, pf, sf, len;\\n    char pfc, sfc;\\n\\n    Block(){\\n        ans = 0, pf = 0, sf = 0, len = 0;\\n        pfc = \\'#\\', sfc = \\'#\\';\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void build(string &s, vector<Block> &tree, int st, int emd, int node){\\n        if(st==emd){\\n            tree[node].ans = tree[node].pf = tree[node].sf = tree[node].len = 1;\\n            tree[node].pfc = tree[node].sfc = s[st];\\n            return;\\n        }\\n\\n        int mid = (st+emd)/2;\\n        build(s, tree, st, mid, 2*node);\\n        build(s, tree, mid+1, emd, 2*node+1);\\n\\n        tree[node].len = tree[2*node].len + tree[2*node+1].len;\\n        tree[node].ans = max(tree[2*node].ans, tree[2*node+1].ans);\\n        if(tree[2*node].sfc==tree[2*node+1].pfc) tree[node].ans = max(tree[node].ans, tree[2*node].sf+tree[2*node+1].pf);\\n        tree[node].pfc = tree[2*node].pfc, tree[node].sfc = tree[2*node+1].sfc;\\n\\n        tree[node].pf = tree[2*node].pf;\\n        if(tree[2*node].pf==tree[2*node].len && tree[2*node].sfc==tree[2*node+1].pfc)\\n            tree[node].pf = max(tree[node].pf, tree[2*node].len + tree[2*node+1].pf);\\n\\n        tree[node].sf = tree[2*node+1].sf;\\n        if(tree[2*node+1].len == tree[2*node+1].sf && tree[2*node+1].pfc==tree[2*node].sfc)\\n            tree[node].sf = max(tree[node].sf, tree[2*node+1].len + tree[2*node].sf);\\n    }\\n\\n    void update(vector<Block> &tree, int st, int emd, int node, int idx, char ch){\\n        if(st==emd){\\n            tree[node].pfc = tree[node].sfc = ch;\\n            return;\\n        }\\n\\n        int mid = (st+emd)/2;\\n        if(idx<=mid) update(tree, st, mid, 2*node, idx, ch);\\n        else update(tree, mid+1, emd, 2*node+1, idx, ch);\\n\\n        tree[node].len = tree[2*node].len + tree[2*node+1].len;\\n        tree[node].ans = max(tree[2*node].ans, tree[2*node+1].ans);\\n        if(tree[2*node].sfc==tree[2*node+1].pfc) tree[node].ans = max(tree[node].ans, tree[2*node].sf+tree[2*node+1].pf);\\n        tree[node].pfc = tree[2*node].pfc, tree[node].sfc = tree[2*node+1].sfc;\\n\\n        tree[node].pf = tree[2*node].pf;\\n        if(tree[2*node].pf==tree[2*node].len && tree[2*node].sfc==tree[2*node+1].pfc)\\n            tree[node].pf = max(tree[node].pf, tree[2*node].len + tree[2*node+1].pf);\\n\\n        tree[node].sf = tree[2*node+1].sf;\\n        if(tree[2*node+1].len == tree[2*node+1].sf && tree[2*node+1].pfc==tree[2*node].sfc)\\n            tree[node].sf = max(tree[node].sf, tree[2*node+1].len + tree[2*node].sf);\\n    }\\n\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        int n = s.length();\\n        vector<Block> tree(4*n);\\n\\n        build(s, tree, 0, n-1, 1);\\n\\n        int q = queryIndices.size();\\n        vector<int> ans;\\n        for(int i=0;i<q;i++){\\n            update(tree, 0, n-1, 1, queryIndices[i], queryCharacters[i]);\\n            ans.push_back(tree[1].ans);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nclass Block{\\npublic:\\n    int ans, pf, sf, len;\\n    char pfc, sfc;\\n\\n    Block(){\\n        ans = 0, pf = 0, sf = 0, len = 0;\\n        pfc = \\'#\\', sfc = \\'#\\';\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void build(string &s, vector<Block> &tree, int st, int emd, int node){\\n        if(st==emd){\\n            tree[node].ans = tree[node].pf = tree[node].sf = tree[node].len = 1;\\n            tree[node].pfc = tree[node].sfc = s[st];\\n            return;\\n        }\\n\\n        int mid = (st+emd)/2;\\n        build(s, tree, st, mid, 2*node);\\n        build(s, tree, mid+1, emd, 2*node+1);\\n\\n        tree[node].len = tree[2*node].len + tree[2*node+1].len;\\n        tree[node].ans = max(tree[2*node].ans, tree[2*node+1].ans);\\n        if(tree[2*node].sfc==tree[2*node+1].pfc) tree[node].ans = max(tree[node].ans, tree[2*node].sf+tree[2*node+1].pf);\\n        tree[node].pfc = tree[2*node].pfc, tree[node].sfc = tree[2*node+1].sfc;\\n\\n        tree[node].pf = tree[2*node].pf;\\n        if(tree[2*node].pf==tree[2*node].len && tree[2*node].sfc==tree[2*node+1].pfc)\\n            tree[node].pf = max(tree[node].pf, tree[2*node].len + tree[2*node+1].pf);\\n\\n        tree[node].sf = tree[2*node+1].sf;\\n        if(tree[2*node+1].len == tree[2*node+1].sf && tree[2*node+1].pfc==tree[2*node].sfc)\\n            tree[node].sf = max(tree[node].sf, tree[2*node+1].len + tree[2*node].sf);\\n    }\\n\\n    void update(vector<Block> &tree, int st, int emd, int node, int idx, char ch){\\n        if(st==emd){\\n            tree[node].pfc = tree[node].sfc = ch;\\n            return;\\n        }\\n\\n        int mid = (st+emd)/2;\\n        if(idx<=mid) update(tree, st, mid, 2*node, idx, ch);\\n        else update(tree, mid+1, emd, 2*node+1, idx, ch);\\n\\n        tree[node].len = tree[2*node].len + tree[2*node+1].len;\\n        tree[node].ans = max(tree[2*node].ans, tree[2*node+1].ans);\\n        if(tree[2*node].sfc==tree[2*node+1].pfc) tree[node].ans = max(tree[node].ans, tree[2*node].sf+tree[2*node+1].pf);\\n        tree[node].pfc = tree[2*node].pfc, tree[node].sfc = tree[2*node+1].sfc;\\n\\n        tree[node].pf = tree[2*node].pf;\\n        if(tree[2*node].pf==tree[2*node].len && tree[2*node].sfc==tree[2*node+1].pfc)\\n            tree[node].pf = max(tree[node].pf, tree[2*node].len + tree[2*node+1].pf);\\n\\n        tree[node].sf = tree[2*node+1].sf;\\n        if(tree[2*node+1].len == tree[2*node+1].sf && tree[2*node+1].pfc==tree[2*node].sfc)\\n            tree[node].sf = max(tree[node].sf, tree[2*node+1].len + tree[2*node].sf);\\n    }\\n\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        int n = s.length();\\n        vector<Block> tree(4*n);\\n\\n        build(s, tree, 0, n-1, 1);\\n\\n        int q = queryIndices.size();\\n        vector<int> ans;\\n        for(int i=0;i<q;i++){\\n            update(tree, 0, n-1, 1, queryIndices[i], queryCharacters[i]);\\n            ans.push_back(tree[1].ans);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460196,
                "title": "golang-segmentation-tree-standard-way",
                "content": "# Intuition\\nI believer there\\'re a numerous of segmentation-tree based solutions out there being neat, efficient and clear. \\n\\nI present my `raw` segmentation tree based solutions here to provide a verbose while standard version of the solution. Optimizations may apply\\n\\n# Code\\n```\\n\\nfunc max(arr ...int) int {\\n\\tret := -1\\n\\tfor _, elem := range arr {\\n\\t\\tif ret < elem {\\n\\t\\t\\tret = elem\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n\\ntype SegTreeNode struct {\\n\\tlchar, rchar byte\\n\\tl, r, lc, rc int\\n\\tlth          int\\n\\tleft, right  *SegTreeNode\\n}\\n\\nfunc (n *SegTreeNode) Merge() {\\n\\tn.lc = n.left.lc\\n\\tn.rc = n.right.rc\\n\\tn.lchar = n.left.lchar\\n\\tn.rchar = n.right.rchar\\n\\tn.lth = max(n.left.lth, n.right.lth)\\n\\tif n.left.rchar == n.right.lchar {\\n\\t\\tn.lth = max(n.lth, n.left.rc+n.right.lc)\\n\\t\\tif n.left.lth == (n.left.r - n.left.l + 1) {\\n\\t\\t\\tn.lc = n.left.lc + n.right.lc\\n\\t\\t}\\n\\t\\tif n.right.lth == (n.right.r - n.right.l + 1) {\\n\\t\\t\\tn.rc = n.right.rc + n.left.rc\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc Split(l, r int, src *string) *SegTreeNode {\\n\\n\\tn := &SegTreeNode{\\n\\t\\tl:     l,\\n\\t\\tr:     r,\\n\\t\\tlchar: (*src)[l],\\n\\t\\trchar: (*src)[r],\\n\\t\\tlc:    1,\\n\\t\\trc:    1,\\n\\t\\tlth:   1,\\n\\t\\tleft:  nil,\\n\\t\\tright: nil,\\n\\t}\\n\\n\\tif l != r {\\n\\t\\tmid := (l + r) / 2\\n\\t\\tn.left = Split(l, mid, src)\\n\\t\\tn.right = Split(mid+1, r, src)\\n\\t\\tn.Merge()\\n\\t}\\n\\n\\treturn n\\n}\\n\\nfunc (n *SegTreeNode) Update(i int, c byte) *SegTreeNode {\\n\\n\\tif n == nil {\\n\\t\\treturn n\\n\\t} else if i < n.l || i > n.r {\\n\\t\\treturn n\\n\\t} else if n.l == n.r {\\n\\t\\tn.lchar = c\\n\\t\\tn.rchar = c\\n\\t\\treturn n\\n\\t}\\n\\n\\tn.left.Update(i, c)\\n\\tn.right.Update(i, c)\\n\\tn.Merge()\\n\\treturn n\\n}\\n\\nfunc longestRepeating(s string, queryCharacters string, queryIndices []int) []int {\\n\\t// Build Tree\\n\\troot := Split(0, len(s)-1, &s)\\n\\tn := len(queryCharacters)\\n\\tret := make([]int, 0)\\n\\tfor i := 0; i < n; i += 1 {\\n\\t\\troot.Update(queryIndices[i], queryCharacters[i])\\n\\t\\tret = append(ret, root.lth)\\n\\t}\\n\\treturn ret\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc max(arr ...int) int {\\n\\tret := -1\\n\\tfor _, elem := range arr {\\n\\t\\tif ret < elem {\\n\\t\\t\\tret = elem\\n\\t\\t}\\n\\t}\\n\\treturn ret\\n}\\n\\ntype SegTreeNode struct {\\n\\tlchar, rchar byte\\n\\tl, r, lc, rc int\\n\\tlth          int\\n\\tleft, right  *SegTreeNode\\n}\\n\\nfunc (n *SegTreeNode) Merge() {\\n\\tn.lc = n.left.lc\\n\\tn.rc = n.right.rc\\n\\tn.lchar = n.left.lchar\\n\\tn.rchar = n.right.rchar\\n\\tn.lth = max(n.left.lth, n.right.lth)\\n\\tif n.left.rchar == n.right.lchar {\\n\\t\\tn.lth = max(n.lth, n.left.rc+n.right.lc)\\n\\t\\tif n.left.lth == (n.left.r - n.left.l + 1) {\\n\\t\\t\\tn.lc = n.left.lc + n.right.lc\\n\\t\\t}\\n\\t\\tif n.right.lth == (n.right.r - n.right.l + 1) {\\n\\t\\t\\tn.rc = n.right.rc + n.left.rc\\n\\t\\t}\\n\\t}\\n}\\n\\nfunc Split(l, r int, src *string) *SegTreeNode {\\n\\n\\tn := &SegTreeNode{\\n\\t\\tl:     l,\\n\\t\\tr:     r,\\n\\t\\tlchar: (*src)[l],\\n\\t\\trchar: (*src)[r],\\n\\t\\tlc:    1,\\n\\t\\trc:    1,\\n\\t\\tlth:   1,\\n\\t\\tleft:  nil,\\n\\t\\tright: nil,\\n\\t}\\n\\n\\tif l != r {\\n\\t\\tmid := (l + r) / 2\\n\\t\\tn.left = Split(l, mid, src)\\n\\t\\tn.right = Split(mid+1, r, src)\\n\\t\\tn.Merge()\\n\\t}\\n\\n\\treturn n\\n}\\n\\nfunc (n *SegTreeNode) Update(i int, c byte) *SegTreeNode {\\n\\n\\tif n == nil {\\n\\t\\treturn n\\n\\t} else if i < n.l || i > n.r {\\n\\t\\treturn n\\n\\t} else if n.l == n.r {\\n\\t\\tn.lchar = c\\n\\t\\tn.rchar = c\\n\\t\\treturn n\\n\\t}\\n\\n\\tn.left.Update(i, c)\\n\\tn.right.Update(i, c)\\n\\tn.Merge()\\n\\treturn n\\n}\\n\\nfunc longestRepeating(s string, queryCharacters string, queryIndices []int) []int {\\n\\t// Build Tree\\n\\troot := Split(0, len(s)-1, &s)\\n\\tn := len(queryCharacters)\\n\\tret := make([]int, 0)\\n\\tfor i := 0; i < n; i += 1 {\\n\\t\\troot.Update(queryIndices[i], queryCharacters[i])\\n\\t\\tret = append(ret, root.lth)\\n\\t}\\n\\treturn ret\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3364499,
                "title": "c",
                "content": "```\\nclass Solution {\\nprivate:\\n    map<int, int>Map ; //key : interval head\\n                       //val : interval tail\\n    multiset<int>Set ; //lengths of all intervals\\n    int n ;\\n    string str ;\\n    void insert(int idx){\\n        auto iter = Map.upper_bound(idx);\\n        iter = prev(iter) ;\\n        int a = iter->first ;\\n        int b = iter->second ;\\n        if(a == b)\\n            return ;\\n        removeInterval(a);       \\n        if(a == idx){;\\n            addInterval(a, a);\\n            addInterval(a+1, b);\\n        }\\n        else if(b == idx){\\n            addInterval(a, b-1);\\n            addInterval(b, b);\\n        }\\n        else{\\n            addInterval(a, idx-1);\\n            addInterval(idx, idx);\\n            addInterval(idx+1, b);\\n        }\\n    }\\n    \\n    void mergeRight(int idx){\\n        if(idx == (n-1) || str[idx] != str[idx+1])\\n            return  ;\\n        auto iter = Map.lower_bound(idx+1);\\n        int b = iter->second;\\n        removeInterval(idx) ;\\n        removeInterval(idx+1) ;\\n        addInterval(idx, b) ;       \\n    }\\n    void mergeLeft(int idx){\\n        if(idx == 0 || str[idx] != str[idx-1])\\n            return  ;\\n        auto iter = Map.find(idx);\\n        iter = prev(iter) ;\\n        int a = iter->first ;\\n        int b = Map[idx] ;\\n        removeInterval(idx) ;\\n        removeInterval(a) ;\\n        addInterval(a, b) ;        \\n    }    \\n    \\n    void removeInterval(int idx){\\n        int b = Map[idx] ;\\n        Map.erase(idx) ;\\n        Set.erase(Set.find(b-idx+1)) ;        \\n    }\\n    \\n    void addInterval(int a, int b){\\n        Map[a] = b ;\\n        Set.insert(b-a + 1) ;\\n    }\\n    \\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        this->n = s.size() ;\\n        this->str = s ;\\n        for(int i = 0; i < n; i++){\\n            int j = i ;\\n            while(j < n && s[j] == s[i])\\n                j++ ;\\n            Map[i] = j-1 ;\\n            Set.insert(j-i) ;\\n            i = j - 1 ;\\n        }\\n            \\n        vector<int>ret ;\\n        for(int i = 0; i < queryIndices.size(); i++){\\n            int idx = queryIndices[i] ;\\n            if(str[idx] != queryCharacters[i]){               \\n                insert(idx) ;\\n                str[idx] = queryCharacters[i] ;\\n                mergeRight(idx) ;\\n                mergeLeft(idx) ;\\n            }\\n            ret.push_back(*Set.rbegin()) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    map<int, int>Map ; //key : interval head\\n                       //val : interval tail\\n    multiset<int>Set ; //lengths of all intervals\\n    int n ;\\n    string str ;\\n    void insert(int idx){\\n        auto iter = Map.upper_bound(idx);\\n        iter = prev(iter) ;\\n        int a = iter->first ;\\n        int b = iter->second ;\\n        if(a == b)\\n            return ;\\n        removeInterval(a);       \\n        if(a == idx){;\\n            addInterval(a, a);\\n            addInterval(a+1, b);\\n        }\\n        else if(b == idx){\\n            addInterval(a, b-1);\\n            addInterval(b, b);\\n        }\\n        else{\\n            addInterval(a, idx-1);\\n            addInterval(idx, idx);\\n            addInterval(idx+1, b);\\n        }\\n    }\\n    \\n    void mergeRight(int idx){\\n        if(idx == (n-1) || str[idx] != str[idx+1])\\n            return  ;\\n        auto iter = Map.lower_bound(idx+1);\\n        int b = iter->second;\\n        removeInterval(idx) ;\\n        removeInterval(idx+1) ;\\n        addInterval(idx, b) ;       \\n    }\\n    void mergeLeft(int idx){\\n        if(idx == 0 || str[idx] != str[idx-1])\\n            return  ;\\n        auto iter = Map.find(idx);\\n        iter = prev(iter) ;\\n        int a = iter->first ;\\n        int b = Map[idx] ;\\n        removeInterval(idx) ;\\n        removeInterval(a) ;\\n        addInterval(a, b) ;        \\n    }    \\n    \\n    void removeInterval(int idx){\\n        int b = Map[idx] ;\\n        Map.erase(idx) ;\\n        Set.erase(Set.find(b-idx+1)) ;        \\n    }\\n    \\n    void addInterval(int a, int b){\\n        Map[a] = b ;\\n        Set.insert(b-a + 1) ;\\n    }\\n    \\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        this->n = s.size() ;\\n        this->str = s ;\\n        for(int i = 0; i < n; i++){\\n            int j = i ;\\n            while(j < n && s[j] == s[i])\\n                j++ ;\\n            Map[i] = j-1 ;\\n            Set.insert(j-i) ;\\n            i = j - 1 ;\\n        }\\n            \\n        vector<int>ret ;\\n        for(int i = 0; i < queryIndices.size(); i++){\\n            int idx = queryIndices[i] ;\\n            if(str[idx] != queryCharacters[i]){               \\n                insert(idx) ;\\n                str[idx] = queryCharacters[i] ;\\n                mergeRight(idx) ;\\n                mergeLeft(idx) ;\\n            }\\n            ret.push_back(*Set.rbegin()) ;\\n        }\\n        return ret ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350862,
                "title": "c-segment-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    struct huy{\\n        int value;\\n        char left,right;\\n        int vl,vr;\\n        bool check;\\n    };\\n    huy tree[4*100001];\\n    void build(int id,int l,int r,string & s)\\n    {\\n        if(l==r)\\n        {\\n            tree[id].value=1;\\n            tree[id].left=s[l];\\n            tree[id].right=s[l];\\n            tree[id].vl=1;\\n            tree[id].vr=1;\\n            tree[id].check=true;\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        build(id*2,l,mid,s);\\n        build(id*2+1,mid+1,r,s);\\n        \\n        int temp=0,f1,f2;\\n            \\n        tree[id].left=tree[id*2].left;\\n        tree[id].right=tree[id*2+1].right;\\n        \\n        if(tree[id*2].right==tree[id*2+1].left) temp=tree[id*2].vr+tree[id*2+1].vl;\\n        \\n        if(tree[id*2].check==true)\\n        {\\n            if(tree[id*2].right==tree[id*2+1].left) tree[id].vl=temp;\\n            else tree[id].vl=tree[id*2].vl;\\n        }\\n        else tree[id].vl=tree[id*2].vl;\\n        if(tree[id*2+1].check==true)\\n        {\\n            if(tree[id*2].right==tree[id*2+1].left) tree[id].vr=temp;\\n            else tree[id].vr=tree[id*2+1].vr;\\n        }\\n        else tree[id].vr=tree[id*2+1].vr;\\n        \\n        if(tree[id*2].check==true&&tree[id*2+1].check==true&&tree[id*2].right==tree[id*2+1].left)\\n            tree[id].check=true;\\n        else tree[id].check=false;\\n        \\n        tree[id].value=max(temp,max(tree[id*2].value,tree[id*2+1].value));\\n    }\\n    void update(int id,int l,int r,int x,char huy,string & s)\\n    {\\n        if(l>x||r<x) return;\\n        if(l==r)\\n        {\\n            s[l]=huy;\\n            tree[id].left=s[l];\\n            tree[id].right=s[l];\\n            tree[id].vl=1;\\n            tree[id].vr=1;\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        update(id*2,l,mid,x,huy,s);\\n        update(id*2+1,mid+1,r,x,huy,s);\\n        \\n        int temp=0,f1,f2;\\n            \\n        tree[id].left=tree[id*2].left;\\n        tree[id].right=tree[id*2+1].right;\\n        \\n        if(tree[id*2].right==tree[id*2+1].left) temp=tree[id*2].vr+tree[id*2+1].vl;\\n        \\n        if(tree[id*2].check==true)\\n        {\\n            if(tree[id*2].right==tree[id*2+1].left) tree[id].vl=temp;\\n            else tree[id].vl=tree[id*2].vl;\\n        }\\n        else tree[id].vl=tree[id*2].vl;\\n        if(tree[id*2+1].check==true)\\n        {\\n            if(tree[id*2].right==tree[id*2+1].left) tree[id].vr=temp;\\n            else tree[id].vr=tree[id*2+1].vr;\\n        }\\n        else tree[id].vr=tree[id*2+1].vr;\\n        \\n        if(tree[id*2].check==true&&tree[id*2+1].check==true&&tree[id*2].right==tree[id*2+1].left)\\n            tree[id].check=true;\\n        else tree[id].check=false;\\n        \\n        tree[id].value=max(temp,max(tree[id*2].value,tree[id*2+1].value));\\n    }\\n    vector<int> longestRepeating(string & s, string & f, vector<int>& A) {\\n        build(1,0,s.size()-1,s);\\n        vector<int> ans(A.size());\\n        for(int i=0;i<=f.size()-1;i++)\\n        {\\n            update(1,0,s.size()-1,A[i],f[i],s);\\n            ans[i]=tree[1].value;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct huy{\\n        int value;\\n        char left,right;\\n        int vl,vr;\\n        bool check;\\n    };\\n    huy tree[4*100001];\\n    void build(int id,int l,int r,string & s)\\n    {\\n        if(l==r)\\n        {\\n            tree[id].value=1;\\n            tree[id].left=s[l];\\n            tree[id].right=s[l];\\n            tree[id].vl=1;\\n            tree[id].vr=1;\\n            tree[id].check=true;\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        build(id*2,l,mid,s);\\n        build(id*2+1,mid+1,r,s);\\n        \\n        int temp=0,f1,f2;\\n            \\n        tree[id].left=tree[id*2].left;\\n        tree[id].right=tree[id*2+1].right;\\n        \\n        if(tree[id*2].right==tree[id*2+1].left) temp=tree[id*2].vr+tree[id*2+1].vl;\\n        \\n        if(tree[id*2].check==true)\\n        {\\n            if(tree[id*2].right==tree[id*2+1].left) tree[id].vl=temp;\\n            else tree[id].vl=tree[id*2].vl;\\n        }\\n        else tree[id].vl=tree[id*2].vl;\\n        if(tree[id*2+1].check==true)\\n        {\\n            if(tree[id*2].right==tree[id*2+1].left) tree[id].vr=temp;\\n            else tree[id].vr=tree[id*2+1].vr;\\n        }\\n        else tree[id].vr=tree[id*2+1].vr;\\n        \\n        if(tree[id*2].check==true&&tree[id*2+1].check==true&&tree[id*2].right==tree[id*2+1].left)\\n            tree[id].check=true;\\n        else tree[id].check=false;\\n        \\n        tree[id].value=max(temp,max(tree[id*2].value,tree[id*2+1].value));\\n    }\\n    void update(int id,int l,int r,int x,char huy,string & s)\\n    {\\n        if(l>x||r<x) return;\\n        if(l==r)\\n        {\\n            s[l]=huy;\\n            tree[id].left=s[l];\\n            tree[id].right=s[l];\\n            tree[id].vl=1;\\n            tree[id].vr=1;\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        update(id*2,l,mid,x,huy,s);\\n        update(id*2+1,mid+1,r,x,huy,s);\\n        \\n        int temp=0,f1,f2;\\n            \\n        tree[id].left=tree[id*2].left;\\n        tree[id].right=tree[id*2+1].right;\\n        \\n        if(tree[id*2].right==tree[id*2+1].left) temp=tree[id*2].vr+tree[id*2+1].vl;\\n        \\n        if(tree[id*2].check==true)\\n        {\\n            if(tree[id*2].right==tree[id*2+1].left) tree[id].vl=temp;\\n            else tree[id].vl=tree[id*2].vl;\\n        }\\n        else tree[id].vl=tree[id*2].vl;\\n        if(tree[id*2+1].check==true)\\n        {\\n            if(tree[id*2].right==tree[id*2+1].left) tree[id].vr=temp;\\n            else tree[id].vr=tree[id*2+1].vr;\\n        }\\n        else tree[id].vr=tree[id*2+1].vr;\\n        \\n        if(tree[id*2].check==true&&tree[id*2+1].check==true&&tree[id*2].right==tree[id*2+1].left)\\n            tree[id].check=true;\\n        else tree[id].check=false;\\n        \\n        tree[id].value=max(temp,max(tree[id*2].value,tree[id*2+1].value));\\n    }\\n    vector<int> longestRepeating(string & s, string & f, vector<int>& A) {\\n        build(1,0,s.size()-1,s);\\n        vector<int> ans(A.size());\\n        for(int i=0;i<=f.size()-1;i++)\\n        {\\n            update(1,0,s.size()-1,A[i],f[i],s);\\n            ans[i]=tree[1].value;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3340064,
                "title": "c-segment-tree-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a \"Point Update , Range Query\" question. So we can use segment tree to solve it. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complex of each update is O(logn).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n        public int[] LongestRepeating(string s, string queryCharacters, int[] queryIndices) {\\n            int n = queryCharacters.Length;\\n            var tree = new SegmentRepeatCharTree(s);\\n            int[] res = new int[n];\\n            for (int i = 0; i < n; i++)\\n            {\\n                res[i] = tree.Update(queryIndices[i], queryCharacters[i]);\\n            }\\n            return res;\\n    }\\n\\n        public class SegmentRepeatCharTree\\n    {\\n        private class SegmentRepeatCharNode\\n        {\\n            public char leftChar, rightChar;//chat at leftmost and right most indexes.\\n            public int start, end;//this node represent range [start,end] of string\\n            public int leftLen, rightLen;//len of same char from left and right\\n            public int max;//max length of this node\\n            public int count => end-start+1;//[start,end] contains how many chars\\n            public bool IsSame => this.max==this.count;//all chars same\\n            public SegmentRepeatCharNode leftNode, rightNode;//left and right childs\\n        }\\n\\n        private readonly SegmentRepeatCharNode root;\\n        private readonly char[] arr;\\n        public SegmentRepeatCharTree(string s)\\n        {\\n            int n = s.Length;\\n            this.arr = new char[n];//cache of current string\\n            this.root = buildInternal(s, 0, n-1);\\n        }\\n        private SegmentRepeatCharNode buildInternal(string s, int start, int end)\\n        {\\n            var node = new SegmentRepeatCharNode();\\n            node.start= start;\\n            node.end=end;\\n            node.leftChar=s[start];\\n            node.rightChar=s[end];\\n            if (start == end)\\n            {\\n                this.arr[start]=s[start];\\n\\n                node.leftLen=1;\\n                node.rightLen=1;\\n                node.max = 1;\\n            }\\n            else\\n            {\\n                int mid = start + (end - start) / 2;\\n                node.leftNode = buildInternal(s, start, mid);\\n                node.rightNode = buildInternal(s, mid + 1, end);\\n                mergeChildsInternal(node);\\n            }\\n            return node;\\n        }\\n        //merge two childs\\n        private void mergeChildsInternal(SegmentRepeatCharNode node)\\n        {\\n            node.leftChar = node.leftNode.leftChar;\\n            node.rightChar= node.rightNode.rightChar;\\n            //both same\\n            if (node.leftNode.IsSame && node.rightNode.IsSame)\\n            {\\n                if (node.leftNode.leftChar == node.rightNode.leftChar)\\n                {\\n                    //left and right childs contain only one char, merge them\\n                    node.max = node.count;\\n                    node.leftLen =node.count;\\n                    node.rightLen = node.count;\\n                }\\n                else\\n                {\\n                    //cannot merge\\n                    node.leftLen = node.leftNode.leftLen;\\n                    node.rightLen = node.rightNode.rightLen;\\n                    node.max = Math.Max(node.leftNode.max, node.rightNode.max);\\n                }\\n            }\\n            else if (node.leftNode.IsSame)//only left is same\\n            {\\n                if (node.leftNode.leftChar == node.rightNode.leftChar)\\n                {\\n                    node.leftLen = node.leftNode.count+node.rightNode.leftLen;\\n                    node.rightLen = node.rightNode.rightLen;\\n                    node.max = Math.Max(node.leftLen, node.rightNode.max);\\n                }\\n                else\\n                {\\n                    //cannot merge\\n                    node.leftLen = node.leftNode.leftLen;\\n                    node.rightLen = node.rightNode.rightLen;\\n                    node.max = Math.Max(node.leftNode.max, node.rightNode.max);\\n                }\\n            }\\n            else if (node.rightNode.IsSame)//only right is same\\n            {\\n                if (node.leftNode.rightChar == node.rightNode.leftChar)\\n                {\\n                    node.leftLen = node.leftNode.leftLen;\\n                    node.rightLen = node.leftNode.rightLen+ node.rightNode.count;\\n                    node.max = Math.Max(node.leftNode.max, node.rightLen);\\n                }\\n                else\\n                {\\n                    //cannot merge\\n                    node.leftLen = node.leftNode.leftLen;\\n                    node.rightLen = node.rightNode.rightLen;\\n                    node.max = Math.Max(node.leftNode.max, node.rightNode.max);\\n                }\\n            }\\n            else\\n            {\\n                node.leftLen = node.leftNode.leftLen;\\n                node.rightLen = node.rightNode.rightLen;\\n                if (node.leftNode.rightChar != node.rightNode.leftChar)\\n                {\\n                    node.max = Math.Max(node.leftNode.max, node.rightNode.max);\\n                }\\n                else\\n                {\\n                    node.max =Math.Max(node.leftNode.rightLen+node.rightNode.leftLen, Math.Max(node.leftNode.max, node.rightNode.max));\\n                }\\n            }\\n        }\\n\\n        public int Update(int index, char c)\\n        {\\n            if (this.arr[index]!=c)//skip useless update\\n                updateInternal(root, index, c);\\n            return this.root.max;\\n        }\\n\\n        private void updateInternal(SegmentRepeatCharNode node, int index, char c)\\n        {\\n            if (node.start == node.end)\\n            {\\n                this.arr[index] = c;\\n                node.leftChar=c;\\n                node.rightChar=c;\\n            }\\n            else\\n            {\\n                int mid = node.start + (node.end - node.start) / 2;\\n                if (index <= mid)\\n                {\\n                    updateInternal(node.leftNode, index, c);\\n                }\\n                else\\n                {\\n                    updateInternal(node.rightNode, index, c);\\n                }\\n\\n                mergeChildsInternal(node);\\n            }\\n        }\\n\\n        public int Max()\\n        {\\n            return this.root.max;\\n        }\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n        public int[] LongestRepeating(string s, string queryCharacters, int[] queryIndices) {\\n            int n = queryCharacters.Length;\\n            var tree = new SegmentRepeatCharTree(s);\\n            int[] res = new int[n];\\n            for (int i = 0; i < n; i++)\\n            {\\n                res[i] = tree.Update(queryIndices[i], queryCharacters[i]);\\n            }\\n            return res;\\n    }\\n\\n        public class SegmentRepeatCharTree\\n    {\\n        private class SegmentRepeatCharNode\\n        {\\n            public char leftChar, rightChar;//chat at leftmost and right most indexes.\\n            public int start, end;//this node represent range [start,end] of string\\n            public int leftLen, rightLen;//len of same char from left and right\\n            public int max;//max length of this node\\n            public int count => end-start+1;//[start,end] contains how many chars\\n            public bool IsSame => this.max==this.count;//all chars same\\n            public SegmentRepeatCharNode leftNode, rightNode;//left and right childs\\n        }\\n\\n        private readonly SegmentRepeatCharNode root;\\n        private readonly char[] arr;\\n        public SegmentRepeatCharTree(string s)\\n        {\\n            int n = s.Length;\\n            this.arr = new char[n];//cache of current string\\n            this.root = buildInternal(s, 0, n-1);\\n        }\\n        private SegmentRepeatCharNode buildInternal(string s, int start, int end)\\n        {\\n            var node = new SegmentRepeatCharNode();\\n            node.start= start;\\n            node.end=end;\\n            node.leftChar=s[start];\\n            node.rightChar=s[end];\\n            if (start == end)\\n            {\\n                this.arr[start]=s[start];\\n\\n                node.leftLen=1;\\n                node.rightLen=1;\\n                node.max = 1;\\n            }\\n            else\\n            {\\n                int mid = start + (end - start) / 2;\\n                node.leftNode = buildInternal(s, start, mid);\\n                node.rightNode = buildInternal(s, mid + 1, end);\\n                mergeChildsInternal(node);\\n            }\\n            return node;\\n        }\\n        //merge two childs\\n        private void mergeChildsInternal(SegmentRepeatCharNode node)\\n        {\\n            node.leftChar = node.leftNode.leftChar;\\n            node.rightChar= node.rightNode.rightChar;\\n            //both same\\n            if (node.leftNode.IsSame && node.rightNode.IsSame)\\n            {\\n                if (node.leftNode.leftChar == node.rightNode.leftChar)\\n                {\\n                    //left and right childs contain only one char, merge them\\n                    node.max = node.count;\\n                    node.leftLen =node.count;\\n                    node.rightLen = node.count;\\n                }\\n                else\\n                {\\n                    //cannot merge\\n                    node.leftLen = node.leftNode.leftLen;\\n                    node.rightLen = node.rightNode.rightLen;\\n                    node.max = Math.Max(node.leftNode.max, node.rightNode.max);\\n                }\\n            }\\n            else if (node.leftNode.IsSame)//only left is same\\n            {\\n                if (node.leftNode.leftChar == node.rightNode.leftChar)\\n                {\\n                    node.leftLen = node.leftNode.count+node.rightNode.leftLen;\\n                    node.rightLen = node.rightNode.rightLen;\\n                    node.max = Math.Max(node.leftLen, node.rightNode.max);\\n                }\\n                else\\n                {\\n                    //cannot merge\\n                    node.leftLen = node.leftNode.leftLen;\\n                    node.rightLen = node.rightNode.rightLen;\\n                    node.max = Math.Max(node.leftNode.max, node.rightNode.max);\\n                }\\n            }\\n            else if (node.rightNode.IsSame)//only right is same\\n            {\\n                if (node.leftNode.rightChar == node.rightNode.leftChar)\\n                {\\n                    node.leftLen = node.leftNode.leftLen;\\n                    node.rightLen = node.leftNode.rightLen+ node.rightNode.count;\\n                    node.max = Math.Max(node.leftNode.max, node.rightLen);\\n                }\\n                else\\n                {\\n                    //cannot merge\\n                    node.leftLen = node.leftNode.leftLen;\\n                    node.rightLen = node.rightNode.rightLen;\\n                    node.max = Math.Max(node.leftNode.max, node.rightNode.max);\\n                }\\n            }\\n            else\\n            {\\n                node.leftLen = node.leftNode.leftLen;\\n                node.rightLen = node.rightNode.rightLen;\\n                if (node.leftNode.rightChar != node.rightNode.leftChar)\\n                {\\n                    node.max = Math.Max(node.leftNode.max, node.rightNode.max);\\n                }\\n                else\\n                {\\n                    node.max =Math.Max(node.leftNode.rightLen+node.rightNode.leftLen, Math.Max(node.leftNode.max, node.rightNode.max));\\n                }\\n            }\\n        }\\n\\n        public int Update(int index, char c)\\n        {\\n            if (this.arr[index]!=c)//skip useless update\\n                updateInternal(root, index, c);\\n            return this.root.max;\\n        }\\n\\n        private void updateInternal(SegmentRepeatCharNode node, int index, char c)\\n        {\\n            if (node.start == node.end)\\n            {\\n                this.arr[index] = c;\\n                node.leftChar=c;\\n                node.rightChar=c;\\n            }\\n            else\\n            {\\n                int mid = node.start + (node.end - node.start) / 2;\\n                if (index <= mid)\\n                {\\n                    updateInternal(node.leftNode, index, c);\\n                }\\n                else\\n                {\\n                    updateInternal(node.rightNode, index, c);\\n                }\\n\\n                mergeChildsInternal(node);\\n            }\\n        }\\n\\n        public int Max()\\n        {\\n            return this.root.max;\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320310,
                "title": "longest-substring-with-one-repeating-charecter",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->sliding window approach \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->can refer to the longest substring with k unique charecter here it can be k=1\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# def longestKSubstr(s,k):\\n#         i=0\\n#         j=0\\n#         maxi=-float(\\'inf\\')\\n#         d=dict()\\n#         while j<len(s):\\n#             d[s[j]]=1+d.get(s[j],0)\\n#             if len(d)<k:\\n#                 j+=1\\n#             elif len(d)==k:\\n#                 maxi=max(maxi,(j-i+1))\\n#                 j+=1\\n#             elif len(d)>k:\\n#                 while len(d)>k:\\n#                     d[s[i]]-=1\\n#                     if d[s[i]]==0:\\n#                         del d[s[i]]\\n#                     i+=1\\n#                 if len(d)==k:\\n#                     maxi=max(maxi,j-i+1)\\n#                 j+=1\\n#         return maxi if maxi>0 else -1\\n# class Solution:\\n#     def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n          \\n#         # # m=list(s)\\n#         # # q=list(queryCharacters)\\n#         # res=[]\\n#         # for i in range(len(queryIndices)):\\n#         #     s=s[:queryIndices[i]] + queryCharacters[i] + s[queryIndices[i]+1:]\\n#         #     res.append(longestKSubstr(s,1))\\n#         #     # m[queryIndices[i]]=q[i]\\n#         #     # res.append(longestKSubstr(\\'\\'.join(m),1))\\n#         # return res\\n\\n#         res=[]\\n#         for i in range(len(queryIndices)):\\n#             s=s[:queryIndices[i]] + queryCharacters[i] + s[queryIndices[i]+1:]\\n#             res.append(longestKSubstr(s,1))\\n#         return res\\n\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        sl = SortedList()\\n        length = SortedList()\\n        curr = 0\\n        for char, it in itertools.groupby(s):\\n            c = sum(1 for _ in it)\\n            length.add(c)\\n            sl.add((curr, curr + c, char))\\n            curr += c\\n        ans = []\\n        for char, i in zip(queryCharacters, queryIndices):\\n            t = (i, math.inf, \\'a\\')\\n            index = sl.bisect_right(t) - 1\\n            to_remove = [sl[index]]\\n            to_add = []\\n            left, right, original_char = to_remove[0]\\n            if original_char != char:\\n                length.remove(right - left)\\n                if right - left > 1:\\n                    if i == left:\\n                        left += 1\\n                        to_add.append((left, right, original_char))\\n                        length.add(right - left)\\n                    elif i == right - 1:\\n                        right -= 1\\n                        to_add.append((left, right, original_char))\\n                        length.add(right - left)\\n                    else:\\n                        to_add.append((left, i, original_char))\\n                        length.add(i - left)\\n                        to_add.append((i + 1, right, original_char))\\n                        length.add(right - (i + 1))\\n                \\n                l, r = i, i + 1\\n                if index - 1 >= 0 and sl[index - 1][1:3] == (i, char):\\n                    l, old_r, _ = sl[index - 1]\\n                    to_remove.append(sl[index - 1])\\n                    length.remove(old_r - l)\\n                if index + 1 < len(sl) and sl[index + 1][0] == i + 1 and sl[index + 1][2] == char:\\n                    old_l, r, old_length = sl[index + 1]\\n                    to_remove.append(sl[index + 1])\\n                    length.remove(r - old_l)\\n                length.add(r - l)\\n                sl.add((l, r, char))\\n                for t in to_remove:\\n                    sl.remove(t)\\n                sl.update(to_add)\\n            # print(sl)\\n            # print(length)\\n            ans.append(length[-1])\\n\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\n# def longestKSubstr(s,k):\\n#         i=0\\n#         j=0\\n#         maxi=-float(\\'inf\\')\\n#         d=dict()\\n#         while j<len(s):\\n#             d[s[j]]=1+d.get(s[j],0)\\n#             if len(d)<k:\\n#                 j+=1\\n#             elif len(d)==k:\\n#                 maxi=max(maxi,(j-i+1))\\n#                 j+=1\\n#             elif len(d)>k:\\n#                 while len(d)>k:\\n#                     d[s[i]]-=1\\n#                     if d[s[i]]==0:\\n#                         del d[s[i]]\\n#                     i+=1\\n#                 if len(d)==k:\\n#                     maxi=max(maxi,j-i+1)\\n#                 j+=1\\n#         return maxi if maxi>0 else -1\\n# class Solution:\\n#     def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n          \\n#         # # m=list(s)\\n#         # # q=list(queryCharacters)\\n#         # res=[]\\n#         # for i in range(len(queryIndices)):\\n#         #     s=s[:queryIndices[i]] + queryCharacters[i] + s[queryIndices[i]+1:]\\n#         #     res.append(longestKSubstr(s,1))\\n#         #     # m[queryIndices[i]]=q[i]\\n#         #     # res.append(longestKSubstr(\\'\\'.join(m),1))\\n#         # return res\\n\\n#         res=[]\\n#         for i in range(len(queryIndices)):\\n#             s=s[:queryIndices[i]] + queryCharacters[i] + s[queryIndices[i]+1:]\\n#             res.append(longestKSubstr(s,1))\\n#         return res\\n\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        sl = SortedList()\\n        length = SortedList()\\n        curr = 0\\n        for char, it in itertools.groupby(s):\\n            c = sum(1 for _ in it)\\n            length.add(c)\\n            sl.add((curr, curr + c, char))\\n            curr += c\\n        ans = []\\n        for char, i in zip(queryCharacters, queryIndices):\\n            t = (i, math.inf, \\'a\\')\\n            index = sl.bisect_right(t) - 1\\n            to_remove = [sl[index]]\\n            to_add = []\\n            left, right, original_char = to_remove[0]\\n            if original_char != char:\\n                length.remove(right - left)\\n                if right - left > 1:\\n                    if i == left:\\n                        left += 1\\n                        to_add.append((left, right, original_char))\\n                        length.add(right - left)\\n                    elif i == right - 1:\\n                        right -= 1\\n                        to_add.append((left, right, original_char))\\n                        length.add(right - left)\\n                    else:\\n                        to_add.append((left, i, original_char))\\n                        length.add(i - left)\\n                        to_add.append((i + 1, right, original_char))\\n                        length.add(right - (i + 1))\\n                \\n                l, r = i, i + 1\\n                if index - 1 >= 0 and sl[index - 1][1:3] == (i, char):\\n                    l, old_r, _ = sl[index - 1]\\n                    to_remove.append(sl[index - 1])\\n                    length.remove(old_r - l)\\n                if index + 1 < len(sl) and sl[index + 1][0] == i + 1 and sl[index + 1][2] == char:\\n                    old_l, r, old_length = sl[index + 1]\\n                    to_remove.append(sl[index + 1])\\n                    length.remove(r - old_l)\\n                length.add(r - l)\\n                sl.add((l, r, char))\\n                for t in to_remove:\\n                    sl.remove(t)\\n                sl.update(to_add)\\n            # print(sl)\\n            # print(length)\\n            ans.append(length[-1])\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273621,
                "title": "c-segment-tree",
                "content": "```\\n// maintain the following properties for each segment\\nstruct Node {\\n    struct Pair {int c; int len;};\\n    int len; // total length of the segment\\n\\tPair left, right, max; // the {character, length} of the {leftmost, rightmost, longest} one-repeating substring\\n};\\n\\n// merge two segments\\nNode operator+ (const Node& l, const Node& r) {\\n    if (l.len == 0) return r;\\n    if (r.len == 0) return l;\\n    Node ret = {l.len + r.len, l.left, r.right, l.max.len > r.max.len ? l.max : r.max};\\n\\t// check if the leftmost/rightmost one-repeating substring will be updated\\n    if (l.left.c == r.left.c && l.left.len == l.len) ret.left.len += r.left.len;\\n    if (r.right.c == l.right.c && r.right.len == r.len) ret.right.len += l.right.len;\\n\\t// check if the longest one-repeating substring will be updated\\n    if (l.right.c == r.left.c && l.right.len + r.left.len > ret.max.len)\\n        ret.max = {l.right.c, l.right.len + r.left.len};\\n    return ret;\\n}\\n\\n// a quite normal segment tree\\nclass SegTree {\\npublic:\\n    SegTree(const string& _s): n(_s.size()), data(2 * _s.size()) {\\n        for (int i = 0; i < n; ++i)\\n            data[n + i] = {1, {_s[i], 1}, {_s[i], 1}, {_s[i], 1}};\\n        for (int i = n - 1; i > 0; --i) {\\n            data[i] = data[2 * i] + data[2 * i + 1];\\n        }\\n    }\\n\\n    void update(int p, int c) {\\n        data[n + p] = {1, {c, 1}, {c, 1}, {c, 1}};\\n        for (int i = (n + p) / 2; i > 0; i /= 2)\\n            data[i] = data[2 * i] + data[2 * i + 1];\\n    }\\n\\n    int query(int l, int r) {\\n        return doQuery(n + l, n + r).max.len;\\n    }\\n\\nprivate:\\n    Node doQuery(int l, int r) {\\n        if (l > r) return Node{0};\\n        Node leftend = l % 2 == 0 ? Node{0} : data[l++];\\n        Node rightend = r % 2 == 1 ? Node{0} : data[r--];\\n        return leftend + doQuery(l / 2, r / 2) + rightend;\\n    }\\n    vector<Node> data;\\n    int n;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        SegTree t(s);\\n        vector<int> res;\\n        for (int i = 0; i < queryCharacters.size(); ++i) {\\n            t.update(queryIndices[i], queryCharacters[i]);\\n            res.push_back(t.query(0, s.size() - 1));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// maintain the following properties for each segment\\nstruct Node {\\n    struct Pair {int c; int len;};\\n    int len; // total length of the segment\\n\\tPair left, right, max; // the {character, length} of the {leftmost, rightmost, longest} one-repeating substring\\n};\\n\\n// merge two segments\\nNode operator+ (const Node& l, const Node& r) {\\n    if (l.len == 0) return r;\\n    if (r.len == 0) return l;\\n    Node ret = {l.len + r.len, l.left, r.right, l.max.len > r.max.len ? l.max : r.max};\\n\\t// check if the leftmost/rightmost one-repeating substring will be updated\\n    if (l.left.c == r.left.c && l.left.len == l.len) ret.left.len += r.left.len;\\n    if (r.right.c == l.right.c && r.right.len == r.len) ret.right.len += l.right.len;\\n\\t// check if the longest one-repeating substring will be updated\\n    if (l.right.c == r.left.c && l.right.len + r.left.len > ret.max.len)\\n        ret.max = {l.right.c, l.right.len + r.left.len};\\n    return ret;\\n}\\n\\n// a quite normal segment tree\\nclass SegTree {\\npublic:\\n    SegTree(const string& _s): n(_s.size()), data(2 * _s.size()) {\\n        for (int i = 0; i < n; ++i)\\n            data[n + i] = {1, {_s[i], 1}, {_s[i], 1}, {_s[i], 1}};\\n        for (int i = n - 1; i > 0; --i) {\\n            data[i] = data[2 * i] + data[2 * i + 1];\\n        }\\n    }\\n\\n    void update(int p, int c) {\\n        data[n + p] = {1, {c, 1}, {c, 1}, {c, 1}};\\n        for (int i = (n + p) / 2; i > 0; i /= 2)\\n            data[i] = data[2 * i] + data[2 * i + 1];\\n    }\\n\\n    int query(int l, int r) {\\n        return doQuery(n + l, n + r).max.len;\\n    }\\n\\nprivate:\\n    Node doQuery(int l, int r) {\\n        if (l > r) return Node{0};\\n        Node leftend = l % 2 == 0 ? Node{0} : data[l++];\\n        Node rightend = r % 2 == 1 ? Node{0} : data[r--];\\n        return leftend + doQuery(l / 2, r / 2) + rightend;\\n    }\\n    vector<Node> data;\\n    int n;\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        SegTree t(s);\\n        vector<int> res;\\n        for (int i = 0; i < queryCharacters.size(); ++i) {\\n            t.update(queryIndices[i], queryCharacters[i]);\\n            res.push_back(t.query(0, s.size() - 1));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227775,
                "title": "python-ac-merge-intervals-explain-sortedcontainers",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use segment tree but it didn\\'t work for me in python TLE :(\\nWe can also think this problem as merging intervals, each interval will represent range of repeated characters.\\ninterval - [start,end,character]\\nFor each query update these intervals accordingly.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(NlogN)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(N)$$\\n# Code\\n```\\nfrom sortedcontainers import SortedList,SortedDict\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        n = len(s)\\n        lens = SortedDict() # lengths sorted order\\n        m = SortedList() # contain repeated intervals (start,end,char)\\n        m.add((-1,-1,\\'\\')) # handle edge case\\n        m.add((n,n,\\'\\'))\\n        # helper functions\\n        def add(start,end,c): # add interval \\n            m.add((start,end,c))\\n            lens[end-start+1] =lens.get(end-start+1,0) + 1\\n        def rm(ival): # remove interval\\n            m.remove(ival)\\n            ln = ival[1]-ival[0] + 1\\n            lens[ln] -=1\\n            if(lens[ln]<=0): del lens[ln]\\n        # building the m and lens\\n        i = 0\\n        while(i<n):\\n            c = s[i]\\n            start = i\\n            while(i<n and s[i]==c): i += 1\\n            add(start,i-1,c)\\n        def query(index,nc): # replace character at specific index\\n            pos = m.bisect_right((index,index,\\'\\'))\\n            if(m[pos][0]>index): pos -=1 \\n            ival = m[pos]\\n            if(ival[2]==nc): return lens.peekitem()[0]; # no change if same as old character\\n            prev,nxt = m[pos-1],m[pos+1] # get adjacent interval for possible merge\\n            cur = [index,index,nc]\\n            if(ival[0]==index and prev[2]==nc): # try to merge with prev\\n                cur[0] = prev[0]\\n                rm(prev)\\n            if(ival[1]==index and nxt[2]==nc): # merge with next\\n                cur[1] = nxt[1]\\n                rm(nxt)\\n            rm(ival)\\n            if(cur): add(*cur)\\n            if(ival[0]<cur[0]): add(ival[0],cur[0]-1,ival[2]) # split left\\n            if(ival[1]>cur[1]): add(cur[1]+1,ival[1],ival[2]) # split right\\n            return lens.peekitem()[0]\\n        return [query(j,queryCharacters[i]) for i,j in enumerate(queryIndices)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList,SortedDict\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        n = len(s)\\n        lens = SortedDict() # lengths sorted order\\n        m = SortedList() # contain repeated intervals (start,end,char)\\n        m.add((-1,-1,\\'\\')) # handle edge case\\n        m.add((n,n,\\'\\'))\\n        # helper functions\\n        def add(start,end,c): # add interval \\n            m.add((start,end,c))\\n            lens[end-start+1] =lens.get(end-start+1,0) + 1\\n        def rm(ival): # remove interval\\n            m.remove(ival)\\n            ln = ival[1]-ival[0] + 1\\n            lens[ln] -=1\\n            if(lens[ln]<=0): del lens[ln]\\n        # building the m and lens\\n        i = 0\\n        while(i<n):\\n            c = s[i]\\n            start = i\\n            while(i<n and s[i]==c): i += 1\\n            add(start,i-1,c)\\n        def query(index,nc): # replace character at specific index\\n            pos = m.bisect_right((index,index,\\'\\'))\\n            if(m[pos][0]>index): pos -=1 \\n            ival = m[pos]\\n            if(ival[2]==nc): return lens.peekitem()[0]; # no change if same as old character\\n            prev,nxt = m[pos-1],m[pos+1] # get adjacent interval for possible merge\\n            cur = [index,index,nc]\\n            if(ival[0]==index and prev[2]==nc): # try to merge with prev\\n                cur[0] = prev[0]\\n                rm(prev)\\n            if(ival[1]==index and nxt[2]==nc): # merge with next\\n                cur[1] = nxt[1]\\n                rm(nxt)\\n            rm(ival)\\n            if(cur): add(*cur)\\n            if(ival[0]<cur[0]): add(ival[0],cur[0]-1,ival[2]) # split left\\n            if(ival[1]>cur[1]): add(cur[1]+1,ival[1],ival[2]) # split right\\n            return lens.peekitem()[0]\\n        return [query(j,queryCharacters[i]) for i,j in enumerate(queryIndices)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3185795,
                "title": "best-python-sol",
                "content": "\\n# Code\\n```\\n\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def longestRepeating(self, s: str, qc: str, qi):\\n        qr = list(zip(list(qc), qi))\\n        srt = SortedList([])\\n        mx = SortedList([])\\n        cr = s[0]\\n        sz = 1\\n        start, end = 0, 0\\n        for i in range(1, len(s)):\\n            if s[i] == cr:\\n                sz += 1\\n                end = i\\n            else:\\n                srt.add((start, end, sz, cr))\\n                mx.add(sz)\\n                cr = s[i]\\n                start = i\\n                end = i\\n                sz = 1\\n        srt.add((start, end, sz, cr))\\n        mx.add(sz)\\n        s = list(s)\\n        n = len(s)\\n        ans = [0] * len(qr)\\n        for id, (ch, ind) in enumerate(qr):\\n            if s[ind] == ch:\\n                ans[id] = mx[-1]\\n                continue\\n            s[ind] = ch\\n\\n            ll = srt.bisect_left((ind, n + 1, n + 1, \"z\")) - 1\\n            start, end, sz, cho = srt[ll]\\n            srt.pop(ll)\\n            # todo start==end\\n            if start == end:\\n\\n                mx.remove(sz)\\n                if ind + 1 < n and s[ind + 1] == ch and ind - 1 >= 0 and s[ind - 1] == ch:\\n                    ll = srt.bisect_left((ind + 1, n + 1, n + 1, \"z\")) - 1\\n                    sr, endr, szr, chr = srt[ll]\\n                    srt.pop(ll)\\n                    mx.remove(szr)\\n                    ll = srt.bisect_left((ind - 1, n + 1, n + 1, \"z\")) - 1\\n                    sl, endl, szl, chl = srt[ll]\\n                    srt.pop(ll)\\n                    mx.remove(szl)\\n                    mid = (sl, endr, szr+szl+1, ch)\\n                    srt.add(mid)\\n                    mx.add(szr+szl+1)\\n                elif ind + 1 < n and s[ind + 1] == ch:\\n                    ll = srt.bisect_left((ind + 1, n + 1, n + 1, \"z\")) - 1\\n                    sr, endr, szr, chr = srt[ll]\\n                    srt.pop(ll)\\n                    right = (ind, endr, szr + 1, chr)\\n                    srt.add(right)\\n                    mx.remove(szr)\\n                    mx.add(szr + 1)\\n                elif ind - 1 >= 0 and s[ind - 1] == ch:\\n                    ll = srt.bisect_left((ind - 1, n + 1, n + 1, \"z\")) - 1\\n                    sl, endl, szl, chl = srt[ll]\\n                    srt.pop(ll)\\n                    left = (sl, ind, szl + 1, ch)\\n                    srt.add(left)\\n                    mx.remove(szl)\\n                    mx.add(szl + 1)\\n                else:\\n                    srt.add((start, end, sz, ch))\\n                    mx.add(sz)\\n\\n            elif ind == end:\\n                left = (start, end - 1, sz - 1, cho)\\n                srt.add(left)\\n                mx.remove(sz)\\n                mx.add(sz - 1)\\n                if ind + 1 < n and s[ind + 1] == ch:\\n                    ll = srt.bisect_left((ind + 1, n + 1, n + 1, \"z\")) - 1\\n                    sr, endr, szr, chr = srt[ll]\\n                    srt.pop(ll)\\n                    right = (ind, endr, szr + 1, chr)\\n                    srt.add(right)\\n                    mx.remove(szr)\\n                    mx.add(szr + 1)\\n                else:\\n                    right = (ind, ind, 1, ch)\\n                    srt.add(right)\\n                    mx.add(1)\\n            elif ind == start:\\n                right = (start + 1, end, sz - 1, cho)\\n                srt.add(right)\\n                mx.remove(sz)\\n                mx.add(sz-1)\\n                if ind - 1 >= 0 and s[ind - 1] == ch:\\n                    ll = srt.bisect_left((ind - 1, n + 1, n + 1, \"z\")) - 1\\n                    sl, endl, szl, chl = srt[ll]\\n                    srt.pop(ll)\\n                    left = (sl, ind, szl + 1, ch)\\n                    mx.remove(szl)\\n                    srt.add(left)\\n                    mx.add(szl + 1)\\n                else:\\n                    left = (ind, ind, 1, ch)\\n                    srt.add(left)\\n                    mx.add(1)\\n            else:\\n                left = (start, ind - 1, ((ind - 1)-start + 1), cho)\\n                mid = (ind, ind, 1, ch)\\n                right = (ind + 1, end, (end - (ind + 1) +1), cho)\\n                srt.add(left)\\n                srt.add(right)\\n                srt.add(mid)\\n                mx.remove(sz)\\n                mx.add(left[2])\\n                mx.add(right[2])\\n                mx.add(1)\\n\\n            ans[id] = mx[-1]\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def longestRepeating(self, s: str, qc: str, qi):\\n        qr = list(zip(list(qc), qi))\\n        srt = SortedList([])\\n        mx = SortedList([])\\n        cr = s[0]\\n        sz = 1\\n        start, end = 0, 0\\n        for i in range(1, len(s)):\\n            if s[i] == cr:\\n                sz += 1\\n                end = i\\n            else:\\n                srt.add((start, end, sz, cr))\\n                mx.add(sz)\\n                cr = s[i]\\n                start = i\\n                end = i\\n                sz = 1\\n        srt.add((start, end, sz, cr))\\n        mx.add(sz)\\n        s = list(s)\\n        n = len(s)\\n        ans = [0] * len(qr)\\n        for id, (ch, ind) in enumerate(qr):\\n            if s[ind] == ch:\\n                ans[id] = mx[-1]\\n                continue\\n            s[ind] = ch\\n\\n            ll = srt.bisect_left((ind, n + 1, n + 1, \"z\")) - 1\\n            start, end, sz, cho = srt[ll]\\n            srt.pop(ll)\\n            # todo start==end\\n            if start == end:\\n\\n                mx.remove(sz)\\n                if ind + 1 < n and s[ind + 1] == ch and ind - 1 >= 0 and s[ind - 1] == ch:\\n                    ll = srt.bisect_left((ind + 1, n + 1, n + 1, \"z\")) - 1\\n                    sr, endr, szr, chr = srt[ll]\\n                    srt.pop(ll)\\n                    mx.remove(szr)\\n                    ll = srt.bisect_left((ind - 1, n + 1, n + 1, \"z\")) - 1\\n                    sl, endl, szl, chl = srt[ll]\\n                    srt.pop(ll)\\n                    mx.remove(szl)\\n                    mid = (sl, endr, szr+szl+1, ch)\\n                    srt.add(mid)\\n                    mx.add(szr+szl+1)\\n                elif ind + 1 < n and s[ind + 1] == ch:\\n                    ll = srt.bisect_left((ind + 1, n + 1, n + 1, \"z\")) - 1\\n                    sr, endr, szr, chr = srt[ll]\\n                    srt.pop(ll)\\n                    right = (ind, endr, szr + 1, chr)\\n                    srt.add(right)\\n                    mx.remove(szr)\\n                    mx.add(szr + 1)\\n                elif ind - 1 >= 0 and s[ind - 1] == ch:\\n                    ll = srt.bisect_left((ind - 1, n + 1, n + 1, \"z\")) - 1\\n                    sl, endl, szl, chl = srt[ll]\\n                    srt.pop(ll)\\n                    left = (sl, ind, szl + 1, ch)\\n                    srt.add(left)\\n                    mx.remove(szl)\\n                    mx.add(szl + 1)\\n                else:\\n                    srt.add((start, end, sz, ch))\\n                    mx.add(sz)\\n\\n            elif ind == end:\\n                left = (start, end - 1, sz - 1, cho)\\n                srt.add(left)\\n                mx.remove(sz)\\n                mx.add(sz - 1)\\n                if ind + 1 < n and s[ind + 1] == ch:\\n                    ll = srt.bisect_left((ind + 1, n + 1, n + 1, \"z\")) - 1\\n                    sr, endr, szr, chr = srt[ll]\\n                    srt.pop(ll)\\n                    right = (ind, endr, szr + 1, chr)\\n                    srt.add(right)\\n                    mx.remove(szr)\\n                    mx.add(szr + 1)\\n                else:\\n                    right = (ind, ind, 1, ch)\\n                    srt.add(right)\\n                    mx.add(1)\\n            elif ind == start:\\n                right = (start + 1, end, sz - 1, cho)\\n                srt.add(right)\\n                mx.remove(sz)\\n                mx.add(sz-1)\\n                if ind - 1 >= 0 and s[ind - 1] == ch:\\n                    ll = srt.bisect_left((ind - 1, n + 1, n + 1, \"z\")) - 1\\n                    sl, endl, szl, chl = srt[ll]\\n                    srt.pop(ll)\\n                    left = (sl, ind, szl + 1, ch)\\n                    mx.remove(szl)\\n                    srt.add(left)\\n                    mx.add(szl + 1)\\n                else:\\n                    left = (ind, ind, 1, ch)\\n                    srt.add(left)\\n                    mx.add(1)\\n            else:\\n                left = (start, ind - 1, ((ind - 1)-start + 1), cho)\\n                mid = (ind, ind, 1, ch)\\n                right = (ind + 1, end, (end - (ind + 1) +1), cho)\\n                srt.add(left)\\n                srt.add(right)\\n                srt.add(mid)\\n                mx.remove(sz)\\n                mx.add(left[2])\\n                mx.add(right[2])\\n                mx.add(1)\\n\\n            ans[id] = mx[-1]\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157720,
                "title": "best-explained-solution",
                "content": "\\n```\\nclass sgtree{\\npublic:\\n    vector<int> nums,left,right;\\n    vector<char> lc,rc; int n;\\n    sgtree(string &s){\\n        n = s.size();\\n        nums = vector<int>(4*n+5,0);\\n        left = vector<int>(4*n+5,-1);\\n        right = vector<int>(4*n+5,-1);\\n        lc = vector<char>(4*n+5,\\'*\\');\\n        rc = vector<char>(4*n+5,\\'*\\');\\n        build(0,s,0,n-1);\\n    }\\n    void build(int in, string &s,int l,int h){\\n        if(l>h) return;\\n        if(l==h){\\n            lc[in] = rc[in] = s[l];\\n            left[in] = l,right[in] = l; nums[in] = 1;\\n            return;\\n        }\\n        int m = (l+h)/2;\\n        build(2*in+1,s,l,m); build(2*in+2,s,m+1,h); \\n        merge(in,l,m,h);\\n    }\\n    void merge(int in,int l,int m,int h){\\n        int lt = in*2+1, rt = in*2+2, max_ = 0;\\n        lc[in] = lc[lt]; rc[in] = rc[rt];\\n        left[in] = left[lt];\\n        right[in] = right[rt]; \\n        if(rc[lt]==lc[rt]){ \\n            if(left[lt]==m) left[in] = left[rt];\\n        }\\n        if(lc[rt]==rc[lt]){ \\n            if(right[rt]==m+1) right[in] = right[lt]; \\n        }\\n        if(rc[lt]==lc[rt]) max_ = left[rt]-right[lt]+1;\\n        \\n        max_ = max(max_,left[in]-l+1);\\n        max_ = max(max_,h-right[in]+1);\\n        nums[in] = max(max_,max(nums[lt],nums[rt]));\\n    }\\n    int update(int in,int l,int h,int j,char ch){\\n        if(l>h) return 0;\\n        if(l==h){\\n            lc[in] = rc[in] = ch;\\n            left[in] = l,right[in] = l; nums[in] = 1;\\n            return 1;\\n        }\\n        int m = (l+h)/2;\\n        if(j>=l && j<=m) update(2*in+1,l,m,j,ch);\\n        else update(2*in+2,m+1,h,j,ch); \\n        merge(in,l,m,h);\\n        return nums[in];\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string q, vector<int>& in) {\\n        sgtree node(s);\\n        vector<int> re(q.size(),0);\\n        for(int i = 0; i<q.size();++i){\\n            re[i] = node.update(0,0,s.size()-1,in[i],q[i]);\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ruby",
                    "Bash",
                    "Go",
                    "Scala",
                    "Kotlin"
                ],
                "code": "```\\nclass sgtree{\\npublic:\\n    vector<int> nums,left,right;\\n    vector<char> lc,rc; int n;\\n    sgtree(string &s){\\n        n = s.size();\\n        nums = vector<int>(4*n+5,0);\\n        left = vector<int>(4*n+5,-1);\\n        right = vector<int>(4*n+5,-1);\\n        lc = vector<char>(4*n+5,\\'*\\');\\n        rc = vector<char>(4*n+5,\\'*\\');\\n        build(0,s,0,n-1);\\n    }\\n    void build(int in, string &s,int l,int h){\\n        if(l>h) return;\\n        if(l==h){\\n            lc[in] = rc[in] = s[l];\\n            left[in] = l,right[in] = l; nums[in] = 1;\\n            return;\\n        }\\n        int m = (l+h)/2;\\n        build(2*in+1,s,l,m); build(2*in+2,s,m+1,h); \\n        merge(in,l,m,h);\\n    }\\n    void merge(int in,int l,int m,int h){\\n        int lt = in*2+1, rt = in*2+2, max_ = 0;\\n        lc[in] = lc[lt]; rc[in] = rc[rt];\\n        left[in] = left[lt];\\n        right[in] = right[rt]; \\n        if(rc[lt]==lc[rt]){ \\n            if(left[lt]==m) left[in] = left[rt];\\n        }\\n        if(lc[rt]==rc[lt]){ \\n            if(right[rt]==m+1) right[in] = right[lt]; \\n        }\\n        if(rc[lt]==lc[rt]) max_ = left[rt]-right[lt]+1;\\n        \\n        max_ = max(max_,left[in]-l+1);\\n        max_ = max(max_,h-right[in]+1);\\n        nums[in] = max(max_,max(nums[lt],nums[rt]));\\n    }\\n    int update(int in,int l,int h,int j,char ch){\\n        if(l>h) return 0;\\n        if(l==h){\\n            lc[in] = rc[in] = ch;\\n            left[in] = l,right[in] = l; nums[in] = 1;\\n            return 1;\\n        }\\n        int m = (l+h)/2;\\n        if(j>=l && j<=m) update(2*in+1,l,m,j,ch);\\n        else update(2*in+2,m+1,h,j,ch); \\n        merge(in,l,m,h);\\n        return nums[in];\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string q, vector<int>& in) {\\n        sgtree node(s);\\n        vector<int> re(q.size(),0);\\n        for(int i = 0; i<q.size();++i){\\n            re[i] = node.update(0,0,s.size()-1,in[i],q[i]);\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126889,
                "title": "segment-tree",
                "content": "public class Solution {\\n    int N;\\n    Node[] bt;\\n    public class Node{\\n        public int max;\\n        public int left,right;\\n        public char leftc,rightc;\\n        int sum;\\n        public Node(){\\n            max=-1;\\n            left=0;\\n            right=0;\\n            leftc=\\' \\';\\n            rightc=\\' \\';\\n            sum=0;\\n        }\\n        \\n        public void Add(char c)\\n        {\\n            max=1;\\n            left=right=1;\\n            leftc=rightc=c;\\n            sum=1;\\n        }\\n        \\n        public void Adjust(Node lnode,Node rnode)\\n        {\\n            max=Math.Max(rnode.max,lnode.max);\\n            left=lnode.left;\\n            leftc=lnode.leftc;\\n            right=rnode.right;\\n            rightc=rnode.rightc;\\n            if(lnode.rightc==rnode.leftc){\\n                max=Math.Max(max,lnode.right+rnode.left);\\n                if(lnode.isAllSame())\\n                    left+=rnode.left;\\n                if(rnode.isAllSame())\\n                    right+=lnode.right;\\n            }\\n            \\n            sum=lnode.sum+rnode.sum;\\n        }\\n        \\n        public bool isAllSame()\\n        {\\n            return (max==sum);\\n                \\n            \\n        }\\n        \\n    }// class\\n    \\n    \\n    \\n    \\n    public int[] LongestRepeating(string s, string queryCharacters, int[] queryIndices) {\\n        int[] result=new int[queryCharacters.Length];\\n        N=1;\\n        while(N<Math.Min(100_000,s.Length))\\n            N=N<<1;    \\n        \\n        bt=new Node[2*N-1];\\n        \\n        for(int ii=0;ii<N;ii++)\\n        {\\n            bt[N+ii-1]=new Node();\\n            if(ii<s.Length) bt[N+ii-1].Add(s[ii]);\\n            \\n        }\\n\\n        int a=N-1;\\n        while(a>0)\\n        {\\n            a=(a-1)/2;\\n\\n            for(int t=a;t<2*a+1;t++)\\n            {\\n                bt[t]=new Node();\\n                bt[t].Adjust(bt[t*2+1],bt[t*2+2]);                \\n                \\n            }\\n\\n            \\n        }\\n        \\n        for(int i=0;i<queryCharacters.Length;i++)\\n        {\\n            int curr=N-1+queryIndices[i];\\n            \\n            bt[curr].Add(queryCharacters[i]);\\n            while(curr>0){\\n                curr=(curr-1)/2;\\n                bt[curr].Adjust(bt[curr*2+1],bt[curr*2+2]);\\n            }\\n\\n            result[i]=bt[0].max;\\n        }\\n        return result;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int N;\\n    Node[] bt;\\n    public class Node{\\n        public int max;\\n        public int left,right;\\n        public char leftc,rightc;\\n        int sum;\\n        public Node(){\\n            max=-1;\\n            left=0;\\n            right=0;\\n            leftc=\\' \\';\\n            rightc=\\' \\';\\n            sum=0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3125761,
                "title": "order-set-map-solutions-with-explanation-c-beat-70-step-by-step-thinking-process",
                "content": "# Intuition\\nTime complexity hints: the input size is 10^5 so we could only use at most o(nlogn) algorithm.\\n\\n# What we need to do:\\n- Converting a character, find the maximum consecutive string\\n\\n### What is converting a character\\nObservation: converting a character is the same as the following: \\n-> given a consecutive string `\"aaaaaa\"`, a char would be convert at the beginning `\"baaaaa\"`/ middle `\"aabaaa\"`/ end `\"aaaaab\"`\\n\\nWhich creates three cases `[0:1), [1:end)`/ `[0:k), [k:k+1), [k+1: end)` /`\"[0:end - 1), [end - 1: end)\"`\\n=> without the lost of generality, we could transfer all the case to the middle case.\\n=> That is for begin: `\"[0,0), [0:1), [1:end)\"` where k = 0\\n=> for end: `\"[0: end - 1), [end - 1, end), [end, end)\"` where k = end - 1\\n\\n### By understand the first observation\\n- We could easily know that in each convertion, it will break a consecutive string into three pieces.\\n    - That is \"xxxx\", \"yyyy\", \"zzzz\" (without lost of generality we could ignore the length of each consecutive string: it could be 0, 1, n length)\\n    - Let roll back a little bit and see the original string.\\n        - original: `\"other consecutive\"` + `\"consecutive 1\"`+  `\"consecutive 2\"` + `\"consecutive 3\"` + `\"other consecutive\"`\\n        - now: `\"consecutive 1\"`+  `\"xxxx\"` + `\"yyyy\"` + `\"zzzz\"` + `\"consecutive 3\"`\\n    - To find the max consecutive, there only few cases:\\n        1. it would some consecutives no related this change\\n        2. `\"consecutive 1\"` + `\"xxxx\"`\\n        3. `\"yyyy\"`\\n        4. `\"zzzz\"` + `\"consecutive 3\"`\\n        - By default, x != y and y != z since we break the consecutive by changing one element\\n\\n### Let move to the algorithm\\n1. We locate the consecutive we would like to change \\n    - My implementation: use a set to search the upper and lower bound of consecutive quickly in `log(n) time`\\n2. We change the consecutive and split it to 3 consecutive\\n    - My implementation: insert the upper and lower bound for each consecutive into set `log(n) time` * 6 operations\\n3. We merge `\"consecutive 1\"` and `\"xxxx\"` if they are the same\\n    - My implementation: erase the bound in the set if they are the same `log(n) time`\\n4. We merge `\"zzzz\"` and `\"consecutive 3\"` if they are the same \\n    - My implementation: erase the bound in the set if they are the same `log(n) time`\\n5. During the algorithm, we used a order map to keep count the length of each consecutive where the key is length and the value is how many consecutive have the this length.\\n    - Add the order map last key into answer vector in each operation.\\n\\n# Time complexity\\n- `log(n)` for each iteration\\n- Total: O(`nlog(n)`) for n iteration\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        set<int> count;\\n        map<int, int> dict;\\n        int last(0);\\n        count.insert(-1);\\n        count.insert(0);\\n        for (int i = 1; i < s.size(); ++i){\\n            if (s[i] != s[i - 1]) {\\n                count.insert(i);\\n                dict[i - last]++;\\n                last = i;    \\n            }\\n        }\\n        count.insert(s.size());\\n        dict[s.size() - last]++;\\n        vector<int> ans(queryCharacters.size(), 0);\\n\\n        for (int i = 0; i < queryCharacters.size(); ++i){\\n            // for (auto &a: dict) cout << a.first << \":\" << a.second << \" \";\\n            // cout << endl;\\n            // for (auto &a: count) cout << a << \" \";\\n            // cout << endl;\\n            if (queryCharacters[i] == s[queryIndices[i]]) ans[i] = dict.rbegin()->first;\\n            else{\\n                auto it2 = count.upper_bound(queryIndices[i]);\\n                auto it1 = prev(it2);\\n                dict[*it2 - *it1]--;\\n                if (dict[*it2 - *it1] == 0) dict.erase(dict.find(*it2 - *it1));\\n                if (queryIndices[i] - *it1 != 0) dict[queryIndices[i] - *it1]++;\\n                dict[1]++;\\n                if (*it2 - (queryIndices[i] + 1) != 0) dict[*it2 - queryIndices[i] - 1]++;\\n                count.insert(queryIndices[i]);\\n                count.insert(queryIndices[i] + 1);\\n                s[queryIndices[i]] = queryCharacters[i];\\n                it2 = count.lower_bound(queryIndices[i]);\\n                it1 = prev(it2);\\n                if (*it1 == -1){\\n                    it1 = next(it1);\\n                    it2 = next(it2);\\n                }else{\\n                    if (s[*it1] == s[*it2]){\\n                        dict[*it2 - *it1]--;\\n                        dict[1]--;\\n                        if (dict[*it2 - *it1] == 0) dict.erase(dict.find(*it2 - *it1));\\n                        if (dict[1] == 0) dict.erase(dict.find(1));\\n                        count.erase(it2);\\n                        it2 = count.upper_bound(queryIndices[i]);\\n                        dict[*it2 - *it1]++;\\n                    }else{\\n                        it1 = next(it1);\\n                        it2 = next(it2);\\n                    }\\n                }\\n\\n                if (*it2 != s.size()){\\n                    if (s[*it1] == s[*it2]){\\n                        dict[*it2 - *it1]--;\\n                        if (dict[*it2 - *it1] == 0) dict.erase(dict.find(*it2 - *it1));\\n                        dict[*next(it2) - *it2]--;\\n                        if (dict[*next(it2) - *it2] == 0) dict.erase(dict.find(*next(it2) - *it2));\\n                        count.erase(it2);\\n                        it2 = count.upper_bound(queryIndices[i] + 1);\\n                        dict[*it2 - *it1]++;\\n                    }\\n                }\\n            }\\n            ans[i] = dict.rbegin()->first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        set<int> count;\\n        map<int, int> dict;\\n        int last(0);\\n        count.insert(-1);\\n        count.insert(0);\\n        for (int i = 1; i < s.size(); ++i){\\n            if (s[i] != s[i - 1]) {\\n                count.insert(i);\\n                dict[i - last]++;\\n                last = i;    \\n            }\\n        }\\n        count.insert(s.size());\\n        dict[s.size() - last]++;\\n        vector<int> ans(queryCharacters.size(), 0);\\n\\n        for (int i = 0; i < queryCharacters.size(); ++i){\\n            // for (auto &a: dict) cout << a.first << \":\" << a.second << \" \";\\n            // cout << endl;\\n            // for (auto &a: count) cout << a << \" \";\\n            // cout << endl;\\n            if (queryCharacters[i] == s[queryIndices[i]]) ans[i] = dict.rbegin()->first;\\n            else{\\n                auto it2 = count.upper_bound(queryIndices[i]);\\n                auto it1 = prev(it2);\\n                dict[*it2 - *it1]--;\\n                if (dict[*it2 - *it1] == 0) dict.erase(dict.find(*it2 - *it1));\\n                if (queryIndices[i] - *it1 != 0) dict[queryIndices[i] - *it1]++;\\n                dict[1]++;\\n                if (*it2 - (queryIndices[i] + 1) != 0) dict[*it2 - queryIndices[i] - 1]++;\\n                count.insert(queryIndices[i]);\\n                count.insert(queryIndices[i] + 1);\\n                s[queryIndices[i]] = queryCharacters[i];\\n                it2 = count.lower_bound(queryIndices[i]);\\n                it1 = prev(it2);\\n                if (*it1 == -1){\\n                    it1 = next(it1);\\n                    it2 = next(it2);\\n                }else{\\n                    if (s[*it1] == s[*it2]){\\n                        dict[*it2 - *it1]--;\\n                        dict[1]--;\\n                        if (dict[*it2 - *it1] == 0) dict.erase(dict.find(*it2 - *it1));\\n                        if (dict[1] == 0) dict.erase(dict.find(1));\\n                        count.erase(it2);\\n                        it2 = count.upper_bound(queryIndices[i]);\\n                        dict[*it2 - *it1]++;\\n                    }else{\\n                        it1 = next(it1);\\n                        it2 = next(it2);\\n                    }\\n                }\\n\\n                if (*it2 != s.size()){\\n                    if (s[*it1] == s[*it2]){\\n                        dict[*it2 - *it1]--;\\n                        if (dict[*it2 - *it1] == 0) dict.erase(dict.find(*it2 - *it1));\\n                        dict[*next(it2) - *it2]--;\\n                        if (dict[*next(it2) - *it2] == 0) dict.erase(dict.find(*next(it2) - *it2));\\n                        count.erase(it2);\\n                        it2 = count.upper_bound(queryIndices[i] + 1);\\n                        dict[*it2 - *it1]++;\\n                    }\\n                }\\n            }\\n            ans[i] = dict.rbegin()->first;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3062084,
                "title": "c-segmenttree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct Node {\\n        char prefixChar;\\n        char suffixChar;\\n        int prefixLen;\\n        int suffixLen;\\n        int maxLen;\\n        int totalLen;\\n        Node(char c) {\\n            prefixChar = c;\\n            suffixChar = c;\\n            prefixLen = 1;\\n            suffixLen = 1;\\n            maxLen = 1;\\n            totalLen = 1;\\n        }\\n\\n        void merge(Node* l, Node* r) {\\n            maxLen = max(l->maxLen, r->maxLen);\\n            if(l->suffixChar == r->prefixChar) {\\n                maxLen = max(maxLen, l->suffixLen+r->prefixLen);\\n            }\\n            totalLen = l->totalLen + r->totalLen;\\n\\n            prefixChar = l->prefixChar;\\n            suffixChar = r->suffixChar;\\n            prefixLen = l->prefixLen + (l->prefixLen == l->totalLen && l->suffixChar == r->prefixChar ? r->prefixLen : 0);\\n            suffixLen = r->suffixLen + (r->suffixLen == r->totalLen && l->suffixChar == r->prefixChar ? l->suffixLen : 0);\\n        }\\n    };\\n\\n    vector<struct Node*> st;\\n\\n    void buildST(string& s, int idx, int l, int r) {\\n        st[idx] = new Node(s[l]);\\n        if(l != r) {\\n            int m = l + (r-l)/2;\\n            buildST(s, 2*idx+1, l, m);\\n            buildST(s, 2*idx+2, m+1, r);\\n            st[idx]->merge(st[2*idx+1], st[2*idx+2]);\\n        }\\n    }\\n\\n    void update(int idx, int pos, char c, int l, int r) {\\n        if(l == r) {\\n            st[idx]->prefixChar = c;\\n            st[idx]->suffixChar = c;\\n            return;\\n        }\\n\\n        int m = l + (r-l)/2;\\n        if(pos <= m) {\\n            update(2*idx+1, pos, c, l, m);\\n        } else {\\n            update(2*idx+2, pos, c, m+1, r);\\n        }\\n        st[idx]->merge(st[2*idx+1], st[2*idx+2]);\\n    }\\n\\n    vector<int> longestRepeating(string s, string C, vector<int>& I) {\\n        vector<int> res;\\n        int N = s.size();\\n        st.resize(4*N);\\n        buildST(s, 0, 0, N-1);\\n        for(int i = 0; i < C.size(); i++) {\\n            update(0, I[i], C[i], 0, N-1);\\n            res.push_back(st[0]->maxLen);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Node {\\n        char prefixChar;\\n        char suffixChar;\\n        int prefixLen;\\n        int suffixLen;\\n        int maxLen;\\n        int totalLen;\\n        Node(char c) {\\n            prefixChar = c;\\n            suffixChar = c;\\n            prefixLen = 1;\\n            suffixLen = 1;\\n            maxLen = 1;\\n            totalLen = 1;\\n        }\\n\\n        void merge(Node* l, Node* r) {\\n            maxLen = max(l->maxLen, r->maxLen);\\n            if(l->suffixChar == r->prefixChar) {\\n                maxLen = max(maxLen, l->suffixLen+r->prefixLen);\\n            }\\n            totalLen = l->totalLen + r->totalLen;\\n\\n            prefixChar = l->prefixChar;\\n            suffixChar = r->suffixChar;\\n            prefixLen = l->prefixLen + (l->prefixLen == l->totalLen && l->suffixChar == r->prefixChar ? r->prefixLen : 0);\\n            suffixLen = r->suffixLen + (r->suffixLen == r->totalLen && l->suffixChar == r->prefixChar ? l->suffixLen : 0);\\n        }\\n    };\\n\\n    vector<struct Node*> st;\\n\\n    void buildST(string& s, int idx, int l, int r) {\\n        st[idx] = new Node(s[l]);\\n        if(l != r) {\\n            int m = l + (r-l)/2;\\n            buildST(s, 2*idx+1, l, m);\\n            buildST(s, 2*idx+2, m+1, r);\\n            st[idx]->merge(st[2*idx+1], st[2*idx+2]);\\n        }\\n    }\\n\\n    void update(int idx, int pos, char c, int l, int r) {\\n        if(l == r) {\\n            st[idx]->prefixChar = c;\\n            st[idx]->suffixChar = c;\\n            return;\\n        }\\n\\n        int m = l + (r-l)/2;\\n        if(pos <= m) {\\n            update(2*idx+1, pos, c, l, m);\\n        } else {\\n            update(2*idx+2, pos, c, m+1, r);\\n        }\\n        st[idx]->merge(st[2*idx+1], st[2*idx+2]);\\n    }\\n\\n    vector<int> longestRepeating(string s, string C, vector<int>& I) {\\n        vector<int> res;\\n        int N = s.size();\\n        st.resize(4*N);\\n        buildST(s, 0, 0, N-1);\\n        for(int i = 0; i < C.size(); i++) {\\n            update(0, I[i], C[i], 0, N-1);\\n            res.push_back(st[0]->maxLen);\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051241,
                "title": "java-solution",
                "content": "\\n\\n# Approach\\n1.Store the span of each letter in a TreeMap\\n2.Also use a second TreeMap to record the frequency of each span length\\n3.On each query, update both TreeMaps\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        char[] arr = s.toCharArray();\\n        int m = arr.length, n = queryIndices.length;\\n        int[] output = new int[n];\\n        TreeMap<Integer, Integer> lengths = new TreeMap<>(), spans = new TreeMap<>();\\n        // Stores spans of each letter in the TreeMap\\n        for (int i = 0, j = 1; j <= m; j++) if (j == m || arr[i] != arr[j]) {\\n            lengths.put(j - i, lengths.getOrDefault(j - i, 0) + 1);\\n            spans.put(i, j - 1);\\n            i = j;\\n        }\\n        // Update spans on each query and find the max length\\n        for (int i = 0; i < queryIndices.length; i++) {\\n            int j = queryIndices[i];\\n            if (arr[j] != queryCharacters.charAt(i)) {\\n                // Remove the spans that has the character to be updated\\n                int l = spans.floorKey(j), r = spans.remove(l), length = r - l + 1;\\n                if (lengths.get(length) == 1) lengths.remove(length);\\n                else lengths.put(length, lengths.get(length) - 1);\\n                // if the character is going to be different from its neighbors, break the span\\n                if (l < j) {\\n                    spans.put(l, j - 1);\\n                    lengths.put(j - l, lengths.getOrDefault(j - l, 0) + 1);\\n                }\\n                if (r > j) {\\n                    spans.put(j + 1, r);\\n                    lengths.put(r - j, lengths.getOrDefault(r - j, 0) + 1);\\n                }\\n                arr[j] = queryCharacters.charAt(i);\\n                l = j;\\n                r = j;\\n                // if the character is going to be same as its neighbors, merge the spans\\n                if (j > 0 && arr[j] == arr[j - 1]) {\\n                    l = spans.floorKey(j);\\n                    length = spans.remove(l) - l + 1;\\n                    if (lengths.get(length) == 1) lengths.remove(length);\\n                    else lengths.put(length, lengths.get(length) - 1);\\n                }\\n                if (j < m - 1 && arr[j] == arr[j + 1]) {\\n                    int key = spans.ceilingKey(j);\\n                    r = spans.remove(key);\\n                    length = r - key + 1;\\n                    if (lengths.get(length) == 1) lengths.remove(length);\\n                    else lengths.put(length, lengths.get(length) - 1);\\n                }\\n                spans.put(l, r);\\n                lengths.put(r - l + 1, lengths.getOrDefault(r - l + 1, 0) + 1);\\n            }\\n            output[i] = lengths.lastKey();\\n        }\\n        return output;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        char[] arr = s.toCharArray();\\n        int m = arr.length, n = queryIndices.length;\\n        int[] output = new int[n];\\n        TreeMap<Integer, Integer> lengths = new TreeMap<>(), spans = new TreeMap<>();\\n        // Stores spans of each letter in the TreeMap\\n        for (int i = 0, j = 1; j <= m; j++) if (j == m || arr[i] != arr[j]) {\\n            lengths.put(j - i, lengths.getOrDefault(j - i, 0) + 1);\\n            spans.put(i, j - 1);\\n            i = j;\\n        }\\n        // Update spans on each query and find the max length\\n        for (int i = 0; i < queryIndices.length; i++) {\\n            int j = queryIndices[i];\\n            if (arr[j] != queryCharacters.charAt(i)) {\\n                // Remove the spans that has the character to be updated\\n                int l = spans.floorKey(j), r = spans.remove(l), length = r - l + 1;\\n                if (lengths.get(length) == 1) lengths.remove(length);\\n                else lengths.put(length, lengths.get(length) - 1);\\n                // if the character is going to be different from its neighbors, break the span\\n                if (l < j) {\\n                    spans.put(l, j - 1);\\n                    lengths.put(j - l, lengths.getOrDefault(j - l, 0) + 1);\\n                }\\n                if (r > j) {\\n                    spans.put(j + 1, r);\\n                    lengths.put(r - j, lengths.getOrDefault(r - j, 0) + 1);\\n                }\\n                arr[j] = queryCharacters.charAt(i);\\n                l = j;\\n                r = j;\\n                // if the character is going to be same as its neighbors, merge the spans\\n                if (j > 0 && arr[j] == arr[j - 1]) {\\n                    l = spans.floorKey(j);\\n                    length = spans.remove(l) - l + 1;\\n                    if (lengths.get(length) == 1) lengths.remove(length);\\n                    else lengths.put(length, lengths.get(length) - 1);\\n                }\\n                if (j < m - 1 && arr[j] == arr[j + 1]) {\\n                    int key = spans.ceilingKey(j);\\n                    r = spans.remove(key);\\n                    length = r - key + 1;\\n                    if (lengths.get(length) == 1) lengths.remove(length);\\n                    else lengths.put(length, lengths.get(length) - 1);\\n                }\\n                spans.put(l, r);\\n                lengths.put(r - l + 1, lengths.getOrDefault(r - l + 1, 0) + 1);\\n            }\\n            output[i] = lengths.lastKey();\\n        }\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814033,
                "title": "python-segment-tree",
                "content": "Our segment Tree stores 3 values - [max length with unique chars, leftmost index till where we have only leftmost char of that segment, rightmost index till where we have only rightmost char of that segment]\\nFor example if we have segment [b,b,a,a] ,our segment will have values [2,1 (for b) , 2 (for a)].\\nAgain if we have abcd, our segment is [1,0 (for a), 3 (for d)].\\nMerge all segments and check cases when mid and mid+1 char is same , in other cases just take max of both the segments.\\nNow our update function works exactly similar to build function , it just updates string char rather than initializing segment tree array which we do in build. For each query just return segTree[0][0] as it gives max length unique chars over all indices of s.\\nTime Complexity- O(K logN) \\n```\\nclass Solution:\\n    def longestRepeating(self, s: str, queryC: str, queryI: List[int]) -> List[int]:\\n        n,m=len(s),len(queryC)\\n        s=list(c for c in s)\\n        st=[[0,None,None] for _ in range(4*n)]\\n        ans=[]\\n        def build(ss,se,si):\\n            if ss==se:\\n                st[si]=[1,ss,ss]\\n                return\\n            mid=(ss+se)//2\\n            build(ss,mid,2*si+1)\\n            build(mid+1,se,2*si+2)\\n            max1,li1,ri1=st[2*si+1]\\n            max2,li2,ri2=st[2*si+2]\\n            if s[mid]!=s[mid+1]:\\n                st[si][0]=max(max1,max2)\\n                st[si][1]=li1\\n                st[si][2]=ri2\\n                return\\n            st[si][0]=max(max1,max2,li2-ri1+1)\\n            if mid-ss+1==max1:\\n                st[si][1]=li2\\n            else:\\n                st[si][1]=li1\\n            if se-(mid+1)+1==max2:\\n                st[si][2]=ri1\\n            else:\\n                st[si][2]=ri2\\n        def update(ss,se,val,idx,si):\\n            if idx<ss or idx>se:\\n                return\\n            if ss==se:\\n                s[ss]=val\\n                return\\n            mid=(ss+se)//2\\n            if idx>mid:\\n                update(mid+1,se,val,idx,2*si+2)\\n            else:\\n                update(ss,mid,val,idx,2*si+1)\\n            max1,li1,ri1=st[2*si+1]\\n            max2,li2,ri2=st[2*si+2]\\n            if s[mid]!=s[mid+1]:\\n                st[si][0]=max(max1,max2)\\n                st[si][1]=li1\\n                st[si][2]=ri2\\n                return\\n            st[si][0]=max(max1,max2,li2-ri1+1)\\n            if mid-ss+1==max1:\\n                st[si][1]=li2\\n            else:\\n                st[si][1]=li1\\n            if se-(mid+1)+1==max2:\\n                st[si][2]=ri1\\n            else:\\n                st[si][2]=ri2\\n        build(0,n-1,0)\\n        for i in range(m):\\n            update(0,n-1,queryC[i],queryI[i],0)\\n            ans.append(st[0][0])\\n        return ans\\n        \\n            \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def longestRepeating(self, s: str, queryC: str, queryI: List[int]) -> List[int]:\\n        n,m=len(s),len(queryC)\\n        s=list(c for c in s)\\n        st=[[0,None,None] for _ in range(4*n)]\\n        ans=[]\\n        def build(ss,se,si):\\n            if ss==se:\\n                st[si]=[1,ss,ss]\\n                return\\n            mid=(ss+se)//2\\n            build(ss,mid,2*si+1)\\n            build(mid+1,se,2*si+2)\\n            max1,li1,ri1=st[2*si+1]\\n            max2,li2,ri2=st[2*si+2]\\n            if s[mid]!=s[mid+1]:\\n                st[si][0]=max(max1,max2)\\n                st[si][1]=li1\\n                st[si][2]=ri2\\n                return\\n            st[si][0]=max(max1,max2,li2-ri1+1)\\n            if mid-ss+1==max1:\\n                st[si][1]=li2\\n            else:\\n                st[si][1]=li1\\n            if se-(mid+1)+1==max2:\\n                st[si][2]=ri1\\n            else:\\n                st[si][2]=ri2\\n        def update(ss,se,val,idx,si):\\n            if idx<ss or idx>se:\\n                return\\n            if ss==se:\\n                s[ss]=val\\n                return\\n            mid=(ss+se)//2\\n            if idx>mid:\\n                update(mid+1,se,val,idx,2*si+2)\\n            else:\\n                update(ss,mid,val,idx,2*si+1)\\n            max1,li1,ri1=st[2*si+1]\\n            max2,li2,ri2=st[2*si+2]\\n            if s[mid]!=s[mid+1]:\\n                st[si][0]=max(max1,max2)\\n                st[si][1]=li1\\n                st[si][2]=ri2\\n                return\\n            st[si][0]=max(max1,max2,li2-ri1+1)\\n            if mid-ss+1==max1:\\n                st[si][1]=li2\\n            else:\\n                st[si][1]=li1\\n            if se-(mid+1)+1==max2:\\n                st[si][2]=ri1\\n            else:\\n                st[si][2]=ri2\\n        build(0,n-1,0)\\n        for i in range(m):\\n            update(0,n-1,queryC[i],queryI[i],0)\\n            ans.append(st[0][0])\\n        return ans\\n        \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748473,
                "title": "python-bisect-and-ordereddict-clean-code-beat-90",
                "content": "```\\nfrom sortedcontainers import SortedDict\\nfrom bisect import bisect_left, insort\\n\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        last = 0\\n        # idxchr is used to store oredered One Repeating Character substring (leftbound, rightbound, char),  also can use SortedList but slower\\n        # lenidxs is used to a SortedDict, One Repeating Character substring length as key, numbers of such substring as values\\n        idxchr, lenidxs = [], SortedDict()\\n        def removerng(idx):\\n            l, r, _ = idxchr[idx]\\n            idxchr[idx:idx + 1] = [] #quick delete\\n            lenidxs[r - l + 1] -= 1\\n            if not lenidxs[r - l + 1]: lenidxs.pop(r - l + 1)\\n        def addrng(l, r, c):\\n            insort(idxchr, (l, r, c))\\n            if r - l + 1 not in lenidxs: lenidxs[r - l + 1] = 0\\n            lenidxs[r - l + 1] += 1\\n        for i, c in enumerate(s + \\'#\\'): # add \\'#\\' to deal with tail of s\\n            if c != s[last]:\\n                addrng(last, i - 1, s[last])\\n                last = i\\n        ans = []\\n        for qc, qi in zip(queryCharacters, queryIndices):\\n            pos = min(bisect_right(idxchr, (qi, qi, \\'a\\')), len(idxchr) - 1)\\n            l, r, c = idxchr[pos]\\n            if not l <= qi <= r:\\n                pos -= 1\\n                l, r, c = idxchr[pos]\\n            # left and right of current pos\\n            ll, lr, lc = idxchr[pos - 1] if pos >= 1 else [None] * 3\\n            rl, rr, rc = idxchr[pos + 1] if pos + 1 < len(idxchr) else [None] * 3\\n            rm, add = [pos], []\\n            if qc != c:\\n                # can merge with left and right pos\\n                if qi == l and qc == lc or qi == r and qc == rc:\\n                    if qi == l and qc == lc:\\n                        add.append((ll, qi, qc))\\n                        rm.append(pos - 1)\\n                        if l + 1 <= r: add.append((l + 1, r, c))\\n                    if qi == r and qc == rc:\\n                        add.append((qi, rr, qc))\\n                        rm.append(pos + 1)\\n                        if l <= r - 1: add.append((l, r - 1, c))\\n                else:\\n                    if qi - 1 >= l: add.append((l, qi - 1, c))\\n                    add.append((qi, qi, qc))\\n                    if qi + 1 <= r: add.append((qi + 1, r, c))\\n                #special case: [ll, ..., qi], [qi, ...., rr], means we insert one char same as left and right\\n                if l == r and len(add) == 2: add = [(add[0][0], add[1][1], add[0][2])] \\n                for idx in sorted(rm, reverse=True): removerng(idx)\\n                for l, r, c in add: addrng(l, r, c)\\n            ans.append(lenidxs.peekitem(-1)[0])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedDict\\nfrom bisect import bisect_left, insort\\n\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        last = 0\\n        # idxchr is used to store oredered One Repeating Character substring (leftbound, rightbound, char),  also can use SortedList but slower\\n        # lenidxs is used to a SortedDict, One Repeating Character substring length as key, numbers of such substring as values\\n        idxchr, lenidxs = [], SortedDict()\\n        def removerng(idx):\\n            l, r, _ = idxchr[idx]\\n            idxchr[idx:idx + 1] = [] #quick delete\\n            lenidxs[r - l + 1] -= 1\\n            if not lenidxs[r - l + 1]: lenidxs.pop(r - l + 1)\\n        def addrng(l, r, c):\\n            insort(idxchr, (l, r, c))\\n            if r - l + 1 not in lenidxs: lenidxs[r - l + 1] = 0\\n            lenidxs[r - l + 1] += 1\\n        for i, c in enumerate(s + \\'#\\'): # add \\'#\\' to deal with tail of s\\n            if c != s[last]:\\n                addrng(last, i - 1, s[last])\\n                last = i\\n        ans = []\\n        for qc, qi in zip(queryCharacters, queryIndices):\\n            pos = min(bisect_right(idxchr, (qi, qi, \\'a\\')), len(idxchr) - 1)\\n            l, r, c = idxchr[pos]\\n            if not l <= qi <= r:\\n                pos -= 1\\n                l, r, c = idxchr[pos]\\n            # left and right of current pos\\n            ll, lr, lc = idxchr[pos - 1] if pos >= 1 else [None] * 3\\n            rl, rr, rc = idxchr[pos + 1] if pos + 1 < len(idxchr) else [None] * 3\\n            rm, add = [pos], []\\n            if qc != c:\\n                # can merge with left and right pos\\n                if qi == l and qc == lc or qi == r and qc == rc:\\n                    if qi == l and qc == lc:\\n                        add.append((ll, qi, qc))\\n                        rm.append(pos - 1)\\n                        if l + 1 <= r: add.append((l + 1, r, c))\\n                    if qi == r and qc == rc:\\n                        add.append((qi, rr, qc))\\n                        rm.append(pos + 1)\\n                        if l <= r - 1: add.append((l, r - 1, c))\\n                else:\\n                    if qi - 1 >= l: add.append((l, qi - 1, c))\\n                    add.append((qi, qi, qc))\\n                    if qi + 1 <= r: add.append((qi + 1, r, c))\\n                #special case: [ll, ..., qi], [qi, ...., rr], means we insert one char same as left and right\\n                if l == r and len(add) == 2: add = [(add[0][0], add[1][1], add[0][2])] \\n                for idx in sorted(rm, reverse=True): removerng(idx)\\n                for l, r, c in add: addrng(l, r, c)\\n            ans.append(lenidxs.peekitem(-1)[0])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677283,
                "title": "lazyperson-s-solution-in-python-faster-than-89",
                "content": "Similar to the \"[Range Module](https://leetcode.com/problems/range-module/)\\'\\' problem, we maintain disjoint interval for each segment in the same color. The built-in Sorted List is used because I am too lazy to code efficient a data structure. \\n\\nTo reduce the number of cases to handle, my solution always first deletes the location to update from the interval collection. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def remove_seg(self, l, r):\\n        self.segs.remove((l, r))\\n        self.max_segs.remove((r-l, l, r))\\n        \\n    def add_seg(self, l, r):\\n        self.segs.add((l, r))\\n        self.max_segs.add((r-l, l, r))\\n        \\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        s = list(s)\\n        self.segs = SortedList()\\n        self.max_segs = SortedList()\\n        l = 0\\n        for i in range(len(s)):\\n            if i and s[i] != s[i-1]:\\n                self.add_seg(l, i)\\n                l = i\\n        if l < len(s):\\n            self.add_seg(l, len(s))\\n        results = []\\n        for c, idx in zip(queryCharacters, queryIndices):\\n            if s[idx] == c:\\n\\t\\t\\t\\tresults.append(results[-1] if results else self.max_segs[-1][0])\\n                continue\\n            current = self.segs.bisect_left((idx, -inf))\\n            if current == len(self.segs) or self.segs[current][0] > idx:\\n                current -= 1\\n            l, r = self.segs[current]\\n            self.remove_seg(l, r)\\n            if r - (idx + 1) > 0:\\n                self.add_seg(idx+1, r)\\n            if idx - l > 0:\\n                self.add_seg(l, idx)\\n                current += 1            \\n            if 0 < idx < len(s) - 1 and s[idx-1] == c == s[idx+1]:\\n                prev = self.segs[current - 1]\\n                succ = self.segs[current]\\n                self.remove_seg(prev[0], prev[1])\\n                self.remove_seg(succ[0], succ[1])\\n                self.add_seg(prev[0], succ[1])\\n            elif 0 < idx and s[idx-1] == c:\\n                prev = self.segs[current - 1]\\n                self.remove_seg(prev[0], prev[1])\\n                self.add_seg(prev[0], idx+1)\\n            elif idx < len(s) - 1 and s[idx+1] == c:\\n                succ = self.segs[current]\\n                self.remove_seg(succ[0], succ[1])\\n                self.add_seg(idx, succ[1])\\n            else:\\n                self.add_seg(idx, idx+1)\\n            s[idx] = c\\n            results.append(self.max_segs[-1][0])\\n        return results\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "Similar to the \"[Range Module](https://leetcode.com/problems/range-module/)\\'\\' problem, we maintain disjoint interval for each segment in the same color. The built-in Sorted List is used because I am too lazy to code efficient a data structure. \\n\\nTo reduce the number of cases to handle, my solution always first deletes the location to update from the interval collection. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def remove_seg(self, l, r):\\n        self.segs.remove((l, r))\\n        self.max_segs.remove((r-l, l, r))\\n        \\n    def add_seg(self, l, r):\\n        self.segs.add((l, r))\\n        self.max_segs.add((r-l, l, r))\\n        \\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        s = list(s)\\n        self.segs = SortedList()\\n        self.max_segs = SortedList()\\n        l = 0\\n        for i in range(len(s)):\\n            if i and s[i] != s[i-1]:\\n                self.add_seg(l, i)\\n                l = i\\n        if l < len(s):\\n            self.add_seg(l, len(s))\\n        results = []\\n        for c, idx in zip(queryCharacters, queryIndices):\\n            if s[idx] == c:\\n\\t\\t\\t\\tresults.append(results[-1] if results else self.max_segs[-1][0])\\n                continue\\n            current = self.segs.bisect_left((idx, -inf))\\n            if current == len(self.segs) or self.segs[current][0] > idx:\\n                current -= 1\\n            l, r = self.segs[current]\\n            self.remove_seg(l, r)\\n            if r - (idx + 1) > 0:\\n                self.add_seg(idx+1, r)\\n            if idx - l > 0:\\n                self.add_seg(l, idx)\\n                current += 1            \\n            if 0 < idx < len(s) - 1 and s[idx-1] == c == s[idx+1]:\\n                prev = self.segs[current - 1]\\n                succ = self.segs[current]\\n                self.remove_seg(prev[0], prev[1])\\n                self.remove_seg(succ[0], succ[1])\\n                self.add_seg(prev[0], succ[1])\\n            elif 0 < idx and s[idx-1] == c:\\n                prev = self.segs[current - 1]\\n                self.remove_seg(prev[0], prev[1])\\n                self.add_seg(prev[0], idx+1)\\n            elif idx < len(s) - 1 and s[idx+1] == c:\\n                succ = self.segs[current]\\n                self.remove_seg(succ[0], succ[1])\\n                self.add_seg(idx, succ[1])\\n            else:\\n                self.add_seg(idx, idx+1)\\n            s[idx] = c\\n            results.append(self.max_segs[-1][0])\\n        return results\\n",
                "codeTag": "Java"
            },
            {
                "id": 2674182,
                "title": "c-segment-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        auto root = Node(s, 0, s.size());\\n        vector<int> res;\\n        for(int i=0;i< queryCharacters.size(); i++){\\n            root.change( queryCharacters[i], queryIndices[i]);\\n            res.push_back(root.maxLen);\\n        }\\n        return res;\\n    }\\n    \\n    struct Node{   \\n        Node(const string& s, int al, int ar) : l(al), r(ar), n(r-l){\\n            if (l+1 == r){\\n                cLeft = cRight = s[l];\\n                lenLeft = lenRight = maxLen = 1;\\n                isFull = true;\\n                return;\\n            }\\n            \\n            auto mid = (l + r) / 2;\\n            pl = new Node(s, l, mid);\\n            pr = new Node(s, mid, r);            \\n            update();                        \\n        }\\n        \\n        //when child changed\\n        void update(){\\n            cLeft = pl->cLeft;\\n            cRight = pr->cRight;\\n            \\n            lenLeft = pl->lenLeft;\\n            if(pl->isFull && pl->cLeft == pr->cLeft) lenLeft += pr->lenLeft;\\n            \\n            lenRight = pr->lenRight;\\n            if(pr->isFull && pl->cRight == pr->cLeft) lenRight += pl->lenRight;\\n            \\n            isFull = (lenLeft == n);            \\n            \\n            maxLen = max(pl->maxLen, pr->maxLen);\\n            if(pl->cRight == pr->cLeft) maxLen = max(maxLen, pl->lenRight + pr->lenLeft);\\n        }        \\n        \\n        void change(char c, int pos){\\n            if(l == r-1){\\n                assert(l == pos);\\n                cLeft = cRight = c;\\n                return;\\n            }\\n            \\n            auto mid = (l + r) / 2;\\n            (pos < mid ? pl : pr)->change(c, pos);\\n            update();            \\n        }\\n        \\n        const int l;\\n        const int r;\\n        const int n;\\n        bool isFull;\\n        int lenLeft;\\n        int lenRight;\\n        int maxLen;\\n        char cLeft;\\n        char cRight;\\n        Node* pl = nullptr;\\n        Node* pr = nullptr;\\n    };\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        auto root = Node(s, 0, s.size());\\n        vector<int> res;\\n        for(int i=0;i< queryCharacters.size(); i++){\\n            root.change( queryCharacters[i], queryIndices[i]);\\n            res.push_back(root.maxLen);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2631602,
                "title": "python-tc-96-ordered-map-explained",
                "content": "**My solution got accepted in 8000ms, which means sometimes it might give TLE.\\nBut I also found a faster solution which gets accepted in 5000ms so u can read that one too.**\\n```\\nfrom bisect import bisect_right\\nfrom collections import Counter\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        idx = [i for i,(x,y) in enumerate(zip(\\'_\\' + s, s + \\'_\\')) if x != y]\\n        idx, deg = [-1] + idx, Counter(y - x for x,y in zip(idx, idx[1:]))\\n        # print(idx)\\n        # print(deg)\\n        res, s, best = [], list(s + \\'_\\'), max(deg)\\n        for i,x in zip(queryIndices, queryCharacters):\\n            s[i], k = x, bisect_right(idx, i) - 1\\n            old, idx0 = idx[k-1:k+3], [idx[k], i, i+1, idx[k+1]]\\n            idx0 = [y for x,y in zip(old[:1] + idx0, idx0) if s[x] != s[y] ]\\n            fix = [y - x for x,y in zip(old[:1] + idx0, idx0 + old[3:])]\\n            idx[k:k+2], best0 = idx0, max(fix)\\n            deg.update(fix)\\n            for x,y in zip(old, old[1:]):\\n                y -= x\\n                if deg[y] == 1: deg.pop(y)\\n                else: deg[y] -= 1\\n            if best <= best0:\\n                best = best0\\n            elif not deg[best]:\\n                best = max(deg)\\n            res.append(best)\\n        return res\\n```\\n\\n```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        #imagine repeating characters to be in their own interval/group\\n        #we need some way to keep track of these intervals\\n        #realise that two ordered sets needed: one represents interval size, other interval indices\\n        #because the set is sorted, u can use binary search to find the interval where queryIndex lies\\n        #you can also always easily access the maximum interval\\n        \\n        #problem is not difficult but being aware of all cases is important\\n        #eg: sbs->sss, ssbb->sssb, bbs->bss, sb->ss\\n        #eg: sss->sbs, sssb->ssbb, bss->bbs, ss->sb\\n        \\n        #Approach: realise that this problem will involve breaking intervals, and joining them\\n        #so handle breaking intervals and joining intervals separately\\n        \\n        #manipulating input a little bit to avoid tedious out of index errors\\n        s = [\"#\"] + [ch for ch in s] + [\"#\"]\\n        queryIndices = [q_i + 1 for q_i in queryIndices]\\n        \\n        n = len(s); k = len(queryIndices)\\n        \\n        size = SortedSet()\\n        index = SortedSet()\\n        \\n        start = 0\\n        for i in range(n):\\n            if i==n-1 or s[i] != s[i+1]:\\n                size.add((i - start + 1, i))\\n                index.add((i, start))\\n                start = i+1\\n        \\n        ans = []\\n        for i in range(k):\\n            q_i = queryIndices[i]\\n            q_ch = queryCharacters[i]\\n            \\n            if q_ch == s[q_i]:#no change, so just move to the next one\\n                ans.append(size[-1][0])\\n                continue\\n            \\n            end, start = index[index.bisect_left((q_i, -1))]\\n            c_size = end - start + 1\\n            index.remove((end, start)); size.remove((c_size, end))\\n            \\n            #breaking intervals\\n            if c_size > 1:\\n                if q_i == start:#ss->bs\\n                    size.add((c_size - 1, end)); index.add((end, start + 1))\\n                elif q_i == end:#ss->sb\\n                    size.add((c_size - 1, end - 1)); index.add((end - 1, start))\\n                else:#sss->sbs\\n                    size.add((q_i - start, q_i-1)); size.add((end - q_i, end))\\n                    index.add((q_i-1, start)); index.add((end, q_i+1))\\n            \\n            index.add((q_i, q_i)); size.add((1, q_i))\\n            ii = index.bisect_left((q_i, q_i))\\n            \\n            #joining intervals\\n            if q_ch==s[index[ii-1][0]]==s[index[ii+1][0]]:#sbs -> sss\\n                left_end, left_start = index[ii-1]\\n                right_end, right_start = index[ii+1]\\n                index.remove((q_i, q_i)); size.remove((1, q_i))\\n                index.remove((right_end, right_start)); index.remove((left_end, left_start))\\n                size.remove((right_end - right_start + 1, right_end)); size.remove((left_end - left_start + 1, left_end))\\n                index.add((right_end, left_start)); size.add((right_end - left_start + 1, right_end))\\n            elif q_ch==s[index[ii-1][0]]:#bss -> sss\\n                left_end, left_start = index[ii-1]\\n                index.remove((q_i, q_i)); size.remove((1, q_i))\\n                index.remove((left_end, left_start)); size.remove((left_end - left_start + 1, left_end))\\n                index.add((q_i, left_start)); size.add((q_i - left_start + 1, q_i))\\n            elif q_ch==s[index[ii+1][0]]:#ssb -> sss\\n                right_end, right_start = index[ii+1]\\n                index.remove((q_i, q_i)); size.remove((1, q_i))\\n                index.remove((right_end, right_start)); size.remove((right_end - right_start + 1, right_end))\\n                index.add((right_end, q_i)); size.add((right_end - q_i + 1, right_end))\\n\\n            s[q_i] = q_ch\\n            ans.append(size[-1][0])\\n        \\n        return ans\\n```\\n**C++ Implementation of above sol**\\n```\\n    vector<int> longestRepeating(string S, string queryCharacters, vector<int>& queryIndices) {\\n        S = \"#\" + S + \"#\";\\n        vector<char> s(S.begin(), S.end());\\n        for(vector<int>::iterator it = queryIndices.begin(); it!=queryIndices.end(); ++it){\\n            *it += 1;\\n        }\\n        \\n        int n = s.size(); int k = queryIndices.size();\\n        set<pair<int, int>> size; map<int, int> index;\\n        \\n        int start = 0;\\n        for(int i = 0; i<n; i++){\\n            if(i==n-1 || s[i+1]!=s[i]){\\n                index[i] = start;\\n                size.insert(pair<int, int>(i - start + 1, i));\\n                start = i+1;\\n            }\\n        }\\n        \\n        vector<int> ans(k, -1);\\n        for(int i = 0; i<k; i++){\\n            int q_i = queryIndices[i];\\n            char q_ch = queryCharacters[i];\\n            \\n            if(q_ch == s[q_i]){\\n                ans[i] = size.rbegin()->first;\\n                continue;\\n            }\\n            \\n            auto curr_pointer = index.lower_bound(q_i);\\n            int end = curr_pointer->first; int start = curr_pointer->second;\\n            int c_size = end - start + 1;\\n            index.erase(end); size.erase(pair<int, int>(c_size, end));\\n            \\n            if(c_size > 1){\\n                if(end == q_i){\\n                    index[end-1] = start; size.insert(pair<int, int>(c_size-1, end-1));\\n                }\\n                else if(start == q_i){\\n                    index[end] = q_i+1; size.insert(pair<int, int>(c_size-1, end));\\n                }\\n                else{\\n                    index[end] = q_i+1; size.insert(pair<int,int>(end - q_i, end));\\n                    index[q_i-1] = start; size.insert(pair<int, int>(q_i - start, q_i-1));\\n                }\\n            }\\n            \\n            index[q_i] = q_i; size.insert(pair<int, int>(1, q_i));\\n            curr_pointer = index.lower_bound(q_i);\\n            auto left_pointer = --curr_pointer; curr_pointer++;\\n            auto right_pointer = ++curr_pointer; curr_pointer--;\\n            if(q_ch==s[right_pointer->first] && q_ch==s[left_pointer->first]){\\n                int left_end = left_pointer->first; int left_start = left_pointer->second;\\n                int right_end = right_pointer->first; int right_start = right_pointer->second;\\n                index.erase(q_i); size.erase(pair<int, int>(1, q_i));\\n                index.erase(left_pointer); size.erase(pair<int, int>(left_end-left_start+1, left_end));\\n                index.erase(right_pointer); size.erase(pair<int,int>(right_end-right_start+1, right_end));\\n                index[right_end] = left_start; size.insert(pair<int, int>(right_end - left_start + 1, right_end));\\n            }\\n            else if(q_ch == s[left_pointer->first]){\\n                int left_end = left_pointer->first; int left_start = left_pointer->second;\\n                index.erase(q_i); size.erase(pair<int, int>(1, q_i));\\n                index.erase(left_pointer); size.erase(pair<int, int>(left_end-left_start+1, left_end));\\n                index[q_i] = left_start; size.insert(pair<int,int>(q_i-left_start+1, q_i));\\n            }\\n            else if(q_ch == s[right_pointer->first]){\\n                int right_end = right_pointer->first; int right_start = right_pointer->second;\\n                index.erase(q_i); size.erase(pair<int, int>(1, q_i));\\n                index.erase(right_pointer); size.erase(pair<int,int>(right_end-right_start+1, right_end));\\n                index[right_end] = q_i; size.insert(pair<int,int>(right_end - q_i + 1, right_end));\\n            }\\n            \\n            s[q_i] = q_ch;\\n            ans[i] = size.rbegin()->first;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nfrom bisect import bisect_right\\nfrom collections import Counter\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        idx = [i for i,(x,y) in enumerate(zip(\\'_\\' + s, s + \\'_\\')) if x != y]\\n        idx, deg = [-1] + idx, Counter(y - x for x,y in zip(idx, idx[1:]))\\n        # print(idx)\\n        # print(deg)\\n        res, s, best = [], list(s + \\'_\\'), max(deg)\\n        for i,x in zip(queryIndices, queryCharacters):\\n            s[i], k = x, bisect_right(idx, i) - 1\\n            old, idx0 = idx[k-1:k+3], [idx[k], i, i+1, idx[k+1]]\\n            idx0 = [y for x,y in zip(old[:1] + idx0, idx0) if s[x] != s[y] ]\\n            fix = [y - x for x,y in zip(old[:1] + idx0, idx0 + old[3:])]\\n            idx[k:k+2], best0 = idx0, max(fix)\\n            deg.update(fix)\\n            for x,y in zip(old, old[1:]):\\n                y -= x\\n                if deg[y] == 1: deg.pop(y)\\n                else: deg[y] -= 1\\n            if best <= best0:\\n                best = best0\\n            elif not deg[best]:\\n                best = max(deg)\\n            res.append(best)\\n        return res\\n```\n```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        #imagine repeating characters to be in their own interval/group\\n        #we need some way to keep track of these intervals\\n        #realise that two ordered sets needed: one represents interval size, other interval indices\\n        #because the set is sorted, u can use binary search to find the interval where queryIndex lies\\n        #you can also always easily access the maximum interval\\n        \\n        #problem is not difficult but being aware of all cases is important\\n        #eg: sbs->sss, ssbb->sssb, bbs->bss, sb->ss\\n        #eg: sss->sbs, sssb->ssbb, bss->bbs, ss->sb\\n        \\n        #Approach: realise that this problem will involve breaking intervals, and joining them\\n        #so handle breaking intervals and joining intervals separately\\n        \\n        #manipulating input a little bit to avoid tedious out of index errors\\n        s = [\"#\"] + [ch for ch in s] + [\"#\"]\\n        queryIndices = [q_i + 1 for q_i in queryIndices]\\n        \\n        n = len(s); k = len(queryIndices)\\n        \\n        size = SortedSet()\\n        index = SortedSet()\\n        \\n        start = 0\\n        for i in range(n):\\n            if i==n-1 or s[i] != s[i+1]:\\n                size.add((i - start + 1, i))\\n                index.add((i, start))\\n                start = i+1\\n        \\n        ans = []\\n        for i in range(k):\\n            q_i = queryIndices[i]\\n            q_ch = queryCharacters[i]\\n            \\n            if q_ch == s[q_i]:#no change, so just move to the next one\\n                ans.append(size[-1][0])\\n                continue\\n            \\n            end, start = index[index.bisect_left((q_i, -1))]\\n            c_size = end - start + 1\\n            index.remove((end, start)); size.remove((c_size, end))\\n            \\n            #breaking intervals\\n            if c_size > 1:\\n                if q_i == start:#ss->bs\\n                    size.add((c_size - 1, end)); index.add((end, start + 1))\\n                elif q_i == end:#ss->sb\\n                    size.add((c_size - 1, end - 1)); index.add((end - 1, start))\\n                else:#sss->sbs\\n                    size.add((q_i - start, q_i-1)); size.add((end - q_i, end))\\n                    index.add((q_i-1, start)); index.add((end, q_i+1))\\n            \\n            index.add((q_i, q_i)); size.add((1, q_i))\\n            ii = index.bisect_left((q_i, q_i))\\n            \\n            #joining intervals\\n            if q_ch==s[index[ii-1][0]]==s[index[ii+1][0]]:#sbs -> sss\\n                left_end, left_start = index[ii-1]\\n                right_end, right_start = index[ii+1]\\n                index.remove((q_i, q_i)); size.remove((1, q_i))\\n                index.remove((right_end, right_start)); index.remove((left_end, left_start))\\n                size.remove((right_end - right_start + 1, right_end)); size.remove((left_end - left_start + 1, left_end))\\n                index.add((right_end, left_start)); size.add((right_end - left_start + 1, right_end))\\n            elif q_ch==s[index[ii-1][0]]:#bss -> sss\\n                left_end, left_start = index[ii-1]\\n                index.remove((q_i, q_i)); size.remove((1, q_i))\\n                index.remove((left_end, left_start)); size.remove((left_end - left_start + 1, left_end))\\n                index.add((q_i, left_start)); size.add((q_i - left_start + 1, q_i))\\n            elif q_ch==s[index[ii+1][0]]:#ssb -> sss\\n                right_end, right_start = index[ii+1]\\n                index.remove((q_i, q_i)); size.remove((1, q_i))\\n                index.remove((right_end, right_start)); size.remove((right_end - right_start + 1, right_end))\\n                index.add((right_end, q_i)); size.add((right_end - q_i + 1, right_end))\\n\\n            s[q_i] = q_ch\\n            ans.append(size[-1][0])\\n        \\n        return ans\\n```\n```\\n    vector<int> longestRepeating(string S, string queryCharacters, vector<int>& queryIndices) {\\n        S = \"#\" + S + \"#\";\\n        vector<char> s(S.begin(), S.end());\\n        for(vector<int>::iterator it = queryIndices.begin(); it!=queryIndices.end(); ++it){\\n            *it += 1;\\n        }\\n        \\n        int n = s.size(); int k = queryIndices.size();\\n        set<pair<int, int>> size; map<int, int> index;\\n        \\n        int start = 0;\\n        for(int i = 0; i<n; i++){\\n            if(i==n-1 || s[i+1]!=s[i]){\\n                index[i] = start;\\n                size.insert(pair<int, int>(i - start + 1, i));\\n                start = i+1;\\n            }\\n        }\\n        \\n        vector<int> ans(k, -1);\\n        for(int i = 0; i<k; i++){\\n            int q_i = queryIndices[i];\\n            char q_ch = queryCharacters[i];\\n            \\n            if(q_ch == s[q_i]){\\n                ans[i] = size.rbegin()->first;\\n                continue;\\n            }\\n            \\n            auto curr_pointer = index.lower_bound(q_i);\\n            int end = curr_pointer->first; int start = curr_pointer->second;\\n            int c_size = end - start + 1;\\n            index.erase(end); size.erase(pair<int, int>(c_size, end));\\n            \\n            if(c_size > 1){\\n                if(end == q_i){\\n                    index[end-1] = start; size.insert(pair<int, int>(c_size-1, end-1));\\n                }\\n                else if(start == q_i){\\n                    index[end] = q_i+1; size.insert(pair<int, int>(c_size-1, end));\\n                }\\n                else{\\n                    index[end] = q_i+1; size.insert(pair<int,int>(end - q_i, end));\\n                    index[q_i-1] = start; size.insert(pair<int, int>(q_i - start, q_i-1));\\n                }\\n            }\\n            \\n            index[q_i] = q_i; size.insert(pair<int, int>(1, q_i));\\n            curr_pointer = index.lower_bound(q_i);\\n            auto left_pointer = --curr_pointer; curr_pointer++;\\n            auto right_pointer = ++curr_pointer; curr_pointer--;\\n            if(q_ch==s[right_pointer->first] && q_ch==s[left_pointer->first]){\\n                int left_end = left_pointer->first; int left_start = left_pointer->second;\\n                int right_end = right_pointer->first; int right_start = right_pointer->second;\\n                index.erase(q_i); size.erase(pair<int, int>(1, q_i));\\n                index.erase(left_pointer); size.erase(pair<int, int>(left_end-left_start+1, left_end));\\n                index.erase(right_pointer); size.erase(pair<int,int>(right_end-right_start+1, right_end));\\n                index[right_end] = left_start; size.insert(pair<int, int>(right_end - left_start + 1, right_end));\\n            }\\n            else if(q_ch == s[left_pointer->first]){\\n                int left_end = left_pointer->first; int left_start = left_pointer->second;\\n                index.erase(q_i); size.erase(pair<int, int>(1, q_i));\\n                index.erase(left_pointer); size.erase(pair<int, int>(left_end-left_start+1, left_end));\\n                index[q_i] = left_start; size.insert(pair<int,int>(q_i-left_start+1, q_i));\\n            }\\n            else if(q_ch == s[right_pointer->first]){\\n                int right_end = right_pointer->first; int right_start = right_pointer->second;\\n                index.erase(q_i); size.erase(pair<int, int>(1, q_i));\\n                index.erase(right_pointer); size.erase(pair<int,int>(right_end-right_start+1, right_end));\\n                index[right_end] = q_i; size.insert(pair<int,int>(right_end - q_i + 1, right_end));\\n            }\\n            \\n            s[q_i] = q_ch;\\n            ans[i] = size.rbegin()->first;\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602529,
                "title": "kotlin-interval-map",
                "content": "```\\nfun longestRepeating(s: String, queryCharacters: String, queryIndices: IntArray): IntArray {\\n    val arr = mutableListOf<Triple<Char, Int, Int>>()\\n    val charArray = s.toCharArray()\\n    var now = charArray[0]\\n    var nowStartIndex = 0\\n\\n    // filling \"abaaabbcdc\" to\\n    // [0 0] [1 1] [2 4] [5 6] [7 7] [8 8] [9 9]\\n    //  a     b     a     b     c     d     c\\n    val map = TreeSet(compareByDescending<Triple<Char, Int, Int>> { it.third - it.second }\\n        .thenBy { it.second }\\n        .thenBy { it.third }.thenBy { it.first })\\n\\n    for (i in 1 until s.length) {\\n        if (charArray[i] != now) {\\n            Triple(now, nowStartIndex, i - 1).also {\\n                arr.add(it)\\n                map.add(it)\\n            }\\n            nowStartIndex = i\\n            now = charArray[i]\\n        }\\n    }\\n    Triple(now, nowStartIndex, s.length - 1).also {\\n        arr.add(it)\\n        map.add(it)\\n    }\\n\\n    val res = IntArray(queryIndices.size)\\n\\n    fun indexOfInterval(indexToChange: Int, start: Int, end: Int): Int {\\n        if (start == end) return start\\n        val centerIndex = start + (end - start) / 2\\n        return if (arr[centerIndex].third < indexToChange) {\\n            indexOfInterval(indexToChange, centerIndex + 1, end)\\n        } else {\\n            indexOfInterval(indexToChange, start, centerIndex)\\n        }\\n    }\\n\\n    queryIndices.forEachIndexed { index, queryIndexToChange ->\\n        val queryChar = queryCharacters[index]\\n\\n        val intervalIndex = indexOfInterval(queryIndexToChange, 0, arr.size)\\n        val interval = arr[intervalIndex]\\n\\n\\n        val promPrev = (intervalIndex - 1).takeIf { it >= 0 }?.let { arr[intervalIndex - 1] }\\n        val promNext = (intervalIndex + 1).takeIf { it < arr.size }?.let { arr[intervalIndex + 1] }\\n        if (interval.first != queryChar) {\\n            if (interval.second == interval.third) { // 1 length\\n                if (promPrev?.first == queryChar && promNext?.first == queryChar) {\\n                    //                             *            *\\n                    // changing \\'a\\' to \\'b\\' in [bb][A][bb] to [bbBbb]\\n                    map.remove(arr.removeAt(intervalIndex + 1))\\n                    map.remove(arr.removeAt(intervalIndex))\\n\\n                    map.remove(arr[intervalIndex - 1])\\n                    arr[intervalIndex - 1] = Triple(queryChar, promPrev.second, promNext.third)\\n                    map.add(Triple(queryChar, promPrev.second, promNext.third))\\n                } else if (promPrev?.first == queryChar) {\\n                    //                             *            *\\n                    // changing \\'a\\' to \\'b\\' in [bb][A][cc] to [bbB][cc]\\n\\n                    map.remove(arr.removeAt(intervalIndex))\\n\\n                    map.remove(arr[intervalIndex - 1])\\n                    arr[intervalIndex - 1] = Triple(queryChar, promPrev.second, queryIndexToChange)\\n                    map.add(Triple(queryChar, promPrev.second, queryIndexToChange))\\n                } else if (promNext?.first == queryChar) {\\n                    //                             *              *\\n                    // changing \\'a\\' to \\'b\\' in [cc][A][bb] to [cc][Bbb]\\n\\n                    map.remove(arr.removeAt(intervalIndex))\\n\\n                    map.remove(arr[intervalIndex])\\n                    arr[intervalIndex] = Triple(queryChar, queryIndexToChange, promNext.third)\\n                    map.add(Triple(queryChar, queryIndexToChange, promNext.third))\\n                } else {\\n                    //                             *              *\\n                    // changing \\'a\\' to \\'b\\' in [cc][A][cc] to [cc][B][cc]\\n                    map.remove(arr[intervalIndex])\\n                    arr[intervalIndex] = Triple(queryChar, queryIndexToChange, queryIndexToChange)\\n                    map.add(Triple(queryChar, queryIndexToChange, queryIndexToChange))\\n                }\\n            } else { // 2 or more length\\n                if (queryIndexToChange == interval.second) {\\n                    if (promPrev?.first == queryChar) {\\n                        //                             *             *\\n                        // changing \\'a\\' to \\'b\\' in [bb][Aaa][d] to [bbB][aa][d]\\n                        map.remove(arr[intervalIndex - 1])\\n                        map.remove(arr[intervalIndex])\\n\\n                        arr[intervalIndex - 1] = Triple(queryChar, promPrev.second, queryIndexToChange)\\n                        arr[intervalIndex] = Triple(interval.first, queryIndexToChange + 1, interval.third)\\n                        map.add(Triple(queryChar, promPrev.second, queryIndexToChange))\\n                        map.add(Triple(interval.first, queryIndexToChange + 1, interval.third))\\n                    } else {\\n                        //                            *              *\\n                        // changing \\'a\\' to \\'b\\' in [c][Aaa][d] to [c][B][aa][d]\\n                        map.remove(arr[intervalIndex])\\n\\n                        arr[intervalIndex] = Triple(queryChar, queryIndexToChange, queryIndexToChange)\\n                        arr.add(intervalIndex + 1, Triple(interval.first, queryIndexToChange + 1, interval.third))\\n                        map.add(Triple(queryChar, queryIndexToChange, queryIndexToChange))\\n                        map.add(Triple(interval.first, queryIndexToChange + 1, interval.third))\\n                    }\\n                } else if (queryIndexToChange == interval.third) {\\n                    if (promNext?.first == queryChar) {\\n                        //                              *                *\\n                        // changing \\'a\\' to \\'b\\' in [c][aaA][b] to [c][aa][Bb]\\n                        map.remove(arr[intervalIndex])\\n                        map.remove(arr[intervalIndex + 1])\\n\\n                        arr[intervalIndex] = Triple(interval.first, interval.second, queryIndexToChange - 1)\\n                        arr[intervalIndex + 1] = Triple(queryChar, queryIndexToChange, promNext.third)\\n                        map.add(Triple(interval.first, interval.second, queryIndexToChange - 1))\\n                        map.add(Triple(queryChar, queryIndexToChange, promNext.third))\\n                    } else {\\n                        //                             *                *\\n                        // changing \\'a\\' to \\'b\\' in [c][aA][dd] to [c][a][B][dd]\\n                        map.remove(arr[intervalIndex])\\n\\n                        arr[intervalIndex] = Triple(interval.first, interval.second, queryIndexToChange - 1)\\n                        arr.add(intervalIndex + 1, Triple(queryChar, queryIndexToChange, queryIndexToChange))\\n                        map.add(Triple(interval.first, interval.second, queryIndexToChange - 1))\\n                        map.add(Triple(queryChar, queryIndexToChange, queryIndexToChange))\\n                    }\\n                } else {\\n                    //                             *                 *\\n                    // changing \\'a\\' to \\'b\\' in [c][aAa][dd] to [c][a][B][a][dd\\n                    val toAddEnd = Triple(interval.first, queryIndexToChange + 1, interval.third)\\n                    map.remove(arr[intervalIndex])\\n\\n                    arr[intervalIndex] = Triple(interval.first, interval.second, queryIndexToChange - 1)\\n                    arr.add(intervalIndex + 1, Triple(queryChar, queryIndexToChange, queryIndexToChange))\\n                    arr.add(intervalIndex + 2, toAddEnd)\\n                    map.add(Triple(interval.first, interval.second, queryIndexToChange - 1))\\n                    map.add(Triple(queryChar, queryIndexToChange, queryIndexToChange))\\n                    map.add(toAddEnd)\\n                }\\n            }\\n        }\\n        res[index] = map.first().third - map.first().second + 1\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun longestRepeating(s: String, queryCharacters: String, queryIndices: IntArray): IntArray {\\n    val arr = mutableListOf<Triple<Char, Int, Int>>()\\n    val charArray = s.toCharArray()\\n    var now = charArray[0]\\n    var nowStartIndex = 0\\n\\n    // filling \"abaaabbcdc\" to\\n    // [0 0] [1 1] [2 4] [5 6] [7 7] [8 8] [9 9]\\n    //  a     b     a     b     c     d     c\\n    val map = TreeSet(compareByDescending<Triple<Char, Int, Int>> { it.third - it.second }\\n        .thenBy { it.second }\\n        .thenBy { it.third }.thenBy { it.first })\\n\\n    for (i in 1 until s.length) {\\n        if (charArray[i] != now) {\\n            Triple(now, nowStartIndex, i - 1).also {\\n                arr.add(it)\\n                map.add(it)\\n            }\\n            nowStartIndex = i\\n            now = charArray[i]\\n        }\\n    }\\n    Triple(now, nowStartIndex, s.length - 1).also {\\n        arr.add(it)\\n        map.add(it)\\n    }\\n\\n    val res = IntArray(queryIndices.size)\\n\\n    fun indexOfInterval(indexToChange: Int, start: Int, end: Int): Int {\\n        if (start == end) return start\\n        val centerIndex = start + (end - start) / 2\\n        return if (arr[centerIndex].third < indexToChange) {\\n            indexOfInterval(indexToChange, centerIndex + 1, end)\\n        } else {\\n            indexOfInterval(indexToChange, start, centerIndex)\\n        }\\n    }\\n\\n    queryIndices.forEachIndexed { index, queryIndexToChange ->\\n        val queryChar = queryCharacters[index]\\n\\n        val intervalIndex = indexOfInterval(queryIndexToChange, 0, arr.size)\\n        val interval = arr[intervalIndex]\\n\\n\\n        val promPrev = (intervalIndex - 1).takeIf { it >= 0 }?.let { arr[intervalIndex - 1] }\\n        val promNext = (intervalIndex + 1).takeIf { it < arr.size }?.let { arr[intervalIndex + 1] }\\n        if (interval.first != queryChar) {\\n            if (interval.second == interval.third) { // 1 length\\n                if (promPrev?.first == queryChar && promNext?.first == queryChar) {\\n                    //                             *            *\\n                    // changing \\'a\\' to \\'b\\' in [bb][A][bb] to [bbBbb]\\n                    map.remove(arr.removeAt(intervalIndex + 1))\\n                    map.remove(arr.removeAt(intervalIndex))\\n\\n                    map.remove(arr[intervalIndex - 1])\\n                    arr[intervalIndex - 1] = Triple(queryChar, promPrev.second, promNext.third)\\n                    map.add(Triple(queryChar, promPrev.second, promNext.third))\\n                } else if (promPrev?.first == queryChar) {\\n                    //                             *            *\\n                    // changing \\'a\\' to \\'b\\' in [bb][A][cc] to [bbB][cc]\\n\\n                    map.remove(arr.removeAt(intervalIndex))\\n\\n                    map.remove(arr[intervalIndex - 1])\\n                    arr[intervalIndex - 1] = Triple(queryChar, promPrev.second, queryIndexToChange)\\n                    map.add(Triple(queryChar, promPrev.second, queryIndexToChange))\\n                } else if (promNext?.first == queryChar) {\\n                    //                             *              *\\n                    // changing \\'a\\' to \\'b\\' in [cc][A][bb] to [cc][Bbb]\\n\\n                    map.remove(arr.removeAt(intervalIndex))\\n\\n                    map.remove(arr[intervalIndex])\\n                    arr[intervalIndex] = Triple(queryChar, queryIndexToChange, promNext.third)\\n                    map.add(Triple(queryChar, queryIndexToChange, promNext.third))\\n                } else {\\n                    //                             *              *\\n                    // changing \\'a\\' to \\'b\\' in [cc][A][cc] to [cc][B][cc]\\n                    map.remove(arr[intervalIndex])\\n                    arr[intervalIndex] = Triple(queryChar, queryIndexToChange, queryIndexToChange)\\n                    map.add(Triple(queryChar, queryIndexToChange, queryIndexToChange))\\n                }\\n            } else { // 2 or more length\\n                if (queryIndexToChange == interval.second) {\\n                    if (promPrev?.first == queryChar) {\\n                        //                             *             *\\n                        // changing \\'a\\' to \\'b\\' in [bb][Aaa][d] to [bbB][aa][d]\\n                        map.remove(arr[intervalIndex - 1])\\n                        map.remove(arr[intervalIndex])\\n\\n                        arr[intervalIndex - 1] = Triple(queryChar, promPrev.second, queryIndexToChange)\\n                        arr[intervalIndex] = Triple(interval.first, queryIndexToChange + 1, interval.third)\\n                        map.add(Triple(queryChar, promPrev.second, queryIndexToChange))\\n                        map.add(Triple(interval.first, queryIndexToChange + 1, interval.third))\\n                    } else {\\n                        //                            *              *\\n                        // changing \\'a\\' to \\'b\\' in [c][Aaa][d] to [c][B][aa][d]\\n                        map.remove(arr[intervalIndex])\\n\\n                        arr[intervalIndex] = Triple(queryChar, queryIndexToChange, queryIndexToChange)\\n                        arr.add(intervalIndex + 1, Triple(interval.first, queryIndexToChange + 1, interval.third))\\n                        map.add(Triple(queryChar, queryIndexToChange, queryIndexToChange))\\n                        map.add(Triple(interval.first, queryIndexToChange + 1, interval.third))\\n                    }\\n                } else if (queryIndexToChange == interval.third) {\\n                    if (promNext?.first == queryChar) {\\n                        //                              *                *\\n                        // changing \\'a\\' to \\'b\\' in [c][aaA][b] to [c][aa][Bb]\\n                        map.remove(arr[intervalIndex])\\n                        map.remove(arr[intervalIndex + 1])\\n\\n                        arr[intervalIndex] = Triple(interval.first, interval.second, queryIndexToChange - 1)\\n                        arr[intervalIndex + 1] = Triple(queryChar, queryIndexToChange, promNext.third)\\n                        map.add(Triple(interval.first, interval.second, queryIndexToChange - 1))\\n                        map.add(Triple(queryChar, queryIndexToChange, promNext.third))\\n                    } else {\\n                        //                             *                *\\n                        // changing \\'a\\' to \\'b\\' in [c][aA][dd] to [c][a][B][dd]\\n                        map.remove(arr[intervalIndex])\\n\\n                        arr[intervalIndex] = Triple(interval.first, interval.second, queryIndexToChange - 1)\\n                        arr.add(intervalIndex + 1, Triple(queryChar, queryIndexToChange, queryIndexToChange))\\n                        map.add(Triple(interval.first, interval.second, queryIndexToChange - 1))\\n                        map.add(Triple(queryChar, queryIndexToChange, queryIndexToChange))\\n                    }\\n                } else {\\n                    //                             *                 *\\n                    // changing \\'a\\' to \\'b\\' in [c][aAa][dd] to [c][a][B][a][dd\\n                    val toAddEnd = Triple(interval.first, queryIndexToChange + 1, interval.third)\\n                    map.remove(arr[intervalIndex])\\n\\n                    arr[intervalIndex] = Triple(interval.first, interval.second, queryIndexToChange - 1)\\n                    arr.add(intervalIndex + 1, Triple(queryChar, queryIndexToChange, queryIndexToChange))\\n                    arr.add(intervalIndex + 2, toAddEnd)\\n                    map.add(Triple(interval.first, interval.second, queryIndexToChange - 1))\\n                    map.add(Triple(queryChar, queryIndexToChange, queryIndexToChange))\\n                    map.add(toAddEnd)\\n                }\\n            }\\n        }\\n        res[index] = map.first().third - map.first().second + 1\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2480698,
                "title": "c-segment-tree-easy-understanding-recursion",
                "content": "```\\nclass SegmentTree{\\npublic:\\n    vector<int> tree,left,right;\\n    vector<char> leftch, rightch;\\n    int n;\\n    \\n    SegmentTree(string &s){\\n        n=s.size();\\n        tree.resize(4*n,0);\\n        left.resize(4*n,-1), right.resize(4*n,-1);\\n        leftch.resize(4*n), rightch.resize(4*n);\\n        \\n        build(s,0,n-1,0);\\n    }\\n    \\n    void build(string& s, int low, int high, int ind){\\n        if(low==high){\\n            tree[ind]=1;\\n            left[ind]=right[ind]=low;\\n            leftch[ind]=rightch[ind]=s[low];\\n            return;\\n        }\\n        int mid=low+(high-low)/2;\\n        build(s,low,mid,2*ind+1); build(s,mid+1,high,2*ind+2);\\n        merge(ind,low,high,mid);\\n    }\\n    void merge(int ind, int low, int high, int mid){\\n        int leftchild=2*ind+1, rightchild=2*ind+2;\\n        int maxsub=max(tree[leftchild],tree[rightchild]);\\n        left[ind]=left[leftchild]; right[ind]=right[rightchild];\\n        leftch[ind]=leftch[leftchild]; rightch[ind]=rightch[rightchild];\\n        if(leftch[rightchild]==rightch[leftchild]){\\n            // left = aabbcdee, right = eeeebdfeaba\\n            if(left[leftchild]==mid) // left=aaaa\\n                left[ind]=left[rightchild];\\n            if(right[rightchild]==mid+1)// right=aaaa\\n                right[ind]=right[leftchild];\\n            maxsub=max(maxsub, left[rightchild]-right[leftchild]+1);\\n        } \\n        maxsub=max(maxsub,left[ind]-low+1);\\n        maxsub=max(maxsub,high-right[ind]+1);\\n        tree[ind]=maxsub;\\n    }\\n    \\n    void update(int ind, int low, int high, int index, char ch){\\n        if(low==high){\\n            if(low==index)\\n                leftch[ind]=rightch[ind]=ch;\\n            return;\\n        }\\n        int mid=low+(high-low)/2;\\n        if(index<=mid)\\n            update(2*ind+1,low,mid,index,ch);\\n        if(index>mid)\\n            update(2*ind+2,mid+1,high,index,ch);\\n        merge(ind, low, high, mid);\\n    }\\n    \\n    int query(){\\n        return tree[0];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s,string query, vector<int>& indices){\\n        SegmentTree segment(s);\\n        int n=s.size();\\n        vector<int> ans(query.size(),0);\\n        for(int i=0; i<query.size(); i++){\\n            segment.update(0,0,n-1,indices[i],query[i]);\\n            ans[i]=segment.query();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass SegmentTree{\\npublic:\\n    vector<int> tree,left,right;\\n    vector<char> leftch, rightch;\\n    int n;\\n    \\n    SegmentTree(string &s){\\n        n=s.size();\\n        tree.resize(4*n,0);\\n        left.resize(4*n,-1), right.resize(4*n,-1);\\n        leftch.resize(4*n), rightch.resize(4*n);\\n        \\n        build(s,0,n-1,0);\\n    }\\n    \\n    void build(string& s, int low, int high, int ind){\\n        if(low==high){\\n            tree[ind]=1;\\n            left[ind]=right[ind]=low;\\n            leftch[ind]=rightch[ind]=s[low];\\n            return;\\n        }\\n        int mid=low+(high-low)/2;\\n        build(s,low,mid,2*ind+1); build(s,mid+1,high,2*ind+2);\\n        merge(ind,low,high,mid);\\n    }\\n    void merge(int ind, int low, int high, int mid){\\n        int leftchild=2*ind+1, rightchild=2*ind+2;\\n        int maxsub=max(tree[leftchild],tree[rightchild]);\\n        left[ind]=left[leftchild]; right[ind]=right[rightchild];\\n        leftch[ind]=leftch[leftchild]; rightch[ind]=rightch[rightchild];\\n        if(leftch[rightchild]==rightch[leftchild]){\\n            // left = aabbcdee, right = eeeebdfeaba\\n            if(left[leftchild]==mid) // left=aaaa\\n                left[ind]=left[rightchild];\\n            if(right[rightchild]==mid+1)// right=aaaa\\n                right[ind]=right[leftchild];\\n            maxsub=max(maxsub, left[rightchild]-right[leftchild]+1);\\n        } \\n        maxsub=max(maxsub,left[ind]-low+1);\\n        maxsub=max(maxsub,high-right[ind]+1);\\n        tree[ind]=maxsub;\\n    }\\n    \\n    void update(int ind, int low, int high, int index, char ch){\\n        if(low==high){\\n            if(low==index)\\n                leftch[ind]=rightch[ind]=ch;\\n            return;\\n        }\\n        int mid=low+(high-low)/2;\\n        if(index<=mid)\\n            update(2*ind+1,low,mid,index,ch);\\n        if(index>mid)\\n            update(2*ind+2,mid+1,high,index,ch);\\n        merge(ind, low, high, mid);\\n    }\\n    \\n    int query(){\\n        return tree[0];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s,string query, vector<int>& indices){\\n        SegmentTree segment(s);\\n        int n=s.size();\\n        vector<int> ans(query.size(),0);\\n        for(int i=0; i<query.size(); i++){\\n            segment.update(0,0,n-1,indices[i],query[i]);\\n            ans[i]=segment.query();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2452710,
                "title": "c-maintaining-intervals-of-same-letters",
                "content": "We write a class `Intervals` that maintain intervals of same letters, join and disjoins them. So when we get a query for character at `i` index, we first disjoin intervals containing `i - 1`, `i` and `i`, `i + 1`. And if a new letter at `i` becomes equal to letter at `i - 1` and/or at `i + 1` we join corresponding intervals again.\\n\\n```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n#define F first\\n#define S second\\n#define forn(i, n) for(int i = 0; i < n; ++i)\\n#define forbn(i, b, n) for(int i = b; i < n; ++i)\\n#define sz(v) (int)v.size()\\n#define pb push_back\\n\\ntypedef pair<int, int> ii;\\ntypedef vector<int> vi;\\n\\n\\nclass Intervals {\\npublic:    \\n\\tset<ii> sl;\\n\\tset<ii> sizes;\\n\\tint inf = 1000 * 1000 * 1000;\\n\\n    ii contain(int i) {\\n    \\tauto ptr = sl.lower_bound({i, inf});\\n    \\treturn *(--ptr);\\n    }\\n\\n    void pop(ii otr) {\\n    \\tsl.erase(otr);\\n    \\tsizes.erase({otr.S - otr.F + 1, otr.F});\\n    }\\n\\n    void add(ii otr) {\\n    \\tsl.insert(otr);\\n    \\tsizes.insert({otr.S - otr.F + 1, otr.F});\\n    }\\n\\n    void join(int i) {\\n    \\tii left = contain(i);\\n    \\tii right = contain(i + 1);\\n    \\tif(left.F == right.F)\\n    \\t\\treturn;\\n\\n    \\tii otr = {left.F, right.S};\\n\\n    \\tpop(right);\\n    \\tpop(left);\\n    \\tadd(otr);\\n    }\\n\\n    void disjoin(int i) {\\n    \\tii left = contain(i);\\n    \\tii right = contain(i + 1);\\n    \\tif(left.F != right.F)\\n    \\t\\treturn;\\n        \\n        ii o1 = {left.F, i};\\n        ii o2 = {i + 1, left.S};\\n\\n        pop(left);\\n        add(o1);\\n        add(o2);\\n    }\\n    \\n    int mx_interval() {\\n        return sizes.rbegin()->F;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n    \\ts = \\'#\\' + s + \\'#\\';\\n    \\tint n = sz(s), k = sz(queryCharacters);\\n        \\n        Intervals it;\\n\\n    \\tint left = 0;\\n    \\tforbn(i, 1, n + 1) {\\n    \\t\\tif(i == n || s[i] != s[left]) {\\n    \\t\\t\\tit.add({left, i - 1});\\n    \\t\\t\\tleft = i;\\n    \\t\\t}\\n    \\t}\\n\\n    \\tvi ans;\\n    \\tforn(ind, k) {\\n    \\t\\tchar c = queryCharacters[ind];\\n    \\t\\tint i = queryIndices[ind] + 1;\\n\\n    \\t\\tit.disjoin(i - 1);\\n    \\t\\tit.disjoin(i);\\n\\n    \\t\\ts[i] = c;\\n    \\t\\tif(s[i - 1] == s[i])\\n    \\t\\t\\tit.join(i - 1);\\n    \\t\\tif(s[i] == s[i + 1])\\n    \\t\\t\\tit.join(i);\\n\\n    \\t\\tans.pb(it.mx_interval());\\n    \\t}\\n\\n    \\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <bits/stdc++.h>\\n\\nusing namespace std;\\n\\n#define F first\\n#define S second\\n#define forn(i, n) for(int i = 0; i < n; ++i)\\n#define forbn(i, b, n) for(int i = b; i < n; ++i)\\n#define sz(v) (int)v.size()\\n#define pb push_back\\n\\ntypedef pair<int, int> ii;\\ntypedef vector<int> vi;\\n\\n\\nclass Intervals {\\npublic:    \\n\\tset<ii> sl;\\n\\tset<ii> sizes;\\n\\tint inf = 1000 * 1000 * 1000;\\n\\n    ii contain(int i) {\\n    \\tauto ptr = sl.lower_bound({i, inf});\\n    \\treturn *(--ptr);\\n    }\\n\\n    void pop(ii otr) {\\n    \\tsl.erase(otr);\\n    \\tsizes.erase({otr.S - otr.F + 1, otr.F});\\n    }\\n\\n    void add(ii otr) {\\n    \\tsl.insert(otr);\\n    \\tsizes.insert({otr.S - otr.F + 1, otr.F});\\n    }\\n\\n    void join(int i) {\\n    \\tii left = contain(i);\\n    \\tii right = contain(i + 1);\\n    \\tif(left.F == right.F)\\n    \\t\\treturn;\\n\\n    \\tii otr = {left.F, right.S};\\n\\n    \\tpop(right);\\n    \\tpop(left);\\n    \\tadd(otr);\\n    }\\n\\n    void disjoin(int i) {\\n    \\tii left = contain(i);\\n    \\tii right = contain(i + 1);\\n    \\tif(left.F != right.F)\\n    \\t\\treturn;\\n        \\n        ii o1 = {left.F, i};\\n        ii o2 = {i + 1, left.S};\\n\\n        pop(left);\\n        add(o1);\\n        add(o2);\\n    }\\n    \\n    int mx_interval() {\\n        return sizes.rbegin()->F;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n    \\ts = \\'#\\' + s + \\'#\\';\\n    \\tint n = sz(s), k = sz(queryCharacters);\\n        \\n        Intervals it;\\n\\n    \\tint left = 0;\\n    \\tforbn(i, 1, n + 1) {\\n    \\t\\tif(i == n || s[i] != s[left]) {\\n    \\t\\t\\tit.add({left, i - 1});\\n    \\t\\t\\tleft = i;\\n    \\t\\t}\\n    \\t}\\n\\n    \\tvi ans;\\n    \\tforn(ind, k) {\\n    \\t\\tchar c = queryCharacters[ind];\\n    \\t\\tint i = queryIndices[ind] + 1;\\n\\n    \\t\\tit.disjoin(i - 1);\\n    \\t\\tit.disjoin(i);\\n\\n    \\t\\ts[i] = c;\\n    \\t\\tif(s[i - 1] == s[i])\\n    \\t\\t\\tit.join(i - 1);\\n    \\t\\tif(s[i] == s[i + 1])\\n    \\t\\t\\tit.join(i);\\n\\n    \\t\\tans.pb(it.mx_interval());\\n    \\t}\\n\\n    \\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2420161,
                "title": "python-c-update-intervals-directly-w-two-ordered-sets-o-nlogn",
                "content": "*Python* solution w/ *SortedList, SortedSet*\\n```python\\ndef longestRepeating(self, s, queryCharacters, queryIndices):\\n    from sortedcontainers import SortedList, SortedSet\\n    res, L, P, s = [], SortedList(), SortedSet([0]), list(\" \" + s + \" \")\\n    for i in range(1, len(s)):\\n        if s[i] != s[i - 1]:\\n            L.add(i - P[-1])\\n            P.add(i)\\n    for m, y in zip(queryIndices, queryCharacters):\\n        if s[(m := m + 1)] != y:\\n            x, s[m], z, i = s[m - 1], y, s[m + 1], P.bisect_right(m)\\n            if x == y == z:\\n                l, r = P[i - 2], P[i + 1]\\n                P.remove(m), P.remove(m + 1)\\n                L.add(r - l), L.remove(m - l), L.remove(1), L.remove(r - m - 1)\\n            elif x == y:\\n                l, r = P[i - 2], P[i]\\n                P.add(m + 1), P.remove(m)\\n                L.add(m + 1 - l), L.add(r - m - 1), L.remove(m - l), L.remove(r - m)\\n            elif y == z:\\n                l, r = P[i - 1], P[i + 1]\\n                P.add(m), P.remove(m + 1)\\n                L.add(m - l), L.add(r - m), L.remove(m + 1 - l), L.remove(r - m - 1)\\n            else:\\n                l, r = P[i - 1], P[i]\\n                P.add(m), P.add(m + 1)\\n                L.add(m - l), L.add(1), L.add(r - m - 1), L.remove(r - l)\\n        res.append(L[-1])\\n    return res\\n```\\n\\n*C++* solution w/ *multiset, set*\\n\\n```c++\\nvector<int> longestRepeating(string s, string queryCharacters, vector<int> &queryIndices) {\\n    vector<int> res;\\n    multiset<int> L;\\n    set<int> P({0});\\n    s = \" \" + s + \" \";\\n    for (int i = 1; i < s.size(); ++i) {\\n        if (s[i] != s[i - 1]) {\\n            L.insert(i - *rbegin(P));\\n            P.insert(i);\\n        }\\n    }\\n    for (int k = 0; k < queryIndices.size(); ++k) {\\n        int m = queryIndices[k] + 1, x = s[m - 1], y = queryCharacters[k], z = s[m + 1];\\n        if (s[m] != y) {\\n            s[m] = y;\\n            auto i = P.upper_bound(m);\\n            if (x == y && y == z) {\\n                auto l = *prev(i, 2), r = *next(i);\\n                P.erase(m), P.erase(m + 1);\\n                L.insert(r - l), L.erase(L.find(m - l)), L.erase(L.find(1)), L.erase(L.find(r - m - 1));\\n            } else if (x == y) {\\n                auto l = *prev(i, 2), r = *i;\\n                P.insert(m + 1), P.erase(m);\\n                L.insert(m + 1 - l), L.insert(r - m - 1), L.erase(L.find(m - l)), L.erase(L.find(r - m));\\n            } else if (y == z) {\\n                auto l = *prev(i), r = *next(i);\\n                P.insert(m), P.erase(m + 1);\\n                L.insert(m - l), L.insert(r - m), L.erase(L.find(m + 1 - l)), L.erase(L.find(r - m - 1));\\n            } else {\\n                auto l = *prev(i), r = *i;\\n                P.insert(m), P.insert(m + 1);\\n                L.insert(m - l), L.insert(1), L.insert(r - m - 1), L.erase(L.find(r - l));\\n            }\\n        }\\n        res.push_back(*rbegin(L));\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef longestRepeating(self, s, queryCharacters, queryIndices):\\n    from sortedcontainers import SortedList, SortedSet\\n    res, L, P, s = [], SortedList(), SortedSet([0]), list(\" \" + s + \" \")\\n    for i in range(1, len(s)):\\n        if s[i] != s[i - 1]:\\n            L.add(i - P[-1])\\n            P.add(i)\\n    for m, y in zip(queryIndices, queryCharacters):\\n        if s[(m := m + 1)] != y:\\n            x, s[m], z, i = s[m - 1], y, s[m + 1], P.bisect_right(m)\\n            if x == y == z:\\n                l, r = P[i - 2], P[i + 1]\\n                P.remove(m), P.remove(m + 1)\\n                L.add(r - l), L.remove(m - l), L.remove(1), L.remove(r - m - 1)\\n            elif x == y:\\n                l, r = P[i - 2], P[i]\\n                P.add(m + 1), P.remove(m)\\n                L.add(m + 1 - l), L.add(r - m - 1), L.remove(m - l), L.remove(r - m)\\n            elif y == z:\\n                l, r = P[i - 1], P[i + 1]\\n                P.add(m), P.remove(m + 1)\\n                L.add(m - l), L.add(r - m), L.remove(m + 1 - l), L.remove(r - m - 1)\\n            else:\\n                l, r = P[i - 1], P[i]\\n                P.add(m), P.add(m + 1)\\n                L.add(m - l), L.add(1), L.add(r - m - 1), L.remove(r - l)\\n        res.append(L[-1])\\n    return res\\n```\n```c++\\nvector<int> longestRepeating(string s, string queryCharacters, vector<int> &queryIndices) {\\n    vector<int> res;\\n    multiset<int> L;\\n    set<int> P({0});\\n    s = \" \" + s + \" \";\\n    for (int i = 1; i < s.size(); ++i) {\\n        if (s[i] != s[i - 1]) {\\n            L.insert(i - *rbegin(P));\\n            P.insert(i);\\n        }\\n    }\\n    for (int k = 0; k < queryIndices.size(); ++k) {\\n        int m = queryIndices[k] + 1, x = s[m - 1], y = queryCharacters[k], z = s[m + 1];\\n        if (s[m] != y) {\\n            s[m] = y;\\n            auto i = P.upper_bound(m);\\n            if (x == y && y == z) {\\n                auto l = *prev(i, 2), r = *next(i);\\n                P.erase(m), P.erase(m + 1);\\n                L.insert(r - l), L.erase(L.find(m - l)), L.erase(L.find(1)), L.erase(L.find(r - m - 1));\\n            } else if (x == y) {\\n                auto l = *prev(i, 2), r = *i;\\n                P.insert(m + 1), P.erase(m);\\n                L.insert(m + 1 - l), L.insert(r - m - 1), L.erase(L.find(m - l)), L.erase(L.find(r - m));\\n            } else if (y == z) {\\n                auto l = *prev(i), r = *next(i);\\n                P.insert(m), P.erase(m + 1);\\n                L.insert(m - l), L.insert(r - m), L.erase(L.find(m + 1 - l)), L.erase(L.find(r - m - 1));\\n            } else {\\n                auto l = *prev(i), r = *i;\\n                P.insert(m), P.insert(m + 1);\\n                L.insert(m - l), L.insert(1), L.insert(r - m - 1), L.erase(L.find(r - l));\\n            }\\n        }\\n        res.push_back(*rbegin(L));\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2414653,
                "title": "java-2treemap",
                "content": "```\\n\\n   ////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Runtime: 428 ms, faster than 47.24% of Java online submissions for Longest Substring of One Repeating Character.\\n    //Memory Usage: 232.5 MB, less than 14.96% of Java online submissions for Longest Substring of One Repeating Character.\\n    //treeMap\\n    //Time: O(N * lgN + M * lgN);  Space: O(N + M)\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n\\n        //Time: O(N*lgN)\\n        MyTreeMap2213 myTreeMap = new MyTreeMap2213(s);\\n        //Space: O(M)\\n        int[] res = new int[queryIndices.length];\\n\\n        //Time:O(M * lgN)\\n        for (int i = 0; i < queryIndices.length; i++){\\n            myTreeMap.updateChar(queryIndices[i], queryCharacters.charAt(i));\\n            res[i] = myTreeMap.getMaxLen();\\n        }\\n        return res;\\n    }\\n\\n    class MyTreeMap2213{\\n        //index: node\\n        private TreeMap<Integer, Node> treeMapAll = new TreeMap<>(); \\n        //length : Set<node> : these nodes have same length\\n        private TreeMap<Integer, Set<Node>> treeMapMaxLen = new TreeMap<>();  //length: Set<Node>\\n        private char[] charsList;\\n        public MyTreeMap2213(String s){\\n            charsList = s.toCharArray();\\n            buildData();\\n        }\\n\\n        public int getMaxLen(){\\n            return treeMapMaxLen.lastKey();\\n        }\\n\\n        //Time: O(N*lgN)\\n        private void buildData(){\\n            int i = 0;\\n            while (i < charsList.length) {\\n                char currChar = charsList[i];\\n                Node node = new Node(i++);\\n                while (i < charsList.length && charsList[i] == currChar) i++;\\n                node.end = i - 1;\\n                add(node);\\n            }\\n        }\\n\\n        //Time:O(c * lgN)\\n        public void updateChar(int idx, char newChar){\\n            if (charsList[idx] == newChar) return;\\n\\n            //old node : split it or abandoned \\n            Node oldNode = treeMapAll.floorEntry(idx).getValue();\\n            //treeMapAll.remove(node.begin);\\n            removeViaLength(oldNode);\\n\\n            if (oldNode.length() > 1) {\\n                Node[] newList = oldNode.split(idx);\\n                for (Node n : newList)\\n                    if (n != null) add(n);\\n            }\\n\\n            //get neighbours\\n            Node leftNode = null;\\n            if (idx - 1 >= 0 && charsList[idx - 1] == newChar) {\\n                leftNode = treeMapAll.floorEntry(idx - 1).getValue();\\n                removeViaLength(leftNode);\\n            }\\n\\n            if (leftNode != null)\\n                treeMapAll.remove(oldNode.begin);\\n\\n            Node rightNode = null;\\n            if (idx + 1 < charsList.length && charsList[idx + 1] == newChar ) {\\n                rightNode = treeMapAll.get(idx + 1);\\n                removeViaLength(rightNode);\\n            }\\n\\n            //merge with neighbours\\n            if (leftNode != null && rightNode != null){\\n                treeMapAll.remove(rightNode.begin);\\n                leftNode.end = rightNode.end;\\n                add(leftNode);\\n            }else if (leftNode != null){\\n                leftNode.end = leftNode.end + 1;\\n                add(leftNode);\\n            }else if (rightNode != null){\\n                treeMapAll.remove(rightNode.begin);\\n                rightNode.begin--;\\n                add(rightNode);\\n            }else{\\n                Node node = new Node(idx);\\n                add(node);\\n            }\\n            charsList[idx] = newChar;\\n        }\\n\\n        //Time:O(lgN)\\n        private void add(Node node){\\n            treeMapAll.put(node.begin, node);\\n            Set set = treeMapMaxLen.getOrDefault(node.length(), new HashSet<>());\\n            set.add(node);\\n            treeMapMaxLen.put(node.length(), set);\\n        }\\n\\n        //Time:O(lgN)\\n        private void removeViaLength(Node node){\\n            int len = node.length();\\n            if (treeMapMaxLen.get(len).size() == 1) treeMapMaxLen.remove(len);\\n            else treeMapMaxLen.get(len).remove(node);\\n        }\\n\\n        class Node{\\n            int begin = -1;\\n            int end = -1;\\n\\n            public Node(int idx){\\n                begin = idx;\\n                end = idx;\\n            }\\n            public boolean contain(int idx){\\n                return idx >= begin && idx <= end;\\n            }\\n            public int length() {\\n                return end - begin + 1;\\n            }\\n\\n            public Node[] split(int idx){\\n                Node left = null;\\n                if (idx - 1 >= begin){\\n                    left = new Node(begin);\\n                    left.begin = begin;\\n                    left.end = idx - 1;\\n                }\\n\\n                Node right = null;\\n                if (idx + 1 <= end){\\n                    right = new Node(end);\\n                    right.begin = idx + 1;\\n                    right.end = end;\\n                }\\n                return new Node[]{left, right};\\n            }\\n        }\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n\\n   ////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Runtime: 428 ms, faster than 47.24% of Java online submissions for Longest Substring of One Repeating Character.\\n    //Memory Usage: 232.5 MB, less than 14.96% of Java online submissions for Longest Substring of One Repeating Character.\\n    //treeMap\\n    //Time: O(N * lgN + M * lgN);  Space: O(N + M)\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n\\n        //Time: O(N*lgN)\\n        MyTreeMap2213 myTreeMap = new MyTreeMap2213(s);\\n        //Space: O(M)\\n        int[] res = new int[queryIndices.length];\\n\\n        //Time:O(M * lgN)\\n        for (int i = 0; i < queryIndices.length; i++){\\n            myTreeMap.updateChar(queryIndices[i], queryCharacters.charAt(i));\\n            res[i] = myTreeMap.getMaxLen();\\n        }\\n        return res;\\n    }\\n\\n    class MyTreeMap2213{\\n        //index: node\\n        private TreeMap<Integer, Node> treeMapAll = new TreeMap<>(); \\n        //length : Set<node> : these nodes have same length\\n        private TreeMap<Integer, Set<Node>> treeMapMaxLen = new TreeMap<>();  //length: Set<Node>\\n        private char[] charsList;\\n        public MyTreeMap2213(String s){\\n            charsList = s.toCharArray();\\n            buildData();\\n        }\\n\\n        public int getMaxLen(){\\n            return treeMapMaxLen.lastKey();\\n        }\\n\\n        //Time: O(N*lgN)\\n        private void buildData(){\\n            int i = 0;\\n            while (i < charsList.length) {\\n                char currChar = charsList[i];\\n                Node node = new Node(i++);\\n                while (i < charsList.length && charsList[i] == currChar) i++;\\n                node.end = i - 1;\\n                add(node);\\n            }\\n        }\\n\\n        //Time:O(c * lgN)\\n        public void updateChar(int idx, char newChar){\\n            if (charsList[idx] == newChar) return;\\n\\n            //old node : split it or abandoned \\n            Node oldNode = treeMapAll.floorEntry(idx).getValue();\\n            //treeMapAll.remove(node.begin);\\n            removeViaLength(oldNode);\\n\\n            if (oldNode.length() > 1) {\\n                Node[] newList = oldNode.split(idx);\\n                for (Node n : newList)\\n                    if (n != null) add(n);\\n            }\\n\\n            //get neighbours\\n            Node leftNode = null;\\n            if (idx - 1 >= 0 && charsList[idx - 1] == newChar) {\\n                leftNode = treeMapAll.floorEntry(idx - 1).getValue();\\n                removeViaLength(leftNode);\\n            }\\n\\n            if (leftNode != null)\\n                treeMapAll.remove(oldNode.begin);\\n\\n            Node rightNode = null;\\n            if (idx + 1 < charsList.length && charsList[idx + 1] == newChar ) {\\n                rightNode = treeMapAll.get(idx + 1);\\n                removeViaLength(rightNode);\\n            }\\n\\n            //merge with neighbours\\n            if (leftNode != null && rightNode != null){\\n                treeMapAll.remove(rightNode.begin);\\n                leftNode.end = rightNode.end;\\n                add(leftNode);\\n            }else if (leftNode != null){\\n                leftNode.end = leftNode.end + 1;\\n                add(leftNode);\\n            }else if (rightNode != null){\\n                treeMapAll.remove(rightNode.begin);\\n                rightNode.begin--;\\n                add(rightNode);\\n            }else{\\n                Node node = new Node(idx);\\n                add(node);\\n            }\\n            charsList[idx] = newChar;\\n        }\\n\\n        //Time:O(lgN)\\n        private void add(Node node){\\n            treeMapAll.put(node.begin, node);\\n            Set set = treeMapMaxLen.getOrDefault(node.length(), new HashSet<>());\\n            set.add(node);\\n            treeMapMaxLen.put(node.length(), set);\\n        }\\n\\n        //Time:O(lgN)\\n        private void removeViaLength(Node node){\\n            int len = node.length();\\n            if (treeMapMaxLen.get(len).size() == 1) treeMapMaxLen.remove(len);\\n            else treeMapMaxLen.get(len).remove(node);\\n        }\\n\\n        class Node{\\n            int begin = -1;\\n            int end = -1;\\n\\n            public Node(int idx){\\n                begin = idx;\\n                end = idx;\\n            }\\n            public boolean contain(int idx){\\n                return idx >= begin && idx <= end;\\n            }\\n            public int length() {\\n                return end - begin + 1;\\n            }\\n\\n            public Node[] split(int idx){\\n                Node left = null;\\n                if (idx - 1 >= begin){\\n                    left = new Node(begin);\\n                    left.begin = begin;\\n                    left.end = idx - 1;\\n                }\\n\\n                Node right = null;\\n                if (idx + 1 <= end){\\n                    right = new Node(end);\\n                    right.begin = idx + 1;\\n                    right.end = end;\\n                }\\n                return new Node[]{left, right};\\n            }\\n        }\\n    }\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2412081,
                "title": "java-segment-tree-iteration-without-recursion-faster-than-89-76",
                "content": "```\\n\\t////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Runtime: 163 ms, faster than 89.76% of Java online submissions for Longest Substring of One Repeating Character.\\n    //Memory Usage: 68.7 MB, less than 84.25% of Java online submissions for Longest Substring of One Repeating Character.\\n    //Segment tree + iteration\\n    //Time: O(M*lgN) ; Space: O(4N)\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        int len = s.length();\\n        int treeSize = 2;\\n        while (len >= 1) {\\n            treeSize <<= 1;\\n            len >>= 1;\\n        }\\n        //Space: O(4N)\\n        Node2213[] segmentTree = new Node2213[treeSize];\\n\\n        //Time: O(N)\\n        for (int i = 0; i < s.length();i++)\\n            updateSTree(i, s.charAt(i), segmentTree);\\n\\n        //Time: O(M*lgN)\\n        int[] res = new int[queryIndices.length];\\n        for (int i = 0; i < queryIndices.length;i++){\\n            //Time: O(lgN); Space:O(1)\\n            updateSTree(queryIndices[i], queryCharacters.charAt(i), segmentTree);\\n            res[i] = segmentTree[1].maxLen;\\n        }\\n        return res;\\n    }\\n\\n    class Node2213{\\n        char leftChar, rightChar;\\n        int leftLen = 1, rightLen = 1;\\n        int maxLen = 1;\\n        boolean flag = true;\\n        public Node2213(char c){\\n            leftChar = rightChar = c;\\n        }\\n    }\\n\\n    //Time: O(lgN); Space:O(1)\\n    private void updateSTree(int i, char c, Node2213[] segmentTree){\\n        i += segmentTree.length / 2;\\n        if (segmentTree[i] == null)  segmentTree[i] = new Node2213(\\'$\\');\\n        segmentTree[i].rightChar = c;\\n        segmentTree[i].leftChar = c;\\n\\n        while (i > 1){\\n            i = i >> 1;\\n            if (segmentTree[i] == null)  segmentTree[i] = new Node2213(\\'$\\');\\n            if (segmentTree[i*2+1] == null)  segmentTree[i*2+1] = new Node2213(\\'$\\');\\n\\n            //left\\n            segmentTree[i].leftChar =  segmentTree[i * 2].leftChar;\\n            segmentTree[i].leftLen =  segmentTree[i * 2].leftLen;\\n            //right\\n            segmentTree[i].rightChar =  segmentTree[i * 2 + 1].rightChar;\\n            segmentTree[i].rightLen =  segmentTree[i * 2 + 1].rightLen;\\n\\n            //maxLen & flag\\n            segmentTree[i].flag = segmentTree[i * 2].flag & segmentTree[i * 2 + 1].flag\\n                    & segmentTree[i * 2].rightChar == segmentTree[i * 2 + 1].leftChar;\\n\\n            segmentTree[i].maxLen = Math.max(segmentTree[i * 2].maxLen, segmentTree[i * 2 + 1].maxLen);\\n\\n            //do merge\\n            if (segmentTree[i * 2].rightChar != \\'$\\' && segmentTree[i * 2].rightChar == segmentTree[i * 2 + 1].leftChar) {\\n                int maxLen = segmentTree[i].maxLen;\\n                int midLen = segmentTree[i * 2].rightLen + segmentTree[i * 2 + 1].leftLen;\\n\\n                if (segmentTree[i * 2].flag) {\\n                    segmentTree[i].leftLen += segmentTree[i * 2 + 1].leftLen;\\n                    midLen = Math.max(midLen, segmentTree[i].leftLen);\\n                }\\n\\n                if (segmentTree[i * 2 + 1].flag) {\\n                    segmentTree[i].rightLen += segmentTree[i * 2].rightLen;\\n                    midLen = Math.max(midLen, segmentTree[i].rightLen);\\n                }\\n\\n                segmentTree[i].maxLen = Math.max(maxLen, midLen);;\\n            }//End if\\n        }//End While\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\n\\t////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////\\n    //Runtime: 163 ms, faster than 89.76% of Java online submissions for Longest Substring of One Repeating Character.\\n    //Memory Usage: 68.7 MB, less than 84.25% of Java online submissions for Longest Substring of One Repeating Character.\\n    //Segment tree + iteration\\n    //Time: O(M*lgN) ; Space: O(4N)\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        int len = s.length();\\n        int treeSize = 2;\\n        while (len >= 1) {\\n            treeSize <<= 1;\\n            len >>= 1;\\n        }\\n        //Space: O(4N)\\n        Node2213[] segmentTree = new Node2213[treeSize];\\n\\n        //Time: O(N)\\n        for (int i = 0; i < s.length();i++)\\n            updateSTree(i, s.charAt(i), segmentTree);\\n\\n        //Time: O(M*lgN)\\n        int[] res = new int[queryIndices.length];\\n        for (int i = 0; i < queryIndices.length;i++){\\n            //Time: O(lgN); Space:O(1)\\n            updateSTree(queryIndices[i], queryCharacters.charAt(i), segmentTree);\\n            res[i] = segmentTree[1].maxLen;\\n        }\\n        return res;\\n    }\\n\\n    class Node2213{\\n        char leftChar, rightChar;\\n        int leftLen = 1, rightLen = 1;\\n        int maxLen = 1;\\n        boolean flag = true;\\n        public Node2213(char c){\\n            leftChar = rightChar = c;\\n        }\\n    }\\n\\n    //Time: O(lgN); Space:O(1)\\n    private void updateSTree(int i, char c, Node2213[] segmentTree){\\n        i += segmentTree.length / 2;\\n        if (segmentTree[i] == null)  segmentTree[i] = new Node2213(\\'$\\');\\n        segmentTree[i].rightChar = c;\\n        segmentTree[i].leftChar = c;\\n\\n        while (i > 1){\\n            i = i >> 1;\\n            if (segmentTree[i] == null)  segmentTree[i] = new Node2213(\\'$\\');\\n            if (segmentTree[i*2+1] == null)  segmentTree[i*2+1] = new Node2213(\\'$\\');\\n\\n            //left\\n            segmentTree[i].leftChar =  segmentTree[i * 2].leftChar;\\n            segmentTree[i].leftLen =  segmentTree[i * 2].leftLen;\\n            //right\\n            segmentTree[i].rightChar =  segmentTree[i * 2 + 1].rightChar;\\n            segmentTree[i].rightLen =  segmentTree[i * 2 + 1].rightLen;\\n\\n            //maxLen & flag\\n            segmentTree[i].flag = segmentTree[i * 2].flag & segmentTree[i * 2 + 1].flag\\n                    & segmentTree[i * 2].rightChar == segmentTree[i * 2 + 1].leftChar;\\n\\n            segmentTree[i].maxLen = Math.max(segmentTree[i * 2].maxLen, segmentTree[i * 2 + 1].maxLen);\\n\\n            //do merge\\n            if (segmentTree[i * 2].rightChar != \\'$\\' && segmentTree[i * 2].rightChar == segmentTree[i * 2 + 1].leftChar) {\\n                int maxLen = segmentTree[i].maxLen;\\n                int midLen = segmentTree[i * 2].rightLen + segmentTree[i * 2 + 1].leftLen;\\n\\n                if (segmentTree[i * 2].flag) {\\n                    segmentTree[i].leftLen += segmentTree[i * 2 + 1].leftLen;\\n                    midLen = Math.max(midLen, segmentTree[i].leftLen);\\n                }\\n\\n                if (segmentTree[i * 2 + 1].flag) {\\n                    segmentTree[i].rightLen += segmentTree[i * 2].rightLen;\\n                    midLen = Math.max(midLen, segmentTree[i].rightLen);\\n                }\\n\\n                segmentTree[i].maxLen = Math.max(maxLen, midLen);;\\n            }//End if\\n        }//End While\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2328861,
                "title": "c-code-for-beginners-segment-tree-clean-code",
                "content": "```\\nstruct Info{\\n    char left=\\'#\\';\\n    char right=\\'#\\';\\n    int prefixCommon=0;\\n    int suffixCommon=0;\\n    int res=0;\\n};\\n\\nclass Solution {\\nprivate:\\n    Info tree[400001];\\npublic:\\n    int MAX(int a, int b, int c, int d, int e){\\n        return max(max(max(a,b),max(c,d)),e);\\n    }\\n    \\n    Info merge(Info &left, Info &right, int low, int mid, int high, int parent){\\n        Info temp;\\n        \\n        temp.left=tree[2*parent+1].left;\\n        temp.right=tree[2*parent+2].right;\\n        temp.prefixCommon=tree[2*parent+1].prefixCommon;\\n        temp.suffixCommon=tree[2*parent+2].suffixCommon;\\n        temp.res=MAX(temp.res,temp.prefixCommon,temp.suffixCommon,tree[2*parent+1].res,tree[2*parent+2].res);\\n        \\n        if(tree[2*parent+1].left==tree[2*parent+2].left && tree[2*parent+1].prefixCommon==mid-low+1){\\n            temp.prefixCommon=tree[2*parent+1].prefixCommon+tree[2*parent+2].prefixCommon;\\n        }\\n        if(tree[2*parent+1].right==tree[2*parent+2].right && tree[2*parent+2].suffixCommon==high-(mid+1)+1){\\n            temp.suffixCommon=tree[2*parent+1].suffixCommon+tree[2*parent+2].suffixCommon;\\n        }\\n        if(tree[2*parent+1].right==tree[2*parent+2].left){\\n            temp.res=max(temp.res,tree[2*parent+1].suffixCommon+tree[2*parent+2].prefixCommon);\\n        }\\n        return temp;\\n    }\\n    \\n    void build(string &s, int low, int high, int parent){\\n        if(low>high){\\n            return;\\n        }\\n        if(low==high){\\n            Info res={s[low],s[low],1,1,1};\\n            tree[parent]=res;\\n            return;\\n        }\\n        int mid=(low+high)/2;\\n        build(s,low,mid,2*parent+1);\\n        build(s,mid+1,high,2*parent+2);\\n        tree[parent]=merge(tree[2*parent+1],tree[2*parent+2],low,mid,high,parent);\\n    }\\n    \\n    void update(int low, int high, int parent, int index, char val){\\n        if(low>high){\\n            return;\\n        }\\n        if(low==high){\\n            Info res={val,val,1,1,1};\\n            tree[parent]=res;\\n            return;\\n        }\\n        int mid=(low+high)/2;\\n        if(index<=mid){\\n            update(low,mid,2*parent+1,index,val);\\n        }\\n        else{\\n            update(mid+1,high,2*parent+2,index,val);\\n        }\\n        tree[parent]=merge(tree[2*parent+1],tree[2*parent+2],low,mid,high,parent);\\n    }\\n    \\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        int n=s.size();\\n        vector<int> res;\\n        build(s,0,n-1,0);\\n        for(int i=0;i<queryIndices.size();i++){\\n            update(0,n-1,0,queryIndices[i],queryCharacters[i]);\\n            res.push_back(tree[0].res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct Info{\\n    char left=\\'#\\';\\n    char right=\\'#\\';\\n    int prefixCommon=0;\\n    int suffixCommon=0;\\n    int res=0;\\n};\\n\\nclass Solution {\\nprivate:\\n    Info tree[400001];\\npublic:\\n    int MAX(int a, int b, int c, int d, int e){\\n        return max(max(max(a,b),max(c,d)),e);\\n    }\\n    \\n    Info merge(Info &left, Info &right, int low, int mid, int high, int parent){\\n        Info temp;\\n        \\n        temp.left=tree[2*parent+1].left;\\n        temp.right=tree[2*parent+2].right;\\n        temp.prefixCommon=tree[2*parent+1].prefixCommon;\\n        temp.suffixCommon=tree[2*parent+2].suffixCommon;\\n        temp.res=MAX(temp.res,temp.prefixCommon,temp.suffixCommon,tree[2*parent+1].res,tree[2*parent+2].res);\\n        \\n        if(tree[2*parent+1].left==tree[2*parent+2].left && tree[2*parent+1].prefixCommon==mid-low+1){\\n            temp.prefixCommon=tree[2*parent+1].prefixCommon+tree[2*parent+2].prefixCommon;\\n        }\\n        if(tree[2*parent+1].right==tree[2*parent+2].right && tree[2*parent+2].suffixCommon==high-(mid+1)+1){\\n            temp.suffixCommon=tree[2*parent+1].suffixCommon+tree[2*parent+2].suffixCommon;\\n        }\\n        if(tree[2*parent+1].right==tree[2*parent+2].left){\\n            temp.res=max(temp.res,tree[2*parent+1].suffixCommon+tree[2*parent+2].prefixCommon);\\n        }\\n        return temp;\\n    }\\n    \\n    void build(string &s, int low, int high, int parent){\\n        if(low>high){\\n            return;\\n        }\\n        if(low==high){\\n            Info res={s[low],s[low],1,1,1};\\n            tree[parent]=res;\\n            return;\\n        }\\n        int mid=(low+high)/2;\\n        build(s,low,mid,2*parent+1);\\n        build(s,mid+1,high,2*parent+2);\\n        tree[parent]=merge(tree[2*parent+1],tree[2*parent+2],low,mid,high,parent);\\n    }\\n    \\n    void update(int low, int high, int parent, int index, char val){\\n        if(low>high){\\n            return;\\n        }\\n        if(low==high){\\n            Info res={val,val,1,1,1};\\n            tree[parent]=res;\\n            return;\\n        }\\n        int mid=(low+high)/2;\\n        if(index<=mid){\\n            update(low,mid,2*parent+1,index,val);\\n        }\\n        else{\\n            update(mid+1,high,2*parent+2,index,val);\\n        }\\n        tree[parent]=merge(tree[2*parent+1],tree[2*parent+2],low,mid,high,parent);\\n    }\\n    \\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        int n=s.size();\\n        vector<int> res;\\n        build(s,0,n-1,0);\\n        for(int i=0;i<queryIndices.size();i++){\\n            update(0,n-1,0,queryIndices[i],queryCharacters[i]);\\n            res.push_back(tree[0].res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2323999,
                "title": "c-maps",
                "content": "I would have explained this solution, but i do not want to.\\nI, myself hardly made it out alive, doing this problem.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {\\n        map<int, int> mp, len;\\n        int ind=0;\\n        mp[-1]=-1;\\n        mp[s.size()]=-1;\\n        len[s.size()+100000]=-1;\\n        while(ind<s.size())\\n        {\\n            int j=ind;\\n            while(j<s.size() && s[ind]==s[j])\\n                mp[ind]=j++;\\n            len[j-ind]++;\\n            ind=j;\\n        }\\n\\n        vector<int> res;\\n        for(int i=0; i<qi.size(); i++)\\n        {\\n            auto it = mp.lower_bound(qi[i]);\\n            if(it->first>qi[i])\\n                it--;\\n            len[it->second - it->first + 1]--;\\n            if(len[it->second-it->first+1]<=0)\\n                len.erase(it->second-it->first+1);\\n            if(it->second>=qi[i]+1)\\n            {\\n                mp[qi[i]+1]=it->second;\\n                len[it->second-qi[i]]++;\\n            }\\n            if(it->first<=qi[i]-1)\\n            {\\n                mp[it->first]=qi[i]-1;\\n                len[qi[i]-it->first]++;\\n            }\\n            mp[qi[i]]=qi[i];\\n            len[1]++;\\n            s[qi[i]]=qc[i];\\n            if(qi[i]+1<s.size() && s[qi[i]]==s[qi[i]+1])\\n            {\\n                len[1]--;\\n                if(len[1]==0)\\n                    len.erase(1);\\n                len[mp[qi[i]+1]-qi[i]]--;\\n                if(len[mp[qi[i]+1]-qi[i]]<=0)\\n                    len.erase(mp[qi[i]+1]-qi[i]);\\n                mp[qi[i]]=mp[qi[i]+1];\\n                len[mp[qi[i]]-qi[i]+1]++;\\n                mp.erase(qi[i]+1);\\n            }\\n            it=mp.find(qi[i]);\\n            it--;\\n            if(it->first>=0 && s[it->first]==s[qi[i]])\\n            {\\n                len[mp[qi[i]]-qi[i]+1]--;\\n                len[mp[it->first]-it->first+1]--;\\n                if(len[mp[it->first]-it->first+1]<=0)\\n                    len.erase(mp[it->first]-it->first+1);\\n                if(len[mp[qi[i]]-qi[i]+1]<=0)\\n                    len.erase(mp[qi[i]]-qi[i]+1);\\n                mp[it->first]=mp[qi[i]];\\n                len[mp[it->first]-it->first+1]++;\\n                mp.erase(qi[i]);\\n            }\\n            \\n            auto it2 = len.lower_bound(s.size()+100000);\\n            it2--;\\n            res.push_back(it2->first);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {\\n        map<int, int> mp, len;\\n        int ind=0;\\n        mp[-1]=-1;\\n        mp[s.size()]=-1;\\n        len[s.size()+100000]=-1;\\n        while(ind<s.size())\\n        {\\n            int j=ind;\\n            while(j<s.size() && s[ind]==s[j])\\n                mp[ind]=j++;\\n            len[j-ind]++;\\n            ind=j;\\n        }\\n\\n        vector<int> res;\\n        for(int i=0; i<qi.size(); i++)\\n        {\\n            auto it = mp.lower_bound(qi[i]);\\n            if(it->first>qi[i])\\n                it--;\\n            len[it->second - it->first + 1]--;\\n            if(len[it->second-it->first+1]<=0)\\n                len.erase(it->second-it->first+1);\\n            if(it->second>=qi[i]+1)\\n            {\\n                mp[qi[i]+1]=it->second;\\n                len[it->second-qi[i]]++;\\n            }\\n            if(it->first<=qi[i]-1)\\n            {\\n                mp[it->first]=qi[i]-1;\\n                len[qi[i]-it->first]++;\\n            }\\n            mp[qi[i]]=qi[i];\\n            len[1]++;\\n            s[qi[i]]=qc[i];\\n            if(qi[i]+1<s.size() && s[qi[i]]==s[qi[i]+1])\\n            {\\n                len[1]--;\\n                if(len[1]==0)\\n                    len.erase(1);\\n                len[mp[qi[i]+1]-qi[i]]--;\\n                if(len[mp[qi[i]+1]-qi[i]]<=0)\\n                    len.erase(mp[qi[i]+1]-qi[i]);\\n                mp[qi[i]]=mp[qi[i]+1];\\n                len[mp[qi[i]]-qi[i]+1]++;\\n                mp.erase(qi[i]+1);\\n            }\\n            it=mp.find(qi[i]);\\n            it--;\\n            if(it->first>=0 && s[it->first]==s[qi[i]])\\n            {\\n                len[mp[qi[i]]-qi[i]+1]--;\\n                len[mp[it->first]-it->first+1]--;\\n                if(len[mp[it->first]-it->first+1]<=0)\\n                    len.erase(mp[it->first]-it->first+1);\\n                if(len[mp[qi[i]]-qi[i]+1]<=0)\\n                    len.erase(mp[qi[i]]-qi[i]+1);\\n                mp[it->first]=mp[qi[i]];\\n                len[mp[it->first]-it->first+1]++;\\n                mp.erase(qi[i]);\\n            }\\n            \\n            auto it2 = len.lower_bound(s.size()+100000);\\n            it2--;\\n            res.push_back(it2->first);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2206771,
                "title": "error-tle",
                "content": "Why TLE error in this topic :(\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "Why TLE error in this topic :(\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2131575,
                "title": "rust-segment-tree",
                "content": "```rust\\nuse std::{\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::{BTreeMap, BinaryHeap, HashMap, VecDeque},\\n    rc::Rc,\\n};\\n\\n\\n/// Member Node of the SegmentTree\\n#[derive(Debug)]\\nstruct Node {\\n    /// the left bound of the Node in the Segment Tree\\n    left_index: usize,\\n    /// the right bound of the Node in the Segment Tree\\n    right_index: usize,\\n    /// length of the longest substring of one repeating character between [left_index, right_index]\\n    longest_substring_len: usize,\\n    /// leftmost char of the segment\\n    left_char: char,\\n    /// rightmost char of the segment\\n    right_char: char,\\n    /// length of the substring of one repeating character that start at the left_index\\n    left_char_rep_len: usize,\\n    /// length of the substring of one repeating character that end at the right_index\\n    right_char_rep_len: usize,\\n    /// left subnode\\n    left_node: Option<Rc<RefCell<Node>>>,\\n    /// right subnode\\n    right_node: Option<Rc<RefCell<Node>>>,\\n}\\n\\nimpl Node {\\n    fn construct(characters: &Vec<char>, left_index: usize, right_index: usize) -> Node {\\n        if left_index == right_index {\\n            Node {\\n                left_index,\\n                right_index,\\n                longest_substring_len: 1,\\n                left_char: characters[left_index],\\n                right_char: characters[right_index],\\n                left_char_rep_len: 1,\\n                right_char_rep_len: 1,\\n                left_node: None,\\n                right_node: None,\\n            }\\n        } else {\\n            let mut mid_index = (left_index + right_index) / 2;\\n            let left_node = Rc::new(RefCell::new(Node::construct(\\n                characters, left_index, mid_index,\\n            )));\\n            let right_node = Rc::new(RefCell::new(Node::construct(\\n                characters,\\n                mid_index + 1,\\n                right_index,\\n            )));\\n            Self::merge(left_node, right_node)\\n        }\\n    }\\n\\n    fn merge(left_node: Rc<RefCell<Node>>, right_node: Rc<RefCell<Node>>) -> Node {\\n        let mut longest_substring_len = std::cmp::max(\\n            left_node.borrow().longest_substring_len,\\n            right_node.borrow().longest_substring_len,\\n        );\\n        let merge_len = if left_node.borrow().right_char == right_node.borrow().left_char {\\n            left_node.borrow().right_char_rep_len + right_node.borrow().left_char_rep_len\\n        } else {\\n            0\\n        };\\n        longest_substring_len = std::cmp::max(longest_substring_len, merge_len);\\n\\n        let left_char_rep_len = if left_node.borrow().right_index - left_node.borrow().left_index + 1\\n            == left_node.borrow().left_char_rep_len\\n            && left_node.borrow().right_char == right_node.borrow().left_char\\n        {\\n            left_node.borrow().left_char_rep_len + right_node.borrow().left_char_rep_len\\n        } else {\\n            left_node.borrow().left_char_rep_len\\n        };\\n\\n        let right_char_rep_len = if right_node.borrow().right_index - right_node.borrow().left_index + 1\\n            == right_node.borrow().right_char_rep_len\\n            && left_node.borrow().right_char == right_node.borrow().left_char\\n        {\\n            right_node.borrow().right_char_rep_len + left_node.borrow().right_char_rep_len\\n        } else {\\n            right_node.borrow().right_char_rep_len\\n        };\\n\\n        Node {\\n            left_index: left_node.borrow().left_index,\\n            right_index: right_node.borrow().right_index,\\n            longest_substring_len,\\n            left_char: left_node.borrow().left_char,\\n            right_char: right_node.borrow().right_char,\\n            left_char_rep_len,\\n            right_char_rep_len,\\n            left_node: Some(left_node.clone()),\\n            right_node: Some(right_node.clone()),\\n        }\\n    }\\n\\n    fn update(&mut self, index: usize, character: char) {\\n        if self.left_index == self.right_index {\\n            self.left_char = character;\\n            self.right_char = character;\\n        } else {\\n            let l_node = self.left_node.clone().unwrap().clone();\\n            let r_node = self.right_node.clone().unwrap().clone();\\n            if index <= l_node.borrow().right_index {\\n                l_node.borrow_mut().update(index, character)\\n            } else {\\n                r_node.borrow_mut().update(index, character)\\n            }\\n\\n            *self = Node::merge(l_node, r_node)\\n        }\\n    }\\n}\\n\\n#[derive(Debug)]\\nstruct SegmentTree {\\n    node: Node,\\n}\\n\\nimpl SegmentTree {\\n    fn construct(characters: &Vec<char>) -> SegmentTree {\\n        SegmentTree {\\n            node: Node::construct(characters, 0, characters.len() - 1)\\n        }\\n    }\\n\\n    fn update(&mut self, index: usize, character: char) {\\n        self.node.update(index, character)\\n    }\\n\\n    fn longest_repeating(&self) -> usize {\\n        self.node.longest_substring_len\\n    }\\n}\\n\\n\\nimpl Solution {\\n    pub fn longest_repeating(\\n        s: String,\\n        query_characters: String,\\n        query_indices: Vec<i32>,\\n    ) -> Vec<i32> {\\n        let characters: Vec<char> = s.chars().collect();\\n        let query_characters: Vec<char> = query_characters.chars().collect();\\n        let mut res = vec![0; query_characters.len()];\\n        let mut segment_tree = SegmentTree::construct(&characters);\\n\\n        for query_index in 0..query_characters.len() {\\n            segment_tree.update(\\n                query_indices[query_index] as usize,\\n                query_characters[query_index],\\n            );\\n            res[query_index] = segment_tree.longest_repeating() as i32;\\n        }\\n\\n        res\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Tree"
                ],
                "code": "```rust\\nuse std::{\\n    cell::RefCell,\\n    cmp::Ordering,\\n    collections::{BTreeMap, BinaryHeap, HashMap, VecDeque},\\n    rc::Rc,\\n};\\n\\n\\n/// Member Node of the SegmentTree\\n#[derive(Debug)]\\nstruct Node {\\n    /// the left bound of the Node in the Segment Tree\\n    left_index: usize,\\n    /// the right bound of the Node in the Segment Tree\\n    right_index: usize,\\n    /// length of the longest substring of one repeating character between [left_index, right_index]\\n    longest_substring_len: usize,\\n    /// leftmost char of the segment\\n    left_char: char,\\n    /// rightmost char of the segment\\n    right_char: char,\\n    /// length of the substring of one repeating character that start at the left_index\\n    left_char_rep_len: usize,\\n    /// length of the substring of one repeating character that end at the right_index\\n    right_char_rep_len: usize,\\n    /// left subnode\\n    left_node: Option<Rc<RefCell<Node>>>,\\n    /// right subnode\\n    right_node: Option<Rc<RefCell<Node>>>,\\n}\\n\\nimpl Node {\\n    fn construct(characters: &Vec<char>, left_index: usize, right_index: usize) -> Node {\\n        if left_index == right_index {\\n            Node {\\n                left_index,\\n                right_index,\\n                longest_substring_len: 1,\\n                left_char: characters[left_index],\\n                right_char: characters[right_index],\\n                left_char_rep_len: 1,\\n                right_char_rep_len: 1,\\n                left_node: None,\\n                right_node: None,\\n            }\\n        } else {\\n            let mut mid_index = (left_index + right_index) / 2;\\n            let left_node = Rc::new(RefCell::new(Node::construct(\\n                characters, left_index, mid_index,\\n            )));\\n            let right_node = Rc::new(RefCell::new(Node::construct(\\n                characters,\\n                mid_index + 1,\\n                right_index,\\n            )));\\n            Self::merge(left_node, right_node)\\n        }\\n    }\\n\\n    fn merge(left_node: Rc<RefCell<Node>>, right_node: Rc<RefCell<Node>>) -> Node {\\n        let mut longest_substring_len = std::cmp::max(\\n            left_node.borrow().longest_substring_len,\\n            right_node.borrow().longest_substring_len,\\n        );\\n        let merge_len = if left_node.borrow().right_char == right_node.borrow().left_char {\\n            left_node.borrow().right_char_rep_len + right_node.borrow().left_char_rep_len\\n        } else {\\n            0\\n        };\\n        longest_substring_len = std::cmp::max(longest_substring_len, merge_len);\\n\\n        let left_char_rep_len = if left_node.borrow().right_index - left_node.borrow().left_index + 1\\n            == left_node.borrow().left_char_rep_len\\n            && left_node.borrow().right_char == right_node.borrow().left_char\\n        {\\n            left_node.borrow().left_char_rep_len + right_node.borrow().left_char_rep_len\\n        } else {\\n            left_node.borrow().left_char_rep_len\\n        };\\n\\n        let right_char_rep_len = if right_node.borrow().right_index - right_node.borrow().left_index + 1\\n            == right_node.borrow().right_char_rep_len\\n            && left_node.borrow().right_char == right_node.borrow().left_char\\n        {\\n            right_node.borrow().right_char_rep_len + left_node.borrow().right_char_rep_len\\n        } else {\\n            right_node.borrow().right_char_rep_len\\n        };\\n\\n        Node {\\n            left_index: left_node.borrow().left_index,\\n            right_index: right_node.borrow().right_index,\\n            longest_substring_len,\\n            left_char: left_node.borrow().left_char,\\n            right_char: right_node.borrow().right_char,\\n            left_char_rep_len,\\n            right_char_rep_len,\\n            left_node: Some(left_node.clone()),\\n            right_node: Some(right_node.clone()),\\n        }\\n    }\\n\\n    fn update(&mut self, index: usize, character: char) {\\n        if self.left_index == self.right_index {\\n            self.left_char = character;\\n            self.right_char = character;\\n        } else {\\n            let l_node = self.left_node.clone().unwrap().clone();\\n            let r_node = self.right_node.clone().unwrap().clone();\\n            if index <= l_node.borrow().right_index {\\n                l_node.borrow_mut().update(index, character)\\n            } else {\\n                r_node.borrow_mut().update(index, character)\\n            }\\n\\n            *self = Node::merge(l_node, r_node)\\n        }\\n    }\\n}\\n\\n#[derive(Debug)]\\nstruct SegmentTree {\\n    node: Node,\\n}\\n\\nimpl SegmentTree {\\n    fn construct(characters: &Vec<char>) -> SegmentTree {\\n        SegmentTree {\\n            node: Node::construct(characters, 0, characters.len() - 1)\\n        }\\n    }\\n\\n    fn update(&mut self, index: usize, character: char) {\\n        self.node.update(index, character)\\n    }\\n\\n    fn longest_repeating(&self) -> usize {\\n        self.node.longest_substring_len\\n    }\\n}\\n\\n\\nimpl Solution {\\n    pub fn longest_repeating(\\n        s: String,\\n        query_characters: String,\\n        query_indices: Vec<i32>,\\n    ) -> Vec<i32> {\\n        let characters: Vec<char> = s.chars().collect();\\n        let query_characters: Vec<char> = query_characters.chars().collect();\\n        let mut res = vec![0; query_characters.len()];\\n        let mut segment_tree = SegmentTree::construct(&characters);\\n\\n        for query_index in 0..query_characters.len() {\\n            segment_tree.update(\\n                query_indices[query_index] as usize,\\n                query_characters[query_index],\\n            );\\n            res[query_index] = segment_tree.longest_repeating() as i32;\\n        }\\n\\n        res\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028915,
                "title": "using-treemap",
                "content": "```\\nclass Solution {\\n    \\n    TreeMap<Integer, Character> map;\\n    TreeMap<Integer, Integer> maxHeap;\\n    \\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        \\n        map = new TreeMap<>();\\n        maxHeap = new TreeMap<>();\\n        \\n        int n = s.length();\\n        add(new Node(new int[]{-2, -2}, \\'*\\'));\\n        add(new Node(new int[]{-1, -1}, \\'.\\'));\\n        add(new Node(new int[]{n, n}, \\'.\\'));\\n        add(new Node(new int[]{n+1, n+1}, \\'*\\'));\\n        \\n        for(int i=0; i<s.length();) {\\n            int j = i;\\n            while(j<s.length() && s.charAt(i)==s.charAt(j)) {\\n                j++;\\n            }\\n            add(new Node(new int[]{i, j-1}, s.charAt(i)));\\n            i=j;\\n        }\\n        \\n        n = queryIndices.length;\\n        int[] ans = new int[n];\\n        \\n        for(int i=0; i<n; i++) {\\n            int index = queryIndices[i];\\n            char ch = queryCharacters.charAt(i);\\n            Node node = remove(index);\\n            add(new Node(new int[]{index, index}, ch));\\n            \\n            if(node.range[0]<index) {\\n                add(new Node(new int[]{node.range[0], index-1}, node.ch));\\n            }\\n            if(index<node.range[1]) {\\n                add(new Node(new int[]{index+1, node.range[1]}, node.ch));\\n            }\\n            fix(index);\\n            ans[i] = maxHeap.floorKey(s.length());\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void add(Node node) {\\n        map.put(node.range[0], node.ch);\\n        int diff = node.range[1]-node.range[0]+1;\\n        maxHeap.put(diff, maxHeap.getOrDefault(diff, 0)+1);\\n    }\\n    \\n    private int[] findRange(int index) {\\n        int[] range = new int[2];\\n        range[0] = map.floorKey(index);\\n        range[1] = map.higherKey(index)-1;\\n        \\n        return range;\\n    }\\n    \\n    private Node remove(int index) {\\n        int[] range = findRange(index);\\n        char ch = map.get(range[0]);\\n        \\n        map.remove(range[0]);\\n        int diff = range[1]-range[0]+1;\\n        int prev = maxHeap.get(diff);\\n        if(prev == 1) {\\n            maxHeap.remove(diff);\\n        } else {\\n            maxHeap.put(diff, prev-1);   \\n        }\\n        \\n        return new Node(range, ch);\\n    }\\n    \\n    private void fix(int index) {\\n        int[] currRange = findRange(index);\\n        Node prev = remove(currRange[0]-1);\\n        Node curr = remove(index);\\n        Node next = remove(currRange[1]+1);\\n        if(prev.ch == curr.ch && curr.ch == next.ch) {\\n            Node node = new Node(new int[]{prev.range[0], next.range[1]}, curr.ch);\\n            add(node);\\n        } else if(prev.ch == curr.ch) {\\n            Node node = new Node(new int[]{prev.range[0], curr.range[1]}, curr.ch);\\n            add(node);\\n            add(next);\\n        } else if(curr.ch == next.ch) {\\n            Node node = new Node(new int[]{curr.range[0], next.range[1]}, curr.ch);\\n            add(node);\\n            add(prev);\\n        } else {\\n            add(curr);\\n            add(prev);\\n            add(next);\\n        }\\n    }\\n}\\n\\nclass Node {\\n    int[] range;\\n    char ch;\\n    Node(int[] range, char ch) {\\n        this.range = range;\\n        this.ch = ch;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    TreeMap<Integer, Character> map;\\n    TreeMap<Integer, Integer> maxHeap;\\n    \\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        \\n        map = new TreeMap<>();\\n        maxHeap = new TreeMap<>();\\n        \\n        int n = s.length();\\n        add(new Node(new int[]{-2, -2}, \\'*\\'));\\n        add(new Node(new int[]{-1, -1}, \\'.\\'));\\n        add(new Node(new int[]{n, n}, \\'.\\'));\\n        add(new Node(new int[]{n+1, n+1}, \\'*\\'));\\n        \\n        for(int i=0; i<s.length();) {\\n            int j = i;\\n            while(j<s.length() && s.charAt(i)==s.charAt(j)) {\\n                j++;\\n            }\\n            add(new Node(new int[]{i, j-1}, s.charAt(i)));\\n            i=j;\\n        }\\n        \\n        n = queryIndices.length;\\n        int[] ans = new int[n];\\n        \\n        for(int i=0; i<n; i++) {\\n            int index = queryIndices[i];\\n            char ch = queryCharacters.charAt(i);\\n            Node node = remove(index);\\n            add(new Node(new int[]{index, index}, ch));\\n            \\n            if(node.range[0]<index) {\\n                add(new Node(new int[]{node.range[0], index-1}, node.ch));\\n            }\\n            if(index<node.range[1]) {\\n                add(new Node(new int[]{index+1, node.range[1]}, node.ch));\\n            }\\n            fix(index);\\n            ans[i] = maxHeap.floorKey(s.length());\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private void add(Node node) {\\n        map.put(node.range[0], node.ch);\\n        int diff = node.range[1]-node.range[0]+1;\\n        maxHeap.put(diff, maxHeap.getOrDefault(diff, 0)+1);\\n    }\\n    \\n    private int[] findRange(int index) {\\n        int[] range = new int[2];\\n        range[0] = map.floorKey(index);\\n        range[1] = map.higherKey(index)-1;\\n        \\n        return range;\\n    }\\n    \\n    private Node remove(int index) {\\n        int[] range = findRange(index);\\n        char ch = map.get(range[0]);\\n        \\n        map.remove(range[0]);\\n        int diff = range[1]-range[0]+1;\\n        int prev = maxHeap.get(diff);\\n        if(prev == 1) {\\n            maxHeap.remove(diff);\\n        } else {\\n            maxHeap.put(diff, prev-1);   \\n        }\\n        \\n        return new Node(range, ch);\\n    }\\n    \\n    private void fix(int index) {\\n        int[] currRange = findRange(index);\\n        Node prev = remove(currRange[0]-1);\\n        Node curr = remove(index);\\n        Node next = remove(currRange[1]+1);\\n        if(prev.ch == curr.ch && curr.ch == next.ch) {\\n            Node node = new Node(new int[]{prev.range[0], next.range[1]}, curr.ch);\\n            add(node);\\n        } else if(prev.ch == curr.ch) {\\n            Node node = new Node(new int[]{prev.range[0], curr.range[1]}, curr.ch);\\n            add(node);\\n            add(next);\\n        } else if(curr.ch == next.ch) {\\n            Node node = new Node(new int[]{curr.range[0], next.range[1]}, curr.ch);\\n            add(node);\\n            add(prev);\\n        } else {\\n            add(curr);\\n            add(prev);\\n            add(next);\\n        }\\n    }\\n}\\n\\nclass Node {\\n    int[] range;\\n    char ch;\\n    Node(int[] range, char ch) {\\n        this.range = range;\\n        this.ch = ch;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945570,
                "title": "python-share-my-code-with-segment-tree-it-still-gets-tle-but-simple-to-understand",
                "content": "My code is not accepted due to TLE but I think it\\'s simple to read. If you have any idea to make it faster, please share. Thanks\\n```python\\nclass Item:\\n    def __init__(self, char, count):\\n        self.char = char\\n        self.count = count\\n\\n    def set(self, char, count):\\n        self.char = char\\n        self.count = count\\n\\n\\nclass Node:\\n    def __init__(self):\\n        self.prefix = Item(\\'\\', 0)\\n        self.suffix = Item(\\'\\', 0)\\n        self.max = 0\\n        self.size = 0\\n\\n    def update(self, left: \\'Node\\', right: \\'Node\\'):\\n        self.size = left.size + right.size\\n\\n        if left.is_monotonic and left.suffix.char == right.prefix.char:\\n            self.prefix.set(left.prefix.char, left.prefix.count + right.prefix.count)\\n        else:\\n            self.prefix.set(left.prefix.char, left.prefix.count)\\n\\n        if right.size == 0: # Only do this for right node because we may have empty node on the right\\n            self.suffix.set(left.suffix.char, left.suffix.count)\\n        elif right.is_monotonic and right.prefix.char == left.suffix.char:\\n            self.suffix.set(right.suffix.char, left.suffix.count + right.suffix.count)\\n        else:\\n            self.suffix.set(right.suffix.char, right.suffix.count)\\n\\t\\t\\t\\n        middle = (left.suffix.count + right.prefix.count) if left.suffix.char == right.prefix.char else 0\\n        self.max = max(self.prefix.count, self.suffix.count, left.max, right.max, middle)\\n\\n    def single(self, char):\\n        self.prefix.set(char, 1)\\n        self.suffix.set(char, 1)\\n        self.max = 1\\n        self.size = 1\\n\\n    @property\\n    def is_monotonic(self):\\n        return self.prefix.count == self.size and self.size > 0\\n\\n\\nclass SegTree:\\n\\n    def __init__(self, s):\\n        l = len(s)\\n        self.size = 1 << len(format(l, \\'b\\'))\\n        self.tree = [Node() for _ in range(self.size * 2)]\\n        for i, c in enumerate(s):\\n            self.set(i, c)\\n\\n    def set(self, i, char):\\n        index = self.size + i\\n        self.tree[index].single(char)\\n        index //= 2\\n        while index > 0:\\n            self.tree[index].update(self.tree[index * 2], self.tree[index * 2 + 1])\\n            index //= 2\\n\\n    def max(self):\\n        return self.tree[1].max\\n\\n\\nclass Solution:\\n    def longestRepeating(self, s, queryCharacters, queryIndices):\\n        tree = SegTree(s)\\n        ans = []\\n        for c, i in zip(queryCharacters, queryIndices):\\n            tree.set(i, c)\\n            ans.append(tree.max())\\n        return ans\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```python\\nclass Item:\\n    def __init__(self, char, count):\\n        self.char = char\\n        self.count = count\\n\\n    def set(self, char, count):\\n        self.char = char\\n        self.count = count\\n\\n\\nclass Node:\\n    def __init__(self):\\n        self.prefix = Item(\\'\\', 0)\\n        self.suffix = Item(\\'\\', 0)\\n        self.max = 0\\n        self.size = 0\\n\\n    def update(self, left: \\'Node\\', right: \\'Node\\'):\\n        self.size = left.size + right.size\\n\\n        if left.is_monotonic and left.suffix.char == right.prefix.char:\\n            self.prefix.set(left.prefix.char, left.prefix.count + right.prefix.count)\\n        else:\\n            self.prefix.set(left.prefix.char, left.prefix.count)\\n\\n        if right.size == 0: # Only do this for right node because we may have empty node on the right\\n            self.suffix.set(left.suffix.char, left.suffix.count)\\n        elif right.is_monotonic and right.prefix.char == left.suffix.char:\\n            self.suffix.set(right.suffix.char, left.suffix.count + right.suffix.count)\\n        else:\\n            self.suffix.set(right.suffix.char, right.suffix.count)\\n\\t\\t\\t\\n        middle = (left.suffix.count + right.prefix.count) if left.suffix.char == right.prefix.char else 0\\n        self.max = max(self.prefix.count, self.suffix.count, left.max, right.max, middle)\\n\\n    def single(self, char):\\n        self.prefix.set(char, 1)\\n        self.suffix.set(char, 1)\\n        self.max = 1\\n        self.size = 1\\n\\n    @property\\n    def is_monotonic(self):\\n        return self.prefix.count == self.size and self.size > 0\\n\\n\\nclass SegTree:\\n\\n    def __init__(self, s):\\n        l = len(s)\\n        self.size = 1 << len(format(l, \\'b\\'))\\n        self.tree = [Node() for _ in range(self.size * 2)]\\n        for i, c in enumerate(s):\\n            self.set(i, c)\\n\\n    def set(self, i, char):\\n        index = self.size + i\\n        self.tree[index].single(char)\\n        index //= 2\\n        while index > 0:\\n            self.tree[index].update(self.tree[index * 2], self.tree[index * 2 + 1])\\n            index //= 2\\n\\n    def max(self):\\n        return self.tree[1].max\\n\\n\\nclass Solution:\\n    def longestRepeating(self, s, queryCharacters, queryIndices):\\n        tree = SegTree(s)\\n        ans = []\\n        for c, i in zip(queryCharacters, queryIndices):\\n            tree.set(i, c)\\n            ans.append(tree.max())\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943316,
                "title": "simple-c-segment-tree",
                "content": "```cpp\\nclass SegTree {\\nprivate:\\n    int sz;\\n    string S;\\n    vector<int> total;\\n    vector<int> left, right;\\n    \\n    void insert(int idx, int s, int e, int index, char ch) {\\n        if (index<s || index>e) return;\\n        if (s==e) {\\n            total[idx] = 1;\\n            left[idx] = 1;\\n            right[idx] = 1;\\n            S[index] = ch;\\n            return;\\n        }\\n        int l = 2*idx + 1;\\n        int r = 2*idx + 2;\\n        int m = s + (e-s)/2;\\n        insert(l, s, m, index, ch);\\n        insert(r, m + 1, e, index, ch);\\n        if (S[m]!=\\'*\\' && S[m]==S[m+1]) {\\n            total[idx] = max({total[l], total[r], right[l]+left[r]});\\n            left[idx] = (right[l]+left[l]>m-s+1)?left[l] + left[r]: left[l];\\n            right[idx] = (right[r]+left[r]>e-m)?right[r] + right[l]: right[r];\\n        } else {\\n            total[idx] = max({total[l], total[r]});\\n            left[idx] = left[l];\\n            right[idx] = right[r];\\n        }\\n    }\\n    \\npublic:\\n    SegTree(int n) {\\n        sz = n;\\n        S.resize(n, \\'*\\');\\n        total.resize(4*n+4, 0);\\n        left.resize(4*n+4, 0);\\n        right.resize(4*n+4, 0);\\n    }\\n    \\n    void insert(int idx, char ch) {\\n        insert(0, 0, sz-1, idx, ch);\\n    }\\n    \\n    int getTop() { return total[0]; }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string qC, vector<int>& qI) {\\n        int n = s.length();\\n        SegTree st(n);\\n        for (int i=0;i<n;i++) {\\n            st.insert(i, s[i]);\\n        }\\n        \\n        vector<int> ans;\\n        for (int i=0;i<qI.size();i++) {\\n            st.insert(qI[i], qC[i]);\\n            ans.push_back(st.getTop());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```cpp\\nclass SegTree {\\nprivate:\\n    int sz;\\n    string S;\\n    vector<int> total;\\n    vector<int> left, right;\\n    \\n    void insert(int idx, int s, int e, int index, char ch) {\\n        if (index<s || index>e) return;\\n        if (s==e) {\\n            total[idx] = 1;\\n            left[idx] = 1;\\n            right[idx] = 1;\\n            S[index] = ch;\\n            return;\\n        }\\n        int l = 2*idx + 1;\\n        int r = 2*idx + 2;\\n        int m = s + (e-s)/2;\\n        insert(l, s, m, index, ch);\\n        insert(r, m + 1, e, index, ch);\\n        if (S[m]!=\\'*\\' && S[m]==S[m+1]) {\\n            total[idx] = max({total[l], total[r], right[l]+left[r]});\\n            left[idx] = (right[l]+left[l]>m-s+1)?left[l] + left[r]: left[l];\\n            right[idx] = (right[r]+left[r]>e-m)?right[r] + right[l]: right[r];\\n        } else {\\n            total[idx] = max({total[l], total[r]});\\n            left[idx] = left[l];\\n            right[idx] = right[r];\\n        }\\n    }\\n    \\npublic:\\n    SegTree(int n) {\\n        sz = n;\\n        S.resize(n, \\'*\\');\\n        total.resize(4*n+4, 0);\\n        left.resize(4*n+4, 0);\\n        right.resize(4*n+4, 0);\\n    }\\n    \\n    void insert(int idx, char ch) {\\n        insert(0, 0, sz-1, idx, ch);\\n    }\\n    \\n    int getTop() { return total[0]; }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string qC, vector<int>& qI) {\\n        int n = s.length();\\n        SegTree st(n);\\n        for (int i=0;i<n;i++) {\\n            st.insert(i, s[i]);\\n        }\\n        \\n        vector<int> ans;\\n        for (int i=0;i<qI.size();i++) {\\n            st.insert(qI[i], qC[i]);\\n            ans.push_back(st.getTop());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1915286,
                "title": "please-fix-python3-can-not-pass",
                "content": "This problem for some reason can not be passed with python3 implementations anymore (as of 04/04/2022). PLEASE FIX!!!\\n\\nTo other leetcoders: don\\'t try to pass it with python. I tried several of the python implementations in the discussions and for the ones that could pass, its almost hitting the 10s threshold.\\n\\nPython3 implementation that failed to pass (51/57) :\\n```\\nclass Node:\\n    def __init__(self, start, end, value):\\n        self.start, self.end = start, end\\n        self.lC, self.rC = value, value\\n        self.lL, self.rL, self.mL = 1, 1, 1\\n        self.left, self.right = None, None\\n\\t\\tself.L = end - start + 1\\n    def initChild(self, left, right):\\n        self.left = left\\n        self.right = right\\n        self.updateRL()\\n    def updateRL(self):\\n        left, right = self.left, self.right\\n        self.lC = left.lC\\n        self.rC = right.rC\\n        self.lL = left.lL\\n        self.rL = right.rL\\n        self.mL = max(self.left.mL, self.right.mL)\\n        if left.rC == right.lC:\\n            if left.lL == left.L:\\n                self.lL = left.lL + right.lL\\n            if right.rL == right.L:\\n                self.rL = right.rL + left.rL\\n            self.mL = max(self.mL, self.lL, self.rL, left.rL + right.lL)\\n    def update(self, index, value):\\n        if self.start == self.end and self.start == index:\\n            self.lC, self.rC = value, value\\n            return\\n        if index <= self.left.end:\\n            self.left.update(index, value)\\n        else:\\n            self.right.update(index, value)\\n        self.updateRL()\\n        \\nclass SegmentTree:\\n    def __init__(self, s):\\n        self.string = s\\n        self.root = self.build(0, len(s)-1)\\n    def build(self, start, end):\\n        if start == end:\\n            return Node(start, end, self.string[start])\\n        mid = start + end >> 1\\n        left = self.build(start, mid)\\n        right = self.build(mid+1, end)\\n        current = Node(start, end, \"\")\\n        current.initChild(left, right)\\n        return current\\n    def update(self, idx, value):\\n        self.root.update(idx, value)\\n    def query(self):\\n        return self.root.mL\\n\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        segTree = SegmentTree(s)\\n        solution = []\\n        for idx, value in zip(queryIndices, queryCharacters):\\n            segTree.update(idx, value)\\n            solution.append(segTree.query()) \\n        return solution\\n```\\n\\nC++ implementations that passed (705ms / 184.2 MB ):\\n```\\nclass Node {\\n    public:\\n    int start, end;\\n    char lC, rC;\\n    int lL, rL, mL, l;\\n    Node * left, * right;\\n    Node(int start, int end, char value){\\n        this->start = start;\\n        this->end = end;\\n        lL = 1, rL = 1, mL = 1;\\n        lC = value, rC = value;\\n        left = nullptr, right = nullptr;\\n        l = end - start + 1;\\n    }\\n    void initChild(Node * left, Node * right){\\n        this->left = left;\\n        this->right = right;\\n        updateRL();\\n    }\\n    void updateRL(){\\n        lC = left->lC;\\n        rC = right->rC;\\n        lL = left->lL;\\n        rL = right->rL;\\n        mL = max(left->mL, right->mL);\\n        if(left->rC == right->lC){\\n            if(left->lL == left->l) {\\n                lL = left->lL + right->lL;\\n                mL = max(mL, lL);\\n            }\\n            if(right->rL == right->l){\\n                rL = right->rL + left->rL;\\n                mL = max(mL, rL);\\n            }\\n            mL = max(mL, left->rL + right->lL);\\n        }\\n    }\\n    void update(int index, char value){\\n        if(start == end && start == index){\\n            lC = value;\\n            rC = value;\\n            return;\\n        }\\n        int mid = (start+end) >> 1;\\n        if(index <= mid)\\n            left->update(index, value);\\n        else \\n            right->update(index, value);\\n        updateRL();\\n    }\\n    \\n};\\n\\nclass Tree{\\n    public:\\n    string s;\\n    Node * root;\\n    Tree(string s){\\n        this->s = s;\\n        root = build(0, s.length()-1);\\n    }\\n    Node * build(int left, int right){\\n        if(left == right){\\n            auto current = new Node(left, right, s[left]);\\n            return current;\\n        }\\n        int mid = (left + right) >> 1;\\n        Node * lNode = build(left, mid);\\n        Node * rNode = build(mid+1, right);\\n        Node * current = new Node(left, right, \\' \\');\\n        current->initChild(lNode, rNode);\\n        return current;\\n    }\\n    int update(int index, char value){\\n        root->update(index, value);\\n        return root->mL;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        Tree segTree(s);\\n        vector<int> solution;\\n        for(int i = 0; i < queryCharacters.size(); i++)\\n            solution.push_back(segTree.update(queryIndices[i], queryCharacters[i]));\\n        return solution;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Node:\\n    def __init__(self, start, end, value):\\n        self.start, self.end = start, end\\n        self.lC, self.rC = value, value\\n        self.lL, self.rL, self.mL = 1, 1, 1\\n        self.left, self.right = None, None\\n\\t\\tself.L = end - start + 1\\n    def initChild(self, left, right):\\n        self.left = left\\n        self.right = right\\n        self.updateRL()\\n    def updateRL(self):\\n        left, right = self.left, self.right\\n        self.lC = left.lC\\n        self.rC = right.rC\\n        self.lL = left.lL\\n        self.rL = right.rL\\n        self.mL = max(self.left.mL, self.right.mL)\\n        if left.rC == right.lC:\\n            if left.lL == left.L:\\n                self.lL = left.lL + right.lL\\n            if right.rL == right.L:\\n                self.rL = right.rL + left.rL\\n            self.mL = max(self.mL, self.lL, self.rL, left.rL + right.lL)\\n    def update(self, index, value):\\n        if self.start == self.end and self.start == index:\\n            self.lC, self.rC = value, value\\n            return\\n        if index <= self.left.end:\\n            self.left.update(index, value)\\n        else:\\n            self.right.update(index, value)\\n        self.updateRL()\\n        \\nclass SegmentTree:\\n    def __init__(self, s):\\n        self.string = s\\n        self.root = self.build(0, len(s)-1)\\n    def build(self, start, end):\\n        if start == end:\\n            return Node(start, end, self.string[start])\\n        mid = start + end >> 1\\n        left = self.build(start, mid)\\n        right = self.build(mid+1, end)\\n        current = Node(start, end, \"\")\\n        current.initChild(left, right)\\n        return current\\n    def update(self, idx, value):\\n        self.root.update(idx, value)\\n    def query(self):\\n        return self.root.mL\\n\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        segTree = SegmentTree(s)\\n        solution = []\\n        for idx, value in zip(queryIndices, queryCharacters):\\n            segTree.update(idx, value)\\n            solution.append(segTree.query()) \\n        return solution\\n```\n```\\nclass Node {\\n    public:\\n    int start, end;\\n    char lC, rC;\\n    int lL, rL, mL, l;\\n    Node * left, * right;\\n    Node(int start, int end, char value){\\n        this->start = start;\\n        this->end = end;\\n        lL = 1, rL = 1, mL = 1;\\n        lC = value, rC = value;\\n        left = nullptr, right = nullptr;\\n        l = end - start + 1;\\n    }\\n    void initChild(Node * left, Node * right){\\n        this->left = left;\\n        this->right = right;\\n        updateRL();\\n    }\\n    void updateRL(){\\n        lC = left->lC;\\n        rC = right->rC;\\n        lL = left->lL;\\n        rL = right->rL;\\n        mL = max(left->mL, right->mL);\\n        if(left->rC == right->lC){\\n            if(left->lL == left->l) {\\n                lL = left->lL + right->lL;\\n                mL = max(mL, lL);\\n            }\\n            if(right->rL == right->l){\\n                rL = right->rL + left->rL;\\n                mL = max(mL, rL);\\n            }\\n            mL = max(mL, left->rL + right->lL);\\n        }\\n    }\\n    void update(int index, char value){\\n        if(start == end && start == index){\\n            lC = value;\\n            rC = value;\\n            return;\\n        }\\n        int mid = (start+end) >> 1;\\n        if(index <= mid)\\n            left->update(index, value);\\n        else \\n            right->update(index, value);\\n        updateRL();\\n    }\\n    \\n};\\n\\nclass Tree{\\n    public:\\n    string s;\\n    Node * root;\\n    Tree(string s){\\n        this->s = s;\\n        root = build(0, s.length()-1);\\n    }\\n    Node * build(int left, int right){\\n        if(left == right){\\n            auto current = new Node(left, right, s[left]);\\n            return current;\\n        }\\n        int mid = (left + right) >> 1;\\n        Node * lNode = build(left, mid);\\n        Node * rNode = build(mid+1, right);\\n        Node * current = new Node(left, right, \\' \\');\\n        current->initChild(lNode, rNode);\\n        return current;\\n    }\\n    int update(int index, char value){\\n        root->update(index, value);\\n        return root->mL;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        Tree segTree(s);\\n        vector<int> solution;\\n        for(int i = 0; i < queryCharacters.size(); i++)\\n            solution.push_back(segTree.update(queryIndices[i], queryCharacters[i]));\\n        return solution;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890178,
                "title": "java-easy-treemap-solution",
                "content": "Use a treemap to store all segments, another treemap to track the max length, then the solution have O(logN) complex for each operation.\\n\\n```\\nclass Solution {\\n    \\n    TreeMap<Integer, Segment> tree = new TreeMap<>();\\n    TreeMap<Integer, Set<Segment>> lengths = new TreeMap<>();\\n\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        if (s == null || s.isEmpty()) {  // Preconditions \\n            return new int[]{0};\\n        }\\n        for (int i = 1, start = 0; i <= s.length(); i ++) {  // Init the maps\\n            if (i == s.length() || s.charAt(i) != s.charAt(start)) {\\n                add(new Segment(s.charAt(start), start, i - 1));\\n                start = i;\\n            }\\n        }\\n        int[] result = new int[queryIndices.length];\\n        for (int i = 0; i < queryIndices.length; i ++) {  // Do the work.\\n            int k = queryIndices[i];\\n            char r = queryCharacters.charAt(i);\\n            if (floor(k).c == r) {\\n                result[i] = maxLen();\\n                continue;\\n            }\\n            Segment seg = remove(floor(k).start);\\n            if (seg.start < k) { // split left\\n                add(new Segment(seg.c, seg.start, k - 1));\\n            }\\n            if (seg.end > k) { // split right\\n                add(new Segment(seg.c, k + 1, seg.end));\\n            }\\n            seg = new Segment(r, k, k);\\n            Segment left = floor(k - 1), right = ceiling(k + 1);\\n            if (left != null && left.c == r) { // merge left\\n                seg.start = remove(left.start).start;\\n            }\\n            if (right != null && right.c == r) { // merge right\\n                seg.end = remove(right.start).end;\\n            }\\n            add(seg);\\n            result[i] = maxLen();\\n        }\\n        return result;\\n    }\\n\\t    \\n    private void add(Segment s) {\\n        tree.put(s.start, s);\\n        lengths.putIfAbsent(s.len(), new HashSet<>());\\n        lengths.get(s.len()).add(s);\\n    }\\n    \\n    private Segment remove(int key) {\\n        Segment removed = tree.remove(key);\\n        lengths.get(removed.len()).remove(removed);\\n        if (lengths.get(removed.len()).isEmpty()) {\\n            lengths.remove(removed.len());\\n        }\\n        return removed;\\n    }\\n    \\n    private Segment floor(int i) {\\n        if (tree.floorEntry(i) != null) {\\n            return tree.floorEntry(i).getValue();\\n        }\\n        return null;\\n    }\\n    \\n    private Segment ceiling(int i) {\\n        if (tree.ceilingEntry(i) != null) {\\n            return tree.ceilingEntry(i).getValue();\\n        }\\n        return null;\\n    }\\n    \\n    private int maxLen() {\\n        return lengths.lastKey();\\n    }\\n\\t\\n\\tstatic class Segment {\\n        public char c;\\n        public int start;\\n        public int end;\\n        \\n        public Segment(char c, int start, int end) {\\n            this.c = c;\\n            this.start = start;\\n            this.end = end;\\n        }\\n        \\n        public int len() {\\n            return end - start + 1;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            return String.format(\"[%c|%d-%d]\", c, start, end);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    \\n    TreeMap<Integer, Segment> tree = new TreeMap<>();\\n    TreeMap<Integer, Set<Segment>> lengths = new TreeMap<>();\\n\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        if (s == null || s.isEmpty()) {  // Preconditions \\n            return new int[]{0};\\n        }\\n        for (int i = 1, start = 0; i <= s.length(); i ++) {  // Init the maps\\n            if (i == s.length() || s.charAt(i) != s.charAt(start)) {\\n                add(new Segment(s.charAt(start), start, i - 1));\\n                start = i;\\n            }\\n        }\\n        int[] result = new int[queryIndices.length];\\n        for (int i = 0; i < queryIndices.length; i ++) {  // Do the work.\\n            int k = queryIndices[i];\\n            char r = queryCharacters.charAt(i);\\n            if (floor(k).c == r) {\\n                result[i] = maxLen();\\n                continue;\\n            }\\n            Segment seg = remove(floor(k).start);\\n            if (seg.start < k) { // split left\\n                add(new Segment(seg.c, seg.start, k - 1));\\n            }\\n            if (seg.end > k) { // split right\\n                add(new Segment(seg.c, k + 1, seg.end));\\n            }\\n            seg = new Segment(r, k, k);\\n            Segment left = floor(k - 1), right = ceiling(k + 1);\\n            if (left != null && left.c == r) { // merge left\\n                seg.start = remove(left.start).start;\\n            }\\n            if (right != null && right.c == r) { // merge right\\n                seg.end = remove(right.start).end;\\n            }\\n            add(seg);\\n            result[i] = maxLen();\\n        }\\n        return result;\\n    }\\n\\t    \\n    private void add(Segment s) {\\n        tree.put(s.start, s);\\n        lengths.putIfAbsent(s.len(), new HashSet<>());\\n        lengths.get(s.len()).add(s);\\n    }\\n    \\n    private Segment remove(int key) {\\n        Segment removed = tree.remove(key);\\n        lengths.get(removed.len()).remove(removed);\\n        if (lengths.get(removed.len()).isEmpty()) {\\n            lengths.remove(removed.len());\\n        }\\n        return removed;\\n    }\\n    \\n    private Segment floor(int i) {\\n        if (tree.floorEntry(i) != null) {\\n            return tree.floorEntry(i).getValue();\\n        }\\n        return null;\\n    }\\n    \\n    private Segment ceiling(int i) {\\n        if (tree.ceilingEntry(i) != null) {\\n            return tree.ceilingEntry(i).getValue();\\n        }\\n        return null;\\n    }\\n    \\n    private int maxLen() {\\n        return lengths.lastKey();\\n    }\\n\\t\\n\\tstatic class Segment {\\n        public char c;\\n        public int start;\\n        public int end;\\n        \\n        public Segment(char c, int start, int end) {\\n            this.c = c;\\n            this.start = start;\\n            this.end = end;\\n        }\\n        \\n        public int len() {\\n            return end - start + 1;\\n        }\\n        \\n        @Override\\n        public String toString() {\\n            return String.format(\"[%c|%d-%d]\", c, start, end);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884495,
                "title": "c-easy-bottom-up-segment-tree",
                "content": "EACH NODE OF SEGMENT TREE CARRY A SUBSTRING OF THE ORIGNAL STRING \\n\\n```\\nclass Solution {\\npublic:\\n    class tree\\n    {\\n        public:\\n        int st; // start index of substring\\n        int ed; //end index  of substring\\n        char cst; // start character of sustring\\n        char ced; // end character of substring\\n        tree* left;\\n        tree* right;\\n        int pl;  // lenght of longest prifix with one reapiting character\\n        int sl;  //  lenght of longest suffix with one reapiting character\\n        int ans;  \\n        tree(int st,int ed,char cst,char ced,int pl,int sl):st(st),ed(ed),cst(cst),ced(ced),pl(pl),sl(sl),left(NULL),right(NULL),ans(1)\\n        {\\n            \\n        }\\n        \\n        \\n        \\n        \\n    };\\n    tree* build(string &s,int i,int j)\\n    {\\n        if(i>j)\\n            return NULL;\\n        if(i==j)\\n            return new tree(i,j,s[i],s[j],1,1);\\n        \\n        tree* temp=new tree(i,j,s[i],s[j],0,0);\\n        \\n        int m=(i+j)/2;\\n        temp->left=build(s,i,m);\\n        temp->right=build(s,m+1,j);\\n        \\n       \\n        if(temp->left->ced==temp->right->cst)\\n        {\\n            temp->ans=max(max(temp->left->ans,temp->right->ans),temp->left->sl+temp->right->pl);\\n            \\n            if(temp->left->sl==temp->left->ed-temp->left->st+1 && temp->right->pl==temp->right->ed-temp->right->st+1)\\n            {\\n                temp->pl=j-i+1;\\n                temp->sl=j-i+1;\\n            }\\n            else if(temp->left->sl==temp->left->ed-temp->left->st+1)\\n            {\\n                temp->pl=temp->left->sl+temp->right->pl;\\n                temp->sl=temp->right->sl;\\n                \\n            }\\n            else if(temp->right->pl==temp->right->ed-temp->right->st+1)\\n            {\\n                temp->pl=temp->left->pl;\\n                temp->sl=temp->right->pl+temp->left->sl;\\n            }\\n            else\\n            {\\n                temp->sl=temp->right->sl;\\n                temp->pl=temp->left->pl;\\n            }\\n        }\\n        else\\n        {\\n            temp->ans=max(temp->left->ans,temp->right->ans);\\n            temp->pl=temp->left->pl;\\n            temp->sl=temp->right->sl;\\n        }\\n          \\n        return temp;\\n            \\n    }\\n    tree* update(tree* root ,char c,int t)\\n    {\\n        if(!root)\\n            return NULL;\\n        if(t<root->st || t>root->ed)\\n            return root;\\n        \\n        if(t==root->st && root->st==root->ed)\\n        {\\n            root->cst=c;\\n            root->ced=c;\\n            return root;\\n        }\\n        else\\n        {\\n            root->left=update(root->left,c,t);\\n            root->right=update(root->right,c,t);\\n            root->ced=root->right->ced;\\n            root->cst=root->left->cst;\\n            if(root->left->ced==root->right->cst)\\n            {\\n            root->ans=max(max(root->left->ans,root->right->ans),root->left->sl+root->right->pl);\\n            \\n                \\n            if(root->left->sl==root->left->ed-root->left->st+1 && root->right->pl==root->right->ed-root->right->st+1)\\n            {\\n                \\n                root->pl=root->right->ed-root->left->st+1;\\n                root->sl=root->right->ed-root->left->st+1;\\n            }\\n            else if(root->left->sl==root->left->ed-root->left->st+1)\\n            {\\n                root->pl=root->left->sl+root->right->pl;\\n                root->sl=root->right->sl;\\n                \\n            }\\n            else if(root->right->pl==root->right->ed-root->right->st+1)\\n            {\\n                root->pl=root->left->pl;\\n                root->sl=root->right->pl+root->left->sl;\\n            }\\n            else\\n            {\\n                root->sl=root->right->sl;\\n                root->pl=root->left->pl;\\n            }\\n        }\\n        else\\n        {\\n            root->ans=max(root->left->ans,root->right->ans);\\n            root->pl=root->left->pl;\\n            root->sl=root->right->sl;\\n        }\\n          \\n        return root;\\n            \\n        }\\n    }\\n    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {\\n        \\n        int n=s.length();\\n        \\n        tree* root=build(s,0,n-1);\\n        vector<int>ans;\\n        \\n        int m=qi.size();\\n        for(int i=0;i<m;i++)\\n        {\\n            \\n            root=update(root,qc[i],qi[i]);\\n            ans.push_back(root->ans);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    class tree\\n    {\\n        public:\\n        int st; // start index of substring\\n        int ed; //end index  of substring\\n        char cst; // start character of sustring\\n        char ced; // end character of substring\\n        tree* left;\\n        tree* right;\\n        int pl;  // lenght of longest prifix with one reapiting character\\n        int sl;  //  lenght of longest suffix with one reapiting character\\n        int ans;  \\n        tree(int st,int ed,char cst,char ced,int pl,int sl):st(st),ed(ed),cst(cst),ced(ced),pl(pl),sl(sl),left(NULL),right(NULL),ans(1)\\n        {\\n            \\n        }\\n        \\n        \\n        \\n        \\n    };\\n    tree* build(string &s,int i,int j)\\n    {\\n        if(i>j)\\n            return NULL;\\n        if(i==j)\\n            return new tree(i,j,s[i],s[j],1,1);\\n        \\n        tree* temp=new tree(i,j,s[i],s[j],0,0);\\n        \\n        int m=(i+j)/2;\\n        temp->left=build(s,i,m);\\n        temp->right=build(s,m+1,j);\\n        \\n       \\n        if(temp->left->ced==temp->right->cst)\\n        {\\n            temp->ans=max(max(temp->left->ans,temp->right->ans),temp->left->sl+temp->right->pl);\\n            \\n            if(temp->left->sl==temp->left->ed-temp->left->st+1 && temp->right->pl==temp->right->ed-temp->right->st+1)\\n            {\\n                temp->pl=j-i+1;\\n                temp->sl=j-i+1;\\n            }\\n            else if(temp->left->sl==temp->left->ed-temp->left->st+1)\\n            {\\n                temp->pl=temp->left->sl+temp->right->pl;\\n                temp->sl=temp->right->sl;\\n                \\n            }\\n            else if(temp->right->pl==temp->right->ed-temp->right->st+1)\\n            {\\n                temp->pl=temp->left->pl;\\n                temp->sl=temp->right->pl+temp->left->sl;\\n            }\\n            else\\n            {\\n                temp->sl=temp->right->sl;\\n                temp->pl=temp->left->pl;\\n            }\\n        }\\n        else\\n        {\\n            temp->ans=max(temp->left->ans,temp->right->ans);\\n            temp->pl=temp->left->pl;\\n            temp->sl=temp->right->sl;\\n        }\\n          \\n        return temp;\\n            \\n    }\\n    tree* update(tree* root ,char c,int t)\\n    {\\n        if(!root)\\n            return NULL;\\n        if(t<root->st || t>root->ed)\\n            return root;\\n        \\n        if(t==root->st && root->st==root->ed)\\n        {\\n            root->cst=c;\\n            root->ced=c;\\n            return root;\\n        }\\n        else\\n        {\\n            root->left=update(root->left,c,t);\\n            root->right=update(root->right,c,t);\\n            root->ced=root->right->ced;\\n            root->cst=root->left->cst;\\n            if(root->left->ced==root->right->cst)\\n            {\\n            root->ans=max(max(root->left->ans,root->right->ans),root->left->sl+root->right->pl);\\n            \\n                \\n            if(root->left->sl==root->left->ed-root->left->st+1 && root->right->pl==root->right->ed-root->right->st+1)\\n            {\\n                \\n                root->pl=root->right->ed-root->left->st+1;\\n                root->sl=root->right->ed-root->left->st+1;\\n            }\\n            else if(root->left->sl==root->left->ed-root->left->st+1)\\n            {\\n                root->pl=root->left->sl+root->right->pl;\\n                root->sl=root->right->sl;\\n                \\n            }\\n            else if(root->right->pl==root->right->ed-root->right->st+1)\\n            {\\n                root->pl=root->left->pl;\\n                root->sl=root->right->pl+root->left->sl;\\n            }\\n            else\\n            {\\n                root->sl=root->right->sl;\\n                root->pl=root->left->pl;\\n            }\\n        }\\n        else\\n        {\\n            root->ans=max(root->left->ans,root->right->ans);\\n            root->pl=root->left->pl;\\n            root->sl=root->right->sl;\\n        }\\n          \\n        return root;\\n            \\n        }\\n    }\\n    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {\\n        \\n        int n=s.length();\\n        \\n        tree* root=build(s,0,n-1);\\n        vector<int>ans;\\n        \\n        int m=qi.size();\\n        for(int i=0;i<m;i++)\\n        {\\n            \\n            root=update(root,qc[i],qi[i]);\\n            ans.push_back(root->ans);\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883814,
                "title": "an-implementation-of-the-zkw-segment-tree",
                "content": "Here I have implemented the [zkw segment tree](https://topic.alibabacloud.com/a/zkw-segment-tree-template-summary_8_8_10243967.html), hope it can be helpful! The zkw segment tree is an implementation of the segment tree that has the feature as **bottom-up**, **usually smaller run-time than ordinary segment tree**, **easy to implement**.\\n\\n```\\nclass SegmentTree {\\npublic:\\n    vector<int> rtree,ltree,tree,L,R;\\n    string data;\\n    int m{1};\\n    SegmentTree(string s): data{s}{\\n        int n=data.size();\\n        while(m<=n){\\n            m<<=1;\\n        }\\n        tree.assign(m<<1|1,0);\\n        rtree.assign(m<<1|1,0);\\n        ltree.assign(m<<1|1,0);\\n        L.assign(m<<1|1,0);\\n        R.assign(m<<1|1,0);\\n        for(int idx=m+1;idx<=m+n;idx++){\\n            tree[idx]=1;\\n            rtree[idx]=1;\\n            ltree[idx]=1;\\n            L[idx]=idx-m-1;\\n            R[idx]=idx-m-1;\\n        }\\n        for(int idx=m-1;idx;idx--){\\n            maintain(idx);\\n            L[idx]=L[lc(idx)];\\n            R[idx]=R[rc(idx)];\\n        }\\n    }\\n    \\n    inline int lc(int idx){\\n        return idx<<1;\\n    }\\n    inline int rc(int idx){\\n        return idx<<1|1;\\n    }\\n    \\n    void update(int pos, char c){\\n        data[pos]=c;\\n        pos+=m+1;\\n        pos>>=1;\\n        while(pos){\\n            maintain(pos);\\n            pos>>=1;\\n        }\\n    }\\n    \\n    void maintain(int idx){\\n        if(data[R[lc(idx)]]!=data[L[rc(idx)]]){\\n            tree[idx]=max(tree[lc(idx)],tree[rc(idx)]);\\n            ltree[idx]=ltree[lc(idx)];\\n            rtree[idx]=rtree[rc(idx)];\\n        }\\n        else{\\n            tree[idx]=max({tree[lc(idx)],tree[rc(idx)],rtree[lc(idx)]+ltree[rc(idx)]});\\n            if(ltree[lc(idx)]==R[lc(idx)]-L[lc(idx)]+1){\\n                ltree[idx]=ltree[lc(idx)]+ltree[rc(idx)];\\n            }\\n            else{\\n                ltree[idx]=ltree[lc(idx)];\\n            }\\n            if(rtree[rc(idx)]==R[rc(idx)]-L[rc(idx)]+1){\\n                rtree[idx]=rtree[rc(idx)]+rtree[lc(idx)];\\n            }\\n            else{\\n                rtree[idx]=rtree[rc(idx)];\\n            }\\n        }\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        auto st=SegmentTree(s);\\n        vector<int> res;\\n        for(int i=0;i<queryCharacters.size();i++){\\n            st.update(queryIndices[i],queryCharacters[i]);\\n            res.push_back(st.tree[1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass SegmentTree {\\npublic:\\n    vector<int> rtree,ltree,tree,L,R;\\n    string data;\\n    int m{1};\\n    SegmentTree(string s): data{s}{\\n        int n=data.size();\\n        while(m<=n){\\n            m<<=1;\\n        }\\n        tree.assign(m<<1|1,0);\\n        rtree.assign(m<<1|1,0);\\n        ltree.assign(m<<1|1,0);\\n        L.assign(m<<1|1,0);\\n        R.assign(m<<1|1,0);\\n        for(int idx=m+1;idx<=m+n;idx++){\\n            tree[idx]=1;\\n            rtree[idx]=1;\\n            ltree[idx]=1;\\n            L[idx]=idx-m-1;\\n            R[idx]=idx-m-1;\\n        }\\n        for(int idx=m-1;idx;idx--){\\n            maintain(idx);\\n            L[idx]=L[lc(idx)];\\n            R[idx]=R[rc(idx)];\\n        }\\n    }\\n    \\n    inline int lc(int idx){\\n        return idx<<1;\\n    }\\n    inline int rc(int idx){\\n        return idx<<1|1;\\n    }\\n    \\n    void update(int pos, char c){\\n        data[pos]=c;\\n        pos+=m+1;\\n        pos>>=1;\\n        while(pos){\\n            maintain(pos);\\n            pos>>=1;\\n        }\\n    }\\n    \\n    void maintain(int idx){\\n        if(data[R[lc(idx)]]!=data[L[rc(idx)]]){\\n            tree[idx]=max(tree[lc(idx)],tree[rc(idx)]);\\n            ltree[idx]=ltree[lc(idx)];\\n            rtree[idx]=rtree[rc(idx)];\\n        }\\n        else{\\n            tree[idx]=max({tree[lc(idx)],tree[rc(idx)],rtree[lc(idx)]+ltree[rc(idx)]});\\n            if(ltree[lc(idx)]==R[lc(idx)]-L[lc(idx)]+1){\\n                ltree[idx]=ltree[lc(idx)]+ltree[rc(idx)];\\n            }\\n            else{\\n                ltree[idx]=ltree[lc(idx)];\\n            }\\n            if(rtree[rc(idx)]==R[rc(idx)]-L[rc(idx)]+1){\\n                rtree[idx]=rtree[rc(idx)]+rtree[lc(idx)];\\n            }\\n            else{\\n                rtree[idx]=rtree[rc(idx)];\\n            }\\n        }\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n        auto st=SegmentTree(s);\\n        vector<int> res;\\n        for(int i=0;i<queryCharacters.size();i++){\\n            st.update(queryIndices[i],queryCharacters[i]);\\n            res.push_back(st.tree[1]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883265,
                "title": "brute-force-with-kadane-s-algo-python-3-43-57-cases-pass-also-need-soln-to-bug-explained-in-it",
                "content": "I have used the following code in Pyhton 3, mix of brute force and Kadane\\'s algo.\\nAll the code is going okay and passed 43/57 test cases\\n\\nBut I found there is one problem in the code on debugging the code:\\nIt is not updating the last queryCharacter in the Original String although it is looping thruogh the whole lenght of queryCharacter\\n\\n\\nThe code is:::::::::\\n```\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        ans_arr=[]\\n        for i in range(len(queryIndices)):\\n            new = queryCharacters[i]\\n            ind = queryIndices[i]\\n            \\n            s = s[0:ind]+new+s[ind+1:]\\n            #return s\\n            msf = 0\\n            meh = 0\\n            \\n            for j in range(len(s)-1):\\n                if s[j]==s[j+1]:\\n                    meh += 1\\n                else:\\n                    msf = max(msf,meh)\\n                    meh = 0\\n            ans_arr.append(msf+1)\\n\\n        \\n        return ans_arr\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        ans_arr=[]\\n        for i in range(len(queryIndices)):\\n            new = queryCharacters[i]\\n            ind = queryIndices[i]\\n            \\n            s = s[0:ind]+new+s[ind+1:]\\n            #return s\\n            msf = 0\\n            meh = 0\\n            \\n            for j in range(len(s)-1):\\n                if s[j]==s[j+1]:\\n                    meh += 1\\n                else:\\n                    msf = max(msf,meh)\\n                    meh = 0\\n            ans_arr.append(msf+1)\\n\\n        \\n        return ans_arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1878885,
                "title": "c-using-2-bsts-lengthy-and-cumbersome-solution-however",
                "content": "Putting it here in case it is useful but I would recommend looking at other solutions since they seem cleaner than mine.\\n```\\nclass Solution {\\npublic:\\n  // Find parent using binary search\\n  int getParent(int idx, map<int, int>& parentToLen) {\\n    auto parentIt = parentToLen.lower_bound(idx);\\n    if (parentIt != parentToLen.end() && parentIt->first == idx) {\\n      return idx;\\n    } else {\\n      return (--parentIt)->first;\\n    }\\n  }\\n  \\n  vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n    int n = s.size();\\n    int numQueries = queryCharacters.size();\\n    \\n    // The previous character\\n    char prev = \\'\\\\0\\';\\n    int parentIdx = -1;\\n    \\n    // Stores the mapping of parent to the patch of repeating characters\\n    map<int, int> parentToLen;\\n    // Stores the mapping of lengths to the number of parents with that length\\n    map<int, int> lenToNumParents;\\n    \\n    // Populate parentToLen\\n    for (int i = 0; i < n; ++i) {\\n      char c = s[i];\\n      if (prev) {\\n        if (c == prev) {\\n          parentToLen[parentIdx]++;\\n        } else {\\n          parentIdx = i;\\n          parentToLen[i] = 1;\\n        }\\n      } else {\\n        parentIdx = i;\\n        parentToLen[i] = 1;\\n      }\\n      prev = c;\\n    }\\n    // Populate lenToNumParents\\n    for (auto it = parentToLen.begin(); it != parentToLen.end(); ++it) {\\n      lenToNumParents[it->second]++;\\n    }\\n    \\n    vector<int> result;\\n    for (int q = 0; q < numQueries; ++q) {\\n      char qC = queryCharacters[q];\\n      int qI = queryIndices[q];\\n      char original = s[qI];\\n      \\n      // Just re-use the old result if qC is the same as the original char\\n      if (qC == original) {\\n        if (!result.empty()) {\\n          result.push_back(result.back());\\n        } else {\\n          result.push_back(lenToNumParents.rbegin()->first);\\n        }\\n        continue;\\n      }\\n      \\n      // Information about the char on the left (if any)\\n      char left = \\'\\\\0\\';\\n      int leftParent = -1;\\n      int leftParentLen = -1;\\n      if (qI > 0) {\\n        left = s[qI - 1];\\n        leftParent = getParent(qI - 1, parentToLen);\\n        leftParentLen = parentToLen[leftParent];\\n      }\\n      \\n      // Information about the char on the right (if any)\\n      char right = \\'\\\\0\\';\\n      int rightParent = -1;\\n      int rightParentLen = -1;\\n      if (qI < (n - 1)) {\\n        right = s[qI + 1];\\n        rightParent = getParent(qI + 1, parentToLen);\\n        rightParentLen = parentToLen[rightParent];\\n      }\\n      \\n      if (left && right && left == qC && qC == right) {\\n        // Bridging two patches\\n        lenToNumParents[parentToLen[leftParent]]--;\\n        parentToLen[leftParent] += (1 + rightParentLen);\\n        lenToNumParents[parentToLen[leftParent]]++;\\n        \\n        lenToNumParents[parentToLen[rightParent]]--;\\n        lenToNumParents[parentToLen[qI]]--;\\n        parentToLen.erase(rightParent);\\n        parentToLen.erase(qI);\\n      } else if (left && right && left == original && original == right) {\\n        // Breaking up a patch\\n        lenToNumParents[parentToLen[leftParent]]--;\\n        lenToNumParents[parentToLen[qI + 1]]--;\\n        lenToNumParents[parentToLen[qI]]--;\\n        parentToLen[qI + 1] = leftParent + leftParentLen - qI - 1;\\n        parentToLen[leftParent] = qI - leftParent;\\n        parentToLen[qI] = 1;\\n        lenToNumParents[parentToLen[leftParent]]++;\\n        lenToNumParents[parentToLen[qI + 1]]++;\\n        lenToNumParents[parentToLen[qI]]++;\\n      } else {\\n        if (left && left == qC) {\\n          // Forming left edge of patch\\n          lenToNumParents[parentToLen[leftParent]]--;\\n          parentToLen[leftParent]++;\\n          lenToNumParents[parentToLen[leftParent]]++;\\n          lenToNumParents[parentToLen[qI]]--;\\n          parentToLen.erase(qI);\\n        } else if (left && left == original) {\\n          // Breaking left edge of patch\\n          lenToNumParents[parentToLen[leftParent]]--;\\n          parentToLen[leftParent]--;\\n          lenToNumParents[parentToLen[leftParent]]++;\\n        }\\n        if (right && qC == right) {\\n          // Forming right edge of patch\\n          lenToNumParents[parentToLen[qI]]--;\\n          parentToLen[qI] = 1 + rightParentLen;\\n          lenToNumParents[parentToLen[qI]]++;\\n          lenToNumParents[parentToLen[rightParent]]--;\\n          parentToLen.erase(rightParent);\\n        } else if (right && original == right) {\\n          // Breaking right edge of patch\\n          lenToNumParents[parentToLen[qI + 1]]--;\\n          parentToLen[qI + 1] = rightParentLen - 1;\\n          lenToNumParents[parentToLen[qI + 1]]++;\\n          lenToNumParents[parentToLen[rightParent]]--;\\n          parentToLen.erase(rightParent);\\n        }\\n        if (left != qC && qC != right) {\\n          // Just a single character change\\n          lenToNumParents[parentToLen[qI]]--;\\n          parentToLen[qI] = 1;\\n          lenToNumParents[parentToLen[qI]]++;\\n        }\\n      }\\n      \\n      vector<int> lensToErase;\\n      for (auto it = lenToNumParents.rbegin(); it != lenToNumParents.rend(); ++it) {\\n        if (it->second == 0) {\\n          lensToErase.push_back(it->first);\\n        }\\n        if (it->second > 0) {\\n          result.push_back(it->first);\\n          break;\\n        }\\n      }\\n      \\n      // Remove lens otherwise they clutter the map\\n      for (int len: lensToErase) {\\n        lenToNumParents.erase(len);\\n      }\\n      \\n      // Update the string\\n      s[qI] = qC;\\n    }\\n\\n    return result;\\n  }\\n\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  // Find parent using binary search\\n  int getParent(int idx, map<int, int>& parentToLen) {\\n    auto parentIt = parentToLen.lower_bound(idx);\\n    if (parentIt != parentToLen.end() && parentIt->first == idx) {\\n      return idx;\\n    } else {\\n      return (--parentIt)->first;\\n    }\\n  }\\n  \\n  vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n    int n = s.size();\\n    int numQueries = queryCharacters.size();\\n    \\n    // The previous character\\n    char prev = \\'\\\\0\\';\\n    int parentIdx = -1;\\n    \\n    // Stores the mapping of parent to the patch of repeating characters\\n    map<int, int> parentToLen;\\n    // Stores the mapping of lengths to the number of parents with that length\\n    map<int, int> lenToNumParents;\\n    \\n    // Populate parentToLen\\n    for (int i = 0; i < n; ++i) {\\n      char c = s[i];\\n      if (prev) {\\n        if (c == prev) {\\n          parentToLen[parentIdx]++;\\n        } else {\\n          parentIdx = i;\\n          parentToLen[i] = 1;\\n        }\\n      } else {\\n        parentIdx = i;\\n        parentToLen[i] = 1;\\n      }\\n      prev = c;\\n    }\\n    // Populate lenToNumParents\\n    for (auto it = parentToLen.begin(); it != parentToLen.end(); ++it) {\\n      lenToNumParents[it->second]++;\\n    }\\n    \\n    vector<int> result;\\n    for (int q = 0; q < numQueries; ++q) {\\n      char qC = queryCharacters[q];\\n      int qI = queryIndices[q];\\n      char original = s[qI];\\n      \\n      // Just re-use the old result if qC is the same as the original char\\n      if (qC == original) {\\n        if (!result.empty()) {\\n          result.push_back(result.back());\\n        } else {\\n          result.push_back(lenToNumParents.rbegin()->first);\\n        }\\n        continue;\\n      }\\n      \\n      // Information about the char on the left (if any)\\n      char left = \\'\\\\0\\';\\n      int leftParent = -1;\\n      int leftParentLen = -1;\\n      if (qI > 0) {\\n        left = s[qI - 1];\\n        leftParent = getParent(qI - 1, parentToLen);\\n        leftParentLen = parentToLen[leftParent];\\n      }\\n      \\n      // Information about the char on the right (if any)\\n      char right = \\'\\\\0\\';\\n      int rightParent = -1;\\n      int rightParentLen = -1;\\n      if (qI < (n - 1)) {\\n        right = s[qI + 1];\\n        rightParent = getParent(qI + 1, parentToLen);\\n        rightParentLen = parentToLen[rightParent];\\n      }\\n      \\n      if (left && right && left == qC && qC == right) {\\n        // Bridging two patches\\n        lenToNumParents[parentToLen[leftParent]]--;\\n        parentToLen[leftParent] += (1 + rightParentLen);\\n        lenToNumParents[parentToLen[leftParent]]++;\\n        \\n        lenToNumParents[parentToLen[rightParent]]--;\\n        lenToNumParents[parentToLen[qI]]--;\\n        parentToLen.erase(rightParent);\\n        parentToLen.erase(qI);\\n      } else if (left && right && left == original && original == right) {\\n        // Breaking up a patch\\n        lenToNumParents[parentToLen[leftParent]]--;\\n        lenToNumParents[parentToLen[qI + 1]]--;\\n        lenToNumParents[parentToLen[qI]]--;\\n        parentToLen[qI + 1] = leftParent + leftParentLen - qI - 1;\\n        parentToLen[leftParent] = qI - leftParent;\\n        parentToLen[qI] = 1;\\n        lenToNumParents[parentToLen[leftParent]]++;\\n        lenToNumParents[parentToLen[qI + 1]]++;\\n        lenToNumParents[parentToLen[qI]]++;\\n      } else {\\n        if (left && left == qC) {\\n          // Forming left edge of patch\\n          lenToNumParents[parentToLen[leftParent]]--;\\n          parentToLen[leftParent]++;\\n          lenToNumParents[parentToLen[leftParent]]++;\\n          lenToNumParents[parentToLen[qI]]--;\\n          parentToLen.erase(qI);\\n        } else if (left && left == original) {\\n          // Breaking left edge of patch\\n          lenToNumParents[parentToLen[leftParent]]--;\\n          parentToLen[leftParent]--;\\n          lenToNumParents[parentToLen[leftParent]]++;\\n        }\\n        if (right && qC == right) {\\n          // Forming right edge of patch\\n          lenToNumParents[parentToLen[qI]]--;\\n          parentToLen[qI] = 1 + rightParentLen;\\n          lenToNumParents[parentToLen[qI]]++;\\n          lenToNumParents[parentToLen[rightParent]]--;\\n          parentToLen.erase(rightParent);\\n        } else if (right && original == right) {\\n          // Breaking right edge of patch\\n          lenToNumParents[parentToLen[qI + 1]]--;\\n          parentToLen[qI + 1] = rightParentLen - 1;\\n          lenToNumParents[parentToLen[qI + 1]]++;\\n          lenToNumParents[parentToLen[rightParent]]--;\\n          parentToLen.erase(rightParent);\\n        }\\n        if (left != qC && qC != right) {\\n          // Just a single character change\\n          lenToNumParents[parentToLen[qI]]--;\\n          parentToLen[qI] = 1;\\n          lenToNumParents[parentToLen[qI]]++;\\n        }\\n      }\\n      \\n      vector<int> lensToErase;\\n      for (auto it = lenToNumParents.rbegin(); it != lenToNumParents.rend(); ++it) {\\n        if (it->second == 0) {\\n          lensToErase.push_back(it->first);\\n        }\\n        if (it->second > 0) {\\n          result.push_back(it->first);\\n          break;\\n        }\\n      }\\n      \\n      // Remove lens otherwise they clutter the map\\n      for (int len: lensToErase) {\\n        lenToNumParents.erase(len);\\n      }\\n      \\n      // Update the string\\n      s[qI] = qC;\\n    }\\n\\n    return result;\\n  }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1876738,
                "title": "c-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {\\n        int n = s.size();\\n        int k = qc.size();\\n        vector<set<pair<int, int>>> where(26);\\n        multiset<int> st;\\n        for (int i = 0; i < n;) {\\n            int j = i;\\n            while (j < n && s[i] == s[j]) ++j;\\n            where[s[i] - \\'a\\'].insert(make_pair(i, j - 1));\\n            st.insert(j - i);\\n            i = j;\\n        }\\n        auto add = [&] (int pos, int in) {\\n            int l = in;\\n            int r = in;\\n            auto it = where[pos].lower_bound({in, in});\\n            auto it1 = it;\\n            if (it != where[pos].begin()) {\\n                it1 = prev(it);\\n            }\\n            if (it != it1 && it != where[pos].end()) {\\n                if (it1->second == l - 1 && it->first == r + 1) {\\n                    l = it1->first;\\n                    r = it->second;\\n                    st.erase(st.lower_bound(it->second - it->first + 1));\\n                    st.erase(st.lower_bound(it1->second - it1->first + 1));\\n                    where[pos].erase(it);\\n                    where[pos].erase(it1);\\n                    st.insert(r - l + 1);\\n                    where[pos].insert({l, r});\\n                    return;\\n                }\\n            }\\n            if (it != where[pos].end()) {\\n                if (it->first == r + 1) {\\n                    r = it->second;\\n                    st.erase(st.lower_bound(it->second - it->first + 1));\\n                    where[pos].erase(it);\\n                    where[pos].insert({l, r});\\n                    st.insert(r - l + 1);\\n                    return;\\n                }\\n            }\\n            if (it != it1) {\\n                if (it1->second == l - 1) {\\n                    l = it1->first;\\n                    st.erase(st.lower_bound(it1->second - it1->first + 1));\\n                    where[pos].erase(it1);\\n                    where[pos].insert({l, r});\\n                    st.insert(r - l + 1);\\n                    return;\\n                }\\n            }\\n            st.insert(r - l + 1);\\n            where[pos].insert({l, r});\\n        };\\n        auto remove = [&] (int pos, int in) {\\n            auto it = where[pos].lower_bound({in, in});\\n            auto it1 = it;\\n            if (it != where[pos].begin()) {\\n                it1 = prev(it);\\n            }\\n            if (it != where[pos].end() && in >= it->first && in <= it->second) {\\n                int l = it->first;\\n                int r = it->second;\\n                st.erase(st.lower_bound(it->second - it->first + 1));\\n                where[pos].erase(it);\\n                if (l <= in - 1) {\\n                    where[pos].insert({l, in - 1});\\n                    st.insert(in - 1 - l + 1);\\n                }\\n                if (in + 1 <= r) {\\n                    where[pos].insert({in + 1, r});\\n                    st.insert(r - in - 1 + 1);\\n                }\\n                return;\\n            }\\n            if (in >= it1->first && in <= it1->second) {\\n                int l = it1->first;\\n                int r = it1->second;\\n                st.erase(st.lower_bound(it1->second - it1->first + 1));\\n                where[pos].erase(it1);\\n                if (l <= in - 1) {\\n                    where[pos].insert({l, in - 1});\\n                    st.insert(in - 1 - l + 1);\\n                }\\n                if (in + 1 <= r) {\\n                    where[pos].insert({in + 1, r});\\n                    st.insert(r - in - 1 + 1);\\n                }\\n            }\\n        };\\n        vector<int> sol(k);\\n        for (int i = 0; i < k; i++) {\\n            int in = qi[i];\\n            int pos = s[in] - \\'a\\';\\n            s[in] = qc[i];\\n            remove(pos, in);\\n            pos = qc[i] - \\'a\\';\\n            add(pos, in);\\n            sol[i] = *prev(st.end());\\n            \\n            \\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string s, string qc, vector<int>& qi) {\\n        int n = s.size();\\n        int k = qc.size();\\n        vector<set<pair<int, int>>> where(26);\\n        multiset<int> st;\\n        for (int i = 0; i < n;) {\\n            int j = i;\\n            while (j < n && s[i] == s[j]) ++j;\\n            where[s[i] - \\'a\\'].insert(make_pair(i, j - 1));\\n            st.insert(j - i);\\n            i = j;\\n        }\\n        auto add = [&] (int pos, int in) {\\n            int l = in;\\n            int r = in;\\n            auto it = where[pos].lower_bound({in, in});\\n            auto it1 = it;\\n            if (it != where[pos].begin()) {\\n                it1 = prev(it);\\n            }\\n            if (it != it1 && it != where[pos].end()) {\\n                if (it1->second == l - 1 && it->first == r + 1) {\\n                    l = it1->first;\\n                    r = it->second;\\n                    st.erase(st.lower_bound(it->second - it->first + 1));\\n                    st.erase(st.lower_bound(it1->second - it1->first + 1));\\n                    where[pos].erase(it);\\n                    where[pos].erase(it1);\\n                    st.insert(r - l + 1);\\n                    where[pos].insert({l, r});\\n                    return;\\n                }\\n            }\\n            if (it != where[pos].end()) {\\n                if (it->first == r + 1) {\\n                    r = it->second;\\n                    st.erase(st.lower_bound(it->second - it->first + 1));\\n                    where[pos].erase(it);\\n                    where[pos].insert({l, r});\\n                    st.insert(r - l + 1);\\n                    return;\\n                }\\n            }\\n            if (it != it1) {\\n                if (it1->second == l - 1) {\\n                    l = it1->first;\\n                    st.erase(st.lower_bound(it1->second - it1->first + 1));\\n                    where[pos].erase(it1);\\n                    where[pos].insert({l, r});\\n                    st.insert(r - l + 1);\\n                    return;\\n                }\\n            }\\n            st.insert(r - l + 1);\\n            where[pos].insert({l, r});\\n        };\\n        auto remove = [&] (int pos, int in) {\\n            auto it = where[pos].lower_bound({in, in});\\n            auto it1 = it;\\n            if (it != where[pos].begin()) {\\n                it1 = prev(it);\\n            }\\n            if (it != where[pos].end() && in >= it->first && in <= it->second) {\\n                int l = it->first;\\n                int r = it->second;\\n                st.erase(st.lower_bound(it->second - it->first + 1));\\n                where[pos].erase(it);\\n                if (l <= in - 1) {\\n                    where[pos].insert({l, in - 1});\\n                    st.insert(in - 1 - l + 1);\\n                }\\n                if (in + 1 <= r) {\\n                    where[pos].insert({in + 1, r});\\n                    st.insert(r - in - 1 + 1);\\n                }\\n                return;\\n            }\\n            if (in >= it1->first && in <= it1->second) {\\n                int l = it1->first;\\n                int r = it1->second;\\n                st.erase(st.lower_bound(it1->second - it1->first + 1));\\n                where[pos].erase(it1);\\n                if (l <= in - 1) {\\n                    where[pos].insert({l, in - 1});\\n                    st.insert(in - 1 - l + 1);\\n                }\\n                if (in + 1 <= r) {\\n                    where[pos].insert({in + 1, r});\\n                    st.insert(r - in - 1 + 1);\\n                }\\n            }\\n        };\\n        vector<int> sol(k);\\n        for (int i = 0; i < k; i++) {\\n            int in = qi[i];\\n            int pos = s[in] - \\'a\\';\\n            s[in] = qc[i];\\n            remove(pos, in);\\n            pos = qc[i] - \\'a\\';\\n            add(pos, in);\\n            sol[i] = *prev(st.end());\\n            \\n            \\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1875106,
                "title": "java-segment-tree",
                "content": "Thanks to @rishabhrawat192 !\\nhttps://leetcode.com/problems/longest-substring-of-one-repeating-character/discuss/1866110/Java-clean-Segment-tree-solution\\n\\n```java\\nclass Solution {\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        SegTree tree = new SegTree(s);\\n        int[] res = new int[queryIndices.length];\\n        for (int i = 0; i < queryIndices.length; i += 1) {\\n            tree.update(queryIndices[i], queryCharacters.charAt(i));\\n            res[i] = tree.tree[0].max;\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Node {\\n    int max;\\n    int start, end;\\n    int pref;\\n    int suf;\\n    \\n    Node(int start, int end, int pref, int suf, int max) {\\n        this.max = max;\\n        this.start = start;\\n        this.end = end;\\n        this.pref = pref;\\n        this.suf = suf;\\n    }\\n}\\n\\nclass SegTree {\\n    Node[] tree;\\n    StringBuilder s = new StringBuilder();\\n    SegTree(String s) {\\n        this.s.append(s);\\n        tree = new Node[s.length() * 4];\\n        build(0, s.length() - 1, 0);\\n    }\\n    \\n    private void build(int start, int end, int treeIdx) {\\n        if (start == end) {\\n            tree[treeIdx] = new Node(start, end, start, start, 1);\\n        } else {\\n            int mid = start + (end - start) / 2;\\n            build(start, mid, getLeft(treeIdx));\\n            build(mid + 1, end, getRight(treeIdx));\\n            tree[treeIdx] = merge(tree[getLeft(treeIdx)], tree[getRight(treeIdx)]);\\n        }\\n    }\\n    \\n    private Node merge(Node left, Node right) {\\n        Node res = new Node(left.start, right.end, left.pref, right.suf, \\n                            Math.max(left.max, right.max));\\n        if (s.charAt(left.end) == s.charAt(right.start)) {\\n            res.max = Math.max(res.max, right.pref - left.suf + 1);\\n            if (left.pref == left.end) {\\n                res.pref = right.pref;\\n            }\\n            if (right.suf == right.start) {\\n                res.suf = left.suf;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    // pos: position/index in the string\\n    public void update(int pos, char ch) {\\n        update(0, pos, ch);// start from root\\n    }\\n    \\n    private void update(int treeIdx, int pos, char ch) {\\n        Node cur = tree[treeIdx];\\n        if (cur.start == cur.end) {\\n            s.setCharAt(pos, ch);\\n            return;\\n        }\\n        int mid = cur.start + (cur.end - cur.start) / 2;\\n        if (pos <= mid) {\\n            update(getLeft(treeIdx), pos, ch);\\n        } else {\\n            update(getRight(treeIdx), pos, ch);\\n        }\\n        \\n        tree[treeIdx] = merge(tree[getLeft(treeIdx)], tree[getRight(treeIdx)]);\\n    }\\n    \\n    // get the tree index of the left child\\n    private int getLeft(int idx) {\\n        return idx * 2 + 1;\\n    }\\n    // get the tree index of the right child\\n    private int getRight(int idx) {\\n        return idx * 2 + 2;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        SegTree tree = new SegTree(s);\\n        int[] res = new int[queryIndices.length];\\n        for (int i = 0; i < queryIndices.length; i += 1) {\\n            tree.update(queryIndices[i], queryCharacters.charAt(i));\\n            res[i] = tree.tree[0].max;\\n        }\\n        return res;\\n    }\\n}\\n\\nclass Node {\\n    int max;\\n    int start, end;\\n    int pref;\\n    int suf;\\n    \\n    Node(int start, int end, int pref, int suf, int max) {\\n        this.max = max;\\n        this.start = start;\\n        this.end = end;\\n        this.pref = pref;\\n        this.suf = suf;\\n    }\\n}\\n\\nclass SegTree {\\n    Node[] tree;\\n    StringBuilder s = new StringBuilder();\\n    SegTree(String s) {\\n        this.s.append(s);\\n        tree = new Node[s.length() * 4];\\n        build(0, s.length() - 1, 0);\\n    }\\n    \\n    private void build(int start, int end, int treeIdx) {\\n        if (start == end) {\\n            tree[treeIdx] = new Node(start, end, start, start, 1);\\n        } else {\\n            int mid = start + (end - start) / 2;\\n            build(start, mid, getLeft(treeIdx));\\n            build(mid + 1, end, getRight(treeIdx));\\n            tree[treeIdx] = merge(tree[getLeft(treeIdx)], tree[getRight(treeIdx)]);\\n        }\\n    }\\n    \\n    private Node merge(Node left, Node right) {\\n        Node res = new Node(left.start, right.end, left.pref, right.suf, \\n                            Math.max(left.max, right.max));\\n        if (s.charAt(left.end) == s.charAt(right.start)) {\\n            res.max = Math.max(res.max, right.pref - left.suf + 1);\\n            if (left.pref == left.end) {\\n                res.pref = right.pref;\\n            }\\n            if (right.suf == right.start) {\\n                res.suf = left.suf;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    // pos: position/index in the string\\n    public void update(int pos, char ch) {\\n        update(0, pos, ch);// start from root\\n    }\\n    \\n    private void update(int treeIdx, int pos, char ch) {\\n        Node cur = tree[treeIdx];\\n        if (cur.start == cur.end) {\\n            s.setCharAt(pos, ch);\\n            return;\\n        }\\n        int mid = cur.start + (cur.end - cur.start) / 2;\\n        if (pos <= mid) {\\n            update(getLeft(treeIdx), pos, ch);\\n        } else {\\n            update(getRight(treeIdx), pos, ch);\\n        }\\n        \\n        tree[treeIdx] = merge(tree[getLeft(treeIdx)], tree[getRight(treeIdx)]);\\n    }\\n    \\n    // get the tree index of the left child\\n    private int getLeft(int idx) {\\n        return idx * 2 + 1;\\n    }\\n    // get the tree index of the right child\\n    private int getRight(int idx) {\\n        return idx * 2 + 2;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869138,
                "title": "python-3-sortedlist",
                "content": "Quite lengthy and not fast. The idea is simple, maintain groups of repeating letters. Once a new query, find the impacted group(s), and replace old group(s) with newly formed ones.\\n\\nMultiple situations need to be taken into account, I had them split into the following, but some can be combined.\\n```\\n1) One group aaaaa split into three aa, b, aa\\n\\ts = aaaaa\\n\\tquery = b @ index 3\\n\\tnew s = aabaa\\n2) Left connection, two groups bb, aaa replaced by bbb, aa\\n\\ts =  bbaaa\\n\\tquery = b @ index 3\\n\\tnew s = bbbaa\\n3) Right connection, two groups aaa, bb replaced aa, bbb\\n\\ts =  aaabb\\n\\tquery = b @ index 3\\n\\tnew s = aabbb\\n4) Single char group x\\n\\ta) No connection, one single char group x replaced by one new single char group b\\n\\t\\ts = aaxcc\\n\\t\\tquery = b @ index 3\\n\\t\\tnew s = aabcc\\n\\tb) Left connection, two groups bb, x replaced by one new bbb\\n\\t\\ts = bbxcc\\n\\t\\tquery = b @ index 3\\n\\t\\tnew s = bbbcc\\n\\tc) Right connection, two groups x, bb replaced by one new bbb\\n\\t\\ts = aaxbb\\n\\t\\tquery = b @ index 3\\n\\t\\tnew s = aabbb\\n\\td) Left and right connections, three groups bb, x, bb replaced by one new bbbbb\\n\\t\\ts = bbxbb\\n\\t    query = b\\n\\t\\tnew s = bbbbb\\n```\\n\\nI used two sorted lists, one for (start index, end index, char), the other stores (length, start index, char). They are equivalent but kept for different purposes. First one `q_i` for detecting impact ranges, and second one `q_l` to grab the max length post each query. Further optimization possible.\\n\\n```\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        s += \\'#\\' # a trailing # to handle connection checking across 0 and n - 1\\n        arr = list(s)\\n        \\n        from sortedcontainers import SortedList\\n        q_i = SortedList()\\n        q_l = SortedList()\\n        start = 0\\n        gs = groupby(s)\\n        for g in gs:\\n            l = len(list(g[1]))\\n            q_i.add((start, start + l - 1, g[0]))\\n            q_l.add((l, start, g[0]))\\n            start += l\\n        \\n        def i2l(tp):\\n            le, ri, c = tp\\n            return (ri - le + 1, le, c)\\n        \\n        ans = []\\n        for i, c in zip(queryIndices, queryCharacters):\\n            if c == arr[i]:\\n                ans.append(q_l[-1][0])\\n            else:\\n                key_i = (i, i, c)\\n                x = q_i.bisect_left(key_i)\\n                if x > 0 and i < q_i[x][0]:\\n                    x -= 1\\n                \\n                # impacted group to be removed\\n                le, ri, c_grp = q_i[x]\\n                rmv = [q_i[x]]\\n                \\n                # forming new groups\\n                if le < i < ri:\\n                    new = [(le, i - 1, c_grp), (i, i, c), (i + 1, ri, c_grp)]\\n                else:\\n                    if i == le < ri:\\n                        if c != arr[i - 1]:\\n                            new = [(i, i, c), (i + 1, ri, c_grp)]\\n                        else:\\n                            rmv.append(q_i[x - 1])\\n                            le_prev, ri_prev, c_prev = q_i[x - 1]\\n                            new = [(le_prev, i, c), (i + 1, ri, c_grp)]\\n                    elif le < ri == i:\\n                        if c != arr[i + 1]:\\n                            new = [(le, i - 1, c_grp), (i, i, c)]\\n                        else:\\n                            rmv.append(q_i[x + 1])\\n                            le_next, ri_next, c_next = q_i[x + 1]\\n                            new = [(le, i - 1, c_grp), (i, ri_next, c)]\\n                    else: # le == i == ri\\n                        if arr[i - 1] != c and c != arr[i + 1]:\\n                            new = [(i, i, c)]\\n                        elif arr[i - 1] == c and c != arr[i + 1]:\\n                            rmv.append(q_i[x - 1])\\n                            le_prev, ri_prev, c_prev = q_i[x - 1]\\n                            new = [(le_prev, i, c)]\\n                        elif arr[i - 1] != c and c == arr[i + 1]:\\n                            rmv.append(q_i[x + 1])\\n                            le_next, ri_next, c_next = q_i[x + 1]\\n                            new = [(i, ri_next, c)]\\n                        else: # arr[i - 1] == c == arr[i + 1]:\\n                            rmv.append(q_i[x - 1])\\n                            rmv.append(q_i[x + 1])\\n                            le_prev, ri_prev, c_prev = q_i[x - 1]\\n                            le_next, ri_next, c_next = q_i[x + 1]\\n                            new = [(le_prev, ri_next, c)]\\n                \\n                # update s\\n                arr[i] = c\\n                \\n                # remove broken groups\\n                for g in rmv:\\n                    # index groups\\n                    x = q_i.index(g)\\n                    del q_i[x]\\n                    # length groups\\n                    gl = i2l(g)\\n                    x = q_l.index(gl)\\n                    del q_l[x]\\n                \\n                # add new groups\\n                for g in new:\\n                    # index groups\\n                    q_i.add(g)\\n                    # length groups\\n                    gl = i2l(g)\\n                    q_l.add(gl)\\n                \\n                ans.append(q_l[-1][0])\\n            \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n1) One group aaaaa split into three aa, b, aa\\n\\ts = aaaaa\\n\\tquery = b @ index 3\\n\\tnew s = aabaa\\n2) Left connection, two groups bb, aaa replaced by bbb, aa\\n\\ts =  bbaaa\\n\\tquery = b @ index 3\\n\\tnew s = bbbaa\\n3) Right connection, two groups aaa, bb replaced aa, bbb\\n\\ts =  aaabb\\n\\tquery = b @ index 3\\n\\tnew s = aabbb\\n4) Single char group x\\n\\ta) No connection, one single char group x replaced by one new single char group b\\n\\t\\ts = aaxcc\\n\\t\\tquery = b @ index 3\\n\\t\\tnew s = aabcc\\n\\tb) Left connection, two groups bb, x replaced by one new bbb\\n\\t\\ts = bbxcc\\n\\t\\tquery = b @ index 3\\n\\t\\tnew s = bbbcc\\n\\tc) Right connection, two groups x, bb replaced by one new bbb\\n\\t\\ts = aaxbb\\n\\t\\tquery = b @ index 3\\n\\t\\tnew s = aabbb\\n\\td) Left and right connections, three groups bb, x, bb replaced by one new bbbbb\\n\\t\\ts = bbxbb\\n\\t    query = b\\n\\t\\tnew s = bbbbb\\n```\n```\\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        s += \\'#\\' # a trailing # to handle connection checking across 0 and n - 1\\n        arr = list(s)\\n        \\n        from sortedcontainers import SortedList\\n        q_i = SortedList()\\n        q_l = SortedList()\\n        start = 0\\n        gs = groupby(s)\\n        for g in gs:\\n            l = len(list(g[1]))\\n            q_i.add((start, start + l - 1, g[0]))\\n            q_l.add((l, start, g[0]))\\n            start += l\\n        \\n        def i2l(tp):\\n            le, ri, c = tp\\n            return (ri - le + 1, le, c)\\n        \\n        ans = []\\n        for i, c in zip(queryIndices, queryCharacters):\\n            if c == arr[i]:\\n                ans.append(q_l[-1][0])\\n            else:\\n                key_i = (i, i, c)\\n                x = q_i.bisect_left(key_i)\\n                if x > 0 and i < q_i[x][0]:\\n                    x -= 1\\n                \\n                # impacted group to be removed\\n                le, ri, c_grp = q_i[x]\\n                rmv = [q_i[x]]\\n                \\n                # forming new groups\\n                if le < i < ri:\\n                    new = [(le, i - 1, c_grp), (i, i, c), (i + 1, ri, c_grp)]\\n                else:\\n                    if i == le < ri:\\n                        if c != arr[i - 1]:\\n                            new = [(i, i, c), (i + 1, ri, c_grp)]\\n                        else:\\n                            rmv.append(q_i[x - 1])\\n                            le_prev, ri_prev, c_prev = q_i[x - 1]\\n                            new = [(le_prev, i, c), (i + 1, ri, c_grp)]\\n                    elif le < ri == i:\\n                        if c != arr[i + 1]:\\n                            new = [(le, i - 1, c_grp), (i, i, c)]\\n                        else:\\n                            rmv.append(q_i[x + 1])\\n                            le_next, ri_next, c_next = q_i[x + 1]\\n                            new = [(le, i - 1, c_grp), (i, ri_next, c)]\\n                    else: # le == i == ri\\n                        if arr[i - 1] != c and c != arr[i + 1]:\\n                            new = [(i, i, c)]\\n                        elif arr[i - 1] == c and c != arr[i + 1]:\\n                            rmv.append(q_i[x - 1])\\n                            le_prev, ri_prev, c_prev = q_i[x - 1]\\n                            new = [(le_prev, i, c)]\\n                        elif arr[i - 1] != c and c == arr[i + 1]:\\n                            rmv.append(q_i[x + 1])\\n                            le_next, ri_next, c_next = q_i[x + 1]\\n                            new = [(i, ri_next, c)]\\n                        else: # arr[i - 1] == c == arr[i + 1]:\\n                            rmv.append(q_i[x - 1])\\n                            rmv.append(q_i[x + 1])\\n                            le_prev, ri_prev, c_prev = q_i[x - 1]\\n                            le_next, ri_next, c_next = q_i[x + 1]\\n                            new = [(le_prev, ri_next, c)]\\n                \\n                # update s\\n                arr[i] = c\\n                \\n                # remove broken groups\\n                for g in rmv:\\n                    # index groups\\n                    x = q_i.index(g)\\n                    del q_i[x]\\n                    # length groups\\n                    gl = i2l(g)\\n                    x = q_l.index(gl)\\n                    del q_l[x]\\n                \\n                # add new groups\\n                for g in new:\\n                    # index groups\\n                    q_i.add(g)\\n                    # length groups\\n                    gl = i2l(g)\\n                    q_l.add(gl)\\n                \\n                ans.append(q_l[-1][0])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868664,
                "title": "c-top-down-clean-segment-tree",
                "content": "```cpp\\nstruct SegmentTreeNode {\\n  int lo;\\n  int hi;\\n  char maxChar;\\n  char prefixChar;\\n  char suffixChar;\\n  int maxLength;\\n  int prefixLength;\\n  int suffixLength;\\n  SegmentTreeNode* left;\\n  SegmentTreeNode* right;\\n  SegmentTreeNode(int lo, int hi, char maxChar, char prefixChar,\\n                  char suffixChar, int maxLength, int prefixLength,\\n                  int suffixLength, SegmentTreeNode* left = nullptr,\\n                  SegmentTreeNode* right = nullptr)\\n      : lo(lo),\\n        hi(hi),\\n        maxChar(maxChar),\\n        prefixChar(prefixChar),\\n        suffixChar(suffixChar),\\n        maxLength(maxLength),\\n        prefixLength(prefixLength),\\n        suffixLength(suffixLength),\\n        left(left),\\n        right(right) {}\\n  ~SegmentTreeNode() {\\n    delete left;\\n    delete right;\\n    left = nullptr;\\n    right = nullptr;\\n  }\\n};\\n\\nclass SegmentTree {\\n public:\\n  SegmentTree(const string& s) : root(build(s, 0, s.length() - 1)) {}\\n  ~SegmentTree() {\\n    delete root;\\n  }\\n\\n  void update(int i, char val) {\\n    root = update(root, i, val);\\n  }\\n\\n  int getMaxLength() {\\n    return root->maxLength;\\n  }\\n\\n private:\\n  SegmentTreeNode* root;\\n\\n  SegmentTreeNode* build(const string& s, int lo, int hi) const {\\n    if (lo == hi)\\n      return new SegmentTreeNode(lo, hi, s[lo], s[lo], s[lo], 1, 1, 1);\\n    const int mid = (lo + hi) / 2;\\n    auto left = build(s, lo, mid);\\n    auto right = build(s, mid + 1, hi);\\n    return merge(left, right);\\n  }\\n\\n  SegmentTreeNode* update(SegmentTreeNode* root, int i, char c) {\\n    if (root->lo == i && root->hi == i) {\\n      root->maxChar = c;\\n      root->prefixChar = c;\\n      root->suffixChar = c;\\n      return root;\\n    }\\n    const int mid = (root->lo + root->hi) / 2;\\n    if (i <= mid) {\\n      auto updatedLeft = update(root->left, i, c);\\n      return root = merge(updatedLeft, root->right);\\n    } else {\\n      auto updatedRight = update(root->right, i, c);\\n      return root = merge(root->left, updatedRight);\\n    }\\n  }\\n\\n  SegmentTreeNode* merge(SegmentTreeNode* left, SegmentTreeNode* right) const {\\n    // get maxChar and maxLength\\n    char maxChar = \\' \\';\\n    int maxLength = 0;\\n    if (left->maxLength > right->maxLength) {\\n      maxChar = left->maxChar;\\n      maxLength = left->maxLength;\\n    } else {\\n      maxChar = right->maxChar;\\n      maxLength = right->maxLength;\\n    }\\n    if (left->suffixChar == right->prefixChar &&\\n        left->suffixLength + right->prefixLength > maxLength) {\\n      maxChar = left->suffixChar;\\n      maxLength = left->suffixLength + right->prefixLength;\\n    }\\n\\n    // get prefixChar and prefixLength\\n    char prefixChar = left->prefixChar;\\n    int prefixLength = left->prefixLength;\\n    if (left->lo + prefixLength == right->lo &&\\n        left->prefixChar == right->prefixChar)\\n      prefixLength += right->prefixLength;\\n\\n    // get suffixChar and suffixLength\\n    char suffixChar = right->suffixChar;\\n    int suffixLength = right->suffixLength;\\n    if (right->hi - suffixLength == left->hi &&\\n        right->suffixChar == left->suffixChar)\\n      suffixLength += left->suffixLength;\\n\\n    return new SegmentTreeNode(left->lo, right->hi, maxChar, prefixChar,\\n                               suffixChar, maxLength, prefixLength,\\n                               suffixLength, left, right);\\n  }\\n};\\n\\nclass Solution {\\n public:\\n  vector<int> longestRepeating(string s, string queryCharacters,\\n                               vector<int>& queryIndices) {\\n    vector<int> ans;\\n    SegmentTree tree(s);\\n\\n    for (int i = 0; i < queryIndices.size(); ++i) {\\n      tree.update(queryIndices[i], queryCharacters[i]);\\n      ans.push_back(tree.getMaxLength());\\n    }\\n\\n    return ans;\\n  }\\n};\\n```\\n\\n- Time: O(nlogn)\\n- Space: O(n)",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```cpp\\nstruct SegmentTreeNode {\\n  int lo;\\n  int hi;\\n  char maxChar;\\n  char prefixChar;\\n  char suffixChar;\\n  int maxLength;\\n  int prefixLength;\\n  int suffixLength;\\n  SegmentTreeNode* left;\\n  SegmentTreeNode* right;\\n  SegmentTreeNode(int lo, int hi, char maxChar, char prefixChar,\\n                  char suffixChar, int maxLength, int prefixLength,\\n                  int suffixLength, SegmentTreeNode* left = nullptr,\\n                  SegmentTreeNode* right = nullptr)\\n      : lo(lo),\\n        hi(hi),\\n        maxChar(maxChar),\\n        prefixChar(prefixChar),\\n        suffixChar(suffixChar),\\n        maxLength(maxLength),\\n        prefixLength(prefixLength),\\n        suffixLength(suffixLength),\\n        left(left),\\n        right(right) {}\\n  ~SegmentTreeNode() {\\n    delete left;\\n    delete right;\\n    left = nullptr;\\n    right = nullptr;\\n  }\\n};\\n\\nclass SegmentTree {\\n public:\\n  SegmentTree(const string& s) : root(build(s, 0, s.length() - 1)) {}\\n  ~SegmentTree() {\\n    delete root;\\n  }\\n\\n  void update(int i, char val) {\\n    root = update(root, i, val);\\n  }\\n\\n  int getMaxLength() {\\n    return root->maxLength;\\n  }\\n\\n private:\\n  SegmentTreeNode* root;\\n\\n  SegmentTreeNode* build(const string& s, int lo, int hi) const {\\n    if (lo == hi)\\n      return new SegmentTreeNode(lo, hi, s[lo], s[lo], s[lo], 1, 1, 1);\\n    const int mid = (lo + hi) / 2;\\n    auto left = build(s, lo, mid);\\n    auto right = build(s, mid + 1, hi);\\n    return merge(left, right);\\n  }\\n\\n  SegmentTreeNode* update(SegmentTreeNode* root, int i, char c) {\\n    if (root->lo == i && root->hi == i) {\\n      root->maxChar = c;\\n      root->prefixChar = c;\\n      root->suffixChar = c;\\n      return root;\\n    }\\n    const int mid = (root->lo + root->hi) / 2;\\n    if (i <= mid) {\\n      auto updatedLeft = update(root->left, i, c);\\n      return root = merge(updatedLeft, root->right);\\n    } else {\\n      auto updatedRight = update(root->right, i, c);\\n      return root = merge(root->left, updatedRight);\\n    }\\n  }\\n\\n  SegmentTreeNode* merge(SegmentTreeNode* left, SegmentTreeNode* right) const {\\n    // get maxChar and maxLength\\n    char maxChar = \\' \\';\\n    int maxLength = 0;\\n    if (left->maxLength > right->maxLength) {\\n      maxChar = left->maxChar;\\n      maxLength = left->maxLength;\\n    } else {\\n      maxChar = right->maxChar;\\n      maxLength = right->maxLength;\\n    }\\n    if (left->suffixChar == right->prefixChar &&\\n        left->suffixLength + right->prefixLength > maxLength) {\\n      maxChar = left->suffixChar;\\n      maxLength = left->suffixLength + right->prefixLength;\\n    }\\n\\n    // get prefixChar and prefixLength\\n    char prefixChar = left->prefixChar;\\n    int prefixLength = left->prefixLength;\\n    if (left->lo + prefixLength == right->lo &&\\n        left->prefixChar == right->prefixChar)\\n      prefixLength += right->prefixLength;\\n\\n    // get suffixChar and suffixLength\\n    char suffixChar = right->suffixChar;\\n    int suffixLength = right->suffixLength;\\n    if (right->hi - suffixLength == left->hi &&\\n        right->suffixChar == left->suffixChar)\\n      suffixLength += left->suffixLength;\\n\\n    return new SegmentTreeNode(left->lo, right->hi, maxChar, prefixChar,\\n                               suffixChar, maxLength, prefixLength,\\n                               suffixLength, left, right);\\n  }\\n};\\n\\nclass Solution {\\n public:\\n  vector<int> longestRepeating(string s, string queryCharacters,\\n                               vector<int>& queryIndices) {\\n    vector<int> ans;\\n    SegmentTree tree(s);\\n\\n    for (int i = 0; i < queryIndices.size(); ++i) {\\n      tree.update(queryIndices[i], queryCharacters[i]);\\n      ans.push_back(tree.getMaxLength());\\n    }\\n\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868466,
                "title": "java-segment-tree",
                "content": "The idea is to contruct three segement trees which maintain max length of 1)one-character repeating string from the left of the interval, 2) one-character repeating string from the right of the interval, and 3) one-character repeating string in the interval. The reason for the previous two is that they can be combined into a longer substring if they are using same character.\\n\\nThe major tasks related with segement tree in this case are 1) build, 2) merge, and 3) update.\\nConcrete structure used for segement tree is just an array. The size is usually 4 times the size of the actual string. \\n\\nBuild(`idx, left, right`): It is a recursive call, base case is when left is equal to right, then all three segment tree with index equals to idx is set to 1. In recursive case, (left < right), you have to find the middle point mid, and recursively build two sub segment tree with (`2 * idx, left, mid`) and (`2 * idx + 1, mid + 1, right`). After these two sub segement tree are constructed, you need to merge them. Merge is a very generic term, in different problems, merge can mean different things. \\n\\nMerge(`idx, left, right, mid`): This is not a recursive call. What it does in this case is to derive values for all three segement trees at index idx, based on two sub segement trees with index `2 * idx` and `2 * idx + 1`. This merge operation is needed for every non-base build operation to merge two sub segment trees generated in that build operation. \\n\\nThree things need to be considered in this merge if the characters at the rightmost of left interval and the leftmost of the right interval are the same.\\n* max length of repeating substring starting from left of the left interval may extent to right if its length is the size of left interval\\n* max length of repeating substring starting from right of the right interval may exent to left if its length is the size of right interval\\n* max length of repeating substring in the new combined interval can be updated by the sum of max length of repeating substring from right in left interval and the max length of repeating substring from left in right interval.\\n\\nWith above two, you have all three segement trees. However, we need to update them when the string is changed. This leads to Update operation.\\n\\nUpdate(`idx, left, right, uid`): This recursively call itself to perform a binary search to find the interval where `uid` lies in. Once the smallest interval is find, it reruns Merge operation from bottom up to update information related with the change in the string. \\n\\n```\\nclass Solution {\\n    int max = (int) 1e5 + 1;\\n    int[] sMax = new int[ max * 4];\\n    int[] sLeft = new int[ max * 4];\\n    int[] sRight = new int[ max * 4];\\n    char[] cs;\\n    \\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        cs = s.toCharArray();\\n        build(1, 0, s.length() - 1);\\n        int[] res = new int[queryIndices.length];\\n        for (int i = 0; i < queryIndices.length; i++) {\\n            int cid = queryIndices[i];\\n            cs[cid] = queryCharacters.charAt(i);\\n            update(1, 0, s.length()-1, cid);\\n            res[i] = sMax[1];\\n        }\\n        return res;\\n    }\\n    \\n    private void build(int idx, int left, int right) {\\n        if (left == right) {\\n            sLeft[idx] = 1;\\n            sRight[idx] = 1;\\n            sMax[idx] = 1;\\n            return;\\n        }\\n        int mid = left + (right - left) / 2;\\n        build(idx * 2, left, mid);\\n        build(idx * 2 + 1, mid + 1, right);\\n        merge(idx, left, right, mid);\\n    }\\n    \\n    private void merge(int idx, int left, int right, int mid) {\\n        sLeft[idx] = sLeft[idx * 2];\\n        sRight[idx] = sRight[idx * 2 + 1];\\n        sMax[idx] = Math.max(sMax[idx * 2], sMax[idx * 2 + 1]);\\n        \\n        if (cs[mid] == cs[mid + 1]) {\\n            if (sLeft[idx * 2] == mid - left +1) {\\n                sLeft[idx] += sLeft[2 * idx + 1];\\n            }\\n            if (sRight[idx * 2 + 1] == right - mid) {\\n                sRight[idx] += sRight[2 * idx];\\n            }\\n            sMax[idx] = Math.max(sMax[idx], sLeft[2 * idx + 1] + sRight[2 * idx]);\\n        }\\n    }\\n    \\n    private void update(int idx, int left, int right, int insert) {\\n        if (left == right) {\\n            return;\\n        }\\n        \\n        int mid = left + (right - left) / 2;\\n        if (insert <= mid) {\\n            update(idx * 2, left, mid, insert);\\n        } else {\\n            update(idx * 2 + 1, mid + 1, right, insert);\\n        }\\n        \\n        merge(idx, left, right, mid); \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    int max = (int) 1e5 + 1;\\n    int[] sMax = new int[ max * 4];\\n    int[] sLeft = new int[ max * 4];\\n    int[] sRight = new int[ max * 4];\\n    char[] cs;\\n    \\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        cs = s.toCharArray();\\n        build(1, 0, s.length() - 1);\\n        int[] res = new int[queryIndices.length];\\n        for (int i = 0; i < queryIndices.length; i++) {\\n            int cid = queryIndices[i];\\n            cs[cid] = queryCharacters.charAt(i);\\n            update(1, 0, s.length()-1, cid);\\n            res[i] = sMax[1];\\n        }\\n        return res;\\n    }\\n    \\n    private void build(int idx, int left, int right) {\\n        if (left == right) {\\n            sLeft[idx] = 1;\\n            sRight[idx] = 1;\\n            sMax[idx] = 1;\\n            return;\\n        }\\n        int mid = left + (right - left) / 2;\\n        build(idx * 2, left, mid);\\n        build(idx * 2 + 1, mid + 1, right);\\n        merge(idx, left, right, mid);\\n    }\\n    \\n    private void merge(int idx, int left, int right, int mid) {\\n        sLeft[idx] = sLeft[idx * 2];\\n        sRight[idx] = sRight[idx * 2 + 1];\\n        sMax[idx] = Math.max(sMax[idx * 2], sMax[idx * 2 + 1]);\\n        \\n        if (cs[mid] == cs[mid + 1]) {\\n            if (sLeft[idx * 2] == mid - left +1) {\\n                sLeft[idx] += sLeft[2 * idx + 1];\\n            }\\n            if (sRight[idx * 2 + 1] == right - mid) {\\n                sRight[idx] += sRight[2 * idx];\\n            }\\n            sMax[idx] = Math.max(sMax[idx], sLeft[2 * idx + 1] + sRight[2 * idx]);\\n        }\\n    }\\n    \\n    private void update(int idx, int left, int right, int insert) {\\n        if (left == right) {\\n            return;\\n        }\\n        \\n        int mid = left + (right - left) / 2;\\n        if (insert <= mid) {\\n            update(idx * 2, left, mid, insert);\\n        } else {\\n            update(idx * 2 + 1, mid + 1, right, insert);\\n        }\\n        \\n        merge(idx, left, right, mid); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1868459,
                "title": "python-sorted-intervals-no-treemap",
                "content": "The basic idea is: for each char in s, we maitain a sorted interval for this character. Each query, we need to 1) updated the new character\\'s interval 2) delete one index from the old charater. \\nWhen update the character\\'s interval, there is another \"f\" dictionary. This is used to maintain the so far frequencies. And it is used to track what is the longest repeated length so far. \\n\\nSaw the other solutions are using segment trees and kinda long. Share mine use dictionary of list and bisect only. \\n\\t\\n\\t\\n\\tdef longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        \\n        ans = []\\n        d = defaultdict(list)\\n        f = defaultdict(int)\\n        ii = 0\\n        n = len(s)\\n        s = list(s)\\n        maxl=1\\n        while ii<n:\\n            \\n            l = 1\\n            while ii+l<n and s[ii+l]==s[ii]: l+=1\\n            d[s[ii]].append([ii, ii+l-1])\\n            f[l] += 1\\n            maxl = max(l, maxl)\\n            ii += l\\n        \\n        for c, ind in zip(queryCharacters[:], queryIndices[:]):\\n            \\n            \\n            if c!=s[ind]:\\n                #print(d[c], [ind, n])\\n                ip = bisect_right(d[c], [ind, n])\\n                if ip>0: l1= d[c][ip-1][1]-d[c][ip-1][0]+1\\n                if ip<len(d[c]): l2=d[c][ip][1]-d[c][ip][0]+1\\n                if ip>0 and ind==d[c][ip-1][1]+1 and (ip<len(d[c]) and ind==d[c][ip][0]-1):\\n                    \\n                    d[c] = d[c][:ip-1] + [[d[c][ip-1][0], d[c][ip][1]]]+d[c][ip+1:]\\n                    f[l1]-=1\\n                    f[l2]-=1\\n                    f[l1+l2+1]+=1\\n                    maxl = max(maxl, l1+l2+1)\\n                elif ip>0 and ind==d[c][ip-1][1]+1:\\n                    d[c][ip-1][1] += 1\\n                    maxl = max(maxl, l1 +1)\\n                    f[l1]-=1\\n                    f[l1+1]+= 1\\n                elif ip<len(d[c]) and ind==d[c][ip][0]-1:\\n                    maxl = max(maxl, l2+1)\\n                    f[l2]-=1\\n                    f[l2+1]+=1\\n                    d[c][ip][0]-=1\\n                else:\\n                    bisect.insort(d[c],[ind, ind])\\n                    f[1]+=1\\n                r = s[ind]\\n                ip = bisect_right(d[r], [ind, n])\\n                \\n                l =  d[r][ip-1][1]-d[r][ip-1][0]+1\\n                f[l]-=1\\n                if d[r][ip-1]==[ind,ind]:\\n                    d[r].pop(ip-1)\\n                    \\n                elif d[r][ip-1][0]==ind: \\n                    d[r][ip-1][0]+= 1    \\n                    \\n                    f[l-1]+=1\\n                elif d[r][ip-1][1]==ind: \\n                    \\n                    f[l-1]+=1\\n                    d[r][ip-1][1]-=1\\n                else:\\n                    l1, l2 = ind-d[r][ip-1][0], d[r][ip-1][1]-ind\\n                    rep = d[r][ip-1][1] \\n                    d[r][ip-1][1] = ind-1\\n                    bisect.insort(d[r], [ind+1, rep])\\n                    f[l1]+=1\\n                    f[l2]+=1\\n                    \\n                if l == maxl and f[maxl]==0 and maxl>1:\\n                    maxl -=1\\n                    while f[maxl]==0 and maxl>1: maxl -=1\\n                    \\n            \\n            ans.append(maxl)\\n            s[ind]=c\\n        \\n        return ans\\n",
                "solutionTags": [],
                "code": "The basic idea is: for each char in s, we maitain a sorted interval for this character. Each query, we need to 1) updated the new character\\'s interval 2) delete one index from the old charater. \\nWhen update the character\\'s interval, there is another \"f\" dictionary. This is used to maintain the so far frequencies. And it is used to track what is the longest repeated length so far. \\n\\nSaw the other solutions are using segment trees and kinda long. Share mine use dictionary of list and bisect only. \\n\\t\\n\\t\\n\\tdef longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        \\n        ans = []\\n        d = defaultdict(list)\\n        f = defaultdict(int)\\n        ii = 0\\n        n = len(s)\\n        s = list(s)\\n        maxl=1\\n        while ii<n:\\n            \\n            l = 1\\n            while ii+l<n and s[ii+l]==s[ii]: l+=1\\n            d[s[ii]].append([ii, ii+l-1])\\n            f[l] += 1\\n            maxl = max(l, maxl)\\n            ii += l\\n        \\n        for c, ind in zip(queryCharacters[:], queryIndices[:]):\\n            \\n            \\n            if c!=s[ind]:\\n                #print(d[c], [ind, n])\\n                ip = bisect_right(d[c], [ind, n])\\n                if ip>0: l1= d[c][ip-1][1]-d[c][ip-1][0]+1\\n                if ip<len(d[c]): l2=d[c][ip][1]-d[c][ip][0]+1\\n                if ip>0 and ind==d[c][ip-1][1]+1 and (ip<len(d[c]) and ind==d[c][ip][0]-1):\\n                    \\n                    d[c] = d[c][:ip-1] + [[d[c][ip-1][0], d[c][ip][1]]]+d[c][ip+1:]\\n                    f[l1]-=1\\n                    f[l2]-=1\\n                    f[l1+l2+1]+=1\\n                    maxl = max(maxl, l1+l2+1)\\n                elif ip>0 and ind==d[c][ip-1][1]+1:\\n                    d[c][ip-1][1] += 1\\n                    maxl = max(maxl, l1 +1)\\n                    f[l1]-=1\\n                    f[l1+1]+= 1\\n                elif ip<len(d[c]) and ind==d[c][ip][0]-1:\\n                    maxl = max(maxl, l2+1)\\n                    f[l2]-=1\\n                    f[l2+1]+=1\\n                    d[c][ip][0]-=1\\n                else:\\n                    bisect.insort(d[c],[ind, ind])\\n                    f[1]+=1\\n                r = s[ind]\\n                ip = bisect_right(d[r], [ind, n])\\n                \\n                l =  d[r][ip-1][1]-d[r][ip-1][0]+1\\n                f[l]-=1\\n                if d[r][ip-1]==[ind,ind]:\\n                    d[r].pop(ip-1)\\n                    \\n                elif d[r][ip-1][0]==ind: \\n                    d[r][ip-1][0]+= 1    \\n                    \\n                    f[l-1]+=1\\n                elif d[r][ip-1][1]==ind: \\n                    \\n                    f[l-1]+=1\\n                    d[r][ip-1][1]-=1\\n                else:\\n                    l1, l2 = ind-d[r][ip-1][0], d[r][ip-1][1]-ind\\n                    rep = d[r][ip-1][1] \\n                    d[r][ip-1][1] = ind-1\\n                    bisect.insort(d[r], [ind+1, rep])\\n                    f[l1]+=1\\n                    f[l2]+=1\\n                    \\n                if l == maxl and f[maxl]==0 and maxl>1:\\n                    maxl -=1\\n                    while f[maxl]==0 and maxl>1: maxl -=1\\n                    \\n            \\n            ans.append(maxl)\\n            s[ind]=c\\n        \\n        return ans\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1867774,
                "title": "c-straightforward-range-split-merge-with-std-map",
                "content": "```\\nclass Solution {\\n    std::map<int, int> ranges; // start, end\\n    std::multiset<int, std::greater<int>> lengths;\\n  \\n    void insert(int start, int end)\\n    {\\n      ranges.insert({start, end});\\n      lengths.insert(end-start+1);\\n    }\\n  \\n    void erase(std::map<int, int>::iterator it)\\n    {\\n      lengths.erase(lengths.find(it->second-it->first+1));\\n      ranges.erase(it);\\n    }\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n      // aba -> aaa  merge\\n      // aaa -> aba  split\\n      \\n      for(int i=0;  i < s.size();)\\n      {\\n        int start = i;\\n        while(i < s.size() && s[start]==s[i]) ++i;\\n        int end = i;\\n        insert(start, end-1);\\n      }\\n      \\n      std::vector<int> result;\\n      for(int i = 0; i < queryIndices.size(); ++i)\\n      {\\n        int index_to_change = queryIndices[i];\\n        char char_to_replace = queryCharacters[i];\\n        \\n        if(s[index_to_change]!=char_to_replace)\\n        {\\n          // split\\n          {\\n            auto it = std::prev(ranges.upper_bound(index_to_change));\\n            auto range = *it;\\n            erase(it);\\n            \\n            if(index_to_change>0 && s[index_to_change-1]==s[index_to_change])\\n              insert(range.first, index_to_change-1);\\n            \\n            if(index_to_change+1 < s.size() && s[index_to_change+1]==s[index_to_change])\\n              insert(index_to_change+1, range.second);\\n          }\\n          \\n          s[index_to_change]=char_to_replace;\\n\\n          // merge\\n          {\\n            int start = index_to_change;\\n            int end = index_to_change;\\n            if(index_to_change>0 && s[index_to_change-1]==s[index_to_change])\\n            {\\n              auto it = std::prev(ranges.upper_bound(index_to_change-1));\\n              start = it->first;\\n              erase(it);\\n            }\\n            if(index_to_change+1<s.size() && s[index_to_change+1]==s[index_to_change])\\n            {\\n              auto it = std::prev(ranges.upper_bound(index_to_change+1));\\n              end = it->second;\\n              erase(it);\\n            }\\n            insert(start, end);\\n          }\\n        }\\n        \\n        result.push_back(*lengths.begin());\\n      }\\n      \\n      return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    std::map<int, int> ranges; // start, end\\n    std::multiset<int, std::greater<int>> lengths;\\n  \\n    void insert(int start, int end)\\n    {\\n      ranges.insert({start, end});\\n      lengths.insert(end-start+1);\\n    }\\n  \\n    void erase(std::map<int, int>::iterator it)\\n    {\\n      lengths.erase(lengths.find(it->second-it->first+1));\\n      ranges.erase(it);\\n    }\\npublic:\\n    vector<int> longestRepeating(string s, string queryCharacters, vector<int>& queryIndices) {\\n      // aba -> aaa  merge\\n      // aaa -> aba  split\\n      \\n      for(int i=0;  i < s.size();)\\n      {\\n        int start = i;\\n        while(i < s.size() && s[start]==s[i]) ++i;\\n        int end = i;\\n        insert(start, end-1);\\n      }\\n      \\n      std::vector<int> result;\\n      for(int i = 0; i < queryIndices.size(); ++i)\\n      {\\n        int index_to_change = queryIndices[i];\\n        char char_to_replace = queryCharacters[i];\\n        \\n        if(s[index_to_change]!=char_to_replace)\\n        {\\n          // split\\n          {\\n            auto it = std::prev(ranges.upper_bound(index_to_change));\\n            auto range = *it;\\n            erase(it);\\n            \\n            if(index_to_change>0 && s[index_to_change-1]==s[index_to_change])\\n              insert(range.first, index_to_change-1);\\n            \\n            if(index_to_change+1 < s.size() && s[index_to_change+1]==s[index_to_change])\\n              insert(index_to_change+1, range.second);\\n          }\\n          \\n          s[index_to_change]=char_to_replace;\\n\\n          // merge\\n          {\\n            int start = index_to_change;\\n            int end = index_to_change;\\n            if(index_to_change>0 && s[index_to_change-1]==s[index_to_change])\\n            {\\n              auto it = std::prev(ranges.upper_bound(index_to_change-1));\\n              start = it->first;\\n              erase(it);\\n            }\\n            if(index_to_change+1<s.size() && s[index_to_change+1]==s[index_to_change])\\n            {\\n              auto it = std::prev(ranges.upper_bound(index_to_change+1));\\n              end = it->second;\\n              erase(it);\\n            }\\n            insert(start, end);\\n          }\\n        }\\n        \\n        result.push_back(*lengths.begin());\\n      }\\n      \\n      return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867684,
                "title": "java-o-n-log-n-k-log-n-treeset-treemap-intervals-of-same-characters",
                "content": "The input string can be thought of as a list of non-overlapping intervals - each interval is the repeating character and its beginning and ending index in the string.\\nThe brute force solution would require checking for the max length of such intervals after every query (which updates / mutates the intervals) - this would be O(kn) in time complexity.\\n\\nBy using self-balancing binary search trees we can achieve the overall time complexity of **O(n log n + k log n)** - with each update to BSTs taking O(log n) time.\\n\\nHere we use:\\n1. a TreeSet **rank** - to hold the dynamic order of intervals by their length,\\n2. a TreeMap **intervals** - to look up an interval based on an index in the input string - required when identifying the interval to be updated by the mutating queries.\\n\\nThe code needs to handle the various cases of splitting and merging intervals, in response to the queries.\\n\\nI also added a much more principled and effectively simpler to code [**Segment Tree solution**](https://leetcode.com/problems/longest-substring-of-one-repeating-character/discuss/1871687/Java-or-Segment-Tree).\\n\\n```\\nclass Solution {\\n    class Interval{\\n        int ib, ie;  // start and end index \\n        char c;     // interval character\\n        public Interval(char c, int ib, int ie){\\n            this.c= c;\\n            this.ib= ib;\\n            this.ie= ie;\\n        }\\n        public boolean equals(Object o){\\n            return this.ib == ((Interval)o).ib;\\n        }\\n        public int hashCode(){\\n            return Integer.hashCode(ib);\\n        }\\n    }\\n\\n    public int[] longestRepeating(String s, String queryCharacters, int[] queryIndices) {\\n        char[] ca= s.toCharArray();\\n        int n= ca.length;\\n        // interval rank: intervals sorted descending by their length\\n        TreeSet<Interval> rank= new TreeSet<>((in1, in2)->{\\n            int comp= Integer.compare(in2.ie-in2.ib, in1.ie-in1.ib);\\n            return comp!=0 ? comp : in1.ib-in2.ib;\\n        }); \\n        // interval map - to look up interval by index (key is start of interval)\\n        TreeMap<Integer,Interval> intervals= new TreeMap<>();\\n        \\n        // create intervals and populate rank and map: O(n log n)\\n        for(int i=0; i<n; i++){\\n            int ib= i, ie= ib;\\n            while(i<n && ca[i]==ca[ib]) i++;\\n            Interval in= new Interval(ca[ib], ib, --i);\\n            rank.add(in);\\n            intervals.put(ib, in);\\n        }\\n        \\n\\t\\t// execte queries in O(k log n)\\n        int k= queryIndices.length;\\n        int[] ans= new int[k];\\n        for(int i=0; i<k; i++){ \\n            char qc= queryCharacters.charAt(i);\\n            int qi= queryIndices[i];\\n            ca[qi]= qc;\\n            ans[i]= updateIntervals(n, intervals, rank, qc, qi);\\n        }\\n        return ans;\\n    }\\n    \\n    int updateIntervals(int n, TreeMap<Integer,Interval> intervals, TreeSet<Interval> rank, char qc, int qi){\\n        Map.Entry<Integer,Interval> entry= intervals.floorEntry(qi);\\n        int ib= entry.getKey();\\n        Interval in= entry.getValue();\\n        if(qc!=in.c){\\n            if(in.ib==in.ie){\\n                // if the length of updated interval == 1\\n                // update interval character\\n                in.c= qc;\\n                // check merge with both next and previous intervals\\n                if(ib+1<n) checkMergeIntervals(intervals, rank, in, ib+1);\\n                if(ib>0) checkMergeIntervals(intervals, rank, in, ib-1);\\n            }else{\\n                // if the length of updated interval > 1:\\n                if(qi==in.ib){\\n                    // if first character is updated - split into 2\\n                    rank.remove(in);\\n                    Interval in2= new Interval(in.c, qi+1, in.ie);\\n                    intervals.put(qi+1, in2);\\n                    in.c= qc;\\n                    in.ie= in.ib;\\n                    rank.add(in);\\n                    rank.add(in2);\\n                    //check merge with previous interval\\n                    if(qi>0) checkMergeIntervals(intervals, rank, in, qi-1);\\n                }else if(qi==in.ie){\\n                    // if last character is updated - split into 2\\n                    rank.remove(in);\\n                    Interval qin= new Interval(qc, qi, qi);\\n                    intervals.put(qi, qin);\\n                    in.ie--;\\n                    rank.add(in);\\n                    rank.add(qin);                    \\n                    // check merge with next interval\\n                    if(qi+1<n) checkMergeIntervals(intervals, rank, qin, qi+1);\\n                }else{\\n                    // len>2 and middle character is updated: split interval into 3 (no merges)\\n                    rank.remove(in);\\n                    Interval qin= new Interval(qc, qi, qi);\\n                    intervals.put(qi, qin);\\n                    Interval in2= new Interval(in.c, qi+1, in.ie);\\n                    intervals.put(qi+1, in2);\\n                    in.ie= qi-1;\\n                    rank.add(in);\\n                    rank.add(qin);\\n                    rank.add(in2);\\n                }\\n            }\\n        }\\n        Interval max= rank.first();\\n        return max.ie-max.ib+1;\\n    }\\n    \\n    void checkMergeIntervals(TreeMap<Integer,Interval> intervals, TreeSet<Interval> rank, Interval in, int checkIndex){\\n        Map.Entry<Integer,Interval> entry2= intervals.floorEntry(checkIndex);\\n        if(entry2==null) return; // no interval to merge with\\n        int ib2= entry2.getKey();\\n        Interval in2= entry2.getValue();\\n        if(in.c!=in2.c) return; // merge not applicable\\n        rank.remove(in);\\n        rank.remove(in2);\\n        if(in.ib<in2.ib){\\n            in.ie= in2.ie;\\n            intervals.remove(in2.ib);\\n            rank.add(in);\\n        }else{\\n            in2.ie= in.ie;\\n            intervals.remove(in.ib);\\n            rank.add(in2);\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    class Interval{\\n        int ib, ie;  // start and end index \\n        char c;     // interval character\\n        public Interval(char c, int ib, int ie){\\n            this.c= c;\\n            this.ib= ib;\\n            this.ie= ie;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1867176,
                "title": "c-simulation-pure-stl-clean-code",
                "content": "This is a clean solution using only STL and standard operations. No fancy data structures such as segment tree. Just carefully simulate the process and consider all possible cases.\\nTime: O(nlogn)\\nSpace: O(n)\\n```c++\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string& s, string& qC, vector<int>& qI) {\\n        multiset<int, greater<int>> ms;\\n        map<int, int> range;\\n        vector<int> res;\\n        \\n        auto insert = [&](const pair<int, int>& p) {\\n            ms.insert(p.second - p.first);\\n            range.insert(p);\\n        };\\n        \\n        auto erase = [&](map<int, int>::iterator it) {\\n            ms.erase(ms.find(it->second - it->first));\\n            range.erase(it);\\n        };\\n        \\n        for (int i = 0, j; i < s.size(); i = j) {\\n            for (j = i; j < s.size() && s[j] == s[i]; j++);\\n            insert({i, j});\\n        }\\n        \\n        for (int i = 0; i < qC.size(); i++) {\\n            int idx = qI[i];\\n            char orig = s[idx], replaced = qC[i];\\n            s[idx] = replaced;\\n            \\n            if (orig != replaced) {\\n                map<int, int>::iterator it = prev(range.upper_bound(idx)),\\n                    prev_it = it == range.begin() ? range.end() : prev(it), next_it = next(it);\\n                pair<int, int> left = {it->first, idx}, mid = {idx, idx + 1}, right = {idx + 1, it->second}, to_add;\\n                vector<map<int, int>::iterator> to_remove;\\n                \\n                if (prev_it != range.end() && next_it != range.end()\\n                        && left.first == left.second && right.first == right.second\\n                        && replaced == s[prev_it->first] && replaced == s[next_it->first]) {\\n                    to_add = {prev_it->first, next_it->second};\\n                    to_remove = {prev_it, it, next_it};\\n                } else if (prev_it != range.end() && left.first == left.second && replaced == s[prev_it->first]) {\\n                    to_add = {prev_it->first, mid.second};\\n                    to_remove = {prev_it, it};\\n                } else if (next_it != range.end() && right.first == right.second && replaced == s[next_it->first]) {\\n                    to_add = {mid.first, next_it->second};\\n                    to_remove = {it, next_it};\\n                } else {\\n                    to_add = mid;\\n                    to_remove = {it};\\n                }\\n                \\n                for (auto& remove_it : to_remove)\\n                    erase(remove_it);\\n                insert(to_add);\\n                if (left.first < left.second)\\n                    insert(left);\\n                if (right.first < right.second)\\n                    insert(right);\\n            }\\n            \\n            res.push_back(*ms.begin());\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Simulation"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> longestRepeating(string& s, string& qC, vector<int>& qI) {\\n        multiset<int, greater<int>> ms;\\n        map<int, int> range;\\n        vector<int> res;\\n        \\n        auto insert = [&](const pair<int, int>& p) {\\n            ms.insert(p.second - p.first);\\n            range.insert(p);\\n        };\\n        \\n        auto erase = [&](map<int, int>::iterator it) {\\n            ms.erase(ms.find(it->second - it->first));\\n            range.erase(it);\\n        };\\n        \\n        for (int i = 0, j; i < s.size(); i = j) {\\n            for (j = i; j < s.size() && s[j] == s[i]; j++);\\n            insert({i, j});\\n        }\\n        \\n        for (int i = 0; i < qC.size(); i++) {\\n            int idx = qI[i];\\n            char orig = s[idx], replaced = qC[i];\\n            s[idx] = replaced;\\n            \\n            if (orig != replaced) {\\n                map<int, int>::iterator it = prev(range.upper_bound(idx)),\\n                    prev_it = it == range.begin() ? range.end() : prev(it), next_it = next(it);\\n                pair<int, int> left = {it->first, idx}, mid = {idx, idx + 1}, right = {idx + 1, it->second}, to_add;\\n                vector<map<int, int>::iterator> to_remove;\\n                \\n                if (prev_it != range.end() && next_it != range.end()\\n                        && left.first == left.second && right.first == right.second\\n                        && replaced == s[prev_it->first] && replaced == s[next_it->first]) {\\n                    to_add = {prev_it->first, next_it->second};\\n                    to_remove = {prev_it, it, next_it};\\n                } else if (prev_it != range.end() && left.first == left.second && replaced == s[prev_it->first]) {\\n                    to_add = {prev_it->first, mid.second};\\n                    to_remove = {prev_it, it};\\n                } else if (next_it != range.end() && right.first == right.second && replaced == s[next_it->first]) {\\n                    to_add = {mid.first, next_it->second};\\n                    to_remove = {it, next_it};\\n                } else {\\n                    to_add = mid;\\n                    to_remove = {it};\\n                }\\n                \\n                for (auto& remove_it : to_remove)\\n                    erase(remove_it);\\n                insert(to_add);\\n                if (left.first < left.second)\\n                    insert(left);\\n                if (right.first < right.second)\\n                    insert(right);\\n            }\\n            \\n            res.push_back(*ms.begin());\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866735,
                "title": "segment-tree-converted-python-code-to-javascript",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string} queryCharacters\\n * @param {number[]} queryIndices\\n * @return {number[]}\\n */\\nfunction Node() {\\n    this.left = null;\\n    this.right = null;\\n    this.lmost = null;\\n    this.lchar = null;\\n    this.rmost = null;\\n    this.rchar = null;\\n    this.most = null;\\n    this.i = null;\\n    this.j = null;\\n}\\nfunction update_stats(node) {\\n    if(node.left == null) {\\n        return;\\n    }\\n    if(node.left.lmost == node.left.j - node.left.i && node.left.lchar == node.right.lchar) {\\n        node.lchar = node.left.lchar;\\n        node.lmost = node.left.lmost + node.right.lmost;\\n    } else {\\n        node.lchar = node.left.lchar;\\n        node.lmost = node.left.lmost;\\n    }\\n    if(node.right.rmost == node.right.j - node.right.i && node.right.rchar == node.left.rchar) {\\n        node.rchar = node.right.rchar;\\n        node.rmost = node.right.rmost + node.left.rmost;\\n    } else {\\n        node.rchar = node.right.rchar;\\n        node.rmost = node.right.rmost;\\n    }\\n    \\n    node.most = Math.max(node.left.most, node.right.most);\\n    if(node.left.rchar == node.right.lchar) {\\n        let most2 = node.left.rmost + node.right.lmost;\\n        node.most = Math.max(node.most, most2);\\n    }\\n}\\nfunction create(node, s, i, j) {\\n    if(i+1 == j) {\\n        node.lmost = 1;\\n        node.rmost = 1;\\n        node.lchar = s[i];\\n        node.rchar = s[i];\\n        node.most = 1;\\n        node.i = i;\\n        node.j = j;\\n    } else {\\n        let m = ((i+j) / 2 )| 0;\\n        node.left = create(new Node(),s, i, m);\\n        node.right = create(new Node(),s, m, j);\\n        node.i = i;\\n        node.j = j;\\n        update_stats(node);\\n    }\\n    return node;\\n}\\nfunction update(node, pos, char) {\\n    if(node.left == null) {\\n        node.lchar = node.rchar = char;\\n    } else if(pos < node.left.j) {\\n        update(node.left, pos, char);\\n    } else {\\n        update(node.right, pos, char);\\n    }\\n    update_stats(node);\\n}\\nvar longestRepeating = function(s, queryCharacters, queryIndices) {\\n    let node = new Node();\\n    \\n    \\n    create(node, s, 0, s.length);\\n    let ans = [];\\n    for(let i=0;i<queryIndices.length;i++) {\\n        let iq = queryIndices[i];\\n        let c = queryCharacters[i];\\n        update(node, iq, c);\\n        ans.push(node.most);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string} queryCharacters\\n * @param {number[]} queryIndices\\n * @return {number[]}\\n */\\nfunction Node() {\\n    this.left = null;\\n    this.right = null;\\n    this.lmost = null;\\n    this.lchar = null;\\n    this.rmost = null;\\n    this.rchar = null;\\n    this.most = null;\\n    this.i = null;\\n    this.j = null;\\n}\\nfunction update_stats(node) {\\n    if(node.left == null) {\\n        return;\\n    }\\n    if(node.left.lmost == node.left.j - node.left.i && node.left.lchar == node.right.lchar) {\\n        node.lchar = node.left.lchar;\\n        node.lmost = node.left.lmost + node.right.lmost;\\n    } else {\\n        node.lchar = node.left.lchar;\\n        node.lmost = node.left.lmost;\\n    }\\n    if(node.right.rmost == node.right.j - node.right.i && node.right.rchar == node.left.rchar) {\\n        node.rchar = node.right.rchar;\\n        node.rmost = node.right.rmost + node.left.rmost;\\n    } else {\\n        node.rchar = node.right.rchar;\\n        node.rmost = node.right.rmost;\\n    }\\n    \\n    node.most = Math.max(node.left.most, node.right.most);\\n    if(node.left.rchar == node.right.lchar) {\\n        let most2 = node.left.rmost + node.right.lmost;\\n        node.most = Math.max(node.most, most2);\\n    }\\n}\\nfunction create(node, s, i, j) {\\n    if(i+1 == j) {\\n        node.lmost = 1;\\n        node.rmost = 1;\\n        node.lchar = s[i];\\n        node.rchar = s[i];\\n        node.most = 1;\\n        node.i = i;\\n        node.j = j;\\n    } else {\\n        let m = ((i+j) / 2 )| 0;\\n        node.left = create(new Node(),s, i, m);\\n        node.right = create(new Node(),s, m, j);\\n        node.i = i;\\n        node.j = j;\\n        update_stats(node);\\n    }\\n    return node;\\n}\\nfunction update(node, pos, char) {\\n    if(node.left == null) {\\n        node.lchar = node.rchar = char;\\n    } else if(pos < node.left.j) {\\n        update(node.left, pos, char);\\n    } else {\\n        update(node.right, pos, char);\\n    }\\n    update_stats(node);\\n}\\nvar longestRepeating = function(s, queryCharacters, queryIndices) {\\n    let node = new Node();\\n    \\n    \\n    create(node, s, 0, s.length);\\n    let ans = [];\\n    for(let i=0;i<queryIndices.length;i++) {\\n        let iq = queryIndices[i];\\n        let c = queryCharacters[i];\\n        update(node, iq, c);\\n        ans.push(node.most);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1866611,
                "title": "python-sortedlist-with-counter",
                "content": "```\\nfrom collections import defaultdict\\nfrom sortedcontainers import SortedList\\n\\n    \\nclass Dummy:\\n    def __init__(self, idx):\\n        self.r = idx\\n        \\nclass Node:\\n    maxL = None\\n    crtMaxL = 0\\n    def __init__(self, l, r, chr):\\n        self.l, self.r, self.c, self.length = l, r, chr, r - l\\n        self.add()\\n        \\n    def update(self, new_l, new_r):\\n        self.l, self.r, self.length = new_l, new_r, new_r - new_l\\n        self.add()\\n        \\n    def add(self):\\n        Node.maxL[self.length] += 1\\n        if self.length > Node.crtMaxL:\\n            Node.crtMaxL = self.length\\n    \\n    def remove(self):\\n        Node.maxL[self.length] -= 1\\n        if Node.maxL[self.length] == 0:\\n            del Node.maxL[self.length]\\n            if self.length == Node.crtMaxL:\\n                Node.crtMaxL = max(Node.maxL.keys(), default=0)\\n\\n    def split(self, idx, c):\\n        self.remove()\\n        ret = []\\n        if self.l < idx:\\n            ret.append(Node(self.l, idx - 1, self.c))\\n        ret.append(Node(idx, idx, c))\\n        if self.r > idx:\\n            ret.append(Node(idx + 1, self.r, self.c))\\n        return self.l == idx, self.r == idx, ret\\n\\n    def merge(nodes):\\n        i = 0\\n        ret = []\\n        while i < len(nodes):\\n            l = i\\n            while i < len(nodes) and nodes[l].c == nodes[i].c:\\n                nodes[i].remove()\\n                i += 1\\n            nodes[l].update(nodes[l].l, nodes[i - 1].r)\\n            ret.append(nodes[l])\\n        return ret\\n            \\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        nodes = []\\n        Node.maxL = defaultdict(int)\\n        Node.crtMaxL = 0\\n        ret = []\\n        i = 0\\n        while i < len(s):\\n            l = i\\n            while i < len(s) and s[i] == s[l]:\\n                i += 1\\n            node = Node(l, i - 1, s[l])\\n            nodes.append(node)\\n            \\n        nodes = SortedList(nodes, key=lambda x:x.r)\\n        \\n        def update_nodes(idx, c):\\n            nonlocal nodes\\n            i = nodes.bisect_left(Dummy(idx))\\n            node = nodes[i]\\n            if c == node.c:\\n                return\\n            \\n            need_merge_left, need_merge_right, list_of_nodes = node.split(idx, c)\\n            \\n            list_to_remove = [node]\\n            list_to_merge = []\\n            if need_merge_left and i > 0 and nodes[i - 1].c == c:\\n                lNode = nodes[i - 1]\\n                list_to_merge.append(lNode)\\n                list_to_remove.append(lNode)\\n            \\n            list_to_merge += list_of_nodes\\n            \\n            if need_merge_right and i < len(nodes) - 1 and nodes[i + 1].c == c:\\n                rNode = nodes[i + 1]\\n                list_to_merge.append(rNode)\\n                list_to_remove.append(rNode)\\n                \\n            [nodes.remove(n) for n in list_to_remove]\\n            nodes.update(Node.merge(list_to_merge))\\n                \\n        for c, idx in zip(queryCharacters, queryIndices):\\n            update_nodes(idx, c)\\n            ret.append(Node.crtMaxL + 1)\\n\\n        return ret\\n```\\nUse sortedList to locate the span Node and maintain a Counter of node length. (sometimes gets TLE when judging, very confusing)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom sortedcontainers import SortedList\\n\\n    \\nclass Dummy:\\n    def __init__(self, idx):\\n        self.r = idx\\n        \\nclass Node:\\n    maxL = None\\n    crtMaxL = 0\\n    def __init__(self, l, r, chr):\\n        self.l, self.r, self.c, self.length = l, r, chr, r - l\\n        self.add()\\n        \\n    def update(self, new_l, new_r):\\n        self.l, self.r, self.length = new_l, new_r, new_r - new_l\\n        self.add()\\n        \\n    def add(self):\\n        Node.maxL[self.length] += 1\\n        if self.length > Node.crtMaxL:\\n            Node.crtMaxL = self.length\\n    \\n    def remove(self):\\n        Node.maxL[self.length] -= 1\\n        if Node.maxL[self.length] == 0:\\n            del Node.maxL[self.length]\\n            if self.length == Node.crtMaxL:\\n                Node.crtMaxL = max(Node.maxL.keys(), default=0)\\n\\n    def split(self, idx, c):\\n        self.remove()\\n        ret = []\\n        if self.l < idx:\\n            ret.append(Node(self.l, idx - 1, self.c))\\n        ret.append(Node(idx, idx, c))\\n        if self.r > idx:\\n            ret.append(Node(idx + 1, self.r, self.c))\\n        return self.l == idx, self.r == idx, ret\\n\\n    def merge(nodes):\\n        i = 0\\n        ret = []\\n        while i < len(nodes):\\n            l = i\\n            while i < len(nodes) and nodes[l].c == nodes[i].c:\\n                nodes[i].remove()\\n                i += 1\\n            nodes[l].update(nodes[l].l, nodes[i - 1].r)\\n            ret.append(nodes[l])\\n        return ret\\n            \\nclass Solution:\\n    def longestRepeating(self, s: str, queryCharacters: str, queryIndices: List[int]) -> List[int]:\\n        nodes = []\\n        Node.maxL = defaultdict(int)\\n        Node.crtMaxL = 0\\n        ret = []\\n        i = 0\\n        while i < len(s):\\n            l = i\\n            while i < len(s) and s[i] == s[l]:\\n                i += 1\\n            node = Node(l, i - 1, s[l])\\n            nodes.append(node)\\n            \\n        nodes = SortedList(nodes, key=lambda x:x.r)\\n        \\n        def update_nodes(idx, c):\\n            nonlocal nodes\\n            i = nodes.bisect_left(Dummy(idx))\\n            node = nodes[i]\\n            if c == node.c:\\n                return\\n            \\n            need_merge_left, need_merge_right, list_of_nodes = node.split(idx, c)\\n            \\n            list_to_remove = [node]\\n            list_to_merge = []\\n            if need_merge_left and i > 0 and nodes[i - 1].c == c:\\n                lNode = nodes[i - 1]\\n                list_to_merge.append(lNode)\\n                list_to_remove.append(lNode)\\n            \\n            list_to_merge += list_of_nodes\\n            \\n            if need_merge_right and i < len(nodes) - 1 and nodes[i + 1].c == c:\\n                rNode = nodes[i + 1]\\n                list_to_merge.append(rNode)\\n                list_to_remove.append(rNode)\\n                \\n            [nodes.remove(n) for n in list_to_remove]\\n            nodes.update(Node.merge(list_to_merge))\\n                \\n        for c, idx in zip(queryCharacters, queryIndices):\\n            update_nodes(idx, c)\\n            ret.append(Node.crtMaxL + 1)\\n\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866542,
                "title": "o-n-log-n-segment-tree",
                "content": "```csharp\\npublic class SegmentNode\\n{\\n\\tpublic int Value { get; set; }\\n\\tpublic int LeftLen { get; set; }\\n\\tpublic int RightLen { get; set; }\\n\\tpublic char Left { get; set; }\\n\\tpublic char Right { get; set; }\\n}\\n\\npublic int[] LongestRepeating(string input, string queryCharacters, int[] queryIndices)\\n{\\n\\tchar[] s = input.ToCharArray();\\n\\tint[] result = new int[queryCharacters.Length];\\n\\tSegmentNode[] tree = new SegmentNode[s.Length * 4];\\n\\tfor (int i = 0; i < tree.Length; i++)\\n\\t{\\n\\t\\ttree[i] = new();\\n\\t}\\n\\n\\tbuildSegmentTree(s, 0, s.Length - 1, tree, 0);\\n\\n\\tfor (int i = 0; i < result.Length; i++)\\n\\t{\\n\\t\\tupdateSegmentTree(s, 0, s.Length - 1, tree, queryCharacters[i], queryIndices[i], 0);\\n\\t\\tresult[i] = tree[0].Value;\\n\\t}\\n\\n\\treturn result;\\n}\\n\\nprivate void buildSegmentTree(char[] s, int left, int right, SegmentNode[] tree, int treeIndex)\\n{\\n\\t// Leaves\\n\\tif (left == right)\\n\\t{\\n\\t\\ttree[treeIndex].Left = tree[treeIndex].Right = s[left];\\n\\t\\ttree[treeIndex].LeftLen = tree[treeIndex].RightLen = 1;\\n\\t\\ttree[treeIndex].Value = 1;\\n\\t\\treturn;\\n\\t}\\n\\n\\tint mid = left + (right - left) / 2;\\n\\tbuildSegmentTree(s, left, mid, tree, treeIndex * 2 + 1);\\n\\tbuildSegmentTree(s, mid + 1, right, tree, treeIndex * 2 + 2);\\n\\tupdate(tree, treeIndex, left, right);\\n}\\n\\nprivate void update(SegmentNode[] tree, int treeIndex, int left, int right)\\n{\\n\\tint mid = left + (right - left) / 2;\\n\\tint leftChild = treeIndex * 2 + 1;\\n\\tint rightchild = treeIndex * 2 + 2;\\n\\n\\ttree[treeIndex].Value = Math.Max(tree[leftChild].Value, tree[rightchild].Value);\\n\\ttree[treeIndex].LeftLen = tree[leftChild].LeftLen;\\n\\ttree[treeIndex].RightLen = tree[rightchild].RightLen;\\n\\ttree[treeIndex].Left = tree[leftChild].Left;\\n\\ttree[treeIndex].Right = tree[rightchild].Right;\\n\\n\\tif (tree[leftChild].Right == tree[rightchild].Left)\\n\\t{\\n\\t\\ttree[treeIndex].Value = Math.Max(tree[treeIndex].Value, tree[leftChild].RightLen + tree[rightchild].LeftLen);\\n\\n\\t\\tif (tree[leftChild].LeftLen == (mid - left + 1))\\n\\t\\t{\\n\\t\\t\\ttree[treeIndex].LeftLen += tree[rightchild].LeftLen;\\n\\t\\t}\\n\\n\\t\\tif (tree[rightchild].RightLen == (right - mid))\\n\\t\\t{\\n\\t\\t\\ttree[treeIndex].RightLen += tree[leftChild].RightLen;\\n\\t\\t}\\n\\t}\\n}\\n\\nprivate void updateSegmentTree(char[] s, int left, int right, SegmentNode[] tree, char c, int index, int treeIndex)\\n{\\n\\tif (left == right)\\n\\t{\\n\\t\\ts[index] = c;\\n\\t\\ttree[treeIndex].Left = tree[treeIndex].Right = c;\\n\\t\\treturn;\\n\\t}\\n\\n\\tint mid = left + (right - left) / 2;\\n\\tif (index <= mid)\\n\\t{\\n\\t\\tupdateSegmentTree(s, left, mid, tree, c, index, 2 * treeIndex + 1);\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tupdateSegmentTree(s, mid + 1, right, tree, c, index, 2 * treeIndex + 2);\\n\\t}\\n\\n\\tupdate(tree, treeIndex, left, right);\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class SegmentNode\\n{\\n\\tpublic int Value { get; set; }\\n\\tpublic int LeftLen { get; set; }\\n\\tpublic int RightLen { get; set; }\\n\\tpublic char Left { get; set; }\\n\\tpublic char Right { get; set; }\\n}\\n\\npublic int[] LongestRepeating(string input, string queryCharacters, int[] queryIndices)\\n{\\n\\tchar[] s = input.ToCharArray();\\n\\tint[] result = new int[queryCharacters.Length];\\n\\tSegmentNode[] tree = new SegmentNode[s.Length * 4];\\n\\tfor (int i = 0; i < tree.Length; i++)\\n\\t{\\n\\t\\ttree[i] = new();\\n\\t}\\n\\n\\tbuildSegmentTree(s, 0, s.Length - 1, tree, 0);\\n\\n\\tfor (int i = 0; i < result.Length; i++)\\n\\t{\\n\\t\\tupdateSegmentTree(s, 0, s.Length - 1, tree, queryCharacters[i], queryIndices[i], 0);\\n\\t\\tresult[i] = tree[0].Value;\\n\\t}\\n\\n\\treturn result;\\n}\\n\\nprivate void buildSegmentTree(char[] s, int left, int right, SegmentNode[] tree, int treeIndex)\\n{\\n\\t// Leaves\\n\\tif (left == right)\\n\\t{\\n\\t\\ttree[treeIndex].Left = tree[treeIndex].Right = s[left];\\n\\t\\ttree[treeIndex].LeftLen = tree[treeIndex].RightLen = 1;\\n\\t\\ttree[treeIndex].Value = 1;\\n\\t\\treturn;\\n\\t}\\n\\n\\tint mid = left + (right - left) / 2;\\n\\tbuildSegmentTree(s, left, mid, tree, treeIndex * 2 + 1);\\n\\tbuildSegmentTree(s, mid + 1, right, tree, treeIndex * 2 + 2);\\n\\tupdate(tree, treeIndex, left, right);\\n}\\n\\nprivate void update(SegmentNode[] tree, int treeIndex, int left, int right)\\n{\\n\\tint mid = left + (right - left) / 2;\\n\\tint leftChild = treeIndex * 2 + 1;\\n\\tint rightchild = treeIndex * 2 + 2;\\n\\n\\ttree[treeIndex].Value = Math.Max(tree[leftChild].Value, tree[rightchild].Value);\\n\\ttree[treeIndex].LeftLen = tree[leftChild].LeftLen;\\n\\ttree[treeIndex].RightLen = tree[rightchild].RightLen;\\n\\ttree[treeIndex].Left = tree[leftChild].Left;\\n\\ttree[treeIndex].Right = tree[rightchild].Right;\\n\\n\\tif (tree[leftChild].Right == tree[rightchild].Left)\\n\\t{\\n\\t\\ttree[treeIndex].Value = Math.Max(tree[treeIndex].Value, tree[leftChild].RightLen + tree[rightchild].LeftLen);\\n\\n\\t\\tif (tree[leftChild].LeftLen == (mid - left + 1))\\n\\t\\t{\\n\\t\\t\\ttree[treeIndex].LeftLen += tree[rightchild].LeftLen;\\n\\t\\t}\\n\\n\\t\\tif (tree[rightchild].RightLen == (right - mid))\\n\\t\\t{\\n\\t\\t\\ttree[treeIndex].RightLen += tree[leftChild].RightLen;\\n\\t\\t}\\n\\t}\\n}\\n\\nprivate void updateSegmentTree(char[] s, int left, int right, SegmentNode[] tree, char c, int index, int treeIndex)\\n{\\n\\tif (left == right)\\n\\t{\\n\\t\\ts[index] = c;\\n\\t\\ttree[treeIndex].Left = tree[treeIndex].Right = c;\\n\\t\\treturn;\\n\\t}\\n\\n\\tint mid = left + (right - left) / 2;\\n\\tif (index <= mid)\\n\\t{\\n\\t\\tupdateSegmentTree(s, left, mid, tree, c, index, 2 * treeIndex + 1);\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tupdateSegmentTree(s, mid + 1, right, tree, c, index, 2 * treeIndex + 2);\\n\\t}\\n\\n\\tupdate(tree, treeIndex, left, right);\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1866535,
                "title": "c-concise-efficient-bottom-up-segment-perfect-tree",
                "content": "```\\npublic class Node {\\n\\tpublic char lc, rc;\\n\\tpublic int lcnt, rcnt, mx;\\n\\tpublic bool same;\\n\\n\\tpublic Node(Node ln, Node rn) {\\n\\t\\tlc = ln.lc; lcnt = ln.lcnt; rc = rn.rc; rcnt = rn.rcnt;\\n\\t\\tmx = Math.Max(ln.mx, rn.mx); same = false;\\n\\n\\t\\tif (ln.rc == rn.lc) {\\n\\t\\t\\tmx = Math.Max(mx, ln.rcnt + rn.lcnt);\\n\\t\\t\\tif (ln.same && rn.same) {\\n\\t\\t\\t\\tlcnt = ln.rcnt + rn.lcnt;\\n\\t\\t\\t\\trcnt = ln.rcnt + rn.lcnt;\\n\\t\\t\\t\\tsame = true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif(ln.same && ln.lc == rn.lc) {\\n\\t\\t\\t\\t\\tlcnt += rn.lcnt;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(rn.same && rn.rc == ln.rc) {\\n\\t\\t\\t\\t\\trcnt += ln.rcnt;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic Node(char c) {\\n\\t\\tlc = c; lcnt = 1; rc = c; rcnt = 1; mx = 1; same = true;\\n\\t}\\n\\tpublic Node() {}\\n}\\n\\npublic int[] LongestRepeating(string s, string queryCharacters, int[] queryIndices) {\\n\\n\\tint n = 1;\\n\\twhile(n < s.Length) {\\n\\t\\tn *= 2;\\n\\t}\\n\\n\\tNode[] tree = new Node[2 * n];\\n\\tbuildTree(tree, s, n);\\n\\n\\tint[] res = new int[queryCharacters.Length];\\n\\tfor(int i=0; i<queryCharacters.Length; i++) {\\n\\t\\tupdateTreeNode(tree, queryIndices[i], queryCharacters[i], n);\\n\\t\\tres[i] = tree[1].mx;\\n\\t}\\n\\treturn res;\\n}\\n\\nvoid updateTreeNode(Node[] tree, int idx, char c, int n) {\\n\\ttree[idx + n] = new Node(c);\\n\\t// move upward and update parents\\n\\tfor (int i = idx + n; i > 1; i >>= 1) {\\n\\t\\tif (i%2==0) {\\n\\t\\t\\ttree[i >> 1] = new Node(tree[i], tree[i^1]);\\n\\t\\t} else {\\n\\t\\t\\ttree[i >> 1] = new Node(tree[i^1], tree[i]);\\n\\t\\t}\\n\\t}\\n}\\n\\nvoid buildTree(Node[] tree, string s, int n) {\\n\\n\\t// insert leaf nodes in tree\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif(i < s.Length) {\\n\\t\\t\\ttree[n + i] = new Node(s[i]);\\n\\t\\t} else {\\n\\t\\t\\ttree[n + i] = new Node();\\n\\t\\t}\\n\\t}\\n\\t// build the tree by calculating parents\\n\\tfor (int i = n - 1; i > 0; --i) {\\n\\t\\ttree[i] = new Node(tree[i << 1], tree[i << 1 | 1]);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\npublic class Node {\\n\\tpublic char lc, rc;\\n\\tpublic int lcnt, rcnt, mx;\\n\\tpublic bool same;\\n\\n\\tpublic Node(Node ln, Node rn) {\\n\\t\\tlc = ln.lc; lcnt = ln.lcnt; rc = rn.rc; rcnt = rn.rcnt;\\n\\t\\tmx = Math.Max(ln.mx, rn.mx); same = false;\\n\\n\\t\\tif (ln.rc == rn.lc) {\\n\\t\\t\\tmx = Math.Max(mx, ln.rcnt + rn.lcnt);\\n\\t\\t\\tif (ln.same && rn.same) {\\n\\t\\t\\t\\tlcnt = ln.rcnt + rn.lcnt;\\n\\t\\t\\t\\trcnt = ln.rcnt + rn.lcnt;\\n\\t\\t\\t\\tsame = true;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif(ln.same && ln.lc == rn.lc) {\\n\\t\\t\\t\\t\\tlcnt += rn.lcnt;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(rn.same && rn.rc == ln.rc) {\\n\\t\\t\\t\\t\\trcnt += ln.rcnt;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tpublic Node(char c) {\\n\\t\\tlc = c; lcnt = 1; rc = c; rcnt = 1; mx = 1; same = true;\\n\\t}\\n\\tpublic Node() {}\\n}\\n\\npublic int[] LongestRepeating(string s, string queryCharacters, int[] queryIndices) {\\n\\n\\tint n = 1;\\n\\twhile(n < s.Length) {\\n\\t\\tn *= 2;\\n\\t}\\n\\n\\tNode[] tree = new Node[2 * n];\\n\\tbuildTree(tree, s, n);\\n\\n\\tint[] res = new int[queryCharacters.Length];\\n\\tfor(int i=0; i<queryCharacters.Length; i++) {\\n\\t\\tupdateTreeNode(tree, queryIndices[i], queryCharacters[i], n);\\n\\t\\tres[i] = tree[1].mx;\\n\\t}\\n\\treturn res;\\n}\\n\\nvoid updateTreeNode(Node[] tree, int idx, char c, int n) {\\n\\ttree[idx + n] = new Node(c);\\n\\t// move upward and update parents\\n\\tfor (int i = idx + n; i > 1; i >>= 1) {\\n\\t\\tif (i%2==0) {\\n\\t\\t\\ttree[i >> 1] = new Node(tree[i], tree[i^1]);\\n\\t\\t} else {\\n\\t\\t\\ttree[i >> 1] = new Node(tree[i^1], tree[i]);\\n\\t\\t}\\n\\t}\\n}\\n\\nvoid buildTree(Node[] tree, string s, int n) {\\n\\n\\t// insert leaf nodes in tree\\n\\tfor (int i = 0; i < n; i++) {\\n\\t\\tif(i < s.Length) {\\n\\t\\t\\ttree[n + i] = new Node(s[i]);\\n\\t\\t} else {\\n\\t\\t\\ttree[n + i] = new Node();\\n\\t\\t}\\n\\t}\\n\\t// build the tree by calculating parents\\n\\tfor (int i = n - 1; i > 0; --i) {\\n\\t\\ttree[i] = new Node(tree[i << 1], tree[i << 1 | 1]);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2030299,
                "content": [
                    {
                        "username": "ALZ113",
                        "content": "why No discussions?\\n"
                    }
                ]
            }
        ]
    }
]