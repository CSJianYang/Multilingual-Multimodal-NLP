[
    {
        "title": "Odd String Difference",
        "question_content": "You are given an array of equal-length strings words. Assume that the length of each string is n.\nEach string words[i] can be converted into a difference integer array difference[i] of length n - 1 where difference[i][j] = words[i][j+1] - words[i][j] where 0 <= j <= n - 2. Note that the difference between two letters is the difference between their positions in the alphabet i.e.&nbsp;the position of 'a' is 0, 'b' is 1, and 'z' is 25.\n\n\tFor example, for the string \"acb\", the difference integer array is [2 - 0, 1 - 2] = [2, -1].\n\nAll the strings in words have the same difference integer array, except one. You should find that string.\nReturn the string in words that has different difference integer array.\n&nbsp;\nExample 1:\n\nInput: words = [\"adc\",\"wzy\",\"abc\"]\nOutput: \"abc\"\nExplanation: \n- The difference integer array of \"adc\" is [3 - 0, 2 - 3] = [3, -1].\n- The difference integer array of \"wzy\" is [25 - 22, 24 - 25]= [3, -1].\n- The difference integer array of \"abc\" is [1 - 0, 2 - 1] = [1, 1]. \nThe odd array out is [1, 1], so we return the corresponding string, \"abc\".\n\nExample 2:\n\nInput: words = [\"aaa\",\"bob\",\"ccc\",\"ddd\"]\nOutput: \"bob\"\nExplanation: All the integer arrays are [0, 0] except for \"bob\", which corresponds to [13, -13].\n\n&nbsp;\nConstraints:\n\n\t3 <= words.length <= 100\n\tn == words[i].length\n\t2 <= n <= 20\n\twords[i] consists of lowercase English letters.",
        "solutions": [
            {
                "id": 2756345,
                "title": "c-map-with-o-n-solution-explained-very-simple-and-easy-to-understand",
                "content": "<b>Up Vote if you like the solution \\n```\\n/* \\nCreate a difference string and add it to map, also increment count while adding to map.\\nWhile adding to the map, I am creating a string by just concatenating the numbers and \"_\" between each number.\\nThen scan the map to have an element with value 1 ( as we are looking for unique string)  and return corresponding string\\n*/\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        unordered_map<string, string> amp;\\n        for(auto w: words){ \\n            string s = \"\"; \\n            for(int j = 0; j < w.size()-1; ++j){   //concatenate each nuber with a \"_\" in between\\n                int t = w[j+1] - w[j];\\n                s += to_string(t) + \"_\";\\n            }\\n            mp[s]++;   //add it to map and increament the value\\n            amp[s] = w;   //preserve the original string reference\\n        }\\n        for(auto m: mp){   //scan for string with count equal to 1 ( unique string )\\n            if(m.second == 1) return amp[m.first];   //return original string when found\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/* \\nCreate a difference string and add it to map, also increment count while adding to map.\\nWhile adding to the map, I am creating a string by just concatenating the numbers and \"_\" between each number.\\nThen scan the map to have an element with value 1 ( as we are looking for unique string)  and return corresponding string\\n*/\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        unordered_map<string, int> mp;\\n        unordered_map<string, string> amp;\\n        for(auto w: words){ \\n            string s = \"\"; \\n            for(int j = 0; j < w.size()-1; ++j){   //concatenate each nuber with a \"_\" in between\\n                int t = w[j+1] - w[j];\\n                s += to_string(t) + \"_\";\\n            }\\n            mp[s]++;   //add it to map and increament the value\\n            amp[s] = w;   //preserve the original string reference\\n        }\\n        for(auto m: mp){   //scan for string with count equal to 1 ( unique string )\\n            if(m.second == 1) return amp[m.first];   //return original string when found\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756439,
                "title": "python-c-java-rust-group-using-hashmap-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs hashmap to group words according to their difference array. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**. \\n\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        \\n        # [1] as stated in the problem, there will be two groups \\n        #     of words according to their difference array;\\n        #     we\\'ll store them in a hashmap/dict using the\\n        #     difference array as a key\\n        eq = defaultdict(list)\\n        \\n        for w in words:\\n            # [2] in Python, keys are immutable, thus we convert\\n            #     the difference array to \\'tuple\\'\\n            diff = [ord(a)-ord(b) for a, b in zip(w[:-1], w[1:])]\\n            eq[tuple(diff)].append(w)\\n        \\n        # [3] as guaranteed in the problem, there will be 2\\n        #     groups of words, one of them of size 1\\n        for _, ws in eq.items():\\n            if len(ws) == 1:\\n                return ws[0]\\n```\\n\\n<iframe src=\"https://leetcode.com/playground/WWYKqVgx/shared\" frameBorder=\"0\" width=\"800\" height=\"500\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        \\n        # [1] as stated in the problem, there will be two groups \\n        #     of words according to their difference array;\\n        #     we\\'ll store them in a hashmap/dict using the\\n        #     difference array as a key\\n        eq = defaultdict(list)\\n        \\n        for w in words:\\n            # [2] in Python, keys are immutable, thus we convert\\n            #     the difference array to \\'tuple\\'\\n            diff = [ord(a)-ord(b) for a, b in zip(w[:-1], w[1:])]\\n            eq[tuple(diff)].append(w)\\n        \\n        # [3] as guaranteed in the problem, there will be 2\\n        #     groups of words, one of them of size 1\\n        for _, ws in eq.items():\\n            if len(ws) == 1:\\n                return ws[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756780,
                "title": "java-hashmap-explained",
                "content": "# **Please Upvote** :D\\nThe aim of this approach is to get hashmaps like these for every input:\\n![image](https://assets.leetcode.com/users/images/ae595111-4b4a-4620-bc2a-236f1fa6d17c_1667063178.6080215.png)\\n\\nFor each **difference list** that we come up with, we **map all the strings** as a list to that difference list **which gives that particular difference list**.\\n\\nLike in the image:\\nIn **test case 1**:\\nDifference list **`[1, 1]`** was given by **`\"abc\"`** while **`[3, -1]`** was given by **`\"adc\"`** and **`\"wzy\"`**.\\n\\nSo this way, for all test cases, there is going to be only 1 string that will give a different list (as mentioned in the problem statement).\\nSo at the end we iterate through the map and return that value where there is only 1 string mapped to the key.\\n*(if only 1 string as a list is mapped to a key then the length of that list (containing that single string) will be 1)*.\\n\\n``` java []\\nclass Solution {\\n    public String oddString(String[] words) {\\n        Map<List<Integer>, List<String>> map = new HashMap<>();\\n\\n        for (int i = 0; i < words.length; i++) {\\n            char[] ch = words[i].toCharArray();\\n            List<Integer> list = new ArrayList<>();\\n\\n            for (int j = 0; j < ch.length - 1; j++) {\\n                list.add(ch[j + 1] - ch[j]);\\n            }\\n\\n            if (map.containsKey(list)) {\\n                map.get(list).add(words[i]);\\n            }\\n            else {\\n                List<String> l = new ArrayList<>();\\n                l.add(words[i]);\\n                map.put(list, l);\\n            }\\n        }\\n\\n        for (List<Integer> key : map.keySet()) {\\n            if (map.get(key).size() == 1) {\\n                return map.get(key).get(0);\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n}\\n\\n// TC: O(n * k) => O(n) because k is constant\\n// n -> length of input array\\n// k -> length of strings in input array\\n\\n// SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "``` java []\\nclass Solution {\\n    public String oddString(String[] words) {\\n        Map<List<Integer>, List<String>> map = new HashMap<>();\\n\\n        for (int i = 0; i < words.length; i++) {\\n            char[] ch = words[i].toCharArray();\\n            List<Integer> list = new ArrayList<>();\\n\\n            for (int j = 0; j < ch.length - 1; j++) {\\n                list.add(ch[j + 1] - ch[j]);\\n            }\\n\\n            if (map.containsKey(list)) {\\n                map.get(list).add(words[i]);\\n            }\\n            else {\\n                List<String> l = new ArrayList<>();\\n                l.add(words[i]);\\n                map.put(list, l);\\n            }\\n        }\\n\\n        for (List<Integer> key : map.keySet()) {\\n            if (map.get(key).size() == 1) {\\n                return map.get(key).get(0);\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n}\\n\\n// TC: O(n * k) => O(n) because k is constant\\n// n -> length of input array\\n// k -> length of strings in input array\\n\\n// SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756419,
                "title": "check-one-by-one",
                "content": "No need to build difference arrays for each string.\\n\\nWe can an odd string by looking at one difference at a time.\\n\\n**C++**\\n```cpp\\nstring oddString(vector<string>& ws) {\\n    for (int j = 0; j + 1 < ws[0].size(); ++j) {\\n        unordered_map<int, vector<int>> m;\\n        for (int i = 0; i < ws.size(); ++i)\\n            m[ws[i][j + 1] - ws[i][j]].push_back(i);\\n        if (m.size() == 2)\\n            return ws[begin(m)->second.size() == 1 ? begin(m)->second.back() : next(begin(m))->second.back()];\\n    }\\n    return ws[0];\\n}\\n```\\n#### O(1) Memory\\n**C++**\\n```cpp\\nstring oddString(vector<string>& ws) {\\n    for (int j = 0; j + 1 < ws[0].size(); ++j) {\\n        unordered_map<int, vector<int>> m;\\n        for (int i = 0; i < ws.size(); ++i)\\n            if (m[ws[i][j + 1] - ws[i][j]].size() < 2)\\n                m[ws[i][j + 1] - ws[i][j]].push_back(i);\\n        if (m.size() == 2)\\n            return ws[begin(m)->second.size() == 1 ? begin(m)->second.back() : next(begin(m))->second.back()];\\n    }\\n    return ws[0];\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring oddString(vector<string>& ws) {\\n    for (int j = 0; j + 1 < ws[0].size(); ++j) {\\n        unordered_map<int, vector<int>> m;\\n        for (int i = 0; i < ws.size(); ++i)\\n            m[ws[i][j + 1] - ws[i][j]].push_back(i);\\n        if (m.size() == 2)\\n            return ws[begin(m)->second.size() == 1 ? begin(m)->second.back() : next(begin(m))->second.back()];\\n    }\\n    return ws[0];\\n}\\n```\n```cpp\\nstring oddString(vector<string>& ws) {\\n    for (int j = 0; j + 1 < ws[0].size(); ++j) {\\n        unordered_map<int, vector<int>> m;\\n        for (int i = 0; i < ws.size(); ++i)\\n            if (m[ws[i][j + 1] - ws[i][j]].size() < 2)\\n                m[ws[i][j + 1] - ws[i][j]].push_back(i);\\n        if (m.size() == 2)\\n            return ws[begin(m)->second.size() == 1 ? begin(m)->second.back() : next(begin(m))->second.back()];\\n    }\\n    return ws[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2763310,
                "title": "java-c-constant-space-no-hashmaps",
                "content": "# Intuition\\nSince we don\\'t need to return the differences we don\\'t need to store them or even calculate them; we only need to compare the differences one by one.\\n\\n# Approach\\nTake the first word from the input and see if its difference matches other words. If there is one word that doesn\\'t match, we return that word; if no other words match then the first word is the odd one out.\\n\\n# Complexity\\n- Time complexity: `O(n * m)` where `n` is the number of words and `m` is the length of words.\\n\\n- Space complexity: `O(1)` as we make no allocations and don\\'t use recursion.\\n\\n# Java\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int matchesFirst = 0;\\n        int mismatchIdx = -1;\\n        for (int i = 1; i < words.length; i++) {\\n            if (matchesDiff(words[0], words[i])) {\\n                matchesFirst++;\\n            } else {\\n                mismatchIdx = i;\\n            }\\n        }\\n        if (matchesFirst == 0) {\\n            return words[0];\\n        }\\n        return words[mismatchIdx];\\n    }\\n\\n    private static boolean matchesDiff(String a, String b) {\\n        for (int i = 0; i < a.length() - 1; i++) {\\n            if (a.charAt(i + 1) - a.charAt(i) != b.charAt(i + 1) - b.charAt(i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string oddString(const vector<string>& words) {\\n        int matchingFirst = 0;\\n        int mismatchIndex = 0;\\n        for (size_t i = 1; i < words.size(); i++) {\\n            if (matchesDiff(words[0], words[i])) {\\n                matchingFirst++;\\n            } else {\\n                mismatchIndex = i;\\n            }\\n        }\\n        return matchingFirst > 0 ? words[mismatchIndex] : words[0];\\n    }\\n\\nprivate:\\n    static bool matchesDiff(const std::string& a, const std::string& b) {\\n        for (size_t i = 0; i < a.length() - 1; i++) {\\n            if (a[i + 1] - a[i] != b[i + 1] - b[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int matchesFirst = 0;\\n        int mismatchIdx = -1;\\n        for (int i = 1; i < words.length; i++) {\\n            if (matchesDiff(words[0], words[i])) {\\n                matchesFirst++;\\n            } else {\\n                mismatchIdx = i;\\n            }\\n        }\\n        if (matchesFirst == 0) {\\n            return words[0];\\n        }\\n        return words[mismatchIdx];\\n    }\\n\\n    private static boolean matchesDiff(String a, String b) {\\n        for (int i = 0; i < a.length() - 1; i++) {\\n            if (a.charAt(i + 1) - a.charAt(i) != b.charAt(i + 1) - b.charAt(i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string oddString(const vector<string>& words) {\\n        int matchingFirst = 0;\\n        int mismatchIndex = 0;\\n        for (size_t i = 1; i < words.size(); i++) {\\n            if (matchesDiff(words[0], words[i])) {\\n                matchingFirst++;\\n            } else {\\n                mismatchIndex = i;\\n            }\\n        }\\n        return matchingFirst > 0 ? words[mismatchIndex] : words[0];\\n    }\\n\\nprivate:\\n    static bool matchesDiff(const std::string& a, const std::string& b) {\\n        for (size_t i = 0; i < a.length() - 1; i++) {\\n            if (a[i + 1] - a[i] != b[i + 1] - b[i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756590,
                "title": "python-easy-solution-readable",
                "content": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        hashmap = defaultdict(list)\\n        for w in words:\\n            difference = []\\n            for i in range(1,len(w)):\\n                difference.append(ord(w[i])-ord(w[i-1]))\\n            hashmap[tuple(difference)].append(w)\\n        for k,a in hashmap.items():\\n            if len(a) == 1:\\n                return a[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        hashmap = defaultdict(list)\\n        for w in words:\\n            difference = []\\n            for i in range(1,len(w)):\\n                difference.append(ord(w[i])-ord(w[i-1]))\\n            hashmap[tuple(difference)].append(w)\\n        for k,a in hashmap.items():\\n            if len(a) == 1:\\n                return a[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756932,
                "title": "very-simple-c-brute-force-complete-explanation",
                "content": "**The function score is finding the vector representing difference array for a string**\\n\\n**Now, I am iterating over words... so there are three possibilities.**\\n**1.  one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2.  If the left string (0th index) is the answer then score for ith (i==0 in this case)  string is different from score for (i+1)th string.\\n\\n**3.  Else last string will be the answer---> No need of any check just return the last string.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756335,
                "title": "c-brute-force-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& v1) {\\n        int n = v1.size(), m = v1[0].size();\\n        string ans = \"\";\\n        map<vector<int>, vector<string>> m1;\\n        for(auto &it: v1){\\n            vector<int> a;\\n            for(int i=1; i<m; i++)          a.push_back(it[i]-it[i-1]);\\n            m1[a].push_back(it);\\n        }\\n        for(auto &it: m1){\\n            if(it.second.size()==1) {\\n                ans = it.second[0];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& v1) {\\n        int n = v1.size(), m = v1[0].size();\\n        string ans = \"\";\\n        map<vector<int>, vector<string>> m1;\\n        for(auto &it: v1){\\n            vector<int> a;\\n            for(int i=1; i<m; i++)          a.push_back(it[i]-it[i-1]);\\n            m1[a].push_back(it);\\n        }\\n        for(auto &it: m1){\\n            if(it.second.size()==1) {\\n                ans = it.second[0];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756767,
                "title": "python-3-3-lines-t-m-37ms-13-8-mb",
                "content": "Note that words.length <= 100, so O(nlogn) works just fine.\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n\\n        diff = lambda x: [ord(x[j])-ord(x[j-1]) for j in range(1,len(x))]\\n\\n        words.sort(key = diff)\\n\\n        return words[0] if diff(words[0]) != diff(words[1]) else words[-1]\\n```\\n[https://leetcode.com/submissions/detail/832790709/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n\\n        diff = lambda x: [ord(x[j])-ord(x[j-1]) for j in range(1,len(x))]\\n\\n        words.sort(key = diff)\\n\\n        return words[0] if diff(words[0]) != diff(words[1]) else words[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865554,
                "title": "java-brute-force-easy-to-understand-with-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWith HashMap\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public String oddString(String[] words) {\\n        Map<List<Integer>, Integer> map = new HashMap<>();\\n        int n = words.length;\\n        for(int i=0; i<n; i++){\\n            List<Integer> arr = new ArrayList<Integer>();\\n            for(int j=0; j<words[i].length()-1; j++){\\n                arr.add(words[i].charAt(j+1) - words[i].charAt(j));\\n            }\\n            // System.out.println(Arrays.toString(arr));\\n            Integer temp = map.getOrDefault(arr,0);\\n            map.put(arr,temp+1);\\n        }\\n\\n        // System.out.println(map);\\n        List<Integer> ans = new ArrayList<Integer>();\\n        for(Map.Entry<List<Integer>, Integer> m : map.entrySet()){\\n            if(m.getValue() == 1)\\n                ans = m.getKey();\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            List<Integer> arr = new ArrayList<Integer>();\\n            for(int j=0; j<words[i].length()-1; j++){\\n                arr.add(words[i].charAt(j+1) - words[i].charAt(j));\\n            }\\n            // System.out.println(Arrays.toString(arr));\\n            if(arr.equals(ans)) return words[i];\\n        }\\n\\n        System.out.println(ans);\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String oddString(String[] words) {\\n        Map<List<Integer>, Integer> map = new HashMap<>();\\n        int n = words.length;\\n        for(int i=0; i<n; i++){\\n            List<Integer> arr = new ArrayList<Integer>();\\n            for(int j=0; j<words[i].length()-1; j++){\\n                arr.add(words[i].charAt(j+1) - words[i].charAt(j));\\n            }\\n            // System.out.println(Arrays.toString(arr));\\n            Integer temp = map.getOrDefault(arr,0);\\n            map.put(arr,temp+1);\\n        }\\n\\n        // System.out.println(map);\\n        List<Integer> ans = new ArrayList<Integer>();\\n        for(Map.Entry<List<Integer>, Integer> m : map.entrySet()){\\n            if(m.getValue() == 1)\\n                ans = m.getKey();\\n        }\\n\\n        for(int i=0; i<n; i++){\\n            List<Integer> arr = new ArrayList<Integer>();\\n            for(int j=0; j<words[i].length()-1; j++){\\n                arr.add(words[i].charAt(j+1) - words[i].charAt(j));\\n            }\\n            // System.out.println(Arrays.toString(arr));\\n            if(arr.equals(ans)) return words[i];\\n        }\\n\\n        System.out.println(ans);\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756495,
                "title": "javascript-map-tc-o-n-sc-o-n",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar oddString = function(words) {\\n    const map = {};\\n    const ans = {};\\n    \\n    for (const word of words) {\\n        let key = \\'\\';\\n        for (let i = 1; i < word.length; i++) {\\n            key += `_${word[i].charCodeAt() - word[i-1].charCodeAt()}`;\\n        }\\n        map[key] = ++map[key] || 1;\\n        ans[key] = word;\\n    }\\n    \\n    const key = Object.keys(map).find(e => map[e] === 1);\\n    \\n    return ans[key];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar oddString = function(words) {\\n    const map = {};\\n    const ans = {};\\n    \\n    for (const word of words) {\\n        let key = \\'\\';\\n        for (let i = 1; i < word.length; i++) {\\n            key += `_${word[i].charCodeAt() - word[i-1].charCodeAt()}`;\\n        }\\n        map[key] = ++map[key] || 1;\\n        ans[key] = word;\\n    }\\n    \\n    const key = Object.keys(map).find(e => map[e] === 1);\\n    \\n    return ans[key];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2756430,
                "title": "return-with-count-1",
                "content": "The difference array converted to a string will be mapped to:\\n- number of strings of which its a difference array of.\\n- The latest string of which this was a differnce array.\\n    \\nWe will convert our difference array to string for getting better time complexity to place it in a hashset.\\nAfter the operation we will return the keys second parameter whose count is 1.\\n\\n# C++\\n\\n    string oddString(vector<string>& words){\\n         unordered_map<string, pair<int, string>> mp;\\n         for (auto w: words){\\n              string p;\\n              for (int j = 0; j + 1 < w.size(); j++)\\n                  p += to_string((w[j + 1] - \\'0\\') - (w[j] - \\'0\\')) + \" \";\\n              mp[p].first++;\\n              mp[p].second = w;\\n         }\\n\\n         for (auto i: mp)\\n             if (i.second.first == 1) return i.second.second;\\n\\n         return \"\";\\n      }\\n\\n**Time** - O(n * m)\\n**Space** - O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "The difference array converted to a string will be mapped to:\\n- number of strings of which its a difference array of.\\n- The latest string of which this was a differnce array.\\n    \\nWe will convert our difference array to string for getting better time complexity to place it in a hashset.\\nAfter the operation we will return the keys second parameter whose count is 1.\\n\\n# C++\\n\\n    string oddString(vector<string>& words){\\n         unordered_map<string, pair<int, string>> mp;\\n         for (auto w: words){\\n              string p;\\n              for (int j = 0; j + 1 < w.size(); j++)\\n                  p += to_string((w[j + 1] - \\'0\\') - (w[j] - \\'0\\')) + \" \";\\n              mp[p].first++;\\n              mp[p].second = w;\\n         }\\n\\n         for (auto i: mp)\\n             if (i.second.first == 1) return i.second.second;\\n\\n         return \"\";\\n      }\\n\\n**Time** - O(n * m)\\n**Space** - O(1)",
                "codeTag": "Unknown"
            },
            {
                "id": 2756363,
                "title": "is-it-a-easy-problem",
                "content": "**Approach:**\\nStep-1 : Calculate difference array for each word and store it into mp (2-d vector).\\nsteop-2 : Compare each difference array with others difference array if they are not equal increase count of their index in vector count.\\nstep-3 : Iterate in count vector and find max value index that\\'s the answer.\\n\\n\\n```\\nclass Solution \\n{\\npublic:\\n    string oddString(vector<string>& words) \\n    {\\n        int w_size=words[0].size();\\n        int n=words.size();\\n        \\n\\t\\t//step-1\\n\\t\\tvector<int> temp(w_size-1);\\n        vector<vector<int>> mp;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<w_size-1; j++)\\n            {\\n                temp[j] = words[i][j+1]-words[i][j];\\n            }\\n            mp.push_back(temp);\\n        }\\n        \\n        //step-2\\n        vector<int> count(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(mp[i] != mp[j])\\n                {\\n                    count[i]++;\\n                    count[j]++;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//step-3\\n        int maxi=INT_MIN, idx;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(count[i] > maxi)\\n            {\\n                maxi = count[i];\\n                idx = i;\\n            }\\n        }\\n        return words[idx];\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string oddString(vector<string>& words) \\n    {\\n        int w_size=words[0].size();\\n        int n=words.size();\\n        \\n\\t\\t//step-1\\n\\t\\tvector<int> temp(w_size-1);\\n        vector<vector<int>> mp;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<w_size-1; j++)\\n            {\\n                temp[j] = words[i][j+1]-words[i][j];\\n            }\\n            mp.push_back(temp);\\n        }\\n        \\n        //step-2\\n        vector<int> count(n);\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(mp[i] != mp[j])\\n                {\\n                    count[i]++;\\n                    count[j]++;\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t//step-3\\n        int maxi=INT_MIN, idx;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(count[i] > maxi)\\n            {\\n                maxi = count[i];\\n                idx = i;\\n            }\\n        }\\n        return words[idx];\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774188,
                "title": "easy-to-understand-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        k=len(words[0])\\n        arr=[]\\n        for i in words:\\n            l=[]\\n            for j in range(1,k):\\n                diff=ord(i[j])-ord(i[j-1])\\n                l.append(diff)\\n            arr.append(l)\\n        for i in range(len(arr)):\\n            if arr.count(arr[i])==1:\\n                return words[i]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        k=len(words[0])\\n        arr=[]\\n        for i in words:\\n            l=[]\\n            for j in range(1,k):\\n                diff=ord(i[j])-ord(i[j-1])\\n                l.append(diff)\\n            arr.append(l)\\n        for i in range(len(arr)):\\n            if arr.count(arr[i])==1:\\n                return words[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756698,
                "title": "c-vector",
                "content": "**Approach 1:** 2D Vector\\n\\n    string oddString(vector<string>& words) {\\n        int n = words.size(); \\n        vector<vector<int>> v(n); \\n        \\n        for (int i = 0; i < n; i++) //store difference\\n            for (int j = 0; j < words[0].size()-1; j++)\\n                v[i].push_back(words[i][j+1] - words[i][j]);\\n        \\n        for (int i = 0; i < v.size(); i++)\\n        {\\n            int notEqual = 0;\\n            for (int j = 0; j < 3; j++)\\n                if (v[i] != v[j])\\n                    if (++notEqual > 1) return words[i];\\n        }\\n        return \"\";\\n    }\\n**Approach 2:** Vector\\t\\n\\t\\n    string oddString(vector<string>& words) {\\n        int n = words.size(); \\n        vector<int> v(n); //store difference\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            int diff = 0;\\n            for (int j = 0; j < words[0].size()-1; j++)\\n                diff = (10 * diff) + (words[i][j+1] - words[i][j]);\\n            v[i] = diff;\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            int notEqual = 0;\\n            for (int j = 0; j < 3; j++)\\n                if (v[i] != v[j])\\n                    if (++notEqual > 1) return words[i];\\n        }\\n        return \"\";\\n    }\\t\\n//\\tApproach 3: Using map",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**Approach 1:** 2D Vector\\n\\n    string oddString(vector<string>& words) {\\n        int n = words.size(); \\n        vector<vector<int>> v(n); \\n        \\n        for (int i = 0; i < n; i++) //store difference\\n            for (int j = 0; j < words[0].size()-1; j++)\\n                v[i].push_back(words[i][j+1] - words[i][j]);\\n        \\n        for (int i = 0; i < v.size(); i++)\\n        {\\n            int notEqual = 0;\\n            for (int j = 0; j < 3; j++)\\n                if (v[i] != v[j])\\n                    if (++notEqual > 1) return words[i];\\n        }\\n        return \"\";\\n    }\\n**Approach 2:** Vector\\t\\n\\t\\n    string oddString(vector<string>& words) {\\n        int n = words.size(); \\n        vector<int> v(n); //store difference\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            int diff = 0;\\n            for (int j = 0; j < words[0].size()-1; j++)\\n                diff = (10 * diff) + (words[i][j+1] - words[i][j]);\\n            v[i] = diff;\\n        }\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            int notEqual = 0;\\n            for (int j = 0; j < 3; j++)\\n                if (v[i] != v[j])\\n                    if (++notEqual > 1) return words[i];\\n        }\\n        return \"\";\\n    }\\t\\n//\\tApproach 3: Using map",
                "codeTag": "Unknown"
            },
            {
                "id": 2756372,
                "title": "c-easy-to-understand-2-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<vector<int>, int> mp;\\n        int n = words.size();\\n        int m = words[0].size();\\n        map<vector<int>, string> toMark;\\n        for(int i = 0; i < n; i++) {\\n            vector<int> temp(m - 1);\\n            for(int j = 1; j < m; j++) {\\n                int diff = words[i][j] - words[i][j - 1];\\n                temp[j - 1] = diff;\\n            }\\n            mp[temp] += 1;\\n            toMark[temp] = words[i];\\n        }\\n        string res;\\n        for(auto it: mp) {\\n            if(it.second == 1) {\\n                return res = toMark[it.first];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<vector<int>, int> mp;\\n        int n = words.size();\\n        int m = words[0].size();\\n        map<vector<int>, string> toMark;\\n        for(int i = 0; i < n; i++) {\\n            vector<int> temp(m - 1);\\n            for(int j = 1; j < m; j++) {\\n                int diff = words[i][j] - words[i][j - 1];\\n                temp[j - 1] = diff;\\n            }\\n            mp[temp] += 1;\\n            toMark[temp] = words[i];\\n        }\\n        string res;\\n        for(auto it: mp) {\\n            if(it.second == 1) {\\n                return res = toMark[it.first];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159928,
                "title": "easy-c-very-unique-using-map-well-commented",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStore words and differences obtained - Vector\\nMap words to their differences in form of strings - Pair\\nFrequency of occurance - Map\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince the question required us to find the odd one out from the differences, frequency of occurance must be known. So, the data structure used is map along with vector of pair to store the word and the difference in form of string. Finally check which word has frequency as 1, because all others will have frequency of occurance more than one. So, the difference string with frequency=1, the word corresponding to it, is the ans.\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int n=words.size(); //no of words\\n        int m=words[0].size(); //length of each word\\n\\n        vector<pair<string, string>> res; //store pair and diff string\\n        map<string, int> mp; //to find freq of occurance\\n        // to find odd one out\\n\\n        string ans=\"\";\\n        for(int i=0; i<n; i++){\\n            ans=\"\"; //re-initialize to empty string\\n            for(int j=0; j<m-1; j++){\\n                ans+=to_string((words[i][j+1]-\\'0\\')-(words[i][j]-\\'0\\')); //difference of consecutive characters \\n//convert to string for easy comparison\\n                ans += \\',\\'; //to distinguish between cases 11,1 and 1,11 coz in string both 111 and 111 are same.\\n            }\\n            // cout<<ans<<endl;\\n            res.push_back({words[i], ans}); \\n            mp[ans]++; //increase freq\\n        }\\n\\n        string com=\"\";\\n        for(auto it: mp){\\n            if(it.second==1){ \\n                //check if frequency=1, if so -> odd one out coz others have freq>1\\n                com+=it.first; //store the difference string\\n                break;\\n            }\\n        }\\n        for(auto it: res){\\n            if(it.second==com){\\n                //print the word corresponding to that difference string\\n                return it.first;\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int n=words.size(); //no of words\\n        int m=words[0].size(); //length of each word\\n\\n        vector<pair<string, string>> res; //store pair and diff string\\n        map<string, int> mp; //to find freq of occurance\\n        // to find odd one out\\n\\n        string ans=\"\";\\n        for(int i=0; i<n; i++){\\n            ans=\"\"; //re-initialize to empty string\\n            for(int j=0; j<m-1; j++){\\n                ans+=to_string((words[i][j+1]-\\'0\\')-(words[i][j]-\\'0\\')); //difference of consecutive characters \\n//convert to string for easy comparison\\n                ans += \\',\\'; //to distinguish between cases 11,1 and 1,11 coz in string both 111 and 111 are same.\\n            }\\n            // cout<<ans<<endl;\\n            res.push_back({words[i], ans}); \\n            mp[ans]++; //increase freq\\n        }\\n\\n        string com=\"\";\\n        for(auto it: mp){\\n            if(it.second==1){ \\n                //check if frequency=1, if so -> odd one out coz others have freq>1\\n                com+=it.first; //store the difference string\\n                break;\\n            }\\n        }\\n        for(auto it: res){\\n            if(it.second==com){\\n                //print the word corresponding to that difference string\\n                return it.first;\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2867638,
                "title": "python-ord-time-o-n-2",
                "content": "https://leetcode.com/submissions/detail/853029967/\\n```\\nRuntime: 54 ms, faster than 74.05% of Python3 online submissions for Odd String Difference.\\nMemory Usage: 13.8 MB, less than 78.50% of Python3 online submissions for Odd String Difference.\\n```\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        def get_differences(word):\\n            return [ord(word[j])-ord(word[j+1]) for j in range(len(word)-1)]\\n        \\n        d1, d2, d3 = get_differences(words[0]), get_differences(words[1]), get_differences(words[2])\\n        if d1==d2 and d2!=d3: return words[2] \\n        if d1==d3 and d1!=d2: return words[1]\\n        if d2==d3 and d1!=d2: return words[0]\\n        \\n        for word in words[3:]:\\n            if get_differences(word)!=d1:\\n                return word\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nRuntime: 54 ms, faster than 74.05% of Python3 online submissions for Odd String Difference.\\nMemory Usage: 13.8 MB, less than 78.50% of Python3 online submissions for Odd String Difference.\\n```\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        def get_differences(word):\\n            return [ord(word[j])-ord(word[j+1]) for j in range(len(word)-1)]\\n        \\n        d1, d2, d3 = get_differences(words[0]), get_differences(words[1]), get_differences(words[2])\\n        if d1==d2 and d2!=d3: return words[2] \\n        if d1==d3 and d1!=d2: return words[1]\\n        if d2==d3 and d1!=d2: return words[0]\\n        \\n        for word in words[3:]:\\n            if get_differences(word)!=d1:\\n                return word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838972,
                "title": "simple-and-precise-java-solution",
                "content": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int n = words[0].length();\\n        // Taking first 3 arrays for checking the difference\\n        int[] nums0 = new int[n];\\n        int[] nums1 = new int[n];\\n        int[] nums2 = new int[n];\\n\\n        // Find the difference integer array for first three strings.\\n        for (int i = 0; i < n - 1; i++) {\\n            nums0[i] = words[0].charAt(i + 1) - words[0].charAt(i);\\n            nums1[i] = words[1].charAt(i + 1) - words[1].charAt(i);\\n            nums2[i] = words[2].charAt(i + 1) - words[2].charAt(i);\\n        }\\n        // Check if there is any odd, then we have found the answer and no need of further checking rest of the strings in the array\\n        if (Arrays.equals(nums0, nums1) && !Arrays.equals(nums0, nums2)) return words[2];\\n        if (Arrays.equals(nums0, nums2) && !Arrays.equals(nums1, nums2)) return words[1];\\n        if (Arrays.equals(nums2, nums1) && !Arrays.equals(nums0, nums2)) return words[0];\\n\\n        // If all above are equal, then it means that the ans is in the remainder of the strings\\n        // Thus iterating over Strings and find first odd one\\n        for (int j = 3; j < words.length; j++) {\\n            int[] temp = new int[n];\\n            for (int i = 0; i < n - 1; i++) {\\n                temp[i] = words[j].charAt(i + 1) - words[j].charAt(i);\\n            }\\n            if (!Arrays.equals(nums0, temp)) return words[j];\\n        }\\n        return words[0];//As it is guaranteed that there is an ans, the code will never reach at this point\\n        //So, just adding the return statement to complete the code\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public String oddString(String[] words) {\\n        int n = words[0].length();\\n        // Taking first 3 arrays for checking the difference\\n        int[] nums0 = new int[n];\\n        int[] nums1 = new int[n];\\n        int[] nums2 = new int[n];\\n\\n        // Find the difference integer array for first three strings.\\n        for (int i = 0; i < n - 1; i++) {\\n            nums0[i] = words[0].charAt(i + 1) - words[0].charAt(i);\\n            nums1[i] = words[1].charAt(i + 1) - words[1].charAt(i);\\n            nums2[i] = words[2].charAt(i + 1) - words[2].charAt(i);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2762197,
                "title": "java-odd-string-difference",
                "content": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        Map<String,Integer> map=new HashMap<>();\\n        Map<String,String> m=new HashMap<>();\\n        for(String s:words)\\n        {\\n            String str=\"\";\\n            for(int i=1;i<s.length();i++){\\n                str+=((s.charAt(i)-\\'a\\')-(s.charAt(i-1)-\\'a\\'));\\n                str+=\" \";\\n            }\\n            m.put(str,s);\\n            map.put(str,map.getOrDefault(str,0)+1);\\n        }\\n        //System.out.println(m);\\n         //System.out.println(map);\\n        \\n        for(String s1:map.keySet()){\\n            if(map.get(s1)==1)return m.get(s1);\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        Map<String,Integer> map=new HashMap<>();\\n        Map<String,String> m=new HashMap<>();\\n        for(String s:words)\\n        {\\n            String str=\"\";\\n            for(int i=1;i<s.length();i++){\\n                str+=((s.charAt(i)-\\'a\\')-(s.charAt(i-1)-\\'a\\'));\\n                str+=\" \";\\n            }\\n            m.put(str,s);\\n            map.put(str,map.getOrDefault(str,0)+1);\\n        }\\n        //System.out.println(m);\\n         //System.out.println(map);\\n        \\n        for(String s1:map.keySet()){\\n            if(map.get(s1)==1)return m.get(s1);\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756844,
                "title": "c-linq-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can group words by their difference arrays and pick the group with one item.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLinq quertu\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * word.Length)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n * word.Length)\\n\\n# Code\\n```\\npublic class Solution {\\n    public string OddString(string[] words) => words\\n            .GroupBy(word => string.Join(\",\", Enumerable\\n                .Range(0, word.Length - 1)\\n                .Select(i => word[i] - word[i + 1])))\\n            .Where(group => group.Count() == 1)\\n            .First()\\n            .First();        \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string OddString(string[] words) => words\\n            .GroupBy(word => string.Join(\",\", Enumerable\\n                .Range(0, word.Length - 1)\\n                .Select(i => word[i] - word[i + 1])))\\n            .Where(group => group.Count() == 1)\\n            .First()\\n            .First();        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3564510,
                "title": "2-liner-in-python-for-fun",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        a = [[ord(s[i])-ord(s[i-1]) for i in range(1,len(s))] for s in words]\\n        return words[a.index(*[arr for arr in a if a.count(arr) == 1])]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        a = [[ord(s[i])-ord(s[i-1]) for i in range(1,len(s))] for s in words]\\n        return words[a.index(*[arr for arr in a if a.count(arr) == 1])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046413,
                "title": "easy-c-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<string,int> mp;\\n        map<string,string> ms;\\n        vector<long> v(words[0].size()-1);\\n        string s;\\n        for(int i=0;i<words.size();i++){\\n            s=\"\";\\n            for(int j=0;j<words[i].size()-1;j++){\\n                int t=words[i][j+1]-words[i][j];\\n                s+=to_string(t)+\"_\";\\n                }\\n            mp[s]++;\\n            ms[s]=words[i];\\n        }\\n      \\n        for ( auto i: mp){\\n            if(i.second==1)\\n            {\\n                return ms[i.first];\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<string,int> mp;\\n        map<string,string> ms;\\n        vector<long> v(words[0].size()-1);\\n        string s;\\n        for(int i=0;i<words.size();i++){\\n            s=\"\";\\n            for(int j=0;j<words[i].size()-1;j++){\\n                int t=words[i][j+1]-words[i][j];\\n                s+=to_string(t)+\"_\";\\n                }\\n            mp[s]++;\\n            ms[s]=words[i];\\n        }\\n      \\n        for ( auto i: mp){\\n            if(i.second==1)\\n            {\\n                return ms[i.first];\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031594,
                "title": "easy-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        \\n        map<vector<int>,int>mp;\\n        map<vector<int>,string>mp1;\\n        \\n          for(auto i:words){\\n              vector<int>v;\\n              for(int j=1;j<i.size();j++){\\n                  \\n                   int ans=i[j]-i[j-1];\\n                  \\n                   v.push_back(ans);\\n              }\\n             mp[v]++;\\n              mp1.insert({v,i});\\n          }\\n        vector<int>v1;\\n        string s=\"\"; \\n        \\n       for(auto i:mp){\\n           \\n           if(i.second==1){\\n             s= mp1[i.first];\\n               break;\\n           }\\n       }\\n     \\n       \\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        \\n        map<vector<int>,int>mp;\\n        map<vector<int>,string>mp1;\\n        \\n          for(auto i:words){\\n              vector<int>v;\\n              for(int j=1;j<i.size();j++){\\n                  \\n                   int ans=i[j]-i[j-1];\\n                  \\n                   v.push_back(ans);\\n              }\\n             mp[v]++;\\n              mp1.insert({v,i});\\n          }\\n        vector<int>v1;\\n        string s=\"\"; \\n        \\n       for(auto i:mp){\\n           \\n           if(i.second==1){\\n             s= mp1[i.first];\\n               break;\\n           }\\n       }\\n     \\n       \\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2865375,
                "title": "java-2ms-solution",
                "content": "1. Create and fill array to calculate differences.\\n2. In the second for loop I find the index of word with distinct differences by comparing adjacent 1d arrays inside 2d array.\\n# Code\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int[][] arr = new int[words.length][words[0].length() - 1];\\n        for (int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            for (int j = 0; j < word.length() - 1; j++) {\\n                arr[i][j] = word.charAt(j + 1) - word.charAt(j);\\n            }\\n        }\\n\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            for (int j = 0; j < arr[0].length; j++) {\\n                if (arr[i - 1][j] != arr[i][j] && arr[i][j] != arr[i + 1][j]) {\\n                    return words[i];\\n                } else if (arr[i - 1][j] != arr[i][j]) {\\n                    return words[i - 1];\\n                } else if (arr[i + 1][j] != arr[i][j]) {\\n                    return words[i + 1];\\n                }\\n            }\\n        }\\n        return words[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int[][] arr = new int[words.length][words[0].length() - 1];\\n        for (int i = 0; i < words.length; i++) {\\n            String word = words[i];\\n            for (int j = 0; j < word.length() - 1; j++) {\\n                arr[i][j] = word.charAt(j + 1) - word.charAt(j);\\n            }\\n        }\\n\\n        for (int i = 1; i < arr.length - 1; i++) {\\n            for (int j = 0; j < arr[0].length; j++) {\\n                if (arr[i - 1][j] != arr[i][j] && arr[i][j] != arr[i + 1][j]) {\\n                    return words[i];\\n                } else if (arr[i - 1][j] != arr[i][j]) {\\n                    return words[i - 1];\\n                } else if (arr[i + 1][j] != arr[i][j]) {\\n                    return words[i + 1];\\n                }\\n            }\\n        }\\n        return words[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2806885,
                "title": "upvote-please",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        var map=new HashMap<List<Integer>,List<String>>();\\n        for(var v:words){\\n            char chars[]=v.toCharArray();\\n            var intlist=new ArrayList<Integer>();\\n            for(int i=0;i<chars.length-1;i++){\\n                intlist.add(chars[i+1]-chars[i]);\\n            }\\n            if(map.containsKey(intlist)) map.get(intlist).add(v);\\n            else {\\n                var strList = new ArrayList<String>();\\n                strList.add(v);\\n                map.put(intlist,strList);\\n            }\\n        }\\n\\n        for(var v:map.keySet()){\\n            var oddString =map.get(v);\\n            if(oddString.size()==1) return oddString.get(0);\\n        }\\n        throw null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        var map=new HashMap<List<Integer>,List<String>>();\\n        for(var v:words){\\n            char chars[]=v.toCharArray();\\n            var intlist=new ArrayList<Integer>();\\n            for(int i=0;i<chars.length-1;i++){\\n                intlist.add(chars[i+1]-chars[i]);\\n            }\\n            if(map.containsKey(intlist)) map.get(intlist).add(v);\\n            else {\\n                var strList = new ArrayList<String>();\\n                strList.add(v);\\n                map.put(intlist,strList);\\n            }\\n        }\\n\\n        for(var v:map.keySet()){\\n            var oddString =map.get(v);\\n            if(oddString.size()==1) return oddString.get(0);\\n        }\\n        throw null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801299,
                "title": "cpp-solution-using-map-of-vectors",
                "content": "# Approach\\nAs the question given tells us that,\\n  **difference[i][j] = words[i][j+1] - words[i][j]**\\n\\n-> The idea is to create a Hashmap with a Vector as Key and Vector as its value, we will store the difference of each letter of a particular word and store it in the Key vector (*In order to find the unique element easily*)\\n\\n-> Then we store that string(word) into the Value vector of the map.\\n\\n-> Once we traversed in all the string We will traverse in map to find the unique element. \\n\\n-> All the strings in words have the same difference integer array, except one.\\n\\n# Complexity\\n- Time complexity: O(n2), 21.79% better than online Cpp submissions\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 34.53% better than online Cpp submissions\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& s) {\\n        map<vector<int>,vector<string>> mp;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            vector<int> g;\\n            for(int j=0;j<s[i].size()-1;j++)\\n            {\\n               g.push_back(s[i][j+1]-s[i][j]);\\n            }\\n            mp[g].push_back(s[i]);\\n        }\\n        string g;\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n// The value which contains only one string in it is our unique string \\n           if(itr->second.size()==1)\\n           {\\n              g=itr->second[0];\\n              break;\\n           }\\n        }\\n   return g; }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& s) {\\n        map<vector<int>,vector<string>> mp;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            vector<int> g;\\n            for(int j=0;j<s[i].size()-1;j++)\\n            {\\n               g.push_back(s[i][j+1]-s[i][j]);\\n            }\\n            mp[g].push_back(s[i]);\\n        }\\n        string g;\\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n// The value which contains only one string in it is our unique string \\n           if(itr->second.size()==1)\\n           {\\n              g=itr->second[0];\\n              break;\\n           }\\n        }\\n   return g; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799333,
                "title": "hash-the-difference",
                "content": "# Intuition\\nAs we need ot compute a difference Array and identify strings by it only.\\nSo we hash the difference array only and find the cound of each; the res is whose differnece array freqency is `1`.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nHash function hashes the string into difference array. which we use as a key.\\nThen we identify the differce array whose frequency is 1.\\nusing the difference array we identify the string and return it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n`m` : `words.length`\\n`n` : `words[i].length`\\n- Time complexity: *`O(m*n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n\\n    vector<int> hash(string& word) {\\n        vector<int> diff;\\n        for(int i = 0; i < n - 1; i++)\\n            diff.push_back(word[i + 1] - word[i]);\\n        return diff;\\n    }\\n    \\n    string oddString(vector<string>& words) {\\n        n = words[0].length();\\n        map<vector<int>, int> feq;\\n        for(string& word: words)\\n            feq[hash(word)]++;\\n        vector<int> ans;\\n        for(auto& it: feq)\\n            if(it.second == 1)\\n                ans = it.first;\\n        for(string& word: words)\\n            if(hash(word) == ans)\\n                return word;\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n\\n    vector<int> hash(string& word) {\\n        vector<int> diff;\\n        for(int i = 0; i < n - 1; i++)\\n            diff.push_back(word[i + 1] - word[i]);\\n        return diff;\\n    }\\n    \\n    string oddString(vector<string>& words) {\\n        n = words[0].length();\\n        map<vector<int>, int> feq;\\n        for(string& word: words)\\n            feq[hash(word)]++;\\n        vector<int> ans;\\n        for(auto& it: feq)\\n            if(it.second == 1)\\n                ans = it.first;\\n        for(string& word: words)\\n            if(hash(word) == ans)\\n                return word;\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2786608,
                "title": "java-o-n-solution-using-hashmap-with-explanation",
                "content": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        Map<List<Integer>, List<String>> stringMap = new HashMap<>();\\n        for(String string: words) {\\n            List<Integer> diffs = new ArrayList<>();\\n            char[] chars = string.toCharArray();\\n\\t\\t\\t// Calculate the diff between each characters in the string and add these diffs to a list\\n            for(int i = 0; i < chars.length - 1; i++) {\\n                int diff = (chars[i + 1] - \\'a\\') - (chars[i] - \\'a\\');\\n                diffs.add(diff);\\n            }\\n\\t\\t\\t// Check if the same list exists in the map then add the word to the list of words that have this diff.\\n\\t\\t\\t// Otherwise create a new entry with the diff and the word\\n            if (stringMap.containsKey(diffs)) {\\n                List<String> values = stringMap.get(diffs);\\n                values.add(string);\\n                stringMap.put(diffs, values);\\n            } else {\\n                List<String> values = new ArrayList<>();\\n                values.add(string);\\n                stringMap.put(diffs, values);\\n            }\\n        }\\n\\t\\t// Iterate through the map and check for the odd string. \\n\\t\\t// Since there is only one odd string there will be a key whose value would be a list of size 1.\\n        for(List<Integer> list: stringMap.keySet()) {\\n            if (stringMap.get(list).size() == 1) {\\n                return stringMap.get(list).get(0);\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        Map<List<Integer>, List<String>> stringMap = new HashMap<>();\\n        for(String string: words) {\\n            List<Integer> diffs = new ArrayList<>();\\n            char[] chars = string.toCharArray();\\n\\t\\t\\t// Calculate the diff between each characters in the string and add these diffs to a list\\n            for(int i = 0; i < chars.length - 1; i++) {\\n                int diff = (chars[i + 1] - \\'a\\') - (chars[i] - \\'a\\');\\n                diffs.add(diff);\\n            }\\n\\t\\t\\t// Check if the same list exists in the map then add the word to the list of words that have this diff.\\n\\t\\t\\t// Otherwise create a new entry with the diff and the word\\n            if (stringMap.containsKey(diffs)) {\\n                List<String> values = stringMap.get(diffs);\\n                values.add(string);\\n                stringMap.put(diffs, values);\\n            } else {\\n                List<String> values = new ArrayList<>();\\n                values.add(string);\\n                stringMap.put(diffs, values);\\n            }\\n        }\\n\\t\\t// Iterate through the map and check for the odd string. \\n\\t\\t// Since there is only one odd string there will be a key whose value would be a list of size 1.\\n        for(List<Integer> list: stringMap.keySet()) {\\n            if (stringMap.get(list).size() == 1) {\\n                return stringMap.get(list).get(0);\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759638,
                "title": "c-std-adjacent-difference",
                "content": "### Approach 1: ```std::adjacent_difference``` and hash map\\n\\nInstead of a raw loop we can use ```std::adjacent_difference``` to compute the signature for each word, we only need to set the first element to zero and that we are just counting how often we are seeing a given signatur and keep track of the index of the first word with a given signatur.\\n\\n```cpp\\n    static string oddString(const vector<string>& words) {\\n        unordered_map<string, pair<int, int>> m;\\n        for (int i = 0; i < size(words); ++i) {\\n            string sig{words[i]};\\n            adjacent_difference(begin(sig), end(sig), begin(sig));\\n            sig[0] = 0;\\n            auto& p = m[sig];\\n            if (!p.first++) p.second = i;\\n        }\\n        for (auto& [k, p] : m) if (p.first == 1) return words[p.second];\\n        \\n        // unreachable\\n        assert(false);\\n        return \"\";\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the total number of characters in the input then the\\n  * Time complexity is $$O(n)$$ as we need to look at all the characters in the input a constant number of times and the\\n  * Space complexity is $$O(n)$$ to keep track of all the signaturs in a hash map.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```std::adjacent_difference```\n```std::adjacent_difference```\n```cpp\\n    static string oddString(const vector<string>& words) {\\n        unordered_map<string, pair<int, int>> m;\\n        for (int i = 0; i < size(words); ++i) {\\n            string sig{words[i]};\\n            adjacent_difference(begin(sig), end(sig), begin(sig));\\n            sig[0] = 0;\\n            auto& p = m[sig];\\n            if (!p.first++) p.second = i;\\n        }\\n        for (auto& [k, p] : m) if (p.first == 1) return words[p.second];\\n        \\n        // unreachable\\n        assert(false);\\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2758328,
                "title": "c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<vector<int>,vector<string> > m;\\n        int l=words.size();\\n        string t = \"\";\\n        for(int i=0; i<l; ++i){\\n            vector<int> v;\\n            for(int j=0; j<words[i].size()-1; ++j){\\n                v.push_back(words[i][j+1]-words[i][j]);\\n            }\\n            m[v].push_back(words[i]);\\n        }\\n        for(auto& itr : m){\\n            if(itr.second.size() == 1){\\n                t = itr.second[0];\\n                break;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<vector<int>,vector<string> > m;\\n        int l=words.size();\\n        string t = \"\";\\n        for(int i=0; i<l; ++i){\\n            vector<int> v;\\n            for(int j=0; j<words[i].size()-1; ++j){\\n                v.push_back(words[i][j+1]-words[i][j]);\\n            }\\n            m[v].push_back(words[i]);\\n        }\\n        for(auto& itr : m){\\n            if(itr.second.size() == 1){\\n                t = itr.second[0];\\n                break;\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756876,
                "title": "java-example-explanation-in-detail-logical",
                "content": "LOGIC : \\nEX = [\"adc\",\"wzy\",\"abc\"]\\n\\nso\\n- The difference integer array of \"adc\" is [3 - 0, 2 - 3] = [3, -1]\\n- The difference integer array of \"wzy\" is [25 - 22, 24 - 25]= [3, -1].\\n- The difference integer array of \"abc\" is [1 - 0, 2 - 1] = [1, 1]. \\n\\nBut here is catch we will convert difference Integer array into string , now question is how so as it mentioned\\nin question that there would be guaranted answer mean one unique answer .\\nif our different integer array is [1,1] so we will store it as \"aa\" in map as key.\\nmention we will convert every integer into alphabet (lower) and append into our string \\nas there would be at max two  string pattern and our answer would be one of them.\\n\\nNow as we are taking map and string as key but our value would be List<String> as we have to return string.\\nso we will find which key has value i.e list of size 1 and we will return that because we know its unique one.\\n\\nSimulation of example:\\n\\n- The difference integer array of \"adc\" is [3 - 0, 2 - 3] = [3, -1] ==> \"d`\"\\n- The difference integer array of \"wzy\" is [25 - 22, 24 - 25]= [3, -1]. ==> \"d`\"\\n- The difference integer array of \"abc\" is [1 - 0, 2 - 1] = [1, 1]. ==> \"bb\"\\n\\n \"d`\"  ==>List of  \"adc\" , \"wzy\"\\n \"bb\" ==> List of  \"abc\"\\n \\n as \"bb\" has one count so we return \"abc\"\\n \\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        \\n        HashMap<String,List<String>> map = new HashMap();\\n        \\n        for(String s : words){\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = 1; i < s.length(); i++){\\n                int t = (s.charAt(i)-\\'a\\')-(s.charAt(i-1)-\\'a\\');\\n                sb.append(String.valueOf((char)(\\'a\\'+ t)));\\n            }\\n            \\n            List<String> temp = map.getOrDefault(sb.toString(), new ArrayList());\\n            \\n            temp.add(s);\\n            map.put(sb.toString(),temp);\\n        }\\n        \\n        for(String s : map.keySet()){\\n            \\n            if(map.get(s).size() == 1)return map.get(s).get(0);\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        \\n        HashMap<String,List<String>> map = new HashMap();\\n        \\n        for(String s : words){\\n            StringBuilder sb = new StringBuilder();\\n            for(int i = 1; i < s.length(); i++){\\n                int t = (s.charAt(i)-\\'a\\')-(s.charAt(i-1)-\\'a\\');\\n                sb.append(String.valueOf((char)(\\'a\\'+ t)));\\n            }\\n            \\n            List<String> temp = map.getOrDefault(sb.toString(), new ArrayList());\\n            \\n            temp.add(s);\\n            map.put(sb.toString(),temp);\\n        }\\n        \\n        for(String s : map.keySet()){\\n            \\n            if(map.get(s).size() == 1)return map.get(s).get(0);\\n        }\\n        \\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756447,
                "title": "javascript-easy-hashmap-solution-74ms",
                "content": "```\\nvar oddString = function(words) {\\n    let hashMap = {};\\n    for(word of words){\\n        let temp = \\'\\';\\n        for(let i =0;i<word.length-1;i++){\\n            temp+=word[i+1].charCodeAt(0)-word[i].charCodeAt(0)+\\'_\\';\\n        }\\n        hashMap[temp] = hashMap[temp] ? [...hashMap[temp],word]:[word]\\n    }\\n    for(value of [...Object.values(hashMap)]) {\\n        if(value.length===1) return value[0]\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar oddString = function(words) {\\n    let hashMap = {};\\n    for(word of words){\\n        let temp = \\'\\';\\n        for(let i =0;i<word.length-1;i++){\\n            temp+=word[i+1].charCodeAt(0)-word[i].charCodeAt(0)+\\'_\\';\\n        }\\n        hashMap[temp] = hashMap[temp] ? [...hashMap[temp],word]:[word]\\n    }\\n    for(value of [...Object.values(hashMap)]) {\\n        if(value.length===1) return value[0]\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2756414,
                "title": "java-easiest-with-explanation",
                "content": "```\\npublic String oddString(String[] words) {\\n\\t\\tint n = words[0].length();\\n\\t\\t// Take 3 arrays for difference\\n\\t\\tint[] arr1 = new int[n];\\n\\t\\tint[] arr2 = new int[n];\\n\\t\\tint[] arr3 = new int[n];\\n\\n\\t\\t// Calculate for first 3 Strings\\n\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\tarr1[i] = words[0].charAt(i + 1) - words[0].charAt(i);\\n\\t\\t\\tarr2[i] = words[1].charAt(i + 1) - words[1].charAt(i);\\n\\t\\t\\tarr3[i] = words[2].charAt(i + 1) - words[2].charAt(i);\\n\\t\\t}\\n\\t\\t// Check if there is any odd\\n\\t\\tif (Arrays.equals(arr1, arr2) && !Arrays.equals(arr1, arr3)) return words[2];\\n\\t\\tif (Arrays.equals(arr1, arr3) && !Arrays.equals(arr2, arr3)) return words[1];\\n\\t\\tif (Arrays.equals(arr3, arr2) && !Arrays.equals(arr1, arr3)) return words[0];\\n\\n\\t\\t// If all above are equal then iterate over Strings and find first odd one\\n\\t\\tfor (int j = 3; j < words.length; j++) {\\n\\t\\t\\tint[] temp = new int[n];\\n\\t\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\t\\ttemp[i] = words[j].charAt(i + 1) - words[j].charAt(i);\\n\\t\\t\\t}\\n\\t\\t\\tif (!Arrays.equals(arr1, temp)) return words[j];\\n\\t\\t}\\n\\t\\treturn null;\\n\\t}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String oddString(String[] words) {\\n\\t\\tint n = words[0].length();\\n\\t\\t// Take 3 arrays for difference\\n\\t\\tint[] arr1 = new int[n];\\n\\t\\tint[] arr2 = new int[n];\\n\\t\\tint[] arr3 = new int[n];\\n\\n\\t\\t// Calculate for first 3 Strings\\n\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\tarr1[i] = words[0].charAt(i + 1) - words[0].charAt(i);\\n\\t\\t\\tarr2[i] = words[1].charAt(i + 1) - words[1].charAt(i);\\n\\t\\t\\tarr3[i] = words[2].charAt(i + 1) - words[2].charAt(i);\\n\\t\\t}\\n\\t\\t// Check if there is any odd\\n\\t\\tif (Arrays.equals(arr1, arr2) && !Arrays.equals(arr1, arr3)) return words[2];\\n\\t\\tif (Arrays.equals(arr1, arr3) && !Arrays.equals(arr2, arr3)) return words[1];\\n\\t\\tif (Arrays.equals(arr3, arr2) && !Arrays.equals(arr1, arr3)) return words[0];\\n\\n\\t\\t// If all above are equal then iterate over Strings and find first odd one\\n\\t\\tfor (int j = 3; j < words.length; j++) {\\n\\t\\t\\tint[] temp = new int[n];\\n\\t\\t\\tfor (int i = 0; i < n - 1; i++) {\\n\\t\\t\\t\\ttemp[i] = words[j].charAt(i + 1) - words[j].charAt(i);\\n\\t\\t\\t}\\n\\t\\t\\tif (!Arrays.equals(arr1, temp)) return words[j];\\n\\t\\t}\\n\\t\\treturn null;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2756392,
                "title": "java-solution-easy-to-understand-using-list-100-faster",
                "content": "```\\nclass Solution {\\n    \\n    public static List<Integer> count(String w) {\\n\\t\\tint sum=0;\\n\\t\\tList<Integer> l=new ArrayList<Integer>();\\n\\t\\tfor(int i=0;i<w.length()-1;i++) {\\n\\t\\t\\tl.add(w.charAt(i+1)-w.charAt(i));\\n\\t\\t}\\n\\t\\treturn l;\\n\\t}\\n\\n\\tpublic String oddString(String[] words) {\\n\\t\\tList<List<Integer>> l=new ArrayList<List<Integer>>();\\n\\t\\tfor(int i=0;i<words.length;i++) {\\n\\t\\t\\tString w=words[i];\\n\\t\\t\\tl.add(count(w));\\n\\t\\t}\\n\\t\\tfor(int i=0;i<l.size()-1;i++) {\\n\\t\\t\\tif(l.get(i).equals(l.get(i+1))) continue;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(i==l.size()-1) return words[i+1];\\n\\t\\t\\t\\telse if(i==0) {\\n\\t\\t\\t\\t\\tif(l.get(1).equals(l.get(2))) return words[0];\\n\\t\\t\\t\\t\\telse if(l.get(0).equals(l.get(2))) return words[1];\\n\\t\\t\\t\\t}else return words[i+1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn \"\";\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public static List<Integer> count(String w) {\\n\\t\\tint sum=0;\\n\\t\\tList<Integer> l=new ArrayList<Integer>();\\n\\t\\tfor(int i=0;i<w.length()-1;i++) {\\n\\t\\t\\tl.add(w.charAt(i+1)-w.charAt(i));\\n\\t\\t}\\n\\t\\treturn l;\\n\\t}\\n\\n\\tpublic String oddString(String[] words) {\\n\\t\\tList<List<Integer>> l=new ArrayList<List<Integer>>();\\n\\t\\tfor(int i=0;i<words.length;i++) {\\n\\t\\t\\tString w=words[i];\\n\\t\\t\\tl.add(count(w));\\n\\t\\t}\\n\\t\\tfor(int i=0;i<l.size()-1;i++) {\\n\\t\\t\\tif(l.get(i).equals(l.get(i+1))) continue;\\n\\t\\t\\telse {\\n\\t\\t\\t\\tif(i==l.size()-1) return words[i+1];\\n\\t\\t\\t\\telse if(i==0) {\\n\\t\\t\\t\\t\\tif(l.get(1).equals(l.get(2))) return words[0];\\n\\t\\t\\t\\t\\telse if(l.get(0).equals(l.get(2))) return words[1];\\n\\t\\t\\t\\t}else return words[i+1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn \"\";\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339120,
                "title": "using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        Map<String,Integer> as=new LinkedHashMap<>();\\n         Map<String,String> as1=new LinkedHashMap<>(); \\n        String a=\"\",ans=\"\",finalans=\"\";\\n        for(String b:words){\\n            a=\"\";\\n            for(int i=0;i<b.length()-1;i++){\\n                char ch=b.charAt(i),ch1=b.charAt(i+1);\\n                a+=ch1-ch;\\n                a+=\" \";\\n            }\\n            as.put(a,as.getOrDefault(a,0)+1);\\n            as1.put(b,a);\\n        }\\n      //  System.out.println(as);\\n        for(Map.Entry<String,Integer> e: as.entrySet()){\\n            if(e.getValue()==1)\\n            ans=e.getKey();\\n        }\\n        for(Map.Entry<String,String> e: as1.entrySet()){\\n            if(e.getValue().equals(ans))\\n            finalans=e.getKey();\\n        }\\n       \\n    \\n        return finalans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        Map<String,Integer> as=new LinkedHashMap<>();\\n         Map<String,String> as1=new LinkedHashMap<>(); \\n        String a=\"\",ans=\"\",finalans=\"\";\\n        for(String b:words){\\n            a=\"\";\\n            for(int i=0;i<b.length()-1;i++){\\n                char ch=b.charAt(i),ch1=b.charAt(i+1);\\n                a+=ch1-ch;\\n                a+=\" \";\\n            }\\n            as.put(a,as.getOrDefault(a,0)+1);\\n            as1.put(b,a);\\n        }\\n      //  System.out.println(as);\\n        for(Map.Entry<String,Integer> e: as.entrySet()){\\n            if(e.getValue()==1)\\n            ans=e.getKey();\\n        }\\n        for(Map.Entry<String,String> e: as1.entrySet()){\\n            if(e.getValue().equals(ans))\\n            finalans=e.getKey();\\n        }\\n       \\n    \\n        return finalans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332617,
                "title": "very-efficient-solution-c-100-efficient",
                "content": "Okay so like many others I was confused as that i have to like traverse the arrays 2-3 times and check the odd one out but the actual solution is quite simple and all we have to do is check three strings at the same time\\n\\nas the length of each string is same e traverse through the 3 strings and list out their differnces and then through a chain of if else we can figure out the odd one out and then simply return the odd one out string\\n\\nHere it is easy and probably the best solution for this kind of question\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int n = words.size();\\n        int s = words[0].length();\\n\\n        for(int i=1; i<n-1; i++)\\n        {\\n            for(int k=1; k<s; k++)\\n            {\\n                char diff = words[i-1][k] - words[i-1][k-1];\\n                char diff2 = words[i][k] - words[i][k-1];\\n                char diff3 = words[i+1][k] - words[i+1][k-1];\\n\\n                if(diff == diff2 && diff2 == diff3) continue;\\n                else if(diff == diff2) return words[i+1];\\n                else  if(diff == diff3) return words[i];\\n                else return words[i-1];  \\n            }  \\n        }  \\n\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int n = words.size();\\n        int s = words[0].length();\\n\\n        for(int i=1; i<n-1; i++)\\n        {\\n            for(int k=1; k<s; k++)\\n            {\\n                char diff = words[i-1][k] - words[i-1][k-1];\\n                char diff2 = words[i][k] - words[i][k-1];\\n                char diff3 = words[i+1][k] - words[i+1][k-1];\\n\\n                if(diff == diff2 && diff2 == diff3) continue;\\n                else if(diff == diff2) return words[i+1];\\n                else  if(diff == diff3) return words[i];\\n                else return words[i-1];  \\n            }  \\n        }  \\n\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3216033,
                "title": "golang-xor-o-n-o-1-100-fastest-no-hashmaps-no-extra-space",
                "content": "```\\n// just comparing difference between 2 letters \\n// in each first word and next. when we\\'ve found difference \\n// question is w[0] is our target or word, idx solve this case.\\nfunc oddString(w []string) string {\\n    var idx int\\n    for k, word := range w {\\n        for c, v := range word {\\n            if c > 0 && (w[0][c]-w[0][c-1]) ^ (byte(v) - word[c-1]) != 0  {\\n                   if idx != 0 { return w[0] }\\n                idx = k\\n                break \\n            } \\n        }\\n    }\\n    return w[idx]\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// just comparing difference between 2 letters \\n// in each first word and next. when we\\'ve found difference \\n// question is w[0] is our target or word, idx solve this case.\\nfunc oddString(w []string) string {\\n    var idx int\\n    for k, word := range w {\\n        for c, v := range word {\\n            if c > 0 && (w[0][c]-w[0][c-1]) ^ (byte(v) - word[c-1]) != 0  {\\n                   if idx != 0 { return w[0] }\\n                idx = k\\n                break \\n            } \\n        }\\n    }\\n    return w[idx]\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3162767,
                "title": "odd-string-difference-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. First, we initialize n with the length of the words array and m with the length of each word in the words array.\\n\\n2. Next, we initialize an empty list diff to store the difference arrays of all the words.\\n\\n3. Then, we loop through all the words in the words array and calculate the difference array of each word. The difference array is calculated by subtracting the ASCII value of the current character from the ASCII value of the next character in each word.\\n\\n4. After that, we use the collections.Counter function to count the frequency of each difference array in the diff list.\\n\\n5. Finally, we loop through the diff list and return the first word whose difference array has a frequency of 1 in the diff list. This word is the word with a different difference array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        n = len(words)\\n        m = len(words[0])\\n        diff = []\\n        for i in range(n):\\n            cur = []\\n            for j in range(m-1):\\n                cur.append(ord(words[i][j+1]) - ord(words[i][j]))\\n            diff.append(tuple(cur))\\n        \\n        cnt = collections.Counter(diff)\\n        for i in range(n):\\n            if cnt[diff[i]] == 1:\\n                return words[i]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        n = len(words)\\n        m = len(words[0])\\n        diff = []\\n        for i in range(n):\\n            cur = []\\n            for j in range(m-1):\\n                cur.append(ord(words[i][j+1]) - ord(words[i][j]))\\n            diff.append(tuple(cur))\\n        \\n        cnt = collections.Counter(diff)\\n        for i in range(n):\\n            if cnt[diff[i]] == 1:\\n                return words[i]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3027070,
                "title": "just-use-this-trick-super-easy-0ms-explanied",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n# Most intuitive||Easiest||Explained||0ms\\nwe are gonna use hashmap of string and int and some special trick to make this question super easy\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) we will create a hashmap of string and int \\n2) we will traverse our words array and will find diffrence (s[i]-s[i-1]) and store it with the help of string for each element of words we are gonna create a new string and we will also add \\'*\\' in between for uniquely identifying all combinations \\n3) Now we know that we only need index of that element only whose diffrence is minimum so we will put \\'-1\\' in hashmap for  strings which are reapeting(which are already present in hashmap) and we will only store index of that one element which is unique which was not present in hashmap before\\n4) then we will traverse the hahsmap and we will easily find out that index of that element which is unique (which is not -1) and return string of word of that index\\njust take a look at code and try to do a dryrun\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        int k=0;//for finding indexes\\n        for(auto i:words){\\n            string t=\"\";\\n            for(int j=1;j<i.size();j++){\\n                t.push_back(\\'*\\');//adding * for making it unique\\n                t.push_back(i[j]-i[j-1]);//calculating diffrence\\n            }\\n           if(mp.count(t))mp[t]=-1;//we dont index of similar diffrence  strings only need index of that string  whose diffrence is unique\\n           else mp[t]=k;//we only need index of that element which is unique which is not presend in hashmap\\n           k++;   //only for indexing   \\n        }\\n        for(auto i:mp)\\n         if(i.second!=-1)return words[i.second];//if elements value is not -1 means its our unique element\\n         \\n        return \"\";\\n    }\\n};\\n```\\n\\n\\n\\n\\n# clean code here guys\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        int k=0; \\n        for(auto i:words){\\n            string t=\"\";\\n            for(int j=1;j<i.size();j++){\\n                t.push_back(\\'*\\');\\n                t.push_back(i[j]-i[j-1]);\\n            }\\n           if(mp.count(t))mp[t]=-1;\\n           else mp[t]=k; \\n           k++;  \\n        }\\n        for(auto i:mp)\\n         if(i.second!=-1)return words[i.second]; \\n        return \"\";\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        int k=0;//for finding indexes\\n        for(auto i:words){\\n            string t=\"\";\\n            for(int j=1;j<i.size();j++){\\n                t.push_back(\\'*\\');//adding * for making it unique\\n                t.push_back(i[j]-i[j-1]);//calculating diffrence\\n            }\\n           if(mp.count(t))mp[t]=-1;//we dont index of similar diffrence  strings only need index of that string  whose diffrence is unique\\n           else mp[t]=k;//we only need index of that element which is unique which is not presend in hashmap\\n           k++;   //only for indexing   \\n        }\\n        for(auto i:mp)\\n         if(i.second!=-1)return words[i.second];//if elements value is not -1 means its our unique element\\n         \\n        return \"\";\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        unordered_map<string,int>mp;\\n        int k=0; \\n        for(auto i:words){\\n            string t=\"\";\\n            for(int j=1;j<i.size();j++){\\n                t.push_back(\\'*\\');\\n                t.push_back(i[j]-i[j-1]);\\n            }\\n           if(mp.count(t))mp[t]=-1;\\n           else mp[t]=k; \\n           k++;  \\n        }\\n        for(auto i:mp)\\n         if(i.second!=-1)return words[i.second]; \\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997284,
                "title": "c-unique-sol-time-and-memory-efficient-explained",
                "content": "Initially I thought that i should make a map \\n```\\nmap<vector<int>,vector<int>> mp;\\n```\\nto map each string value difference to its index then I thought.\\n\\nInstead I should add the indexes but with 0 based index 0+1<2 also withh 1 based indes 1+2 = 3, so I thought of 3 based index so i just added then index starting from 3. 2 Based can also work.\\nNow sum of all prevoius index is always smaller then the current index if curr index is greater then 4 if inex starts from 3\\n3+4>5 or if you take any case\\n\\nIf the string lies in first 3 index then the final return statement will gitve ans else the 1st one\\n\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<vector<short>,int> mp;int k = 3;\\n        for(int j = 0;j<words.size();j++){\\n            vector<short> temp;\\n            for(int i = 0;i<words[j].size()-1;i++) temp.push_back(words[j][i+1]-words[j][i]);\\n            mp[temp]+= k++;\\n            if(mp.size()==2 and j>2)return words[min(begin(mp)->second,next(begin(mp))->second)-3];\\n\\n        }\\n        return words[min(begin(mp)->second,next(begin(mp))->second)-3];\\n    }\\n};\\n```\\n\\nOR\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<string,int> mp;int k = 3;\\n        for(int j = 0;j<words.size();j++){\\n            string temp;\\n            for(int i = 0;i<words[j].size()-1;i++) temp.push_back(words[j][i+1]-words[j][i]);\\n            mp[temp]+= k++;\\n            if(mp.size()==2 and j>2)return words[min(begin(mp)->second,next(begin(mp))->second)-3];\\n\\n        }\\n        return words[min(begin(mp)->second,next(begin(mp))->second)-3];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nmap<vector<int>,vector<int>> mp;\\n```\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<vector<short>,int> mp;int k = 3;\\n        for(int j = 0;j<words.size();j++){\\n            vector<short> temp;\\n            for(int i = 0;i<words[j].size()-1;i++) temp.push_back(words[j][i+1]-words[j][i]);\\n            mp[temp]+= k++;\\n            if(mp.size()==2 and j>2)return words[min(begin(mp)->second,next(begin(mp))->second)-3];\\n\\n        }\\n        return words[min(begin(mp)->second,next(begin(mp))->second)-3];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<string,int> mp;int k = 3;\\n        for(int j = 0;j<words.size();j++){\\n            string temp;\\n            for(int i = 0;i<words[j].size()-1;i++) temp.push_back(words[j][i+1]-words[j][i]);\\n            mp[temp]+= k++;\\n            if(mp.size()==2 and j>2)return words[min(begin(mp)->second,next(begin(mp))->second)-3];\\n\\n        }\\n        return words[min(begin(mp)->second,next(begin(mp))->second)-3];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2997033,
                "title": "easy-understanding-hash-table-solution",
                "content": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar oddString = function(words) {\\n    let hash = {}\\n    for(let i=0 ; i<words.length ; i++){\\n        let diff = \"\"\\n        for(let j=0; j<words[i].length-1 ; j++ ){\\n            diff = diff + \".\" + String(words[i].charCodeAt(j+1)- words[i].charCodeAt(j))\\n        }\\n        if(hash[diff]) hash[diff].push(i)\\n        else hash[diff]=  [i]\\n    }\\n   for (const [key, value] of Object.entries(hash)) {\\n    if(value.length ===1) return words[value[0]]\\n}\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar oddString = function(words) {\\n    let hash = {}\\n    for(let i=0 ; i<words.length ; i++){\\n        let diff = \"\"\\n        for(let j=0; j<words[i].length-1 ; j++ ){\\n            diff = diff + \".\" + String(words[i].charCodeAt(j+1)- words[i].charCodeAt(j))\\n        }\\n        if(hash[diff]) hash[diff].push(i)\\n        else hash[diff]=  [i]\\n    }\\n   for (const [key, value] of Object.entries(hash)) {\\n    if(value.length ===1) return words[value[0]]\\n}\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2868121,
                "title": "python-faster-than-90-54-memory-beats-78-47",
                "content": "### ***Note***: List Comprehension is used in my code!\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words):\\n        difference = []\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n        for word in words:\\n            diff = []\\n            for j in range(len(word) - 1):\\n                diff.append(alphabet.index(word[j+1]) - alphabet.index(word[j]))\\n            difference.append(diff)\\n        return [ words[d] for d in range(len(difference)) if difference.count(difference[d]) == 1 ][0]\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/3e57a5ed-1384-43fd-a427-6471e1dffa29_1669944751.7015214.png)\\n\\n![image.png](https://assets.leetcode.com/users/images/a9a7f681-b315-431d-a809-10272e77a0dc_1669944772.774014.png)\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words):\\n        difference = []\\n        alphabet = \"abcdefghijklmnopqrstuvwxyz\"\\n        for word in words:\\n            diff = []\\n            for j in range(len(word) - 1):\\n                diff.append(alphabet.index(word[j+1]) - alphabet.index(word[j]))\\n            difference.append(diff)\\n        return [ words[d] for d in range(len(difference)) if difference.count(difference[d]) == 1 ][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843540,
                "title": "easy-c-solution",
                "content": "```\\n string oddString(vector<string>& words) {\\n        map<char,int> mp;\\n        vector<vector<int>> vec;\\n        int j=0;\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            mp[i]=j;\\n            j++;\\n        }\\n        vector<int> temp;\\n       for(string n:words){\\n           for(int i=0;i<n.size()-1;i++){\\n               temp.push_back(mp[n[i]]-mp[n[i+1]]);\\n           }\\n           vec.push_back(temp);\\n           temp.clear();\\n       } \\n    \\n    for(int i=0;i<vec.size();i++){\\n        if(count(vec.begin(),vec.end(),vec[i])==1){\\n            return words[i];\\n        }\\n    }\\n    }\\n   ```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n string oddString(vector<string>& words) {\\n        map<char,int> mp;\\n        vector<vector<int>> vec;\\n        int j=0;\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            mp[i]=j;\\n            j++;\\n        }\\n        vector<int> temp;\\n       for(string n:words){\\n           for(int i=0;i<n.size()-1;i++){\\n               temp.push_back(mp[n[i]]-mp[n[i+1]]);\\n           }\\n           vec.push_back(temp);\\n           temp.clear();\\n       } \\n    \\n    for(int i=0;i<vec.size();i++){\\n        if(count(vec.begin(),vec.end(),vec[i])==1){\\n            return words[i];\\n        }\\n    }\\n    }\\n   ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2804254,
                "title": "odd-string-difference-solution-java",
                "content": "class Solution {\\n  public String oddString(String[] words) {\\n    List<Pair<String, Integer>> wordAndHashCodes = getWordAndHashCodes(words);\\n    Map<Integer, Integer> hashCodeCount = new HashMap<>();\\n\\n    for (Pair<String, Integer> wordAndHashCode : wordAndHashCodes)\\n      hashCodeCount.merge(wordAndHashCode.getValue(), 1, Integer::sum);\\n\\n    for (Pair<String, Integer> wordAndHashCode : wordAndHashCodes)\\n      if (hashCodeCount.get(wordAndHashCode.getValue()) == 1)\\n        return wordAndHashCode.getKey();\\n\\n    throw new IllegalArgumentException();\\n  }\\n\\n  // Returns pairs of word and its corresponding hash code.\\n  private List<Pair<String, Integer>> getWordAndHashCodes(String[] words) {\\n    List<Pair<String, Integer>> wordAndHashCodes = new ArrayList<>();\\n    for (final String word : words)\\n      wordAndHashCodes.add(new Pair<>(word, getDiffStr(word).hashCode()));\\n    return wordAndHashCodes;\\n  }\\n\\n  // Returns difference string of `s`.\\n  // E.g., getDiffStr(\"adc\") -> \"3#-1#\"\\n  private String getDiffStr(final String s) {\\n    StringBuilder sb = new StringBuilder();\\n    for (int i = 1; i < s.length(); ++i)\\n      sb.append(s.charAt(i) - s.charAt(i - 1)).append(\"#\");\\n    return sb.toString();\\n  }\\n}\\n",
                "solutionTags": [
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "class Solution {\\n  public String oddString(String[] words) {\\n    List<Pair<String, Integer>> wordAndHashCodes = getWordAndHashCodes(words);\\n    Map<Integer, Integer> hashCodeCount = new HashMap<>();\\n\\n    for (Pair<String, Integer> wordAndHashCode : wordAndHashCodes)\\n      hashCodeCount.merge(wordAndHashCode.getValue(), 1, Integer::sum);\\n\\n    for (Pair<String, Integer> wordAndHashCode : wordAndHashCodes)\\n      if (hashCodeCount.get(wordAndHashCode.getValue()) == 1)\\n        return wordAndHashCode.getKey();\\n\\n    throw new IllegalArgumentException();\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2763524,
                "title": "java-easiest-map-method-with-answer",
                "content": "HashMap<List<Integer>,String>map=new HashMap<>();\\n       List<String>res=new ArrayList<>();\\n      for(int i=0;i<words.length;i++){\\n           List<Integer>ll=new ArrayList<>();\\n             for(int j=0;j<=words[i].length()-2;j++){\\n                ll.add(words[i].charAt(j+1)-words[i].charAt(j);       \\n            }\\n        if(map.containsKey(ll)==false){\\n                res.add(words[i]);\\n               map.put(ll,words[i]);   \\n            }\\n            else {\\n            res.remove(map.get(ll));\\n            map.put(ll,words[i]);\\n            }        \\n        }\\n       return  res.get(0);",
                "solutionTags": [],
                "code": "HashMap<List<Integer>,String>map=new HashMap<>();\\n       List<String>res=new ArrayList<>();\\n      for(int i=0;i<words.length;i++){\\n           List<Integer>ll=new ArrayList<>();\\n             for(int j=0;j<=words[i].length()-2;j++){\\n                ll.add(words[i].charAt(j+1)-words[i].charAt(j);       \\n            }\\n        if(map.containsKey(ll)==false){\\n                res.add(words[i]);\\n               map.put(ll,words[i]);   \\n            }\\n            else {\\n            res.remove(map.get(ll));\\n            map.put(ll,words[i]);\\n            }        \\n        }\\n       return  res.get(0);",
                "codeTag": "Unknown"
            },
            {
                "id": 2762038,
                "title": "c-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<vector<int>, pair<int, string>> mp;\\n        \\n        for(auto it:words){\\n            vector<int> v;\\n            for(int i = 0; i < it.length()-1; i++){\\n                int x = it[i+1] - it[i];\\n                v.push_back(x);\\n            }\\n            if(mp.find(v) == mp.end())\\n                mp[v] = {1, it};\\n            else\\n                mp[v].first++, mp[v].second = it;\\n        }\\n        \\n        for(auto it = mp.begin(); it != mp.end(); it++)\\n            if(it->second.first == 1)\\n                return it->second.second;\\n        return \"\";\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<vector<int>, pair<int, string>> mp;\\n        \\n        for(auto it:words){\\n            vector<int> v;\\n            for(int i = 0; i < it.length()-1; i++){\\n                int x = it[i+1] - it[i];\\n                v.push_back(x);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2760636,
                "title": "c-maps-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n\\n    string oddString(vector<string>& words) {\\n        vector<pair<vector<int>, string>>v;\\n        map<vector<int>, string>x;\\n        for(int i=0; i<words.size(); i++){\\n            vector<int>temp;\\n            for(int j=0; j<words[i].size()-1; j++){\\n                temp.push_back((words[i][j+1]-\\'a\\')-(words[i][j]-\\'a\\'));\\n            }\\n            v.push_back({temp, words[i]});\\n            x[temp]=words[i];\\n        }\\n        map<vector<int>, int>m;\\n        for(int i=0; i<v.size(); i++){\\n            m[v[i].first]++;\\n        }\\n        string ans=\"\";\\n        for(auto it: m){\\n            if(it.second==1){\\n                ans=x[it.first]; break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string oddString(vector<string>& words) {\\n        vector<pair<vector<int>, string>>v;\\n        map<vector<int>, string>x;\\n        for(int i=0; i<words.size(); i++){\\n            vector<int>temp;\\n            for(int j=0; j<words[i].size()-1; j++){\\n                temp.push_back((words[i][j+1]-\\'a\\')-(words[i][j]-\\'a\\'));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2759049,
                "title": "python-easy-understaning-hashmap-solution",
                "content": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        hashmap = {}\\n        for i,j in zip(\\'abcdefghijklmnopqrstuvwxyz\\',range(26)):\\n            hashmap[i] = j\\n        diff = []\\n        for i in range(len(words)):\\n            temp = []\\n            for j in range(1, len(words[i])):\\n                temp.append(hashmap[words[i][j]]-hashmap[words[i][j-1]])\\n            diff.append(temp)\\n        for i in range(len(diff)):\\n            if diff.count(diff[i]) == 1:\\n                ans = i\\n        return words[ans]\\n```",
                "solutionTags": [
                    "Python",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        hashmap = {}\\n        for i,j in zip(\\'abcdefghijklmnopqrstuvwxyz\\',range(26)):\\n            hashmap[i] = j\\n        diff = []\\n        for i in range(len(words)):\\n            temp = []\\n            for j in range(1, len(words[i])):\\n                temp.append(hashmap[words[i][j]]-hashmap[words[i][j-1]])\\n            diff.append(temp)\\n        for i in range(len(diff)):\\n            if diff.count(diff[i]) == 1:\\n                ans = i\\n        return words[ans]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758769,
                "title": "c-no-hashmaps-included-0ms-100-memory-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/951f3913-1563-4f4e-9f1f-4b4deb871cda_1667110841.2851784.png)\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        vector<int> temp;\\n        for(int i=0;i<words.size();i++){\\n            vector<int> v;\\n            for(int j=1;j<words[i].size();j++){\\n                v.push_back(words[i][j]-words[i][j-1]);\\n            }\\n            if(i==0) temp=v;\\n            else if(v!=temp){\\n                if(i!=1) return words[i];\\n                else{\\n                    vector<int> z;\\n                    for(int q=1;q<words[2].size();q++){\\n                        z.push_back(words[2][q]-words[2][q-1]);  \\n                    }\\n                    if(z==temp) return words[1];\\n                    else return words[0];\\n                }\\n            } \\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        vector<int> temp;\\n        for(int i=0;i<words.size();i++){\\n            vector<int> v;\\n            for(int j=1;j<words[i].size();j++){\\n                v.push_back(words[i][j]-words[i][j-1]);\\n            }\\n            if(i==0) temp=v;\\n            else if(v!=temp){\\n                if(i!=1) return words[i];\\n                else{\\n                    vector<int> z;\\n                    for(int q=1;q<words[2].size();q++){\\n                        z.push_back(words[2][q]-words[2][q-1]);  \\n                    }\\n                    if(z==temp) return words[1];\\n                    else return words[0];\\n                }\\n            } \\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758517,
                "title": "java-simple-solution",
                "content": "**Dev Bhayani**\\n\\nclass Solution {\\n    public String oddString(String[] a) {\\n        int x=0;\\n        int dif[][]=new int[a.length][a[0].length()-1];\\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int j=0;j<a[0].length()-1;j++)\\n            {\\n                dif[i][j]=(int)(a[i].charAt(j+1))-(int)(a[i].charAt(j));\\n            }\\n        }\\n        for(int j=0;j<a[0].length()-1;j++)\\n        {\\n            for(int i=1;i<a.length;i++)\\n            {\\n                if(dif[i][j]!=dif[i-1][j])\\n                {   \\n                    if(i!=a.length-1)\\n                    {\\n                        if(dif[i][j]!=dif[i+1][j] )\\n                        {\\n                        x=i;\\n                        }\\n                        else\\n                    {\\n                        x=i-1;\\n                    }\\n                    }\\n                    else if(i==a.length-1)\\n                    {\\n                        if(dif[i][j]!=dif[i-2][j])\\n                    {\\n                        x=i;\\n                    }else\\n                    {\\n                        x=i-1;\\n                    }\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return a[x];\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String oddString(String[] a) {\\n        int x=0;\\n        int dif[][]=new int[a.length][a[0].length()-1];\\n        for(int i=0;i<a.length;i++)\\n        {\\n            for(int j=0;j<a[0].length()-1;j++)\\n            {\\n                dif[i][j]=(int)(a[i].charAt(j+1))-(int)(a[i].charAt(j));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2757955,
                "title": "java-easy-solution-brute-force",
                "content": "class Solution {\\n    public String oddString(String[] words) {\\n        \\n        int[][] diff = new int[words.length][words.length-1];\\n        \\n        for(int i=0;i<words.length;i++){\\n            for(int j=0;j<words[i].length()-1;j++){\\n                diff[i][j] = words[i].charAt(j+1) - words[i].charAt(j);\\n            }\\n        }\\n        \\n        for(int j=0;j<diff[0].length;j++){\\n            if(diff[0][j] != diff[1][j] && diff[0][j] != diff[2][j]){\\n                return words[0];\\n            }\\n        }\\n        \\n        for(int i=0;i<diff.length-1;i++){\\n            for(int j=0;j<diff[i].length;j++){\\n                if(diff[i][j] != diff[i+1][j]){\\n                    return words[i+1];\\n                }\\n            }\\n        }\\n        \\n        return words[0];\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String oddString(String[] words) {\\n        \\n        int[][] diff = new int[words.length][words.length-1];\\n        \\n        for(int i=0;i<words.length;i++){\\n            for(int j=0;j<words[i].length()-1;j++){\\n                diff[i][j] = words[i].charAt(j+1) - words[i].charAt(j);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2757282,
                "title": "swift-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\n    func oddString(_ words: [String]) -> String {\\n        let words = words.map{ Array($0) }\\n        var diffs: [[Int]: [String]] = [:]\\n        \\n        for word in words {\\n            var cur: [Int] = []\\n            for i in 1..<word.count {\\n                cur.append(Int(word[i].asciiValue!) - Int(word[i - 1].asciiValue!))\\n            }\\n            diffs[cur, default: []].append(String(word))\\n        }\\n        \\n        return diffs.first(where: { $0.value.count == 1 })!.value.first!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func oddString(_ words: [String]) -> String {\\n        let words = words.map{ Array($0) }\\n        var diffs: [[Int]: [String]] = [:]\\n        \\n        for word in words {\\n            var cur: [Int] = []\\n            for i in 1..<word.count {\\n                cur.append(Int(word[i].asciiValue!) - Int(word[i - 1].asciiValue!))\\n            }\\n            diffs[cur, default: []].append(String(word))\\n        }\\n        \\n        return diffs.first(where: { $0.value.count == 1 })!.value.first!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757067,
                "title": "java-no-map-o-1-space-optimal-solution",
                "content": "The optimal solution is the most  easiest to read and understand.\\n\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int ans=-1;\\n        for(int i=0;i<words[0].length()-1;i++)\\n        {\\n            int first=words[0].charAt(i+1)-words[0].charAt(i);\\n            int second=words[1].charAt(i+1)-words[1].charAt(i);\\n            for(int j=2;j<words.length;j++)\\n            {\\n                int curr = words[j].charAt(i+1)-words[j].charAt(i);\\n                if(curr==first && curr!=second)\\n                {\\n                    ans = 1;\\n                } \\n                if(curr==second && curr!=first)\\n                {\\n                    ans = 0;\\n                }\\n                if(curr!=second && curr!=first)\\n                {\\n                    ans = j;\\n                }\\n            }\\n            if(ans!=-1)\\n                break;\\n        }\\n        return words[ans];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int ans=-1;\\n        for(int i=0;i<words[0].length()-1;i++)\\n        {\\n            int first=words[0].charAt(i+1)-words[0].charAt(i);\\n            int second=words[1].charAt(i+1)-words[1].charAt(i);\\n            for(int j=2;j<words.length;j++)\\n            {\\n                int curr = words[j].charAt(i+1)-words[j].charAt(i);\\n                if(curr==first && curr!=second)\\n                {\\n                    ans = 1;\\n                } \\n                if(curr==second && curr!=first)\\n                {\\n                    ans = 0;\\n                }\\n                if(curr!=second && curr!=first)\\n                {\\n                    ans = j;\\n                }\\n            }\\n            if(ans!=-1)\\n                break;\\n        }\\n        return words[ans];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757013,
                "title": "python-easy-map-brute-way",
                "content": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        d=defaultdict(list)\\n        for i in words:\\n            l=[]\\n            for j in range(len(i)-1):\\n                l.append(ord(i[j+1])-ord(i[j]))\\n            d[str(l)].append(i)\\n        val=\"\"\\n        for i in d:\\n            if len((d[i]))==1:\\n                return d[i][0]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        d=defaultdict(list)\\n        for i in words:\\n            l=[]\\n            for j in range(len(i)-1):\\n                l.append(ord(i[j+1])-ord(i[j]))\\n            d[str(l)].append(i)\\n        val=\"\"\\n        for i in d:\\n            if len((d[i]))==1:\\n                return d[i][0]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2756792,
                "title": "python-easy-solution-o-n-using-ord",
                "content": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        \\n        word_int=[]\\n        l=[]\\n        unique_min=0\\n        \\n        for word in words:\\n            for i in range(len(word)):               \\n                if(i!=len(word)-1):\\n                    l.append(ord(word[i+1])-ord(word[i]))\\n            word_int.append(\\' \\'.join(str(x) for x in l))\\n            l=[]\\n        \\n        word_int_count=Counter(word_int)\\n        \\n        \\n        for i in word_int_count:\\n            if(word_int_count[i]==1):\\n                unique_min=i\\n                break\\n        \\n        for i in range(len(word_int)):\\n            if(word_int[i]==unique_min):\\n                return words[i]\\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        \\n        word_int=[]\\n        l=[]\\n        unique_min=0\\n        \\n        for word in words:\\n            for i in range(len(word)):               \\n                if(i!=len(word)-1):\\n                    l.append(ord(word[i+1])-ord(word[i]))\\n            word_int.append(\\' \\'.join(str(x) for x in l))\\n            l=[]\\n        \\n        word_int_count=Counter(word_int)\\n        \\n        \\n        for i in word_int_count:\\n            if(word_int_count[i]==1):\\n                unique_min=i\\n                break\\n        \\n        for i in range(len(word_int)):\\n            if(word_int[i]==unique_min):\\n                return words[i]\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756685,
                "title": "java-o-1-space-approach",
                "content": "Instead of comparing chars in a string comparing same indexed chars in different strings to find for which string the difference does not match.\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int count = 0;\\n        int index=0;\\n        String word1= words[0];\\n        for(int i=1;i<words.length;i++){\\n            String word2=words[i];\\n            int diff1 = word2.charAt(0) - word1.charAt(0);\\n            for( int j=1;j<word2.length();j++) {\\n                int diff2 = word2.charAt(j) - word1.charAt(j);\\n                if (diff1 != diff2) {\\n                    index = i;\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        if(count==1)return words[index];\\n        else return words[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int count = 0;\\n        int index=0;\\n        String word1= words[0];\\n        for(int i=1;i<words.length;i++){\\n            String word2=words[i];\\n            int diff1 = word2.charAt(0) - word1.charAt(0);\\n            for( int j=1;j<word2.length();j++) {\\n                int diff2 = word2.charAt(j) - word1.charAt(j);\\n                if (diff1 != diff2) {\\n                    index = i;\\n                    count++;\\n                    break;\\n                }\\n            }\\n        }\\n        if(count==1)return words[index];\\n        else return words[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756618,
                "title": "brute-force-java-5ms",
                "content": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int n=words[0].length();\\n        List<int[]>ls=new ArrayList<>();\\n        for(String s:words){\\n            int arr[]=new int[s.length()-1];\\n            for(int i=0;i<s.length()-1;i++){\\n                arr[i]=s.charAt(i+1)-s.charAt(i);\\n            }\\n            ls.add(arr);\\n        }\\n        for(int i=1;i<ls.size()-1;i++){\\n            boolean l=false,r=false;\\n            int left[]=ls.get(i-1),mid[]=ls.get(i),right[]=ls.get(i+1);\\n            for(int j=0;j<n-1;j++){\\n                \\n                if(left[j]!=mid[j]){\\n                    l=true;\\n                    break;\\n                }\\n            }\\n            for(int j=0;j<n-1;j++){\\n                if(mid[j]!=right[j]){\\n                    r=true;            \\n                    break;\\n                }\\n            }\\n            if(l==false && r==true)return words[i+1];\\n            else if(l==true && r==false)return words[i-1];\\n            else if(l==true && r==true)return words[i];\\n            \\n            \\n        }\\n        return words[words.length-1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int n=words[0].length();\\n        List<int[]>ls=new ArrayList<>();\\n        for(String s:words){\\n            int arr[]=new int[s.length()-1];\\n            for(int i=0;i<s.length()-1;i++){\\n                arr[i]=s.charAt(i+1)-s.charAt(i);\\n            }\\n            ls.add(arr);\\n        }\\n        for(int i=1;i<ls.size()-1;i++){\\n            boolean l=false,r=false;\\n            int left[]=ls.get(i-1),mid[]=ls.get(i),right[]=ls.get(i+1);\\n            for(int j=0;j<n-1;j++){\\n                \\n                if(left[j]!=mid[j]){\\n                    l=true;\\n                    break;\\n                }\\n            }\\n            for(int j=0;j<n-1;j++){\\n                if(mid[j]!=right[j]){\\n                    r=true;            \\n                    break;\\n                }\\n            }\\n            if(l==false && r==true)return words[i+1];\\n            else if(l==true && r==false)return words[i-1];\\n            else if(l==true && r==true)return words[i];\\n            \\n            \\n        }\\n        return words[words.length-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756594,
                "title": "c-straight-forward-approach-simple-way-no-maps",
                "content": "->So first we define a function to get difference integer array.\\n->If first and second words have same difference integer array then we go check for the odd difference array by comparing with the second word difference integer array(or first).\\n->If first and second are different then we compare with third one to find the odd ones.\\n-> Please do upvote if found helpful :)\\n\\n```\\nclass Solution {    \\npublic:\\n    \\n    \\n    vector<int> diff_arr(string s){\\n        int n = s.size();\\n        vector<int> v;\\n        int a;\\n        for(int i = 1; i <n;i++){\\n            int diff = s[i]-s[i-1];\\n            v.push_back(diff);\\n        }\\n        \\n        return v;\\n        }\\n    \\n    \\npublic:\\n    string oddString(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> first = diff_arr(words[0]);\\n        vector<int> second = diff_arr(words[1]);\\n        if(first == second){\\n        for(int i = 2; i <n; i++){\\n            vector<int> next = diff_arr(words[i]);\\n            if(second != next) return words[i];\\n        }\\n        }\\n        vector<int> third = diff_arr(words[2]); \\n        if(first == third) return words[1];\\n        if (second == third) return words[0];\\n            \\n    return \"s\";\\n    \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {    \\npublic:\\n    \\n    \\n    vector<int> diff_arr(string s){\\n        int n = s.size();\\n        vector<int> v;\\n        int a;\\n        for(int i = 1; i <n;i++){\\n            int diff = s[i]-s[i-1];\\n            v.push_back(diff);\\n        }\\n        \\n        return v;\\n        }\\n    \\n    \\npublic:\\n    string oddString(vector<string>& words) {\\n        int n = words.size();\\n        vector<int> first = diff_arr(words[0]);\\n        vector<int> second = diff_arr(words[1]);\\n        if(first == second){\\n        for(int i = 2; i <n; i++){\\n            vector<int> next = diff_arr(words[i]);\\n            if(second != next) return words[i];\\n        }\\n        }\\n        vector<int> third = diff_arr(words[2]); \\n        if(first == third) return words[1];\\n        if (second == third) return words[0];\\n            \\n    return \"s\";\\n    \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756589,
                "title": "c-with-notes-and-explanation",
                "content": "# Approach\\nCalculate the difference integer array for each word and save them into a map. So, we will have 2 difference integer arrays stored in the map. Then just check which one of these appears only once (this is the **Answer**).\\n\\n\\n# Complexity\\n`m = words.size()`\\n`n = words[i].size()`\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int n = words[0].size();\\n        map<vector<int>, vector<string>> mp;\\n\\n        for (string word : words){\\n            int prev = word[0];\\n            vector<int> temp;\\n            //Calculate the difference integer array\\n            for (int i = 1; i < n; i++){\\n                int c_int = word[i] - \\'a\\';\\n                temp.push_back(c_int - prev);\\n                prev = c_int; \\n            }\\n\\n            //save it into a map\\n            mp[temp].push_back(word);\\n        }\\n        \\n        string res = \"\";\\n        \\n        //find which one appears only once\\n        for (auto const [key,val] : mp)\\n            if (val.size() == 1){\\n                res = val[0];\\n                break;\\n            }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int n = words[0].size();\\n        map<vector<int>, vector<string>> mp;\\n\\n        for (string word : words){\\n            int prev = word[0];\\n            vector<int> temp;\\n            //Calculate the difference integer array\\n            for (int i = 1; i < n; i++){\\n                int c_int = word[i] - \\'a\\';\\n                temp.push_back(c_int - prev);\\n                prev = c_int; \\n            }\\n\\n            //save it into a map\\n            mp[temp].push_back(word);\\n        }\\n        \\n        string res = \"\";\\n        \\n        //find which one appears only once\\n        for (auto const [key,val] : mp)\\n            if (val.size() == 1){\\n                res = val[0];\\n                break;\\n            }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756549,
                "title": "map-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<vector<int>,pair<string,int>> mp;\\n        for(auto ele:words){\\n            vector<int> arr;\\n            for(int i =0;i<ele.size()-1;i++){\\n                arr.push_back(ele[i+1]-ele[i]);\\n            }\\n            mp[arr].first = ele;\\n            mp[arr].second++;\\n        };\\n        for(auto ele:mp){\\n            if(ele.second.second == 1){\\n                return ele.second.first;\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<vector<int>,pair<string,int>> mp;\\n        for(auto ele:words){\\n            vector<int> arr;\\n            for(int i =0;i<ele.size()-1;i++){\\n                arr.push_back(ele[i+1]-ele[i]);\\n            }\\n            mp[arr].first = ele;\\n            mp[arr].second++;\\n        };\\n        for(auto ele:mp){\\n            if(ele.second.second == 1){\\n                return ele.second.first;\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756499,
                "title": "easy-c-map-of-vector-solution",
                "content": "\\n```\\nclass Solution {\\n    vector<int>convert(string f){\\n        vector<int>k;\\n        for(int i=0;i+1<f.length();i++){\\n            k.push_back(f[i+1]-f[i]);\\n        }\\n        return k;\\n    }\\npublic:\\n    string oddString(vector<string>& w) {\\n        map<vector<int>,int>mp;\\n        vector<int>k;\\n        for(auto i:w){\\n            mp[convert(i)]++;\\n        }\\n        for(auto i:mp){\\n            if(i.second==1){\\n                k=i.first;\\n            }\\n        }\\n        for(int i=0;i<w.size();i++){\\n            if(convert(w[i])==k){\\n                return w[i];\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    vector<int>convert(string f){\\n        vector<int>k;\\n        for(int i=0;i+1<f.length();i++){\\n            k.push_back(f[i+1]-f[i]);\\n        }\\n        return k;\\n    }\\npublic:\\n    string oddString(vector<string>& w) {\\n        map<vector<int>,int>mp;\\n        vector<int>k;\\n        for(auto i:w){\\n            mp[convert(i)]++;\\n        }\\n        for(auto i:mp){\\n            if(i.second==1){\\n                k=i.first;\\n            }\\n        }\\n        for(int i=0;i<w.size();i++){\\n            if(convert(w[i])==k){\\n                return w[i];\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756491,
                "title": "java-easy-solution-hashmap",
                "content": "Brief steps-\\n1. Calculate the difference array \\'temp\\', for all strings \\'s\\', and add (temp, s) to the map .\\n2. If temp exists in the map, change s to null.\\n3. Iterate through the map and return the string whose value isn\\'t null.\\n\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        HashMap<List<Integer>, String> map = new HashMap<>();\\n        \\n        for(String s : words){\\n            List<Integer> temp = new ArrayList<>();\\n            for(int i=0; i<s.length()-1; i++){\\n                temp.add(i, (s.charAt(i+1)-s.charAt(i)));\\n            }\\n          \\n            if(map.containsKey(temp))\\n                map.put(temp, null);\\n            else\\n                map.put(temp, s);\\n        }\\n        \\n         for (Map.Entry<List<Integer>, String> mapElement : map.entrySet()) {\\n            String value = mapElement.getValue();\\n             if(value!=null)\\n                 return value;\\n         }\\n        return null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        HashMap<List<Integer>, String> map = new HashMap<>();\\n        \\n        for(String s : words){\\n            List<Integer> temp = new ArrayList<>();\\n            for(int i=0; i<s.length()-1; i++){\\n                temp.add(i, (s.charAt(i+1)-s.charAt(i)));\\n            }\\n          \\n            if(map.containsKey(temp))\\n                map.put(temp, null);\\n            else\\n                map.put(temp, s);\\n        }\\n        \\n         for (Map.Entry<List<Integer>, String> mapElement : map.entrySet()) {\\n            String value = mapElement.getValue();\\n             if(value!=null)\\n                 return value;\\n         }\\n        return null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756485,
                "title": "heavy-implementation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> a, vector<int> b)\\n    {\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]!=b[i]) return false;\\n        }\\n        return true;\\n    }\\n    string oddString(vector<string>& words) {\\n        vector<vector<int>> temp;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            vector<int> arr;\\n            string s=words[i];\\n            for(int j=0;j<s.length()-1;j++)\\n            {\\n                arr.push_back(s[j+1]-s[j]);\\n            }\\n            temp.push_back(arr);\\n        }\\n        int count=0;\\n        for(int i=1;i<words.size();i++)\\n        {\\n            if(!check(temp[0],temp[i]))\\n            {\\n                count++;\\n            }\\n                if(count>1)\\n                {\\n                    return words[0];\\n                }\\n            \\n        }\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(!check(temp[i],temp[0]))\\n            {\\n                return words[i];\\n            }\\n        }\\n        return words[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(vector<int> a, vector<int> b)\\n    {\\n        int n=a.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]!=b[i]) return false;\\n        }\\n        return true;\\n    }\\n    string oddString(vector<string>& words) {\\n        vector<vector<int>> temp;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            vector<int> arr;\\n            string s=words[i];\\n            for(int j=0;j<s.length()-1;j++)\\n            {\\n                arr.push_back(s[j+1]-s[j]);\\n            }\\n            temp.push_back(arr);\\n        }\\n        int count=0;\\n        for(int i=1;i<words.size();i++)\\n        {\\n            if(!check(temp[0],temp[i]))\\n            {\\n                count++;\\n            }\\n                if(count>1)\\n                {\\n                    return words[0];\\n                }\\n            \\n        }\\n        for(int i=0;i<words.size();i++)\\n        {\\n            if(!check(temp[i],temp[0]))\\n            {\\n                return words[i];\\n            }\\n        }\\n        return words[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756418,
                "title": "java",
                "content": "Normalize every word and count frequency\\n```\\nclass Solution\\n{\\n    public String oddString(String[] words)\\n    {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for(String word : words)\\n        {\\n            char[] arr = word.toCharArray();\\n            int diff = arr[0]-\\'a\\';\\n            \\n            for(int i = 0; i < arr.length; i++)\\n                arr[i] = (char) (arr[i]-\\'a\\'-diff+97);\\n            \\n            if(!map.containsKey(String.valueOf(arr)))\\n                map.put(String.valueOf(arr),new ArrayList<String>());\\n            \\n            map.get(String.valueOf(arr)).add(word);\\n        }\\n        for(String word : map.keySet())\\n            if(map.get(word).size() == 1)\\n                return map.get(word).get(0);\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public String oddString(String[] words)\\n    {\\n        Map<String, List<String>> map = new HashMap<>();\\n        for(String word : words)\\n        {\\n            char[] arr = word.toCharArray();\\n            int diff = arr[0]-\\'a\\';\\n            \\n            for(int i = 0; i < arr.length; i++)\\n                arr[i] = (char) (arr[i]-\\'a\\'-diff+97);\\n            \\n            if(!map.containsKey(String.valueOf(arr)))\\n                map.put(String.valueOf(arr),new ArrayList<String>());\\n            \\n            map.get(String.valueOf(arr)).add(word);\\n        }\\n        for(String word : map.keySet())\\n            if(map.get(word).size() == 1)\\n                return map.get(word).get(0);\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756395,
                "title": "simple-brute-force-solution",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define pb push_back\\npublic:\\n    string oddString(vector<string>&v) {\\n        unordered_map<string, vi(ll)>ump;\\n        for(ll j=0;j<v.size();++j){\\n            const string&s=v[j];\\n            string str;\\n            for(ll i=0;i<s.size()-1;++i){\\n                ll dif=s[i+1]-s[i];\\n                str.append(to_string(dif));\\n                str.pb(\\'.\\');\\n            }\\n            str.pop_back();\\n            ump[str].pb(j);\\n        }\\n        ll ans=-1;\\n        for(const auto&it:ump){\\n            if(it.second.size()==1){\\n                ans=it.second[0];\\n                break;\\n            }\\n        }\\n        return v[ans];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define pb push_back\\npublic:\\n    string oddString(vector<string>&v) {\\n        unordered_map<string, vi(ll)>ump;\\n        for(ll j=0;j<v.size();++j){\\n            const string&s=v[j];\\n            string str;\\n            for(ll i=0;i<s.size()-1;++i){\\n                ll dif=s[i+1]-s[i];\\n                str.append(to_string(dif));\\n                str.pb(\\'.\\');\\n            }\\n            str.pop_back();\\n            ump[str].pb(j);\\n        }\\n        ll ans=-1;\\n        for(const auto&it:ump){\\n            if(it.second.size()==1){\\n                ans=it.second[0];\\n                break;\\n            }\\n        }\\n        return v[ans];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756387,
                "title": "c-using-two-map",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n       \\n      int n = words.size();\\n      vector<vector<int>> arr(n);\\n      \\n      map<vector<int>,string> mp1; // first map to store the difference integer with their words\\n      map<vector<int>,int> mp2;  // second map to count the frequency of difference integer vector \\n      \\n      \\n      \\n      for(int i=0;i<words.size();i++){\\n         int j  = 1;\\n         vector<int> w;\\n        while(j < words[i].size()){\\n          \\n          int dif = (words[i][j] - \\'0\\') - (words[i][j-1] - \\'0\\');  \\n          w.push_back(dif);\\n          j++;\\n        }\\n        mp1[w] = words[i];\\n        mp2[w]++;\\n        arr.push_back(w);\\n        w.clear();\\n      }\\n      string ans;\\n      \\n     \\n      for(auto it : arr){\\n        if(mp2[it] == 1){  // if freq count is one then this is answer\\n          ans = mp1[it];  // it store the string with help of map 1\\n        }\\n      }\\n        \\n    return ans;\\n      \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n       \\n      int n = words.size();\\n      vector<vector<int>> arr(n);\\n      \\n      map<vector<int>,string> mp1; // first map to store the difference integer with their words\\n      map<vector<int>,int> mp2;  // second map to count the frequency of difference integer vector \\n      \\n      \\n      \\n      for(int i=0;i<words.size();i++){\\n         int j  = 1;\\n         vector<int> w;\\n        while(j < words[i].size()){\\n          \\n          int dif = (words[i][j] - \\'0\\') - (words[i][j-1] - \\'0\\');  \\n          w.push_back(dif);\\n          j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2756333,
                "title": "a-few-solutions",
                "content": "Let `f` be a function which produces the adjacent ordinal value difference for each string `s` of the input array `A`, then use a map `m` to count the frequency each key `k = f(s)` and return the string `s` with a count of `1`.\\n\\n---\\n    \\n*Kotlin*\\n```\\nclass Solution {\\n    fun oddString(A: Array<String>): String {\\n        var m = mutableMapOf<String, MutableList<String>>()\\n        var f = { s: String -> s.toCharArray().withIndex().map{ (i, _) -> if (0 < i) \"${s[i].toInt() - s[i - 1].toInt()}\" else  \"\" }.joinToString() }\\n        for (s in A) {\\n            var k = f(s)\\n            if (!m.contains(k))\\n                m[k] = mutableListOf<String>()\\n            m[k]!!.add(s)\\n        }\\n        return m.filter{ (_, A) -> A.size == 1 }.map{ (_, A) -> A[0] }.toList()[0]\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet oddString = (A, ord = c => c.charCodeAt(0), m = new Map()) => {\\n    let f = s => s.split(\\'\\').map((_, i) => i ? `${ord(s[i]) - ord(s[i - 1])}` : \\'\\').join(\\',\\');\\n    for (let s of A) {\\n        let k = f(s);\\n        if (!m.has(k))\\n            m.set(k, []);\\n        m.get(k).push(s);\\n    }\\n    return [...m].filter(([_, A]) => A.length == 1).map(([_, A]) => A[0])[0];\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def oddString(self, A: List[str]) -> str:\\n        f = lambda s: \\',\\'.join(str(ord(s[i]) - ord(s[i - 1])) for i in range(1, len(s)))\\n        m = defaultdict(list)\\n        for s in A:\\n            m[f(s)].append(s)\\n        return [A[0] for A in m.values() if len(A) == 1][0]\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Map = unordered_map<string, VS>;\\n    string oddString(VS& A, Map m = {}) {\\n        auto f = [](auto& s) {\\n            ostringstream os;\\n            for (auto i{ 1 }; i < s.size(); ++i)\\n                os << int(s[i] - s[i - 1]) << \",\";\\n            return os.str();\\n        };\\n        for (auto& s: A)\\n            m[f(s)].emplace_back(s);\\n        for (auto& [_, A]: m)\\n            if (A.size() == 1)\\n                return A[0];\\n        return {};\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun oddString(A: Array<String>): String {\\n        var m = mutableMapOf<String, MutableList<String>>()\\n        var f = { s: String -> s.toCharArray().withIndex().map{ (i, _) -> if (0 < i) \"${s[i].toInt() - s[i - 1].toInt()}\" else  \"\" }.joinToString() }\\n        for (s in A) {\\n            var k = f(s)\\n            if (!m.contains(k))\\n                m[k] = mutableListOf<String>()\\n            m[k]!!.add(s)\\n        }\\n        return m.filter{ (_, A) -> A.size == 1 }.map{ (_, A) -> A[0] }.toList()[0]\\n    }\\n}\\n```\n```\\nlet oddString = (A, ord = c => c.charCodeAt(0), m = new Map()) => {\\n    let f = s => s.split(\\'\\').map((_, i) => i ? `${ord(s[i]) - ord(s[i - 1])}` : \\'\\').join(\\',\\');\\n    for (let s of A) {\\n        let k = f(s);\\n        if (!m.has(k))\\n            m.set(k, []);\\n        m.get(k).push(s);\\n    }\\n    return [...m].filter(([_, A]) => A.length == 1).map(([_, A]) => A[0])[0];\\n};\\n```\n```\\nclass Solution:\\n    def oddString(self, A: List[str]) -> str:\\n        f = lambda s: \\',\\'.join(str(ord(s[i]) - ord(s[i - 1])) for i in range(1, len(s)))\\n        m = defaultdict(list)\\n        for s in A:\\n            m[f(s)].append(s)\\n        return [A[0] for A in m.values() if len(A) == 1][0]\\n```\n```\\nclass Solution {\\npublic:\\n    using VS = vector<string>;\\n    using Map = unordered_map<string, VS>;\\n    string oddString(VS& A, Map m = {}) {\\n        auto f = [](auto& s) {\\n            ostringstream os;\\n            for (auto i{ 1 }; i < s.size(); ++i)\\n                os << int(s[i] - s[i - 1]) << \",\";\\n            return os.str();\\n        };\\n        for (auto& s: A)\\n            m[f(s)].emplace_back(s);\\n        for (auto& [_, A]: m)\\n            if (A.size() == 1)\\n                return A[0];\\n        return {};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096243,
                "title": "simple-solution-using-a-dictionary",
                "content": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        cnt = defaultdict(list)\\n        for word in words:\\n            cnt[\"\".join(str(ord(ch)-ord(word[0])) for ch in word)].append(word)\\n        return min(cnt.values(), key= len)[0]\\n```\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        dic = {}\\n        for word in words:\\n            s = \"\".join(str(ord(ch)-ord(word[0])) for ch in word)\\n            if len(dic) > 1:\\n                if s in dic:\\n                    del dic[s]\\n                    return dic.popitem()[1]\\n                else:\\n                    return word\\n            dic[s] = word\\n        return words[-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        cnt = defaultdict(list)\\n        for word in words:\\n            cnt[\"\".join(str(ord(ch)-ord(word[0])) for ch in word)].append(word)\\n        return min(cnt.values(), key= len)[0]\\n```\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        dic = {}\\n        for word in words:\\n            s = \"\".join(str(ord(ch)-ord(word[0])) for ch in word)\\n            if len(dic) > 1:\\n                if s in dic:\\n                    del dic[s]\\n                    return dic.popitem()[1]\\n                else:\\n                    return word\\n            dic[s] = word\\n        return words[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083554,
                "title": "vey-easy-beats-90-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        b=[]\\n        c=[]\\n        for i in words:\\n            a=[]\\n            for j in range(len(i)-1):\\n                a.append(ord(i[j+1])-ord(i[j]))\\n            b.append(a)\\n        for i in b:\\n            if i not in c:\\n                c.append(i)\\n        for i in c:\\n            if b.count(i)==1:\\n                return words[b.index(i)]\\n\\n\\n       \\n\\n\\n        \\n\\n\\n\\n        \\n        \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        b=[]\\n        c=[]\\n        for i in words:\\n            a=[]\\n            for j in range(len(i)-1):\\n                a.append(ord(i[j+1])-ord(i[j]))\\n            b.append(a)\\n        for i in b:\\n            if i not in c:\\n                c.append(i)\\n        for i in c:\\n            if b.count(i)==1:\\n                return words[b.index(i)]\\n\\n\\n       \\n\\n\\n        \\n\\n\\n\\n        \\n        \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079491,
                "title": "c-solution",
                "content": "# Approach\\n- Helper `getDifference` method is calculating the difference of each two neighboring letters in the word and returns it as a comma-separated string\\n- `OddString` calculating the difference strings for each word and track their counts in a dictionary. Then it checks which word has a difference count equal to 1. The required word is the one with count 1.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public string OddString(string[] words)\\n    {\\n        var differenceCounts = new Dictionary<string, int>();\\n\\n        foreach (var word in words)\\n        {\\n            var difference = getDifference(word);\\n            differenceCounts[difference] = differenceCounts.GetValueOrDefault(difference) + 1;\\n        }\\n\\n        foreach (var word in words)\\n        {\\n            if (differenceCounts[getDifference(word)] == 1)\\n            {\\n                return word;\\n            }\\n        }\\n\\n        return string.Empty;\\n    }\\n\\n    private static string getDifference(string word)\\n    {\\n        var difference = new StringBuilder();\\n        for (var i = 0; i < word.Length - 1; i++)\\n        {\\n            difference.Append(word[i + 1] - word[i]);\\n            difference.Append(\",\");\\n        }\\n\\n        return difference.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public string OddString(string[] words)\\n    {\\n        var differenceCounts = new Dictionary<string, int>();\\n\\n        foreach (var word in words)\\n        {\\n            var difference = getDifference(word);\\n            differenceCounts[difference] = differenceCounts.GetValueOrDefault(difference) + 1;\\n        }\\n\\n        foreach (var word in words)\\n        {\\n            if (differenceCounts[getDifference(word)] == 1)\\n            {\\n                return word;\\n            }\\n        }\\n\\n        return string.Empty;\\n    }\\n\\n    private static string getDifference(string word)\\n    {\\n        var difference = new StringBuilder();\\n        for (var i = 0; i < word.Length - 1; i++)\\n        {\\n            difference.Append(word[i + 1] - word[i]);\\n            difference.Append(\",\");\\n        }\\n\\n        return difference.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079107,
                "title": "easy-cpp-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Getting the index of string stored for each diff vector stored in the map.\\n- Then traverse the map, find the diff vector with number of index == 1, return the words ith index string as result.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int sz = words.size(), sz2 = words[0].length();\\n        map<vector<int>, vector<int>> mp;\\n        vector<int> v(sz2);\\n        for(int i=0; i<sz; i++){\\n            v.assign(sz2,0);\\n            for(int j=0; j<sz2-1; j++)\\n                v[j] = words[i][j+1] - words[i][j];\\n\\n            mp[v].push_back(i);\\n        }\\n        \\n        for(auto i : mp)\\n            if(i.second.size() == 1) return words[i.second[0]];\\n\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int sz = words.size(), sz2 = words[0].length();\\n        map<vector<int>, vector<int>> mp;\\n        vector<int> v(sz2);\\n        for(int i=0; i<sz; i++){\\n            v.assign(sz2,0);\\n            for(int j=0; j<sz2-1; j++)\\n                v[j] = words[i][j+1] - words[i][j];\\n\\n            mp[v].push_back(i);\\n        }\\n        \\n        for(auto i : mp)\\n            if(i.second.size() == 1) return words[i.second[0]];\\n\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057276,
                "title": "python3-hashmap-shift",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nSince the relative difference is the same, then the absolute difference to the first letter will also be the same. Therefore, we can shift all the letters in a word to a baseline \"a\". \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        \\n        def encode(s:str):\\n            shift = ord(s[0]) - ord(\\'a\\')\\n            w =[ chr(ord(i) - shift) for i in s]\\n            return \"\".join(w)\\n\\n        d = collections.defaultdict(list)\\n\\n        for word in words:\\n            d[encode(word)].append(word)\\n\\n        for k in d:\\n            if len(d[k]) == 1:\\n                return d[k][0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        \\n        def encode(s:str):\\n            shift = ord(s[0]) - ord(\\'a\\')\\n            w =[ chr(ord(i) - shift) for i in s]\\n            return \"\".join(w)\\n\\n        d = collections.defaultdict(list)\\n\\n        for word in words:\\n            d[encode(word)].append(word)\\n\\n        for k in d:\\n            if len(d[k]) == 1:\\n                return d[k][0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053531,
                "title": "92-runtime-85-memory-intresting-solution",
                "content": "![image.png](https://assets.leetcode.com/users/images/d7ba0b5e-ba08-4aff-9e25-cd5c24729d9b_1694910143.4078977.png)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        s = string.ascii_lowercase.index\\n\\n        def generate_list(w: str) -> list:\\n            return [s(w[j]) - s(w[j-1]) for j in range(1,length)]\\n\\n        w1, w2 = words[-1], words[-2]; length = len(w1)\\n        diff1 = generate_list(w1)\\n        diff2 = generate_list(w2)\\n        \\n        if diff1 != diff2:\\n            w3 = words[-3]\\n            diff3 = generate_list(w3)\\n\\n            if diff1 == diff3: return w2\\n            elif diff1 == diff2: return w3\\n            else: return w1\\n\\n        for w in words:\\n            arr = generate_list(w)\\n\\n            if diff1 != arr: return w\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        s = string.ascii_lowercase.index\\n\\n        def generate_list(w: str) -> list:\\n            return [s(w[j]) - s(w[j-1]) for j in range(1,length)]\\n\\n        w1, w2 = words[-1], words[-2]; length = len(w1)\\n        diff1 = generate_list(w1)\\n        diff2 = generate_list(w2)\\n        \\n        if diff1 != diff2:\\n            w3 = words[-3]\\n            diff3 = generate_list(w3)\\n\\n            if diff1 == diff3: return w2\\n            elif diff1 == diff2: return w3\\n            else: return w1\\n\\n        for w in words:\\n            arr = generate_list(w)\\n\\n            if diff1 != arr: return w\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050088,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String oddString(String[] w) {\\n        int n=w[0].length();\\n        int[] d=new int[n-1];\\n        for(int i=0;i<n-1;i++){\\n            d[i]=w[0].charAt(i+1)-w[0].charAt(i);\\n        }\\n        if(d[0]!=w[1].charAt(1)-w[1].charAt(0) && d[0]!=w[2].charAt(1)-w[2].charAt(0)){\\n            return w[0];\\n        }\\n        for(int j=0;j<w.length;j++){\\n            for(int i=0;i<n-1;i++){\\n                if(d[i]!=w[j].charAt(i+1)-w[j].charAt(i)){\\n                    return w[j];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] w) {\\n        int n=w[0].length();\\n        int[] d=new int[n-1];\\n        for(int i=0;i<n-1;i++){\\n            d[i]=w[0].charAt(i+1)-w[0].charAt(i);\\n        }\\n        if(d[0]!=w[1].charAt(1)-w[1].charAt(0) && d[0]!=w[2].charAt(1)-w[2].charAt(0)){\\n            return w[0];\\n        }\\n        for(int j=0;j<w.length;j++){\\n            for(int i=0;i<n-1;i++){\\n                if(d[i]!=w[j].charAt(i+1)-w[j].charAt(i)){\\n                    return w[j];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036997,
                "title": "short-python-solution",
                "content": "```\\n# https://leetcode.com/problems/odd-string-difference/\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        d = []\\n        for w in words:\\n            d.append(\\n                str([ord(y) - ord(x) for x, y in zip(w[1:], w[:-1])])\\n            )\\n\\t\\t\\t\\n        return words[d.index(Counter(d).most_common()[-1][0])]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# https://leetcode.com/problems/odd-string-difference/\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        d = []\\n        for w in words:\\n            d.append(\\n                str([ord(y) - ord(x) for x, y in zip(w[1:], w[:-1])])\\n            )\\n\\t\\t\\t\\n        return words[d.index(Counter(d).most_common()[-1][0])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032986,
                "title": "easy-python-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n\\n        # compute the distance between contiguous elements in a word\\n        # and store the list of distances as a key for a hashmap\\n        def shift(word):\\n            diff = []\\n            for i in range(1, len(word)):\\n                diff.append((ord(word[i]) - ord(word[i-1])) % 26)\\n            return \\'\\'.join(str(diff))  # this step IMPORTANT to store int list as a key\\n\\n        ans = collections.defaultdict(list)\\n        # iterate in the words list and compute the distance for each word\\n        for word in words:\\n            key = shift(word)\\n            # store the word according to the same distance\\n            ans[key].append(word)\\n            \\n        # return to the element with length 1 in the hashmap\\n        for item in ans:\\n            if len(ans[item]) == 1:\\n                return \\'\\'.join(ans[item])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n\\n        # compute the distance between contiguous elements in a word\\n        # and store the list of distances as a key for a hashmap\\n        def shift(word):\\n            diff = []\\n            for i in range(1, len(word)):\\n                diff.append((ord(word[i]) - ord(word[i-1])) % 26)\\n            return \\'\\'.join(str(diff))  # this step IMPORTANT to store int list as a key\\n\\n        ans = collections.defaultdict(list)\\n        # iterate in the words list and compute the distance for each word\\n        for word in words:\\n            key = shift(word)\\n            # store the word according to the same distance\\n            ans[key].append(word)\\n            \\n        # return to the element with length 1 in the hashmap\\n        for item in ans:\\n            if len(ans[item]) == 1:\\n                return \\'\\'.join(ans[item])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032805,
                "title": "java-2-solutions-with-without-hashset-in-detailed-explanations",
                "content": "# Intuition & Approach\\nThe basic idea of this problem is simple:\\n1. Find the difference integer array for each string.\\n2. Compare them to find the odd one out.\\n\\nTo find the difference integer array for each string, we can iterate on each word, letter by letter, to calculate the difference array.\\nTo compare the difference array, we can either use `Arrays.equals(arr1, arr2)` method in Java, or add the array into a HashSet and just observe the change in its size.\\n\\nPlease note that even if we use HashSet, we still need to check the first three words seperately since we cannot tell whether `words[0]` or `words[1]` is the odd one when `set.size` hits 2 immediately in the second iteration.\\n\\n# Complexity\\n- Time complexity: $$O(n * L)$$ where n is the number of words and L is the average length of the words.\\n- Space complexity: $$O(L)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n\\t\\t// No-HashSet Approach\\n        int n = words.length;\\n        int[] arr1 = diff(words[0]);\\n        int[] arr2 = diff(words[1]);\\n        int[] arr3 = diff(words[2]);\\n        if (Arrays.equals(arr2, arr3) && !Arrays.equals(arr1, arr2)) {\\n            return words[0];\\n        }\\n        for (int i = 3; i < n; i++) {\\n            if (!Arrays.equals(arr1, arr2) && !Arrays.equals(arr2, arr3)) {\\n                return words[i - 2];\\n            }\\n            arr1 = arr2;\\n            arr2 = arr3;\\n            arr3 = diff(words[i]);\\n        }\\n        if (!Arrays.equals(arr1, arr2) && !Arrays.equals(arr2, arr3)) {\\n            return words[n - 2];\\n        }\\n        return words[n - 1];\\n    }\\n    \\n    private int[] diff (String word) {\\n        int n = word.length();\\n        int[] diff = new int[n - 1];\\n        for (int i = 0; i < n - 1; i++) {\\n            diff[i] = word.charAt(i + 1) - word.charAt(i);\\n        }\\n        return diff;\\n    }\\n}\\n```\\n\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n\\t\\t// HashSet Approach\\n        int n = words.length;\\n        Set<String> set = new HashSet<>();\\n        int[] arr1 = diff(words[0]);\\n        int[] arr2 = diff(words[1]);\\n        int[] arr3 = diff(words[2]);\\n        if (Arrays.equals(arr2, arr3) && !Arrays.equals(arr1, arr2)) {\\n            return words[0];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            String s = Arrays.toString(diff(words[i]));\\n            set.add(s);\\n            if (set.size() == 2) {\\n                return words[i];\\n            }\\n        }\\n        return words[n - 1];\\n    }\\n    \\n    private int[] diff (String word) {\\n        int n = word.length();\\n        int[] diff = new int[n - 1];\\n        for (int i = 0; i < n - 1; i++) {\\n            diff[i] = word.charAt(i + 1) - word.charAt(i);\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n\\t\\t// No-HashSet Approach\\n        int n = words.length;\\n        int[] arr1 = diff(words[0]);\\n        int[] arr2 = diff(words[1]);\\n        int[] arr3 = diff(words[2]);\\n        if (Arrays.equals(arr2, arr3) && !Arrays.equals(arr1, arr2)) {\\n            return words[0];\\n        }\\n        for (int i = 3; i < n; i++) {\\n            if (!Arrays.equals(arr1, arr2) && !Arrays.equals(arr2, arr3)) {\\n                return words[i - 2];\\n            }\\n            arr1 = arr2;\\n            arr2 = arr3;\\n            arr3 = diff(words[i]);\\n        }\\n        if (!Arrays.equals(arr1, arr2) && !Arrays.equals(arr2, arr3)) {\\n            return words[n - 2];\\n        }\\n        return words[n - 1];\\n    }\\n    \\n    private int[] diff (String word) {\\n        int n = word.length();\\n        int[] diff = new int[n - 1];\\n        for (int i = 0; i < n - 1; i++) {\\n            diff[i] = word.charAt(i + 1) - word.charAt(i);\\n        }\\n        return diff;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n\\t\\t// HashSet Approach\\n        int n = words.length;\\n        Set<String> set = new HashSet<>();\\n        int[] arr1 = diff(words[0]);\\n        int[] arr2 = diff(words[1]);\\n        int[] arr3 = diff(words[2]);\\n        if (Arrays.equals(arr2, arr3) && !Arrays.equals(arr1, arr2)) {\\n            return words[0];\\n        }\\n        for (int i = 0; i < n; i++) {\\n            String s = Arrays.toString(diff(words[i]));\\n            set.add(s);\\n            if (set.size() == 2) {\\n                return words[i];\\n            }\\n        }\\n        return words[n - 1];\\n    }\\n    \\n    private int[] diff (String word) {\\n        int n = word.length();\\n        int[] diff = new int[n - 1];\\n        for (int i = 0; i < n - 1; i++) {\\n            diff[i] = word.charAt(i + 1) - word.charAt(i);\\n        }\\n        return diff;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031831,
                "title": "c-map-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int ct=0;\\n        \\n               map<vector<int>,int>mp;\\n                for(auto it:words)\\n             {\\n              vector<int>st;\\n              for(int i=1;i<it.size();i++)\\n                {\\n                  int v1=(it[i]-\\'a\\')-1,v2=(it[i-1]-\\'a\\')-1;\\n                  int diff=v2-v1;\\n                  \\n                   st.push_back(diff);\\n                }\\n                  mp[st]++;\\n             }\\n             for(auto it:words){\\n                 vector<int>st;\\n                 for(int i=1;i<it.size();i++)\\n                {\\n                  int v1=(it[i]-\\'a\\')-1,v2=(it[i-1]-\\'a\\')-1;\\n                  int diff=v2-v1;\\n                  \\n                   st.push_back(diff);\\n                }\\n                 if(mp[st]==1)\\n                 return it;\\n             }\\n      \\n             \\n          return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int ct=0;\\n        \\n               map<vector<int>,int>mp;\\n                for(auto it:words)\\n             {\\n              vector<int>st;\\n              for(int i=1;i<it.size();i++)\\n                {\\n                  int v1=(it[i]-\\'a\\')-1,v2=(it[i-1]-\\'a\\')-1;\\n                  int diff=v2-v1;\\n                  \\n                   st.push_back(diff);\\n                }\\n                  mp[st]++;\\n             }\\n             for(auto it:words){\\n                 vector<int>st;\\n                 for(int i=1;i<it.size();i++)\\n                {\\n                  int v1=(it[i]-\\'a\\')-1,v2=(it[i-1]-\\'a\\')-1;\\n                  int diff=v2-v1;\\n                  \\n                   st.push_back(diff);\\n                }\\n                 if(mp[st]==1)\\n                 return it;\\n             }\\n      \\n             \\n          return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031249,
                "title": "linear-solution-in-python-without-hashmaps",
                "content": "# Intuition\\n\\nThis explanation is maybe overcomplicated...sorry :-) ! Don\\'t hesitate to give me some advice to simplify it.\\n\\n1. We first compute the diff arrays for the first two words, let\\'s call them D1 and D2.\\n\\n2. If those diff arrays are the same, we just have to return the first word whose diff array is different (than the 2 first ones).\\n\\n3. If those diff arrays are different, then the third word has a diff array equals to D1 or D2.\\nIf it\\'s D1, then D1 appears twice and the answer is the word corresponding to D2.\\nAnd vice-versa : If it\\'s D2, then D2 appears twice and the answer is the word corresponding to D1.\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(N)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$ (no use of hashmaps here)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n        # We isolate the computation of the difference array in this function :\\n        def computeDiffArray(word: str):\\n            currentDiffArray = []\\n            prev = word[0]\\n\\n            for c in word[1:]:\\n                currentDiffArray.append(ord(c)-ord(prev))\\n                prev = c\\n            \\n            return currentDiffArray\\n\\n        candidateUniqueDiffArray0 = computeDiffArray(words[0])\\n        candidateUniqueDiffArray1 = computeDiffArray(words[1])\\n\\n        for word in words[2:]:\\n            if candidateUniqueDiffArray0 == candidateUniqueDiffArray1:\\n                if computeDiffArray(word) != candidateUniqueDiffArray0:\\n                    return word\\n            else:\\n                if computeDiffArray(word) == candidateUniqueDiffArray1:\\n                    return words[0]\\n                else:\\n                    return words[1]\\n            \\n        \\n        \\n        \\n\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n        # We isolate the computation of the difference array in this function :\\n        def computeDiffArray(word: str):\\n            currentDiffArray = []\\n            prev = word[0]\\n\\n            for c in word[1:]:\\n                currentDiffArray.append(ord(c)-ord(prev))\\n                prev = c\\n            \\n            return currentDiffArray\\n\\n        candidateUniqueDiffArray0 = computeDiffArray(words[0])\\n        candidateUniqueDiffArray1 = computeDiffArray(words[1])\\n\\n        for word in words[2:]:\\n            if candidateUniqueDiffArray0 == candidateUniqueDiffArray1:\\n                if computeDiffArray(word) != candidateUniqueDiffArray0:\\n                    return word\\n            else:\\n                if computeDiffArray(word) == candidateUniqueDiffArray1:\\n                    return words[0]\\n                else:\\n                    return words[1]\\n            \\n        \\n        \\n        \\n\\n        \\n\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4004905,
                "title": "fast-and-efficient-state-solution-c",
                "content": "# Intuition\\nLooking at the problem, best way to solve it would be always comparing the set number array, with the current one and returning the current one if its not the same\\n\\nHowever there is a problem\\n1. How do we decide which one is set\\n(set being the number array which we know can be at least twice calculated from the word vector)\\n\\n\\n\\n# Approach\\nIn order to solve the problem in one swoop, I have decided to use states. \\nThis allows me to handle everything in one loop, with simple check for each position in the number array and if there is something wrong, I let the program know and the program handles this information thanks to its state checks\\n\\nSo the ideal case here is:\\n1. Calculate the first number array from words[0]\\n2. Compare it with words[1], find out they are the same \\n3. Return anything that is any different from words[0] number array\\nThis would mean state 0 -> state 1 -> solution\\n\\nHowever what happens if the first number array is the odd one or if the second number array is the odd one?\\nFor simplicity sake and readability stake, why not just let the program know that that is what happened?\\nHere is how that goes\\n1. Calculate the first number array from words[0]\\n2. Compare it with words[1], find out they are different\\n3. Compare words[0] with words[2], find out if they are different\\n4. If they are, words[0] is the odd one, if not words[1] is odd\\nThis would mean state 0 -> state 2 -> state 3 -> solution\\n\\nNow that the program knows whats going on thanks to states, all I need to do is add state checks and state changes in the proper places and ensure state changes only when the proper conditions are met.\\n\\nThe ideal case is pretty straightforward, however in the second case scenario, I set state to 2 and right after it to 3. This is because the check for the last state happens right after state 2 is set, which indicates the scanario that words[1] odd. If the code never gets there, it is because right before it, on the third second itteration, difference between words[0] is again detected, indicating that words[0] is odd\\n                           \\n\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(n *m)$$ \\n\\n- Space complexity:\\n $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int state1 = 0;\\n        //0 -> beggining state\\n        //1 -> 2 in row were same therefor any that isnt same gets returned\\n        //2 -> first and second dont match\\n        //3 -> first and second dont match \\n\\n        int arrsize = words[0].length();\\n\\n        vector <int> arr1;\\n\\n\\n\\n        for (int i = 1; i < arrsize; i++) {\\n            arr1.push_back((words[0][i] - words[0][i - 1]));\\n        }\\n\\n\\n\\n\\n        state1 = 0;\\n        int i;\\n\\n        for (i = 1; i < words.size(); i++) {\\n            for (int x = 1; x < words[i].size(); x++) {\\n                if (((words[i][x] - words[i][x - 1])) != arr1[x - 1]) {\\n                    if (state1 == 1) { return words[i]; }\\n                    else if (state1 == 0) {\\n                        state1 = 2; break;\\n                    }\\n                    else { return words[0]; }\\n                }\\n                \\n\\n            }\\n            if (state1 == 0) state1 = 1;\\n            else if (state1 == 2) { state1 = 3; }\\n            else if (state1 == 3) { return words[i - 1]; }\\n        }\\n        return words[i];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int state1 = 0;\\n        //0 -> beggining state\\n        //1 -> 2 in row were same therefor any that isnt same gets returned\\n        //2 -> first and second dont match\\n        //3 -> first and second dont match \\n\\n        int arrsize = words[0].length();\\n\\n        vector <int> arr1;\\n\\n\\n\\n        for (int i = 1; i < arrsize; i++) {\\n            arr1.push_back((words[0][i] - words[0][i - 1]));\\n        }\\n\\n\\n\\n\\n        state1 = 0;\\n        int i;\\n\\n        for (i = 1; i < words.size(); i++) {\\n            for (int x = 1; x < words[i].size(); x++) {\\n                if (((words[i][x] - words[i][x - 1])) != arr1[x - 1]) {\\n                    if (state1 == 1) { return words[i]; }\\n                    else if (state1 == 0) {\\n                        state1 = 2; break;\\n                    }\\n                    else { return words[0]; }\\n                }\\n                \\n\\n            }\\n            if (state1 == 0) state1 = 1;\\n            else if (state1 == 2) { state1 = 3; }\\n            else if (state1 == 3) { return words[i - 1]; }\\n        }\\n        return words[i];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002879,
                "title": "easiest-explanation-with-commented-code",
                "content": "# Intuition\\nFirst we haveto calculate the diffrence pairs, then we will calculate if that diffrence pair is unique or not. So, here we can map the diffrence pairs with the corrosponding strings.\\n# Approach\\nIn the hashmap we will map the diffrence values with strings. If any diffrence pair match then we will push them in the vector<string> of that corrosponding diffrence vector.\\nIn the end, in map we check which diffrence pair has only 1 value to their string by using i.second in map. That string will be the output. So, we will give output i.second[0].\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        //take map to store diffrence pair with its strings.\\n        map<vector<int>,vector<string>>mp;\\n        for(auto i:words)\\n        {\\n            //to calculate diffrence pairs & store it in v\\n            vector<int>v;\\n            for(int j=1;j<i.size();j++)\\n            {\\n                v.push_back(i[j]-i[j-1]);\\n            }\\n            //Add the string with corrosponding diffrence pair\\n            mp[v].push_back(i);\\n        }\\n        //Check if size of any diffrence pair is 1 then give that string as output\\n        for(auto i:mp)\\n        {\\n            if(i.second.size()==1) return i.second[0];\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        //take map to store diffrence pair with its strings.\\n        map<vector<int>,vector<string>>mp;\\n        for(auto i:words)\\n        {\\n            //to calculate diffrence pairs & store it in v\\n            vector<int>v;\\n            for(int j=1;j<i.size();j++)\\n            {\\n                v.push_back(i[j]-i[j-1]);\\n            }\\n            //Add the string with corrosponding diffrence pair\\n            mp[v].push_back(i);\\n        }\\n        //Check if size of any diffrence pair is 1 then give that string as output\\n        for(auto i:mp)\\n        {\\n            if(i.second.size()==1) return i.second[0];\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981269,
                "title": "don-t-forget-the-key-here-is-my-solution",
                "content": "I think i don\\'t need to two values which are `strings` and `nums` like that. It is better to make the list using `ord()`.\\nBut\\' that\\'s my first approach. I think it might be faster than this if it is changed.\\nAnyway, Thanks for reading :)\\nIf you help this, Please thumbs up!\\nIt will make me motive ^.^\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        strings = list(string.ascii_lowercase)\\n        nums = [i for i in range(0, 26)]\\n        sets = dict(zip(strings, nums))\\n        ans, key_val = {}, {}\\n        for i in range(len(words)):\\n            temp = []\\n            for j in range(len(words[i])-1):\\n                temp.append(sets[words[i][j+1]] - sets[words[i][j]])\\n            temp_2_str = \\'\\'.join(str(temp))\\n            if temp_2_str not in ans:\\n                ans[temp_2_str] = 1\\n                key_val[temp_2_str] = i\\n            else:\\n                ans[temp_2_str] += 1\\n        diff_key = [k for k, v in ans.items() if v == min(ans.values())]\\n        return words[key_val[diff_key[0]]]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        strings = list(string.ascii_lowercase)\\n        nums = [i for i in range(0, 26)]\\n        sets = dict(zip(strings, nums))\\n        ans, key_val = {}, {}\\n        for i in range(len(words)):\\n            temp = []\\n            for j in range(len(words[i])-1):\\n                temp.append(sets[words[i][j+1]] - sets[words[i][j]])\\n            temp_2_str = \\'\\'.join(str(temp))\\n            if temp_2_str not in ans:\\n                ans[temp_2_str] = 1\\n                key_val[temp_2_str] = i\\n            else:\\n                ans[temp_2_str] += 1\\n        diff_key = [k for k, v in ans.items() if v == min(ans.values())]\\n        return words[key_val[diff_key[0]]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961992,
                "title": "fast-elegant-solution-beats-100",
                "content": "# Intuition\\n`\\uD83C\\uDF74 Don\\'t forget to UpVote \\uD83C\\uDF74`\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n\\n- Space complexity: $$O(n*m)$$\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int n = words[0].size();\\n        string word = words[0];\\n        vector<int> vec(n-1);\\n        for(int i=0; i<n-1; i++) {\\n            vec[i] = (word[i+1]-\\'a\\') - (word[i]-\\'a\\');\\n        }\\n        int diff = 0;\\n        string ans;\\n    \\n        for(int k=1; k<words.size(); k++) {\\n            vector<int> v(n-1);\\n            for(int i=0; i<n-1; i++) {\\n                v[i] = (words[k][i+1]-\\'a\\') - (words[k][i]-\\'a\\');\\n            }\\n            if(vec != v) {\\n                ans = words[k];\\n                diff++;\\n            }\\n            if(diff > 1) return words[0];\\n            if(diff == 1 && k>1) return ans;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Greedy"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int n = words[0].size();\\n        string word = words[0];\\n        vector<int> vec(n-1);\\n        for(int i=0; i<n-1; i++) {\\n            vec[i] = (word[i+1]-\\'a\\') - (word[i]-\\'a\\');\\n        }\\n        int diff = 0;\\n        string ans;\\n    \\n        for(int k=1; k<words.size(); k++) {\\n            vector<int> v(n-1);\\n            for(int i=0; i<n-1; i++) {\\n                v[i] = (words[k][i+1]-\\'a\\') - (words[k][i]-\\'a\\');\\n            }\\n            if(vec != v) {\\n                ans = words[k];\\n                diff++;\\n            }\\n            if(diff > 1) return words[0];\\n            if(diff == 1 && k>1) return ans;\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960735,
                "title": "simple-and-precise-dart-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n String oddString(List<String> words) {\\n  int n = words[0].length;\\n\\n  // Taking first 3 arrays for checking the difference\\n  List<int> nums0 = List<int>.filled(n, 0);\\n  List<int> nums1 = List<int>.filled(n, 0);\\n  List<int> nums2 = List<int>.filled(n, 0);\\n\\n\\n  // Find the difference integer array for first three strings.\\n  for (int i = 0; i < n - 1; i++) {\\n    nums0[i] = words[0].codeUnitAt(i + 1) - words[0].codeUnitAt(i);\\n    nums1[i] = words[1].codeUnitAt(i + 1) - words[1].codeUnitAt(i);\\n    nums2[i] = words[2].codeUnitAt(i + 1) - words[2].codeUnitAt(i);\\n  }\\n\\n  // Check if there is any odd, then we have found the answer and no need of further checking rest of the strings in the array\\n  if (listEquals(nums0, nums1) && !listEquals(nums0, nums2)) return words[2];\\n  if (listEquals(nums0, nums2) && !listEquals(nums1, nums2)) return words[1];\\n  if (listEquals(nums2, nums1) && !listEquals(nums0, nums2)) return words[0];\\n\\n  // If all above are equal, then it means that the ans is in the remainder of the strings\\n\\n  // Thus iterating over Strings and find first odd one\\n\\n  for (int j = 3; j < words.length; j++) {\\n    List<int> temp = List<int>.filled(n, 0);\\n    for (int i = 0; i < n - 1; i++) {\\n      temp[i] = words[j].codeUnitAt(i + 1) - words[j].codeUnitAt(i);\\n    }\\n    if (!listEquals(nums0, temp)) return words[j];\\n  }\\n\\n  return words[0]; \\n\\n// As it is guaranteed that there is an ans, the code will never reach this point\\n\\n  // So, just adding the return statement to complete the code\\n}\\n\\nbool listEquals(List a, List b) {\\n  if (identical(a, b)) return true;\\n  if (a.length != b.length) return false;\\n  for (var i = 0; i < a.length; i++) {\\n    if (a[i] != b[i]) return false;\\n  }\\n  return true;\\n}\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n String oddString(List<String> words) {\\n  int n = words[0].length;\\n\\n  // Taking first 3 arrays for checking the difference\\n  List<int> nums0 = List<int>.filled(n, 0);\\n  List<int> nums1 = List<int>.filled(n, 0);\\n  List<int> nums2 = List<int>.filled(n, 0);\\n\\n\\n  // Find the difference integer array for first three strings.\\n  for (int i = 0; i < n - 1; i++) {\\n    nums0[i] = words[0].codeUnitAt(i + 1) - words[0].codeUnitAt(i);\\n    nums1[i] = words[1].codeUnitAt(i + 1) - words[1].codeUnitAt(i);\\n    nums2[i] = words[2].codeUnitAt(i + 1) - words[2].codeUnitAt(i);\\n  }\\n\\n  // Check if there is any odd, then we have found the answer and no need of further checking rest of the strings in the array\\n  if (listEquals(nums0, nums1) && !listEquals(nums0, nums2)) return words[2];\\n  if (listEquals(nums0, nums2) && !listEquals(nums1, nums2)) return words[1];\\n  if (listEquals(nums2, nums1) && !listEquals(nums0, nums2)) return words[0];\\n\\n  // If all above are equal, then it means that the ans is in the remainder of the strings\\n\\n  // Thus iterating over Strings and find first odd one\\n\\n  for (int j = 3; j < words.length; j++) {\\n    List<int> temp = List<int>.filled(n, 0);\\n    for (int i = 0; i < n - 1; i++) {\\n      temp[i] = words[j].codeUnitAt(i + 1) - words[j].codeUnitAt(i);\\n    }\\n    if (!listEquals(nums0, temp)) return words[j];\\n  }\\n\\n  return words[0]; \\n\\n// As it is guaranteed that there is an ans, the code will never reach this point\\n\\n  // So, just adding the return statement to complete the code\\n}\\n\\nbool listEquals(List a, List b) {\\n  if (identical(a, b)) return true;\\n  if (a.length != b.length) return false;\\n  for (var i = 0; i < a.length; i++) {\\n    if (a[i] != b[i]) return false;\\n  }\\n  return true;\\n}\\n\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3897152,
                "title": "java-solution-using-hashmap",
                "content": "```\\n\\nclass Solution {\\n    public String oddString(String[] words) {\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n        char a = \\'a\\';\\n        //Mapping characters to their index positions\\n        for(int i = 0; i<26; i++){\\n            map.put((char) (a++), i);\\n        }\\n\\t\\t\\n        //String that is used to store non-odd difference integer array (Ex. [3, -1])\\n        String basic = \"\";\\n        \\n\\t\\t//Check if first 2 words has same difference integer array then set basic as below\\n        if(Arrays.toString(calc(words[0], map)).equals(Arrays.toString(calc(words[1], map)))){\\n                basic = Arrays.toString(calc(words[0], map));\\n        }\\n\\t\\t\\n\\t\\t//If first two elements have different integer array then we have our answer in first 2 words, \\n\\t\\t//so just check the difference integer array of 1st and 2nd word with the 3rd one and return the answer\\n\\t\\telse{\\n            if(Arrays.toString(calc(words[0], map)).equals(Arrays.toString(calc(words[2], map)))){\\n                return words[1];\\n            }else{\\n                return words[0];\\n            }\\n        }\\n        \\n\\t\\t//At this point we know that our answer in not in first two words and we got the non-odd array stored in basic\\n\\t\\t//So we just need to check for each word if its difference integer array is same as basic or not\\n        for(int i = 2; i<words.length; i++){\\n            if(!Arrays.toString(calc(words[i], map)).equals(basic)){\\n                return words[i];\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n    \\n\\t//Calculates difference integer array for string\\n    public int[] calc(String str, Map<Character, Integer> map){\\n        \\n        int n = str.length();\\n        int[] arr = new int[n-1];\\n        \\n        for(int i = 0; i<n-1; i++){\\n            arr[i] = map.get(str.charAt(i+1)) - map.get(str.charAt(i));\\n        }\\n        return arr;\\n    }\\n}\\n\\n//This is my first DISCUSS comment solution in leetcode so kindly ignore my naive posting mistakes\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public String oddString(String[] words) {\\n        \\n        Map<Character, Integer> map = new HashMap<>();\\n        char a = \\'a\\';\\n        //Mapping characters to their index positions\\n        for(int i = 0; i<26; i++){\\n            map.put((char) (a++), i);\\n        }\\n\\t\\t\\n        //String that is used to store non-odd difference integer array (Ex. [3, -1])\\n        String basic = \"\";\\n        \\n\\t\\t//Check if first 2 words has same difference integer array then set basic as below\\n        if(Arrays.toString(calc(words[0], map)).equals(Arrays.toString(calc(words[1], map)))){\\n                basic = Arrays.toString(calc(words[0], map));\\n        }\\n\\t\\t\\n\\t\\t//If first two elements have different integer array then we have our answer in first 2 words, \\n\\t\\t//so just check the difference integer array of 1st and 2nd word with the 3rd one and return the answer\\n\\t\\telse{\\n            if(Arrays.toString(calc(words[0], map)).equals(Arrays.toString(calc(words[2], map)))){\\n                return words[1];\\n            }else{\\n                return words[0];\\n            }\\n        }\\n        \\n\\t\\t//At this point we know that our answer in not in first two words and we got the non-odd array stored in basic\\n\\t\\t//So we just need to check for each word if its difference integer array is same as basic or not\\n        for(int i = 2; i<words.length; i++){\\n            if(!Arrays.toString(calc(words[i], map)).equals(basic)){\\n                return words[i];\\n            }\\n        }\\n        \\n        return \"\";\\n    }\\n    \\n\\t//Calculates difference integer array for string\\n    public int[] calc(String str, Map<Character, Integer> map){\\n        \\n        int n = str.length();\\n        int[] arr = new int[n-1];\\n        \\n        for(int i = 0; i<n-1; i++){\\n            arr[i] = map.get(str.charAt(i+1)) - map.get(str.charAt(i));\\n        }\\n        return arr;\\n    }\\n}\\n\\n//This is my first DISCUSS comment solution in leetcode so kindly ignore my naive posting mistakes\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860240,
                "title": "java-100-speed-91-memory-optimal-way-no-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        \\n        int[] arr0 = getArray(words[0]);\\n        int[] arr1 = getArray(words[1]);\\n\\n        if (Arrays.equals(arr0, arr1) == false) {\\n            int[] arr2 = getArray(words[2]);\\n            if (Arrays.equals(arr0, arr2) == true) {\\n                return words[1];\\n            } else {\\n                return words[0];\\n            }\\n        }\\n\\n        arr1 = null;\\n\\n        for (int k = 2; k < words.length; k++) {\\n            String string = words[k];\\n            for (int i = 0; i < string.length() - 1; i++) {\\n                if (arr0[i] != (string.charAt(i + 1) - \\'a\\') - (string.charAt(i) - \\'a\\')) {\\n                    return string;\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    private int[] getArray(String string) {\\n        int[] array = new int[string.length() - 1];\\n\\n        for (int i = 0; i < string.length() - 1; i++) {\\n            array[i] = (string.charAt(i + 1) - \\'a\\') - (string.charAt(i) - \\'a\\');\\n        }\\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        \\n        int[] arr0 = getArray(words[0]);\\n        int[] arr1 = getArray(words[1]);\\n\\n        if (Arrays.equals(arr0, arr1) == false) {\\n            int[] arr2 = getArray(words[2]);\\n            if (Arrays.equals(arr0, arr2) == true) {\\n                return words[1];\\n            } else {\\n                return words[0];\\n            }\\n        }\\n\\n        arr1 = null;\\n\\n        for (int k = 2; k < words.length; k++) {\\n            String string = words[k];\\n            for (int i = 0; i < string.length() - 1; i++) {\\n                if (arr0[i] != (string.charAt(i + 1) - \\'a\\') - (string.charAt(i) - \\'a\\')) {\\n                    return string;\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    private int[] getArray(String string) {\\n        int[] array = new int[string.length() - 1];\\n\\n        for (int i = 0; i < string.length() - 1; i++) {\\n            array[i] = (string.charAt(i + 1) - \\'a\\') - (string.charAt(i) - \\'a\\');\\n        }\\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845283,
                "title": "swift-two-two-line-functions",
                "content": "# Code\\n```\\nclass Solution {\\n    func stringDifference(_ s: String) -> [Int] {\\n        let asciiValues = s.compactMap { $0.asciiValue }\\n        return (1..<asciiValues.count).map { Int(asciiValues[$0]) - Int(asciiValues[$0 - 1])}\\n    }\\n    \\n    func oddString(_ words: [String]) -> String {\\n        let diffGroups = Dictionary(grouping: words, by: { stringDifference($0) })\\n        return diffGroups.filter { $0.value.count == 1}[0].value[0]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func stringDifference(_ s: String) -> [Int] {\\n        let asciiValues = s.compactMap { $0.asciiValue }\\n        return (1..<asciiValues.count).map { Int(asciiValues[$0]) - Int(asciiValues[$0 - 1])}\\n    }\\n    \\n    func oddString(_ words: [String]) -> String {\\n        let diffGroups = Dictionary(grouping: words, by: { stringDifference($0) })\\n        return diffGroups.filter { $0.value.count == 1}[0].value[0]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843228,
                "title": "js-for-and-while",
                "content": "# Intuition\\nloop through the words and calculate them sum, then compare the sums\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar oddString = function(words) {\\n    var l = words.length  \\n    var arr = []\\n\\n    // calculate the sum of differences between chars\\n    // for the entire words\\n    for (var i = 0; i < l; i++){\\n       var diff = 0;\\n        for (var j = 1; j < words[i].length; j++){\\n            var c0 = words[i][j-1].charCodeAt(0)\\n            var c1 = words[i][j].charCodeAt(0)\\n            diff += diff+(c1-c0)\\n        }\\n        arr.push(diff)      //// build array for the sums\\n    }\\n\\n    var checked = []        //// pop() from arr[] and dump here\\n\\n    while(arr.length>0){    \\n        var d = arr.pop()   //// pop() from arr[] ...\\n        var bool0 = arr.includes(d)\\n        var bool1 = checked.includes(d)\\n\\n        if(!bool0 && !bool1){return words[arr.length]}\\n        checked.push(d)     //// ... and dump here\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar oddString = function(words) {\\n    var l = words.length  \\n    var arr = []\\n\\n    // calculate the sum of differences between chars\\n    // for the entire words\\n    for (var i = 0; i < l; i++){\\n       var diff = 0;\\n        for (var j = 1; j < words[i].length; j++){\\n            var c0 = words[i][j-1].charCodeAt(0)\\n            var c1 = words[i][j].charCodeAt(0)\\n            diff += diff+(c1-c0)\\n        }\\n        arr.push(diff)      //// build array for the sums\\n    }\\n\\n    var checked = []        //// pop() from arr[] and dump here\\n\\n    while(arr.length>0){    \\n        var d = arr.pop()   //// pop() from arr[] ...\\n        var bool0 = arr.includes(d)\\n        var bool1 = checked.includes(d)\\n\\n        if(!bool0 && !bool1){return words[arr.length]}\\n        checked.push(d)     //// ... and dump here\\n    }\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3832769,
                "title": "hash-table-and-helper-function",
                "content": "# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        def diff(word):\\n            result = []\\n            for i in range(1, len(word)):\\n                result.append(ord(word[i]) - ord(word[i - 1]))\\n            return tuple(result)\\n\\n        count = {}\\n        for i in words:\\n            d = diff(i)\\n            if d not in count:\\n                count[d] = [i]\\n            else:\\n                count[d].append(i)\\n\\n        for val in count.values():\\n            if len(val) == 1:\\n                return val[0] \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        def diff(word):\\n            result = []\\n            for i in range(1, len(word)):\\n                result.append(ord(word[i]) - ord(word[i - 1]))\\n            return tuple(result)\\n\\n        count = {}\\n        for i in words:\\n            d = diff(i)\\n            if d not in count:\\n                count[d] = [i]\\n            else:\\n                count[d].append(i)\\n\\n        for val in count.values():\\n            if len(val) == 1:\\n                return val[0] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827427,
                "title": "0ms-runtime-100-beats-very-easy-and-understandable-solution-in-java",
                "content": "# Intuition:\\n\\nThe code is aimed at finding the odd string among a given array of strings based on a specific pattern in their characters. It compares the differences between consecutive characters in the first two strings and stores them in arrays `arr1` and `arr2`. Then, it checks if the pattern of differences in the subsequent strings matches either `arr1` or `arr2` to identify the odd string.\\n\\n# Approach:\\n\\n1. The `checkArray` method is used to compare two arrays `arr1` and `arr2` to determine if they are equal.\\n\\n2. The `oddString` method starts by handling the base case when there is only one string in the array (`words.length == 1`), in which case it returns that string.\\n\\n3. It initializes the `len` variable to the length of the first string (`words[0]`).\\n\\n4. Two arrays `arr1` and `arr2` are initialized with the differences between consecutive characters in `words[0]` and `words[1]`, respectively.\\n\\n5. If `arr1` and `arr2` are identical (checked by `checkArray(arr1, arr2)`), it means the odd string should have a different pattern of differences. The code then iterates through the subsequent strings starting from the third one (`k=2`) and compares their differences with `arr1`. If there is a mismatch, the corresponding string is returned as the odd string.\\n\\n6. If `arr1` and `arr2` are not identical, it means the odd string should have the same pattern as `arr1`. The code then iterates through the subsequent strings starting from the third one (`k=2`) and compares their differences with `arr1`. If there is a match, `words[1]` is returned as the odd string; otherwise, `words[0]` is returned.\\n\\n#Time Complexity:\\n\\nThe time complexity of the code is O(n * m), where n is the number of strings in the input array `words`, and m is the length of the first string in the array (`words[0]`). This is because the code iterates through all strings in the array and processes each character in the strings to calculate the differences.\\n\\nIn the worst case, the entire array of strings needs to be traversed, and for each string, all its characters need to be processed to determine the odd string. Thus, the overall time complexity is O(n * m).\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public boolean checkArray(int[] arr1,int[] arr2){\\n        for(int i=0;i<arr1.length;i++){\\n            if(arr1[i] != arr2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public String oddString(String[] words) {\\n\\n        if(words.length == 1){\\n            return words[0];\\n        }\\n        \\n        int len = words[0].length();\\n\\n        int[] arr1 = new int[len-1];\\n        int[] arr2 = new int[len-1];\\n        \\n        for(int j=1;j<len;j++){\\n            arr1[j-1] = words[0].charAt(j) - words[0].charAt(j-1);\\n            arr2[j-1] = words[1].charAt(j) - words[1].charAt(j-1);\\n        }\\n\\n        if(checkArray(arr1,arr2)){\\n            //  System.out.print(\"in if\");\\n            int[] res = new int[len-1];\\n            for(int k = 2;k<words.length;k++){\\n                for(int l=1;l<len;l++){\\n                    res[l-1] = words[k].charAt(l) - words[k].charAt(l-1);\\n            \\n                }\\n                if(!checkArray(arr1,res)){\\n                    return words[k];\\n                }\\n            }\\n        }\\n        else{\\n            // System.out.print(\"in else\");\\n            int[] res = new int[len-1];\\n            for(int k = 2;k<words.length;k++){\\n                for(int l=1;l<len;l++){\\n                    res[l-1] = words[k].charAt(l) - words[k].charAt(l-1);\\n            \\n                }\\n                if(checkArray(arr1,res)){\\n                    return words[1];\\n                }\\n                else{\\n                    return words[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public boolean checkArray(int[] arr1,int[] arr2){\\n        for(int i=0;i<arr1.length;i++){\\n            if(arr1[i] != arr2[i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public String oddString(String[] words) {\\n\\n        if(words.length == 1){\\n            return words[0];\\n        }\\n        \\n        int len = words[0].length();\\n\\n        int[] arr1 = new int[len-1];\\n        int[] arr2 = new int[len-1];\\n        \\n        for(int j=1;j<len;j++){\\n            arr1[j-1] = words[0].charAt(j) - words[0].charAt(j-1);\\n            arr2[j-1] = words[1].charAt(j) - words[1].charAt(j-1);\\n        }\\n\\n        if(checkArray(arr1,arr2)){\\n            //  System.out.print(\"in if\");\\n            int[] res = new int[len-1];\\n            for(int k = 2;k<words.length;k++){\\n                for(int l=1;l<len;l++){\\n                    res[l-1] = words[k].charAt(l) - words[k].charAt(l-1);\\n            \\n                }\\n                if(!checkArray(arr1,res)){\\n                    return words[k];\\n                }\\n            }\\n        }\\n        else{\\n            // System.out.print(\"in else\");\\n            int[] res = new int[len-1];\\n            for(int k = 2;k<words.length;k++){\\n                for(int l=1;l<len;l++){\\n                    res[l-1] = words[k].charAt(l) - words[k].charAt(l-1);\\n            \\n                }\\n                if(checkArray(arr1,res)){\\n                    return words[1];\\n                }\\n                else{\\n                    return words[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826590,
                "title": "python-beats-97-66-and-98-70",
                "content": "![\\u672A\\u547D\\u540D.png](https://assets.leetcode.com/users/images/c81cc639-4412-46c7-81cf-d2a2d0688e72_1690515032.7771666.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        l = []\\n        t = []\\n        d = {}\\n\\n        for i in range(0,len(words)):\\n            for j in range(1,len(words[i])):\\n                l.append(ord(words[i][j]) - ord(words[i][j-1]))\\n            t.append(l)\\n            l = []\\n        \\n        if t[0] == t[1]:\\n            for i in range(2,len(t)):\\n                if t[i] != t[0]:\\n                    return words[i]\\n        elif t[0] != t[1]:\\n            if t[2] == t[0]:\\n                return words[1]\\n            else:\\n                return words[0]\\n\\n        # 20230728\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        l = []\\n        t = []\\n        d = {}\\n\\n        for i in range(0,len(words)):\\n            for j in range(1,len(words[i])):\\n                l.append(ord(words[i][j]) - ord(words[i][j-1]))\\n            t.append(l)\\n            l = []\\n        \\n        if t[0] == t[1]:\\n            for i in range(2,len(t)):\\n                if t[i] != t[0]:\\n                    return words[i]\\n        elif t[0] != t[1]:\\n            if t[2] == t[0]:\\n                return words[1]\\n            else:\\n                return words[0]\\n\\n        # 20230728\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825864,
                "title": "try-switching-the-loops-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy iterating along the word length instead of the number of words, we can quickly find the outlier.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nIterate over the length of the first word, and then compute a difference frequency for all words at that index.\\n\\nThis method can find the different word by only finding the first occurrence of a different character difference. This might return after just a single character of each word is checked!\\n\\nMy solution beats 100% in both time and memory.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ / Constant Extra Space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nconst oddString = function(words) {\\n    // Iterating along the word length\\n    for (let i = 0; i < words[0].length - 1; ++i) {\\n        // Using array because a hashmap with just 2 keys is overkill\\n        const counts = [];\\n        // Compute the frequency of each difference at index i\\n        for (let j = 0; j < words.length; ++j) {\\n            const diff = words[j].charCodeAt(i + 1) - words[j].charCodeAt(i);\\n            // Update the frequency map\\n            if (counts.length == 0) {\\n                counts.push([diff, j, 1]);\\n            } else if (counts[0][0] == diff) {\\n                counts[0][2] += 1;\\n            } else if (counts.length == 1) {\\n                counts.push([diff, j, 1]);\\n            } else {\\n                counts[1][2] += 1;\\n            }\\n        }\\n        // Simply find if any count is equal to 1 and return the relevant index\\n        for (const [key, index, count] of counts) {\\n            if (count == 1) {\\n                return words[index];\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nconst oddString = function(words) {\\n    // Iterating along the word length\\n    for (let i = 0; i < words[0].length - 1; ++i) {\\n        // Using array because a hashmap with just 2 keys is overkill\\n        const counts = [];\\n        // Compute the frequency of each difference at index i\\n        for (let j = 0; j < words.length; ++j) {\\n            const diff = words[j].charCodeAt(i + 1) - words[j].charCodeAt(i);\\n            // Update the frequency map\\n            if (counts.length == 0) {\\n                counts.push([diff, j, 1]);\\n            } else if (counts[0][0] == diff) {\\n                counts[0][2] += 1;\\n            } else if (counts.length == 1) {\\n                counts.push([diff, j, 1]);\\n            } else {\\n                counts[1][2] += 1;\\n            }\\n        }\\n        // Simply find if any count is equal to 1 and return the relevant index\\n        for (const [key, index, count] of counts) {\\n            if (count == 1) {\\n                return words[index];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3788281,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        vector<vector<int>> differenceArray;\\n        string word = words[0];\\n\\n        vector<int> diff;\\n        for (int i = 0 ; i < word.length()-1 ; i++){\\n            int n1 = word[i+1] - \\'a\\';\\n            int n2 = word[i] - \\'a\\';\\n            diff.push_back(n1 - n2);\\n        }\\n        differenceArray.push_back(diff);\\n        string ans = \"\";\\n\\n        for (int i=1 ; i<words.size() ; i++){\\n            diff = {};\\n            for (int j=0 ; j<words[i].length()-1 ; j++){\\n                int n1 = words[i][j+1]-\\'a\\';\\n                int n2 = words[i][j] - \\'a\\';\\n                diff.push_back(n1 - n2);\\n            }\\n            differenceArray.push_back(diff);\\n        }    \\n        for (int i=1 ; i<differenceArray.size()-1 ; i++){\\n            if (differenceArray[i] != differenceArray[i-1] && differenceArray[i] == differenceArray[i+1]){\\n                ans = words[i-1];\\n                break;\\n            } \\n            else if (differenceArray[i] == differenceArray[i-1] && differenceArray[i] != differenceArray[i+1]){\\n                ans = words[i+1];\\n                break;\\n            }\\n            else if (differenceArray[i+1] == differenceArray[i-1] && differenceArray[i] != differenceArray[i+1]){\\n                ans = words[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        vector<vector<int>> differenceArray;\\n        string word = words[0];\\n\\n        vector<int> diff;\\n        for (int i = 0 ; i < word.length()-1 ; i++){\\n            int n1 = word[i+1] - \\'a\\';\\n            int n2 = word[i] - \\'a\\';\\n            diff.push_back(n1 - n2);\\n        }\\n        differenceArray.push_back(diff);\\n        string ans = \"\";\\n\\n        for (int i=1 ; i<words.size() ; i++){\\n            diff = {};\\n            for (int j=0 ; j<words[i].length()-1 ; j++){\\n                int n1 = words[i][j+1]-\\'a\\';\\n                int n2 = words[i][j] - \\'a\\';\\n                diff.push_back(n1 - n2);\\n            }\\n            differenceArray.push_back(diff);\\n        }    \\n        for (int i=1 ; i<differenceArray.size()-1 ; i++){\\n            if (differenceArray[i] != differenceArray[i-1] && differenceArray[i] == differenceArray[i+1]){\\n                ans = words[i-1];\\n                break;\\n            } \\n            else if (differenceArray[i] == differenceArray[i-1] && differenceArray[i] != differenceArray[i+1]){\\n                ans = words[i+1];\\n                break;\\n            }\\n            else if (differenceArray[i+1] == differenceArray[i-1] && differenceArray[i] != differenceArray[i+1]){\\n                ans = words[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3784070,
                "title": "intuitive-typescript-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. convert each word to its difference integer array `differences `\\n2. find the unique difference integer array among others\\n3. return its corresponding \\'word\\'\\n\\n# Complexity\\n- Time complexity: O(nk) + O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction oddString(words: string[]): string {\\n    const n = words[0].length;\\n\\n    const differences = words.map(word => {\\n        const difference = [];\\n        for (let i = 0; i < n - 1; i++) {\\n            difference.push(word[i+1].charCodeAt(0) - word[i].charCodeAt(0));\\n        }\\n        return difference;\\n    });\\n\\n    const resultIndex = differences.findIndex((x, i) => \\n        !differences.some((xx, ii) => String(x) === String(xx) && i !== ii)\\n    );\\n    return words[resultIndex];\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction oddString(words: string[]): string {\\n    const n = words[0].length;\\n\\n    const differences = words.map(word => {\\n        const difference = [];\\n        for (let i = 0; i < n - 1; i++) {\\n            difference.push(word[i+1].charCodeAt(0) - word[i].charCodeAt(0));\\n        }\\n        return difference;\\n    });\\n\\n    const resultIndex = differences.findIndex((x, i) => \\n        !differences.some((xx, ii) => String(x) === String(xx) && i !== ii)\\n    );\\n    return words[resultIndex];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3782428,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar oddString = function(words) {\\n    let obj = {};\\n    let diff = [];\\n\\n    words.forEach(word => {\\n        let arr = [];\\n        for (let i=0; i< word.length -1;i++) {\\n            arr.push((word.charCodeAt(i+1) - 97) - (word.charCodeAt(i) - 97));\\n        }\\n        diff.push(arr.toString());\\n    });\\n\\n    for (let i=0 ;i< diff.length;i++) {\\n        if(!obj[diff[i]]) {\\n            obj[diff[i]] = 1;\\n        } else {\\n            obj[diff[i]] = obj[diff[i]] +1;\\n        }\\n    }\\n   \\n   for (key in obj) {\\n       if(obj[key] === 1) {\\n           return words[diff.indexOf(key)];\\n       }\\n   }\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar oddString = function(words) {\\n    let obj = {};\\n    let diff = [];\\n\\n    words.forEach(word => {\\n        let arr = [];\\n        for (let i=0; i< word.length -1;i++) {\\n            arr.push((word.charCodeAt(i+1) - 97) - (word.charCodeAt(i) - 97));\\n        }\\n        diff.push(arr.toString());\\n    });\\n\\n    for (let i=0 ;i< diff.length;i++) {\\n        if(!obj[diff[i]]) {\\n            obj[diff[i]] = 1;\\n        } else {\\n            obj[diff[i]] = obj[diff[i]] +1;\\n        }\\n    }\\n   \\n   for (key in obj) {\\n       if(obj[key] === 1) {\\n           return words[diff.indexOf(key)];\\n       }\\n   }\\n    \\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3772527,
                "title": "simple-to-think",
                "content": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>&w){\\n        vector<vector<int>>v;\\n        for(int i=0; i<w.size(); i++){\\n            vector<int>t;\\n            for(int j=1; j<w[i].size(); j++){\\n                t.push_back(w[i][j]-w[i][j-1]);\\n            }\\n            v.push_back(t);\\n        }\\n        int idx=-1;\\n        for(int i=0; i<v.size()-2; i++){\\n            if(v[i]!=v[i+1] && v[i+1]!=v[i+2]){\\n                idx = i+1;\\n            }\\n        }\\n        if(idx==-1){\\n            if(v[0]!=v[1]){\\n                idx=0;\\n            }\\n            if(v[v.size()-1]!=v[v.size()-2]){\\n                idx=v.size()-1;\\n            }\\n        }\\n        return w[idx];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>&w){\\n        vector<vector<int>>v;\\n        for(int i=0; i<w.size(); i++){\\n            vector<int>t;\\n            for(int j=1; j<w[i].size(); j++){\\n                t.push_back(w[i][j]-w[i][j-1]);\\n            }\\n            v.push_back(t);\\n        }\\n        int idx=-1;\\n        for(int i=0; i<v.size()-2; i++){\\n            if(v[i]!=v[i+1] && v[i+1]!=v[i+2]){\\n                idx = i+1;\\n            }\\n        }\\n        if(idx==-1){\\n            if(v[0]!=v[1]){\\n                idx=0;\\n            }\\n            if(v[v.size()-1]!=v[v.size()-2]){\\n                idx=v.size()-1;\\n            }\\n        }\\n        return w[idx];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771813,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n * m), where n is the number of words in the input vector and m is the length of the longest word\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(m) where m is the word[0].size()\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        vector<int> diff;\\n        for(int i=0; i < words[0].size() -1; i++) diff.push_back(words[0][i+1] - words[0][i]);\\n        int d = 0, trigger = 0;\\n        string temp;\\n        for(int i=1; i < words.size(); i++){\\n            int flag=0;\\n            for(int j=0; j < words[i].size()-1; j++){\\n                if(words[i][j+1] - words[i][j] != diff[j]){\\n                    if(trigger) return words[i];\\n                    else{\\n                        temp = words[i];\\n                        flag=1;\\n                    }\\n                }\\n            }\\n            if(flag) d++;\\n            if(i > 2 and d <= 1) trigger = 1;\\n            if(d>1) return words[0];\\n        }\\n        return temp;\\n    }\\n};\\n```\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        vector<int> diff;\\n        for(int i=0; i < words[0].size() -1; i++){\\n            diff.push_back(words[0][i+1] - words[0][i]);\\n        }\\n        int d = 0;\\n        string temp;\\n        for(int i=1; i < words.size(); i++){\\n            int flag=0;\\n            for(int j=0; j < words[i].size()-1; j++){\\n                if(words[i][j+1] - words[i][j] != diff[j]){\\n                    temp = words[i];\\n                    flag=1;\\n                }\\n            }\\n            if(flag) d++;\\n            if(d>1) return words[0];\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        vector<int> diff;\\n        for(int i=0; i < words[0].size() -1; i++) diff.push_back(words[0][i+1] - words[0][i]);\\n        int d = 0, trigger = 0;\\n        string temp;\\n        for(int i=1; i < words.size(); i++){\\n            int flag=0;\\n            for(int j=0; j < words[i].size()-1; j++){\\n                if(words[i][j+1] - words[i][j] != diff[j]){\\n                    if(trigger) return words[i];\\n                    else{\\n                        temp = words[i];\\n                        flag=1;\\n                    }\\n                }\\n            }\\n            if(flag) d++;\\n            if(i > 2 and d <= 1) trigger = 1;\\n            if(d>1) return words[0];\\n        }\\n        return temp;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        vector<int> diff;\\n        for(int i=0; i < words[0].size() -1; i++){\\n            diff.push_back(words[0][i+1] - words[0][i]);\\n        }\\n        int d = 0;\\n        string temp;\\n        for(int i=1; i < words.size(); i++){\\n            int flag=0;\\n            for(int j=0; j < words[i].size()-1; j++){\\n                if(words[i][j+1] - words[i][j] != diff[j]){\\n                    temp = words[i];\\n                    flag=1;\\n                }\\n            }\\n            if(flag) d++;\\n            if(d>1) return words[0];\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765360,
                "title": "simple-kotlin-solution-without-map",
                "content": "# Code\\n```\\nclass Solution {\\n    fun oddString(words: Array<String>): String {\\n        var i = 0\\n\\n        while (i < words.size) {\\n            val oddWord = findOddWord(words[i], words[i+1], words[i+2])\\n            if (oddWord != \"\") return oddWord\\n            i++\\n        }\\n\\n        return \"\"\\n    }\\n\\n    private fun findOddWord(word1: String, word2: String, word3: String): String {\\n        var i = 1\\n\\n        while (i < word1.length) {\\n            val diff1 = word1[i] - word1[i-1]\\n            val diff2 = word2[i] - word2[i-1]\\n            val diff3 = word3[i] - word3[i-1]\\n\\n            if (diff1 == diff2 && diff2 == diff3)\\n                i++\\n            else return if (diff1 == diff2) word3\\n                    else if (diff1 == diff3) word2\\n                    else word1\\n        }\\n\\n        return \"\"\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun oddString(words: Array<String>): String {\\n        var i = 0\\n\\n        while (i < words.size) {\\n            val oddWord = findOddWord(words[i], words[i+1], words[i+2])\\n            if (oddWord != \"\") return oddWord\\n            i++\\n        }\\n\\n        return \"\"\\n    }\\n\\n    private fun findOddWord(word1: String, word2: String, word3: String): String {\\n        var i = 1\\n\\n        while (i < word1.length) {\\n            val diff1 = word1[i] - word1[i-1]\\n            val diff2 = word2[i] - word2[i-1]\\n            val diff3 = word3[i] - word3[i-1]\\n\\n            if (diff1 == diff2 && diff2 == diff3)\\n                i++\\n            else return if (diff1 == diff2) word3\\n                    else if (diff1 == diff3) word2\\n                    else word1\\n        }\\n\\n        return \"\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750992,
                "title": "two-hash-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc oddString(w []string) string {\\n    maps := map[string]int{}\\n    maps2 := map[string]string{}\\n    for i := 0; i < len(w); i++{\\n        s := w[i]\\n        arr := \"\"\\n        for j := 0; j < len(s)-1; j++{\\n            res := getAlp(byte(s[j+1])) - getAlp(byte(s[j]))\\n            arr = arr +\",\"+ strconv.Itoa(res)\\n        }\\n            maps[arr]++\\n            maps2[arr] = s\\n    } \\n   \\n   for k,v := range maps{\\n       if v == 1{\\n           return maps2[k]\\n       }\\n   }\\n    return \"\"\\n}\\n\\nfunc getAlp(letter byte)int{\\n    switch letter{\\n        case \\'a\\':\\n        return 0\\n        case \\'b\\':\\n        return 1\\n        case \\'c\\':\\n        return 2\\n        case \\'d\\':\\n        return 3\\n        case \\'e\\':\\n        return 4\\n        case \\'f\\':\\n        return 5\\n        case \\'g\\':\\n        return 6\\n        case \\'h\\':\\n        return 7\\n        case \\'i\\':\\n        return 8\\n        case \\'j\\':\\n        return 9\\n        case \\'k\\':\\n        return 10\\n        case \\'l\\':\\n        return 11\\n        case \\'m\\':\\n        return 12\\n        case \\'n\\':\\n        return 13\\n        case \\'o\\':\\n        return 14\\n        case \\'p\\':\\n        return 15\\n        case \\'q\\':\\n        return 16\\n        case \\'r\\':\\n        return 17\\n        case \\'s\\':\\n        return 18\\n        case \\'t\\':\\n        return 19\\n        case \\'u\\':\\n        return 20\\n        case \\'v\\':\\n        return 21\\n        case \\'w\\':\\n        return 22\\n        case \\'x\\':\\n        return 23\\n        case \\'y\\':\\n        return 24\\n        case \\'z\\':\\n        return 25\\n    }\\n    return -1\\n}\\nfunc alp(maps map[string]int){\\n    for i := 0; i <= 25; i++{\\n        maps[string(\\'a\\' + i)]=i\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc oddString(w []string) string {\\n    maps := map[string]int{}\\n    maps2 := map[string]string{}\\n    for i := 0; i < len(w); i++{\\n        s := w[i]\\n        arr := \"\"\\n        for j := 0; j < len(s)-1; j++{\\n            res := getAlp(byte(s[j+1])) - getAlp(byte(s[j]))\\n            arr = arr +\",\"+ strconv.Itoa(res)\\n        }\\n            maps[arr]++\\n            maps2[arr] = s\\n    } \\n   \\n   for k,v := range maps{\\n       if v == 1{\\n           return maps2[k]\\n       }\\n   }\\n    return \"\"\\n}\\n\\nfunc getAlp(letter byte)int{\\n    switch letter{\\n        case \\'a\\':\\n        return 0\\n        case \\'b\\':\\n        return 1\\n        case \\'c\\':\\n        return 2\\n        case \\'d\\':\\n        return 3\\n        case \\'e\\':\\n        return 4\\n        case \\'f\\':\\n        return 5\\n        case \\'g\\':\\n        return 6\\n        case \\'h\\':\\n        return 7\\n        case \\'i\\':\\n        return 8\\n        case \\'j\\':\\n        return 9\\n        case \\'k\\':\\n        return 10\\n        case \\'l\\':\\n        return 11\\n        case \\'m\\':\\n        return 12\\n        case \\'n\\':\\n        return 13\\n        case \\'o\\':\\n        return 14\\n        case \\'p\\':\\n        return 15\\n        case \\'q\\':\\n        return 16\\n        case \\'r\\':\\n        return 17\\n        case \\'s\\':\\n        return 18\\n        case \\'t\\':\\n        return 19\\n        case \\'u\\':\\n        return 20\\n        case \\'v\\':\\n        return 21\\n        case \\'w\\':\\n        return 22\\n        case \\'x\\':\\n        return 23\\n        case \\'y\\':\\n        return 24\\n        case \\'z\\':\\n        return 25\\n    }\\n    return -1\\n}\\nfunc alp(maps map[string]int){\\n    for i := 0; i <= 25; i++{\\n        maps[string(\\'a\\' + i)]=i\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3748602,
                "title": "python-simple-solution-bruteforce-list-comparison",
                "content": "# Complexity\\n- Time complexity: $$O(n ^ 2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def oddString(self, words: List[str]) -> str:\\n    difference = []\\n    for i in range(1, len(words[0])):\\n      difference.append(ord(words[0][i]) - ord(words[0][i - 1]))\\n    \\n    index = 0\\n    counter = 0    \\n    for i in range(1, len(words)):\\n      current_difference = []\\n      for j in range(1, len(words[i])):\\n        current_difference.append(ord(words[i][j]) - ord(words[i][j - 1]))\\n      if difference != current_difference:\\n        counter += 1\\n        index = i\\n    if counter >= 2:\\n      return words[0]\\n\\n    return words[index]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n  def oddString(self, words: List[str]) -> str:\\n    difference = []\\n    for i in range(1, len(words[0])):\\n      difference.append(ord(words[0][i]) - ord(words[0][i - 1]))\\n    \\n    index = 0\\n    counter = 0    \\n    for i in range(1, len(words)):\\n      current_difference = []\\n      for j in range(1, len(words[i])):\\n        current_difference.append(ord(words[i][j]) - ord(words[i][j - 1]))\\n      if difference != current_difference:\\n        counter += 1\\n        index = i\\n    if counter >= 2:\\n      return words[0]\\n\\n    return words[index]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736912,
                "title": "very-easy-jebasraja",
                "content": "# Intuition:karunya university:Accenture\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n {\\n    public String oddString(String[] words)\\n     {\\n\\n  \\n //String[] words = {\"abm\",\"bcn\",\"alm\"};\\n\\nHashMap<String,Integer> map=new HashMap<String,Integer>();\\n\\nString str=\"\";\\n\\n\\nfor (int i = 0; i < words.length; i++) \\n{\\n    for (int j = 0; j <=words[i].length()-2; j++) \\n    {\\n         int a=words[i].charAt(j+1);\\n         int b=words[i].charAt(j);\\n       \\n        str+=String.valueOf(a-b)+\",\"; \\n    }\\n    //System.out.println(str);\\n    if (map.containsKey(str))\\n    {\\n         map.put(str, 999);      \\n    }\\n    else\\n    {\\n     map.put(str, i);\\n    }\\n    str=\"\";   \\n}\\n\\nSystem.out.println(\"mapping\");\\n \\n int finalanswer=0;\\n\\nfor (Map.Entry<String,Integer> entry:map.entrySet()) \\n{\\n //System.out.println(entry.getKey()+\" \"+entry.getValue()); \\nif (entry.getValue()!=999)\\n{\\n  System.out.println(entry.getKey()+\" \"+entry.getValue());\\n  System.out.println(words[entry.getValue()]);\\n // return \\n  finalanswer=entry.getValue();\\n}\\n}\\n\\nreturn words[finalanswer];\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n {\\n    public String oddString(String[] words)\\n     {\\n\\n  \\n //String[] words = {\"abm\",\"bcn\",\"alm\"};\\n\\nHashMap<String,Integer> map=new HashMap<String,Integer>();\\n\\nString str=\"\";\\n\\n\\nfor (int i = 0; i < words.length; i++) \\n{\\n    for (int j = 0; j <=words[i].length()-2; j++) \\n    {\\n         int a=words[i].charAt(j+1);\\n         int b=words[i].charAt(j);\\n       \\n        str+=String.valueOf(a-b)+\",\"; \\n    }\\n    //System.out.println(str);\\n    if (map.containsKey(str))\\n    {\\n         map.put(str, 999);      \\n    }\\n    else\\n    {\\n     map.put(str, i);\\n    }\\n    str=\"\";   \\n}\\n\\nSystem.out.println(\"mapping\");\\n \\n int finalanswer=0;\\n\\nfor (Map.Entry<String,Integer> entry:map.entrySet()) \\n{\\n //System.out.println(entry.getKey()+\" \"+entry.getValue()); \\nif (entry.getValue()!=999)\\n{\\n  System.out.println(entry.getKey()+\" \"+entry.getValue());\\n  System.out.println(words[entry.getValue()]);\\n // return \\n  finalanswer=entry.getValue();\\n}\\n}\\n\\nreturn words[finalanswer];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729655,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar oddString = function(words) {\\n    const map = {};\\n    const result = {};\\n    for (const word of words) {\\n        let key = \\'\\';\\n        for (let i = 1; i < word.length; i++) {\\n            key += `_${word[i].charCodeAt() - word[i-1].charCodeAt()}`;\\n        }\\n        map[key] = ++map[key] || 1;\\n        result[key] = word;\\n    }\\n    \\n    const key = Object.keys(map).find(e => map[e] === 1);\\n    \\n    return result[key];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar oddString = function(words) {\\n    const map = {};\\n    const result = {};\\n    for (const word of words) {\\n        let key = \\'\\';\\n        for (let i = 1; i < word.length; i++) {\\n            key += `_${word[i].charCodeAt() - word[i-1].charCodeAt()}`;\\n        }\\n        map[key] = ++map[key] || 1;\\n        result[key] = word;\\n    }\\n    \\n    const key = Object.keys(map).find(e => map[e] === 1);\\n    \\n    return result[key];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3646266,
                "title": "easy-to-understand-python",
                "content": "# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n\\n        diff = []\\n\\n        for word in words:\\n            curr = []\\n            for i in range(1, len(word)):\\n                curr.append((ord(word[i]) - ord(\\'a\\')) - (ord(word[i - 1]) - ord(\\'a\\')))\\n            diff.append(curr)\\n        \\n        for i in range(len(diff)):\\n            if diff.count(diff[i]) == 1:\\n                return words[i]\\n\\n        \\n```\\n# Complexity\\n- Time complexity: O(n * m)  where n is  the number of words and m in the length of letters\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) the number of words\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n\\n        diff = []\\n\\n        for word in words:\\n            curr = []\\n            for i in range(1, len(word)):\\n                curr.append((ord(word[i]) - ord(\\'a\\')) - (ord(word[i - 1]) - ord(\\'a\\')))\\n            diff.append(curr)\\n        \\n        for i in range(len(diff)):\\n            if diff.count(diff[i]) == 1:\\n                return words[i]\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639213,
                "title": "super-easy-understandable-code",
                "content": "# Intuition\\nfind the difference array\\n\\n# Approach\\nloop over evert word\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ * $$O(l)$$ \\n\\n- Space complexity:\\n$$O(l)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int n = words[0].length();\\n        int l = words.size();\\n\\n        cout<<n<<\" \"<<l;\\n\\n        // vector<vector<int>> diff;\\n        int index = -1;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            vector <int> row;\\n            \\n            for(int j=0;j<l;j++)\\n            {\\n                int diff = words[j][i+1]-words[j][i];\\n                row.push_back(diff);\\n            }\\n\\n            for(int k=0;k<l;k++)\\n            {\\n                if(row[0]!=row[1])\\n                {\\n                    if(row[0]==row[2])\\n                    index=1;\\n                    else\\n                    index=0;\\n                }\\n                else\\n                {\\n                    if(row[0]!=row[k])\\n                    index=k;\\n                }\\n            }\\n\\n            if(index!=-1)\\n            return words[index];\\n\\n        }\\n        return words[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int n = words[0].length();\\n        int l = words.size();\\n\\n        cout<<n<<\" \"<<l;\\n\\n        // vector<vector<int>> diff;\\n        int index = -1;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            vector <int> row;\\n            \\n            for(int j=0;j<l;j++)\\n            {\\n                int diff = words[j][i+1]-words[j][i];\\n                row.push_back(diff);\\n            }\\n\\n            for(int k=0;k<l;k++)\\n            {\\n                if(row[0]!=row[1])\\n                {\\n                    if(row[0]==row[2])\\n                    index=1;\\n                    else\\n                    index=0;\\n                }\\n                else\\n                {\\n                    if(row[0]!=row[k])\\n                    index=k;\\n                }\\n            }\\n\\n            if(index!=-1)\\n            return words[index];\\n\\n        }\\n        return words[0];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3631045,
                "title": "easy-hashmap-dictionary",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        alpha = dict(zip(map(chr,range(97,123)),range(0,26)))\\n        ans = {}\\n        for i in range(len(words)):\\n            t = []\\n            for j in range(len(words[i])-1):\\n                t.append(alpha[words[i][j]]-alpha[words[i][j+1]])\\n       \\n            if str(t) in ans:\\n            \\n                ans[str(t)].append(words[i])\\n            else:\\n          \\n                ans[str(t)] = [words[i]]\\n\\n        for x in ans:\\n            print(x,ans[x])\\n            if len(ans[x])==1:\\n                return ans[x][0]\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        alpha = dict(zip(map(chr,range(97,123)),range(0,26)))\\n        ans = {}\\n        for i in range(len(words)):\\n            t = []\\n            for j in range(len(words[i])-1):\\n                t.append(alpha[words[i][j]]-alpha[words[i][j+1]])\\n       \\n            if str(t) in ans:\\n            \\n                ans[str(t)].append(words[i])\\n            else:\\n          \\n                ans[str(t)] = [words[i]]\\n\\n        for x in ans:\\n            print(x,ans[x])\\n            if len(ans[x])==1:\\n                return ans[x][0]\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623705,
                "title": "beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar oddString = function(words) {\\n    // find the difference of each word, and create another array to stroe those arrays\\n    let wordsArr = []\\n    for (let i = 0; i < words.length; i++) {\\n        let word = words[i]\\n        let wordArr = []\\n        for (let j = 0; j < word.length - 1; j++) {\\n            let letter = word[j]\\n            wordArr.push(word[j + 1].charCodeAt(0) - word[j].charCodeAt(0))\\n        }\\n        wordsArr.push(wordArr)\\n    }\\n    // console.log(wordsArr)\\n\\n    // Make the map with the key of the arrays. If is duplicated, the valuse is false\\n    let map = new Map()\\n    for (let i = 0; i < words.length; i++) {\\n            if (!map.has(JSON.stringify(wordsArr[i]))) {\\n                map.set(JSON.stringify(wordsArr[i]), words[i])\\n            } else {\\n                map.set(JSON.stringify(wordsArr[i]), false)\\n            }\\n    }\\n\\n    // find the valus not equal to false\\n    let res = \"\"\\n    for (const [key, value] of map) {\\n        if (value !== false) {\\n            res += value\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string}\\n */\\nvar oddString = function(words) {\\n    // find the difference of each word, and create another array to stroe those arrays\\n    let wordsArr = []\\n    for (let i = 0; i < words.length; i++) {\\n        let word = words[i]\\n        let wordArr = []\\n        for (let j = 0; j < word.length - 1; j++) {\\n            let letter = word[j]\\n            wordArr.push(word[j + 1].charCodeAt(0) - word[j].charCodeAt(0))\\n        }\\n        wordsArr.push(wordArr)\\n    }\\n    // console.log(wordsArr)\\n\\n    // Make the map with the key of the arrays. If is duplicated, the valuse is false\\n    let map = new Map()\\n    for (let i = 0; i < words.length; i++) {\\n            if (!map.has(JSON.stringify(wordsArr[i]))) {\\n                map.set(JSON.stringify(wordsArr[i]), words[i])\\n            } else {\\n                map.set(JSON.stringify(wordsArr[i]), false)\\n            }\\n    }\\n\\n    // find the valus not equal to false\\n    let res = \"\"\\n    for (const [key, value] of map) {\\n        if (value !== false) {\\n            res += value\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612291,
                "title": "odd-string-difference-easy-approach-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) \\n    {\\n        unordered_map<string, int> mp;\\n        unordered_map<string, string> amp;\\n        for(auto w: words){ \\n            string s = \"\"; \\n            for(int j = 0; j < w.size()-1; ++j)\\n            {\\n                int t = w[j+1] - w[j];\\n                s += to_string(t) + \"_\";\\n            }\\n            mp[s]++;\\n            amp[s] = w; \\n        }\\n        for(auto m: mp)\\n        {\\n            if(m.second == 1) return amp[m.first]; \\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) \\n    {\\n        unordered_map<string, int> mp;\\n        unordered_map<string, string> amp;\\n        for(auto w: words){ \\n            string s = \"\"; \\n            for(int j = 0; j < w.size()-1; ++j)\\n            {\\n                int t = w[j+1] - w[j];\\n                s += to_string(t) + \"_\";\\n            }\\n            mp[s]++;\\n            amp[s] = w; \\n        }\\n        for(auto m: mp)\\n        {\\n            if(m.second == 1) return amp[m.first]; \\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586341,
                "title": "best-c-solution-ever-you-seen",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        string p=\"\";\\n        map<string,int>mp;\\n        map<string,string>np;\\n         map<string,int> :: iterator it;\\n         map<string,string> :: iterator rt;\\n        int n;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j=0;j<words[i].size()-1;j++)\\n            {\\n                n=(words[i][j+1]-words[i][j]);\\n                p=p+to_string(n);\\n            }\\n            mp[p]++;\\n            np[p]=words[i];\\n            p.clear();\\n        }\\n        rt=np.begin();\\n        for(it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second==1)\\n            {\\n                rt=np.find(it->first);\\n                break;\\n            }\\n        }\\n        \\n          return rt->second;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        string p=\"\";\\n        map<string,int>mp;\\n        map<string,string>np;\\n         map<string,int> :: iterator it;\\n         map<string,string> :: iterator rt;\\n        int n;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            for(int j=0;j<words[i].size()-1;j++)\\n            {\\n                n=(words[i][j+1]-words[i][j]);\\n                p=p+to_string(n);\\n            }\\n            mp[p]++;\\n            np[p]=words[i];\\n            p.clear();\\n        }\\n        rt=np.begin();\\n        for(it=mp.begin();it!=mp.end();it++)\\n        {\\n            if(it->second==1)\\n            {\\n                rt=np.find(it->first);\\n                break;\\n            }\\n        }\\n        \\n          return rt->second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585244,
                "title": "sumit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        l=[]\\n        m=[]\\n        for i in words:\\n            for j in range(len(i)-1):\\n                l.append(ord(i[j+1])-ord(i[j]))\\n            x=l.copy()\\n            m.append([x,i])\\n            l.clear()\\n            m.sort()\\n        for i in range(len(m)-1):\\n            if m[i][0]!=m[i+1][0]:\\n                if m[i-1][0]==m[i][0]:\\n                    return m[i+1][1]\\n                return m[i][1]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        l=[]\\n        m=[]\\n        for i in words:\\n            for j in range(len(i)-1):\\n                l.append(ord(i[j+1])-ord(i[j]))\\n            x=l.copy()\\n            m.append([x,i])\\n            l.clear()\\n            m.sort()\\n        for i in range(len(m)-1):\\n            if m[i][0]!=m[i+1][0]:\\n                if m[i-1][0]==m[i][0]:\\n                    return m[i+1][1]\\n                return m[i][1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580280,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        auto diff = [](const auto& string){\\n            vector<int> result;\\n            for (auto i = 1; i < string.size(); ++i)\\n                result.push_back(string[i] - string[i - 1]);\\n            return result;    \\n        };\\n        auto d1 = diff(words[0]), d2 = diff(words[1]), d3 = diff(words[2]);\\n        if (d2 == d3 && d1 != d2) return words[0];\\n        if (d1 == d3 && d1 != d2) return words[1];\\n        if (d1 == d2 && d2 != d3) return words[2];\\n        for (auto i = 3; i < words.size(); ++i)\\n            if (diff(words[i]) != d1) return words[i];\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        auto diff = [](const auto& string){\\n            vector<int> result;\\n            for (auto i = 1; i < string.size(); ++i)\\n                result.push_back(string[i] - string[i - 1]);\\n            return result;    \\n        };\\n        auto d1 = diff(words[0]), d2 = diff(words[1]), d3 = diff(words[2]);\\n        if (d2 == d3 && d1 != d2) return words[0];\\n        if (d1 == d3 && d1 != d2) return words[1];\\n        if (d1 == d2 && d2 != d3) return words[2];\\n        for (auto i = 3; i < words.size(); ++i)\\n            if (diff(words[i]) != d1) return words[i];\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579377,
                "title": "java-clean-100-simple",
                "content": "# Code\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int foundIndex = 0;\\n        int count = 0;\\n        for (int i = 1; i < words.length; i++) {\\n            if (isMatching(words[0], words[i])) {\\n                count++;\\n            } else {\\n                foundIndex = i;\\n            }\\n        }\\n        if (count == 0) return words[0];\\n        return words[foundIndex];\\n    }\\n    public boolean isMatching(String a, String b) {\\n        for (int i = 0; i < a.length() - 1; i++) {\\n            if (a.charAt(i + 1) - a.charAt(i) != b.charAt(i + 1) - b.charAt(i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int foundIndex = 0;\\n        int count = 0;\\n        for (int i = 1; i < words.length; i++) {\\n            if (isMatching(words[0], words[i])) {\\n                count++;\\n            } else {\\n                foundIndex = i;\\n            }\\n        }\\n        if (count == 0) return words[0];\\n        return words[foundIndex];\\n    }\\n    public boolean isMatching(String a, String b) {\\n        for (int i = 0; i < a.length() - 1; i++) {\\n            if (a.charAt(i + 1) - a.charAt(i) != b.charAt(i + 1) - b.charAt(i)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3576377,
                "title": "brute-force-with-descent-speed-and-o-1-memory-usage-easy-no-hashset-or-something-alike",
                "content": "# Intuition\\nBasic approach is to calculate an array for each word, which I do not like. I do want to keep less in memory;\\n\\n# Approach\\n1. We may use \\'IsEqual\\' function, where we compare letter-by-letter the differences in two strings. If any diffenrence occurs, their arrays are not equal.\\n2. We will compare first two strings:\\n3. If they are equal, any of them should be used as a reference. We will cycle through the \\'words\\' array till we find any word which has different array. We will use our \\'IsEqual\\' function.\\n4. If first two words differs in terms of their target arrays, it would be enough to compare them to the 3-d string.\\n\\n# Complexity\\n- Time complexity: less than O(n*words.Length)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic class Solution {\\n    public string OddString(string[] words) {\\n        if (areArraysEqual(words[0],words[1]) ) {\\n            // This means, that 1-st word is OK and we can compare to it\\n            for (int i=2; i<words.Length; i++){\\n                if ( areArraysEqual(words[0],words[i])==false ) return words[i];\\n            }\\n        }\\n        // Else case means that 1st or 2nd word is the exception\\n        else {\\n            if ( areArraysEqual(words[2],words[1]) ) return words[0];\\n            else return words[1];\\n        }\\n        // Never be here\\n        return \"_error_\";\\n    }\\n\\n    static bool areArraysEqual(string w1, string w2) {\\n        if (w1.Length != w2.Length) return false;\\n        for (int i = 1; i < w1.Length; i++)\\n            if ( w1[i]-w1[i-1] != w2[i]-w2[i-1] ) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "```\\npublic class Solution {\\n    public string OddString(string[] words) {\\n        if (areArraysEqual(words[0],words[1]) ) {\\n            // This means, that 1-st word is OK and we can compare to it\\n            for (int i=2; i<words.Length; i++){\\n                if ( areArraysEqual(words[0],words[i])==false ) return words[i];\\n            }\\n        }\\n        // Else case means that 1st or 2nd word is the exception\\n        else {\\n            if ( areArraysEqual(words[2],words[1]) ) return words[0];\\n            else return words[1];\\n        }\\n        // Never be here\\n        return \"_error_\";\\n    }\\n\\n    static bool areArraysEqual(string w1, string w2) {\\n        if (w1.Length != w2.Length) return false;\\n        for (int i = 1; i < w1.Length; i++)\\n            if ( w1[i]-w1[i-1] != w2[i]-w2[i-1] ) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575957,
                "title": "easy-solution-in-4-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        k,arr=len(words[0]),[]\\n        for i in words:  \\n            arr.append([ord(i[j])-ord(i[j-1]) for j in range(1,k)])\\n        return \\'\\'.join(words[i] for i in range(len(arr)) if arr.count(arr[i])==1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        k,arr=len(words[0]),[]\\n        for i in words:  \\n            arr.append([ord(i[j])-ord(i[j-1]) for j in range(1,k)])\\n        return \\'\\'.join(words[i] for i in range(len(arr)) if arr.count(arr[i])==1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568449,
                "title": "kotlin-solution-using-hashmap",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nm)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nm)\\n\\n# Code\\n```\\nclass Solution {\\n    fun oddString(words: Array<String>): String {\\n        val diffMap = mutableMapOf<String, Int>()\\n        words.forEach { word ->\\n            val diffArray = getDiffArray(word)\\n            diffMap[diffArray] = diffMap.getOrDefault(diffArray, 0) + 1\\n        }\\n        return words.first { word -> diffMap[getDiffArray(word)] == 1 }\\n    }\\n\\n    fun getDiffArray(word: String): String {\\n        val diffArray = StringBuilder()\\n        for (i in 1 until word.length) {\\n            diffArray.append(word[i] - word[i - 1])\\n            diffArray.append(\\',\\')\\n        }\\n        return diffArray.toString()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun oddString(words: Array<String>): String {\\n        val diffMap = mutableMapOf<String, Int>()\\n        words.forEach { word ->\\n            val diffArray = getDiffArray(word)\\n            diffMap[diffArray] = diffMap.getOrDefault(diffArray, 0) + 1\\n        }\\n        return words.first { word -> diffMap[getDiffArray(word)] == 1 }\\n    }\\n\\n    fun getDiffArray(word: String): String {\\n        val diffArray = StringBuilder()\\n        for (i in 1 until word.length) {\\n            diffArray.append(word[i] - word[i - 1])\\n            diffArray.append(\\',\\')\\n        }\\n        return diffArray.toString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3568359,
                "title": "runtime-beats-100-memory-beats-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string getKey(const string& w) {\\n        string k = w;\\n        int diff = w[0]-\\'a\\';\\n        for (int i = 0; i < w.size(); i++) k[i]-=diff;\\n        return k;\\n    }\\n    string oddString(vector<string>& words) {\\n        unordered_map<string, int> cnt;\\n        string key;\\n        for (auto &w : words) {\\n            string k = getKey(w);\\n            if (++cnt[k] > 1) {\\n                key = k;\\n                break;\\n            }\\n        }\\n        for (auto & w : words)\\n            if (getKey(w) != key) return w;\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string getKey(const string& w) {\\n        string k = w;\\n        int diff = w[0]-\\'a\\';\\n        for (int i = 0; i < w.size(); i++) k[i]-=diff;\\n        return k;\\n    }\\n    string oddString(vector<string>& words) {\\n        unordered_map<string, int> cnt;\\n        string key;\\n        for (auto &w : words) {\\n            string k = getKey(w);\\n            if (++cnt[k] > 1) {\\n                key = k;\\n                break;\\n            }\\n        }\\n        for (auto & w : words)\\n            if (getKey(w) != key) return w;\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565365,
                "title": "0ms-beat-100-java-easy-to-read",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int diff = -99; // default value\\n        String original = null;\\n        int i = 0;\\n        int count = 0;\\n        while (i <= words[0].length()-2) {\\n            diff = -99;\\n            count = 0;\\n            for (int s = 0; s < words.length; s++) {\\n                if (diff == -99) {\\n                    diff = words[s].charAt(i+1) - words[s].charAt(i);\\n                    original = words[s];\\n                    continue;\\n                }\\n                if (words[s].charAt(i+1) - words[s].charAt(i) != diff) {\\n                    diff = words[s].charAt(i+1) - words[s].charAt(i);\\n                    if (++count == 2)\\n                        return original;\\n                    original = words[s];\\n                }\\n            }\\n            if (count == 1) {\\n                if (words[0].charAt(i+1) - words[0].charAt(i)\\n                    != words[1].charAt(i+1) - words[1].charAt(i))\\n                    return words[0];\\n                if (words[words.length-1].charAt(i+1) - words[words.length-1].charAt(i)\\n                    != words[words.length-2].charAt(i+1) - words[words.length-2].charAt(i))\\n                    return words[words.length-1];\\n            }\\n            i++;\\n        }\\n        return words[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int diff = -99; // default value\\n        String original = null;\\n        int i = 0;\\n        int count = 0;\\n        while (i <= words[0].length()-2) {\\n            diff = -99;\\n            count = 0;\\n            for (int s = 0; s < words.length; s++) {\\n                if (diff == -99) {\\n                    diff = words[s].charAt(i+1) - words[s].charAt(i);\\n                    original = words[s];\\n                    continue;\\n                }\\n                if (words[s].charAt(i+1) - words[s].charAt(i) != diff) {\\n                    diff = words[s].charAt(i+1) - words[s].charAt(i);\\n                    if (++count == 2)\\n                        return original;\\n                    original = words[s];\\n                }\\n            }\\n            if (count == 1) {\\n                if (words[0].charAt(i+1) - words[0].charAt(i)\\n                    != words[1].charAt(i+1) - words[1].charAt(i))\\n                    return words[0];\\n                if (words[words.length-1].charAt(i+1) - words[words.length-1].charAt(i)\\n                    != words[words.length-2].charAt(i+1) - words[words.length-2].charAt(i))\\n                    return words[words.length-1];\\n            }\\n            i++;\\n        }\\n        return words[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560414,
                "title": "lc-2451-e-python3-a-plain-solution",
                "content": "Find the common difference and check those words.\\nTC: $\\\\Omicron(mn)$ | SC: $\\\\Omicron(n)$. \\n\\n```Python3 []\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        m, n = len(words), len(words[0])\\n        diffs = [[] for _ in range(3)]\\n        for i in range(3):\\n            diffs[i] = [ord(words[i][j+1]) - ord(words[i][j]) for j in range(n-1)]\\n            if diffs[0] == diffs[1]:\\n                diff = diffs[0]\\n                break\\n        if diffs[2]:\\n            return words[1] if diffs[0] == diffs[2] else words[0]\\n\\n        for i in range(2, m):\\n            if [ord(words[i][j+1]) - ord(words[i][j]) for j in range(n-1)] != diff:\\n                return words[i]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```Python3 []\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        m, n = len(words), len(words[0])\\n        diffs = [[] for _ in range(3)]\\n        for i in range(3):\\n            diffs[i] = [ord(words[i][j+1]) - ord(words[i][j]) for j in range(n-1)]\\n            if diffs[0] == diffs[1]:\\n                diff = diffs[0]\\n                break\\n        if diffs[2]:\\n            return words[1] if diffs[0] == diffs[2] else words[0]\\n\\n        for i in range(2, m):\\n            if [ord(words[i][j+1]) - ord(words[i][j]) for j in range(n-1)] != diff:\\n                return words[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555199,
                "title": "python-easy-solution-without-dictionary-and-stop-early",
                "content": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        n = len(words[0])\\n        def diff_arr(word: str) -> list[int]:\\n            return [ord(word[i]) - ord(word[i - 1]) for i in range(1, n)]\\n        \\n        a, b, c = diff_arr(words[0]), diff_arr(words[1]), diff_arr(words[2])\\n        if not a == b == c:\\n            if a == b:\\n                return words[2]\\n            elif a == c:\\n                return words[1]\\n            else:\\n                return words[0]\\n        \\n        main_diff_arr = a\\n        for word in words[3:]:\\n            if diff_arr(word) != main_diff_arr:\\n                return word\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        n = len(words[0])\\n        def diff_arr(word: str) -> list[int]:\\n            return [ord(word[i]) - ord(word[i - 1]) for i in range(1, n)]\\n        \\n        a, b, c = diff_arr(words[0]), diff_arr(words[1]), diff_arr(words[2])\\n        if not a == b == c:\\n            if a == b:\\n                return words[2]\\n            elif a == c:\\n                return words[1]\\n            else:\\n                return words[0]\\n        \\n        main_diff_arr = a\\n        for word in words[3:]:\\n            if diff_arr(word) != main_diff_arr:\\n                return word\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538054,
                "title": "java-2-approaches-o-1-space-hashmap",
                "content": "# O(1) Space\\n### Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\n\\n    public String oddString(String[] words) {\\n        int matchesFirst = 0;\\n        int mismatchIndex = -1;\\n        for (int i = 1; i < words.length; i++) {\\n            if (isEqualDiff(words[0], words[i])) {\\n                matchesFirst++;\\n            } else {\\n                mismatchIndex = i;\\n            }\\n        }\\n\\n        if (matchesFirst == 0) {\\n            return words[0];\\n        }\\n\\n        return words[mismatchIndex];\\n    }\\n\\n    private static boolean isEqualDiff(String a, String b) {\\n        for (int i = 0; i < a.length() - 1; i++) {\\n            if (a.charAt(i + 1) - a.charAt(i) != b.charAt(i + 1) - b.charAt(i)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n# HashMap\\n### Complexity\\n- Time complexity: $$O(m * n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\n\\n    public String oddString(String[] words) {\\n        Map<List<Integer>, List<Integer>> map = new HashMap<>(2);\\n        for (int i = 0; i < words.length; i++) {\\n            List<Integer> difference = new ArrayList<>(words.length - 1);\\n            for (int j = 0; j < words[i].length() - 1; j++) {\\n                difference.add((words[i].charAt(j + 1) - \\'a\\') - (words[i].charAt(j) - \\'a\\'));\\n            }\\n\\n            List<Integer> indices = map.getOrDefault(difference, new ArrayList<>());\\n            indices.add(i);\\n            map.put(difference, indices);\\n        }\\n\\n        for (List<Integer> indices : map.values()) {\\n            if (indices.size() == 1) {\\n                return words[indices.get(0)];\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n\\n    public String oddString(String[] words) {\\n        int matchesFirst = 0;\\n        int mismatchIndex = -1;\\n        for (int i = 1; i < words.length; i++) {\\n            if (isEqualDiff(words[0], words[i])) {\\n                matchesFirst++;\\n            } else {\\n                mismatchIndex = i;\\n            }\\n        }\\n\\n        if (matchesFirst == 0) {\\n            return words[0];\\n        }\\n\\n        return words[mismatchIndex];\\n    }\\n\\n    private static boolean isEqualDiff(String a, String b) {\\n        for (int i = 0; i < a.length() - 1; i++) {\\n            if (a.charAt(i + 1) - a.charAt(i) != b.charAt(i + 1) - b.charAt(i)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\n\\n    public String oddString(String[] words) {\\n        Map<List<Integer>, List<Integer>> map = new HashMap<>(2);\\n        for (int i = 0; i < words.length; i++) {\\n            List<Integer> difference = new ArrayList<>(words.length - 1);\\n            for (int j = 0; j < words[i].length() - 1; j++) {\\n                difference.add((words[i].charAt(j + 1) - \\'a\\') - (words[i].charAt(j) - \\'a\\'));\\n            }\\n\\n            List<Integer> indices = map.getOrDefault(difference, new ArrayList<>());\\n            indices.add(i);\\n            map.put(difference, indices);\\n        }\\n\\n        for (List<Integer> indices : map.values()) {\\n            if (indices.size() == 1) {\\n                return words[indices.get(0)];\\n            }\\n        }\\n\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535172,
                "title": "c-easy-solution-using-vector-runtime-0-ms-beats-100-memory-7-5-mb-beats-68-89",
                "content": "# Intuition\\n<!--  -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        vector<vector<int>> vVect;\\n        int res = -1;\\n        for(int i = 0; i < words.size(); ++i){\\n            vector<int> vect(words.size()-1);\\n            for(int j = 0; j < words[0].size()-1; ++j){\\n                vect[j] = words[i][j+1] - words[i][j];\\n            }\\n            if(vVect.size() == 0){\\n                vVect.push_back(vect);\\n            }\\n            else{\\n                if(vVect.size() == 2){ \\n                        if(vVect.front() == vect){\\n                            res = i - 1;\\n                            break;\\n                        }\\n                        if(vVect.back() == vect){\\n                            res = 0;\\n                        }\\n                        \\n                }\\n                else{\\n                        if(vVect.back() != vect)\\n                            vVect.push_back(vect);\\n                }\\n            }\\n                \\n            //vect.clear();\\n        }\\n        if(res == -1) res = words.size()-1;\\n        return words[res];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        vector<vector<int>> vVect;\\n        int res = -1;\\n        for(int i = 0; i < words.size(); ++i){\\n            vector<int> vect(words.size()-1);\\n            for(int j = 0; j < words[0].size()-1; ++j){\\n                vect[j] = words[i][j+1] - words[i][j];\\n            }\\n            if(vVect.size() == 0){\\n                vVect.push_back(vect);\\n            }\\n            else{\\n                if(vVect.size() == 2){ \\n                        if(vVect.front() == vect){\\n                            res = i - 1;\\n                            break;\\n                        }\\n                        if(vVect.back() == vect){\\n                            res = 0;\\n                        }\\n                        \\n                }\\n                else{\\n                        if(vVect.back() != vect)\\n                            vVect.push_back(vect);\\n                }\\n            }\\n                \\n            //vect.clear();\\n        }\\n        if(res == -1) res = words.size()-1;\\n        return words[res];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534162,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-99-98-memory",
                "content": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int[][] diff = new int[words.length][words[0].length() - 1];\\n        int index = -1;\\n        String p = \"\";\\n        Map<String, Integer> pp = new HashMap<>();\\n        Map<String, Integer> xx = new HashMap<>();\\n        List<String> ppp = new ArrayList<>();\\n        for(String s : words) {\\n            index++;\\n            for (int i = 0; i < s.length() - 1; i++) {\\n                int v = s.charAt(i + 1) - s.charAt(i);\\n                diff[index][i] = v;\\n                p += String.valueOf(v);\\n            }\\n            if(!ppp.contains(p)) {\\n                ppp.add(p);\\n            }\\n            pp.put(p, pp.merge(p, 1, Integer::sum));\\n            xx.put(p, index);\\n            p = \"\";\\n        }\\n        return words[xx.get(ppp.size() == 1 ? ppp.get(0) : pp.get(ppp.get(0)) < pp.get(ppp.get(1)) ? ppp.get(0) : ppp.get(1))];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Math",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int[][] diff = new int[words.length][words[0].length() - 1];\\n        int index = -1;\\n        String p = \"\";\\n        Map<String, Integer> pp = new HashMap<>();\\n        Map<String, Integer> xx = new HashMap<>();\\n        List<String> ppp = new ArrayList<>();\\n        for(String s : words) {\\n            index++;\\n            for (int i = 0; i < s.length() - 1; i++) {\\n                int v = s.charAt(i + 1) - s.charAt(i);\\n                diff[index][i] = v;\\n                p += String.valueOf(v);\\n            }\\n            if(!ppp.contains(p)) {\\n                ppp.add(p);\\n            }\\n            pp.put(p, pp.merge(p, 1, Integer::sum));\\n            xx.put(p, index);\\n            p = \"\";\\n        }\\n        return words[xx.get(ppp.size() == 1 ? ppp.get(0) : pp.get(ppp.get(0)) < pp.get(ppp.get(1)) ? ppp.get(0) : ppp.get(1))];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526533,
                "title": "c-100-beats-time-96-space-without-hash-table",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere\\'re several approaches and maybe less wordy, but this one is quite optimal\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOn each iteration, we simply create a profile for all the `words[0][j + 1] - words[0][j]`. For this we just preallocate `std::vector` of ints - it would be used for every iteration. Then we\\'re comparing 3 values to find a consensus (because we don\\'t know which array value we should consider as normal). If we get 2 vs 1, then 1 loose (cause there\\'s only 1 \"bad\" string)\\n\\n# Complexity\\n- Time complexity:\\nO(words.size() * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(words.size())\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        vector<int> tmp (words.size(), 0);\\n\\n        for (int j = 0; j < words[0].size() - 1; j++)\\n        {\\n            tmp[0] = words[0][j + 1] - words[0][j];\\n            tmp[1] = words[1][j + 1] - words[1][j];\\n\\n            for (int i = 2; i < words.size(); i++)\\n            {\\n                tmp[i] = words[i][j + 1] - words[i][j];\\n                bool b = (tmp[i] == tmp[i - 1] && tmp[i - 1] == tmp[i - 2]);\\n                if (!b)\\n                {\\n                    if (tmp[i] == tmp[i - 1])\\n                        return words[i - 2];\\n                    else if (tmp[i] == tmp[i - 2])\\n                        return words[i - 1];\\n                    return words[i];\\n                }\\n                    \\n            }\\n        }\\n\\n        return words[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        vector<int> tmp (words.size(), 0);\\n\\n        for (int j = 0; j < words[0].size() - 1; j++)\\n        {\\n            tmp[0] = words[0][j + 1] - words[0][j];\\n            tmp[1] = words[1][j + 1] - words[1][j];\\n\\n            for (int i = 2; i < words.size(); i++)\\n            {\\n                tmp[i] = words[i][j + 1] - words[i][j];\\n                bool b = (tmp[i] == tmp[i - 1] && tmp[i - 1] == tmp[i - 2]);\\n                if (!b)\\n                {\\n                    if (tmp[i] == tmp[i - 1])\\n                        return words[i - 2];\\n                    else if (tmp[i] == tmp[i - 2])\\n                        return words[i - 1];\\n                    return words[i];\\n                }\\n                    \\n            }\\n        }\\n\\n        return words[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523753,
                "title": "straightforward-but-slightly-longer-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n\\n        n = len(words[0])\\n\\n        import string\\n        hashmap={}\\n        a= list(string.ascii_lowercase)\\n        for i in range(len(a)):\\n            hashmap[a[i]] = i\\n\\n        lst=[]\\n        for i in range(len(words)):\\n            temp=[]\\n            for j in range(n-1):\\n                temp.append(hashmap[words[i][j+1]] - hashmap[words[i][j]])\\n            lst.append(temp)\\n\\n        for i in range(len(lst)):\\n            if lst.count(lst[i]) == 1:\\n                return words[i]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n\\n        n = len(words[0])\\n\\n        import string\\n        hashmap={}\\n        a= list(string.ascii_lowercase)\\n        for i in range(len(a)):\\n            hashmap[a[i]] = i\\n\\n        lst=[]\\n        for i in range(len(words)):\\n            temp=[]\\n            for j in range(n-1):\\n                temp.append(hashmap[words[i][j+1]] - hashmap[words[i][j]])\\n            lst.append(temp)\\n\\n        for i in range(len(lst)):\\n            if lst.count(lst[i]) == 1:\\n                return words[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522840,
                "title": "c-solution-beats-100-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        vector<vector<int>> diff;\\n        vector<int> v;\\n        int n=words[0].length();\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++){\\n            str=words[i];\\n            for(int j=0;j<=n-2;j++){\\n                int s=str[j+1]-str[j];\\n                v.push_back(s);\\n            }\\n            diff.push_back(v);\\n            v.clear();\\n        }\\n        for(int i=1;i<words.size()-1;i++){\\n            for(int j=0;j<=n-2;j++){\\n                if(diff[i][j]!=diff[i+1][j] && diff[i][j]!=diff[i-1][j]){\\n                    return words[i];\\n                }\\n            }\\n        }\\n        if(diff[0][0]!=diff[1][0]) return words[0];\\n        return words[words.size()-1];\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        vector<vector<int>> diff;\\n        vector<int> v;\\n        int n=words[0].length();\\n        string str=\"\";\\n        for(int i=0;i<words.size();i++){\\n            str=words[i];\\n            for(int j=0;j<=n-2;j++){\\n                int s=str[j+1]-str[j];\\n                v.push_back(s);\\n            }\\n            diff.push_back(v);\\n            v.clear();\\n        }\\n        for(int i=1;i<words.size()-1;i++){\\n            for(int j=0;j<=n-2;j++){\\n                if(diff[i][j]!=diff[i+1][j] && diff[i][j]!=diff[i-1][j]){\\n                    return words[i];\\n                }\\n            }\\n        }\\n        if(diff[0][0]!=diff[1][0]) return words[0];\\n        return words[words.size()-1];\\n    }\\n};\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506141,
                "title": "dictionary-python-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        d = {}\\n        for w in words:\\n            diff = [ord(w[i+1])-ord(w[i]) for i in range(len(w)-1)]\\n            if tuple(diff) not in d:\\n                d[tuple(diff)] = [w]\\n            else:\\n                d[tuple(diff)] += [w]\\n        for k, v in d.items():\\n            if len(v) == 1:\\n                return v[0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        d = {}\\n        for w in words:\\n            diff = [ord(w[i+1])-ord(w[i]) for i in range(len(w)-1)]\\n            if tuple(diff) not in d:\\n                d[tuple(diff)] = [w]\\n            else:\\n                d[tuple(diff)] += [w]\\n        for k, v in d.items():\\n            if len(v) == 1:\\n                return v[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3495048,
                "title": "java-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int n=words.length, m=words[0].length();\\n        int c1=1, c2=0, a=0;\\n        String diff =\"\";\\n\\n        for(int j=0; j<m-1; j++){\\n            for(int i=1; i<n; i++){\\n                a=words[0].charAt(j+1)-words[0].charAt(j);\\n                int b=words[i].charAt(j+1)-words[i].charAt(j);\\n                if(a==b) c1++;\\n                else {\\n                    diff =words[i];\\n                    c2++;\\n                }\\n\\n                if(c1>=2 && c2==1) return diff;\\n                else if(c1==1 && c2==2) return words[0];\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int n=words.length, m=words[0].length();\\n        int c1=1, c2=0, a=0;\\n        String diff =\"\";\\n\\n        for(int j=0; j<m-1; j++){\\n            for(int i=1; i<n; i++){\\n                a=words[0].charAt(j+1)-words[0].charAt(j);\\n                int b=words[i].charAt(j+1)-words[i].charAt(j);\\n                if(a==b) c1++;\\n                else {\\n                    diff =words[i];\\n                    c2++;\\n                }\\n\\n                if(c1>=2 && c2==1) return diff;\\n                else if(c1==1 && c2==2) return words[0];\\n            }\\n        }\\n        return \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456860,
                "title": "scala-straightforward-solution-beats-100-100",
                "content": "# Code\\n```scala\\nobject Solution {\\n\\n  def oddString(words: Array[String]): String = {\\n    import scala.collection.mutable\\n\\n\\n    def toDiffArray(w: String): String = {\\n      val result = new mutable.ListBuffer[Int]\\n      for (i <- 1 until w.length) {\\n        result.append(w(i) - w(i - 1))\\n      }\\n      result.mkString(\",\")\\n    }\\n\\n    words\\n      .map(w => w -> toDiffArray(w))\\n      .groupBy { case (_, diffs) => {\\n        println(diffs)\\n        diffs\\n      }\\n      }\\n      .find { case (_, diffs) => diffs.length == 1 }\\n      .map { case (_, diffs) => diffs.head }\\n      .map { case (w, _) => w }\\n      .get\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Array",
                    "String",
                    "Counting"
                ],
                "code": "```scala\\nobject Solution {\\n\\n  def oddString(words: Array[String]): String = {\\n    import scala.collection.mutable\\n\\n\\n    def toDiffArray(w: String): String = {\\n      val result = new mutable.ListBuffer[Int]\\n      for (i <- 1 until w.length) {\\n        result.append(w(i) - w(i - 1))\\n      }\\n      result.mkString(\",\")\\n    }\\n\\n    words\\n      .map(w => w -> toDiffArray(w))\\n      .groupBy { case (_, diffs) => {\\n        println(diffs)\\n        diffs\\n      }\\n      }\\n      .find { case (_, diffs) => diffs.length == 1 }\\n      .map { case (_, diffs) => diffs.head }\\n      .map { case (w, _) => w }\\n      .get\\n  }\\n\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3447916,
                "title": "python-easy-understandable-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        alpha=[\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        x=[]\\n        y={}\\n        for i in range(len(words)):\\n            x=[]\\n            for j in range(len(words[i])-1):\\n               a=alpha.index(words[i][j])\\n               b=alpha.index(words[i][j+1])\\n               x.append(b-a)\\n            y[words[i]]=x\\n        c=list(y.values())\\n        for i in range(len(c)):\\n           if c.count(c[i])==1:\\n               d=c[i]\\n        for i in y:\\n          if y[i]==d:\\n             return i\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        alpha=[\\'a\\',\\'b\\',\\'c\\',\\'d\\',\\'e\\',\\'f\\',\\'g\\',\\'h\\',\\'i\\',\\'j\\',\\'k\\',\\'l\\',\\'m\\',\\'n\\',\\'o\\',\\'p\\',\\'q\\',\\'r\\',\\'s\\',\\'t\\',\\'u\\',\\'v\\',\\'w\\',\\'x\\',\\'y\\',\\'z\\']\\n        x=[]\\n        y={}\\n        for i in range(len(words)):\\n            x=[]\\n            for j in range(len(words[i])-1):\\n               a=alpha.index(words[i][j])\\n               b=alpha.index(words[i][j+1])\\n               x.append(b-a)\\n            y[words[i]]=x\\n        c=list(y.values())\\n        for i in range(len(c)):\\n           if c.count(c[i])==1:\\n               d=c[i]\\n        for i in y:\\n          if y[i]==d:\\n             return i\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441009,
                "title": "python3-easy-for-understanding-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport string\\n\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        abc, idx, result = string.ascii_lowercase, range(26), []\\n        abc_dict = dict(zip(abc,idx))\\n        for word in words:\\n            diff = []\\n            for x in range(len(word) -1 , 0, -1):\\n                diff.insert(0, abc_dict.get(word[x]) - abc_dict.get(word[x - 1]))\\n            result.append(diff)\\n\\n        return [ words[x] for x in range(len(result)) if result.count(result[x]) == 1 ][0]\\n            \\n        \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport string\\n\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        abc, idx, result = string.ascii_lowercase, range(26), []\\n        abc_dict = dict(zip(abc,idx))\\n        for word in words:\\n            diff = []\\n            for x in range(len(word) -1 , 0, -1):\\n                diff.insert(0, abc_dict.get(word[x]) - abc_dict.get(word[x - 1]))\\n            result.append(diff)\\n\\n        return [ words[x] for x in range(len(result)) if result.count(result[x]) == 1 ][0]\\n            \\n        \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427891,
                "title": "seems-no-one-using-this-sorting-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int n = words.size(), m = words[0].length();\\n        sort(words.begin(), words.end(), [&](string& a, string& b){\\n            for (int j = 1; j < m; j++) {\\n                if (a[j] - a[j-1] < b[j] - b[j-1]) {\\n                    return true;\\n                }\\n                if (a[j] - a[j-1] > b[j] - b[j-1]) {\\n                    return false;\\n                }\\n            }\\n            return false;\\n        });\\n        for (int j = 1; j < m; j++) {\\n            if (words[0][j] - words[0][j-1] != words[1][j] - words[1][j-1]) {\\n                return words[0];\\n            }\\n        }\\n        return words.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        int n = words.size(), m = words[0].length();\\n        sort(words.begin(), words.end(), [&](string& a, string& b){\\n            for (int j = 1; j < m; j++) {\\n                if (a[j] - a[j-1] < b[j] - b[j-1]) {\\n                    return true;\\n                }\\n                if (a[j] - a[j-1] > b[j] - b[j-1]) {\\n                    return false;\\n                }\\n            }\\n            return false;\\n        });\\n        for (int j = 1; j < m; j++) {\\n            if (words[0][j] - words[0][j-1] != words[1][j] - words[1][j-1]) {\\n                return words[0];\\n            }\\n        }\\n        return words.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424528,
                "title": "python-solution-using-hash-table",
                "content": "# Intuition\\nSince list is not hashable, we can convert list into a string seprateed by some char(in this case its \":\")\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: ```O(n)```\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ```O(n)```\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def oddString(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        ht = defaultdict(list)\\n        for i in range(len(words)):\\n            diff_arr = []\\n            for j in range(1, len(words[i])):\\n                curr = ord(words[i][j]) - ord(\\'a\\')\\n                prev = ord(words[i][j-1]) - ord(\\'a\\')\\n                diff_arr.append(str(curr - prev))\\n\\n            ht[\\':\\'.join(diff_arr)].append(words[i])\\n\\n        for val in ht.values():\\n            if len(val) == 1:\\n                return val[0]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```O(n)```\n```O(n)```\n```\\nclass Solution(object):\\n    def oddString(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n        ht = defaultdict(list)\\n        for i in range(len(words)):\\n            diff_arr = []\\n            for j in range(1, len(words[i])):\\n                curr = ord(words[i][j]) - ord(\\'a\\')\\n                prev = ord(words[i][j-1]) - ord(\\'a\\')\\n                diff_arr.append(str(curr - prev))\\n\\n            ht[\\':\\'.join(diff_arr)].append(words[i])\\n\\n        for val in ht.values():\\n            if len(val) == 1:\\n                return val[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423637,
                "title": "c-solution",
                "content": "```\\nstring oddString(vector<string>& words) {\\n\\tmap<vector<int>, int> mp;\\n\\tfor (auto& w : words) {\\n\\t\\tvector<int> v(w.size() - 1);\\n\\t\\tfor (int j = 0; j < w.size() - 1; j++)\\n\\t\\t\\tv[j] = w[j + 1] - w[j];\\n\\t\\tmp[v]++;\\n\\t}\\n\\tfor (auto& w : words) {\\n\\t\\tvector<int> v(w.size() - 1);\\n\\t\\tfor (int j = 0; j < w.size() - 1; j++)\\n\\t\\t\\tv[j] = w[j + 1] - w[j];\\n\\t\\tif (mp[v] == 1)\\n\\t\\t\\treturn w;\\n\\t}\\n\\treturn \"\";\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring oddString(vector<string>& words) {\\n\\tmap<vector<int>, int> mp;\\n\\tfor (auto& w : words) {\\n\\t\\tvector<int> v(w.size() - 1);\\n\\t\\tfor (int j = 0; j < w.size() - 1; j++)\\n\\t\\t\\tv[j] = w[j + 1] - w[j];\\n\\t\\tmp[v]++;\\n\\t}\\n\\tfor (auto& w : words) {\\n\\t\\tvector<int> v(w.size() - 1);\\n\\t\\tfor (int j = 0; j < w.size() - 1; j++)\\n\\t\\t\\tv[j] = w[j + 1] - w[j];\\n\\t\\tif (mp[v] == 1)\\n\\t\\t\\treturn w;\\n\\t}\\n\\treturn \"\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3416677,
                "title": "python-almost-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        the_words_list = []\\n        for word in words:\\n            list_word = []\\n            for idx in range(len(word)-1):\\n                list_word.append(ord(word[idx+1])-ord(word[idx]))\\n            the_words_list.append(list_word)\\n        \\n        for idx in range(len(the_words_list)):\\n            if(the_words_list.count(the_words_list[idx])==1):\\n                return words[idx]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        the_words_list = []\\n        for word in words:\\n            list_word = []\\n            for idx in range(len(word)-1):\\n                list_word.append(ord(word[idx+1])-ord(word[idx]))\\n            the_words_list.append(list_word)\\n        \\n        for idx in range(len(the_words_list)):\\n            if(the_words_list.count(the_words_list[idx])==1):\\n                return words[idx]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414133,
                "title": "100-faster-no-hashmap",
                "content": "# Complexity\\n- Time complexity: $$O(n * m)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int[] arr = new int[words[0].length()];\\n        boolean flag1 = true, flag2 = true;\\n        for(int i = 1; i < arr.length; i++) {\\n            arr[i] = words[0].charAt(i) - words[0].charAt(i - 1);\\n            if(flag1 && words[1].charAt(i) - words[1].charAt(i - 1) != arr[i]) flag1 = false;\\n            if(flag2 && words[2].charAt(i) - words[2].charAt(i - 1) != arr[i]) flag2 = false;\\n        }\\n        if(!flag1 && !flag2) return words[0];\\n        else if(!flag1) return words[1];\\n        else if(!flag2) return words[2];\\n        else {\\n            for(int i = 3; i < words.length; i++) {\\n                for(int j = 1; j < arr.length; j++) if(words[i].charAt(j) - words[i].charAt(j - 1) != arr[j]) return words[i];\\n            }\\n        }\\n        return \"\"; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int[] arr = new int[words[0].length()];\\n        boolean flag1 = true, flag2 = true;\\n        for(int i = 1; i < arr.length; i++) {\\n            arr[i] = words[0].charAt(i) - words[0].charAt(i - 1);\\n            if(flag1 && words[1].charAt(i) - words[1].charAt(i - 1) != arr[i]) flag1 = false;\\n            if(flag2 && words[2].charAt(i) - words[2].charAt(i - 1) != arr[i]) flag2 = false;\\n        }\\n        if(!flag1 && !flag2) return words[0];\\n        else if(!flag1) return words[1];\\n        else if(!flag2) return words[2];\\n        else {\\n            for(int i = 3; i < words.length; i++) {\\n                for(int j = 1; j < arr.length; j++) if(words[i].charAt(j) - words[i].charAt(j - 1) != arr[j]) return words[i];\\n            }\\n        }\\n        return \"\"; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3406251,
                "title": "c-one-pass-o-1-space",
                "content": "Some observations are in order:\\n1. If we create a table of differences, and check some column and in that particular column there is one odd number, then the row (word) related to that number is odd. That is to say, single number difference is enough to make a judgement that such a word is different from the rest. \\n2. There are only 3 options for such difference: \\na. The first word is different from the rest\\nb. The second word is different from the rest\\nc. Some other word beyond the first two is odd.\\n\\nHere, the solution uses the two observations above to do a One Pass through the matrix elements (differences). \\n\\nThe first check is to see if either of the first two words are odd. It is rather easy to see that if the first two words have different number in their sequence, then one of them must be odd. All we need to do in such a case is to compare one of them to the 3rd word and see if they match.\\n\\nOtherwise, if the first two words number are the same, then maybe we can find an odd word at some other index beyond the first two. In this case all we need to do is compare the rest of the differences with our first same two. If we stumble upon some different number, that must be our odd.\\n\\nO(NM) time, O(1) space:\\n```\\nstring oddString(vector<string>& w) {\\n    int n = w.size(), m = w[0].size();\\n    for (int j = 0; j < m - 1; j++) { // cols\\n        int diff0 = w[0][j + 1] - w[0][j];\\n        int diff1 = w[1][j + 1] - w[1][j];\\n        if (diff0 != diff1) { // found\\n            if (diff0 == w[2][j + 1] - w[2][j])\\n                return w[1];\\n            return w[0];\\n        }\\n        // else diff0 == diff1 \\n        for (int i = 2; i < n; i++) // rows, words\\n            if (diff0 != w[i][j + 1] - w[i][j])\\n                return w[i];\\n    }\\n    return \"\";\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstring oddString(vector<string>& w) {\\n    int n = w.size(), m = w[0].size();\\n    for (int j = 0; j < m - 1; j++) { // cols\\n        int diff0 = w[0][j + 1] - w[0][j];\\n        int diff1 = w[1][j + 1] - w[1][j];\\n        if (diff0 != diff1) { // found\\n            if (diff0 == w[2][j + 1] - w[2][j])\\n                return w[1];\\n            return w[0];\\n        }\\n        // else diff0 == diff1 \\n        for (int i = 2; i < n; i++) // rows, words\\n            if (diff0 != w[i][j + 1] - w[i][j])\\n                return w[i];\\n    }\\n    return \"\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3389404,
                "title": "odd-string-difference",
                "content": "------------- Easy C++ Solution --------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        for (int i = 0; i < size(words[0]) - 1; ++i) {\\n            unordered_map<int, vector<int>> lookup;\\n            for (int j = 0; j < size(words); ++j) {\\n                if (size(lookup[words[j][i + 1] - words[j][i]]) < 2) {\\n                    lookup[words[j][i + 1] - words[j][i]].emplace_back(j);\\n                }\\n            }\\n            if (size(lookup) == 2) {\\n                return size(cbegin(lookup)->second) == 1\\n                       ? words[cbegin(lookup)->second[0]]\\n                       : words[next(cbegin(lookup))->second[0]];\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        for (int i = 0; i < size(words[0]) - 1; ++i) {\\n            unordered_map<int, vector<int>> lookup;\\n            for (int j = 0; j < size(words); ++j) {\\n                if (size(lookup[words[j][i + 1] - words[j][i]]) < 2) {\\n                    lookup[words[j][i + 1] - words[j][i]].emplace_back(j);\\n                }\\n            }\\n            if (size(lookup) == 2) {\\n                return size(cbegin(lookup)->second) == 1\\n                       ? words[cbegin(lookup)->second[0]]\\n                       : words[next(cbegin(lookup))->second[0]];\\n            }\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376786,
                "title": "java-solution-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        HashMap<String,ArrayList<Integer>> hm1=new HashMap<>();\\n        HashMap<ArrayList<Integer>,Integer> hm2=new HashMap<>();\\n       for(String word : words)\\n       {\\n           ArrayList<Integer> arr=new ArrayList<>();\\n           for(int i=1;i<word.length();i++)\\n           {\\n               arr.add(word.charAt(i)-word.charAt(i-1));\\n           }\\n           hm1.put(word,arr);\\n            if(hm2.containsKey(arr))\\n            {\\n                hm2.put(arr,hm2.get(arr)+1);\\n            }\\n            else\\n            {\\n                hm2.put(arr,1);\\n            }\\n       }\\n       for(ArrayList<Integer> arr: hm2.keySet())\\n       {\\n           if(hm2.get(arr)==1)\\n           {\\n               for(String str : hm1.keySet())\\n               {\\n                   if(hm1.get(str)==arr)return str;\\n               }\\n           }\\n       }\\n       return  \"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        HashMap<String,ArrayList<Integer>> hm1=new HashMap<>();\\n        HashMap<ArrayList<Integer>,Integer> hm2=new HashMap<>();\\n       for(String word : words)\\n       {\\n           ArrayList<Integer> arr=new ArrayList<>();\\n           for(int i=1;i<word.length();i++)\\n           {\\n               arr.add(word.charAt(i)-word.charAt(i-1));\\n           }\\n           hm1.put(word,arr);\\n            if(hm2.containsKey(arr))\\n            {\\n                hm2.put(arr,hm2.get(arr)+1);\\n            }\\n            else\\n            {\\n                hm2.put(arr,1);\\n            }\\n       }\\n       for(ArrayList<Integer> arr: hm2.keySet())\\n       {\\n           if(hm2.get(arr)==1)\\n           {\\n               for(String str : hm1.keySet())\\n               {\\n                   if(hm1.get(str)==arr)return str;\\n               }\\n           }\\n       }\\n       return  \"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375287,
                "title": "python-solution",
                "content": "\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        \\n        counter = defaultdict(lambda:0)\\n        pos = defaultdict(lambda:[])\\n        for ind,w in enumerate(words):\\n            tmp = []\\n            for i in range(1,len(w)):\\n                tmp.append(ord(w[i])-ord(w[i-1]))\\n            tmp = tuple(tmp)\\n            counter[tmp]+=1\\n            pos[tmp].append(ind)\\n\\n        for k in counter.keys():\\n            if counter[k] == 1 : \\n                return words[pos[k][0]]\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        \\n        counter = defaultdict(lambda:0)\\n        pos = defaultdict(lambda:[])\\n        for ind,w in enumerate(words):\\n            tmp = []\\n            for i in range(1,len(w)):\\n                tmp.append(ord(w[i])-ord(w[i-1]))\\n            tmp = tuple(tmp)\\n            counter[tmp]+=1\\n            pos[tmp].append(ind)\\n\\n        for k in counter.keys():\\n            if counter[k] == 1 : \\n                return words[pos[k][0]]\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3371413,
                "title": "python-with-explanation-runtime-15-ms-beats-92-73",
                "content": "![Screenshot 2023-04-02 9.52.36 PM.png](https://assets.leetcode.com/users/images/cc643fb3-ee2b-4aca-b6fa-ed8fa1cfff10_1680452591.290245.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def oddString(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n\\n        # My Code.\\n\\n        # List to append the difference integers per string.\\n        a = []\\n\\n        # Iterating into words list.\\n        for word in words:\\n\\n            # Appending converted string char into ASCII int into list.\\n            b = [ord(i) for i in word]\\n\\n            # List to append differences of current string.\\n            c = []\\n\\n            # Iterating into string till it\\'s length - 1.\\n            for i in range(len(b) - 1):\\n\\n                # Doing the calculation as written in the question.\\n                c.append(b[i + 1] - b[i])\\n\\n            # Appending c list into a.\\n            a.append(c)\\n\\n\\n        # Iterating into list a.\\n        for i in a:\\n\\n            # If the count of ith value is only 1.\\n            if a.count(i) == 1:\\n\\n                # Getting it\\'s index in list a.\\n                # Using that index to get respective string from words.\\n                # Returning that word.\\n                return words[a.index(i)]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "![Screenshot 2023-04-02 9.52.36 PM.png](https://assets.leetcode.com/users/images/cc643fb3-ee2b-4aca-b6fa-ed8fa1cfff10_1680452591.290245.png)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def oddString(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: str\\n        \"\"\"\\n\\n        # My Code.\\n\\n        # List to append the difference integers per string.\\n        a = []\\n\\n        # Iterating into words list.\\n        for word in words:\\n\\n            # Appending converted string char into ASCII int into list.\\n            b = [ord(i) for i in word]\\n\\n            # List to append differences of current string.\\n            c = []\\n\\n            # Iterating into string till it\\'s length - 1.\\n            for i in range(len(b) - 1):\\n\\n                # Doing the calculation as written in the question.\\n                c.append(b[i + 1] - b[i])\\n\\n            # Appending c list into a.\\n            a.append(c)\\n\\n\\n        # Iterating into list a.\\n        for i in a:\\n\\n            # If the count of ith value is only 1.\\n            if a.count(i) == 1:\\n\\n                # Getting it\\'s index in list a.\\n                # Using that index to get respective string from words.\\n                # Returning that word.\\n                return words[a.index(i)]\\n",
                "codeTag": "Java"
            },
            {
                "id": 3352501,
                "title": "c-intuition-map-brute-force",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<vector<int>, vector<string>> map;\\n        int n = words.size();\\n        string res;\\n\\n        for (int i = 0; i < n; i++) {\\n            vector<int> temp;\\n            for (int j = 0; j < words[i].size() - 1; j++) {\\n                temp.push_back(words[i][j + 1] - words[i][j]);\\n            }\\n            map[temp].push_back(words[i]);\\n        }\\n\\n        for (auto& m : map) {\\n            if (m.second.size() == 1) {\\n                res = m.second[0];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<vector<int>, vector<string>> map;\\n        int n = words.size();\\n        string res;\\n\\n        for (int i = 0; i < n; i++) {\\n            vector<int> temp;\\n            for (int j = 0; j < words[i].size() - 1; j++) {\\n                temp.push_back(words[i][j + 1] - words[i][j]);\\n            }\\n            map[temp].push_back(words[i]);\\n        }\\n\\n        for (auto& m : map) {\\n            if (m.second.size() == 1) {\\n                res = m.second[0];\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347177,
                "title": "go-golang-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the words and set String as a key of the HashMap.\\n\\n# Approach\\nHashMap\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n ^ 2 + n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nfunc oddString(words []string) string {\\n    groups := make(map[string][]string)\\n    for _, word := range words {\\n        letters, key := []byte(word), \"\"\\n        for i := 1; i < len(letters); i++ {\\n            if key != \"\" {\\n                key += \",\"\\n            }\\n            key += fmt.Sprint(letters[i] - letters[i - 1])\\n        }\\n        groups[key] = append(groups[key], word)\\n    }\\n\\n    for _, _words := range groups {\\n        if len(_words) == 1 {\\n            return _words[0]\\n        }\\n    }\\n\\n    return words[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc oddString(words []string) string {\\n    groups := make(map[string][]string)\\n    for _, word := range words {\\n        letters, key := []byte(word), \"\"\\n        for i := 1; i < len(letters); i++ {\\n            if key != \"\" {\\n                key += \",\"\\n            }\\n            key += fmt.Sprint(letters[i] - letters[i - 1])\\n        }\\n        groups[key] = append(groups[key], word)\\n    }\\n\\n    for _, _words := range groups {\\n        if len(_words) == 1 {\\n            return _words[0]\\n        }\\n    }\\n\\n    return words[0]\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3345866,
                "title": "using-dictionary",
                "content": "# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        count = {}   # store the count of the occurences of the differences\\n        idx = {}     # map the difference tuple to the word\\n        flag = False # flag to see if difference is occuring the second time\\n\\n        for word in words:\\n            s = []  # get differences\\n            for i in range(len(word)-1):\\n                s.append(ord(word[i+1])-ord(word[i]))\\n\\n            s = tuple(s)\\n            \\n            # Update the dict count\\n            if s not in count:\\n                count[s]=1\\n                idx[s]=word\\n            elif s in count:\\n                count[s]+=1\\n                flag=True # flag is needed so that we can break early as soon as we see the odd one out.\\n\\n            # if 2 different differences are seen, and one of them has a count of more than 2.\\n            if len(count)==2 and flag:\\n                # get the tuple which is seen only once\\n                a = [x for x in count if count[x]==1][0]\\n                # using the tuple, get the word\\n                return idx[a]\\n\\n        return \\'\\'\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        count = {}   # store the count of the occurences of the differences\\n        idx = {}     # map the difference tuple to the word\\n        flag = False # flag to see if difference is occuring the second time\\n\\n        for word in words:\\n            s = []  # get differences\\n            for i in range(len(word)-1):\\n                s.append(ord(word[i+1])-ord(word[i]))\\n\\n            s = tuple(s)\\n            \\n            # Update the dict count\\n            if s not in count:\\n                count[s]=1\\n                idx[s]=word\\n            elif s in count:\\n                count[s]+=1\\n                flag=True # flag is needed so that we can break early as soon as we see the odd one out.\\n\\n            # if 2 different differences are seen, and one of them has a count of more than 2.\\n            if len(count)==2 and flag:\\n                # get the tuple which is seen only once\\n                a = [x for x in count if count[x]==1][0]\\n                # using the tuple, get the word\\n                return idx[a]\\n\\n        return \\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320580,
                "title": "golang-for-fun-100-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc oddString(words []string) string {\\n\\tstr := words[0]\\n\\tn := len(str)\\n\\tdiff := make([]uint8, n-1)\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tdiff[i-1] = str[i] - str[i-1]\\n\\t}\\n\\tif !fun(words[1], diff) {\\n\\t\\tif fun(words[2], diff) {\\n\\t\\t\\treturn words[1]\\n\\t\\t}\\n\\t\\treturn words[0]\\n\\t}\\n\\tfor i := len(words) - 1; i > 1; i-- {\\n\\t\\tif !fun(words[i], diff) {\\n\\t\\t\\treturn words[i]\\n\\t\\t}\\n\\t}\\n\\treturn \"\"\\n}\\n\\nfunc fun(s string, diff []uint8) bool {\\n\\tfor i := len(s) - 1; i > 0; i-- {\\n\\t\\tif diff[i-1] != s[i]-s[i-1] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc oddString(words []string) string {\\n\\tstr := words[0]\\n\\tn := len(str)\\n\\tdiff := make([]uint8, n-1)\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tdiff[i-1] = str[i] - str[i-1]\\n\\t}\\n\\tif !fun(words[1], diff) {\\n\\t\\tif fun(words[2], diff) {\\n\\t\\t\\treturn words[1]\\n\\t\\t}\\n\\t\\treturn words[0]\\n\\t}\\n\\tfor i := len(words) - 1; i > 1; i-- {\\n\\t\\tif !fun(words[i], diff) {\\n\\t\\t\\treturn words[i]\\n\\t\\t}\\n\\t}\\n\\treturn \"\"\\n}\\n\\nfunc fun(s string, diff []uint8) bool {\\n\\tfor i := len(s) - 1; i > 0; i-- {\\n\\t\\tif diff[i-1] != s[i]-s[i-1] {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\t}\\n\\treturn true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3302120,
                "title": "c-100-no-extra-memory-map-vector",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    // compare difference 2 strings\\n    bool comp(const string& s1, const string& s2) {\\n        for (int i = 1; i < s1.size(); ++i) {\\n            if (s1[i] - s1[i - 1] != s2[i] - s2[i - 1])\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    string oddString(vector<string>& words) {\\n        // compare first 2 words\\n        if (!comp(words[0], words[1]))\\n            // if they are not equal, one is the odd string\\n            // checks with the third string to check\\n            return comp(words[0], words[2]) ? words[1] : words[0];\\n\\n        // if both words are equal, thats the pattern\\n        // check the other words\\n        for (int i = 2; i < words.size(); ++i) {\\n            if (!comp(words[0], words[i]))\\n                return words[i];\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // compare difference 2 strings\\n    bool comp(const string& s1, const string& s2) {\\n        for (int i = 1; i < s1.size(); ++i) {\\n            if (s1[i] - s1[i - 1] != s2[i] - s2[i - 1])\\n                return false;\\n        }\\n        return true;\\n    }\\n\\n    string oddString(vector<string>& words) {\\n        // compare first 2 words\\n        if (!comp(words[0], words[1]))\\n            // if they are not equal, one is the odd string\\n            // checks with the third string to check\\n            return comp(words[0], words[2]) ? words[1] : words[0];\\n\\n        // if both words are equal, thats the pattern\\n        // check the other words\\n        for (int i = 2; i < words.size(); ++i) {\\n            if (!comp(words[0], words[i]))\\n                return words[i];\\n        }\\n        return \"\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3300242,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        res = list()\\n        for i in words:\\n            item = list()\\n            for k in range(len(i)-1):\\n                number = (ord(i[k+1]) - ord(i[k]))    \\n                item.append(number)\\n            res.append(item)\\n            if len(res) > 2:\\n                for j in res:\\n                    if res.count(j) == 1:\\n                        return words[res.index(j)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def oddString(self, words: List[str]) -> str:\\n        res = list()\\n        for i in words:\\n            item = list()\\n            for k in range(len(i)-1):\\n                number = (ord(i[k+1]) - ord(i[k]))    \\n                item.append(number)\\n            res.append(item)\\n            if len(res) > 2:\\n                for j in res:\\n                    if res.count(j) == 1:\\n                        return words[res.index(j)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281901,
                "title": "c-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<vector<int>, vector<int>> mp;\\n        for(int i = 0; i < words.size(); i++){\\n            vector<int> diff;\\n            for(int j = 0; j < words[i].size()-1; j++){\\n                diff.push_back(words[i][j+1] - words[i][j]);\\n            }\\n            mp[diff].push_back(i);\\n        }\\n        for(auto it = mp.begin(); it != mp.end(); ++it){\\n            if(it->second.size() == 1) return words[it->second[0]];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string oddString(vector<string>& words) {\\n        map<vector<int>, vector<int>> mp;\\n        for(int i = 0; i < words.size(); i++){\\n            vector<int> diff;\\n            for(int j = 0; j < words[i].size()-1; j++){\\n                diff.push_back(words[i][j+1] - words[i][j]);\\n            }\\n            mp[diff].push_back(i);\\n        }\\n        for(auto it = mp.begin(); it != mp.end(); ++it){\\n            if(it->second.size() == 1) return words[it->second[0]];\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275902,
                "title": "python3",
                "content": "# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n  def oddString(self, words: List[str]) -> str:\\n    alphabet = dict(zip(string.ascii_lowercase, range(0,26)))\\n    diffs = defaultdict(int)\\n    indexes = defaultdict(list)\\n    for i,w in enumerate(words):\\n      diff = []\\n      for j in range(len(w)-1):\\n        diff.append(alphabet[w[j+1]]-alphabet[w[j]])\\n      diff = \\'.\\'.join(map(str, diff))\\n      diffs[diff] +=1\\n      indexes[diff].append(i)\\n    r = list(filter(lambda x: len(x)==1, indexes.values()))[0]\\n    return words[r[0]]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n  def oddString(self, words: List[str]) -> str:\\n    alphabet = dict(zip(string.ascii_lowercase, range(0,26)))\\n    diffs = defaultdict(int)\\n    indexes = defaultdict(list)\\n    for i,w in enumerate(words):\\n      diff = []\\n      for j in range(len(w)-1):\\n        diff.append(alphabet[w[j+1]]-alphabet[w[j]])\\n      diff = \\'.\\'.join(map(str, diff))\\n      diffs[diff] +=1\\n      indexes[diff].append(i)\\n    r = list(filter(lambda x: len(x)==1, indexes.values()))[0]\\n    return words[r[0]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3265478,
                "title": "beats-85-20-runtime-and-92-84-memory-east-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe main idea is to understand during the enumeration whether the found array is unique. We create a main array that will hold the difference of 1 word from the words array. We create a counter and iterate over the words array. If the new found difference != to our main array and the counter != 0 we found the word we are looking for, otherwise if the main array is equal to the current one, we increase the counter. If the counter is 0, we return the 0 element of the words array, if the counter != 0, then we return the 1 element words, since if words[1] is the search word, it will not be taken into account during the iteration due to the conditions in lines 13 and 16.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int count = 0;\\n        Integer[] main = new Integer[words[0].length()-1];\\n        for(int i = 1; i < words[0].length();i++){\\n            main[i-1] = (words[0].charAt(i)-\\'a\\') - (words[0].charAt(i-1)-\\'a\\');\\n        }\\n        for(String str : words){\\n            Integer[] res = new Integer[str.length()-1];\\n            for(int i = 1; i < str.length();i++){\\n                res[i-1] = (str.charAt(i)-\\'a\\') - (str.charAt(i-1)-\\'a\\');\\n            }\\n            if(!Arrays.equals(main,res) && count != 0){\\n                return str;\\n            }\\n            else if(Arrays.equals(main,res) && str != words[0]){\\n                count++;\\n            }\\n\\n        }\\n        return count == 0 ? words[0] : words[1];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        int count = 0;\\n        Integer[] main = new Integer[words[0].length()-1];\\n        for(int i = 1; i < words[0].length();i++){\\n            main[i-1] = (words[0].charAt(i)-\\'a\\') - (words[0].charAt(i-1)-\\'a\\');\\n        }\\n        for(String str : words){\\n            Integer[] res = new Integer[str.length()-1];\\n            for(int i = 1; i < str.length();i++){\\n                res[i-1] = (str.charAt(i)-\\'a\\') - (str.charAt(i-1)-\\'a\\');\\n            }\\n            if(!Arrays.equals(main,res) && count != 0){\\n                return str;\\n            }\\n            else if(Arrays.equals(main,res) && str != words[0]){\\n                count++;\\n            }\\n\\n        }\\n        return count == 0 ? words[0] : words[1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259021,
                "title": "java-set-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        String first =\"\";\\n        String fs=\"\";\\n        int f_count=0;\\n        String second =\"\";\\n        String sc=\"\";\\n        int s_count =0;\\n        Set<String> s = new HashSet<>();\\n\\n        for(String st: words){\\n            char[] cc = st.toCharArray();\\n            String newS = \"\";\\n            for(int i =1; i < st.length(); i++){\\n                newS = newS + \"-\" + (cc[i] -cc[i-1]);\\n            }\\n\\n           // System.out.println(\"first=\" + first + \" second=\" + second + \"new=\" + newS);\\n            if(s.contains(newS)){\\n                if(newS.equals(first)){\\n                    f_count++;\\n                }else if(newS.equals(second)){\\n                    s_count++;\\n                }\\n            }else{\\n                s.add(newS);\\n                if(first == \"\"){\\n                    first = newS;\\n                    fs = st;\\n                    f_count++;\\n                }else if(second == \"\"){\\n                    second = newS;\\n                    sc =st;\\n                    s_count++;\\n                }\\n            }\\n\\n        }\\n\\n        if(f_count ==1){\\n             return fs;\\n        }else{\\n            return sc;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String oddString(String[] words) {\\n        String first =\"\";\\n        String fs=\"\";\\n        int f_count=0;\\n        String second =\"\";\\n        String sc=\"\";\\n        int s_count =0;\\n        Set<String> s = new HashSet<>();\\n\\n        for(String st: words){\\n            char[] cc = st.toCharArray();\\n            String newS = \"\";\\n            for(int i =1; i < st.length(); i++){\\n                newS = newS + \"-\" + (cc[i] -cc[i-1]);\\n            }\\n\\n           // System.out.println(\"first=\" + first + \" second=\" + second + \"new=\" + newS);\\n            if(s.contains(newS)){\\n                if(newS.equals(first)){\\n                    f_count++;\\n                }else if(newS.equals(second)){\\n                    s_count++;\\n                }\\n            }else{\\n                s.add(newS);\\n                if(first == \"\"){\\n                    first = newS;\\n                    fs = st;\\n                    f_count++;\\n                }else if(second == \"\"){\\n                    second = newS;\\n                    sc =st;\\n                    s_count++;\\n                }\\n            }\\n\\n        }\\n\\n        if(f_count ==1){\\n             return fs;\\n        }else{\\n            return sc;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1669447,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1830203,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1851839,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1688999,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 2051586,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 2051574,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1878296,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1741320,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1740544,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1663355,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1669447,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1830203,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1851839,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1688999,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 2051586,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 2051574,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1878296,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1741320,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1740544,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            },
            {
                "id": 1663355,
                "content": [
                    {
                        "username": "Sinan6942069",
                        "content": "Bro \\uD83D\\uDC80"
                    },
                    {
                        "username": "Suffolk",
                        "content": "Not understand description."
                    },
                    {
                        "username": "bparanj",
                        "content": "1. You are given an array of strings called \"words\". Each string in this array has the same length, let\\'s call it \"n\". \\n\\n2. You can create an \"integer difference array\" from each string in the following way: For each pair of adjacent letters in the string, calculate the difference between their alphabetical positions and store it in the array. For example, for the string \"abc\", the difference array is [1, 1] because \\'b\\' is one position after \\'a\\', and \\'c\\' is one position after \\'b\\'. Note that we are considering the position of \\'a\\' as 0, \\'b\\' as 1, and so on until \\'z\\' as 25.\\n\\n3. All strings in the input array have the same difference array, except one string. This one string\\'s difference array doesn\\'t match with others. Your task is to find and return this \"odd\" string.\\n\\nFor example, consider the input [\"adc\",\"wzy\",\"abc\"]. The difference arrays for the three words are:\\n\\n- \"adc\" --> [3, -1] because \\'d\\' is 3 positions after \\'a\\', and \\'c\\' is 1 position before \\'d\\'.\\n- \"wzy\" --> [3, -1] because \\'z\\' is 3 positions after \\'w\\', and \\'y\\' is 1 position before \\'z\\'.\\n- \"abc\" --> [1, 1] because \\'b\\' is 1 position after \\'a\\', and \\'c\\' is 1 position after \\'b\\'.\\n\\nHere, \"abc\" is the \"odd\" string because its difference array [1, 1] is different from the others, which are [3, -1]. So, the function should return \"abc\"."
                    },
                    {
                        "username": "saahilparmar",
                        "content": "Here is the simplistic explanation of this question.\\n\\nFor the given list, take the first string. Now make a list whose length is len(string) - 1. So, if string is of length 3 than list will be of length 2, & so on. The problem suggests that all the strings are of same length, hence we only have to do that simple calculation once.\\n\\nNow comes the difference array or list, whatever you want to call it. I will explain that with an example.\\nLet\\'s say for string \\'abc\\', we create a list of length 2.\\n\\nFor that, we get ASCII values of every letter. \\n\\nNow first we subtract b from a, & finally c from b. Whatever remains are the elements of the difference list of length 2."
                    },
                    {
                        "username": "nilath",
                        "content": "Extremely easy but the logic pattern is used in multiple places.\\nThe key is that you have to find a unique value index among the same multiple values."
                    },
                    {
                        "username": "naman_khatri_21",
                        "content": "bro sand me an solution\\n"
                    },
                    {
                        "username": "swecpp",
                        "content": "Testcase: [\"abm\",\"bcn\",\"alm\"]\nAll the words have the same difference array \nwhich contradicts the conditions of the problem"
                    },
                    {
                        "username": "swecpp",
                        "content": "Replace difference array to difference string"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Boy that was tricky "
                    },
                    {
                        "username": "FarisRehman",
                        "content": "why is the code showing error for UNORDERED MAP and it is running fine for MAP???"
                    },
                    {
                        "username": "Prajju22",
                        "content": "because in unordered_map c++ have not defined any hash function for vector class so you have to define your own hash function for using unordered_map or else go with map "
                    },
                    {
                        "username": "ranjeet43",
                        "content": "The function score is finding the vector representing difference array for a string\\n\\nNow, I am iterating over words... so there are three possibilities.\\n**1. one of the middle string can be answer (lets say ith string)----> Now, if ith string is the answer then score for ith string will be different from both score for (i-1)th ans (i+1)th string.\\n\\n**2. If the left string (0th index) is the answer then score for ith (i==0 in this case) string is different from score for (i+1)th string.\\n\\n3. Else last string will be the answer---> No need of any check just return the last string.\\n\\nclass Solution {\\npublic:\\n    vector<int> score(string x)\\n    {\\n        vector<int> p;\\n        for(int i=1; i<x.size(); i++) p.push_back((x[i]-\\'a\\')-(x[i-1]-\\'a\\'));\\n        return p;\\n    }\\n    \\n    \\n    string oddString(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size()-1; i++)\\n            if(score(words[i])!=score(words[i+1]) && score(words[i])!=score(words[i-1])) return words[i];\\n        \\n        if(score(words[0])!=score(words[1])) return words[0];\\n        return words[words.size()-1];\\n            \\n    }\\n\\t\\n\\t// Please Upvote it guys ..... thank you :)\\n};\\n\\n\\n"
                    },
                    {
                        "username": "72engineers",
                        "content": "the logic is simple, but I debug for the unpassed cases for like 30+ mins... comparing to I finished Q2, Q3 in 15 mins."
                    }
                ]
            }
        ]
    }
]