[
    {
        "title": "Find All Possible Recipes from Given Supplies",
        "question_content": "You have information about n different recipes. You are given a string array recipes and a 2D string array ingredients. The ith recipe has the name recipes[i], and you can create it if you have all the needed ingredients from ingredients[i]. Ingredients to a recipe may need to be created from other recipes, i.e., ingredients[i] may contain a string that is in recipes.\nYou are also given a string array supplies containing all the ingredients that you initially have, and you have an infinite supply of all of them.\nReturn a list of all the recipes that you can create. You may return the answer in any order.\nNote that two recipes may contain each other in their ingredients.\n&nbsp;\nExample 1:\n\nInput: recipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\nOutput: [\"bread\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\n\nExample 2:\n\nInput: recipes = [\"bread\",\"sandwich\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\n\nExample 3:\n\nInput: recipes = [\"bread\",\"sandwich\",\"burger\"], ingredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]], supplies = [\"yeast\",\"flour\",\"meat\"]\nOutput: [\"bread\",\"sandwich\",\"burger\"]\nExplanation:\nWe can create \"bread\" since we have the ingredients \"yeast\" and \"flour\".\nWe can create \"sandwich\" since we have the ingredient \"meat\" and can create the ingredient \"bread\".\nWe can create \"burger\" since we have the ingredient \"meat\" and can create the ingredients \"bread\" and \"sandwich\".\n\n&nbsp;\nConstraints:\n\n\tn == recipes.length == ingredients.length\n\t1 <= n <= 100\n\t1 <= ingredients[i].length, supplies.length <= 100\n\t1 <= recipes[i].length, ingredients[i][j].length, supplies[k].length <= 10\n\trecipes[i], ingredients[i][j], and supplies[k] consist only of lowercase English letters.\n\tAll the values of recipes and supplies&nbsp;combined are unique.\n\tEach ingredients[i] does not contain any duplicate values.",
        "solutions": [
            {
                "id": 1646622,
                "title": "c-topological-sort-kahn-s-algo",
                "content": "```\\nvector<string> findAllRecipes(vector<string>& rec, vector<vector<string>>& ing, vector<string>& sup) {\\n        unordered_map<string,vector<string>> graph;\\n        int n = rec.size();\\n        unordered_set<string> s;\\n        for(auto x : sup) s.insert(x);            //store all the supplies in unordered set\\n\\t\\t\\n        unordered_map<string,int> indegree;   //to store the indegree of all recipes\\n        for(auto x : rec)indegree[x] = 0;                      //initially take the indegree of all recipes to be 0\\n    \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < (int)ing[i].size(); j++){\\n                if(s.find(ing[i][j]) == s.end()){     \\n                    graph[ing[i][j]].push_back(rec[i]);    //if the ingredient required to make a recipe is not in supplies then  \\n                    indegree[rec[i]]++;                     //we need to make a directed edge from that ingredient to recipe\\n                }\\n            }\\n        }\\n        \\n        //KAHN\\'S ALGORITHM\\n        queue<string> q;\\n        for(auto x : indegree){\\n            if(x.second == 0){\\n                q.push(x.first);\\n            }\\n        }\\n       vector<string> ans;\\n        while(!q.empty()){\\n            string tmp = q.front();\\n            q.pop();\\n            ans.push_back(tmp);\\n            for(auto nbr : graph[tmp]){\\n                indegree[nbr]--;\\n                if(indegree[nbr] == 0)\\n                    q.push(nbr);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n**Please upvote if you find this helpful, or if you think someone else might find it useful :)**\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> findAllRecipes(vector<string>& rec, vector<vector<string>>& ing, vector<string>& sup) {\\n        unordered_map<string,vector<string>> graph;\\n        int n = rec.size();\\n        unordered_set<string> s;\\n        for(auto x : sup) s.insert(x);            //store all the supplies in unordered set\\n\\t\\t\\n        unordered_map<string,int> indegree;   //to store the indegree of all recipes\\n        for(auto x : rec)indegree[x] = 0;                      //initially take the indegree of all recipes to be 0\\n    \\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < (int)ing[i].size(); j++){\\n                if(s.find(ing[i][j]) == s.end()){     \\n                    graph[ing[i][j]].push_back(rec[i]);    //if the ingredient required to make a recipe is not in supplies then  \\n                    indegree[rec[i]]++;                     //we need to make a directed edge from that ingredient to recipe\\n                }\\n            }\\n        }\\n        \\n        //KAHN\\'S ALGORITHM\\n        queue<string> q;\\n        for(auto x : indegree){\\n            if(x.second == 0){\\n                q.push(x.first);\\n            }\\n        }\\n       vector<string> ans;\\n        while(!q.empty()){\\n            string tmp = q.front();\\n            q.pop();\\n            ans.push_back(tmp);\\n            for(auto nbr : graph[tmp]){\\n                indegree[nbr]--;\\n                if(indegree[nbr] == 0)\\n                    q.push(nbr);\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1646584,
                "title": "java-python-3-toplogical-sort-w-brief-explanation",
                "content": "**Method 1: Bruteforce**\\nRepeated BFS till no any more finding\\n\\n1. Put all supplies into a HashSet, `seen`, for checking the availability in `O(1)` time;\\n2. Put into a Queue all indexes of the recipes;\\n3. BFS and put into `seen` all recipes that we currently can create; put back into the Queue if a recipe we currently can not create;\\n4. After any round of breadth search, if no any more recipe we can create, return the recipes we found so far.\\n\\n```java\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Set<String> seen = new HashSet<>();\\n        for (String sup : supplies) {\\n            seen.add(sup);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < recipes.length; ++i) {\\n            q.offer(i);\\n        }\\n        List<String> ans = new ArrayList<>();\\n        int prevSize = seen.size() - 1;\\n        while (seen.size() > prevSize) {\\n            prevSize = seen.size();\\n            mid:\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                int i = q.poll();\\n                for (String ing : ingredients.get(i)) {\\n                    if (!seen.contains(ing)) {\\n                        q.offer(i);\\n                        continue mid;\\n                    }\\n                }\\n                seen.add(recipes[i]);\\n                ans.add(recipes[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        ans = []\\n        seen = set(supplies)\\n        dq = deque([(r, ing) for r, ing in zip(recipes, ingredients)])\\n        \\n        # dummy value for prev_size, just to make sure \\n        # the initial value of prev_size < len(seen) \\n        prev_size = len(seen) - 1 \\n        \\n        # Keep searching if we have any new finding(s).\\n        while len(seen) > prev_size:\\n            prev_size = len(seen)\\n            for _ in range(len(dq)):\\n                r, ing = dq.popleft()\\n                if all(i in seen for i in ing):\\n                    ans.append(r)\\n                    seen.add(r)\\n                else:\\n                    dq.append((r, ing))\\n        return ans\\n```\\n\\n----\\n\\n**Method 2: Topological sort**\\n1. For each recipe, count its non-available ingredients as in degree; Store (non-available ingredient, dependent recipes) as HashMap; \\n2. Store all 0-in-degree recipes into a list as the starting points of topological sort;\\n3. Use topogical sort to decrease the in degree of recipes, whenever the in-degree reaches `0`, add it to return list.\\n\\n```java\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        List<String> ans = new ArrayList<>();\\n        // Put all supplies into HashSet.\\n        Set<String> available = Stream.of(supplies).collect(Collectors.toCollection(HashSet::new));\\n        Map<String, Set<String>> ingredientToRecipes = new HashMap<>();\\n        Map<String, Integer> inDegree = new HashMap<>();\\n        for (int i = 0; i < recipes.length; ++i) {\\n            int nonAvailable = 0;\\n            for (String ing : ingredients.get(i)) {\\n                if (!available.contains(ing)) {\\n                    ingredientToRecipes.computeIfAbsent(ing, s -> new HashSet<>()).add(recipes[i]);\\n                    ++nonAvailable;\\n                }\\n            }\\n            if (nonAvailable == 0) {\\n                ans.add(recipes[i]);\\n            }else {\\n                inDegree.put(recipes[i], nonAvailable);\\n            }\\n        }\\n        // Toplogical Sort.\\n        for (int i = 0; i < ans.size(); ++i) {\\n            String recipe = ans.get(i);\\n            if (ingredientToRecipes.containsKey(recipe)) {\\n                for (String rcp : ingredientToRecipes.remove(recipe)) {\\n                    if (inDegree.merge(rcp, -1, Integer::sum) == 0) {\\n                        ans.add(rcp);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n```python\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        available = set(supplies)\\n        ans, ingredient_to_recipe, in_degree = [], defaultdict(set), Counter()\\n        for rcp, ingredient in zip(recipes, ingredients):\\n            non_available = 0\\n            for ing in ingredient:\\n                if ing not in available:\\n                    non_available += 1\\n                    ingredient_to_recipe[ing].add(rcp)\\n            if non_available == 0:\\n                ans.append(rcp)\\n            else:\\n                in_degree[rcp] = non_available\\n        for rcp in ans:\\n            for recipe in ingredient_to_recipe.pop(rcp, set()):\\n                in_degree[recipe] -= 1\\n                if in_degree[recipe] == 0:\\n                    ans.append(recipe)\\n        return ans\\n```\\n\\nSimpler version is as follows:\\n\\nAssumption: `ingredients do not contain any recipe`.\\n1. For each recipe, count its dependent ingredients as in degree; Store (ingredient, recipes that dependent on it) as HashMap; \\n2. Use the `supplies` as the starting points of topological sort;\\n3. Use topogical sort to decrease the in degree of recipes, whenever the in-degree reaches `0`, add it to return list.\\n```java\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        // Construct directed graph and count in-degrees.\\n        Map<String, Set<String>> ingredientToRecipes = new HashMap<>();\\n        Map<String, Integer> inDegree = new HashMap<>();\\n        for (int i = 0; i < recipes.length; ++i) {\\n            for (String ing : ingredients.get(i)) {\\n                ingredientToRecipes.computeIfAbsent(ing, s -> new HashSet<>()).add(recipes[i]);\\n            }\\n            inDegree.put(recipes[i], ingredients.get(i).size());\\n        }\\n        // Toplogical Sort.\\n        List<String> ans = new ArrayList<>();\\n        Queue<String> available = Stream.of(supplies).collect(Collectors.toCollection(LinkedList::new));\\n        while (!available.isEmpty()) {\\n            String ing = available.poll();\\n            if (ingredientToRecipes.containsKey(ing)) {\\n                for (String rcp : ingredientToRecipes.remove(ing)) {\\n                    if (inDegree.merge(rcp, -1, Integer::sum) == 0) {\\n                        available.offer(rcp);\\n                        ans.add(rcp);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n```python\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        # Construct directed graph and count the in-degrees\\n        ingredient_to_recipe, in_degree = defaultdict(set), Counter()\\n        for rcp, ingredient in zip(recipes, ingredients):\\n            for ing in ingredient:\\n                ingredient_to_recipe[ing].add(rcp)\\n            in_degree[rcp] = len(ingredient)\\n        # Topological sort.    \\n        available, ans = deque(supplies), []\\n        while available:\\n            ing = available.popleft()\\n            for rcp in ingredient_to_recipe.pop(ing, set()):\\n                in_degree[rcp] -= 1\\n                if in_degree[rcp] == 0:\\n                    available.append(rcp)\\n                    ans.append(rcp)\\n        return ans\\n```\\n\\nWe can further simplify a bit the above Python 3 code, if you do NOT mind modifying the input `supplies`: get rid of the deque `available` and use `supplies` instead.\\n\\n```python\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        # Construct directed graph and count the in-degrees\\n        ingredient_to_recipe, in_degree = defaultdict(set), Counter()\\n        for rcp, ingredient in zip(recipes, ingredients):\\n            for ing in ingredient:\\n                ingredient_to_recipe[ing].add(rcp)\\n            in_degree[rcp] = len(ingredient)\\n        # Topological sort.    \\n        ans = []\\n        for ing in supplies:\\n            for rcp in ingredient_to_recipe.pop(ing, set()):\\n                in_degree[rcp] -= 1\\n                if in_degree[rcp] == 0:\\n                    supplies.append(rcp)\\n                    ans.append(rcp)\\n        return ans\\n```\\n\\n----\\n\\n**Q & A**\\nQ1: Please explain the below statement(particularly how these set() funtion here).\\n\\n```python\\n    for rcp in ingredient_to_recipe.pop(ing, set()):\\n```\\nA1: `ingredient_to_recipe.pop(ing, set())`: If existing, the dict will remove the  entry (key, value) and return the value corresponding to the key; if not, the dict will return the default value, a empty set.\\n\\nTherefore, if the key `ing` is in the dict, `ingredient_to_recipe`, the statement will one by one traverse the value, the set corresponding to `ing`; if not, it will NOT iterate into a empty set.\\n\\nQ2: Can you explain the intuition behind mapping ingredients to recipes instead of recipes to ingredients?\\nA2: Mapping ingredients to recipes is an iterative way, and from recipes to ingredients is a recursive way. Topological Sort I used is an iterative algorithm to handle the problem.\\n\\nSince the problem ask us to find all of the possible recipes, and it says that \"Ingredients to a recipe may need to be created from other recipes\", we build nonavailable ingredient to its dependent recipe mapping to implement the Topological Sort algorithm. You may need to learn the algorithm if you are not familiar with it. \\n\\n**End of Q & A**\\n",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Set<String> seen = new HashSet<>();\\n        for (String sup : supplies) {\\n            seen.add(sup);\\n        }\\n        Queue<Integer> q = new LinkedList<>();\\n        for (int i = 0; i < recipes.length; ++i) {\\n            q.offer(i);\\n        }\\n        List<String> ans = new ArrayList<>();\\n        int prevSize = seen.size() - 1;\\n        while (seen.size() > prevSize) {\\n            prevSize = seen.size();\\n            mid:\\n            for (int sz = q.size(); sz > 0; --sz) {\\n                int i = q.poll();\\n                for (String ing : ingredients.get(i)) {\\n                    if (!seen.contains(ing)) {\\n                        q.offer(i);\\n                        continue mid;\\n                    }\\n                }\\n                seen.add(recipes[i]);\\n                ans.add(recipes[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        ans = []\\n        seen = set(supplies)\\n        dq = deque([(r, ing) for r, ing in zip(recipes, ingredients)])\\n        \\n        # dummy value for prev_size, just to make sure \\n        # the initial value of prev_size < len(seen) \\n        prev_size = len(seen) - 1 \\n        \\n        # Keep searching if we have any new finding(s).\\n        while len(seen) > prev_size:\\n            prev_size = len(seen)\\n            for _ in range(len(dq)):\\n                r, ing = dq.popleft()\\n                if all(i in seen for i in ing):\\n                    ans.append(r)\\n                    seen.add(r)\\n                else:\\n                    dq.append((r, ing))\\n        return ans\\n```\n```java\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        List<String> ans = new ArrayList<>();\\n        // Put all supplies into HashSet.\\n        Set<String> available = Stream.of(supplies).collect(Collectors.toCollection(HashSet::new));\\n        Map<String, Set<String>> ingredientToRecipes = new HashMap<>();\\n        Map<String, Integer> inDegree = new HashMap<>();\\n        for (int i = 0; i < recipes.length; ++i) {\\n            int nonAvailable = 0;\\n            for (String ing : ingredients.get(i)) {\\n                if (!available.contains(ing)) {\\n                    ingredientToRecipes.computeIfAbsent(ing, s -> new HashSet<>()).add(recipes[i]);\\n                    ++nonAvailable;\\n                }\\n            }\\n            if (nonAvailable == 0) {\\n                ans.add(recipes[i]);\\n            }else {\\n                inDegree.put(recipes[i], nonAvailable);\\n            }\\n        }\\n        // Toplogical Sort.\\n        for (int i = 0; i < ans.size(); ++i) {\\n            String recipe = ans.get(i);\\n            if (ingredientToRecipes.containsKey(recipe)) {\\n                for (String rcp : ingredientToRecipes.remove(recipe)) {\\n                    if (inDegree.merge(rcp, -1, Integer::sum) == 0) {\\n                        ans.add(rcp);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        available = set(supplies)\\n        ans, ingredient_to_recipe, in_degree = [], defaultdict(set), Counter()\\n        for rcp, ingredient in zip(recipes, ingredients):\\n            non_available = 0\\n            for ing in ingredient:\\n                if ing not in available:\\n                    non_available += 1\\n                    ingredient_to_recipe[ing].add(rcp)\\n            if non_available == 0:\\n                ans.append(rcp)\\n            else:\\n                in_degree[rcp] = non_available\\n        for rcp in ans:\\n            for recipe in ingredient_to_recipe.pop(rcp, set()):\\n                in_degree[recipe] -= 1\\n                if in_degree[recipe] == 0:\\n                    ans.append(recipe)\\n        return ans\\n```\n```java\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        // Construct directed graph and count in-degrees.\\n        Map<String, Set<String>> ingredientToRecipes = new HashMap<>();\\n        Map<String, Integer> inDegree = new HashMap<>();\\n        for (int i = 0; i < recipes.length; ++i) {\\n            for (String ing : ingredients.get(i)) {\\n                ingredientToRecipes.computeIfAbsent(ing, s -> new HashSet<>()).add(recipes[i]);\\n            }\\n            inDegree.put(recipes[i], ingredients.get(i).size());\\n        }\\n        // Toplogical Sort.\\n        List<String> ans = new ArrayList<>();\\n        Queue<String> available = Stream.of(supplies).collect(Collectors.toCollection(LinkedList::new));\\n        while (!available.isEmpty()) {\\n            String ing = available.poll();\\n            if (ingredientToRecipes.containsKey(ing)) {\\n                for (String rcp : ingredientToRecipes.remove(ing)) {\\n                    if (inDegree.merge(rcp, -1, Integer::sum) == 0) {\\n                        available.offer(rcp);\\n                        ans.add(rcp);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```python\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        # Construct directed graph and count the in-degrees\\n        ingredient_to_recipe, in_degree = defaultdict(set), Counter()\\n        for rcp, ingredient in zip(recipes, ingredients):\\n            for ing in ingredient:\\n                ingredient_to_recipe[ing].add(rcp)\\n            in_degree[rcp] = len(ingredient)\\n        # Topological sort.    \\n        available, ans = deque(supplies), []\\n        while available:\\n            ing = available.popleft()\\n            for rcp in ingredient_to_recipe.pop(ing, set()):\\n                in_degree[rcp] -= 1\\n                if in_degree[rcp] == 0:\\n                    available.append(rcp)\\n                    ans.append(rcp)\\n        return ans\\n```\n```python\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        # Construct directed graph and count the in-degrees\\n        ingredient_to_recipe, in_degree = defaultdict(set), Counter()\\n        for rcp, ingredient in zip(recipes, ingredients):\\n            for ing in ingredient:\\n                ingredient_to_recipe[ing].add(rcp)\\n            in_degree[rcp] = len(ingredient)\\n        # Topological sort.    \\n        ans = []\\n        for ing in supplies:\\n            for rcp in ingredient_to_recipe.pop(ing, set()):\\n                in_degree[rcp] -= 1\\n                if in_degree[rcp] == 0:\\n                    supplies.append(rcp)\\n                    ans.append(rcp)\\n        return ans\\n```\n```python\\n    for rcp in ingredient_to_recipe.pop(ing, set()):\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1646903,
                "title": "dfs",
                "content": "This problem is not complex but \"hairy\".\\n\\nSince we only care if a recipe can be made or not (regarless of in which order), we do not need a topological sort. \\n\\nWe can use a simple DFS; we just need to track `can_make` for each recipe (undefined, yes or no), so that we traverse each node only once.\\n\\nTo simplify the DFS logic, we check `supplies` when generating `graph`, and create a self-loop for recipes without needed `supplies`. This ensures that those `recipes` cannot be made.\\n\\n**Python 3**\\n```python\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        graph, can_make, supplies = {recipe : [] for recipe in recipes},  {}, set(supplies)\\n        def dfs(recipe : str) -> bool:\\n            if recipe not in can_make:\\n                can_make[recipe] = False\\n                can_make[recipe] = all([dfs(ingr) for ingr in graph[recipe]])\\n            return can_make[recipe]\\n        for i, recipe in enumerate(recipes):\\n            for ingr in ingredients[i]:\\n                if ingr not in supplies:\\n                    graph[recipe].append(ingr if ingr in graph else recipe)\\n        return [recipe for recipe in recipes if dfs(recipe)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        graph, can_make, supplies = {recipe : [] for recipe in recipes},  {}, set(supplies)\\n        def dfs(recipe : str) -> bool:\\n            if recipe not in can_make:\\n                can_make[recipe] = False\\n                can_make[recipe] = all([dfs(ingr) for ingr in graph[recipe]])\\n            return can_make[recipe]\\n        for i, recipe in enumerate(recipes):\\n            for ingr in ingredients[i]:\\n                if ingr not in supplies:\\n                    graph[recipe].append(ingr if ingr in graph else recipe)\\n        return [recipe for recipe in recipes if dfs(recipe)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646597,
                "title": "topological-sort-dfs-java",
                "content": "**Approach:**\\nGiven problem is similar to topological sort if we consider \\n* Every ingredient as a prerequisite to a receipe.\\n* Supplies as a leaf node.\\n\\nSolution: \\n\\n```\\nclass Solution {\\n    private static final int NOT_VISITED = 0;\\n    private static final int VISITING = 1;\\n    private static final int VISITED = 2;\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, Integer> status = new HashMap<>();\\n        Map<String, List<String>> prereqs = new HashMap<>();\\n        \\n        for (int i = 0; i < recipes.length; ++ i) {\\n            status.put(recipes[i], NOT_VISITED);\\n            prereqs.put(recipes[i], ingredients.get(i));\\n        }\\n        \\n        for (String s: supplies) {\\n            status.put(s, VISITED);\\n        }\\n        \\n        List<String> output = new ArrayList<>();\\n        for (String s: recipes) {\\n            dfs (s, prereqs, status, output);\\n        }\\n        \\n        return output;\\n    }\\n    \\n    public boolean dfs(String s, Map<String, List<String>> prereqs, Map<String, Integer> status, List<String> output) {\\n        if (!status.containsKey(s)) {\\n            return false;\\n        }\\n        \\n        if (status.get(s) == VISITING) {\\n            return false;\\n        }\\n        \\n        if (status.get(s) == VISITED) {\\n            return true;\\n        }\\n        \\n        status.put(s, VISITING);\\n        for (String p: prereqs.get(s)) {\\n            if (!dfs(p, prereqs, status, output)) {\\n                return false;\\n            }\\n        }\\n        status.put(s, VISITED);\\n        output.add(s);\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private static final int NOT_VISITED = 0;\\n    private static final int VISITING = 1;\\n    private static final int VISITED = 2;\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, Integer> status = new HashMap<>();\\n        Map<String, List<String>> prereqs = new HashMap<>();\\n        \\n        for (int i = 0; i < recipes.length; ++ i) {\\n            status.put(recipes[i], NOT_VISITED);\\n            prereqs.put(recipes[i], ingredients.get(i));\\n        }\\n        \\n        for (String s: supplies) {\\n            status.put(s, VISITED);\\n        }\\n        \\n        List<String> output = new ArrayList<>();\\n        for (String s: recipes) {\\n            dfs (s, prereqs, status, output);\\n        }\\n        \\n        return output;\\n    }\\n    \\n    public boolean dfs(String s, Map<String, List<String>> prereqs, Map<String, Integer> status, List<String> output) {\\n        if (!status.containsKey(s)) {\\n            return false;\\n        }\\n        \\n        if (status.get(s) == VISITING) {\\n            return false;\\n        }\\n        \\n        if (status.get(s) == VISITED) {\\n            return true;\\n        }\\n        \\n        status.put(s, VISITING);\\n        for (String p: prereqs.get(s)) {\\n            if (!dfs(p, prereqs, status, output)) {\\n                return false;\\n            }\\n        }\\n        status.put(s, VISITED);\\n        output.add(s);\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646722,
                "title": "topological-sorting-c",
                "content": "```\\nclass Solution\\n{\\n\\tpublic:\\n    unordered_map<string, vector<string>> g;\\n\\n    vector<string> findAllRecipes(vector<string> &recipes, vector<vector<string>> &ingredients, vector<string> &supplies)\\n    {\\n        g.clear();\\n\\t\\t// Dependancy manager \\n        map<string, int> indegree;\\n\\n       \\n        for (int i = 0; i < ingredients.size(); i++)\\n        {\\n            for (string s : ingredients[i])\\n            {\\n\\t\\t\\t\\t// recpes[i] : Hey, I need s to make me so add me to its list(adjecency list)\\n                g[s].push_back(recipes[i]);\\n                indegree[recipes[i]]++;\\n            }\\n        }\\n\\n        queue<string> q;\\n        \\n        for(string item : supplies)\\n        {\\n\\t\\t\\t// Hey I dont need any other item to made me, I am alone and can help making others\\n\\t\\t\\t  q.push(item);\\n            \\n        }\\n\\n        while(!q.empty())\\n        {\\n            string current = q.front();\\n            q.pop();\\n\\n            for(string recipe : g[current])\\n            {\\n                indegree[recipe]--;\\n\\t\\t\\t\\t// Hey wooo!!!, I got all my supplies now I can be used for making other recepies\\n                if(indegree[recipe] == 0)\\n                {\\n                    q.push(recipe);\\n                }\\n            }\\n        }\\n\\n        vector<string> ans;\\n        for(string recipe : recipes)\\n        {\\n\\t\\t\\t// Hey, I just made it to the final!!!!! :)\\n            if(indegree[recipe] == 0)\\n            {\\n                ans.push_back(recipe);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "class Solution\\n{\\n\\tpublic:\\n    unordered_map<string, vector<string>> g;\\n\\n    vector<string> findAllRecipes(vector<string> &recipes, vector<vector<string>> &ingredients, vector<string> &supplies)\\n    {\\n        g.clear();\\n\\t\\t// Dependancy manager \\n        map<string, int> indegree;\\n\\n       \\n        for (int i = 0; i < ingredients.size(); i++)\\n        {\\n            for (string s : ingredients[i])\\n            {\\n\\t\\t\\t\\t// recpes[i] : Hey, I need s to make me so add me to its list(adjecency list)\\n                g[s].push_back(recipes[i]);\\n                indegree[recipes[i]]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1646605,
                "title": "python3-topological-sort-kahn-s-algo",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/8bba95f803d58a5e571fa13de6635c96f5d1c1ee) for solutions of biweekly 68. \\n\\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        indeg = defaultdict(int)\\n        graph = defaultdict(list)\\n        for r, ing in zip(recipes, ingredients): \\n            indeg[r] = len(ing)\\n            for i in ing: graph[i].append(r)\\n        \\n        ans = []\\n        queue = deque(supplies)\\n        recipes = set(recipes)\\n        while queue: \\n            x = queue.popleft()\\n            if x in recipes: ans.append(x)\\n            for xx in graph[x]: \\n                indeg[xx] -= 1\\n                if indeg[xx] == 0: queue.append(xx)\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        indeg = defaultdict(int)\\n        graph = defaultdict(list)\\n        for r, ing in zip(recipes, ingredients): \\n            indeg[r] = len(ing)\\n            for i in ing: graph[i].append(r)\\n        \\n        ans = []\\n        queue = deque(supplies)\\n        recipes = set(recipes)\\n        while queue: \\n            x = queue.popleft()\\n            if x in recipes: ans.append(x)\\n            for xx in graph[x]: \\n                indeg[xx] -= 1\\n                if indeg[xx] == 0: queue.append(xx)\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1664405,
                "title": "beginners-friendly-well-explained-94-faster",
                "content": "## IDEA  :\\n*Yeahh, This  question is little tricky. But when we come to question in which one element is dependent on others element to complete then we have to first think of Graph.*\\nHere, All the recipes and supplies ingredients should be made node and Edges `a->b` to be defined as for completion of recipe `b` we should have ingredients `a`.\\n\\nTaking the first Example:\\n\\'\\'\\'\\n\\n\\trecipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\\n\\t\\n\\twe can now draw the graph first. (Consider the graph directed from upper nodes to downwards)\\n\\t\\n\\t\\t\\t\\t\\tyeast       flour\\n\\t\\t\\t\\t\\t\\t  \\\\     /\\n\\t\\t\\t\\tmeat      Bread\\n\\t\\t\\t\\t  \\\\        /\\n\\t\\t\\t\\t  SandWhich\\n\\nSo From here, we can clearly see that we have to do topological sort, Since our graph will be always DAG.\\n\\n**Topological Sort :-** Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge u v, vertex u comes before v in the ordering. Topological Sorting for a graph is not possible if the graph is not a DAG.\\n****\\n### Implementation :\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\tin_degree = defaultdict(int)\\n\\t\\t\\tfor r,ing in zip(recipes,ingredients):\\n\\t\\t\\t\\tfor i in ing:\\n\\t\\t\\t\\t\\tgraph[i].append(r)\\n\\t\\t\\t\\t\\tin_degree[r]+=1\\n\\n\\t\\t\\tqueue = supplies[::]\\n\\t\\t\\tres = []\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\ting = queue.pop(0)\\n\\t\\t\\t\\tif ing in recipes:\\n\\t\\t\\t\\t\\tres.append(ing)\\n\\n\\t\\t\\t\\tfor child in graph[ing]:\\n\\t\\t\\t\\t\\tin_degree[child]-=1\\n\\t\\t\\t\\t\\tif in_degree[child]==0:\\n\\t\\t\\t\\t\\t\\tqueue.append(child)\\n\\n\\t\\t\\treturn res\\n\\t\\t\\n### Feel free to ask if you have any doubts!! \\uD83E\\uDD17\\n### **Thanks & Upvote if you like the Idea !!** \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "## IDEA  :\\n*Yeahh, This  question is little tricky. But when we come to question in which one element is dependent on others element to complete then we have to first think of Graph.*\\nHere, All the recipes and supplies ingredients should be made node and Edges `a->b` to be defined as for completion of recipe `b` we should have ingredients `a`.\\n\\nTaking the first Example:\\n\\'\\'\\'\\n\\n\\trecipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\\n\\t\\n\\twe can now draw the graph first. (Consider the graph directed from upper nodes to downwards)\\n\\t\\n\\t\\t\\t\\t\\tyeast       flour\\n\\t\\t\\t\\t\\t\\t  \\\\     /\\n\\t\\t\\t\\tmeat      Bread\\n\\t\\t\\t\\t  \\\\        /\\n\\t\\t\\t\\t  SandWhich\\n\\nSo From here, we can clearly see that we have to do topological sort, Since our graph will be always DAG.\\n\\n**Topological Sort :-** Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge u v, vertex u comes before v in the ordering. Topological Sorting for a graph is not possible if the graph is not a DAG.\\n****\\n### Implementation :\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\tin_degree = defaultdict(int)\\n\\t\\t\\tfor r,ing in zip(recipes,ingredients):\\n\\t\\t\\t\\tfor i in ing:\\n\\t\\t\\t\\t\\tgraph[i].append(r)\\n\\t\\t\\t\\t\\tin_degree[r]+=1\\n\\n\\t\\t\\tqueue = supplies[::]\\n\\t\\t\\tres = []\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\ting = queue.pop(0)\\n\\t\\t\\t\\tif ing in recipes:\\n\\t\\t\\t\\t\\tres.append(ing)\\n\\n\\t\\t\\t\\tfor child in graph[ing]:\\n\\t\\t\\t\\t\\tin_degree[child]-=1\\n\\t\\t\\t\\t\\tif in_degree[child]==0:\\n\\t\\t\\t\\t\\t\\tqueue.append(child)\\n\\n\\t\\t\\treturn res\\n\\t\\t\\n### Feel free to ask if you have any doubts!! \\uD83E\\uDD17\\n### **Thanks & Upvote if you like the Idea !!** \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1736422,
                "title": "java-topological-sort-with-comments",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashSet<String> sup = new HashSet<>();\\n        HashMap<String, Integer> index = new HashMap<>();\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        \\n        // create hashset of supplies\\n        for(String s: supplies) {\\n            sup.add(s);\\n        }\\n        \\n        // store index of all recipes\\n        for(int i = 0; i < recipes.length; i++) {\\n            index.put(recipes[i], i);\\n        }\\n        \\n        int[] indegree = new int[recipes.length];\\n        // create a mapping of all the recipes that are Ingredients as well\\n        // to the recipes they are ingredients for\\n        for(int i = 0; i < recipes.length; i++) {\\n            for(String need: ingredients.get(i)) {\\n                if(sup.contains(need))\\n                    continue;\\n                \\n                map.putIfAbsent(need, new ArrayList<String>());\\n                map.get(need).add(recipes[i]);\\n                indegree[i]++;\\n            }\\n        }\\n        \\n        LinkedList<Integer> q = new LinkedList<>();\\n        // add all the recipes with indegree 0 to the queue\\n        for(int i = 0; i < recipes.length; i++) {\\n            if(indegree[i] == 0) {\\n                q.add(i);\\n            }\\n        }\\n        \\n        List<String> cooked = new ArrayList<>();\\n        while(!q.isEmpty()) {\\n            int i = q.poll();\\n            cooked.add(recipes[i]);\\n            \\n            if(!map.containsKey(recipes[i])) {\\n                // if the map does not contain this recipe, this means\\n                // this recipe is not an ingredient for any other recipe\\n                // and no further processing is required\\n                continue;\\n            }\\n            \\n            for(String recipe: map.get(recipes[i])) {\\n                if(--indegree[index.get(recipe)] == 0) {\\n                    q.add(index.get(recipe));\\n                }\\n            }\\n        }\\n        \\n        return cooked;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashSet<String> sup = new HashSet<>();\\n        HashMap<String, Integer> index = new HashMap<>();\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        \\n        // create hashset of supplies\\n        for(String s: supplies) {\\n            sup.add(s);\\n        }\\n        \\n        // store index of all recipes\\n        for(int i = 0; i < recipes.length; i++) {\\n            index.put(recipes[i], i);\\n        }\\n        \\n        int[] indegree = new int[recipes.length];\\n        // create a mapping of all the recipes that are Ingredients as well\\n        // to the recipes they are ingredients for\\n        for(int i = 0; i < recipes.length; i++) {\\n            for(String need: ingredients.get(i)) {\\n                if(sup.contains(need))\\n                    continue;\\n                \\n                map.putIfAbsent(need, new ArrayList<String>());\\n                map.get(need).add(recipes[i]);\\n                indegree[i]++;\\n            }\\n        }\\n        \\n        LinkedList<Integer> q = new LinkedList<>();\\n        // add all the recipes with indegree 0 to the queue\\n        for(int i = 0; i < recipes.length; i++) {\\n            if(indegree[i] == 0) {\\n                q.add(i);\\n            }\\n        }\\n        \\n        List<String> cooked = new ArrayList<>();\\n        while(!q.isEmpty()) {\\n            int i = q.poll();\\n            cooked.add(recipes[i]);\\n            \\n            if(!map.containsKey(recipes[i])) {\\n                // if the map does not contain this recipe, this means\\n                // this recipe is not an ingredient for any other recipe\\n                // and no further processing is required\\n                continue;\\n            }\\n            \\n            for(String recipe: map.get(recipes[i])) {\\n                if(--indegree[index.get(recipe)] == 0) {\\n                    q.add(index.get(recipe));\\n                }\\n            }\\n        }\\n        \\n        return cooked;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646854,
                "title": "c-brute-force-topological-sort-explanation",
                "content": "**Brute force solution**\\n\\n(1) Insert all the suplies into a hash map.\\n(2) We use th existing supplies and create the possible recipes. These recipes are also entered into the has map of available items. \\n(3) We will keep iterating over all the recipes, and check if that recipe can be created now with new set of ingrdients we have, if yes, we will add it also to the map , else we move to the next recipe. \\n(4) We will keep this process running, until we encounter a stage , when we can no longer create new recipes. This is where we break the while loop\\n(5) We insert all the created recipes into a vector and return the result. \\n\\n```\\nvector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n\\n\\tunordered_map<string,bool> available;\\n\\tvector<string> res;\\n\\tfor(auto str:supplies)\\n\\t\\tavailable[str]=true;\\n\\tbool keepCooking=true;\\n\\tint n=recipes.size();\\n\\tvector<int> created(n,0);\\n\\twhile(keepCooking)\\n\\t{\\n\\t\\tkeepCooking=false;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tif(created[i])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tint count=ingredients[i].size();\\n\\t\\t\\tfor(auto &s:ingredients[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(available.find(s)!=available.end())\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t}\\n\\t\\t\\tif(!count)\\n\\t\\t\\t{\\n\\t\\t\\t\\tkeepCooking=true;\\n\\t\\t\\t\\tcreated[i]=1;\\n\\t\\t\\t\\tavailable[recipes[i]]=true;\\n\\t\\t\\t\\tres.push_back(recipes[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n  return res;\\n} \\n```\\n\\n\\n\\n**Using Topological sort**\\n\\n The dishes which can be cooked with the available supplies will be cooked first.It means recipes have a dependency on ingredients. \\n \\n We can contrsuct a directed graph from ingredients to the recipes. \\n The items present in supplies will have zero indegree (zero incoming edges) as those are already cooked and available for use. \\n \\n We insert these items in a queue and then one by one pop those elements out, reducing the indegree of the recipe depedent on that item by 1. \\n \\n If we encounter a recipe for which indegree has become zero, it means all supplies required for cooking it has been received it has been cooked and can further be used for preparing other recipes. It is also added in the ans vector. \\n \\n\\n```\\n vector<string> findAllRecipes(vector<string> &recipes, vector<vector<string>> &ingredients, vector<string> &supplies)\\n    {\\n        // create Directed graph from ingredients to the recipe and store indegree\\n       map<string, int> indegree;\\n       map<string, vector<string>> adj;\\n        for (int i = 0; i < ingredients.size(); i++)\\n        {\\n            for (string ing : ingredients[i])\\n            {\\n                adj[ing].push_back(recipes[i]);\\n                indegree[recipes[i]]++;\\n            }\\n        }\\n\\n        queue<string> q;\\n        vector<string> ans;\\n    \\n        for(string item : supplies)\\n            if(indegree[item] == 0)\\n                q.push(item);\\n\\n        while(!q.empty())\\n        {\\n            string item = q.front();\\n            q.pop();\\n            for(string recipe : adj[item])\\n            {\\n                if(--indegree[recipe] == 0)\\n                {\\n                    q.push(recipe);\\n                     ans.push_back(recipe);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Topological Sort"
                ],
                "code": "```\\nvector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n\\n\\tunordered_map<string,bool> available;\\n\\tvector<string> res;\\n\\tfor(auto str:supplies)\\n\\t\\tavailable[str]=true;\\n\\tbool keepCooking=true;\\n\\tint n=recipes.size();\\n\\tvector<int> created(n,0);\\n\\twhile(keepCooking)\\n\\t{\\n\\t\\tkeepCooking=false;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tif(created[i])\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\tint count=ingredients[i].size();\\n\\t\\t\\tfor(auto &s:ingredients[i])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(available.find(s)!=available.end())\\n\\t\\t\\t\\t\\tcount--;\\n\\t\\t\\t}\\n\\t\\t\\tif(!count)\\n\\t\\t\\t{\\n\\t\\t\\t\\tkeepCooking=true;\\n\\t\\t\\t\\tcreated[i]=1;\\n\\t\\t\\t\\tavailable[recipes[i]]=true;\\n\\t\\t\\t\\tres.push_back(recipes[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n  return res;\\n} \\n```\n```\\n vector<string> findAllRecipes(vector<string> &recipes, vector<vector<string>> &ingredients, vector<string> &supplies)\\n    {\\n        // create Directed graph from ingredients to the recipe and store indegree\\n       map<string, int> indegree;\\n       map<string, vector<string>> adj;\\n        for (int i = 0; i < ingredients.size(); i++)\\n        {\\n            for (string ing : ingredients[i])\\n            {\\n                adj[ing].push_back(recipes[i]);\\n                indegree[recipes[i]]++;\\n            }\\n        }\\n\\n        queue<string> q;\\n        vector<string> ans;\\n    \\n        for(string item : supplies)\\n            if(indegree[item] == 0)\\n                q.push(item);\\n\\n        while(!q.empty())\\n        {\\n            string item = q.front();\\n            q.pop();\\n            for(string recipe : adj[item])\\n            {\\n                if(--indegree[recipe] == 0)\\n                {\\n                    q.push(recipe);\\n                     ans.push_back(recipe);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1756825,
                "title": "python-3-dfs-easiest-to-understand-solution",
                "content": "DFS. If we find out we can make something, add it to our supplies so we don\\'t redo that work.\\n\\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        suppliesSet = set(supplies)\\n        recipesMap = {recipes[i]: ingredients[i] for i in range(0, len(recipes))}\\n        ans = []\\n        \\n        for recipe in recipesMap:\\n            if self.canMake(recipe, suppliesSet, recipesMap, set()):\\n                ans.append(recipe)\\n                \\n        return ans\\n    \\n    def canMake(self, target, suppliesSet, recipesMap, seen):\\n        if target in suppliesSet:\\n            return True\\n        if target in seen:\\n            return False\\n        if target not in recipesMap:\\n            return False\\n        \\n        seen.add(target)\\n        \\n        for ingredient in recipesMap[target]:\\n            if not self.canMake(ingredient, suppliesSet, recipesMap, seen):\\n                return False\\n        \\n        suppliesSet.add(target)\\n        return True\\n        \\n        \\n    \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        suppliesSet = set(supplies)\\n        recipesMap = {recipes[i]: ingredients[i] for i in range(0, len(recipes))}\\n        ans = []\\n        \\n        for recipe in recipesMap:\\n            if self.canMake(recipe, suppliesSet, recipesMap, set()):\\n                ans.append(recipe)\\n                \\n        return ans\\n    \\n    def canMake(self, target, suppliesSet, recipesMap, seen):\\n        if target in suppliesSet:\\n            return True\\n        if target in seen:\\n            return False\\n        if target not in recipesMap:\\n            return False\\n        \\n        seen.add(target)\\n        \\n        for ingredient in recipesMap[target]:\\n            if not self.canMake(ingredient, suppliesSet, recipesMap, seen):\\n                return False\\n        \\n        suppliesSet.add(target)\\n        return True\\n        \\n        \\n    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2268477,
                "title": "c-well-commented-code-topological-sort-easy-to-understand",
                "content": "* For each recipe, count its dependent ingredients as in degree; Store (ingredient, recipes that dependent on it) as map\\n\\n* Use the supplies as the starting points of topological sort (these have no dependency)\\n\\n* Use topogical sort to decrease the in-degree of recipes, whenever the in-degree reaches 0, add it to our answer vector (as all their dependencies are satisfied)\\n\\n---\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // idea is to use TOPOLOGICAL SORTING\\n    \\n    // where any foood item with indegree 0 means that item can be created\\n    \\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        // store what all dependencies exist for any item\\n        // similar to adjacent list of any node N\\n        // here node N is string, and all neighbour nodes are stored as vector<string>\\n        map<string, vector<string>> adjList;\\n        \\n        // to keep track of whether item can be made or still needs something before we can make it\\n        map<string, int>indegree;\\n        \\n        // check for each row of 2D matrix\\n        for(int i=0; i<ingredients.size(); i++)\\n        {\\n            // this will list out all the items need to make recipes[i]\\n            for(auto &item : ingredients[i])\\n            {\\n                // \\'item\\' is required to make \\'recipes[i]\\'\\n                adjList[item].push_back(recipes[i]);\\n                \\n                // recipes[i] now has a dependency \\n                indegree[recipes[i]]++;\\n            }\\n        }\\n        \\n        // will contain all items which can be made\\n        queue<string>q;\\n        \\n        // check from the list of given supplies, if some item is independent and we can make it or use it to make others\\n        for(auto &x : supplies)\\n            if(indegree[x]==0)\\n                q.push(x);\\n        \\n        \\n        \\n        while(!q.empty())\\n        {\\n            string node = q.front();\\n            q.pop();\\n            \\n            \\n            for(auto &nei : adjList[node])\\n            {\\n                // remove link of all neighbours of \\'node\\'\\n                indegree[nei]--;\\n                \\n                // if something becomes independent, add it to our queue\\n                if(indegree[nei]==0)\\n                    q.push(nei);\\n            }\\n        }\\n        \\n        \\n        vector<string> ans;\\n        \\n        // all things which have 0 indegree means that they can be made. hence, they will be part of our answer\\n        for(auto &x : recipes)\\n            if(indegree[x]==0)\\n                ans.push_back(x);\\n            \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Topological Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // idea is to use TOPOLOGICAL SORTING\\n    \\n    // where any foood item with indegree 0 means that item can be created\\n    \\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        // store what all dependencies exist for any item\\n        // similar to adjacent list of any node N\\n        // here node N is string, and all neighbour nodes are stored as vector<string>\\n        map<string, vector<string>> adjList;\\n        \\n        // to keep track of whether item can be made or still needs something before we can make it\\n        map<string, int>indegree;\\n        \\n        // check for each row of 2D matrix\\n        for(int i=0; i<ingredients.size(); i++)\\n        {\\n            // this will list out all the items need to make recipes[i]\\n            for(auto &item : ingredients[i])\\n            {\\n                // \\'item\\' is required to make \\'recipes[i]\\'\\n                adjList[item].push_back(recipes[i]);\\n                \\n                // recipes[i] now has a dependency \\n                indegree[recipes[i]]++;\\n            }\\n        }\\n        \\n        // will contain all items which can be made\\n        queue<string>q;\\n        \\n        // check from the list of given supplies, if some item is independent and we can make it or use it to make others\\n        for(auto &x : supplies)\\n            if(indegree[x]==0)\\n                q.push(x);\\n        \\n        \\n        \\n        while(!q.empty())\\n        {\\n            string node = q.front();\\n            q.pop();\\n            \\n            \\n            for(auto &nei : adjList[node])\\n            {\\n                // remove link of all neighbours of \\'node\\'\\n                indegree[nei]--;\\n                \\n                // if something becomes independent, add it to our queue\\n                if(indegree[nei]==0)\\n                    q.push(nei);\\n            }\\n        }\\n        \\n        \\n        vector<string> ans;\\n        \\n        // all things which have 0 indegree means that they can be made. hence, they will be part of our answer\\n        for(auto &x : recipes)\\n            if(indegree[x]==0)\\n                ans.push_back(x);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874483,
                "title": "dfs-beats-99-3",
                "content": "Idea is to create a graph and do DFS.\\nSince we are only interested if we can make the receipe and not the order, we can only suffice with DFS.\\n\\nTo avoid recalculating again, I have maintained 3 sets. Note total space used by readyItems, cantMakeItem, preparing is O(N) where N is size receipe array\\n\\nEvery receipe can belong to either readyItems, cantMakeItem, preparing\\n\\n```\\nclass Solution { \\n    HashSet<String> supplySet = new HashSet();\\n    HashSet<String> readyItems = new HashSet();\\n    HashSet<String> cantMakeItem = new HashSet();\\n    HashSet<String> preparing = new HashSet();\\n    \\n    HashMap<String, List<String>> preRequisite = new HashMap();\\n    \\n    boolean dfs(String key) {\\n        if(supplySet.contains(key) || readyItems.contains(key)) {\\n            return true;\\n        }\\n        if(cantMakeItem.contains(key) || !preRequisite.containsKey(key) || preparing.contains(key)) {\\n            return false;\\n        }\\n        boolean complete = true;\\n\\t\\t// To avoid cycles\\n        preparing.add(key);\\n        for(String s: preRequisite.get(key)) {\\n            complete = complete && dfs(s);\\n            if(!complete) {\\n                break;\\n            }\\n        }\\n        if(complete) {\\n            readyItems.add(key);\\n        } else {\\n            cantMakeItem.add(key);\\n        }\\n        preparing.remove(key);\\n        return complete;\\n    }\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        for(String s: supplies) {\\n            supplySet.add(s);\\n        }\\n        \\n        for(int i=0; i<recipes.length; ++i) {\\n            preRequisite.put(recipes[i], ingredients.get(i));\\n        }\\n        \\n        for(String key: preRequisite.keySet()) {\\n            dfs(key);\\n        }\\n        \\n        return new ArrayList(readyItems);\\n    }\\n}\\n````\\n\\nPlease upvote if you liked it (y)",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution { \\n    HashSet<String> supplySet = new HashSet();\\n    HashSet<String> readyItems = new HashSet();\\n    HashSet<String> cantMakeItem = new HashSet();\\n    HashSet<String> preparing = new HashSet();\\n    \\n    HashMap<String, List<String>> preRequisite = new HashMap();\\n    \\n    boolean dfs(String key) {\\n        if(supplySet.contains(key) || readyItems.contains(key)) {\\n            return true;\\n        }\\n        if(cantMakeItem.contains(key) || !preRequisite.containsKey(key) || preparing.contains(key)) {\\n            return false;\\n        }\\n        boolean complete = true;\\n\\t\\t// To avoid cycles\\n        preparing.add(key);\\n        for(String s: preRequisite.get(key)) {\\n            complete = complete && dfs(s);\\n            if(!complete) {\\n                break;\\n            }\\n        }\\n        if(complete) {\\n            readyItems.add(key);\\n        } else {\\n            cantMakeItem.add(key);\\n        }\\n        preparing.remove(key);\\n        return complete;\\n    }\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        for(String s: supplies) {\\n            supplySet.add(s);\\n        }\\n        \\n        for(int i=0; i<recipes.length; ++i) {\\n            preRequisite.put(recipes[i], ingredients.get(i));\\n        }\\n        \\n        for(String key: preRequisite.keySet()) {\\n            dfs(key);\\n        }\\n        \\n        return new ArrayList(readyItems);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646775,
                "title": "java-iterative-easy-to-understand",
                "content": "My simple brute force solution\\nWe need at most n itreation(n=recipes.length==ingredients.length)\\n\\nIn each iteration,\\nFor all recipes check if supplies of all ingredients are present or not\\nif present then add it to the answer as well as in supplies list(So that it can be used later)\\n```\\npublic List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n    Set<String> supple=new HashSet<>(Arrays.asList(supplies));\\n    Set<String>ans=new HashSet<>();\\n    \\n    for(int i=0;i<ingredients.size();i++){\\n        outer:\\n        for(int j=0;j<ingredients.size();j++){\\n            if(ans.contains(recipes[j]))continue;//recipe has already been made\\n            for(String ingre:ingredients.get(j)){\\n                if(!supple.contains(ingre))continue outer;//As all ingredients are not present in supplies\\n            }\\n            ans.add(recipes[j]);// add it to the answer\\n            supple.add(recipes[j]); //add it to the supplies list so that another recipe can use this recipe\\n        }\\n\\n    }\\n    return new ArrayList<>(ans);\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n    Set<String> supple=new HashSet<>(Arrays.asList(supplies));\\n    Set<String>ans=new HashSet<>();\\n    \\n    for(int i=0;i<ingredients.size();i++){\\n        outer:\\n        for(int j=0;j<ingredients.size();j++){\\n            if(ans.contains(recipes[j]))continue;//recipe has already been made\\n            for(String ingre:ingredients.get(j)){\\n                if(!supple.contains(ingre))continue outer;//As all ingredients are not present in supplies\\n            }\\n            ans.add(recipes[j]);// add it to the answer\\n            supple.add(recipes[j]); //add it to the supplies list so that another recipe can use this recipe\\n        }\\n\\n    }\\n    return new ArrayList<>(ans);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061290,
                "title": "python-topological-sort-with-graph-visualization",
                "content": "below is the graph for example 2 - \\n![image](https://assets.leetcode.com/users/images/48154896-7716-431f-929b-5a8fa0d878dd_1653167755.1263359.png)\\n\\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        graph = defaultdict(list)\\n        indegree = defaultdict(int)\\n        q = deque()\\n        result = []\\n        \\n        # everything in supplies has an indegree of 0\\n        for s in supplies:\\n            indegree[s] = 0\\n            q.append(s)\\n            \\n        for i, r in enumerate(recipes):\\n            for ing in ingredients[i]:\\n                graph[ing].append(r)\\n                indegree[r] += 1\\n                \\n        while q:\\n            node = q.pop()\\n            if node in recipes:\\n                result.append(node)\\n            for n in graph[node]:\\n                indegree[n] -= 1\\n                if indegree[n] == 0:\\n                    q.append(n)\\n                    \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        graph = defaultdict(list)\\n        indegree = defaultdict(int)\\n        q = deque()\\n        result = []\\n        \\n        # everything in supplies has an indegree of 0\\n        for s in supplies:\\n            indegree[s] = 0\\n            q.append(s)\\n            \\n        for i, r in enumerate(recipes):\\n            for ing in ingredients[i]:\\n                graph[ing].append(r)\\n                indegree[r] += 1\\n                \\n        while q:\\n            node = q.pop()\\n            if node in recipes:\\n                result.append(node)\\n            for n in graph[node]:\\n                indegree[n] -= 1\\n                if indegree[n] == 0:\\n                    q.append(n)\\n                    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144813,
                "title": "python-simple-dfs-solution",
                "content": "build a map `can_make` to save all makable receipes, initalizing with all supplies with True\\n\\nfor each receipe, \\n     if in `can_make`, return the corresponding result\\n\\t if not, if is a receipe, use dfs to check whether all its ingredients are makeable or not.\\n\\t \\n\\n```\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        def dfs(r):\\n            if r not in can_make:\\n                can_make[r] = False\\n                if r in graph:\\n                    can_make[r] = all([dfs(i) for i in graph[r]])\\n            return can_make[r]\\n        \\n        can_make = {s: True for s in supplies}\\n        graph = {r : ing for r, ing in zip(recipes, ingredients)}\\n        return [r for r in recipes if dfs(r)]\\n```",
                "solutionTags": [],
                "code": "```\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        def dfs(r):\\n            if r not in can_make:\\n                can_make[r] = False\\n                if r in graph:\\n                    can_make[r] = all([dfs(i) for i in graph[r]])\\n            return can_make[r]\\n        \\n        can_make = {s: True for s in supplies}\\n        graph = {r : ing for r, ing in zip(recipes, ingredients)}\\n        return [r for r in recipes if dfs(r)]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1646973,
                "title": "simple-java-solution-set-explanation",
                "content": "Track would contain boolean value that would check whether a new recipe is added or not in the while loop.\\n\\nWhile traversing through the while loop. There can be two possibilities :\\n1. A new recipe is added \\n\\t**Ex. recipe1 -> ingredient1, recipe2\\n\\t     recipe2 -> ingredient2, ingredient3\\n\\t\\t Supplies -> ingredient1, ingredient2, ingredient3**\\n\\t\\t While traversing through **while** , we can see in first traversal recipe2 can be made\\n\\t\\t Now I have to loop (while) again (as recipes that required recipe1 as their ingredient can be made now)\\n\\t\\t \\n2. No new Recipe is added\\n No need to traverse again as no new ingredients are added to supplies\\n```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Set<String> store = new HashSet<>();\\n        for(int i = 0; i < supplies.length; i++) {\\n            store.add(supplies[i]);\\n        }\\n        \\n        boolean ans = true, track = true;\\n        List<String> lst = new ArrayList<String>();\\n        while(track){\\n            track = false;\\n            for(int i = 0; i < recipes.length; i++) {\\n                if(store.contains(recipes[i])) continue;\\n\\t\\t\\t\\tans = true;\\n\\t\\t\\t\\tfor(int j = 0; j < ingredients.get(i).size(); j++) {\\n\\t\\t\\t\\t\\tif(!store.contains(ingredients.get(i).get(j))) {\\n\\t\\t\\t\\t\\t\\tans = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(ans == true) {\\n\\t\\t\\t\\t\\ttrack = true;\\n\\t\\t\\t\\t\\tstore.add(recipes[i]);\\n\\t\\t\\t\\t\\tlst.add(recipes[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        }\\n        return lst;\\n        \\n    }\\n}\\n```\\n\\n**Do UPVOTE \\uD83D\\uDE03 , if helped**",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Set<String> store = new HashSet<>();\\n        for(int i = 0; i < supplies.length; i++) {\\n            store.add(supplies[i]);\\n        }\\n        \\n        boolean ans = true, track = true;\\n        List<String> lst = new ArrayList<String>();\\n        while(track){\\n            track = false;\\n            for(int i = 0; i < recipes.length; i++) {\\n                if(store.contains(recipes[i])) continue;\\n\\t\\t\\t\\tans = true;\\n\\t\\t\\t\\tfor(int j = 0; j < ingredients.get(i).size(); j++) {\\n\\t\\t\\t\\t\\tif(!store.contains(ingredients.get(i).get(j))) {\\n\\t\\t\\t\\t\\t\\tans = false;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(ans == true) {\\n\\t\\t\\t\\t\\ttrack = true;\\n\\t\\t\\t\\t\\tstore.add(recipes[i]);\\n\\t\\t\\t\\t\\tlst.add(recipes[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n        }\\n        return lst;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830204,
                "title": "c-topological-storing-with-explanation",
                "content": "# Intuition\\nUsing topological sorting\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe need to create a Directed Acyclic Graph to apply topological sorting.\\n\\nTo create the graph, we create an unordered map where\\nkey -> ingredient\\nvalue -> recipes corresponding to that ingredient\\n\\nFor every recipe whose ingredient is not available in the supply, we create an edge from ingredient to recipe in the graph and also increment the indegree of that recipe.\\nIndegree -> number of incoming edges at a node\\n\\nCreate a queue to store all the recipes whose indegree is 0\\n\\nTraverse through the queue until it\\'s empty\\nLook for its neighbours and decrement their indegree\\nIf their indegree becomes 0, add it to queue and repeat the same process\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        vector<string> ans;\\n        unordered_map<string, vector<string>> graph;\\n        unordered_map<string, int> indegree;\\n        queue<string> q;\\n\\n        for(int i=0; i<recipes.size(); i++){\\n            string rec = recipes[i];\\n            indegree[rec]=0;\\n\\n            for(auto ing: ingredients[i]){\\n                if(find(supplies.begin(), supplies.end(), ing) == supplies.end()){\\n                    indegree[rec]++;\\n                    graph[ing].push_back(rec);\\n                }\\n            }\\n        }\\n\\n        for(auto in: indegree){\\n            if(in.second == 0)\\n                q.push(in.first);\\n        }\\n\\n        while(!q.empty()){\\n            string current = q.front();\\n            q.pop();\\n            ans.push_back(current);\\n\\n            for(auto ad: graph[current]){\\n                indegree[ad]--;\\n                if(indegree[ad] == 0)\\n                    q.push(ad);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        vector<string> ans;\\n        unordered_map<string, vector<string>> graph;\\n        unordered_map<string, int> indegree;\\n        queue<string> q;\\n\\n        for(int i=0; i<recipes.size(); i++){\\n            string rec = recipes[i];\\n            indegree[rec]=0;\\n\\n            for(auto ing: ingredients[i]){\\n                if(find(supplies.begin(), supplies.end(), ing) == supplies.end()){\\n                    indegree[rec]++;\\n                    graph[ing].push_back(rec);\\n                }\\n            }\\n        }\\n\\n        for(auto in: indegree){\\n            if(in.second == 0)\\n                q.push(in.first);\\n        }\\n\\n        while(!q.empty()){\\n            string current = q.front();\\n            q.pop();\\n            ans.push_back(current);\\n\\n            for(auto ad: graph[current]){\\n                indegree[ad]--;\\n                if(indegree[ad] == 0)\\n                    q.push(ad);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1815471,
                "title": "python3-bfs-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        adj=defaultdict(list)\\n        ind=defaultdict(int)\\n        \\n        for i in range(len(ingredients)):\\n            for j in range(len(ingredients[i])):\\n                adj[ingredients[i][j]].append(recipes[i])\\n                ind[recipes[i]]+=1\\n        ans=[]\\n        q=deque()\\n        for i in range(len(supplies)):\\n            q.append(supplies[i])\\n        while q:\\n            node=q.popleft()\\n            for i in adj[node]:\\n                ind[i]-=1\\n                if ind[i]==0:\\n                    q.append(i)\\n                    ans.append(i)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        adj=defaultdict(list)\\n        ind=defaultdict(int)\\n        \\n        for i in range(len(ingredients)):\\n            for j in range(len(ingredients[i])):\\n                adj[ingredients[i][j]].append(recipes[i])\\n                ind[recipes[i]]+=1\\n        ans=[]\\n        q=deque()\\n        for i in range(len(supplies)):\\n            q.append(supplies[i])\\n        while q:\\n            node=q.popleft()\\n            for i in adj[node]:\\n                ind[i]-=1\\n                if ind[i]==0:\\n                    q.append(i)\\n                    ans.append(i)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1684362,
                "title": "c-solutions-using-kahn-s-algorithm-topo-sort",
                "content": "```\\nvector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        //vector to store our final ans\\n        vector<string> res;\\n        \\n\\t\\t//map to store indegree of our recipes , initially indegree of all = 0\\n        unordered_map<string,int> in;\\n        for(auto &rec : recipes) in[rec] = 0;\\n        \\n\\t\\t//our directed graph\\n        unordered_map<string,vector<string>> g;\\n        \\n\\t\\t//set to store supplies\\n        unordered_set<string> st;\\n        for(auto &sup : supplies) st.insert(sup);\\n        \\n\\t\\t//iterate over recipes and check which recipes can be made with initial supplies available\\n        for(int i=0;i<size(recipes);i++)\\n        {\\n            for(int j=0;j<size(ingredients[i]);j++)\\n            {\\n\\t\\t\\t//in case a recipe cann\\'t be made\\n                if(st.find(ingredients[i][j]) == st.end())\\n                {\\n\\t\\t\\t\\t\\t//increase its indegree by 1 and make a directed edge between that ingredient and recipe\\n                    in[recipes[i]]++;\\n                    g[ingredients[i][j]].push_back(recipes[i]);\\n                }\\n            }\\n        }\\n        \\n\\t\\t//from here we just did our standard topo sort, which\\'ll give us our required ans\\n        queue<string> q;\\n        for(auto &[key,value] : in)\\n        {\\n            if(value == 0)\\n                q.push(key);\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int c = size(q);\\n            for(int i=0;i<c;i++)\\n            {\\n                auto rec = q.front(); q.pop();\\n                res.push_back(rec);\\n                for(auto &child : g[rec])\\n                {\\n                    in[child]--;\\n                    if(in[child] == 0) q.push(child);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "```\\nvector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        //vector to store our final ans\\n        vector<string> res;\\n        \\n\\t\\t//map to store indegree of our recipes , initially indegree of all = 0\\n        unordered_map<string,int> in;\\n        for(auto &rec : recipes) in[rec] = 0;\\n        \\n\\t\\t//our directed graph\\n        unordered_map<string,vector<string>> g;\\n        \\n\\t\\t//set to store supplies\\n        unordered_set<string> st;\\n        for(auto &sup : supplies) st.insert(sup);\\n        \\n\\t\\t//iterate over recipes and check which recipes can be made with initial supplies available\\n        for(int i=0;i<size(recipes);i++)\\n        {\\n            for(int j=0;j<size(ingredients[i]);j++)\\n            {\\n\\t\\t\\t//in case a recipe cann\\'t be made\\n                if(st.find(ingredients[i][j]) == st.end())\\n                {\\n\\t\\t\\t\\t\\t//increase its indegree by 1 and make a directed edge between that ingredient and recipe\\n                    in[recipes[i]]++;\\n                    g[ingredients[i][j]].push_back(recipes[i]);\\n                }\\n            }\\n        }\\n        \\n\\t\\t//from here we just did our standard topo sort, which\\'ll give us our required ans\\n        queue<string> q;\\n        for(auto &[key,value] : in)\\n        {\\n            if(value == 0)\\n                q.push(key);\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int c = size(q);\\n            for(int i=0;i<c;i++)\\n            {\\n                auto rec = q.front(); q.pop();\\n                res.push_back(rec);\\n                for(auto &child : g[rec])\\n                {\\n                    in[child]--;\\n                    if(in[child] == 0) q.push(child);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1826723,
                "title": "javascript-three-solutions-dfs-iterative-and-topological-sort",
                "content": "Since we don\\'t need to care of the order these recipes come in, we don\\'t need to use toposort.\\nThanks to @votrubac for this idea. https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/discuss/1646903/DFS\\nBefore solving this problem I didn\\'t know what topological sort is, and I solved it in brute forse, which I add below. But then the more I learned about toposort, it became apparent to me that we don\\'t need to use it.\\n\\nIdea - if we have all of the ingredients we add recipe in the result list. The problem arises when we have two recipes as a prerequisits of one another. So all we have to check if we have started this prereq as a recipe before, that\\'s why I use progress to mark each ingredient. If we have started this prereq before, then we got a problem, we return false, otherwise we continue, placing the rest of the recipes to the result.\\nToposort last solution, like many of users used a queue to go through all of the recipes.\\n\\n```\\nvar findAllRecipes = function(recipes, ingredients, supplies) {\\n    const setOfIngredients = new Set(supplies);\\n    const recipesWithIngredients = new Map();\\n    const progress = new Map();\\n\\t//map recipes to it\\'s ingredients and set each recipe to false in another map called progress\\n    for(let i = 0; i < recipes.length; i++) {\\n        recipesWithIngredients.set(recipes[i], ingredients[i]);\\n        progress.set(recipes[i], false)\\n    }\\n    \\n    const result = [];\\n    \\n    for(const rec of recipes) {\\n        if(recurse(rec, recipesWithIngredients, setOfIngredients, progress)) {\\n            result.push(rec);\\n            setOfIngredients.add(rec);\\n        }\\n    }\\n    \\n    return result;\\n};\\n\\nfunction recurse(rec, recipesWithIngredients, setOfIngredients, progress) {\\n    const currentIngredients = recipesWithIngredients.get(rec);\\n    for(const ingredient of currentIngredients) {\\n        if(setOfIngredients.has(rec)) continue;\\n        if(setOfIngredients.has(ingredient)) continue;\\n        \\n        else if(recipesWithIngredients.has(ingredient)) {\\n            if(progress.get(ingredient)) return false;\\n            progress.set(ingredient, true); \\n            let hasCycle = recurse(ingredient, recipesWithIngredients, setOfIngredients, progress);\\n            if(!hasCycle) return false;\\n            setOfIngredients.add(ingredient);\\n        } else {\\n            return false;\\n        } \\n    }\\n    return true;\\n}\\n```\\n\\nbrute force\\n\\n```\\nvar findAllRecipes = function(recipes, ingredients, supplies) {\\n    const setOfIngredients = new Set();\\n    for(const ingredient of supplies) setOfIngredients.add(ingredient);\\n    const result = [];\\n    let track = true;\\n    while(track) {\\n        track = false;\\n        for(let i = 0; i < recipes.length; i++) {\\n            let recipe = recipes[i];\\n            let ingred = ingredients[i];\\n            if(result.indexOf(recipe) >= 0) continue;\\n            let hasAllIngredients = true;\\n            for(const ing of ingred) { \\n                if(!setOfIngredients.has(ing)) {\\n                    hasAllIngredients = false;\\n                    break;\\n                }\\n            }\\n            if(hasAllIngredients) {\\n                setOfIngredients.add(recipe);\\n                result.push(recipe);\\n                track = true;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```\\nTopological sort\\n\\n```\\nvar findAllRecipes = function(recipes, ingredients, supplies) {\\n    const listOfSupplies = new Set(supplies);\\n    const indexes = new Map();\\n    const map = new Map();\\n    for(let i = 0; i < recipes.length; i++) {\\n        indexes.set(recipes[i], i);\\n    }\\n    \\n    const indegree = new Array(recipes.length).fill(0);\\n    \\n    for(let i = 0; i < recipes.length; i++) {\\n        let ingr = ingredients[i];\\n        for(let ing of ingr) {\\n            if(listOfSupplies.has(ing)) continue;\\n            \\n            if(!map.has(ing)) map.set(ing, []);\\n            map.get(ing).push(recipes[i]);\\n            indegree[i]++;\\n        }\\n    }\\n    \\n    const queue = [];\\n    const result = [];\\n    for(let i = 0; i < indegree.length; i++) {\\n        if(indegree[i] === 0) queue.push(i);\\n    }\\n    while(queue.length > 0) {\\n        let idx = queue.shift();\\n        result.push(recipes[idx]);\\n        if(!map.has(recipes[idx])) continue;\\n        const listOfDeps = map.get(recipes[idx]);\\n        removeDeps(listOfDeps, queue, indexes, indegree)\\n\\n    }\\n    return result;\\n};\\n\\nfunction removeDeps(listOfDeps, queue, indexes, indegree) {\\n    for(const dep of listOfDeps) {\\n        let depsIdx = indexes.get(dep)\\n        indegree[depsIdx]--;\\n        if(indegree[depsIdx] === 0) queue.push(depsIdx)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvar findAllRecipes = function(recipes, ingredients, supplies) {\\n    const setOfIngredients = new Set(supplies);\\n    const recipesWithIngredients = new Map();\\n    const progress = new Map();\\n\\t//map recipes to it\\'s ingredients and set each recipe to false in another map called progress\\n    for(let i = 0; i < recipes.length; i++) {\\n        recipesWithIngredients.set(recipes[i], ingredients[i]);\\n        progress.set(recipes[i], false)\\n    }\\n    \\n    const result = [];\\n    \\n    for(const rec of recipes) {\\n        if(recurse(rec, recipesWithIngredients, setOfIngredients, progress)) {\\n            result.push(rec);\\n            setOfIngredients.add(rec);\\n        }\\n    }\\n    \\n    return result;\\n};\\n\\nfunction recurse(rec, recipesWithIngredients, setOfIngredients, progress) {\\n    const currentIngredients = recipesWithIngredients.get(rec);\\n    for(const ingredient of currentIngredients) {\\n        if(setOfIngredients.has(rec)) continue;\\n        if(setOfIngredients.has(ingredient)) continue;\\n        \\n        else if(recipesWithIngredients.has(ingredient)) {\\n            if(progress.get(ingredient)) return false;\\n            progress.set(ingredient, true); \\n            let hasCycle = recurse(ingredient, recipesWithIngredients, setOfIngredients, progress);\\n            if(!hasCycle) return false;\\n            setOfIngredients.add(ingredient);\\n        } else {\\n            return false;\\n        } \\n    }\\n    return true;\\n}\\n```\n```\\nvar findAllRecipes = function(recipes, ingredients, supplies) {\\n    const setOfIngredients = new Set();\\n    for(const ingredient of supplies) setOfIngredients.add(ingredient);\\n    const result = [];\\n    let track = true;\\n    while(track) {\\n        track = false;\\n        for(let i = 0; i < recipes.length; i++) {\\n            let recipe = recipes[i];\\n            let ingred = ingredients[i];\\n            if(result.indexOf(recipe) >= 0) continue;\\n            let hasAllIngredients = true;\\n            for(const ing of ingred) { \\n                if(!setOfIngredients.has(ing)) {\\n                    hasAllIngredients = false;\\n                    break;\\n                }\\n            }\\n            if(hasAllIngredients) {\\n                setOfIngredients.add(recipe);\\n                result.push(recipe);\\n                track = true;\\n            }\\n        }\\n    }\\n    return result;\\n};\\n```\n```\\nvar findAllRecipes = function(recipes, ingredients, supplies) {\\n    const listOfSupplies = new Set(supplies);\\n    const indexes = new Map();\\n    const map = new Map();\\n    for(let i = 0; i < recipes.length; i++) {\\n        indexes.set(recipes[i], i);\\n    }\\n    \\n    const indegree = new Array(recipes.length).fill(0);\\n    \\n    for(let i = 0; i < recipes.length; i++) {\\n        let ingr = ingredients[i];\\n        for(let ing of ingr) {\\n            if(listOfSupplies.has(ing)) continue;\\n            \\n            if(!map.has(ing)) map.set(ing, []);\\n            map.get(ing).push(recipes[i]);\\n            indegree[i]++;\\n        }\\n    }\\n    \\n    const queue = [];\\n    const result = [];\\n    for(let i = 0; i < indegree.length; i++) {\\n        if(indegree[i] === 0) queue.push(i);\\n    }\\n    while(queue.length > 0) {\\n        let idx = queue.shift();\\n        result.push(recipes[idx]);\\n        if(!map.has(recipes[idx])) continue;\\n        const listOfDeps = map.get(recipes[idx]);\\n        removeDeps(listOfDeps, queue, indexes, indegree)\\n\\n    }\\n    return result;\\n};\\n\\nfunction removeDeps(listOfDeps, queue, indexes, indegree) {\\n    for(const dep of listOfDeps) {\\n        let depsIdx = indexes.get(dep)\\n        indegree[depsIdx]--;\\n        if(indegree[depsIdx] === 0) queue.push(depsIdx)\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1712019,
                "title": "python-topological-sorting",
                "content": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        supplies=set(supplies)\\n        graph=defaultdict(list)\\n        n=len(recipes)\\n        in_degree=defaultdict(int)\\n        for i in range(n):\\n            u=recipes[i]\\n            for v in ingredients[i]:\\n                graph[v].append(u)\\n                in_degree[u]+=1\\n        q=deque([i for i in supplies])\\n        while q:\\n            curr_supp=q.popleft()\\n            for nei in graph[curr_supp]:\\n                in_degree[nei]-=1\\n                if in_degree[nei]==0: q.append(nei)\\n        ans=[]\\n        for recipe in recipes:\\n            if in_degree[recipe]<=0: ans.append(recipe)\\n        return ans\\n                    \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        supplies=set(supplies)\\n        graph=defaultdict(list)\\n        n=len(recipes)\\n        in_degree=defaultdict(int)\\n        for i in range(n):\\n            u=recipes[i]\\n            for v in ingredients[i]:\\n                graph[v].append(u)\\n                in_degree[u]+=1\\n        q=deque([i for i in supplies])\\n        while q:\\n            curr_supp=q.popleft()\\n            for nei in graph[curr_supp]:\\n                in_degree[nei]-=1\\n                if in_degree[nei]==0: q.append(nei)\\n        ans=[]\\n        for recipe in recipes:\\n            if in_degree[recipe]<=0: ans.append(recipe)\\n        return ans\\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647003,
                "title": "c-dfs-memoization",
                "content": "```\\nclass Solution {\\nprivate:\\n    unordered_set<string> have;\\n    unordered_map<string, bool> canMake;\\n    unordered_map<string, int> rcp2idx;\\n    vector<string> ans;\\n    \\n    bool exist(const string& igrd, const vector<vector<string>>& ingredients) {\\n        if (have.count(igrd) > 0) return true;\\n        if (rcp2idx.count(igrd) == 0) return false;\\n        if (canMake.count(igrd) > 0) return canMake[igrd];\\n        \\n        canMake[igrd] = false;\\n        int i = rcp2idx[igrd];\\n        for (const string& igrdNext : ingredients[i]) {\\n            if (!exist(igrdNext, ingredients)) {\\n                return false;\\n            }\\n        }\\n        canMake[igrd] = true;\\n        ans.push_back(igrd);\\n        return true;\\n    }\\n    \\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        for (string& s : supplies) have.insert(s);\\n        for (int i = 0; i < recipes.size(); i++) rcp2idx[recipes[i]] = i;\\n        for (string& rcp : recipes) exist(rcp, ingredients);\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\nprivate:\\n    unordered_set<string> have;\\n    unordered_map<string, bool> canMake;\\n    unordered_map<string, int> rcp2idx;\\n    vector<string> ans;\\n    \\n    bool exist(const string& igrd, const vector<vector<string>>& ingredients) {\\n        if (have.count(igrd) > 0) return true;\\n        if (rcp2idx.count(igrd) == 0) return false;\\n        if (canMake.count(igrd) > 0) return canMake[igrd];\\n        \\n        canMake[igrd] = false;\\n        int i = rcp2idx[igrd];\\n        for (const string& igrdNext : ingredients[i]) {\\n            if (!exist(igrdNext, ingredients)) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2569074,
                "title": "c-topo-sort-with-explanation-kahn-s-algorithm",
                "content": "![image](https://assets.leetcode.com/users/images/45331de0-d254-46bc-8aa9-11a2a6e8f9e0_1663209942.989435.jpeg)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        unordered_map<string,int>indegree;\\n        for(auto i:recipes)\\n            indegree[i]=0;   //Initially indegree of every recipe is 0\\n        \\n        unordered_map<string,vector<string>>graph;\\n        \\n        for(int i=0;i<recipes.size();i++){\\n            \\n            for(int j=0;j<ingredients[i].size();j++){\\n                \\n                if(find(supplies.begin(),supplies.end(),ingredients[i][j])==supplies.end()){ //finds if the ingredient exist in the supply or not\\n                    \\n                    graph[ingredients[i][j]].push_back(recipes[i]); //If not then ingredients[i][j] is required to prepare the recipes[i] i.e bread--->burger, sandwitch ---> burger\\n                    \\n                    indegree[recipes[i]]++;     //increase the indegree of the recipe , for example , bread->burger,sandwitch-->burger , now indegree of burger is 2\\n                }\\n            }\\n        }\\n        queue<string>q;            //Now simple topo sort using bfs (Kahn\\'s algorithm)\\n        for(auto i:indegree){\\n            if(i.second==0)\\n                q.push(i.first);\\n        }\\n        vector<string>ans;\\n        \\n        while(!q.empty()){\\n            string front=q.front();\\n            q.pop();\\n            ans.push_back(front);\\n            for(auto i:graph[front]){\\n                indegree[i]--;\\n                if(!indegree[i])\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        unordered_map<string,int>indegree;\\n        for(auto i:recipes)\\n            indegree[i]=0;   //Initially indegree of every recipe is 0\\n        \\n        unordered_map<string,vector<string>>graph;\\n        \\n        for(int i=0;i<recipes.size();i++){\\n            \\n            for(int j=0;j<ingredients[i].size();j++){\\n                \\n                if(find(supplies.begin(),supplies.end(),ingredients[i][j])==supplies.end()){ //finds if the ingredient exist in the supply or not\\n                    \\n                    graph[ingredients[i][j]].push_back(recipes[i]); //If not then ingredients[i][j] is required to prepare the recipes[i] i.e bread--->burger, sandwitch ---> burger\\n                    \\n                    indegree[recipes[i]]++;     //increase the indegree of the recipe , for example , bread->burger,sandwitch-->burger , now indegree of burger is 2\\n                }\\n            }\\n        }\\n        queue<string>q;            //Now simple topo sort using bfs (Kahn\\'s algorithm)\\n        for(auto i:indegree){\\n            if(i.second==0)\\n                q.push(i.first);\\n        }\\n        vector<string>ans;\\n        \\n        while(!q.empty()){\\n            string front=q.front();\\n            q.pop();\\n            ans.push_back(front);\\n            for(auto i:graph[front]){\\n                indegree[i]--;\\n                if(!indegree[i])\\n                    q.push(i);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2035277,
                "title": "c-solution-using-topological-sort-with-comments",
                "content": "Topological sort is great when you have a list of \"prerequisites\" and you\\'re trying to find out what\\'s possible given the prereqs and some items that depend on them. E.g. which recipes you can make or the order in which you\\'d have to make them. Check out \"Course Schedule\" and \"Course Schedule II\" for the classic topological sort problems.\\n\\n\\n```\\n    public IList<string> FindAllRecipes(string[] recipes, IList<IList<string>> ingredients, string[] supplies) \\n    {\\n        // Create map of ingredient to recipes that contain it\\n        var ingredientToRecipesDict = new Dictionary<string, List<string>>();\\n        \\n        // We want to know how many ingredients each recipe depends on (indegree)\\n        var recipeDependencyCounts = new Dictionary<string, int>();\\n        \\n        for (int i = 0; i < recipes.Length; i++)\\n        {\\n            recipeDependencyCounts.Add(recipes[i], ingredients[i].Count);\\n            \\n            // Loop through the ingredients of each recipe\\n            for (int j = 0; j < ingredients[i].Count(); j++)\\n            {\\n                var ingredient = ingredients[i][j];\\n                if (!ingredientToRecipesDict.ContainsKey(ingredient))\\n                {\\n                    ingredientToRecipesDict.Add(ingredient, new List<string>());\\n                }\\n                \\n                ingredientToRecipesDict[ingredient].Add(recipes[i]);\\n            }\\n        }\\n        \\n        // Now use topological sort to build the list of possible recipes\\n        var possibleRecipes = new List<string>();\\n\\n        // The queue will contain \"available ingredients\"\\n        // Start by queueing all given supplies, then when any recipe is formed, queue the recipe since it has become an \"available ingredient\" for our other recipes\\n        var queue = new Queue<string>();\\n        foreach (var supply in supplies)\\n        {\\n            queue.Enqueue(supply);\\n        }\\n        \\n        while (queue.Any())\\n        {            \\n            var ingredient = queue.Dequeue();\\n            \\n            // Use the dict to get all dependent recipes of this ingredient\\n            if (!ingredientToRecipesDict.ContainsKey(ingredient))\\n            {\\n                // If no recipes depend on this ingredient, continue\\n                continue;\\n            }\\n            \\n            var dependentRecipes = ingredientToRecipesDict[ingredient];\\n            \\n            foreach (var recipe in dependentRecipes)\\n            {\\n                recipeDependencyCounts[recipe]--;\\n                if (recipeDependencyCounts[recipe] == 0)\\n                {\\n                    queue.Enqueue(recipe);\\n                    possibleRecipes.Add(recipe);\\n                }\\n            }\\n        }\\n        \\n        return possibleRecipes;\\n    }\\n\\t",
                "solutionTags": [
                    "Topological Sort",
                    "Queue"
                ],
                "code": "Topological sort is great when you have a list of \"prerequisites\" and you\\'re trying to find out what\\'s possible given the prereqs and some items that depend on them. E.g. which recipes you can make or the order in which you\\'d have to make them. Check out \"Course Schedule\" and \"Course Schedule II\" for the classic topological sort problems.\\n\\n\\n```\\n    public IList<string> FindAllRecipes(string[] recipes, IList<IList<string>> ingredients, string[] supplies) \\n    {\\n        // Create map of ingredient to recipes that contain it\\n        var ingredientToRecipesDict = new Dictionary<string, List<string>>();\\n        \\n        // We want to know how many ingredients each recipe depends on (indegree)\\n        var recipeDependencyCounts = new Dictionary<string, int>();\\n        \\n        for (int i = 0; i < recipes.Length; i++)\\n        {\\n            recipeDependencyCounts.Add(recipes[i], ingredients[i].Count);\\n            \\n            // Loop through the ingredients of each recipe\\n            for (int j = 0; j < ingredients[i].Count(); j++)\\n            {\\n                var ingredient = ingredients[i][j];\\n                if (!ingredientToRecipesDict.ContainsKey(ingredient))\\n                {\\n                    ingredientToRecipesDict.Add(ingredient, new List<string>());\\n                }\\n                \\n                ingredientToRecipesDict[ingredient].Add(recipes[i]);\\n            }\\n        }\\n        \\n        // Now use topological sort to build the list of possible recipes\\n        var possibleRecipes = new List<string>();\\n\\n        // The queue will contain \"available ingredients\"\\n        // Start by queueing all given supplies, then when any recipe is formed, queue the recipe since it has become an \"available ingredient\" for our other recipes\\n        var queue = new Queue<string>();\\n        foreach (var supply in supplies)\\n        {\\n            queue.Enqueue(supply);\\n        }\\n        \\n        while (queue.Any())\\n        {            \\n            var ingredient = queue.Dequeue();\\n            \\n            // Use the dict to get all dependent recipes of this ingredient\\n            if (!ingredientToRecipesDict.ContainsKey(ingredient))\\n            {\\n                // If no recipes depend on this ingredient, continue\\n                continue;\\n            }\\n            \\n            var dependentRecipes = ingredientToRecipesDict[ingredient];\\n            \\n            foreach (var recipe in dependentRecipes)\\n            {\\n                recipeDependencyCounts[recipe]--;\\n                if (recipeDependencyCounts[recipe] == 0)\\n                {\\n                    queue.Enqueue(recipe);\\n                    possibleRecipes.Add(recipe);\\n                }\\n            }\\n        }\\n        \\n        return possibleRecipes;\\n    }\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 1653908,
                "title": "two-ways-to-do-topological-sort",
                "content": "The first is the standard Kahn\\'s Algorithm:\\nPseudocode:\\n- Construct adjacency list graph and inDegrees array\\n- Create two arrays S and L both empty initially\\n- Put all nodes of `supplies` in S\\n- While S is not empty \\n\\t- Pop a node from S and insert in L\\n\\t- Traverse through adjacency list of this node and for each destination node in this adjacency list:\\n\\t  - Decrement `inDegree` of this destination node. This is equivalent to breaking an edge\\n\\t  - if `InDegree` is 0 then insert it into S\\n\\nNotice that at any point in the pseudocode, S consists of only nodes with zero `inDegree`.\\n\\n<iframe src=\"https://leetcode.com/playground/8NcX3sbt/shared\" frameBorder=\"0\" width=\"1000\" height=\"800\"></iframe>\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\nThe second is a cheat way to do topological sort in `O(n^2)` worse case time  complexity (You just keep traversing through the graph again and again till no new node is found). This should throw TLE in a proper contest/interview but surprisingly for me passed all the tests.\\n<iframe src=\"https://leetcode.com/playground/Eyhyenv8/shared\" frameBorder=\"0\" width=\"1000\" height=\"400\"></iframe>",
                "solutionTags": [
                    "Python",
                    "C",
                    "Topological Sort"
                ],
                "code": "The first is the standard Kahn\\'s Algorithm:\\nPseudocode:\\n- Construct adjacency list graph and inDegrees array\\n- Create two arrays S and L both empty initially\\n- Put all nodes of `supplies` in S\\n- While S is not empty \\n\\t- Pop a node from S and insert in L\\n\\t- Traverse through adjacency list of this node and for each destination node in this adjacency list:\\n\\t  - Decrement `inDegree` of this destination node. This is equivalent to breaking an edge\\n\\t  - if `InDegree` is 0 then insert it into S\\n\\nNotice that at any point in the pseudocode, S consists of only nodes with zero `inDegree`.\\n\\n<iframe src=\"https://leetcode.com/playground/8NcX3sbt/shared\" frameBorder=\"0\" width=\"1000\" height=\"800\"></iframe>\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\nThe second is a cheat way to do topological sort in `O(n^2)` worse case time  complexity (You just keep traversing through the graph again and again till no new node is found). This should throw TLE in a proper contest/interview but surprisingly for me passed all the tests.\\n<iframe src=\"https://leetcode.com/playground/Eyhyenv8/shared\" frameBorder=\"0\" width=\"1000\" height=\"400\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3408761,
                "title": "intuition-explained-c-kahn-s-algorithm-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s tricky to understand why graph and topological sort would be used! Look at the below representation for the following input:\\n```\\nrecipes = [\"bread\",\"sandwich\",\"burger\"]\\ningredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]]\\nsupplies = [\"yeast\",\"flour\",\"meat\"]\\n```\\n![image.png](https://assets.leetcode.com/users/images/a2161d85-bd2b-45bc-bd48-b4000b7e456d_1681300522.6122766.png)\\nHere, the edge is starting from the ingredient needed and ending at the recipe for which it\\'s needed. \\nNotice that the graph is directed, and cannot contain cycles as if flour is needed to make bread, it\\'s not possible that bread would be needed to make flour. Hence it is an directed acyclic graph (DAG). Topological sort is used when some step depends on completion of another step. \\n# Approach\\n- We first create a graph from given data. The ingredients would decide the edges between supplies and recipes.\\n- Also, store the indegree of nodes to track the number of incoming edges for each recipe.\\n- Then, perform a topological sort using BFS (Kahn\\'s Algorithm). First, push the independent nodes (with indegree=0) and then process the neighboring nodes by decreasing their indegree. If the indegree becomes 0, it means that the recipe is possible.\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n = recipes.size();\\n        \\n        // Create an adjacency list to represent the relationships between ingredients and recipes\\n        map<string, vector<string>> ingredientToRecipe;\\n        // Create a map to keep track of the number of incoming edges for each recipe\\n        map<string, int> incomingEdges;\\n        \\n        // Populate the adjacency list and incomingEdges map\\n        for(int i = 0; i < n; ++i){\\n            for(string ing: ingredients[i]){\\n                // Each ingredient is connected to the recipe it is a part of\\n                ingredientToRecipe[ing].push_back(recipes[i]);\\n                ++incomingEdges[recipes[i]];\\n            }\\n        }\\n        \\n        queue<string> q;\\n        vector<string> possibleRecipes;\\n        \\n        for(string supp: supplies){\\n            q.push(supp);\\n        }\\n        \\n        // Continue to process the queue until all possible recipes have been added to the possibleRecipes vector\\n        while(!q.empty()){\\n            // Get the next ingredient/supply to process\\n            string curr = q.front();\\n            q.pop();\\n            // If the incoming edges for a recipe reach 0, then it can be made with the given supplies\\n            for(string recipe : ingredientToRecipe[curr]){\\n                incomingEdges[recipe]--;\\n                if(incomingEdges[recipe] == 0) {\\n                    possibleRecipes.push_back(recipe);\\n                    // Add the recipe to the queue so that any additional ingredients it requires can be processed\\n                    q.push(recipe);\\n                }\\n            }\\n        }\\n        return possibleRecipes;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nrecipes = [\"bread\",\"sandwich\",\"burger\"]\\ningredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]]\\nsupplies = [\"yeast\",\"flour\",\"meat\"]\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n = recipes.size();\\n        \\n        // Create an adjacency list to represent the relationships between ingredients and recipes\\n        map<string, vector<string>> ingredientToRecipe;\\n        // Create a map to keep track of the number of incoming edges for each recipe\\n        map<string, int> incomingEdges;\\n        \\n        // Populate the adjacency list and incomingEdges map\\n        for(int i = 0; i < n; ++i){\\n            for(string ing: ingredients[i]){\\n                // Each ingredient is connected to the recipe it is a part of\\n                ingredientToRecipe[ing].push_back(recipes[i]);\\n                ++incomingEdges[recipes[i]];\\n            }\\n        }\\n        \\n        queue<string> q;\\n        vector<string> possibleRecipes;\\n        \\n        for(string supp: supplies){\\n            q.push(supp);\\n        }\\n        \\n        // Continue to process the queue until all possible recipes have been added to the possibleRecipes vector\\n        while(!q.empty()){\\n            // Get the next ingredient/supply to process\\n            string curr = q.front();\\n            q.pop();\\n            // If the incoming edges for a recipe reach 0, then it can be made with the given supplies\\n            for(string recipe : ingredientToRecipe[curr]){\\n                incomingEdges[recipe]--;\\n                if(incomingEdges[recipe] == 0) {\\n                    possibleRecipes.push_back(recipe);\\n                    // Add the recipe to the queue so that any additional ingredients it requires can be processed\\n                    q.push(recipe);\\n                }\\n            }\\n        }\\n        return possibleRecipes;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646616,
                "title": "c-easy-brute-force-unorder-set-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        unordered_set<string> ss(supplies.begin(),supplies.end());\\n        bool f=true;\\n        int n=recipes.size();\\n        vector<int> vis(n,false);\\n        vector<string> res;\\n        while(f){\\n            f=false;\\n            for(int i=0;i<n;i++){\\n                if(vis[i]) continue;\\n                bool t=true;\\n                for(string &s:ingredients[i]){\\n                    if(ss.find(s)==ss.end()){\\n                        t=false;\\n                        break;\\n                    }\\n                }\\n                if(t){\\n                    f=true;\\n                    ss.insert(recipes[i]);\\n                    vis[i]=true;\\n                    res.push_back(recipes[i]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        unordered_set<string> ss(supplies.begin(),supplies.end());\\n        bool f=true;\\n        int n=recipes.size();\\n        vector<int> vis(n,false);\\n        vector<string> res;\\n        while(f){\\n            f=false;\\n            for(int i=0;i<n;i++){\\n                if(vis[i]) continue;\\n                bool t=true;\\n                for(string &s:ingredients[i]){\\n                    if(ss.find(s)==ss.end()){\\n                        t=false;\\n                        break;\\n                    }\\n                }\\n                if(t){\\n                    f=true;\\n                    ss.insert(recipes[i]);\\n                    vis[i]=true;\\n                    res.push_back(recipes[i]);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440881,
                "title": "c-dfs-using-maps",
                "content": "\\n    // Cookable maps if the recipe is achievable by either cooking or supplies\\n    unordered_map<string,bool> cookable;\\n    // adj is the adjancy matrix for the recipies->ingredients\\n    unordered_map<string, vector<string>> adj;\\n    // visited map for checking if we have already visited that ingredient/recipe\\n    unordered_map<string,bool> visited;\\n    \\n    // DFS function\\n    bool dfs(string node)\\n    {\\n        // if we have aready processed a recipe/ingredient return its cookable\\n        if(visited[node]) return cookable[node];\\n        \\n        visited[node]= true;\\n        \\n        // if the recipe/ingredient can be prepared/ in supplies return its cookable\\n        if(cookable.find(node)!=cookable.end())\\n            return cookable[node];\\n        \\n        // if the recipe/ingredient cant be prepared and if it isn\\'t dependant on any other\\n        // recipe/ingredient, we cant prepare that dish.\\n        if(adj[node].size()==0) \\n            return cookable[node]=false; \\n        \\n        //traverse all the ingredients for that dish\\n        for(auto i: adj[node])\\n            \\n            // if any ingredient cant be prepared we cant cook the dish\\n            if(!dfs(i))\\n                 return cookable[node]=false;\\n        \\n        //if none of the above condition satisfied we can cook the dish\\n        return cookable[node]=true;\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n       \\n        int n=recipes.size();\\n        \\n        for(int i=0;i<n;i++)\\n            for(auto j: ingredients[i])\\n                adj[recipes[i]].push_back(j);\\n        \\n        // mark the supplies as cookable\\n        for(auto i:supplies) \\n            cookable[i]=true;\\n        \\n        vector<string> ans;\\n        for(int i=0;i<n;i++)\\n        // if any recipe is cookable we insert it into our ans vector\\n            if(dfs(recipes[i])) \\n                ans.push_back(recipes[i]);\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "\\n    // Cookable maps if the recipe is achievable by either cooking or supplies\\n    unordered_map<string,bool> cookable;\\n    // adj is the adjancy matrix for the recipies->ingredients\\n    unordered_map<string, vector<string>> adj;\\n    // visited map for checking if we have already visited that ingredient/recipe\\n    unordered_map<string,bool> visited;\\n    \\n    // DFS function\\n    bool dfs(string node)\\n    {\\n        // if we have aready processed a recipe/ingredient return its cookable\\n        if(visited[node]) return cookable[node];\\n        \\n        visited[node]= true;\\n        \\n        // if the recipe/ingredient can be prepared/ in supplies return its cookable\\n        if(cookable.find(node)!=cookable.end())\\n            return cookable[node];\\n        \\n        // if the recipe/ingredient cant be prepared and if it isn\\'t dependant on any other\\n        // recipe/ingredient, we cant prepare that dish.\\n        if(adj[node].size()==0) \\n            return cookable[node]=false; \\n        \\n        //traverse all the ingredients for that dish\\n        for(auto i: adj[node])\\n            \\n            // if any ingredient cant be prepared we cant cook the dish\\n            if(!dfs(i))\\n                 return cookable[node]=false;\\n        \\n        //if none of the above condition satisfied we can cook the dish\\n        return cookable[node]=true;\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n       \\n        int n=recipes.size();\\n        \\n        for(int i=0;i<n;i++)\\n            for(auto j: ingredients[i])\\n                adj[recipes[i]].push_back(j);\\n        \\n        // mark the supplies as cookable\\n        for(auto i:supplies) \\n            cookable[i]=true;\\n        \\n        vector<string> ans;\\n        for(int i=0;i<n;i++)\\n        // if any recipe is cookable we insert it into our ans vector\\n            if(dfs(recipes[i])) \\n                ans.push_back(recipes[i]);\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2308740,
                "title": "python-topological-sort",
                "content": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        # initialize data structures + result list\\n        in_degrees = collections.defaultdict(int)\\n        graph = collections.defaultdict(list)\\n        queue = collections.deque()\\n        result = []\\n        \\n        # supplies are our sources - no in degrees\\n        for supply in supplies:\\n            in_degrees[supply] = 0\\n            # because supplies are our sources to start, add to queue\\n            queue.append(supply)\\n        \\n        \\n        # add recipes/ingredients\\n        for i, recipe in enumerate(recipes):\\n            for ingredient in ingredients[i]:\\n                graph[ingredient].append(recipe)\\n                in_degrees[recipe] += 1\\n        \\n        # queue starts off with supplies(our sources with no in degrees)\\n        # we pop off from queue and check if it is a recipe\\n        # if it is, this means we can create it so add to our result\\n        # we remove the edges going into other neighbors since we are done processing\\n        # if the neighbor has no in degrees(no incoming edges) it becomes a source and we add to queue\\n        while queue:\\n            node = queue.popleft()\\n            # check if this is a recipe - if it is we can make it\\n            if node in recipes:\\n                result.append(node)\\n            \\n            for neighbor in graph[node]:\\n                in_degrees[neighbor] -= 1\\n                if in_degrees[neighbor] == 0:\\n                    queue.append(neighbor)\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        # initialize data structures + result list\\n        in_degrees = collections.defaultdict(int)\\n        graph = collections.defaultdict(list)\\n        queue = collections.deque()\\n        result = []\\n        \\n        # supplies are our sources - no in degrees\\n        for supply in supplies:\\n            in_degrees[supply] = 0\\n            # because supplies are our sources to start, add to queue\\n            queue.append(supply)\\n        \\n        \\n        # add recipes/ingredients\\n        for i, recipe in enumerate(recipes):\\n            for ingredient in ingredients[i]:\\n                graph[ingredient].append(recipe)\\n                in_degrees[recipe] += 1\\n        \\n        # queue starts off with supplies(our sources with no in degrees)\\n        # we pop off from queue and check if it is a recipe\\n        # if it is, this means we can create it so add to our result\\n        # we remove the edges going into other neighbors since we are done processing\\n        # if the neighbor has no in degrees(no incoming edges) it becomes a source and we add to queue\\n        while queue:\\n            node = queue.popleft()\\n            # check if this is a recipe - if it is we can make it\\n            if node in recipes:\\n                result.append(node)\\n            \\n            for neighbor in graph[node]:\\n                in_degrees[neighbor] -= 1\\n                if in_degrees[neighbor] == 0:\\n                    queue.append(neighbor)\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648478,
                "title": "c-graph-based-topo-sort",
                "content": "**PLEASE UPVOTE IF U FIND MY SOLUTION AND EXPLANATION HELPFUL.**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& r, vector<vector<string>>& in, vector<string>& s) {\\n        \\n        //map for storing the indegree of a given node in the graph\\n        unordered_map<string,int>indegree;\\n        //map for creating the graph\\n        unordered_map<string,vector<string>>graph;\\n        //vector for storing the result\\n        vector<string>res;\\n        //hashset for storing the required items\\n        unordered_set<string>ss;\\n        \\n        //store all required items in the ss hashset\\n        for(auto &x:r)ss.insert(x);\\n        \\n        //creation of graph \\n        //here we store in a way where ingredients point to the node which is made out of those ingredients\\n        //eg.:\\n        //for tc1: yeast---->bread<----flour    corn\\n        \\n        for(int i=0;i<r.size();i++)\\n        {\\n            for(int j=0;j<in[i].size();j++)\\n            {\\n                graph[in[i][j]].push_back(r[i]);\\n                indegree[r[i]]++;//we increment the indegree as required\\n            }\\n        }\\n        \\n        //we perform a bfs traversal(in particular the toposort algorithm)\\n        //we push the items which has indegree 0 (the supplies)\\n        queue<string>q;\\n        for(auto &x:s)\\n        q.push(x);\\n        \\n        while(!q.empty())\\n        {\\n            string curr=q.front();q.pop();\\n            \\n            //if the current item is among the required then we push that item into the res vector(ans)\\n            if(ss.count(curr))\\n            {\\n                res.push_back(curr);\\n            }\\n            \\n            //if we have a singular node which points to nothing then we continue\\n            //in tc1 \"corn\" is such a node\\n            if(!graph.count(curr))continue;\\n            \\n            //we traverse all the nodes from the current node and push the node in the queue only when its indegree \\n            //becomes zero as we are sure that all ingredients required to make the item is already traversed\\n            //and hence the required item can be made using the supplies.\\n            for(auto &x:graph[curr])\\n            {\\n                indegree[x]--;\\n                if(indegree[x]==0)q.push(x);\\n            }\\n        }\\n        \\n        //return the result vector\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& r, vector<vector<string>>& in, vector<string>& s) {\\n        \\n        //map for storing the indegree of a given node in the graph\\n        unordered_map<string,int>indegree;\\n        //map for creating the graph\\n        unordered_map<string,vector<string>>graph;\\n        //vector for storing the result\\n        vector<string>res;\\n        //hashset for storing the required items\\n        unordered_set<string>ss;\\n        \\n        //store all required items in the ss hashset\\n        for(auto &x:r)ss.insert(x);\\n        \\n        //creation of graph \\n        //here we store in a way where ingredients point to the node which is made out of those ingredients\\n        //eg.:\\n        //for tc1: yeast---->bread<----flour    corn\\n        \\n        for(int i=0;i<r.size();i++)\\n        {\\n            for(int j=0;j<in[i].size();j++)\\n            {\\n                graph[in[i][j]].push_back(r[i]);\\n                indegree[r[i]]++;//we increment the indegree as required\\n            }\\n        }\\n        \\n        //we perform a bfs traversal(in particular the toposort algorithm)\\n        //we push the items which has indegree 0 (the supplies)\\n        queue<string>q;\\n        for(auto &x:s)\\n        q.push(x);\\n        \\n        while(!q.empty())\\n        {\\n            string curr=q.front();q.pop();\\n            \\n            //if the current item is among the required then we push that item into the res vector(ans)\\n            if(ss.count(curr))\\n            {\\n                res.push_back(curr);\\n            }\\n            \\n            //if we have a singular node which points to nothing then we continue\\n            //in tc1 \"corn\" is such a node\\n            if(!graph.count(curr))continue;\\n            \\n            //we traverse all the nodes from the current node and push the node in the queue only when its indegree \\n            //becomes zero as we are sure that all ingredients required to make the item is already traversed\\n            //and hence the required item can be made using the supplies.\\n            for(auto &x:graph[curr])\\n            {\\n                indegree[x]--;\\n                if(indegree[x]==0)q.push(x);\\n            }\\n        }\\n        \\n        //return the result vector\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859776,
                "title": "python3-topological-sort-simple-solution",
                "content": "# Intuition\\nSome Recipe depends on some other Recipe that is cooked before -> Sound very similar to course schedule -> Topological sort\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(N * M)$$ with N is the number of recipes, M is number of ingredients/recipes requires for each recipes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(M * N + S)$$ with N is the number of recipes, M is number of ingredients/recipes requires for each recipes and S is number of supplies\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        not_supplied_needs = collections.Counter()\\n        ingredients_needs = collections.defaultdict(list)\\n        supplies_set = set(supplies)\\n\\n        for i in range(len(recipes)):\\n            recipe = recipes[i]\\n            for ingredient in ingredients[i]:\\n                if ingredient not in supplies:\\n                    not_supplied_needs[recipe] += 1\\n                    ingredients_needs[ingredient].append(recipe)\\n        \\n\\n        q = collections.deque()\\n        for recipe in recipes:\\n            if not_supplied_needs[recipe] == 0: q.append(recipe)\\n\\n        res = []\\n        while q:\\n            recipe = q.popleft()\\n            res.append(recipe)\\n            for new_recipe in ingredients_needs[recipe]:\\n                not_supplied_needs[new_recipe] -= 1\\n                if not_supplied_needs[new_recipe] == 0: q.append(new_recipe)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        not_supplied_needs = collections.Counter()\\n        ingredients_needs = collections.defaultdict(list)\\n        supplies_set = set(supplies)\\n\\n        for i in range(len(recipes)):\\n            recipe = recipes[i]\\n            for ingredient in ingredients[i]:\\n                if ingredient not in supplies:\\n                    not_supplied_needs[recipe] += 1\\n                    ingredients_needs[ingredient].append(recipe)\\n        \\n\\n        q = collections.deque()\\n        for recipe in recipes:\\n            if not_supplied_needs[recipe] == 0: q.append(recipe)\\n\\n        res = []\\n        while q:\\n            recipe = q.popleft()\\n            res.append(recipe)\\n            for new_recipe in ingredients_needs[recipe]:\\n                not_supplied_needs[new_recipe] -= 1\\n                if not_supplied_needs[new_recipe] == 0: q.append(new_recipe)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510704,
                "title": "easy-to-understand-java-solution-using-dfs",
                "content": "```\\n\\tprivate static int UNKNOWN = 0;\\n    private static int CAN_BE_COOKED = 1;\\n    private static int COOKING_IN_PROGRESS = 2;\\n\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, Integer> recipeStatus = new HashMap<>();\\n        Map<String, List<String>> preRequisites = new HashMap<>();\\n\\n        for (int i = 0; i < recipes.length; i++) {\\n            recipeStatus.put(recipes[i], UNKNOWN);\\n            preRequisites.put(recipes[i], ingredients.get(i));\\n        }\\n        for (String supply : supplies) {\\n            recipeStatus.put(supply, CAN_BE_COOKED);\\n        }\\n\\n        List<String> result = new ArrayList<>();\\n        for (String recipe : recipes) {\\n            findIfRecipeCanBeCookedUSingDFS(recipe, recipeStatus, preRequisites, result);\\n        }\\n        return result;\\n    }\\n\\n    public boolean findIfRecipeCanBeCookedUSingDFS(String recipe, Map<String, Integer> recipeStatus, Map<String, List<String>> preRequisites, List<String> result) {\\n        if (!recipeStatus.containsKey(recipe)) {\\n            return false;\\n        }\\n        if (recipeStatus.get(recipe) == COOKING_IN_PROGRESS) {\\n            return false;\\n        }\\n        if (recipeStatus.get(recipe) == CAN_BE_COOKED) {\\n            return true;\\n        }\\n        recipeStatus.put(recipe, COOKING_IN_PROGRESS);\\n        for (String ingredient : preRequisites.get(recipe)) {\\n            if (!findIfRecipeCanBeCookedUSingDFS(ingredient, recipeStatus, preRequisites, result)) {\\n                return false;\\n            }\\n        }\\n        recipeStatus.put(recipe, CAN_BE_COOKED);\\n        result.add(recipe);\\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n\\tprivate static int UNKNOWN = 0;\\n    private static int CAN_BE_COOKED = 1;\\n    private static int COOKING_IN_PROGRESS = 2;\\n\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, Integer> recipeStatus = new HashMap<>();\\n        Map<String, List<String>> preRequisites = new HashMap<>();\\n\\n        for (int i = 0; i < recipes.length; i++) {\\n            recipeStatus.put(recipes[i], UNKNOWN);\\n            preRequisites.put(recipes[i], ingredients.get(i));\\n        }\\n        for (String supply : supplies) {\\n            recipeStatus.put(supply, CAN_BE_COOKED);\\n        }\\n\\n        List<String> result = new ArrayList<>();\\n        for (String recipe : recipes) {\\n            findIfRecipeCanBeCookedUSingDFS(recipe, recipeStatus, preRequisites, result);\\n        }\\n        return result;\\n    }\\n\\n    public boolean findIfRecipeCanBeCookedUSingDFS(String recipe, Map<String, Integer> recipeStatus, Map<String, List<String>> preRequisites, List<String> result) {\\n        if (!recipeStatus.containsKey(recipe)) {\\n            return false;\\n        }\\n        if (recipeStatus.get(recipe) == COOKING_IN_PROGRESS) {\\n            return false;\\n        }\\n        if (recipeStatus.get(recipe) == CAN_BE_COOKED) {\\n            return true;\\n        }\\n        recipeStatus.put(recipe, COOKING_IN_PROGRESS);\\n        for (String ingredient : preRequisites.get(recipe)) {\\n            if (!findIfRecipeCanBeCookedUSingDFS(ingredient, recipeStatus, preRequisites, result)) {\\n                return false;\\n            }\\n        }\\n        recipeStatus.put(recipe, CAN_BE_COOKED);\\n        result.add(recipe);\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2393720,
                "title": "c-simple-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        map<string, vector<string>> mp;\\n        map<string, int>indegree;\\n        \\n        for(int i=0;i<ingredients.size();i++) {\\n            for(auto &item : ingredients[i]) {\\n                mp[item].push_back(recipes[i]);\\n                indegree[recipes[i]]++;\\n            }\\n        }\\n        \\n        queue<string> q;\\n        for(auto x : supplies)\\n            if(indegree[x]==0)\\n                q.push(x);\\n        \\n        while(!q.empty())\\n        {\\n            string node = q.front();\\n            q.pop();\\n            \\n            for(auto &nei : mp[node])\\n            {\\n                indegree[nei]--;\\n                if(indegree[nei]==0)\\n                    q.push(nei);\\n            }\\n        }\\n        \\n        vector<string> ans;\\n        for(auto &x : recipes)\\n            if(indegree[x]==0)\\n                ans.push_back(x);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        map<string, vector<string>> mp;\\n        map<string, int>indegree;\\n        \\n        for(int i=0;i<ingredients.size();i++) {\\n            for(auto &item : ingredients[i]) {\\n                mp[item].push_back(recipes[i]);\\n                indegree[recipes[i]]++;\\n            }\\n        }\\n        \\n        queue<string> q;\\n        for(auto x : supplies)\\n            if(indegree[x]==0)\\n                q.push(x);\\n        \\n        while(!q.empty())\\n        {\\n            string node = q.front();\\n            q.pop();\\n            \\n            for(auto &nei : mp[node])\\n            {\\n                indegree[nei]--;\\n                if(indegree[nei]==0)\\n                    q.push(nei);\\n            }\\n        }\\n        \\n        vector<string> ans;\\n        for(auto &x : recipes)\\n            if(indegree[x]==0)\\n                ans.push_back(x);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139213,
                "title": "python-dfs-solution",
                "content": "```\\ndef find_all_recipes(recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n\\tsupplies = set(supplies)\\n\\tgraph = {}\\n\\tvisited = set()\\n\\tres = []\\n\\n\\tfor recipe, ingredient in zip(recipes, ingredients):\\n\\t\\tgraph[recipe] = ingredient\\n\\n\\tdef dfs(node: str) -> bool:\\n\\t\\tif node in visited:\\n\\t\\t\\treturn False\\n\\n\\t\\tvisited.add(node)\\n\\n\\t\\tif node not in graph:\\n\\t\\t\\treturn False\\n\\n\\t\\tfor dependency in graph[node]:\\n\\t\\t\\t# if ingredient of recipe exist in supplies, it\\'s good to go\\n\\t\\t\\t# if ingredient of recipe doesn\\'t exist in supplies, then use dfs to check if\\n\\t\\t\\t# it hasn\\'t been used(visited) and exist on graph means it comes from another recipies then good to go\\n\\t\\t\\t# if ingredient of recipe doesn\\'t exist and ( already used (visited) or doesn\\'t come from another recipes then \\n\\t\\t\\t# we need to return false since we don\\'t have enough ingredient to follow current recipe\\n\\t\\t\\tif dependency not in supplies and not dfs(dependency):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\tres.append(node)\\n\\t\\tsupplies.add(node)\\n\\t\\treturn True\\n\\n\\tfor recipe in recipes:\\n\\t\\tdfs(recipe)\\n\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\ndef find_all_recipes(recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n\\tsupplies = set(supplies)\\n\\tgraph = {}\\n\\tvisited = set()\\n\\tres = []\\n\\n\\tfor recipe, ingredient in zip(recipes, ingredients):\\n\\t\\tgraph[recipe] = ingredient\\n\\n\\tdef dfs(node: str) -> bool:\\n\\t\\tif node in visited:\\n\\t\\t\\treturn False\\n\\n\\t\\tvisited.add(node)\\n\\n\\t\\tif node not in graph:\\n\\t\\t\\treturn False\\n\\n\\t\\tfor dependency in graph[node]:\\n\\t\\t\\t# if ingredient of recipe exist in supplies, it\\'s good to go\\n\\t\\t\\t# if ingredient of recipe doesn\\'t exist in supplies, then use dfs to check if\\n\\t\\t\\t# it hasn\\'t been used(visited) and exist on graph means it comes from another recipies then good to go\\n\\t\\t\\t# if ingredient of recipe doesn\\'t exist and ( already used (visited) or doesn\\'t come from another recipes then \\n\\t\\t\\t# we need to return false since we don\\'t have enough ingredient to follow current recipe\\n\\t\\t\\tif dependency not in supplies and not dfs(dependency):\\n\\t\\t\\t\\treturn False\\n\\n\\t\\tres.append(node)\\n\\t\\tsupplies.add(node)\\n\\t\\treturn True\\n\\n\\tfor recipe in recipes:\\n\\t\\tdfs(recipe)\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2128803,
                "title": "bfs-easy-java",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashMap<String,LinkedList<String>> map = new HashMap<>();\\n        HashMap<String,Integer> indegree = new HashMap<>();\\n        for(int i = 0;i<recipes.length;i++){\\n            for(int j = 0;j<ingredients.get(i).size();j++){\\n                String s = ingredients.get(i).get(j);\\n                if (map.containsKey(s)) {\\n                    LinkedList<String> a = map.get(s);\\n                    a.add(recipes[i]);\\n                    map.put(s,a);\\n                }\\n                else{\\n                    LinkedList<String> a  = new LinkedList<>();\\n                    a.add(recipes[i]);\\n                    map.put(s,a);\\n                }\\n                indegree.put(recipes[i],indegree.getOrDefault(recipes[i],0)+1);\\n                \\n            }\\n        }\\n        Queue<String> q = new LinkedList<>();\\n        List<String> res = new LinkedList<>();\\n        for(String str : supplies){\\n            q.add(str);\\n        }\\n        while(!q.isEmpty()){\\n            String cur = q.poll();\\n            if(!map.containsKey(cur)) continue;\\n            LinkedList<String> r = map.get(cur);\\n            for(int i = 0;i<r.size();i++){\\n                indegree.put(r.get(i),indegree.get(r.get(i))-1);\\n                if(indegree.get(r.get(i))==0) {\\n                    res.add(r.get(i));\\n                    if(map.containsKey(r.get(i))) q.offer(r.get(i));\\n                }\\n                \\n            }\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashMap<String,LinkedList<String>> map = new HashMap<>();\\n        HashMap<String,Integer> indegree = new HashMap<>();\\n        for(int i = 0;i<recipes.length;i++){\\n            for(int j = 0;j<ingredients.get(i).size();j++){\\n                String s = ingredients.get(i).get(j);\\n                if (map.containsKey(s)) {\\n                    LinkedList<String> a = map.get(s);\\n                    a.add(recipes[i]);\\n                    map.put(s,a);\\n                }\\n                else{\\n                    LinkedList<String> a  = new LinkedList<>();\\n                    a.add(recipes[i]);\\n                    map.put(s,a);\\n                }\\n                indegree.put(recipes[i],indegree.getOrDefault(recipes[i],0)+1);\\n                \\n            }\\n        }\\n        Queue<String> q = new LinkedList<>();\\n        List<String> res = new LinkedList<>();\\n        for(String str : supplies){\\n            q.add(str);\\n        }\\n        while(!q.isEmpty()){\\n            String cur = q.poll();\\n            if(!map.containsKey(cur)) continue;\\n            LinkedList<String> r = map.get(cur);\\n            for(int i = 0;i<r.size();i++){\\n                indegree.put(r.get(i),indegree.get(r.get(i))-1);\\n                if(indegree.get(r.get(i))==0) {\\n                    res.add(r.get(i));\\n                    if(map.containsKey(r.get(i))) q.offer(r.get(i));\\n                }\\n                \\n            }\\n            \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050480,
                "title": "easy-js-solution-using-hashmap-hashset",
                "content": "```\\nconst findAllRecipes = function (recipes, ingredients, supplies) {\\n\\tconst suppliesSet = new Set(supplies),\\n\\t\\tres = [],\\n\\t\\trecipesMap = new Map(),\\n\\t\\tcantMake = new Set();\\n    // Reverse map all recipes\\n\\tfor (let i = 0; i < recipes.length; i++)\\n        recipesMap.set(recipes[i], i);\\n    \\n    // Check if we can make the given food name\\n\\tconst canMake = (name, visited = new Set()) => {\\n\\t\\tif (suppliesSet.has(name)) return true;\\n\\t\\tif (!recipesMap.has(name) || cantMake.has(name) || visited.has(name))\\n\\t\\t\\treturn false;\\n        // We can\\'t make it using our current supplies, find its recipe\\n\\t\\tconst idx = recipesMap.get(name);\\n\\t\\tvisited.add(name); // Prevent loops\\n\\t\\tfor (let i = 0; i < ingredients[idx].length; i++) {\\n\\t\\t\\tconst ingredient = ingredients[idx][i];\\n\\t\\t\\tif (!canMake(ingredient, visited)) {\\n\\t\\t\\t\\tcantMake.add(name);\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n        // Add the food to our list of supplies\\n\\t\\tsuppliesSet.add(name);\\n\\t\\treturn true;\\n\\t};\\n\\tfor (let i = 0; i < recipes.length; i++)\\n\\t\\tif (canMake(recipes[i])) res.push(recipes[i]);\\n\\treturn res;\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst findAllRecipes = function (recipes, ingredients, supplies) {\\n\\tconst suppliesSet = new Set(supplies),\\n\\t\\tres = [],\\n\\t\\trecipesMap = new Map(),\\n\\t\\tcantMake = new Set();\\n    // Reverse map all recipes\\n\\tfor (let i = 0; i < recipes.length; i++)\\n        recipesMap.set(recipes[i], i);\\n    \\n    // Check if we can make the given food name\\n\\tconst canMake = (name, visited = new Set()) => {\\n\\t\\tif (suppliesSet.has(name)) return true;\\n\\t\\tif (!recipesMap.has(name) || cantMake.has(name) || visited.has(name))\\n\\t\\t\\treturn false;\\n        // We can\\'t make it using our current supplies, find its recipe\\n\\t\\tconst idx = recipesMap.get(name);\\n\\t\\tvisited.add(name); // Prevent loops\\n\\t\\tfor (let i = 0; i < ingredients[idx].length; i++) {\\n\\t\\t\\tconst ingredient = ingredients[idx][i];\\n\\t\\t\\tif (!canMake(ingredient, visited)) {\\n\\t\\t\\t\\tcantMake.add(name);\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n        // Add the food to our list of supplies\\n\\t\\tsuppliesSet.add(name);\\n\\t\\treturn true;\\n\\t};\\n\\tfor (let i = 0; i < recipes.length; i++)\\n\\t\\tif (canMake(recipes[i])) res.push(recipes[i]);\\n\\treturn res;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1717981,
                "title": "java-using-kahns-algorithm-bfs-topological-sort",
                "content": "class Solution {\\n    public List<String> BFS(HashMap<String,Integer> inDegree, HashMap<String,List<String>> graph,String []supplies){\\n        \\n        Queue<String> que = new LinkedList<>();\\n        \\n        for(int i=0;i<supplies.length;i++){\\n            que.add(supplies[i]);\\n        }\\n        \\n        List<String> ans = new ArrayList<>();\\n        while(que.size() != 0){\\n            int size = que.size();\\n            while(size-->0){\\n                \\n                String s = que.remove();\\n                List<String> list = graph.getOrDefault(s,new ArrayList<>());\\n                \\n                for(String str : list){\\n                    \\n                    inDegree.put(str,inDegree.get(str) - 1);\\n                    if(inDegree.get(str) == 0) {  \\n    \\n                          que.add(str);\\n                          ans.add(str);\\n                        }\\n                    }  \\n                }\\n            }\\n        return ans;\\n    }\\n    public void makeGraph(HashMap<String,List<String>> graph,String[] recipes, List<List<String>> ingredients){\\n         \\n         for(int i=0;i<ingredients.size();i++){\\n            List<String> list = ingredients.get(i);\\n            for(String str : list){\\n                \\n                if(!graph.containsKey(str)){\\n                    graph.put(str,new ArrayList<>());\\n                }\\n                List<String> l = graph.get(str);\\n                l.add(recipes[i]);\\n                graph.put(str,l);\\n            }\\n        }\\n    }\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        \\n        HashMap<String,List<String>> graph = new HashMap<>();\\n        makeGraph(graph,recipes,ingredients);\\n        \\n        HashMap<String,Integer> inDegree = new HashMap<>();\\n        \\n        Set<String> Keys = graph.keySet();\\n        \\n        for(String Key : Keys){\\n            \\n            List<String> list = graph.get(Key);\\n            for(String s : list){\\n                inDegree.put(s,inDegree.getOrDefault(s,0) + 1);\\n            }\\n        }\\n        \\n        \\n        return BFS(inDegree,graph,supplies);\\n        \\n        \\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> BFS(HashMap<String,Integer> inDegree, HashMap<String,List<String>> graph,String []supplies){\\n        \\n        Queue<String> que = new LinkedList<>();\\n        \\n        for(int i=0;i<supplies.length;i++){\\n            que.add(supplies[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1646960,
                "title": "java-dfs-with-circle-detection",
                "content": "The tricky part of the problem is that there are possibily circles in the graph of recipes. Fot all those nodes in the circles, they cannot be created and thus need to be excluded from the result. To avoid infinity loop, the status of each node needs to be carefully recorded, which is shown as follows:\\n\\n* \\t0 : unvisited;\\n* \\t1 : has been visited in current search (if visited again, a circle is detected);\\n* \\t2 : valid;\\n* \\t-1 : invalid.\\n\\n\\n```\\nclass Solution {\\n    private HashSet<String> supplySet;\\n    private HashSet<String> recipeSet;\\n    private int[] status;\\n    \\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        supplySet = new HashSet<>(Arrays.asList(supplies));\\n        recipeSet = new HashSet<>(Arrays.asList(recipes));\\n        status = new int[recipes.length];\\n        \\n        for(int i = 0; i < recipes.length; i++){\\n            dfs(i, recipes, ingredients);\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        for(int i = 0; i < recipes.length; i++){\\n            if(status[i] == 2)\\n                result.add(recipes[i]);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private boolean dfs(int t, String[] recipes,\\n                       List<List<String>> ingredients){\\n        String target = recipes[t];\\n        \\n        if(status[t] == -1)\\n            return false;\\n        else if(status[t] == 1){\\n            status[t] = -1;\\n            return false;\\n        } else if(status[t] == 2)\\n            return true;\\n        \\n        status[t] = 1;\\n        \\n        for(String item : ingredients.get(t)){\\n            if(supplySet.contains(item))\\n                continue;\\n            \\n            else if(recipeSet.contains(item)){\\n                for(int i = 0; i < recipes.length; i++){\\n                    if(recipes[i].equals(item)){\\n                        if(!dfs(i, recipes, ingredients)){\\n                            status[t] = -1;\\n                            return false;\\n                        }\\n                    }\\n                }\\n            } \\n            \\n            else {\\n                status[t] = -1;\\n                return false;\\n            }\\n        }\\n        \\n        status[t] = 2;\\n        return true;\\n    }\\n}\\n\\xB7\\xB7\\xB7",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    private HashSet<String> supplySet;\\n    private HashSet<String> recipeSet;\\n    private int[] status;\\n    \\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        supplySet = new HashSet<>(Arrays.asList(supplies));\\n        recipeSet = new HashSet<>(Arrays.asList(recipes));\\n        status = new int[recipes.length];\\n        \\n        for(int i = 0; i < recipes.length; i++){\\n            dfs(i, recipes, ingredients);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3923453,
                "title": "python-easy-solution-with-explanation-beginner-friendly-kahn-s-algorithm",
                "content": "# Approach\\nUsing Kahn\\'s Algorithm / Topological Sort\\n# Video Explanation\\nhttps://youtu.be/jsSq5_h-6vE\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        # indegree = {\"bread\" : 2}\\n        indegree = defaultdict(int)\\n        # graph = {\"flour\" : [\"bread\", \" \", \"\"]}\\n        graph = defaultdict(list)\\n        for recipe, ing in zip(recipes, ingredients):\\n            for i in ing:\\n                indegree[recipe] += 1\\n                graph[i].append(recipe)\\n        \\n        answer = []\\n        queue = deque(supplies)\\n        recipes = set(recipes)\\n        while queue:\\n            x = queue.popleft()\\n            if x in recipes:\\n                answer.append(x)\\n            for i in graph[x]:\\n                indegree[i] -= 1\\n                if indegree[i] == 0:\\n                    queue.append(i)\\n        return answer\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        # indegree = {\"bread\" : 2}\\n        indegree = defaultdict(int)\\n        # graph = {\"flour\" : [\"bread\", \" \", \"\"]}\\n        graph = defaultdict(list)\\n        for recipe, ing in zip(recipes, ingredients):\\n            for i in ing:\\n                indegree[recipe] += 1\\n                graph[i].append(recipe)\\n        \\n        answer = []\\n        queue = deque(supplies)\\n        recipes = set(recipes)\\n        while queue:\\n            x = queue.popleft()\\n            if x in recipes:\\n                answer.append(x)\\n            for i in graph[x]:\\n                indegree[i] -= 1\\n                if indegree[i] == 0:\\n                    queue.append(i)\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557583,
                "title": "c-easy-to-understand-topo-sort",
                "content": "# Intuition\\nTopological Sort\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int numberOfRecipes = recipes.size();\\n        vector<string> result;\\n        unordered_map<string,vector<string>> adj;\\n        for(int i=0;i<ingredients.size();i++){\\n            for(int j=0;j<ingredients[i].size();j++){\\n                adj[ingredients[i][j]].push_back(recipes[i]);\\n            }\\n        }\\n        unordered_map<string,int> inDegree;\\n        for(int i=0;i<recipes.size();i++){\\n            inDegree[recipes[i]] = ingredients[i].size();\\n        }\\n        queue<string>q;\\n        for(int i=0;i<supplies.size();i++){\\n            q.push(supplies[i]);\\n        }\\n        while(!q.empty()){\\n            string currentSupply = q.front();\\n            q.pop();\\n            vector<string> recipesThatCanBeMade = adj[currentSupply];\\n            for(int i=0;i<recipesThatCanBeMade.size();i++){\\n                inDegree[recipesThatCanBeMade[i]]--;\\n                if(inDegree[recipesThatCanBeMade[i]]==0){\\n                    q.push(recipesThatCanBeMade[i]);\\n                    result.push_back(recipesThatCanBeMade[i]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int numberOfRecipes = recipes.size();\\n        vector<string> result;\\n        unordered_map<string,vector<string>> adj;\\n        for(int i=0;i<ingredients.size();i++){\\n            for(int j=0;j<ingredients[i].size();j++){\\n                adj[ingredients[i][j]].push_back(recipes[i]);\\n            }\\n        }\\n        unordered_map<string,int> inDegree;\\n        for(int i=0;i<recipes.size();i++){\\n            inDegree[recipes[i]] = ingredients[i].size();\\n        }\\n        queue<string>q;\\n        for(int i=0;i<supplies.size();i++){\\n            q.push(supplies[i]);\\n        }\\n        while(!q.empty()){\\n            string currentSupply = q.front();\\n            q.pop();\\n            vector<string> recipesThatCanBeMade = adj[currentSupply];\\n            for(int i=0;i<recipesThatCanBeMade.size();i++){\\n                inDegree[recipesThatCanBeMade[i]]--;\\n                if(inDegree[recipesThatCanBeMade[i]]==0){\\n                    q.push(recipesThatCanBeMade[i]);\\n                    result.push_back(recipesThatCanBeMade[i]);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418392,
                "title": "topological-python-explained",
                "content": "# Intuition\\ntreat this problem as one of the standard topological problem finding ancestors.\\nWhere if you can create the parent then u can create the child recipe too.\\nNow the trick of the problem is to curate the graph.\\n`1. Think of it as what can be the parents? The ingredients required to make a recipe.`\\n`2. And how to get indegrees? If a ingredient required to make a recipe isnt available in supplies then its dependent on the parent i.e if u cannot make parent the child cant be prepared.`\\n\\nNow solve it as topological\\nif indegrees[recipe] == 0 #it can be made as all the items required are available/ created before\\neg -> \\n1. bread -> yeast (already available)\\n2. sandwich -> (bread, meat) (meat -> already available, bread -> created before)\\n\\nand those whose indegrees become 0 are created thus add it to ans.\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        menu = list(zip(recipes, ingredients))\\n        graph = defaultdict(list)\\n        indegrees = {r: 0 for r in recipes}\\n        for r, ing in menu:\\n            for i in ing:\\n                graph[i].append(r) # parent is ing required to make child recipe \\n                if i not in supplies:\\n                    indegrees[r] += 1 #if not present the child is dependent\\n        \\n        q = deque()\\n        possibleRecipe = []\\n        for r, v in indegrees.items():\\n            if v == 0:\\n                q.append(r)\\n                possibleRecipe.append(r)\\n        \\n        while q:\\n            currRecipe = q.popleft()\\n            for neiRecipe in graph[currRecipe]:\\n                indegrees[neiRecipe] -= 1\\n                if indegrees[neiRecipe] == 0:\\n                    possibleRecipe.append(neiRecipe) # the parent was possible to made so now the child can be made too\\n                    q.append(neiRecipe)\\n        return(possibleRecipe)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        menu = list(zip(recipes, ingredients))\\n        graph = defaultdict(list)\\n        indegrees = {r: 0 for r in recipes}\\n        for r, ing in menu:\\n            for i in ing:\\n                graph[i].append(r) # parent is ing required to make child recipe \\n                if i not in supplies:\\n                    indegrees[r] += 1 #if not present the child is dependent\\n        \\n        q = deque()\\n        possibleRecipe = []\\n        for r, v in indegrees.items():\\n            if v == 0:\\n                q.append(r)\\n                possibleRecipe.append(r)\\n        \\n        while q:\\n            currRecipe = q.popleft()\\n            for neiRecipe in graph[currRecipe]:\\n                indegrees[neiRecipe] -= 1\\n                if indegrees[neiRecipe] == 0:\\n                    possibleRecipe.append(neiRecipe) # the parent was possible to made so now the child can be made too\\n                    q.append(neiRecipe)\\n        return(possibleRecipe)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3329238,
                "title": "brute-force-c",
                "content": "# Intuition\\nWe should first try to make recipe with the given initial ingredients. So as are recipes are made they are added to ingredients list, which will further help us to make other advanced recipe\\nThis is brute force approach\\n\\n# Approach\\nAssuming worst case we will run for loops for O(N^3) times.\\nFirst two for loops to complete every recipe with maximum chance(like even if some recipe is made afterwards which was in that particular recipe\\'s ingredients) \\n\\nUsing map for available ingredients.\\nAlso if some recipe is completed then it will be added to available ingredients map.\\n\\nif some ingredients corresponding to a recipe is completed we will use check vector to store this information and will not again evaluate that recipe\\n\\n\\n# Complexity\\n- Time complexity:  O(N^3)\\nfor 3 for loops ie recipe, ingredients , ingredients[i].length\\n\\n- Space complexity: O(N) \\nfor check vector and map\\n\\n\\n# Code\\n```\\n// Brute force approach, can also be done by Topological Sorting\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n\\n        int n=recipes.size();\\n\\n        unordered_map<string,int> mp;\\n        vector<int> check(n,0);\\n\\n        for(auto it: supplies){\\n            mp[it]=1;\\n        }\\n\\n        for(int i=0; i<n ; i++){\\n\\n            for(int j=0; j<n ; j++){\\n\\n                if(check[j]==0){\\n                    int f=1;\\n\\n                    for(auto it: ingredients[j]){\\n                        if(mp.find(it)==mp.end()){\\n                        f=0;\\n                        break;\\n                        }\\n\\n                    }\\n\\n                    if(f==1){\\n                        check[j]=1;\\n                        mp[recipes[j]]=1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<string> ans;\\n        for(int i=0; i<n; i++){\\n            if(check[i]==1){\\n                ans.push_back(recipes[i]);\\n            }\\n        }\\n\\n        return ans;\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Brute force approach, can also be done by Topological Sorting\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n\\n        int n=recipes.size();\\n\\n        unordered_map<string,int> mp;\\n        vector<int> check(n,0);\\n\\n        for(auto it: supplies){\\n            mp[it]=1;\\n        }\\n\\n        for(int i=0; i<n ; i++){\\n\\n            for(int j=0; j<n ; j++){\\n\\n                if(check[j]==0){\\n                    int f=1;\\n\\n                    for(auto it: ingredients[j]){\\n                        if(mp.find(it)==mp.end()){\\n                        f=0;\\n                        break;\\n                        }\\n\\n                    }\\n\\n                    if(f==1){\\n                        check[j]=1;\\n                        mp[recipes[j]]=1;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<string> ans;\\n        for(int i=0; i<n; i++){\\n            if(check[i]==1){\\n                ans.push_back(recipes[i]);\\n            }\\n        }\\n\\n        return ans;\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3116075,
                "title": "graph-based-dfs-approach-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool DFS(map<string,vector<string>>mp,set<string>&st,map<string,bool>&visited,string res){\\n        visited[res]=true;\\n        bool canMake=true;\\n        for(auto x:mp[res]){\\n            if(st.find(x)==st.end()){\\n                if(visited.find(x)!=visited.end() && !visited[x]){\\n                    canMake= canMake && DFS(mp,st,visited,x);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            \\n        }\\n        if(canMake)st.insert(res);\\n        return canMake;\\n\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        set<string>st(supplies.begin(),supplies.end());\\n        map<string,vector<string>>mp;\\n        map<string,bool>visited;\\n        vector<string>ans;\\n        for(int i=0;i<recipes.size();i++){\\n            mp[recipes[i]]=ingredients[i];\\n            visited[recipes[i]]=false;\\n        }\\n        for(int i=0;i<recipes.size();i++){\\n            string res=recipes[i];\\n            bool canMake=false;\\n            if(!visited[res]){\\n                canMake=DFS(mp,st,visited,res);\\n                if(canMake)ans.push_back(res);\\n            }\\n            else if(visited[res]==true  && st.find(res)!=st.end()){\\n                ans.push_back(res);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool DFS(map<string,vector<string>>mp,set<string>&st,map<string,bool>&visited,string res){\\n        visited[res]=true;\\n        bool canMake=true;\\n        for(auto x:mp[res]){\\n            if(st.find(x)==st.end()){\\n                if(visited.find(x)!=visited.end() && !visited[x]){\\n                    canMake= canMake && DFS(mp,st,visited,x);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            \\n        }\\n        if(canMake)st.insert(res);\\n        return canMake;\\n\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        set<string>st(supplies.begin(),supplies.end());\\n        map<string,vector<string>>mp;\\n        map<string,bool>visited;\\n        vector<string>ans;\\n        for(int i=0;i<recipes.size();i++){\\n            mp[recipes[i]]=ingredients[i];\\n            visited[recipes[i]]=false;\\n        }\\n        for(int i=0;i<recipes.size();i++){\\n            string res=recipes[i];\\n            bool canMake=false;\\n            if(!visited[res]){\\n                canMake=DFS(mp,st,visited,res);\\n                if(canMake)ans.push_back(res);\\n            }\\n            else if(visited[res]==true  && st.find(res)!=st.end()){\\n                ans.push_back(res);\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2645037,
                "title": "bfs",
                "content": "## BFS\\n vector<string> findAllRecipes(vector<string>&res, vector<vector<string>>&ingre, vector<string>&supp) {\\n        map<string,int>reschek;\\n        map<string ,pair<int,vector<string>>>mp;\\n        for (int i = 0; i < res.size(); i++)\\n        {\\n           reschek[res[i]]=1;\\n        }\\n        vector<string>ans;\\n         queue<string>q;\\n          for (int i = 0; i < supp.size(); i++)\\n        {\\n            mp[supp[i]].first=0;\\n            q.push(supp[i]);\\n\\n        }\\n        for (int i = 0; i < ingre.size(); i++)\\n        {\\n             int sz=ingre[i].size();\\n            mp[res[i]].first=sz;\\n            for (int j = 0; j < sz; j++)\\n            {\\n               mp[ingre[i][j]].second.push_back(res[i]);\\n            }\\n            \\n        }\\n       \\n\\n      \\n        while (!q.empty())\\n        {\\n            string temp=q.front();\\n            q.pop();\\n            if (reschek.find(temp)!=reschek.end())\\n            {\\n              if (reschek[temp]==1)\\n              {\\n                    ans.push_back(temp);\\n              }\\n              reschek[temp]=0;\\n            }\\n            int sz=mp[temp].second.size();\\n            for (int i = 0; i < sz; i++)\\n            {\\n               mp[mp[temp].second[i]].first--;\\n               if ( mp[mp[temp].second[i]].first==0)\\n               {\\n                    q.push(mp[temp].second[i]);\\n               }\\n               \\n            }\\n            \\n            \\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "## BFS\\n vector<string> findAllRecipes(vector<string>&res, vector<vector<string>>&ingre, vector<string>&supp) {\\n        map<string,int>reschek;\\n        map<string ,pair<int,vector<string>>>mp;\\n        for (int i = 0; i < res.size(); i++)\\n        {\\n           reschek[res[i]]=1;\\n        }\\n        vector<string>ans;\\n         queue<string>q;\\n          for (int i = 0; i < supp.size(); i++)\\n        {\\n            mp[supp[i]].first=0;\\n            q.push(supp[i]);\\n\\n        }\\n        for (int i = 0; i < ingre.size(); i++)\\n        {\\n             int sz=ingre[i].size();\\n            mp[res[i]].first=sz;\\n            for (int j = 0; j < sz; j++)\\n            {\\n               mp[ingre[i][j]].second.push_back(res[i]);\\n            }\\n            \\n        }\\n       \\n\\n      \\n        while (!q.empty())\\n        {\\n            string temp=q.front();\\n            q.pop();\\n            if (reschek.find(temp)!=reschek.end())\\n            {\\n              if (reschek[temp]==1)\\n              {\\n                    ans.push_back(temp);\\n              }\\n              reschek[temp]=0;\\n            }\\n            int sz=mp[temp].second.size();\\n            for (int i = 0; i < sz; i++)\\n            {\\n               mp[mp[temp].second[i]].first--;\\n               if ( mp[mp[temp].second[i]].first==0)\\n               {\\n                    q.push(mp[temp].second[i]);\\n               }\\n               \\n            }\\n            \\n            \\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2571032,
                "title": "java-topo-sort-solution",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        \\n        Map<String, List<String>> adj = new HashMap<>();\\n        Map<String, Integer> indegree = new HashMap<>();\\n        \\n        for(int i=0; i<ingredients.size(); i++) {\\n            for(int j=0; j<ingredients.get(i).size(); j++) {\\n                adj.putIfAbsent(ingredients.get(i).get(j), new ArrayList<>());\\n                adj.get(ingredients.get(i).get(j)).add(recipes[i]);\\n                indegree.put(recipes[i], indegree.getOrDefault(recipes[i], 0)+1);\\n            }\\n        }\\n        \\n        Queue<String> q = new LinkedList();\\n        \\n        for(String s: supplies) {\\n            q.add(s);\\n        }\\n        \\n        List<String> res = new ArrayList<>();\\n    \\n        \\n        while(!q.isEmpty()) {\\n            String supply = q.poll();\\n            \\n            if(!adj.containsKey(supply)) {\\n                continue;\\n            }\\n            \\n            for(String recp: adj.get(supply)) {\\n                int ind = indegree.get(recp) - 1;\\n                indegree.put(recp, ind);\\n        \\n                if(ind == 0) {\\n                    q.add(recp);\\n                    res.add(recp);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        \\n        Map<String, List<String>> adj = new HashMap<>();\\n        Map<String, Integer> indegree = new HashMap<>();\\n        \\n        for(int i=0; i<ingredients.size(); i++) {\\n            for(int j=0; j<ingredients.get(i).size(); j++) {\\n                adj.putIfAbsent(ingredients.get(i).get(j), new ArrayList<>());\\n                adj.get(ingredients.get(i).get(j)).add(recipes[i]);\\n                indegree.put(recipes[i], indegree.getOrDefault(recipes[i], 0)+1);\\n            }\\n        }\\n        \\n        Queue<String> q = new LinkedList();\\n        \\n        for(String s: supplies) {\\n            q.add(s);\\n        }\\n        \\n        List<String> res = new ArrayList<>();\\n    \\n        \\n        while(!q.isEmpty()) {\\n            String supply = q.poll();\\n            \\n            if(!adj.containsKey(supply)) {\\n                continue;\\n            }\\n            \\n            for(String recp: adj.get(supply)) {\\n                int ind = indegree.get(recp) - 1;\\n                indegree.put(recp, ind);\\n        \\n                if(ind == 0) {\\n                    q.add(recp);\\n                    res.add(recp);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192413,
                "title": "java-dfs-with-memo-visited-97",
                "content": "We can use dfs, and save the result on the way. To detect loop we can use a visited set to add node in that path.\\n```\\n\\nclass Solution {\\n    \\n    private List<List<String>> ingredients;\\n    private Set<String> supplies;\\n    private Map<String, Integer> recipes = new HashMap<>();\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        this.ingredients = ingredients;\\n        this.supplies = new HashSet<>(); // O(K), for O(1) check\\n        \\n        for (String s : supplies) {\\n            this.supplies.add(s);\\n        }\\n        \\n        for (int i = 0; i < recipes.length; ++i) { // O(N), for O(1) check and index retrieval\\n            this.recipes.put(recipes[i], i);\\n        }\\n        \\n        // Each recipe is checked exactly once if we used the \"checked cache\"\\n        // for each recipe, its ingredients list is checked exactly once\\n        // O(NK)\\n        List<String> ans = new ArrayList<>();\\n        Map<Integer, Boolean> checked = new HashMap<>(); // O(N)\\n        for (int i = 0; i < recipes.length; ++i) {\\n            if (dfs(i, checked, new HashSet<>())) {\\n                ans.add(recipes[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    boolean dfs(int cur, Map<Integer, Boolean> checked, Set<Integer> visited) {\\n        if (checked.containsKey(cur)) { // already checked, return result\\n            return checked.get(cur);\\n        }\\n        if (visited.contains(cur)) { // form a circle, cannot work\\n            return false;\\n        }\\n        \\n        visited.add(cur);\\n        \\n        List<String> ings = ingredients.get(cur);\\n        for (String ing : ings) {\\n            // if it is a node\\n            if (recipes.containsKey(ing)) {\\n                boolean canMake = dfs(recipes.get(ing), checked, visited);\\n                // if that node can\\'t be made\\n                if (!canMake) {\\n                    checked.put(cur, false);\\n                    return canMake;\\n                }\\n            }\\n            // if it is a leaf and not provided\\n            else if (!supplies.contains(ing)) {\\n                checked.put(cur, false);\\n                return false;\\n            }\\n        }\\n        // all node and leaves can be made/provided\\n        checked.put(cur, true);\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\n\\nclass Solution {\\n    \\n    private List<List<String>> ingredients;\\n    private Set<String> supplies;\\n    private Map<String, Integer> recipes = new HashMap<>();\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        this.ingredients = ingredients;\\n        this.supplies = new HashSet<>(); // O(K), for O(1) check\\n        \\n        for (String s : supplies) {\\n            this.supplies.add(s);\\n        }\\n        \\n        for (int i = 0; i < recipes.length; ++i) { // O(N), for O(1) check and index retrieval\\n            this.recipes.put(recipes[i], i);\\n        }\\n        \\n        // Each recipe is checked exactly once if we used the \"checked cache\"\\n        // for each recipe, its ingredients list is checked exactly once\\n        // O(NK)\\n        List<String> ans = new ArrayList<>();\\n        Map<Integer, Boolean> checked = new HashMap<>(); // O(N)\\n        for (int i = 0; i < recipes.length; ++i) {\\n            if (dfs(i, checked, new HashSet<>())) {\\n                ans.add(recipes[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    boolean dfs(int cur, Map<Integer, Boolean> checked, Set<Integer> visited) {\\n        if (checked.containsKey(cur)) { // already checked, return result\\n            return checked.get(cur);\\n        }\\n        if (visited.contains(cur)) { // form a circle, cannot work\\n            return false;\\n        }\\n        \\n        visited.add(cur);\\n        \\n        List<String> ings = ingredients.get(cur);\\n        for (String ing : ings) {\\n            // if it is a node\\n            if (recipes.containsKey(ing)) {\\n                boolean canMake = dfs(recipes.get(ing), checked, visited);\\n                // if that node can\\'t be made\\n                if (!canMake) {\\n                    checked.put(cur, false);\\n                    return canMake;\\n                }\\n            }\\n            // if it is a leaf and not provided\\n            else if (!supplies.contains(ing)) {\\n                checked.put(cur, false);\\n                return false;\\n            }\\n        }\\n        // all node and leaves can be made/provided\\n        checked.put(cur, true);\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1984408,
                "title": "kotlin-topological-sort-dfs-time-o-v-e-space-o-v-short-easy-understanding",
                "content": "```\\nfun findAllRecipes(recipes: Array<String>, ingredients: List<List<String>>, supplies: Array<String>): List<String> {\\n\\t\\t// Groups the receipes with the ingredients at the matching index\\n        val recipeMap = recipes.zip(ingredients).toMap()\\n        val supplies = supplies.toMutableSet()\\n        val output = mutableSetOf<String>()\\n        \\n        fun canCook(visiting: MutableSet<String>, recipe: String): Boolean {\\n            if(recipe in supplies) return true\\n            if(recipe !in recipeMap) return false\\n            for(ingredient in recipeMap[recipe] ?: emptyList()) { \\n                if(ingredient in supplies) continue\\n                if(ingredient in visiting) return false\\n                visiting.add(ingredient)\\n                if(!canCook(visiting, ingredient)) return false\\n                visiting.remove(ingredient)\\n            }\\n            supplies.add(recipe)\\n            return true\\n        }\\n        \\n        for(recipe in recipes) {\\n            if(recipe in supplies) output.add(recipe)\\n            if(canCook(mutableSetOf(), recipe)) output.add(recipe)\\n        }\\n        \\n        return output.toList()\\n    }",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nfun findAllRecipes(recipes: Array<String>, ingredients: List<List<String>>, supplies: Array<String>): List<String> {\\n\\t\\t// Groups the receipes with the ingredients at the matching index\\n        val recipeMap = recipes.zip(ingredients).toMap()\\n        val supplies = supplies.toMutableSet()\\n        val output = mutableSetOf<String>()\\n        \\n        fun canCook(visiting: MutableSet<String>, recipe: String): Boolean {\\n            if(recipe in supplies) return true\\n            if(recipe !in recipeMap) return false\\n            for(ingredient in recipeMap[recipe] ?: emptyList()) { \\n                if(ingredient in supplies) continue\\n                if(ingredient in visiting) return false\\n                visiting.add(ingredient)\\n                if(!canCook(visiting, ingredient)) return false\\n                visiting.remove(ingredient)\\n            }\\n            supplies.add(recipe)\\n            return true\\n        }\\n        \\n        for(recipe in recipes) {\\n            if(recipe in supplies) output.add(recipe)\\n            if(canCook(mutableSetOf(), recipe)) output.add(recipe)\\n        }\\n        \\n        return output.toList()\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1876389,
                "title": "c-detailed-dfs-solution-2115",
                "content": "Here the recipes can be checked whether they can be prepared or not in a recursive manner (DFS).\\nTo make it more efficient we need to store the given information and results produced during the previous DFS calls in maps and sets.\\n1. Accessing ingredients by the recipe name will make our work easier so create a map of ```<string,vector<string> >``` where each recipe key contains required ingredients needed to prepare it.\\n2. Make a note of items which are supplies and also decided that they can be prepared in the previous DFS calls in a set (A type of memoization)\\n3. Also make a note of all visited recipes so that the recipes which are visited but cannot be prepared will not present in the set created in step2\\n4. Call DFS for each recipe and in DFS function check for 3 base cases--> (1) If the recipe is one of supplies or already prepared ingredient (The set created in step 2) . (2) If the recipe cannot be prepared (The set created in step 3) . (3) The required item is neither a recipe nor a supply (Number of ingredients is 0).  AND then proceed for DFS calls for each of it\\'s ingredients which return a boolean value representing whether the requested recipe can be prepared or not (Accordingly add the recipe into the set created in step 2)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>>req;\\n    unordered_set<string>ready,vis;\\n    bool dfs(string& s){\\n        if(ready.count(s)){return true;} // prepared previously or is one of the supplies\\n        if(vis.count(s)){return false;} // Cannot be prepared\\n        if(!req.count(s)){return false;} // Extra ingredient which is neither in supplies nor in recipes\\n        vis.insert(s);\\n        bool possible = true;\\n        for(string& ing : req[s]){\\n            if(!dfs(ing)){\\n                possible = false; break;\\n            }\\n        }\\n        if(possible){ready.insert(s);}\\n        return possible;\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n = recipes.size();\\n        for(int i=0;i<n;i++){\\n            req[recipes[i]] = ingredients[i];\\n        }\\n        for(string& s : supplies){ready.insert(s);}\\n        vector<string>res;\\n        for(int i=0;i<n;i++){\\n            if(dfs(recipes[i])){\\n                res.push_back(recipes[i]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nFeel free to comment your queries if any\\n**Upvote** if found useful\\n**Thank You :)**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```<string,vector<string> >```\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>>req;\\n    unordered_set<string>ready,vis;\\n    bool dfs(string& s){\\n        if(ready.count(s)){return true;} // prepared previously or is one of the supplies\\n        if(vis.count(s)){return false;} // Cannot be prepared\\n        if(!req.count(s)){return false;} // Extra ingredient which is neither in supplies nor in recipes\\n        vis.insert(s);\\n        bool possible = true;\\n        for(string& ing : req[s]){\\n            if(!dfs(ing)){\\n                possible = false; break;\\n            }\\n        }\\n        if(possible){ready.insert(s);}\\n        return possible;\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n = recipes.size();\\n        for(int i=0;i<n;i++){\\n            req[recipes[i]] = ingredients[i];\\n        }\\n        for(string& s : supplies){ready.insert(s);}\\n        vector<string>res;\\n        for(int i=0;i<n;i++){\\n            if(dfs(recipes[i])){\\n                res.push_back(recipes[i]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1785173,
                "title": "java-topological-sort-solution-based-on-the-course-schedule-template",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        int totalRecipes = recipes.length;\\n        HashMap<String, Integer> recipeNameIndexMap = new HashMap<>();\\n        for (int i = 0; i < totalRecipes; i++) {\\n            recipeNameIndexMap.put(recipes[i], i);\\n        }\\n        \\n        // put all supplies in a HashSet for easy access\\n        HashSet<String> suppliesSet = new HashSet<>();\\n        for (String supply: supplies) {\\n            suppliesSet.add(supply);\\n        }\\n        \\n        int[] inDegree = new int[totalRecipes];\\n        int[][] adjMatrix = new int[totalRecipes][totalRecipes];\\n        \\n        for (int i = 0; i < totalRecipes; i++) {\\n            List<String> ingredientList = ingredients.get(i);\\n            int listSize = ingredientList.size();\\n            int inSupply = 0;\\n            int otherRecipeItms = 0;\\n            for (String ing: ingredientList) {\\n                if (suppliesSet.contains(ing)) {\\n                    inSupply++;\\n                } else if (recipeNameIndexMap.containsKey(ing)) {\\n                    otherRecipeItms++;\\n                    inDegree[i]++;\\n                    int pre = recipeNameIndexMap.get(ing);\\n                    adjMatrix[pre][i] = 1;\\n                }\\n            }\\n            \\n            // this is when the receipe can\\'t be made because of a missing item\\n            if (inSupply + otherRecipeItms != listSize) {\\n                inDegree[i] = totalRecipes + 1;\\n            }\\n        }\\n        \\n        Queue<String> queue = new LinkedList<>();\\n        for (int i = 0; i < totalRecipes; i++) {\\n            if (inDegree[i] == 0) {\\n                queue.add(recipes[i]);\\n            }\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        while (! queue.isEmpty()) {\\n            String curr = queue.poll();\\n            result.add(curr);\\n            int pre = recipeNameIndexMap.get(curr);\\n            for (int i = 0; i < totalRecipes; i++) {\\n                if (adjMatrix[pre][i] == 1) {\\n                    inDegree[i]--;\\n                    if (inDegree[i] == 0) {\\n                        queue.add(recipes[i]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        int totalRecipes = recipes.length;\\n        HashMap<String, Integer> recipeNameIndexMap = new HashMap<>();\\n        for (int i = 0; i < totalRecipes; i++) {\\n            recipeNameIndexMap.put(recipes[i], i);\\n        }\\n        \\n        // put all supplies in a HashSet for easy access\\n        HashSet<String> suppliesSet = new HashSet<>();\\n        for (String supply: supplies) {\\n            suppliesSet.add(supply);\\n        }\\n        \\n        int[] inDegree = new int[totalRecipes];\\n        int[][] adjMatrix = new int[totalRecipes][totalRecipes];\\n        \\n        for (int i = 0; i < totalRecipes; i++) {\\n            List<String> ingredientList = ingredients.get(i);\\n            int listSize = ingredientList.size();\\n            int inSupply = 0;\\n            int otherRecipeItms = 0;\\n            for (String ing: ingredientList) {\\n                if (suppliesSet.contains(ing)) {\\n                    inSupply++;\\n                } else if (recipeNameIndexMap.containsKey(ing)) {\\n                    otherRecipeItms++;\\n                    inDegree[i]++;\\n                    int pre = recipeNameIndexMap.get(ing);\\n                    adjMatrix[pre][i] = 1;\\n                }\\n            }\\n            \\n            // this is when the receipe can\\'t be made because of a missing item\\n            if (inSupply + otherRecipeItms != listSize) {\\n                inDegree[i] = totalRecipes + 1;\\n            }\\n        }\\n        \\n        Queue<String> queue = new LinkedList<>();\\n        for (int i = 0; i < totalRecipes; i++) {\\n            if (inDegree[i] == 0) {\\n                queue.add(recipes[i]);\\n            }\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        while (! queue.isEmpty()) {\\n            String curr = queue.poll();\\n            result.add(curr);\\n            int pre = recipeNameIndexMap.get(curr);\\n            for (int i = 0; i < totalRecipes; i++) {\\n                if (adjMatrix[pre][i] == 1) {\\n                    inDegree[i]--;\\n                    if (inDegree[i] == 0) {\\n                        queue.add(recipes[i]);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1749427,
                "title": "python-simple-dfs-faster-than-99-o-n",
                "content": "Imagine a graph where edges are from recipes to their ingredients. We recursively visit each recipe and perform dfs on each of its dependencies. If a recpie is valid, we add it to the set of all supplies we have. For each recipe, if after visiting a neighboring recipe and that neighbor is not in all_supplies, then the current recipe is impossible too.\\n```\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        r2i = {r: i for r, i in zip(recipes, ingredients)}\\n        all_supplies = set(supplies)\\n        order = []\\n        visit = set()\\n        def dfs(r):\\n            visit.add(r)\\n            for i in r2i[r]:\\n                if i in r2i and i not in visit: # ingredient is another recipe, so we visit\\n                    dfs(i)\\n                if i not in all_supplies:\\n                    return                      # since ingredient was not added to all_supplies after visiting it, this recipe is impossible\\n            all_supplies.add(r)                 # once outside the loop, all ingredients are in all_supplies, this recipe is possible\\n            order.append(r)\\n        \\n        for r in recipes:\\n            if r not in visit:\\n                dfs(r)\\n        return order",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "Imagine a graph where edges are from recipes to their ingredients. We recursively visit each recipe and perform dfs on each of its dependencies. If a recpie is valid, we add it to the set of all supplies we have. For each recipe, if after visiting a neighboring recipe and that neighbor is not in all_supplies, then the current recipe is impossible too.\\n```\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        r2i = {r: i for r, i in zip(recipes, ingredients)}\\n        all_supplies = set(supplies)\\n        order = []\\n        visit = set()\\n        def dfs(r):\\n            visit.add(r)\\n            for i in r2i[r]:\\n                if i in r2i and i not in visit: # ingredient is another recipe, so we visit\\n                    dfs(i)\\n                if i not in all_supplies:\\n                    return                      # since ingredient was not added to all_supplies after visiting it, this recipe is impossible\\n            all_supplies.add(r)                 # once outside the loop, all ingredients are in all_supplies, this recipe is possible\\n            order.append(r)\\n        \\n        for r in recipes:\\n            if r not in visit:\\n                dfs(r)\\n        return order",
                "codeTag": "Python3"
            },
            {
                "id": 1695519,
                "title": "java-easy-to-follow-topological-sort",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, List<String>> adjList = new HashMap<>();\\n        Map<String, Integer> indegree = new HashMap<>();\\n        Set<String> recipeSet = new HashSet<>();\\n        \\n        for (int i = 0; i < recipes.length; i++) {\\n            String recipe = recipes[i];\\n            recipeSet.add(recipe);\\n            List<String> ingredientOfRecipe = ingredients.get(i);\\n            \\n            for (String ingredient : ingredientOfRecipe) {\\n                adjList.computeIfAbsent(ingredient, x -> new ArrayList<>()).add(recipe);\\n                indegree.put(recipe, indegree.getOrDefault(recipe, 0) + 1);\\n            }\\n        }\\n        \\n        Deque<String> queue = new ArrayDeque<>();\\n        List<String> result = new ArrayList<>();\\n        \\n        for (String supply : supplies) queue.add(supply);\\n        \\n        while (!queue.isEmpty()) {\\n            String curr = queue.removeFirst();\\n            if (recipeSet.contains(curr)) result.add(curr);\\n            \\n            if (adjList.containsKey(curr)) {\\n                for (String neighbor : adjList.get(curr)) {\\n                    int newOccurrence = indegree.get(neighbor) - 1;\\n                    indegree.put(neighbor, newOccurrence);\\n                    if (newOccurrence == 0) queue.add(neighbor);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, List<String>> adjList = new HashMap<>();\\n        Map<String, Integer> indegree = new HashMap<>();\\n        Set<String> recipeSet = new HashSet<>();\\n        \\n        for (int i = 0; i < recipes.length; i++) {\\n            String recipe = recipes[i];\\n            recipeSet.add(recipe);\\n            List<String> ingredientOfRecipe = ingredients.get(i);\\n            \\n            for (String ingredient : ingredientOfRecipe) {\\n                adjList.computeIfAbsent(ingredient, x -> new ArrayList<>()).add(recipe);\\n                indegree.put(recipe, indegree.getOrDefault(recipe, 0) + 1);\\n            }\\n        }\\n        \\n        Deque<String> queue = new ArrayDeque<>();\\n        List<String> result = new ArrayList<>();\\n        \\n        for (String supply : supplies) queue.add(supply);\\n        \\n        while (!queue.isEmpty()) {\\n            String curr = queue.removeFirst();\\n            if (recipeSet.contains(curr)) result.add(curr);\\n            \\n            if (adjList.containsKey(curr)) {\\n                for (String neighbor : adjList.get(curr)) {\\n                    int newOccurrence = indegree.get(neighbor) - 1;\\n                    indegree.put(neighbor, newOccurrence);\\n                    if (newOccurrence == 0) queue.add(neighbor);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1653594,
                "title": "brute-force-python-3-accepted-commented",
                "content": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        ans = []                                             // Store the possible recipes\\n        dict1 = {}                                          //Map each recipe to its ingredient\\n        supplies = set(supplies)                   //Converting to set in order to store unique supplies and avoid redundant checks\\n        for i in range(len(recipes)):\\n            dict1[recipes[i]] = ingredients[i]  //Map each recipe to its ingredient\\n        while True:                                       // loop until terminating criteria is reached\\n            temp = []                                    //temp array to store the non-possible reciepes for a particular iteration\\n            for i in range(len(recipes)):         //Iterage the reciepe array\\n                flag = True                             // Assume each recipe is possible in the start\\n                for j in range(len(dict1[recipes[i]])):          //iterate each ingredient for each reciepe\\n                    if dict1[recipes[i]][j] not in supplies:     // and check if its available in supplies\\n                        flag = False                                       //if not available then set the flag to false\\n                        temp.append(recipes[i])                   //and add the not possible(maybe as of now) reciepe to temp array\\n                        break                                                   //and break\\n                if flag:                                                          //if the reciepe is possible\\n                    ans.append(recipes[i])                             //then add the reciepe to ans array\\n                    supplies.add(recipes[i])                           //also add the reciepe to the supply array as it is possible\\n            if temp == recipes:                                         //terminating criteria for while True loop if there is no change in temp array then break\\n                break\\n            else:\\n                recipes = temp                                            // else update the reciepes array with temp\\n        return ans                                                          //Lastly return the ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        ans = []                                             // Store the possible recipes\\n        dict1 = {}                                          //Map each recipe to its ingredient\\n        supplies = set(supplies)                   //Converting to set in order to store unique supplies and avoid redundant checks\\n        for i in range(len(recipes)):\\n            dict1[recipes[i]] = ingredients[i]  //Map each recipe to its ingredient\\n        while True:                                       // loop until terminating criteria is reached\\n            temp = []                                    //temp array to store the non-possible reciepes for a particular iteration\\n            for i in range(len(recipes)):         //Iterage the reciepe array\\n                flag = True                             // Assume each recipe is possible in the start\\n                for j in range(len(dict1[recipes[i]])):          //iterate each ingredient for each reciepe\\n                    if dict1[recipes[i]][j] not in supplies:     // and check if its available in supplies\\n                        flag = False                                       //if not available then set the flag to false\\n                        temp.append(recipes[i])                   //and add the not possible(maybe as of now) reciepe to temp array\\n                        break                                                   //and break\\n                if flag:                                                          //if the reciepe is possible\\n                    ans.append(recipes[i])                             //then add the reciepe to ans array\\n                    supplies.add(recipes[i])                           //also add the reciepe to the supply array as it is possible\\n            if temp == recipes:                                         //terminating criteria for while True loop if there is no change in temp array then break\\n                break\\n            else:\\n                recipes = temp                                            // else update the reciepes array with temp\\n        return ans                                                          //Lastly return the ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649035,
                "title": "c-brute-force-solution-using-unordered-set",
                "content": "\\n    vector<string> findAllRecipes(vector<string>& rec, vector<vector<string>>& in, vector<string>& sup) {\\n        unordered_set<string>us;\\n        vector<string>ans;\\n        unordered_set<string>supplies(sup.begin(), sup.end());\\n        while(1){\\n            int count = 0;\\n            for(int i=0;i<rec.size();i++){\\n                bool flag = false;\\n                if(us.find(rec[i])==us.end()){\\n                   for(int j=0;j<in[i].size();j++){\\n                    if(supplies.find(in[i][j])==supplies.end()){\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if(flag==false){\\n                    supplies.insert(rec[i]);\\n                    us.insert(rec[i]);\\n                    ans.push_back(rec[i]);\\n                    count++;\\n                } \\n                }\\n            }\\n            if(count == 0)\\n                break;\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n    vector<string> findAllRecipes(vector<string>& rec, vector<vector<string>>& in, vector<string>& sup) {\\n        unordered_set<string>us;\\n        vector<string>ans;\\n        unordered_set<string>supplies(sup.begin(), sup.end());\\n        while(1){\\n            int count = 0;\\n            for(int i=0;i<rec.size();i++){\\n                bool flag = false;\\n                if(us.find(rec[i])==us.end()){\\n                   for(int j=0;j<in[i].size();j++){\\n                    if(supplies.find(in[i][j])==supplies.end()){\\n                        flag = true;\\n                        break;\\n                    }\\n                }\\n                if(flag==false){\\n                    supplies.insert(rec[i]);\\n                    us.insert(rec[i]);\\n                    ans.push_back(rec[i]);\\n                    count++;\\n                } \\n                }\\n            }\\n            if(count == 0)\\n                break;\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1646626,
                "title": "java-topological-sort",
                "content": "\\nMy approach based on course schedule II https://leetcode.com/problems/course-schedule-ii/solution/\\n\\n\\n``` \\n\\npublic List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        \\n        \\n        \\n        List<String> allRecipes= new ArrayList();\\n        Map<String, Integer> map = new HashMap();\\n        List<String> supplyList = new ArrayList();\\n        \\n        for(String supply: supplies){\\n            supplyList.add(supply);\\n        }\\n        \\n        for(int i = 0;i<recipes.length;i++){\\n            map.put(recipes[i], i);\\n        }\\n        Queue<Integer> queue = new LinkedList();\\n        int [] degree = new int[recipes.length];\\n        ArrayList<String> [] recipeEdges = new ArrayList[recipes.length];\\n        \\n        for(int i = 0;i<recipes.length;i++){\\n            recipeEdges[i] = new ArrayList<String>();\\n        }\\n\\t\\t\\n\\t\\t // Create the adjacency list representation of the graph\\n        for(int i = 0;i<ingredients.size();i++){\\n            List<String> currIngredients = ingredients.get(i);\\n            for(int j = 0;j<currIngredients.size();j++){\\n                if(map.containsKey(currIngredients.get(j))){\\n\\t\\t\\t\\t      // Record in-degree of each vertex\\n                    degree[i]++;\\n                    recipeEdges[map.get(currIngredients.get(j))].add(recipes[i]);\\n                    \\n                }\\n            }\\n        }\\n        \\n        // Add all vertices with 0 in-degree to the queue\\n       for(int i = 0;i<degree.length;i++){\\n           if(degree[i] == 0){\\n               queue.add(i);\\n           }\\n       }\\n        \\n\\t\\t // Process until the Q becomes empty\\n        while(!queue.isEmpty()){\\n            \\n            int currRecipe = queue.poll();\\n            //If indegree is 0 check if supplyList contains all ingredients for the recipe, if it does add the recipe itself to the supply            chain\\n            if(supplyList.containsAll(ingredients.get(currRecipe))){\\n               supplyList.add(recipes[currRecipe]);\\n               allRecipes.add(recipes[currRecipe]);\\n            }\\n\\t\\t\\t // Reduce the in-degree of each neighbor by 1  and If in-degree of a neighbor becomes 0, add it to the Q\\n            for(String node : recipeEdges[currRecipe]){\\n                if(--degree[map.get(node)] == 0){\\n                    queue.add(map.get(node));                    \\n          \\n                }\\n            }\\n            \\n        }\\n                                \\n       return allRecipes;\\n    }",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "\\nMy approach based on course schedule II https://leetcode.com/problems/course-schedule-ii/solution/\\n\\n\\n``` \\n\\npublic List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        \\n        \\n        \\n        List<String> allRecipes= new ArrayList();\\n        Map<String, Integer> map = new HashMap();\\n        List<String> supplyList = new ArrayList();\\n        \\n        for(String supply: supplies){\\n            supplyList.add(supply);\\n        }\\n        \\n        for(int i = 0;i<recipes.length;i++){\\n            map.put(recipes[i], i);\\n        }\\n        Queue<Integer> queue = new LinkedList();\\n        int [] degree = new int[recipes.length];\\n        ArrayList<String> [] recipeEdges = new ArrayList[recipes.length];\\n        \\n        for(int i = 0;i<recipes.length;i++){\\n            recipeEdges[i] = new ArrayList<String>();\\n        }\\n\\t\\t\\n\\t\\t // Create the adjacency list representation of the graph\\n        for(int i = 0;i<ingredients.size();i++){\\n            List<String> currIngredients = ingredients.get(i);\\n            for(int j = 0;j<currIngredients.size();j++){\\n                if(map.containsKey(currIngredients.get(j))){\\n\\t\\t\\t\\t      // Record in-degree of each vertex\\n                    degree[i]++;\\n                    recipeEdges[map.get(currIngredients.get(j))].add(recipes[i]);\\n                    \\n                }\\n            }\\n        }\\n        \\n        // Add all vertices with 0 in-degree to the queue\\n       for(int i = 0;i<degree.length;i++){\\n           if(degree[i] == 0){\\n               queue.add(i);\\n           }\\n       }\\n        \\n\\t\\t // Process until the Q becomes empty\\n        while(!queue.isEmpty()){\\n            \\n            int currRecipe = queue.poll();\\n            //If indegree is 0 check if supplyList contains all ingredients for the recipe, if it does add the recipe itself to the supply            chain\\n            if(supplyList.containsAll(ingredients.get(currRecipe))){\\n               supplyList.add(recipes[currRecipe]);\\n               allRecipes.add(recipes[currRecipe]);\\n            }\\n\\t\\t\\t // Reduce the in-degree of each neighbor by 1  and If in-degree of a neighbor becomes 0, add it to the Q\\n            for(String node : recipeEdges[currRecipe]){\\n                if(--degree[map.get(node)] == 0){\\n                    queue.add(map.get(node));                    \\n          \\n                }\\n            }\\n            \\n        }\\n                                \\n       return allRecipes;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3944513,
                "title": "easy-intuitive-solution-well-explained-dfs-memoization-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBy reading the problem it was intuitive enough to use lots of hash map :).\\n\\nHere we will try to do the same. For every ith recipe check if all its ingredient is in supply or not. If all exists in supply then it can be cooked otherwise not. But the problem is when the ingredient for a certain reciepe turns out to be a reciepe itself.\\n\\nTo deal with this we will apply topological sorting. Now at first it may seem fancy but my approach will be more intuitive to you.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst thing first ...populate the given supplies and recipe in the hash map so that O(1) access is possible.\\n\\n```\\nunordered_map<string,int> supply_map;  //hash map to store supplies with their index (a set can be used instead)\\nunordered_map<string,int> recipe_map;  //hash map to store reciepes with their index\\n```\\n\\nThen we will check for evevry recipe if its cookable or not.\\ncan_cook function does the same. Its just Dfs. Now for the given meal(ith reciepe) we will check its ingredient list and search for that ingredient in our supply map. If the ingredient exists all good otherwise we return false.\\n\\nNow if the ingredient itself is a reciepe then we simply apply dfs (can_cook) to it and first check if that ingredient can be cooked or not....so far our basic skeleton for the code is ready now just a little **optimisation is required**.\\n\\n--- \\n\\nNow, this is the memo table we create to look for if any reciepe has already been tried to process.\\n```\\nunordered_map<string,bool> preparable; //a memo table to check for if ith reciepe has already been processed\\n        \\n```\\n\\n**For ex** \\n```\\nrecipes = [\"bread\",\"sandwich\",\"burger\"]\\ningredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]]\\nsupplies = [\"yeast\",\"flour\",\"meat\"]\\n```\\n\\nHere bread is required in both sandwich and burger so without the memo table(preparable) we would just do the computation for bread multiple times. So we are using a memo table just a little bit of dp.\\n\\n---\\n\\nThis is the same Visited map or call_stack map (whatever you name it)\\nused to check if cycle exists or not.\\n\\n```\\nunordered_map<string,bool> visited;  // when applying dfs it make sure if their exists a cycle\\n\\n```\\n\\n**For ex**\\n\\n```\\nrecipes = [\"bread\",\"sandwich\",\"burger\"]\\ningredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\",\"burger\"],[\"sandwich\",\"meat\",\"bread\"]]\\nsupplies = [\"yeast\",\"flour\",\"meat\"]\\n```\\n\\nIn this example both sandwich requires burger and burger requires sandwich. Clearly a cycle exists and without detecting the cycle it will go to infinite recurrsion and give a **Address Sanitizer** error\\n\\nTo deal with it I am just using good old Dfs trick of identifying if a back edge exists or not. Simply put at the beginning of every call I am putting that meal in the visited map and removing it once the processing for the meal is done. (Do check for cycle detection you will understand it or comment done I will be happy to help)\\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**O(nm)**\\nn is the recipe.size()\\nm is ingredient[i].size()\\n\\ni.e all the elements of the ingredient matrix \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n**O(N)**\\n\\n---\\n\\n\\n\\n**DO UPVOTE** if it helped:)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool can_cook(string meal, vector<vector<string>> &ingredients,unordered_map<string,int> &supply_map,unordered_map<string,int> &recipe, unordered_map<string,bool> &preparable,unordered_map<string,bool> &visited)\\n    {\\n        bool ans=true;\\n        int items = recipe[meal];\\n        \\n        if(preparable.find(meal)!=preparable.end()) // if a given recipe has already been processed\\n            return preparable[meal];\\n\\n        if(visited.find(meal)!=visited.end())  // to check cycle exists or not by checking if it is in the current call stack\\n            return false;\\n\\n        visited.insert({meal,false}); //inserting in call stack\\n        for(int i=0;i<ingredients[items].size();i++)\\n        {\\n            if(recipe.find(ingredients[items][i])!=recipe.end()) // if an ingredient is a reciepe we apply dfs\\n                ans&=can_cook(ingredients[items][i],ingredients,supply_map,recipe,preparable,visited);\\n            else if(supply_map.find(ingredients[items][i])==supply_map.end())\\n                ans=false;\\n                \\n            if(ans==false)\\n                break;\\n        }\\n\\n        visited.erase(meal); // removing meal from current call stack\\n        preparable[meal]=ans;\\n        return ans;\\n    }\\n\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        unordered_map<string,int> supply_map;  //hash map to store supplies with their index (a set can be used instead)\\n        unordered_map<string,int> recipe_map;  //hash map to store reciepes with their index\\n        unordered_map<string,bool> preparable; //a memo table to check for if ith reciepe has already been processed\\n        unordered_map<string,bool> visited;  // when applying dfs it make sure if their exists a cycle\\n\\n        vector<string> ans;\\n\\n        //populating supply map\\n        for(int i=0;i<supplies.size();i++)\\n            supply_map.insert({supplies[i],i});\\n\\n        // populating recipe map\\n        for(int i=0;i<recipes.size();i++)\\n        {\\n            recipe_map[recipes[i]]=i;\\n        }\\n\\n        // applying the Dfs(can_cook) to all reciepe\\n        for(int i=0;i<recipes.size();i++)\\n        {\\n            if(can_cook(recipes[i],ingredients,supply_map,recipe_map,preparable,visited))\\n                ans.push_back(recipes[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Topological Sort",
                    "Memoization"
                ],
                "code": "```\\nunordered_map<string,int> supply_map;  //hash map to store supplies with their index (a set can be used instead)\\nunordered_map<string,int> recipe_map;  //hash map to store reciepes with their index\\n```\n```\\nunordered_map<string,bool> preparable; //a memo table to check for if ith reciepe has already been processed\\n        \\n```\n```\\nrecipes = [\"bread\",\"sandwich\",\"burger\"]\\ningredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\"],[\"sandwich\",\"meat\",\"bread\"]]\\nsupplies = [\"yeast\",\"flour\",\"meat\"]\\n```\n```\\nunordered_map<string,bool> visited;  // when applying dfs it make sure if their exists a cycle\\n\\n```\n```\\nrecipes = [\"bread\",\"sandwich\",\"burger\"]\\ningredients = [[\"yeast\",\"flour\"],[\"bread\",\"meat\",\"burger\"],[\"sandwich\",\"meat\",\"bread\"]]\\nsupplies = [\"yeast\",\"flour\",\"meat\"]\\n```\n```\\nclass Solution {\\npublic:\\n\\n    bool can_cook(string meal, vector<vector<string>> &ingredients,unordered_map<string,int> &supply_map,unordered_map<string,int> &recipe, unordered_map<string,bool> &preparable,unordered_map<string,bool> &visited)\\n    {\\n        bool ans=true;\\n        int items = recipe[meal];\\n        \\n        if(preparable.find(meal)!=preparable.end()) // if a given recipe has already been processed\\n            return preparable[meal];\\n\\n        if(visited.find(meal)!=visited.end())  // to check cycle exists or not by checking if it is in the current call stack\\n            return false;\\n\\n        visited.insert({meal,false}); //inserting in call stack\\n        for(int i=0;i<ingredients[items].size();i++)\\n        {\\n            if(recipe.find(ingredients[items][i])!=recipe.end()) // if an ingredient is a reciepe we apply dfs\\n                ans&=can_cook(ingredients[items][i],ingredients,supply_map,recipe,preparable,visited);\\n            else if(supply_map.find(ingredients[items][i])==supply_map.end())\\n                ans=false;\\n                \\n            if(ans==false)\\n                break;\\n        }\\n\\n        visited.erase(meal); // removing meal from current call stack\\n        preparable[meal]=ans;\\n        return ans;\\n    }\\n\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        unordered_map<string,int> supply_map;  //hash map to store supplies with their index (a set can be used instead)\\n        unordered_map<string,int> recipe_map;  //hash map to store reciepes with their index\\n        unordered_map<string,bool> preparable; //a memo table to check for if ith reciepe has already been processed\\n        unordered_map<string,bool> visited;  // when applying dfs it make sure if their exists a cycle\\n\\n        vector<string> ans;\\n\\n        //populating supply map\\n        for(int i=0;i<supplies.size();i++)\\n            supply_map.insert({supplies[i],i});\\n\\n        // populating recipe map\\n        for(int i=0;i<recipes.size();i++)\\n        {\\n            recipe_map[recipes[i]]=i;\\n        }\\n\\n        // applying the Dfs(can_cook) to all reciepe\\n        for(int i=0;i<recipes.size();i++)\\n        {\\n            if(can_cook(recipes[i],ingredients,supply_map,recipe_map,preparable,visited))\\n                ans.push_back(recipes[i]);\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902784,
                "title": "brute-force-dfs-map-and-visit-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n > We will be adding elements of **recipe** and **supplies** into a **map**\\nand, using this **map** along with the recipe and ingredients array to create ****adjacency List****. While making adjacency list if we find any ingredient that is not present in map we will mark the **visit[node]=-1**.\\nNow we will make a **DFS** call for all **receipe** that has not been made i.e. (**visit[node]=0**) and if DFS call returns true, then we will add solution to the **result array**\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(int node,vector<int> adj[],vector<int> &visit){\\n        visit[node] = 2;\\n        for(auto it : adj[node]){\\n            if(visit[it] == -1){\\n                return false;\\n            }\\n    /*If visit[it]==2 means ingredient \"a\" require \"b\" to be made & \"b\" require \"a\" to be made*/\\n            if(visit[it] == 2){\\n                visit[it] = -1;\\n                return false;\\n            }\\n            if(visit[it] == 0){\\n                if(dfs(it , adj , visit) == false){\\n                    visit[it] = -1;\\n                    return false;\\n                }\\n            }\\n        }\\n        /*If all ingredients are present it is apossible to make tha recipe so we will\\n        make visit[node] as 1*/\\n        visit[node]=1;\\n        return true;\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        /*map stores unique number for unique word */\\n        unordered_map<string,int> mp;\\n        int n=0;\\n        for(int i = 0; i < supplies.size() ; i++){\\n            if(mp.find(supplies[i]) == mp.end()){\\n                mp[supplies[i]] = n;\\n                n++;\\n            }\\n        }\\n        for(int i = 0 ; i < recipes.size() ; i++){\\n            if(mp.find(recipes[i]) == mp.end()){\\n                mp[recipes[i]] = n;\\n                n++;\\n            }\\n        }\\n        /*Creating adjacency list */\\n        vector<int> adj[n];\\n        vector<int> visit(n,0);\\n        for(int i = 0 ; i < recipes.size() ; i++){\\n            int x = mp[recipes[i]];\\n            for(int j = 0 ; j < ingredients[i].size() ; j++){\\n                //if we find ingredient in map we will add to adj list\\n                if(mp.find(ingredients[i][j])!=mp.end()){\\n                    int y = mp[ingredients[i][j]];\\n                    adj[x].push_back(y);\\n                }\\n                else{\\n                    //if we don\\'t find ingredient in map we will mark visit as -1 \\n                    visit[x]=-1;\\n                }\\n            }\\n        }\\n\\n        /*visit[i]==2 means it is under process till the recepie has not been made*/\\n        vector<string> res;\\n\\n        for(int i=0;i<recipes.size();i++){\\n            int node = mp[recipes[i]];\\n            //if not possible to make we will continue to next recipe\\n            if(visit[node]==-1) continue;\\n            //if it is possible to make we will add it to our result\\n            if(visit[node]==1){\\n                res.push_back(recipes[i]);\\n                continue;\\n            }\\n            //is not made we will make a dfs call\\n            if(dfs(node,adj,visit)==false){\\n                visit[node]=-1;\\n                continue;\\n            }\\n            else{\\n                //if dfs call is made and if it return true it means we can make the recipe\\n                visit[node]=1;\\n                res.push_back(recipes[i]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(int node,vector<int> adj[],vector<int> &visit){\\n        visit[node] = 2;\\n        for(auto it : adj[node]){\\n            if(visit[it] == -1){\\n                return false;\\n            }\\n    /*If visit[it]==2 means ingredient \"a\" require \"b\" to be made & \"b\" require \"a\" to be made*/\\n            if(visit[it] == 2){\\n                visit[it] = -1;\\n                return false;\\n            }\\n            if(visit[it] == 0){\\n                if(dfs(it , adj , visit) == false){\\n                    visit[it] = -1;\\n                    return false;\\n                }\\n            }\\n        }\\n        /*If all ingredients are present it is apossible to make tha recipe so we will\\n        make visit[node] as 1*/\\n        visit[node]=1;\\n        return true;\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        /*map stores unique number for unique word */\\n        unordered_map<string,int> mp;\\n        int n=0;\\n        for(int i = 0; i < supplies.size() ; i++){\\n            if(mp.find(supplies[i]) == mp.end()){\\n                mp[supplies[i]] = n;\\n                n++;\\n            }\\n        }\\n        for(int i = 0 ; i < recipes.size() ; i++){\\n            if(mp.find(recipes[i]) == mp.end()){\\n                mp[recipes[i]] = n;\\n                n++;\\n            }\\n        }\\n        /*Creating adjacency list */\\n        vector<int> adj[n];\\n        vector<int> visit(n,0);\\n        for(int i = 0 ; i < recipes.size() ; i++){\\n            int x = mp[recipes[i]];\\n            for(int j = 0 ; j < ingredients[i].size() ; j++){\\n                //if we find ingredient in map we will add to adj list\\n                if(mp.find(ingredients[i][j])!=mp.end()){\\n                    int y = mp[ingredients[i][j]];\\n                    adj[x].push_back(y);\\n                }\\n                else{\\n                    //if we don\\'t find ingredient in map we will mark visit as -1 \\n                    visit[x]=-1;\\n                }\\n            }\\n        }\\n\\n        /*visit[i]==2 means it is under process till the recepie has not been made*/\\n        vector<string> res;\\n\\n        for(int i=0;i<recipes.size();i++){\\n            int node = mp[recipes[i]];\\n            //if not possible to make we will continue to next recipe\\n            if(visit[node]==-1) continue;\\n            //if it is possible to make we will add it to our result\\n            if(visit[node]==1){\\n                res.push_back(recipes[i]);\\n                continue;\\n            }\\n            //is not made we will make a dfs call\\n            if(dfs(node,adj,visit)==false){\\n                visit[node]=-1;\\n                continue;\\n            }\\n            else{\\n                //if dfs call is made and if it return true it means we can make the recipe\\n                visit[node]=1;\\n                res.push_back(recipes[i]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3699971,
                "title": "topological-sort-bfs-c",
                "content": "# if it Helps You. Please Upvote Me...\\uD83E\\uDDE1\\uD83E\\uDD0D\\uD83D\\uDC9A\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirstly check all the recipes are **possible to cook** or not after that just find the **toposort** using **BFS Traversal**.\\n\\n# Complexity\\n- Time complexity:O(n * m)(check valid recipes)+O(n * n-1)(toposort)\\n- n = number of recipes \\n- m = number of ingredients\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N*M)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> available_recipes,suppingd,isvalid,indeg;\\n    unordered_map<string,vector<string>> adj;\\n    vector<string> ans;\\n    void solve(vector<string>& r,vector<vector<string>>& ingd, vector<string>& supp,int n)\\n    {\\n        queue<string> q;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(indeg.find(r[i])==indeg.end() && isvalid.find(r[i])==isvalid.end())\\n            q.push(r[i]);\\n        }\\n\\n        while(!q.empty())\\n        {\\n            string s = q.front();\\n            q.pop();\\n            ans.push_back(s);\\n\\n            for(auto x : adj[s])\\n            {\\n                if(indeg.find(x)!=indeg.end() && isvalid.find(x)==isvalid.end())\\n                {\\n                   indeg[x]--; \\n                   if(indeg[x]==0)\\n                   q.push(x); \\n                }  \\n            }\\n        }\\n    }\\n    vector<string> findAllRecipes(vector<string>& r, vector<vector<string>>& ingd, vector<string>& supp) {\\n        int n = r.size();\\n        for(int i = 0;i<r.size();i++)\\n        available_recipes[r[i]] = 1;\\n\\n        for(int i = 0;i<supp.size();i++)\\n        suppingd[supp[i]] = 1;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(auto x : ingd[i])\\n            {\\n                if(suppingd[x]!=1)\\n                {\\n                    if(available_recipes[x]==1)\\n                    {\\n                      adj[x].push_back(r[i]);\\n                      indeg[r[i]]++;  \\n                    }\\n                    else \\n                    isvalid[r[i]] = 0;\\n                }\\n            }\\n        }\\n\\n        solve(r,ingd,supp,n);\\n        return ans;   \\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/4e2895ca-755d-408c-bf62-3f269653441a_1688118948.2365866.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,int> available_recipes,suppingd,isvalid,indeg;\\n    unordered_map<string,vector<string>> adj;\\n    vector<string> ans;\\n    void solve(vector<string>& r,vector<vector<string>>& ingd, vector<string>& supp,int n)\\n    {\\n        queue<string> q;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(indeg.find(r[i])==indeg.end() && isvalid.find(r[i])==isvalid.end())\\n            q.push(r[i]);\\n        }\\n\\n        while(!q.empty())\\n        {\\n            string s = q.front();\\n            q.pop();\\n            ans.push_back(s);\\n\\n            for(auto x : adj[s])\\n            {\\n                if(indeg.find(x)!=indeg.end() && isvalid.find(x)==isvalid.end())\\n                {\\n                   indeg[x]--; \\n                   if(indeg[x]==0)\\n                   q.push(x); \\n                }  \\n            }\\n        }\\n    }\\n    vector<string> findAllRecipes(vector<string>& r, vector<vector<string>>& ingd, vector<string>& supp) {\\n        int n = r.size();\\n        for(int i = 0;i<r.size();i++)\\n        available_recipes[r[i]] = 1;\\n\\n        for(int i = 0;i<supp.size();i++)\\n        suppingd[supp[i]] = 1;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(auto x : ingd[i])\\n            {\\n                if(suppingd[x]!=1)\\n                {\\n                    if(available_recipes[x]==1)\\n                    {\\n                      adj[x].push_back(r[i]);\\n                      indeg[r[i]]++;  \\n                    }\\n                    else \\n                    isvalid[r[i]] = 0;\\n                }\\n            }\\n        }\\n\\n        solve(r,ingd,supp,n);\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585977,
                "title": "best-topologicalsorting-question-c-solution-toposort-best-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nall the indegredients are the prerequisites of the recieps[i]\\nall the supplies have indegree 0\\nall the indegree have some indegree positive \\n\\nafter toposort i may be not be not be able to make all the \\nindegree[recipes[i]] = 0....because there will be some nodes which are not my supplies actually ....i will think all the supplies[i] \\nwith indegree equal to 0....all the nodes which are not supplies are not the nodes of the initial queue means are not nodes with indegree equal to 0\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        unordered_map<string,int> indegree;\\n        unordered_map<string,vector<string>> adj;\\n        int n = ingredients.size();\\n        for(int i=0;i<n;i++){\\n            for(auto s : ingredients[i]){\\n                adj[s].push_back(recipes[i]);\\n                indegree[recipes[i]]++;\\n            }\\n        }\\n        //only the recieps[i]  have the positive indegrees\\n        //after removing edges if the indegree[recipes[i]] == 0\\n        //means current recipes[i] can be preformed by the present nodes\\n\\n\\n\\n        //something before something always think about the toposorting once \\n        //ingredients of the supplies are 0;\\n        queue<string> q;\\n        for(auto it : supplies){\\n            q.push(it);\\n        }\\n        vector<string> ans;\\n        while(q.empty() == false){\\n            string  node = q.front();\\n            q.pop();\\n            for(auto adjnode : adj[node]){\\n                indegree[adjnode]--;\\n                if(indegree[adjnode] == 0){\\n                    q.push(adjnode);\\n                }\\n            }\\n        }\\n        //if indegree[recipes[i]] == 0 ...means i made it to the final \\n        for(string r : recipes){\\n            if(indegree[r] == 0){\\n                ans.push_back(r);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        unordered_map<string,int> indegree;\\n        unordered_map<string,vector<string>> adj;\\n        int n = ingredients.size();\\n        for(int i=0;i<n;i++){\\n            for(auto s : ingredients[i]){\\n                adj[s].push_back(recipes[i]);\\n                indegree[recipes[i]]++;\\n            }\\n        }\\n        //only the recieps[i]  have the positive indegrees\\n        //after removing edges if the indegree[recipes[i]] == 0\\n        //means current recipes[i] can be preformed by the present nodes\\n\\n\\n\\n        //something before something always think about the toposorting once \\n        //ingredients of the supplies are 0;\\n        queue<string> q;\\n        for(auto it : supplies){\\n            q.push(it);\\n        }\\n        vector<string> ans;\\n        while(q.empty() == false){\\n            string  node = q.front();\\n            q.pop();\\n            for(auto adjnode : adj[node]){\\n                indegree[adjnode]--;\\n                if(indegree[adjnode] == 0){\\n                    q.push(adjnode);\\n                }\\n            }\\n        }\\n        //if indegree[recipes[i]] == 0 ...means i made it to the final \\n        for(string r : recipes){\\n            if(indegree[r] == 0){\\n                ans.push_back(r);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918853,
                "title": "c-topological-sort-khans-algorithm",
                "content": "**Example** :\\n1. Recipes : [ bread, sandwich ] \\n2. Ingredients : [ [ yeast, flour ], [ bread, meat ] ]\\n3. Supplies : [ yeast, flour, meat ] \\n\\n\\n**Adj Map** : \\n1. yeast -> bread \\n2. flour -> bread\\n3. bread -> sandwich \\n4. meat -> sandwich \\n\\n**Indegree Map** : \\n1. Bread -> 2\\n2. Sandwich -> 2\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\tvector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n\\t\\t\\t\\t// Topological Sort - Khans Algorithm \\n        \\n\\t\\t\\tmap< string, vector< string > > adj; // make a map of all recipes that contains the particular ingredient \\n\\t\\t\\tmap< string, int > inDegree;         // make a map of all recipes indegree\\n        \\n\\t\\t\\tfor( int i = 0; i < ingredients.size(); i++ ){\\n\\t\\t\\t\\tfor( int j = 0; j < ingredients[i].size(); j++ ){\\n\\t\\t\\t\\t\\tadj[ ingredients[i][j] ].push_back( recipes[i] );\\n\\t\\t\\t\\t\\tinDegree[ recipes[i] ] ++ ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tqueue< string > q;          // push all supplies into queue\\n\\t\\t\\tfor( int i = 0; i < supplies.size(); i++ ){\\n\\t\\t\\t\\tq.push( supplies[i] );\\n\\t\\t\\t}\\n\\t\\t\\tvector< string > ans;\\n        \\n\\t\\t\\twhile( ! q.empty() ){            // Do Topological sort\\n\\t\\t\\t\\tauto front = q.front();      // Elements in Q contains ingredients only with Indegree 0 ;\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tfor( auto k : adj[front] ){  \\n\\t\\t\\t\\t\\tinDegree[k]--;           // For every conneted to Q ingredient , decrease the connected recipes indegree by 1 ;\\n\\t\\t\\t\\t\\tif( inDegree[k] == 0 ){  // If Indegree of Recipe becomes 0, it becomes an ingredient and add it to Queue\\n\\t\\t\\t\\t\\t\\tq.push( k );         // also add it to answer\\n\\t\\t\\t\\t\\t\\tans.push_back(k);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;   // Return answer that contains all the recipes that are prepared means their indegree is 0 ; \\n        \\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\tvector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n\\t\\t\\t\\t// Topological Sort - Khans Algorithm \\n        \\n\\t\\t\\tmap< string, vector< string > > adj; // make a map of all recipes that contains the particular ingredient \\n\\t\\t\\tmap< string, int > inDegree;         // make a map of all recipes indegree\\n        \\n\\t\\t\\tfor( int i = 0; i < ingredients.size(); i++ ){\\n\\t\\t\\t\\tfor( int j = 0; j < ingredients[i].size(); j++ ){\\n\\t\\t\\t\\t\\tadj[ ingredients[i][j] ].push_back( recipes[i] );\\n\\t\\t\\t\\t\\tinDegree[ recipes[i] ] ++ ;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2765842,
                "title": "crisp-n-clear-o-m-n-javascript-memory-5-24-meaningful-vars",
                "content": "Time Complexity: O(M*N)\\nSpace Complexity: O(N)\\n\\nRuntime: 2654 ms, faster than 5.24% of JavaScript online submissions for Find All Possible Recipes from Given Supplies.\\nMemory Usage: 67.8 MB, less than 5.24% of JavaScript online submissions for Find All Possible Recipes from Given Supplies.\\n```\\nvar findAllRecipes = function (recipes, ingredients, supplies) {\\n    const recipesConfig = (function () {\\n        const obj = {};\\n        for (let index = 0; index < recipes.length; index++) {\\n            obj[recipes[index]] = {};\\n            for (const iterator of ingredients[index]) {\\n                obj[recipes[index]][iterator] = true;\\n            }\\n        }\\n        return obj;\\n    })();\\n\\n    const suppliesConfig = (function () {\\n        const obj = {};\\n        for (let index = 0; index < supplies.length; index++) {\\n            obj[supplies[index]] = true;\\n        }\\n        return obj;\\n    })();\\n\\n    const outputConfig = {};\\n\\n    function canPrepare(recipe, requiredRecipe = {}) {\\n        if (outputConfig[recipe]) {\\n            return outputConfig[recipe].status;\\n        }\\n        for (const key in recipesConfig[recipe]) {\\n            if (recipesConfig[key]) {\\n                if (requiredRecipe[key]) {\\n                    return false;\\n                }\\n                requiredRecipe[key] = true;\\n                const response = canPrepare(key, requiredRecipe);\\n                if (!response) {\\n                    return false;\\n                }\\n            } else {\\n                if (!suppliesConfig[key]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    const output = [];\\n\\n    for (let index = 0; index < recipes.length; index++) {\\n        const recipe = recipes[index];\\n        const resp = canPrepare(recipe);\\n        if (!outputConfig[recipe]) {\\n            outputConfig[recipe] = {};\\n        }\\n        outputConfig[recipe].status = resp;\\n        if (resp) {\\n            output.push(recipe);\\n        }\\n    }\\n\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar findAllRecipes = function (recipes, ingredients, supplies) {\\n    const recipesConfig = (function () {\\n        const obj = {};\\n        for (let index = 0; index < recipes.length; index++) {\\n            obj[recipes[index]] = {};\\n            for (const iterator of ingredients[index]) {\\n                obj[recipes[index]][iterator] = true;\\n            }\\n        }\\n        return obj;\\n    })();\\n\\n    const suppliesConfig = (function () {\\n        const obj = {};\\n        for (let index = 0; index < supplies.length; index++) {\\n            obj[supplies[index]] = true;\\n        }\\n        return obj;\\n    })();\\n\\n    const outputConfig = {};\\n\\n    function canPrepare(recipe, requiredRecipe = {}) {\\n        if (outputConfig[recipe]) {\\n            return outputConfig[recipe].status;\\n        }\\n        for (const key in recipesConfig[recipe]) {\\n            if (recipesConfig[key]) {\\n                if (requiredRecipe[key]) {\\n                    return false;\\n                }\\n                requiredRecipe[key] = true;\\n                const response = canPrepare(key, requiredRecipe);\\n                if (!response) {\\n                    return false;\\n                }\\n            } else {\\n                if (!suppliesConfig[key]) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    const output = [];\\n\\n    for (let index = 0; index < recipes.length; index++) {\\n        const recipe = recipes[index];\\n        const resp = canPrepare(recipe);\\n        if (!outputConfig[recipe]) {\\n            outputConfig[recipe] = {};\\n        }\\n        outputConfig[recipe].status = resp;\\n        if (resp) {\\n            output.push(recipe);\\n        }\\n    }\\n\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2702364,
                "title": "python-solution-using-topological-sort",
                "content": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        degree=defaultdict(int)\\n        supplies=set(supplies)\\n        g=defaultdict(list)\\n        for j,i in enumerate(ingredients):\\n            for ing in i:\\n                if ing not in supplies:\\n                    g[ing].append(recipes[j])\\n                    degree[recipes[j]]+=1\\n        q=deque()\\n        for rec in recipes:\\n            if degree[rec]==0:\\n                q.append(rec)\\n        ans=[]\\n        while q:\\n            cur=q.popleft()\\n            ans.append(cur)\\n            for i in g[cur]:\\n                degree[i]-=1\\n                if degree[i]==0:\\n                    q.append(i)\\n        return ans      \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        degree=defaultdict(int)\\n        supplies=set(supplies)\\n        g=defaultdict(list)\\n        for j,i in enumerate(ingredients):\\n            for ing in i:\\n                if ing not in supplies:\\n                    g[ing].append(recipes[j])\\n                    degree[recipes[j]]+=1\\n        q=deque()\\n        for rec in recipes:\\n            if degree[rec]==0:\\n                q.append(rec)\\n        ans=[]\\n        while q:\\n            cur=q.popleft()\\n            ans.append(cur)\\n            for i in g[cur]:\\n                degree[i]-=1\\n                if degree[i]==0:\\n                    q.append(i)\\n        return ans      \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483545,
                "title": "cpp-topological-sort",
                "content": "**Topological sort**\\n\\nApproach\\n\\n1. Ingredients are mappped to thier respective recipes, form a graph usinng this.\\n2. All the elements in the supplies have 0 indegree because they are not dependent on any other ingredient or recipe. \\n3. Topo sort\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        unordered_map<string,vector<string>> graph; \\n        unordered_map<string,int> indegree ;\\n        \\n        //forming graph\\n        for(int i=0; i<ingredients.size(); i++){\\n            for(int j=0; j<ingredients[i].size(); j++){\\n                graph[ingredients[i][j]].push_back(recipes[i]) ;\\n                indegree[recipes[i]]++ ;\\n            }\\n        }\\n        \\n        queue<string> q;\\n        vector<string> ans ;\\n        for(int i=0; i<supplies.size(); i++){\\n            q.push(supplies[i]) ;\\n        }\\n        \\n        while(!q.empty()){\\n            string node = q.front() ;\\n            q.pop() ;\\n            \\n            for(auto it: graph[node]){\\n                indegree[it]-- ;\\n                if(indegree[it] == 0){\\n                    q.push(it) ;\\n                    ans.push_back(it) ;\\n                }\\n            }\\n        }\\n  \\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        unordered_map<string,vector<string>> graph; \\n        unordered_map<string,int> indegree ;\\n        \\n        //forming graph\\n        for(int i=0; i<ingredients.size(); i++){\\n            for(int j=0; j<ingredients[i].size(); j++){\\n                graph[ingredients[i][j]].push_back(recipes[i]) ;\\n                indegree[recipes[i]]++ ;\\n            }\\n        }\\n        \\n        queue<string> q;\\n        vector<string> ans ;\\n        for(int i=0; i<supplies.size(); i++){\\n            q.push(supplies[i]) ;\\n        }\\n        \\n        while(!q.empty()){\\n            string node = q.front() ;\\n            q.pop() ;\\n            \\n            for(auto it: graph[node]){\\n                indegree[it]-- ;\\n                if(indegree[it] == 0){\\n                    q.push(it) ;\\n                    ans.push_back(it) ;\\n                }\\n            }\\n        }\\n  \\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468489,
                "title": "no-fancy-algorithms-simple-and-easy-code",
                "content": "class Solution {\\npublic:\\n\\n    vector<string>ans;\\n    bool dfs(map<string,bool>&mp,map<string,bool>&supply,map<string,bool>&vis,string s,map<string,vector<string>>&ing)\\n    {\\n        if(vis[s])\\n            return mp[s];\\n        vis[s]=true;\\n        vector<bool>scheck(ing[s].size(),false);\\n        for(int i=0;i<ing[s].size();i++)\\n        {\\n            string a=ing[s][i];\\n            if(supply.count(a))\\n            {\\n                scheck[i]=true;\\n            }\\n            else if(mp.count(a))\\n            {\\n                if(mp[a])\\n                    scheck[i]=true;\\n                else\\n                {\\n                    if(dfs(mp,supply,vis,a,ing))\\n                        scheck[i]=true;\\n                    else\\n                        return false;\\n                }\\n            }\\n            else\\n                return false;\\n        }\\n        for(int i=0;i<ing[s].size();i++)\\n        {\\n            if(scheck[i]==false)\\n                return false;\\n        }\\n        return mp[s]=true;\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        map<string,bool>mp;\\n        for(auto i:recipes)\\n        {\\n            mp[i]=false;\\n        }\\n        map<string,bool>supply;\\n        for(auto i:supplies)\\n        {\\n            supply[i]=true;\\n            if(mp.count(i))\\n                mp[i]=true;\\n        }\\n        map<string,vector<string>>ing;\\n        for(int i=0;i<recipes.size();i++)\\n        {\\n            string a=recipes[i];\\n            auto j=ingredients[i];\\n            ing[a]=j;\\n        }\\n        for(int i=0;i<recipes.size();i++)\\n        {\\n            map<string,bool>vis;\\n        for(auto i:recipes)\\n            vis[i]=false;\\n            dfs(mp,supply,vis,recipes[i],ing);\\n        }\\n        for(auto i:mp)\\n        {\\n            if(i.second)\\n                ans.push_back(i.first);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<string>ans;\\n    bool dfs(map<string,bool>&mp,map<string,bool>&supply,map<string,bool>&vis,string s,map<string,vector<string>>&ing)\\n    {\\n        if(vis[s])\\n            return mp[s];\\n        vis[s]=true;\\n        vector<bool>scheck(ing[s].size(),false);\\n        for(int i=0;i<ing[s].size();i++)\\n        {\\n            string a=ing[s][i];\\n            if(supply.count(a))\\n            {\\n                scheck[i]=true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2321593,
                "title": "c-using-topological-sorting-approach-given",
                "content": "Create a Adj map to map the ingerdients with recipes and indeg map to store the indegree of recipes.\\n\\n**Approach->** \\nIf the ingredients are not present in supplies then add the resepctive recipe of that ingredient and increase there indegree by 1.\\nThen use the Topological sorting approach to collect all the zero indeg nodes and add them to the ans.\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>>adj;\\n    unordered_map<string,int> indeg;\\n    unordered_set<string> str;\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n=recipes.size();\\n        vector<string> ans;\\n        \\n        for (auto &e : supplies) str.insert(e);\\n        for(auto& e:recipes)\\n        {\\n            indeg[e]=0;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n\\t\\t\\tfor (int j = 0; j < ingredients[i].size(); ++j) {\\n\\t\\t\\t\\tstring u = recipes[i], v = ingredients[i][j];\\n                \\n                if(str.find(v)==str.end())\\n                {\\n                    indeg[u]++;\\n                    adj[v].push_back(u);\\n                }\\n            }\\n        }\\n        \\n        queue<string> q;\\n        \\n        for(auto& i:recipes)\\n        {\\n            if(indeg[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(q.size()>0)\\n        {\\n            string s=q.front();\\n            q.pop();\\n            ans.push_back(s);\\n            for(auto& e:adj[s])\\n            {\\n                if(--indeg[e]==0)\\n                    q.push(e);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<string,vector<string>>adj;\\n    unordered_map<string,int> indeg;\\n    unordered_set<string> str;\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n=recipes.size();\\n        vector<string> ans;\\n        \\n        for (auto &e : supplies) str.insert(e);\\n        for(auto& e:recipes)\\n        {\\n            indeg[e]=0;\\n        }\\n        for (int i = 0; i < n; ++i) {\\n\\t\\t\\tfor (int j = 0; j < ingredients[i].size(); ++j) {\\n\\t\\t\\t\\tstring u = recipes[i], v = ingredients[i][j];\\n                \\n                if(str.find(v)==str.end())\\n                {\\n                    indeg[u]++;\\n                    adj[v].push_back(u);\\n                }\\n            }\\n        }\\n        \\n        queue<string> q;\\n        \\n        for(auto& i:recipes)\\n        {\\n            if(indeg[i]==0)\\n                q.push(i);\\n        }\\n        \\n        while(q.size()>0)\\n        {\\n            string s=q.front();\\n            q.pop();\\n            ans.push_back(s);\\n            for(auto& e:adj[s])\\n            {\\n                if(--indeg[e]==0)\\n                    q.push(e);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2274436,
                "title": "python-topological-sort-kahn-s-algorithm-time-o-v-e-space-o-v",
                "content": "Simple implementation of Kahn\\'s algorithm. The answer is the indegrees equal to 0. If, by the end of the queue, you have a recipe in there with 1 or more incoming edges, then it means you didn\\'t have all the necessary supplies or ingredients for that specific recipe\\n\\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        # Create a graph and an indegree to hold your adjacency and counts, respectively.\\n        graph = collections.defaultdict(list)\\n        indegree = collections.defaultdict(int)\\n        \\n        # Cycle through each recipe, grab the related ingredients, and add the edges to the graph.\\n        # Also increase the indegree for that recipe for each ingredient.\\n        for index, recipe in enumerate(recipes):\\n            for ingredient in ingredients[index]:\\n                graph[ingredient].append(recipe)\\n                indegree[recipe] += 1\\n        \\n        # Supplies are the starting point (i.e. they would have an indegree == 0)\\n        queue = deque(supplies)\\n        \\n        while queue:\\n            # Remove the first ingredient and cycle through the related mapping which holds the list of edges this ingredient connects to.\\n            current_ingredient = queue.popleft()\\n            while graph[current_ingredient]:\\n                # Remove the ingredient from the recipe mapping, and update the indegree. \\n                # If the indegree is zero you can add it to the queue.\\n                recipe = graph[current_ingredient].pop()\\n                # This is a safety check for ingredients from our supply that are never used in any of the recipes.\\n                # Though, a defaultdict would handle this, and our return list comprehension would only find elements with a parity of 0.\\n                if recipe in indegree: \\n                    indegree[recipe] -= 1\\n                \\n                if indegree[recipe] == 0:\\n                    queue.append(recipe)\\n        # When the queue is exhausted, we return a list of all recipes with an indegree of 0\\n        return [key for key in indegree if indegree[key] == 0]\\n                \\n                \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        # Create a graph and an indegree to hold your adjacency and counts, respectively.\\n        graph = collections.defaultdict(list)\\n        indegree = collections.defaultdict(int)\\n        \\n        # Cycle through each recipe, grab the related ingredients, and add the edges to the graph.\\n        # Also increase the indegree for that recipe for each ingredient.\\n        for index, recipe in enumerate(recipes):\\n            for ingredient in ingredients[index]:\\n                graph[ingredient].append(recipe)\\n                indegree[recipe] += 1\\n        \\n        # Supplies are the starting point (i.e. they would have an indegree == 0)\\n        queue = deque(supplies)\\n        \\n        while queue:\\n            # Remove the first ingredient and cycle through the related mapping which holds the list of edges this ingredient connects to.\\n            current_ingredient = queue.popleft()\\n            while graph[current_ingredient]:\\n                # Remove the ingredient from the recipe mapping, and update the indegree. \\n                # If the indegree is zero you can add it to the queue.\\n                recipe = graph[current_ingredient].pop()\\n                # This is a safety check for ingredients from our supply that are never used in any of the recipes.\\n                # Though, a defaultdict would handle this, and our return list comprehension would only find elements with a parity of 0.\\n                if recipe in indegree: \\n                    indegree[recipe] -= 1\\n                \\n                if indegree[recipe] == 0:\\n                    queue.append(recipe)\\n        # When the queue is exhausted, we return a list of all recipes with an indegree of 0\\n        return [key for key in indegree if indegree[key] == 0]\\n                \\n                \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219629,
                "title": "java-concise-topological-sort",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashMap<String, List<String>> adjMap = new HashMap<>();\\n        HashMap<String, Integer> indegree = new HashMap<>();\\n        for(int i=0; i<recipes.length; i++) {\\n            for(String ingredient: ingredients.get(i)) {\\n                adjMap.putIfAbsent(ingredient, new ArrayList<>());\\n                adjMap.get(ingredient).add(recipes[i]);\\n            }\\n            indegree.putIfAbsent(recipes[i], ingredients.get(i).size());\\n        }\\n        Queue<String> q = new LinkedList<>();\\n        for(String supply: supplies) {\\n            q.offer(supply);\\n        }\\n        List<String> recipesCanBeFormed = new ArrayList<>();\\n        while(!q.isEmpty()) {\\n            String ingredient = q .poll();\\n            if(adjMap.containsKey(ingredient)) {\\n                 for(String recipe: adjMap.get(ingredient)) {\\n                     indegree.put(recipe, indegree.get(recipe)-1);\\n                     if(indegree.get(recipe) == 0){\\n                         q.offer(recipe);\\n                         recipesCanBeFormed.add(recipe);\\n                     }\\n                 }\\n            }\\n           \\n        }\\n      return recipesCanBeFormed;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashMap<String, List<String>> adjMap = new HashMap<>();\\n        HashMap<String, Integer> indegree = new HashMap<>();\\n        for(int i=0; i<recipes.length; i++) {\\n            for(String ingredient: ingredients.get(i)) {\\n                adjMap.putIfAbsent(ingredient, new ArrayList<>());\\n                adjMap.get(ingredient).add(recipes[i]);\\n            }\\n            indegree.putIfAbsent(recipes[i], ingredients.get(i).size());\\n        }\\n        Queue<String> q = new LinkedList<>();\\n        for(String supply: supplies) {\\n            q.offer(supply);\\n        }\\n        List<String> recipesCanBeFormed = new ArrayList<>();\\n        while(!q.isEmpty()) {\\n            String ingredient = q .poll();\\n            if(adjMap.containsKey(ingredient)) {\\n                 for(String recipe: adjMap.get(ingredient)) {\\n                     indegree.put(recipe, indegree.get(recipe)-1);\\n                     if(indegree.get(recipe) == 0){\\n                         q.offer(recipe);\\n                         recipesCanBeFormed.add(recipe);\\n                     }\\n                 }\\n            }\\n           \\n        }\\n      return recipesCanBeFormed;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086794,
                "title": "c-solution-with-dfs",
                "content": "My solution use depth first search.\\n1. first we build a graph where the vertices include both unique ingredients and all recipes. We add an edge from U-> V if to make U(a recipe) you need V(some ingredient or recipe).\\n2. Now we can traverse this graph using dfs and determine whether or not the current node can be obtained. To know this, we just need to determine whether or not it is possible to obtain all V in the adjacency list of the current node.\\n\\nMy implementation is below.\\n```class Solution {\\nprivate: \\n    void traverse(const string& recipe, \\n                  unordered_set<string> &visited, \\n                  unordered_set<string> &supplies, \\n                  unordered_map<string, vector<string> > &adj){\\n        visited.insert(recipe);\\n        if (!adj.count(recipe)){\\n            return;\\n        }\\n        bool isGood=true;\\n        for(auto& ingr: adj[recipe]){\\n            if (!visited.count(ingr)){\\n                traverse(ingr, visited, supplies, adj);\\n            }\\n            isGood=isGood and supplies.count(ingr);\\n        }\\n        \\n        if (isGood){\\n            supplies.insert(recipe);\\n        }\\n    }\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, \\n                                  vector<vector<string>>& ingredients, \\n                                  vector<string>& supplies) {\\n        unordered_map<string, vector<string> > adj;\\n        for(int i=0; i<recipes.size(); i++){\\n            for(auto & ingredient: ingredients[i]){\\n                adj[recipes[i]].push_back(ingredient);\\n            }\\n        }\\n        \\n        unordered_set<string> supplies_set(supplies.begin(), supplies.end());\\n        unordered_set<string> visited;\\n        vector<string> good_recipes;        \\n        for(auto& recipe: recipes)\\n        {\\n            if (!visited.count(recipe)){\\n                traverse(recipe, visited, supplies_set, adj);\\n            }\\n            if (supplies_set.count(recipe)){\\n                good_recipes.push_back(recipe);\\n            }\\n        }\\n        \\n        return good_recipes;\\n        \\n    }\\n};\\n\\n/*\\n\\ntests/examples: \\n\\nnote: \\n\\nobservations:\\n\\nsolution:\\nidea 1: graph, directed graph  where the leaves are ingredients. Run some kind of search starting from the leaves.\\nidea 2: Replacing other recipes in ingredients list with their corresponding ingredients. (might be the same as idea 1)\\n\\n\\nV={}everything including recipes and ingredients.\\ngraph is directed.\\nWe have edge v->u if we need u to make v\\nRun a dfs on the DAG\\nTime complexity O(|recipes|+|sum of ingredients|+|supplies|)\\n*/\\n```\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```class Solution {\\nprivate: \\n    void traverse(const string& recipe, \\n                  unordered_set<string> &visited, \\n                  unordered_set<string> &supplies, \\n                  unordered_map<string, vector<string> > &adj){\\n        visited.insert(recipe);\\n        if (!adj.count(recipe)){\\n            return;\\n        }\\n        bool isGood=true;\\n        for(auto& ingr: adj[recipe]){\\n            if (!visited.count(ingr)){\\n                traverse(ingr, visited, supplies, adj);\\n            }\\n            isGood=isGood and supplies.count(ingr);\\n        }\\n        \\n        if (isGood){\\n            supplies.insert(recipe);\\n        }\\n    }\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, \\n                                  vector<vector<string>>& ingredients, \\n                                  vector<string>& supplies) {\\n        unordered_map<string, vector<string> > adj;\\n        for(int i=0; i<recipes.size(); i++){\\n            for(auto & ingredient: ingredients[i]){\\n                adj[recipes[i]].push_back(ingredient);\\n            }\\n        }\\n        \\n        unordered_set<string> supplies_set(supplies.begin(), supplies.end());\\n        unordered_set<string> visited;\\n        vector<string> good_recipes;        \\n        for(auto& recipe: recipes)\\n        {\\n            if (!visited.count(recipe)){\\n                traverse(recipe, visited, supplies_set, adj);\\n            }\\n            if (supplies_set.count(recipe)){\\n                good_recipes.push_back(recipe);\\n            }\\n        }\\n        \\n        return good_recipes;\\n        \\n    }\\n};\\n\\n/*\\n\\ntests/examples: \\n\\nnote: \\n\\nobservations:\\n\\nsolution:\\nidea 1: graph, directed graph  where the leaves are ingredients. Run some kind of search starting from the leaves.\\nidea 2: Replacing other recipes in ingredients list with their corresponding ingredients. (might be the same as idea 1)\\n\\n\\nV={}everything including recipes and ingredients.\\ngraph is directed.\\nWe have edge v->u if we need u to make v\\nRun a dfs on the DAG\\nTime complexity O(|recipes|+|sum of ingredients|+|supplies|)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2029152,
                "title": "python-topsort-look-for-the-bare-necessities-the-simple-bare-necessities",
                "content": "#### Walkthrough \\n\\nThe idea would be to construct a graph of ingredients, having in/out-bound edges represented by the \\'requires\\'/\\'produces\\' keys.\\n\\n```\\ngraph = {\\n \\'bread\\': {\\'requires\\': [\\'yeast\\', \\'flour\\']}, \\n \\'yeast\\': {\\'produces\\': [\\'bread\\']}, \\n \\'flour\\': {\\'produces\\': [\\'bread\\']}, \\n \\'corn\\': {\\'requires\\': []}\\n}\\n```\\n\\nThen, we apply the topsort algorithm. \\n\\nA queue of supplies (meaning nodes with in-degree 0) is provided, and it gets updated as we unlock new supplies.  Each ingredient currently in the queue will decrease the necessities of the other ingredients. This will happen if it \\'produces\\' something.  `nei` is a shortcut for a neighbor.\\n```\\nif \\'produces\\' in graph[node]:\\n\\tfor nei in graph[node][\\'produces\\']:\\n\\t\\t# try to decrease other dependencies\\n```\\n\\nWhen an ingredient \\'requires\\' no more ingredients, it becomes part of the queue and the unlocked supplies.\\n```\\nif len(graph[nei][\\'requires\\']) == 0:\\n\\tqueue.append(nei)\\n\\tunlocked_supplies.append(nei)\\n```\\n\\n### Solution\\n\\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        def topsort(graph, supplies):\\n            queue = deepcopy(supplies)\\n            unlocked_supplies = []\\n            \\n            while len(queue) > 0:\\n                node = queue.pop(0)\\n                if \\'produces\\' in graph[node]:\\n                    for nei in graph[node][\\'produces\\']:\\n                        idx = graph[nei][\\'requires\\'].index(node)\\n                        graph[nei][\\'requires\\'].pop(idx)\\n                        if len(graph[nei][\\'requires\\']) == 0:\\n                            queue.append(nei)\\n                            unlocked_supplies.append(nei)\\n            \\n            return unlocked_supplies\\n        \\n        graph = defaultdict(dict)\\n        for recipe_name, ingredients_list in zip(recipes, ingredients):\\n            graph[recipe_name][\\'requires\\'] = ingredients_list\\n            for i in ingredients_list:\\n                if \\'produces\\' not in graph[i]:\\n                    graph[i][\\'produces\\'] = [recipe_name]\\n                else:\\n                    graph[i][\\'produces\\'].append(recipe_name)\\n            \\n        for ingredient in supplies:\\n            if ingredient not in graph:\\n                graph[ingredient][\\'requires\\'] = []\\n            \\n        return topsort(graph, supplies)\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\ngraph = {\\n \\'bread\\': {\\'requires\\': [\\'yeast\\', \\'flour\\']}, \\n \\'yeast\\': {\\'produces\\': [\\'bread\\']}, \\n \\'flour\\': {\\'produces\\': [\\'bread\\']}, \\n \\'corn\\': {\\'requires\\': []}\\n}\\n```\n```\\nif \\'produces\\' in graph[node]:\\n\\tfor nei in graph[node][\\'produces\\']:\\n\\t\\t# try to decrease other dependencies\\n```\n```\\nif len(graph[nei][\\'requires\\']) == 0:\\n\\tqueue.append(nei)\\n\\tunlocked_supplies.append(nei)\\n```\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        def topsort(graph, supplies):\\n            queue = deepcopy(supplies)\\n            unlocked_supplies = []\\n            \\n            while len(queue) > 0:\\n                node = queue.pop(0)\\n                if \\'produces\\' in graph[node]:\\n                    for nei in graph[node][\\'produces\\']:\\n                        idx = graph[nei][\\'requires\\'].index(node)\\n                        graph[nei][\\'requires\\'].pop(idx)\\n                        if len(graph[nei][\\'requires\\']) == 0:\\n                            queue.append(nei)\\n                            unlocked_supplies.append(nei)\\n            \\n            return unlocked_supplies\\n        \\n        graph = defaultdict(dict)\\n        for recipe_name, ingredients_list in zip(recipes, ingredients):\\n            graph[recipe_name][\\'requires\\'] = ingredients_list\\n            for i in ingredients_list:\\n                if \\'produces\\' not in graph[i]:\\n                    graph[i][\\'produces\\'] = [recipe_name]\\n                else:\\n                    graph[i][\\'produces\\'].append(recipe_name)\\n            \\n        for ingredient in supplies:\\n            if ingredient not in graph:\\n                graph[ingredient][\\'requires\\'] = []\\n            \\n        return topsort(graph, supplies)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023973,
                "title": "python-topological-sort-with-inline-explanation",
                "content": "```python\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n\\t    # Build a graph where vertices are ingredients and recipes \\n        # and edges are in the form of <ingredient | recipe> -> recipe\\n        graph = defaultdict(set)\\n        indegree = defaultdict(int)\\n\\t\\t# O(R+I) where R is number of recipes and I is the max number of supplies for any given recipe\\n        for recipe, ingredient in zip(recipes, ingredients):\\n            for supply in ingredient:\\n                graph[supply].add(recipe)\\n                indegree[recipe] += 1\\n        \\n\\t\\t# First use all supplies to cook all the possible recipes\\n\\t\\t# O(S+R+I)\\n        for supply in supplies:\\n            for recipe in graph[supply]:\\n                indegree[recipe] -= 1\\n        \\n        # these are the recipes we can cook directly from the given supplies\\n        recipes_with_zero_in_degree = [recipe for recipe in indegree if not indegree[recipe]]\\n\\t\\t# Final answer include these as well\\n        ans = set(recipes_with_zero_in_degree)\\n        \\n        # now let\\'s see what are the recipes we can cook using the already cooked recipes\\n        # We do a DFS where at each iteration we cook a recipe\\n\\t\\t# At each step if there is a new recipe we can cook (i.e., indegree=0) \\n\\t\\t# we add it back to the stack and the final answer\\n\\t\\t# O(R)\\n         while recipes_with_zero_in_degree:\\n            supply = recipes_with_zero_in_degree.pop()\\n            for recipe in graph[supply]:\\n                indegree[recipe] -= 1\\n                if not indegree[recipe]:\\n                    recipes_with_zero_in_degree.append(recipe)\\n                    ans.add(recipe)\\n                \\n        return ans\\n```\\n\\nTime complexity `O(R+I+S)` where `R` is the number of recipes, `I` is the max number of ingredients for any given recipe, and `S` is number of supplies.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```python\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n\\t    # Build a graph where vertices are ingredients and recipes \\n        # and edges are in the form of <ingredient | recipe> -> recipe\\n        graph = defaultdict(set)\\n        indegree = defaultdict(int)\\n\\t\\t# O(R+I) where R is number of recipes and I is the max number of supplies for any given recipe\\n        for recipe, ingredient in zip(recipes, ingredients):\\n            for supply in ingredient:\\n                graph[supply].add(recipe)\\n                indegree[recipe] += 1\\n        \\n\\t\\t# First use all supplies to cook all the possible recipes\\n\\t\\t# O(S+R+I)\\n        for supply in supplies:\\n            for recipe in graph[supply]:\\n                indegree[recipe] -= 1\\n        \\n        # these are the recipes we can cook directly from the given supplies\\n        recipes_with_zero_in_degree = [recipe for recipe in indegree if not indegree[recipe]]\\n\\t\\t# Final answer include these as well\\n        ans = set(recipes_with_zero_in_degree)\\n        \\n        # now let\\'s see what are the recipes we can cook using the already cooked recipes\\n        # We do a DFS where at each iteration we cook a recipe\\n\\t\\t# At each step if there is a new recipe we can cook (i.e., indegree=0) \\n\\t\\t# we add it back to the stack and the final answer\\n\\t\\t# O(R)\\n         while recipes_with_zero_in_degree:\\n            supply = recipes_with_zero_in_degree.pop()\\n            for recipe in graph[supply]:\\n                indegree[recipe] -= 1\\n                if not indegree[recipe]:\\n                    recipes_with_zero_in_degree.append(recipe)\\n                    ans.add(recipe)\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012920,
                "title": "simple-indegree-queue-bfs-c",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> findAllRecipes(vector<string> &recipes, vector<vector<string>> &ingredients, vector<string> &supplies)\\n    {\\n        map<string, vector<string>> adj;\\n        map<string, int> indegree;\\n        int cur_recepie = 0;\\n        for (auto it : ingredients)\\n        {\\n\\t\\t//in each iteration we move to another recepie and another list of ingridients\\n            for (auto i : it)\\n            {\\n                adj[i].push_back(recipes[cur_recepie]);\\n                indegree[recipes[cur_recepie]]++; //increase the indegree of i-th recepie\\n            }\\n            cur_recepie+=1; // just a pointer/ index to recepie, bcz it and i cannot give posoition/ value of recepie.\\n        }\\n        queue<string> q;\\n        vector<string> ans;\\n\\t\\t// insert all the supplies\\n\\t\\t// Note: a recepie will become supply when its indegree will become=0.\\n        for (auto it : supplies)\\n            q.push(it);\\n        string temp;\\n        while (!q.empty())\\n        {\\n            temp = q.front();\\n\\t\\t\\t// let temp=a, and a is needed to make b and c.\\n            q.pop();\\n            for (auto it : adj[temp])\\n            {\\n\\t\\t\\t// Since we got temp = a, then we have one ingridient a to make b and c\\n\\t\\t\\t// hence, we can reduce the indegrees of b and c, bcz we got one ingridinet a\\n\\t\\t\\t// when the indegrees of b and c becomes = 0, they are said to be prepared, and push them in ans.\\n\\t\\t\\t// also they can now act as supply, hence push them in queue, bcz these can be used to make other recepies.\\n                indegree[it]--;\\n                if (indegree[it] == 0)\\n                {\\n                    ans.push_back(it);\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<string> findAllRecipes(vector<string> &recipes, vector<vector<string>> &ingredients, vector<string> &supplies)\\n    {\\n        map<string, vector<string>> adj;\\n        map<string, int> indegree;\\n        int cur_recepie = 0;\\n        for (auto it : ingredients)\\n        {\\n\\t\\t//in each iteration we move to another recepie and another list of ingridients\\n            for (auto i : it)\\n            {\\n                adj[i].push_back(recipes[cur_recepie]);\\n                indegree[recipes[cur_recepie]]++; //increase the indegree of i-th recepie\\n            }\\n            cur_recepie+=1; // just a pointer/ index to recepie, bcz it and i cannot give posoition/ value of recepie.\\n        }\\n        queue<string> q;\\n        vector<string> ans;\\n\\t\\t// insert all the supplies\\n\\t\\t// Note: a recepie will become supply when its indegree will become=0.\\n        for (auto it : supplies)\\n            q.push(it);\\n        string temp;\\n        while (!q.empty())\\n        {\\n            temp = q.front();\\n\\t\\t\\t// let temp=a, and a is needed to make b and c.\\n            q.pop();\\n            for (auto it : adj[temp])\\n            {\\n\\t\\t\\t// Since we got temp = a, then we have one ingridient a to make b and c\\n\\t\\t\\t// hence, we can reduce the indegrees of b and c, bcz we got one ingridinet a\\n\\t\\t\\t// when the indegrees of b and c becomes = 0, they are said to be prepared, and push them in ans.\\n\\t\\t\\t// also they can now act as supply, hence push them in queue, bcz these can be used to make other recepies.\\n                indegree[it]--;\\n                if (indegree[it] == 0)\\n                {\\n                    ans.push_back(it);\\n                    q.push(it);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2007077,
                "title": "straightforward-topological-sort-solution",
                "content": "```\\nfrom collections import defaultdict, deque\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        graph = defaultdict(list)\\n        indeg = {}\\n        queue = deque(supplies)\\n        ans = []\\n        for rec, ing in zip(recipes, ingredients):\\n            in_d = 0\\n            for ingredient in ing:\\n                in_d += 1                       #for each ingredient increase indegree for recipe\\n                graph[ingredient].append(rec)   #build graph ingredient -> recipes\\n            indeg[rec] = in_d                   #indegree for recipes\\n        \\n        while queue:                            #regular topological Sort\\n            ingredient = queue.popleft()\\n            if ingredient in graph:\\n                for recipe in graph[ingredient]:\\n                    indeg[recipe] -= 1\\n                    if indeg[recipe] == 0:      #whenever dependencies reduce to 0, we can make the recipe\\n                        ans.append(recipe)      #add to ans    \\n                        queue.append(recipe)    #add to queue in case the recipe is ingredient for another recipe\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nfrom collections import defaultdict, deque\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        graph = defaultdict(list)\\n        indeg = {}\\n        queue = deque(supplies)\\n        ans = []\\n        for rec, ing in zip(recipes, ingredients):\\n            in_d = 0\\n            for ingredient in ing:\\n                in_d += 1                       #for each ingredient increase indegree for recipe\\n                graph[ingredient].append(rec)   #build graph ingredient -> recipes\\n            indeg[rec] = in_d                   #indegree for recipes\\n        \\n        while queue:                            #regular topological Sort\\n            ingredient = queue.popleft()\\n            if ingredient in graph:\\n                for recipe in graph[ingredient]:\\n                    indeg[recipe] -= 1\\n                    if indeg[recipe] == 0:      #whenever dependencies reduce to 0, we can make the recipe\\n                        ans.append(recipe)      #add to ans    \\n                        queue.append(recipe)    #add to queue in case the recipe is ingredient for another recipe\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1874453,
                "title": "c-topological-sort-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        queue<string> q;\\n\\t\\t\\n\\t\\t// this stores indegree of each recipes\\n        unordered_map<string,int> inorder;\\n\\t\\t//stores all the relations of graph whre it\\'s key will be some supply/recipe need for some recipe\\n        unordered_map<string,vector<string>> adj;\\n        vector<string> ans;\\n\\t\\t\\n\\t\\t//push every supply element in queue as it\\'s indegree will be already zero\\n        for(string s: supplies) q.push(s);\\n        \\n\\t\\t\\n        for(int i=0; i< recipes.size();i++){\\n            for(string str: ingredients[i]){\\n\\t\\t\\t//we are increasing indegree of each recipe according to no. of things needed for it\\n                inorder[recipes[i]]++;\\n\\t\\t\\t//we are pushing each recipe corresponding to ingredient \\n                adj[str].push_back(recipes[i]);\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            string curr = q.front();\\n            q.pop();\\n            for(string s: adj[curr]){\\n\\t\\t\\t\\n\\t\\t\\t//checking if indegree of recipe & pushing it in ans and que as it can be ingredient for some other recipe\\n                if(--inorder[s]==0){\\n                    ans.push_back(s);\\n                    q.push(s);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        queue<string> q;\\n\\t\\t\\n\\t\\t// this stores indegree of each recipes\\n        unordered_map<string,int> inorder;\\n\\t\\t//stores all the relations of graph whre it\\'s key will be some supply/recipe need for some recipe\\n        unordered_map<string,vector<string>> adj;\\n        vector<string> ans;\\n\\t\\t\\n\\t\\t//push every supply element in queue as it\\'s indegree will be already zero\\n        for(string s: supplies) q.push(s);\\n        \\n\\t\\t\\n        for(int i=0; i< recipes.size();i++){\\n            for(string str: ingredients[i]){\\n\\t\\t\\t//we are increasing indegree of each recipe according to no. of things needed for it\\n                inorder[recipes[i]]++;\\n\\t\\t\\t//we are pushing each recipe corresponding to ingredient \\n                adj[str].push_back(recipes[i]);\\n            }\\n        }\\n        \\n        while(!q.empty()){\\n            string curr = q.front();\\n            q.pop();\\n            for(string s: adj[curr]){\\n\\t\\t\\t\\n\\t\\t\\t//checking if indegree of recipe & pushing it in ans and que as it can be ingredient for some other recipe\\n                if(--inorder[s]==0){\\n                    ans.push_back(s);\\n                    q.push(s);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831461,
                "title": "python-hash-and-graph-coloring-method-100-time",
                "content": "```\\n\\tdef findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        # d: map from recipe to index\\n        d, n = {}, len(recipes)\\n        # state: None -> not checked; 1 -> success; 0 -> checking/failed\\n        state = [None] * n\\n        sp = set(supplies)\\n        \\n        for i in range(n):\\n            d[recipes[i]] = i\\n        \\n        def getRecipe(r):\\n            index = d[r]\\n            if state[index] is not None:\\n                return state[index]\\n            \\n            state[index], success = 0, True\\n            for ingre in ingredients[index]:\\n                if ingre in sp:\\n                    continue\\n                if ingre in d:\\n                    success = getRecipe(ingre) == 1\\n                    if not success:\\n                        break\\n                else:\\n                    success = False\\n                    break\\n\\n            state[index] = 1 if success else 0\\n            return state[index]\\n        \\n        for r in recipes:\\n            getRecipe(r)\\n        \\n        return [recipes[i] for i in range(n) if state[i] == 1]\\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        # d: map from recipe to index\\n        d, n = {}, len(recipes)\\n        # state: None -> not checked; 1 -> success; 0 -> checking/failed\\n        state = [None] * n\\n        sp = set(supplies)\\n        \\n        for i in range(n):\\n            d[recipes[i]] = i\\n        \\n        def getRecipe(r):\\n            index = d[r]\\n            if state[index] is not None:\\n                return state[index]\\n            \\n            state[index], success = 0, True\\n            for ingre in ingredients[index]:\\n                if ingre in sp:\\n                    continue\\n                if ingre in d:\\n                    success = getRecipe(ingre) == 1\\n                    if not success:\\n                        break\\n                else:\\n                    success = False\\n                    break\\n\\n            state[index] = 1 if success else 0\\n            return state[index]\\n        \\n        for r in recipes:\\n            getRecipe(r)\\n        \\n        return [recipes[i] for i in range(n) if state[i] == 1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1803206,
                "title": "java-topology-sort-same-as-course-schedule",
                "content": "Typical topology sort problem, if you are very familar with how to solve course schedule problem, this one should also be very easy. But maybe the code is still a little bit long\\n\\n```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        //topology sort\\n        Map<String, List<String>> ingre2recipes = new HashMap<>();\\n        Map<String, Integer> indegree = new HashMap<>();\\n        Set<String> recipeSet = new HashSet<>();\\n        \\n        for (int i = 0; i < recipes.length; i++) {\\n            String r = recipes[i];\\n            recipeSet.add(r);\\n            List<String> ingredientOfRecipe = ingredients.get(i);\\n            \\n            for (String ingredient : ingredientOfRecipe) {\\n                ingre2recipes.computeIfAbsent(ingredient, x -> new ArrayList<>()).add(r);\\n                indegree.put(r, indegree.getOrDefault(r, 0) + 1);\\n            }\\n        }\\n        \\n        Queue<String> q = new LinkedList<>();\\n        List<String> res = new ArrayList<>();\\n        \\n        for (String supply : supplies) q.offer(supply);\\n        \\n        while (!q.isEmpty()) {\\n            String curr = q.poll();\\n            if (recipeSet.contains(curr)) res.add(curr);\\n            \\n            if (ingre2recipes.containsKey(curr)) {\\n                for (String neighbor : ingre2recipes.get(curr)) {\\n                    int newIndegree = indegree.get(neighbor) - 1;\\n                    indegree.put(neighbor, newIndegree);\\n                    if (newIndegree == 0) q.offer(neighbor);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        //topology sort\\n        Map<String, List<String>> ingre2recipes = new HashMap<>();\\n        Map<String, Integer> indegree = new HashMap<>();\\n        Set<String> recipeSet = new HashSet<>();\\n        \\n        for (int i = 0; i < recipes.length; i++) {\\n            String r = recipes[i];\\n            recipeSet.add(r);\\n            List<String> ingredientOfRecipe = ingredients.get(i);\\n            \\n            for (String ingredient : ingredientOfRecipe) {\\n                ingre2recipes.computeIfAbsent(ingredient, x -> new ArrayList<>()).add(r);\\n                indegree.put(r, indegree.getOrDefault(r, 0) + 1);\\n            }\\n        }\\n        \\n        Queue<String> q = new LinkedList<>();\\n        List<String> res = new ArrayList<>();\\n        \\n        for (String supply : supplies) q.offer(supply);\\n        \\n        while (!q.isEmpty()) {\\n            String curr = q.poll();\\n            if (recipeSet.contains(curr)) res.add(curr);\\n            \\n            if (ingre2recipes.containsKey(curr)) {\\n                for (String neighbor : ingre2recipes.get(curr)) {\\n                    int newIndegree = indegree.get(neighbor) - 1;\\n                    indegree.put(neighbor, newIndegree);\\n                    if (newIndegree == 0) q.offer(neighbor);\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768876,
                "title": "c-dfs-cycle-detection-intuitive",
                "content": "```\\nclass Solution {\\n    map<string, vector<string>> gr;\\n    map<string, bool> dp;\\npublic:\\n\\n    bool dfs(string s, set<string> &vis)\\n    {\\n        if (vis.count(s))return false; // Deadlock/Cycle Detection  | s requring s to make it\\n        vis.insert(s);\\n\\n        if (dp.count(s)) {// if s is there in supplies or its answer already computed\\n            vis.erase(s);\\n            return dp[s];\\n        }\\n\\n        bool canMake = gr.count(s);\\n\\n        for (auto x : gr[s]) {\\n            canMake &= dfs(x, vis);\\n        }\\n\\n        vis.erase(s);\\n        return dp[s] = canMake;\\n    }\\n\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies)\\n    {\\n        for (int i = 0; i < recipes.size(); i++) {\\n            gr[recipes[i]] = ingredients[i];\\n        }\\n\\n        for (auto supplyItem : supplies) {\\n            dp[supplyItem] = true;\\n        }\\n\\n        vector<string> ans;\\n\\n        for (int i = 0; i < recipes.size(); i++) {\\n            set<string> vis;\\n            bool canMake = dfs(recipes[i], vis);\\n            if (canMake) {\\n                ans.push_back(recipes[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    map<string, vector<string>> gr;\\n    map<string, bool> dp;\\npublic:\\n\\n    bool dfs(string s, set<string> &vis)\\n    {\\n        if (vis.count(s))return false; // Deadlock/Cycle Detection  | s requring s to make it\\n        vis.insert(s);\\n\\n        if (dp.count(s)) {// if s is there in supplies or its answer already computed\\n            vis.erase(s);\\n            return dp[s];\\n        }\\n\\n        bool canMake = gr.count(s);\\n\\n        for (auto x : gr[s]) {\\n            canMake &= dfs(x, vis);\\n        }\\n\\n        vis.erase(s);\\n        return dp[s] = canMake;\\n    }\\n\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies)\\n    {\\n        for (int i = 0; i < recipes.size(); i++) {\\n            gr[recipes[i]] = ingredients[i];\\n        }\\n\\n        for (auto supplyItem : supplies) {\\n            dp[supplyItem] = true;\\n        }\\n\\n        vector<string> ans;\\n\\n        for (int i = 0; i < recipes.size(); i++) {\\n            set<string> vis;\\n            bool canMake = dfs(recipes[i], vis);\\n            if (canMake) {\\n                ans.push_back(recipes[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1654681,
                "title": "c-without-using-toposort-simple-approach",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n\\n\\n\\t\\t\\tunordered_set<string> st;\\n\\t\\t\\tfor(auto i: supplies){\\n\\t\\t\\t\\tst.insert(i);\\n\\t\\t\\t}\\n\\t\\t\\tqueue<int> q;\\n\\t\\t\\tfor(int i=0;i<recipes.size();i++){\\n\\t\\t\\t\\tq.push(i);\\n\\t\\t\\t}\\n\\t\\t\\tbool vis[recipes.size()];\\n\\t\\t\\tmemset(vis,false,sizeof vis);\\n\\n\\t\\t\\tbool keepIterating= true;\\n\\t\\t\\twhile(keepIterating){\\n\\t\\t\\t\\tkeepIterating= false;\\n\\t\\t\\t\\tqueue<int> dupq;\\n\\n\\t\\t\\t\\twhile(!q.empty()){\\n\\t\\t\\t\\t\\tint i= q.front();\\n\\t\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\t\\tbool fl= true;\\n\\n\\t\\t\\t\\t\\tfor(int j=0;j<ingredients[i].size();j++){\\n\\t\\t\\t\\t\\t\\tif(st.find(ingredients[i][j])==st.end()){\\n\\t\\t\\t\\t\\t\\t\\tfl= false;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif(fl){\\n\\t\\t\\t\\t\\t\\tst.insert(recipes[i]);\\n\\t\\t\\t\\t\\t\\tkeepIterating= true;\\n\\t\\t\\t\\t\\t\\tvis[i]= true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tdupq.push(i);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tq=dupq;\\n\\t\\t\\t}\\n\\t\\t\\tvector<string> ans;\\n\\t\\t\\tfor(int i=0;i<recipes.size();i++){\\n\\t\\t\\t\\tif(vis[i]){\\n\\t\\t\\t\\t\\tans.push_back(recipes[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n\\n\\n\\t\\t\\tunordered_set<string> st;\\n\\t\\t\\tfor(auto i: supplies){\\n\\t\\t\\t\\tst.insert(i);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1652864,
                "title": "c-toposort-kahn-s-algorithm-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        unordered_map<string, vector<string>> mp;\\n        int n = recipes.size();\\n        for(int i=0; i<n; i++){\\n            mp[recipes[i]] = ingredients[i];\\n        }\\n        set<string> st;\\n        for(auto &s : supplies){\\n            st.insert(s);\\n        }\\n        \\n        unordered_map<string, int> indegree;\\n        queue<string> q;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<ingredients[i].size(); j++){\\n                if(mp.count(ingredients[i][j])){\\n                    indegree[recipes[i]]++;\\n                }\\n            }\\n            if(indegree[recipes[i]] == 0){\\n                q.push(recipes[i]);\\n            }\\n        }\\n        vector<string> res;\\n        while(!q.empty()){\\n            string t = q.front();\\n            q.pop();\\n            \\n            bool flag = true;\\n            for(auto &it : mp[t]){\\n                if(!st.count(it)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                res.push_back(t);\\n                st.insert(t);\\n            }\\n            \\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<ingredients[i].size(); j++){\\n                    if(ingredients[i][j] == t){\\n                        indegree[recipes[i]]--;\\n                        if(indegree[recipes[i]] == 0){\\n                            q.push(recipes[i]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        unordered_map<string, vector<string>> mp;\\n        int n = recipes.size();\\n        for(int i=0; i<n; i++){\\n            mp[recipes[i]] = ingredients[i];\\n        }\\n        set<string> st;\\n        for(auto &s : supplies){\\n            st.insert(s);\\n        }\\n        \\n        unordered_map<string, int> indegree;\\n        queue<string> q;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<ingredients[i].size(); j++){\\n                if(mp.count(ingredients[i][j])){\\n                    indegree[recipes[i]]++;\\n                }\\n            }\\n            if(indegree[recipes[i]] == 0){\\n                q.push(recipes[i]);\\n            }\\n        }\\n        vector<string> res;\\n        while(!q.empty()){\\n            string t = q.front();\\n            q.pop();\\n            \\n            bool flag = true;\\n            for(auto &it : mp[t]){\\n                if(!st.count(it)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                res.push_back(t);\\n                st.insert(t);\\n            }\\n            \\n            for(int i=0; i<n; i++){\\n                for(int j=0; j<ingredients[i].size(); j++){\\n                    if(ingredients[i][j] == t){\\n                        indegree[recipes[i]]--;\\n                        if(indegree[recipes[i]] == 0){\\n                            q.push(recipes[i]);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647975,
                "title": "c-solution-using-kahn-s-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ing, vector<string>& supplies) {\\n        //unordered_map for creating graph\\n        unordered_map<string,vector<string>> graph;\\n        //another map for supplies\\n        unordered_map<string,int> sup;\\n        for(auto it : supplies)\\n        {\\n            sup[it]++;\\n        }\\n        int n = recipes.size();\\n        //indegree array\\n        unordered_map<string,int> indegree;\\n        for(auto it : recipes)\\n        {\\n            indegree[it]=0;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<ing[i].size();j++)\\n            {\\n                if(!sup[ing[i][j]])\\n                {\\n                    graph[ing[i][j]].push_back(recipes[i]);\\n                    indegree[recipes[i]]++;\\n                }\\n            }\\n        }\\n        //kahn\\'s algo\\n        queue<string> q;\\n        for(auto it : indegree)\\n        {\\n            if(it.second == 0)\\n            {\\n                q.push(it.first);\\n            }\\n        }\\n        vector<string> ans;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                string temp = q.front();\\n                q.pop();\\n                ans.push_back(temp);\\n                for(auto it : graph[temp])\\n                {\\n                    indegree[it]--;\\n                    if(indegree[it]==0)\\n                    {\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ing, vector<string>& supplies) {\\n        //unordered_map for creating graph\\n        unordered_map<string,vector<string>> graph;\\n        //another map for supplies\\n        unordered_map<string,int> sup;\\n        for(auto it : supplies)\\n        {\\n            sup[it]++;\\n        }\\n        int n = recipes.size();\\n        //indegree array\\n        unordered_map<string,int> indegree;\\n        for(auto it : recipes)\\n        {\\n            indegree[it]=0;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<ing[i].size();j++)\\n            {\\n                if(!sup[ing[i][j]])\\n                {\\n                    graph[ing[i][j]].push_back(recipes[i]);\\n                    indegree[recipes[i]]++;\\n                }\\n            }\\n        }\\n        //kahn\\'s algo\\n        queue<string> q;\\n        for(auto it : indegree)\\n        {\\n            if(it.second == 0)\\n            {\\n                q.push(it.first);\\n            }\\n        }\\n        vector<string> ans;\\n        while(!q.empty())\\n        {\\n            int sz = q.size();\\n            while(sz--)\\n            {\\n                string temp = q.front();\\n                q.pop();\\n                ans.push_back(temp);\\n                for(auto it : graph[temp])\\n                {\\n                    indegree[it]--;\\n                    if(indegree[it]==0)\\n                    {\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646917,
                "title": "java-recursive-dfs",
                "content": "```\\nclass Solution {\\n    List<String> l=new ArrayList<>();   //result\\n    Set<String> set=new HashSet<>();    \\n    Set<String> notSet=new HashSet<>(); \\n    public boolean dfs(String[] recipes, List<List<String>> ingredients,Map<String,Integer> m,int index,boolean[] vis){\\n        if(set.contains(recipes[index]))  //if we already know that recipe can be made\\n            return true;    \\n        \\n        if(notSet.contains(recipes[index])) //vice versa\\n            return false;\\n        \\n        if(vis[index])  //if there is a loop in recipies \\n            return false;\\n        \\n        vis[index]=true;    //make recipe visited\\n        \\n        for(String ing:ingredients.get(index)){ //check each ingredient of recipe\\n            if(!set.contains(ing)){ //if we don\\'t have ingredient in supplies\\n                if(m.containsKey(ing)){ //if ingredient is a recipe\\n                    if(!dfs(recipes,ingredients,m,m.get(ing),vis)){ //recurse for that recipe\\n                        notSet.add(recipes[m.get(ing)]);    //if false is returned add recipe to can\\'t make this recipe\\n                        return false;\\n                    }   \\n                }\\n                else{   //if recipe is not in supplies as well as in recipe\\n                    notSet.add(recipes[index]);\\n                    return false;\\n                }\\n            }\\n        }\\n        vis[index]=false;   //mark as unvisted while returning\\n        return true;    //return true if checked all ingredients\\n    }\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String,Integer> m=new HashMap<>();\\n        int n=recipes.length;\\n        boolean[] vis=new boolean[n];   //to check if there is a loop in recipies \\n        for(int i=0;i<recipes.length;i++){  //fill map to get index of recipe\\n            m.put(recipes[i],i);\\n        }\\n        \\n        for(String sup:supplies)    //make supplies set to check if ingredient is available\\n            set.add(sup);\\n        \\n        for(int i=0;i<recipes.length;i++){  //check each recipe\\n            if(dfs(recipes,ingredients,m,i,vis)){    //if dfs returns true add the to result             \\n                set.add(recipes[i]);\\n                l.add(recipes[i]);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<String> l=new ArrayList<>();   //result\\n    Set<String> set=new HashSet<>();    \\n    Set<String> notSet=new HashSet<>(); \\n    public boolean dfs(String[] recipes, List<List<String>> ingredients,Map<String,Integer> m,int index,boolean[] vis){\\n        if(set.contains(recipes[index]))  //if we already know that recipe can be made\\n            return true;    \\n        \\n        if(notSet.contains(recipes[index])) //vice versa\\n            return false;\\n        \\n        if(vis[index])  //if there is a loop in recipies \\n            return false;\\n        \\n        vis[index]=true;    //make recipe visited\\n        \\n        for(String ing:ingredients.get(index)){ //check each ingredient of recipe\\n            if(!set.contains(ing)){ //if we don\\'t have ingredient in supplies\\n                if(m.containsKey(ing)){ //if ingredient is a recipe\\n                    if(!dfs(recipes,ingredients,m,m.get(ing),vis)){ //recurse for that recipe\\n                        notSet.add(recipes[m.get(ing)]);    //if false is returned add recipe to can\\'t make this recipe\\n                        return false;\\n                    }   \\n                }\\n                else{   //if recipe is not in supplies as well as in recipe\\n                    notSet.add(recipes[index]);\\n                    return false;\\n                }\\n            }\\n        }\\n        vis[index]=false;   //mark as unvisted while returning\\n        return true;    //return true if checked all ingredients\\n    }\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String,Integer> m=new HashMap<>();\\n        int n=recipes.length;\\n        boolean[] vis=new boolean[n];   //to check if there is a loop in recipies \\n        for(int i=0;i<recipes.length;i++){  //fill map to get index of recipe\\n            m.put(recipes[i],i);\\n        }\\n        \\n        for(String sup:supplies)    //make supplies set to check if ingredient is available\\n            set.add(sup);\\n        \\n        for(int i=0;i<recipes.length;i++){  //check each recipe\\n            if(dfs(recipes,ingredients,m,i,vis)){    //if dfs returns true add the to result             \\n                set.add(recipes[i]);\\n                l.add(recipes[i]);\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646843,
                "title": "javascript-kahn-s-alogrithm-148-ms-brute-force-1797-ms",
                "content": "## Brute Force\\n\\nGo though the `recipes`, if all of its ingredients are available, add the recipe to `result`, and `supplies`, then start from the beginning of the loop.\\n\\n```\\n/**\\n * @param {string[]} recipes\\n * @param {string[][]} ingredients\\n * @param {string[]} supplies\\n * @return {string[]}\\n */\\nvar findAllRecipes = function(recipes, ingredients, supplies) {\\n    let result = [];\\n    let found = false;\\n    for (let i = 0; i < recipes.length; ) {\\n        if (result.indexOf(recipes[i]) >= 0) {\\n            i++;\\n            continue;\\n        }\\n        let valid = true;\\n        for (let j = 0; j < ingredients[i].length; j++) {\\n            if (supplies.indexOf(ingredients[i][j]) < 0) {\\n                valid = false;\\n                break;\\n            }\\n        }\\n        if (valid) {\\n            result.push(recipes[i]);\\n            supplies.push(recipes[i]);\\n            i = 0;\\n        } else i++;\\n    }\\n    return result\\n};\\n```\\n\\n## Kahn\\'s Alogrithm\\n\\nKeep the number of unavailable ingredients for each recipe `deg`, and map of recipe which is ingredient of other recipes `ing`.\\nChoose recipe with no unavailable ingredients, use `ing` to update `deg` accordingly.\\n\\nWikipedia : [Topology sort](https://en.wikipedia.org/wiki/Topological_sorting#Algorithms)\\nRelated problem: [Course Schedule II](https://leetcode.com/problems/course-schedule-ii/)\\n\\n```\\n/**\\n * @param {string[]} recipes\\n * @param {string[][]} ingredients\\n * @param {string[]} supplies\\n * @return {string[]}\\n */\\nvar findAllRecipes = function(recipes, ingredients, supplies) {\\n    // Supplies dictionary for faster search latter\\n    let sup = supplies.reduce((prev, val) => {\\n        prev[val] = true;\\n        return prev;\\n    }, {});\\n    \\n    // Map recipe to its index for faster search latter\\n    let rec = recipes.reduce((prev, val, i) => {\\n        prev[val] = i;\\n        return prev;\\n    }, {});\\n    \\n    // ing[i]: array of indices of recipes which require recipes[i] as ingredient\\n    let ing = new Array(recipes.length);\\n    \\n    // Numbers of ingredients missing\\n    let deg = new Array(recipes.length);\\n    \\n    // Indcies of recipes able to cook\\n    let op = [];\\n    \\n    // Initialize op\\n    ingredients.forEach((arr, i) => {\\n        let count = 0;\\n        arr.forEach(e => {\\n            if (!sup[e]) count++;\\n            if (rec[e] >= 0) {\\n                if (ing[rec[e]]) ing[rec[e]].push(i);\\n                else ing[rec[e]] = [i];\\n            }\\n        });\\n        deg[i] = count;\\n        if (count === 0) op.push(i);\\n    });\\n    \\n    let ret = [];\\n    \\n    while (op.length) {\\n        let idx = op.pop();\\n        ret.push(recipes[idx]);\\n        \\n        // Update deg, and op\\n        if (ing[idx] !== undefined) {\\n            ing[idx].forEach(e => {\\n                deg[e]--;\\n                if (deg[e] === 0) op.push(e);\\n            })\\n        }\\n    }\\n    \\n    return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Topological Sort"
                ],
                "code": "```\\n/**\\n * @param {string[]} recipes\\n * @param {string[][]} ingredients\\n * @param {string[]} supplies\\n * @return {string[]}\\n */\\nvar findAllRecipes = function(recipes, ingredients, supplies) {\\n    let result = [];\\n    let found = false;\\n    for (let i = 0; i < recipes.length; ) {\\n        if (result.indexOf(recipes[i]) >= 0) {\\n            i++;\\n            continue;\\n        }\\n        let valid = true;\\n        for (let j = 0; j < ingredients[i].length; j++) {\\n            if (supplies.indexOf(ingredients[i][j]) < 0) {\\n                valid = false;\\n                break;\\n            }\\n        }\\n        if (valid) {\\n            result.push(recipes[i]);\\n            supplies.push(recipes[i]);\\n            i = 0;\\n        } else i++;\\n    }\\n    return result\\n};\\n```\n```\\n/**\\n * @param {string[]} recipes\\n * @param {string[][]} ingredients\\n * @param {string[]} supplies\\n * @return {string[]}\\n */\\nvar findAllRecipes = function(recipes, ingredients, supplies) {\\n    // Supplies dictionary for faster search latter\\n    let sup = supplies.reduce((prev, val) => {\\n        prev[val] = true;\\n        return prev;\\n    }, {});\\n    \\n    // Map recipe to its index for faster search latter\\n    let rec = recipes.reduce((prev, val, i) => {\\n        prev[val] = i;\\n        return prev;\\n    }, {});\\n    \\n    // ing[i]: array of indices of recipes which require recipes[i] as ingredient\\n    let ing = new Array(recipes.length);\\n    \\n    // Numbers of ingredients missing\\n    let deg = new Array(recipes.length);\\n    \\n    // Indcies of recipes able to cook\\n    let op = [];\\n    \\n    // Initialize op\\n    ingredients.forEach((arr, i) => {\\n        let count = 0;\\n        arr.forEach(e => {\\n            if (!sup[e]) count++;\\n            if (rec[e] >= 0) {\\n                if (ing[rec[e]]) ing[rec[e]].push(i);\\n                else ing[rec[e]] = [i];\\n            }\\n        });\\n        deg[i] = count;\\n        if (count === 0) op.push(i);\\n    });\\n    \\n    let ret = [];\\n    \\n    while (op.length) {\\n        let idx = op.pop();\\n        ret.push(recipes[idx]);\\n        \\n        // Update deg, and op\\n        if (ing[idx] !== undefined) {\\n            ing[idx].forEach(e => {\\n                deg[e]--;\\n                if (deg[e] === 0) op.push(e);\\n            })\\n        }\\n    }\\n    \\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1646779,
                "title": "python-coloring-the-graph",
                "content": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        WHITE, GRAY, BLACK = 0, 1, 2\\n        color = defaultdict(int)\\n        \\n        supplies = set(supplies)\\n        recipes_s = set(recipes)\\n        graph = defaultdict(list)\\n        \\n        # Create the graph\\n        for i in range(len(recipes)):\\n            for ingredient in ingredients[i]:\\n                \\n                # Partially color the graph\\n                \\n                # ingredient that requires another recipe always GRAY if the recipe doesn\\'t exist\\n                if ingredient not in recipes_s:\\n                    color[ingredient] = GRAY\\n                \\n                # Ingredient in supplies always BLACK\\n                if ingredient in supplies:\\n                    color[ingredient] = BLACK\\n                    \\n                graph[recipes[i]].append(ingredient)\\n        \\n        \\n        def dfs(node):\\n            if color[node] != WHITE:\\n                return color[node] == BLACK\\n            \\n            color[node] = GRAY\\n            for ingredient in graph[node]:\\n                if color[ingredient] == BLACK:\\n                    continue\\n                if color[ingredient] == GRAY or not dfs(ingredient):\\n                    return False\\n            \\n            color[node] = BLACK\\n            return True\\n        \\n        return [recipe for recipe in recipes if dfs(recipe)]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        WHITE, GRAY, BLACK = 0, 1, 2\\n        color = defaultdict(int)\\n        \\n        supplies = set(supplies)\\n        recipes_s = set(recipes)\\n        graph = defaultdict(list)\\n        \\n        # Create the graph\\n        for i in range(len(recipes)):\\n            for ingredient in ingredients[i]:\\n                \\n                # Partially color the graph\\n                \\n                # ingredient that requires another recipe always GRAY if the recipe doesn\\'t exist\\n                if ingredient not in recipes_s:\\n                    color[ingredient] = GRAY\\n                \\n                # Ingredient in supplies always BLACK\\n                if ingredient in supplies:\\n                    color[ingredient] = BLACK\\n                    \\n                graph[recipes[i]].append(ingredient)\\n        \\n        \\n        def dfs(node):\\n            if color[node] != WHITE:\\n                return color[node] == BLACK\\n            \\n            color[node] = GRAY\\n            for ingredient in graph[node]:\\n                if color[ingredient] == BLACK:\\n                    continue\\n                if color[ingredient] == GRAY or not dfs(ingredient):\\n                    return False\\n            \\n            color[node] = BLACK\\n            return True\\n        \\n        return [recipe for recipe in recipes if dfs(recipe)]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646719,
                "title": "simple-set-operation",
                "content": "The idea is to keep update the supplies when we know that we can supply certain recipe.\\n\\nCraft a dict: key=recipe, val=set of ingredients\\n\\nSImply check the val (set of ingredients) is the subset of supplies or not. If yes, we save it and add it into the supplies and check another round and see if there\\'s any new recipe that we can make.\\n\\nStop until there\\'s no longer new recipes found.\\n\\n```\\nfrom typing import List\\nimport collections\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        ss = set(supplies)\\n        rd = collections.defaultdict(set)\\n        for i in range(len(recipes)):\\n            rd[recipes[i]] = set(ingredients[i])\\n        \\n        res = set()\\n        checked = [False for _ in recipes]\\n        while True:\\n            toAdd = set()\\n            for i in range(len(recipes)):\\n                r = recipes[i]\\n                if not checked[i] and rd[r].issubset(ss):\\n                    toAdd.add(r)\\n                    res.add(r)\\n                    checked[i] = True\\n            ss = ss.union(toAdd)    # update by union\\n            if not toAdd: break\\n        \\n        return list(res)\\n```",
                "solutionTags": [
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nfrom typing import List\\nimport collections\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        ss = set(supplies)\\n        rd = collections.defaultdict(set)\\n        for i in range(len(recipes)):\\n            rd[recipes[i]] = set(ingredients[i])\\n        \\n        res = set()\\n        checked = [False for _ in recipes]\\n        while True:\\n            toAdd = set()\\n            for i in range(len(recipes)):\\n                r = recipes[i]\\n                if not checked[i] and rd[r].issubset(ss):\\n                    toAdd.add(r)\\n                    res.add(r)\\n                    checked[i] = True\\n            ss = ss.union(toAdd)    # update by union\\n            if not toAdd: break\\n        \\n        return list(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646641,
                "title": "c-topological-order",
                "content": "<strong>Logical Thinking</strong>\\n<p>Actually, since every recipe can only be created with all the needed ingredients and the ingredients may contain other recipes, we can regard this problem as a <strong>topological order</strong> problem. Firstly, using a <strong>hash table</strong> to store each ingredient and all the recipes which need it. Then, a vector <code>degree</code> is used to indicate whether all the ingredients are obtained for each recipe. We push all the initial supplies into a <strong>queue</strong> <code>q</code>, for each item in the queue, decrese the degree of the its recipes, if the recipe\\'s degree is <code>0</code>, push it into the queue. Continuously doing this until <code>q</code> is empty, record all the recipes which occurs in the queue.</p>\\n\\n \\n<strong>C++</strong>\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n = recipes.size(), m = supplies.size();\\n        unordered_map<string, vector<string>> ingred;\\n        unordered_map<string, int> degree;\\n        for (int i = 0; i < n; i++)\\n        {\\n            degree[recipes[i]] = ingredients[i].size();\\n            for (auto& j : ingredients[i])\\n                ingred[j].push_back(recipes[i]);\\n        }\\n        unordered_set<string> s(recipes.begin(), recipes.end());\\n        queue<string> q;\\n        for (int i = 0; i < m; i++)\\n            q.push(supplies[i]);\\n        vector<string> ans;\\n        while (!q.empty())\\n        {\\n            string cur = q.front();\\n            q.pop();\\n            if (s.count(cur))\\n                ans.push_back(cur);\\n            for (auto& nxt : ingred[cur])\\n            {\\n                degree[nxt]--;\\n                if (degree[nxt] == 0)\\n                    q.push(nxt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n = recipes.size(), m = supplies.size();\\n        unordered_map<string, vector<string>> ingred;\\n        unordered_map<string, int> degree;\\n        for (int i = 0; i < n; i++)\\n        {\\n            degree[recipes[i]] = ingredients[i].size();\\n            for (auto& j : ingredients[i])\\n                ingred[j].push_back(recipes[i]);\\n        }\\n        unordered_set<string> s(recipes.begin(), recipes.end());\\n        queue<string> q;\\n        for (int i = 0; i < m; i++)\\n            q.push(supplies[i]);\\n        vector<string> ans;\\n        while (!q.empty())\\n        {\\n            string cur = q.front();\\n            q.pop();\\n            if (s.count(cur))\\n                ans.push_back(cur);\\n            for (auto& nxt : ingred[cur])\\n            {\\n                degree[nxt]--;\\n                if (degree[nxt] == 0)\\n                    q.push(nxt);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646638,
                "title": "python3-o-v-e-topological-sort-kahn-s-algorithm-bfs",
                "content": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        inDeg = {s: 0 for s in supplies}\\n        outAdj = {s: [] for s in supplies}\\n        for r in recipes:\\n            inDeg[r] = 0\\n            outAdj[r] = []\\n        for pres, cur in zip(ingredients, recipes):\\n            inDeg[cur] = len(pres)\\n            for p in pres:\\n                if p not in outAdj:\\n                    outAdj[p] = []\\n                    inDeg[p] = 1\\n                outAdj[p].append(cur)\\n\\n        level = [i for i in inDeg if inDeg[i] == 0]\\n        while level:\\n            nextLevel = []\\n            for ing in level:\\n                for adj in outAdj[ing]:\\n                    inDeg[adj] -= 1\\n                    if inDeg[adj] == 0:\\n                        nextLevel.append(adj)\\n            level = nextLevel\\n        return [r for r in inDeg if inDeg[r] == 0 and r in recipes]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        inDeg = {s: 0 for s in supplies}\\n        outAdj = {s: [] for s in supplies}\\n        for r in recipes:\\n            inDeg[r] = 0\\n            outAdj[r] = []\\n        for pres, cur in zip(ingredients, recipes):\\n            inDeg[cur] = len(pres)\\n            for p in pres:\\n                if p not in outAdj:\\n                    outAdj[p] = []\\n                    inDeg[p] = 1\\n                outAdj[p].append(cur)\\n\\n        level = [i for i in inDeg if inDeg[i] == 0]\\n        while level:\\n            nextLevel = []\\n            for ing in level:\\n                for adj in outAdj[ing]:\\n                    inDeg[adj] -= 1\\n                    if inDeg[adj] == 0:\\n                        nextLevel.append(adj)\\n            level = nextLevel\\n        return [r for r in inDeg if inDeg[r] == 0 and r in recipes]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1646619,
                "title": "topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n=recipes.size();\\n        vector<int> degree(n,0);\\n        vector<vector<int> > help(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<ingredients[i].size();j++){\\n                for(int k=0;k<n;k++){\\n                    if(ingredients[i][j]==recipes[k]){\\n                        help[k].push_back(i);\\n                        degree[i]++;\\n                    }\\n                }\\n            }\\n        }\\n        vector<string> ans;\\n        queue<pair<string,int> > helps;\\n        for(int i=0;i<n;i++){\\n            if(degree[i]==0){\\n                bool found=false;\\n                for(int j=0;j<ingredients[i].size();j++){\\n                    found=false;\\n                    for(int k=0;k<supplies.size();k++){\\n                        if(ingredients[i][j]==supplies[k]){\\n                            found=true;\\n                            \\n                            break;\\n                        }\\n                    }\\n                    if(found==false){\\n                        break;\\n                    }\\n                }\\n                // cout<<found<<endl;\\n                if(found==true){\\n                    helps.push({recipes[i],i});\\n                }\\n            }\\n        }\\n        \\n        while(helps.size()){\\n            pair<string,int> fro=helps.front();\\n            helps.pop();\\n            \\n            ans.push_back(fro.first);\\n            for(int i=0;i<help[fro.second].size();i++){\\n                degree[help[fro.second][i]]--;\\n                if(degree[help[fro.second][i]]==0){\\n                    helps.push({recipes[help[fro.second][i]],help[fro.second][i]});\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n=recipes.size();\\n        vector<int> degree(n,0);\\n        vector<vector<int> > help(n);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<ingredients[i].size();j++){\\n                for(int k=0;k<n;k++){\\n                    if(ingredients[i][j]==recipes[k]){\\n                        help[k].push_back(i);\\n                        degree[i]++;\\n                    }\\n                }\\n            }\\n        }\\n        vector<string> ans;\\n        queue<pair<string,int> > helps;\\n        for(int i=0;i<n;i++){\\n            if(degree[i]==0){\\n                bool found=false;\\n                for(int j=0;j<ingredients[i].size();j++){\\n                    found=false;\\n                    for(int k=0;k<supplies.size();k++){\\n                        if(ingredients[i][j]==supplies[k]){\\n                            found=true;\\n                            \\n                            break;\\n                        }\\n                    }\\n                    if(found==false){\\n                        break;\\n                    }\\n                }\\n                // cout<<found<<endl;\\n                if(found==true){\\n                    helps.push({recipes[i],i});\\n                }\\n            }\\n        }\\n        \\n        while(helps.size()){\\n            pair<string,int> fro=helps.front();\\n            helps.pop();\\n            \\n            ans.push_back(fro.first);\\n            for(int i=0;i<help[fro.second].size();i++){\\n                degree[help[fro.second][i]]--;\\n                if(degree[help[fro.second][i]]==0){\\n                    helps.push({recipes[help[fro.second][i]],help[fro.second][i]});\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1646618,
                "title": "java-hashset-easy-solution-brute-force",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashSet<String> hashSet=new HashSet<>();\\n        HashSet<String> answer=new HashSet<>();\\n        for(int i=0;i<supplies.length;i++){\\n            hashSet.add(supplies[i]);\\n        }\\n        int count=0;\\n        while(count<recipes.length){\\n        for(int i=0;i<ingredients.size();i++){\\n             if(!answer.contains(recipes[i])){ \\n            for(int j=0;j<ingredients.get(i).size();j++){\\n                if(hashSet.contains(ingredients.get(i).get(j))){\\n                    if(j==ingredients.get(i).size()-1){\\n                        hashSet.add(recipes[i]);\\n                        answer.add(recipes[i]);\\n                    }\\n                }else{\\n                    break;\\n                }\\n              }    \\n            }\\n          }\\n            count++;\\n        }\\n        List<String> a=new ArrayList<String>();\\n        for(String str:answer){\\n            a.add(str);\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashSet<String> hashSet=new HashSet<>();\\n        HashSet<String> answer=new HashSet<>();\\n        for(int i=0;i<supplies.length;i++){\\n            hashSet.add(supplies[i]);\\n        }\\n        int count=0;\\n        while(count<recipes.length){\\n        for(int i=0;i<ingredients.size();i++){\\n             if(!answer.contains(recipes[i])){ \\n            for(int j=0;j<ingredients.get(i).size();j++){\\n                if(hashSet.contains(ingredients.get(i).get(j))){\\n                    if(j==ingredients.get(i).size()-1){\\n                        hashSet.add(recipes[i]);\\n                        answer.add(recipes[i]);\\n                    }\\n                }else{\\n                    break;\\n                }\\n              }    \\n            }\\n          }\\n            count++;\\n        }\\n        List<String> a=new ArrayList<String>();\\n        for(String str:answer){\\n            a.add(str);\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196265,
                "title": "dfs-c-using-map",
                "content": "# Explaination:-\\n\\nThe main intuition is that we will check for every recipe and if that recipe can be prepared by the available supplies then push that recipe into the supplies so that it could be available for the ingredients of other recipesif required.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool dfs(string str,unordered_map<string,bool>&possible,unordered_map<string,vector<string>>&adj,unordered_map<string,int>&visited){\\n        if(visited[str])return possible[str];\\n        visited[str]=true;\\n        if(possible.find(str)!=possible.end())return possible[str];\\n        if(adj[str].size()==0)return possible[str]=false;\\n        for(auto it: adj[str]){\\n            if(!dfs(it,possible,adj,visited))\\n            return possible[str]=false;\\n        }\\n        return possible[str]=true;\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        unordered_map<string,bool>possible;\\n        unordered_map<string,vector<string>>adj;\\n        unordered_map<string,int>visited;\\n       int n=recipes.size();\\n       for(int i=0;i<recipes.size();i++){\\n           for(auto it: ingredients[i]){\\n               adj[recipes[i]].push_back(it);\\n           }\\n       }\\n       for(auto it: supplies){\\n           possible[it]=1;\\n       } \\n       vector<string>ans;\\n       for(int i=0;i<n;i++){\\n           if(dfs(recipes[i],possible,adj,visited)){\\n               ans.push_back(recipes[i]);\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(string str,unordered_map<string,bool>&possible,unordered_map<string,vector<string>>&adj,unordered_map<string,int>&visited){\\n        if(visited[str])return possible[str];\\n        visited[str]=true;\\n        if(possible.find(str)!=possible.end())return possible[str];\\n        if(adj[str].size()==0)return possible[str]=false;\\n        for(auto it: adj[str]){\\n            if(!dfs(it,possible,adj,visited))\\n            return possible[str]=false;\\n        }\\n        return possible[str]=true;\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        unordered_map<string,bool>possible;\\n        unordered_map<string,vector<string>>adj;\\n        unordered_map<string,int>visited;\\n       int n=recipes.size();\\n       for(int i=0;i<recipes.size();i++){\\n           for(auto it: ingredients[i]){\\n               adj[recipes[i]].push_back(it);\\n           }\\n       }\\n       for(auto it: supplies){\\n           possible[it]=1;\\n       } \\n       vector<string>ans;\\n       for(int i=0;i<n;i++){\\n           if(dfs(recipes[i],possible,adj,visited)){\\n               ans.push_back(recipes[i]);\\n           }\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123410,
                "title": "java-dfs-approach-good-code-quality-cycle-detection",
                "content": "**Approach** :\\n\\t- Each ingredient of a recipe is either in supplies or can be created from other recipe or is not present at all.\\n\\t- This can create a cyclic dependency of recipes which we should keep a track of.\\n\\t- HashMap storing the status of each recipe if it is visited, can be cooked, cannot be cooked or unvisited yet would be beneficial.\\n\\t- Making use of enum improves the code readability.\\n\\t\\n**Solution** :\\n```java\\n\\tenum Status {\\n\\t\\tCAN_BE_COOKED, \\n\\t\\tCANNOT_COOK, \\n\\t\\tUNKNOWN, \\n\\t\\tIS_BEING_COOKED;\\n\\t}\\n\\n\\tSet<String> isIngredientPresent = new HashSet<String>();\\n\\tMap<String, Status> recipeStatus = new HashMap<String, Status>();\\n\\tMap<String, Integer> recipeIndexMapping = new HashMap<String, Integer>();\\n\\n\\tpublic void canCreateRecipe(int index, String[] recipes, List<List<String>> ingredients) {\\n\\t\\tfor (String ingredient : ingredients.get(index)) {\\n\\n\\t\\t\\tif (!isIngredientPresent.contains(ingredient)) {\\n\\n\\t\\t\\t\\tif (recipeStatus.get(ingredient) != null) {\\n\\t\\t\\t\\t\\tStatus status = recipeStatus.get(ingredient);\\n\\t\\t\\t\\t\\tif (status == Status.UNKNOWN) {\\n\\t\\t\\t\\t\\t\\t// CHECK FOR CYCLIC DEPENDENCY\\n\\t\\t\\t\\t\\t\\tif (recipeStatus.get(recipes[index]) == Status.IS_BEING_COOKED) {\\n\\t\\t\\t\\t\\t\\t\\trecipeStatus.put(recipes[index], Status.CANNOT_COOK);\\n\\t\\t\\t\\t\\t\\t\\trecipeStatus.put(ingredient, Status.CANNOT_COOK);\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\trecipeStatus.put(recipes[index], Status.IS_BEING_COOKED);\\n\\t\\t\\t\\t\\t\\tcanCreateRecipe(recipeIndexMapping.get(ingredient), recipes, ingredients);\\n\\t\\t\\t\\t\\t\\trecipeStatus.put(recipes[index], Status.UNKNOWN);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstatus = recipeStatus.get(ingredient);\\n\\t\\t\\t\\t\\tif (status == Status.CAN_BE_COOKED)\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\trecipeStatus.put(recipes[index], Status.CANNOT_COOK);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\trecipeStatus.put(recipes[index], Status.CANNOT_COOK);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\trecipeStatus.put(recipes[index], Status.CAN_BE_COOKED);\\n\\t\\treturn;\\n\\t}\\n\\n\\tpublic List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n\\t\\tint n = recipes.length;\\n\\n\\t\\tfor (String supply : supplies)\\n\\t\\t\\tisIngredientPresent.add(supply);\\n\\n\\t\\tfor (String recipe : recipes)\\n\\t\\t\\trecipeStatus.put(recipe, Status.UNKNOWN);\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\trecipeIndexMapping.put(recipes[i], i);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (recipeStatus.get(recipes[i]) == Status.UNKNOWN)\\n\\t\\t\\t\\tcanCreateRecipe(i, recipes, ingredients);\\n\\t\\t}\\n\\n\\t\\tList<String> ans = new ArrayList<String>();\\n\\t\\tfor (String recipe : recipeStatus.keySet()) {\\n\\t\\t\\tif (recipeStatus.get(recipe) == Status.CAN_BE_COOKED)\\n\\t\\t\\t\\tans.add(recipe);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```java\\n\\tenum Status {\\n\\t\\tCAN_BE_COOKED, \\n\\t\\tCANNOT_COOK, \\n\\t\\tUNKNOWN, \\n\\t\\tIS_BEING_COOKED;\\n\\t}\\n\\n\\tSet<String> isIngredientPresent = new HashSet<String>();\\n\\tMap<String, Status> recipeStatus = new HashMap<String, Status>();\\n\\tMap<String, Integer> recipeIndexMapping = new HashMap<String, Integer>();\\n\\n\\tpublic void canCreateRecipe(int index, String[] recipes, List<List<String>> ingredients) {\\n\\t\\tfor (String ingredient : ingredients.get(index)) {\\n\\n\\t\\t\\tif (!isIngredientPresent.contains(ingredient)) {\\n\\n\\t\\t\\t\\tif (recipeStatus.get(ingredient) != null) {\\n\\t\\t\\t\\t\\tStatus status = recipeStatus.get(ingredient);\\n\\t\\t\\t\\t\\tif (status == Status.UNKNOWN) {\\n\\t\\t\\t\\t\\t\\t// CHECK FOR CYCLIC DEPENDENCY\\n\\t\\t\\t\\t\\t\\tif (recipeStatus.get(recipes[index]) == Status.IS_BEING_COOKED) {\\n\\t\\t\\t\\t\\t\\t\\trecipeStatus.put(recipes[index], Status.CANNOT_COOK);\\n\\t\\t\\t\\t\\t\\t\\trecipeStatus.put(ingredient, Status.CANNOT_COOK);\\n\\t\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\trecipeStatus.put(recipes[index], Status.IS_BEING_COOKED);\\n\\t\\t\\t\\t\\t\\tcanCreateRecipe(recipeIndexMapping.get(ingredient), recipes, ingredients);\\n\\t\\t\\t\\t\\t\\trecipeStatus.put(recipes[index], Status.UNKNOWN);\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstatus = recipeStatus.get(ingredient);\\n\\t\\t\\t\\t\\tif (status == Status.CAN_BE_COOKED)\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\trecipeStatus.put(recipes[index], Status.CANNOT_COOK);\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\trecipeStatus.put(recipes[index], Status.CANNOT_COOK);\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\trecipeStatus.put(recipes[index], Status.CAN_BE_COOKED);\\n\\t\\treturn;\\n\\t}\\n\\n\\tpublic List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n\\t\\tint n = recipes.length;\\n\\n\\t\\tfor (String supply : supplies)\\n\\t\\t\\tisIngredientPresent.add(supply);\\n\\n\\t\\tfor (String recipe : recipes)\\n\\t\\t\\trecipeStatus.put(recipe, Status.UNKNOWN);\\n\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\trecipeIndexMapping.put(recipes[i], i);\\n\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tif (recipeStatus.get(recipes[i]) == Status.UNKNOWN)\\n\\t\\t\\t\\tcanCreateRecipe(i, recipes, ingredients);\\n\\t\\t}\\n\\n\\t\\tList<String> ans = new ArrayList<String>();\\n\\t\\tfor (String recipe : recipeStatus.keySet()) {\\n\\t\\t\\tif (recipeStatus.get(recipe) == Status.CAN_BE_COOKED)\\n\\t\\t\\t\\tans.add(recipe);\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3001902,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                # for j in ans[x]:\\n                    # if j not in ans[i]:\\n                    #     ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                # for j in ans[x]:\\n                    # if j not in ans[i]:\\n                    #     ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3001847,
                "title": "simple-python-topological-sort-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        dct=defaultdict(lambda :[])\\n        indegree={}\\n        n=len(recepies)\\n\\n        for i in recepies:\\n            indegree[i]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                indegree[j]=0\\n\\n        for i in range(n):\\n            for j in ingredients[i]:\\n                dct[j].append(recepies[i])\\n                indegree[recepies[i]]+=1\\n\\n        st=[]\\n        for i in indegree:\\n            if indegree[i]==0:\\n                st.append(i)\\n        flst=[]\\n        ans=defaultdict(lambda :[])\\n        while st:\\n            x=st.pop(0)\\n            for i in dct[x]:\\n                # if ans[x]!=[]:\\n                for j in ans[x]:\\n                    if j not in ans[i]:\\n                        ans[i].append(j)\\n                ans[i].append(x)\\n                indegree[i]-=1\\n                if indegree[i]==0:\\n                    st.append(i)\\n            if x in recepies:\\n                for k in ans[x]:\\n                    if k not in supplies:\\n                        break\\n                else:\\n                    flst.append(x)\\n                    supplies.append(x)\\n\\n        return flst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770911,
                "title": "dfs-cycle-detection",
                "content": "\\n# Approach\\nFormulate the problem as a graph search. A supply is a parent node, and its child nodes are from the ingredients list. After building this graph, we do dfs check each supply (as root node) whether its valid.\\n\\nAs the problem indicates \"Note that two recipes may contain each other in their ingredients.\" In other words, we may face with cycle. Introducing a `seen` set solves the problem.\\n\\nTime complexity: each dfs is O(V+E) where V is the number of nodes and E are the edges. Thanks memorization of visited recipe, we don\\'t need to repeat. Therefore the final time complexity should be O(V+E)\\n\\n# Code\\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        supplies_set = set(supplies)\\n        recipes_dict: Dict[str, List[str]] = {recipes[i]: ingredients[i] for i in range(len(recipes))} # Build a dictionary for quick access\\n\\n        memo: Dict[str, bool] = {sup: True for sup in supplies} \\n        def dfs(rec: str, seen: Set[str]) -> bool:\\n            if rec in memo:\\n                return memo[rec]\\n            if rec not in recipes_dict and rec not in supplies: # for ingredients that is not in supplies\\n                return False\\n            if rec in seen:\\n                return False\\n            seen.add(rec)\\n            ans: bool = True\\n            for ing in recipes_dict[rec]:\\n                ans = ans and dfs(ing, seen)\\n                if not ans:\\n                    break\\n            memo[rec] = ans\\n            return ans\\n\\n        valid_recipes: List[str] = []\\n        for rec in recipes:\\n            seen = set([]) # Add this to avoid cycle \\n            if dfs(rec, seen):\\n                valid_recipes.append(rec)\\n        return valid_recipes\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        supplies_set = set(supplies)\\n        recipes_dict: Dict[str, List[str]] = {recipes[i]: ingredients[i] for i in range(len(recipes))} # Build a dictionary for quick access\\n\\n        memo: Dict[str, bool] = {sup: True for sup in supplies} \\n        def dfs(rec: str, seen: Set[str]) -> bool:\\n            if rec in memo:\\n                return memo[rec]\\n            if rec not in recipes_dict and rec not in supplies: # for ingredients that is not in supplies\\n                return False\\n            if rec in seen:\\n                return False\\n            seen.add(rec)\\n            ans: bool = True\\n            for ing in recipes_dict[rec]:\\n                ans = ans and dfs(ing, seen)\\n                if not ans:\\n                    break\\n            memo[rec] = ans\\n            return ans\\n\\n        valid_recipes: List[str] = []\\n        for rec in recipes:\\n            seen = set([]) # Add this to avoid cycle \\n            if dfs(rec, seen):\\n                valid_recipes.append(rec)\\n        return valid_recipes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2613395,
                "title": "c-topological-sort-fully-commented-kahn-s-algo",
                "content": "```\\n    vector<string> findAllRecipes(vector<string>& rec, vector<vector<string>>& ing, vector<string>& sup) \\n {\\n     int n=ing.size();\\n    //this will store the edges that exist between ingredients and recepies\\n     map<string,vector<string>>grph;\\n        //this will store indegree of recepies\\n     map<string,int>indeg;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<ing[i].size();j++)\\n            {\\n                //map ingredients to their recepies\\n                grph[ing[i][j]].push_back(rec[i]);\\n                //and each recepie will have indegree the nmbr of time we iterate over ingredients\\n                indeg[rec[i]]++;\\n            }\\n        }\\n  \\n        //push supplies to queue because they will have indegree 0\\n     queue<string>q;\\n        for(auto x:sup)\\n         q.push(x);\\n    \\n    //this will store our ans\\n     vector<string>ans;\\n        \\n        //simply run topological sort!!\\n        while(!q.empty())\\n        {\\n            //get the front \\n            string curr=q.front();\\n            q.pop();\\n            //traverse it\\'s neighbours\\n            for(auto nds:grph[curr])\\n            {\\n                //reduce indegree of neighbours\\n                    indeg[nds]--;\\n                //if it becomes 0 then add to queue and to ans\\n                    if(indeg[nds]==0)\\n                    {\\n                        q.push(nds);\\n                        ans.push_back(nds);\\n                    }\\n            }\\n        }\\n        //return the ans\\n        return ans;\\n   }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\n    vector<string> findAllRecipes(vector<string>& rec, vector<vector<string>>& ing, vector<string>& sup) \\n {\\n     int n=ing.size();\\n    //this will store the edges that exist between ingredients and recepies\\n     map<string,vector<string>>grph;\\n        //this will store indegree of recepies\\n     map<string,int>indeg;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<ing[i].size();j++)\\n            {\\n                //map ingredients to their recepies\\n                grph[ing[i][j]].push_back(rec[i]);\\n                //and each recepie will have indegree the nmbr of time we iterate over ingredients\\n                indeg[rec[i]]++;\\n            }\\n        }\\n  \\n        //push supplies to queue because they will have indegree 0\\n     queue<string>q;\\n        for(auto x:sup)\\n         q.push(x);\\n    \\n    //this will store our ans\\n     vector<string>ans;\\n        \\n        //simply run topological sort!!\\n        while(!q.empty())\\n        {\\n            //get the front \\n            string curr=q.front();\\n            q.pop();\\n            //traverse it\\'s neighbours\\n            for(auto nds:grph[curr])\\n            {\\n                //reduce indegree of neighbours\\n                    indeg[nds]--;\\n                //if it becomes 0 then add to queue and to ans\\n                    if(indeg[nds]==0)\\n                    {\\n                        q.push(nds);\\n                        ans.push_back(nds);\\n                    }\\n            }\\n        }\\n        //return the ans\\n        return ans;\\n   }",
                "codeTag": "Unknown"
            },
            {
                "id": 2566284,
                "title": "topoloical-sort-super-easy-python",
                "content": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        \\n        graph = collections.defaultdict(list)\\n        indegree = collections.defaultdict(int)\\n        \\n        for i in range(len(recipes)):\\n            for j in range(len(ingredients[i])):\\n                graph[ingredients[i][j]].append(recipes[i])\\n                indegree[recipes[i]] += 1\\n        queue = []    \\n        for s in supplies:\\n            queue.append(s)\\n        \\n        ans = []\\n        wanted = set(recipes)\\n        while queue:\\n            node = queue.pop(0)\\n            if node in wanted:\\n                ans.append(node)\\n            for v in graph[node]:\\n                indegree[v] -=1\\n                if indegree[v] == 0:\\n                    queue.append(v)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        \\n        graph = collections.defaultdict(list)\\n        indegree = collections.defaultdict(int)\\n        \\n        for i in range(len(recipes)):\\n            for j in range(len(ingredients[i])):\\n                graph[ingredients[i][j]].append(recipes[i])\\n                indegree[recipes[i]] += 1\\n        queue = []    \\n        for s in supplies:\\n            queue.append(s)\\n        \\n        ans = []\\n        wanted = set(recipes)\\n        while queue:\\n            node = queue.pop(0)\\n            if node in wanted:\\n                ans.append(node)\\n            for v in graph[node]:\\n                indegree[v] -=1\\n                if indegree[v] == 0:\\n                    queue.append(v)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2534601,
                "title": "dfs-python-topological-sort",
                "content": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        recipie={r:i for r,i in zip(recipes,ingredients)}\\n        supplies=set(supplies)\\n        can_be_made=set()\\n        visit=set()\\n        def dfs(it):\\n            if it in supplies or it in can_be_made:\\n                return True\\n            if it in visit:\\n                return False\\n            visit.add(it)\\n            for i in recipie[it]:\\n                if (i not in supplies and i not in recipes) or not dfs(i):\\n                    return False\\n            supplies.add(it)\\n            can_be_made.add(it)\\n            return True\\n        for i in recipes:\\n            dfs(i)\\n        return list(can_be_made)\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        recipie={r:i for r,i in zip(recipes,ingredients)}\\n        supplies=set(supplies)\\n        can_be_made=set()\\n        visit=set()\\n        def dfs(it):\\n            if it in supplies or it in can_be_made:\\n                return True\\n            if it in visit:\\n                return False\\n            visit.add(it)\\n            for i in recipie[it]:\\n                if (i not in supplies and i not in recipes) or not dfs(i):\\n                    return False\\n            supplies.add(it)\\n            can_be_made.add(it)\\n            return True\\n        for i in recipes:\\n            dfs(i)\\n        return list(can_be_made)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513219,
                "title": "brute-force-to-optimized-c-bfs-easy-to-understand",
                "content": "\\n**Brute force code :-**\\n                                 \\n\\n```\\nvector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        vector<int>ans(recipes.size(),0);\\n        set<string>st;\\n        for(string s:supplies)st.insert(s);\\n        int n=recipes.size();\\n        \\n        while(n--){\\n            \\n           for(int i=0;i<recipes.size();i++){\\n              int f=0;\\n               for(string str:ingredients[i]){\\n                   if(st.find(str)==st.end()){\\n                       f=1;\\n                       break;\\n                   }\\n               }\\n               if(f==0){\\n                   ans[i]=1;\\n                   st.insert(recipes[i]);\\n               }\\n            }\\n            \\n        }\\n        vector<string>res;\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i]==1) res.push_back(recipes[i]);\\n        }\\n        return res;\\n    }\\n```\\n\\n**Time Complexity:- O(n^3logn)\\nSpace complexity:- O(n)**\\n\\n**Optimized code:-**\\n\\n```\\nvector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n=recipes.size();\\n        vector<int>in(n,0);\\n        set<string>st;\\n        for(string s:supplies)st.insert(s);\\n        unordered_map<string,vector<int>>adj;\\n        queue<string>q;\\n         \\n        for(int i=0;i<n;i++){\\n            for(string s:ingredients[i]){\\n                if(st.find(s)==st.end()){\\n                    in[i]++;\\n                    adj[s].push_back(i);\\n                }\\n            }\\n            if(in[i]==0)q.push(recipes[i]);\\n        } \\n         \\n        vector<string>ans;\\n        while(!q.empty()){\\n            string curr=q.front();\\n            ans.push_back(curr);\\n             \\n            for(int i:adj[curr]){\\n                in[i]--;\\n                if(in[i]==0){\\n                    q.push(recipes[i]);\\n                }\\n            }\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Time complexity:- O(n^2logn)\\nSpace complexity:- O(n^2)**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nvector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        vector<int>ans(recipes.size(),0);\\n        set<string>st;\\n        for(string s:supplies)st.insert(s);\\n        int n=recipes.size();\\n        \\n        while(n--){\\n            \\n           for(int i=0;i<recipes.size();i++){\\n              int f=0;\\n               for(string str:ingredients[i]){\\n                   if(st.find(str)==st.end()){\\n                       f=1;\\n                       break;\\n                   }\\n               }\\n               if(f==0){\\n                   ans[i]=1;\\n                   st.insert(recipes[i]);\\n               }\\n            }\\n            \\n        }\\n        vector<string>res;\\n        for(int i=0;i<ans.size();i++){\\n            if(ans[i]==1) res.push_back(recipes[i]);\\n        }\\n        return res;\\n    }\\n```\n```\\nvector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n=recipes.size();\\n        vector<int>in(n,0);\\n        set<string>st;\\n        for(string s:supplies)st.insert(s);\\n        unordered_map<string,vector<int>>adj;\\n        queue<string>q;\\n         \\n        for(int i=0;i<n;i++){\\n            for(string s:ingredients[i]){\\n                if(st.find(s)==st.end()){\\n                    in[i]++;\\n                    adj[s].push_back(i);\\n                }\\n            }\\n            if(in[i]==0)q.push(recipes[i]);\\n        } \\n         \\n        vector<string>ans;\\n        while(!q.empty()){\\n            string curr=q.front();\\n            ans.push_back(curr);\\n             \\n            for(int i:adj[curr]){\\n                in[i]--;\\n                if(in[i]==0){\\n                    q.push(recipes[i]);\\n                }\\n            }\\n            q.pop();\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2512317,
                "title": "javascript-topological-sort-with-comments",
                "content": "```\\n/**\\n * @param {string[]} recipes\\n * @param {string[][]} ingredients\\n * @param {string[]} supplies\\n * @return {string[]}\\n */\\nconst findAllRecipes = (recipes, ingredients, supplies) => {\\n    // Top Sort\\n    let graph = new Map();\\n    let count = new Map();\\n    let supplySet = new Set(supplies);\\n    \\n    // Build graph and count of indegrees for Top Sort\\n    for(let i = 0; i < recipes.length; i++) {\\n        if(!graph.has(recipes[i])) graph.set(recipes[i], []);\\n        \\n        for(let j = 0; j < ingredients[i].length; j++) {\\n            // Add to graph\\n            if(!graph.has(ingredients[i][j])) graph.set(ingredients[i][j], []);\\n            graph.get(ingredients[i][j]).push(recipes[i]);\\n            \\n            // Add to count\\n            if(!count.has(recipes[i])) count.set(recipes[i], 0);\\n            count.set(recipes[i], count.get(recipes[i]) + 1);\\n            \\n            if(!count.has(ingredients[i][j])) count.set(ingredients[i][j], 0);\\n        }\\n    }\\n    \\n    // Add verticies with NO neighbors to queue, they have a count of 0\\n    let q = [];\\n    for(let [key, value] of count) {\\n        if(!value) q.push(key);\\n    }\\n    \\n    \\n    // Start BFS with Top Sort\\n    let res = []; // res will hold recipes that can be made\\n    while(q.length) {\\n        const key = q.shift(); // Get key from queue\\n        \\n        // If we dont have it as a supply, just continue. This will not add recipes we cant make\\n        if(!supplySet.has(key)) continue;\\n        \\n        for(let n of graph.get(key)) {\\n            // --count of neighbor since we got this far and have the supply\\n            count.set(n, count.get(n) - 1);\\n            \\n            // once a count of a recipe gets to 0, we know we can make it AND its a supply now IMPORTANT\\n            if(!count.get(n)) {\\n                // push to res since we can make it\\n                res.push(n);\\n                // push to queue to process it\\n                q.push(n);\\n                // since we can make it, its a supply now \\n                supplySet.add(n);\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue"
                ],
                "code": "```\\n/**\\n * @param {string[]} recipes\\n * @param {string[][]} ingredients\\n * @param {string[]} supplies\\n * @return {string[]}\\n */\\nconst findAllRecipes = (recipes, ingredients, supplies) => {\\n    // Top Sort\\n    let graph = new Map();\\n    let count = new Map();\\n    let supplySet = new Set(supplies);\\n    \\n    // Build graph and count of indegrees for Top Sort\\n    for(let i = 0; i < recipes.length; i++) {\\n        if(!graph.has(recipes[i])) graph.set(recipes[i], []);\\n        \\n        for(let j = 0; j < ingredients[i].length; j++) {\\n            // Add to graph\\n            if(!graph.has(ingredients[i][j])) graph.set(ingredients[i][j], []);\\n            graph.get(ingredients[i][j]).push(recipes[i]);\\n            \\n            // Add to count\\n            if(!count.has(recipes[i])) count.set(recipes[i], 0);\\n            count.set(recipes[i], count.get(recipes[i]) + 1);\\n            \\n            if(!count.has(ingredients[i][j])) count.set(ingredients[i][j], 0);\\n        }\\n    }\\n    \\n    // Add verticies with NO neighbors to queue, they have a count of 0\\n    let q = [];\\n    for(let [key, value] of count) {\\n        if(!value) q.push(key);\\n    }\\n    \\n    \\n    // Start BFS with Top Sort\\n    let res = []; // res will hold recipes that can be made\\n    while(q.length) {\\n        const key = q.shift(); // Get key from queue\\n        \\n        // If we dont have it as a supply, just continue. This will not add recipes we cant make\\n        if(!supplySet.has(key)) continue;\\n        \\n        for(let n of graph.get(key)) {\\n            // --count of neighbor since we got this far and have the supply\\n            count.set(n, count.get(n) - 1);\\n            \\n            // once a count of a recipe gets to 0, we know we can make it AND its a supply now IMPORTANT\\n            if(!count.get(n)) {\\n                // push to res since we can make it\\n                res.push(n);\\n                // push to queue to process it\\n                q.push(n);\\n                // since we can make it, its a supply now \\n                supplySet.add(n);\\n            }\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2508432,
                "title": "python-solution-topological-sort",
                "content": "\"\"\"\\nfirst count number of ingredients for each recipe.\\nthen build a graph that maps each ingredients to the recipes.\\nusing deque starting from the supplies which we already have we start using them and decrease the degrees of the recipes that requires this supply. \\nif all the supply  is provided means no indegree we alread had it and add to our answer, then add to our queue for future if there is a recipe that uses it as an ingredient\\n\"\"\"\\n\\n\\t\\t def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n\\t\\t\\tin_degree = defaultdict(int)\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\trecipes_s = set(recipes)\\n\\n\\t\\t\\tfor ind in range(len(recipes)):\\n\\t\\t\\t\\tin_degree[recipes[ind]] = len(ingredients[ind])\\n\\t\\t\\t\\tfor ingredient in ingredients[ind]:\\n\\t\\t\\t\\t\\tgraph[ingredient].append(recipes[ind])\\n\\n\\t\\t\\tque = deque(supplies)\\n\\t\\t\\tans = []\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\tcur = que.popleft()\\n\\n\\t\\t\\t\\tif cur in recipes_s:\\n\\t\\t\\t\\t\\tans.append(cur)\\n\\n\\t\\t\\t\\tfor ngh in graph[cur]:\\n\\t\\t\\t\\t\\tin_degree[ngh] -= 1\\n\\t\\t\\t\\t\\tif not  in_degree[ngh]:\\n\\t\\t\\t\\t\\t\\tque.append(ngh)\\n\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "\"\"\"\\nfirst count number of ingredients for each recipe.\\nthen build a graph that maps each ingredients to the recipes.\\nusing deque starting from the supplies which we already have we start using them and decrease the degrees of the recipes that requires this supply. \\nif all the supply  is provided means no indegree we alread had it and add to our answer, then add to our queue for future if there is a recipe that uses it as an ingredient\\n\"\"\"\\n\\n\\t\\t def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n\\t\\t\\tin_degree = defaultdict(int)\\n\\t\\t\\tgraph = defaultdict(list)\\n\\t\\t\\trecipes_s = set(recipes)\\n\\n\\t\\t\\tfor ind in range(len(recipes)):\\n\\t\\t\\t\\tin_degree[recipes[ind]] = len(ingredients[ind])\\n\\t\\t\\t\\tfor ingredient in ingredients[ind]:\\n\\t\\t\\t\\t\\tgraph[ingredient].append(recipes[ind])\\n\\n\\t\\t\\tque = deque(supplies)\\n\\t\\t\\tans = []\\n\\t\\t\\twhile que:\\n\\t\\t\\t\\tcur = que.popleft()\\n\\n\\t\\t\\t\\tif cur in recipes_s:\\n\\t\\t\\t\\t\\tans.append(cur)\\n\\n\\t\\t\\t\\tfor ngh in graph[cur]:\\n\\t\\t\\t\\t\\tin_degree[ngh] -= 1\\n\\t\\t\\t\\t\\tif not  in_degree[ngh]:\\n\\t\\t\\t\\t\\t\\tque.append(ngh)\\n\\n\\t\\t\\treturn ans",
                "codeTag": "Python3"
            },
            {
                "id": 2484868,
                "title": "o-n-m-l-order-is-just-1-iteration-over-all-arrays-still-getting-tle",
                "content": "\\n\\t   public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        int n = recipes.length;\\n        Map<String, Recipe> map = new HashMap<>();\\n        \\n        for(int i=0; i<n; i++) {\\n            String rec = recipes[i];\\n            List<String> reqIngr = ingredients.get(i);\\n            \\n            List<Recipe> ingrObjs = new ArrayList<>();\\n            \\n            for(String ingr : reqIngr) {\\n                if(map.containsKey(ingr)) {\\n                    ingrObjs.add(map.get(ingr));\\n                } else {\\n                    Recipe newRec = new Recipe(ingr);\\n                    ingrObjs.add(newRec);\\n                    map.put(ingr, newRec);\\n                }                \\n            }\\n            \\n            if(map.containsKey(rec)) {\\n                Recipe recObj = map.get(rec);\\n                recObj.ingredients = ingrObjs;\\n            } else {\\n                Recipe recObj = new Recipe(rec, ingrObjs);\\n                map.put(rec, recObj);\\n            }\\n        }\\n        \\n        List<String> ans = new ArrayList<String>();\\n        Map<String, Boolean> recipeMap = new HashMap<String, Boolean>();\\n        for(int s=0; s<supplies.length; s++) {\\n            recipeMap.put(supplies[s], true);\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            String recipe = recipes[i];\\n            if(!recipeMap.containsKey(recipe)) {\\n                Recipe recipeObj = map.get(recipe);\\n                checkIfPossible(recipeObj, recipeMap);\\n            }\\n            \\n            if(recipeMap.get(recipe)) {\\n                ans.add(recipe);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean checkIfPossible(Recipe recipe, Map<String, Boolean> recipeMap) {\\n        if(recipeMap.containsKey(recipe.name)) {\\n            return recipeMap.get(recipe.name);\\n        }\\n        \\n        List<Recipe> ingredients = recipe.ingredients;\\n        if(ingredients == null || ingredients.size() == 0) {\\n            recipeMap.put(recipe.name, false);\\n            return false;\\n        }\\n        \\n        boolean possible = true;\\n        for(Recipe ingredient: ingredients) {\\n            boolean ingrPossible = checkIfPossible(ingredient, recipeMap);\\n            possible = possible && ingrPossible;\\n        }\\n        \\n        recipeMap.put(recipe.name, possible);\\n        return possible;\\n    }\\n    \\n    class Recipe {\\n        String name;\\n        List<Recipe> ingredients;\\n        \\n        Recipe(String name) {\\n            this.name = name;\\n        }\\n        \\n        Recipe(String name, List<Recipe> ingredients) {\\n            this.name = name;\\n            this.ingredients = ingredients;\\n        }\\n    }",
                "solutionTags": [],
                "code": "\\n\\t   public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        int n = recipes.length;\\n        Map<String, Recipe> map = new HashMap<>();\\n        \\n        for(int i=0; i<n; i++) {\\n            String rec = recipes[i];\\n            List<String> reqIngr = ingredients.get(i);\\n            \\n            List<Recipe> ingrObjs = new ArrayList<>();\\n            \\n            for(String ingr : reqIngr) {\\n                if(map.containsKey(ingr)) {\\n                    ingrObjs.add(map.get(ingr));\\n                } else {\\n                    Recipe newRec = new Recipe(ingr);\\n                    ingrObjs.add(newRec);\\n                    map.put(ingr, newRec);\\n                }                \\n            }\\n            \\n            if(map.containsKey(rec)) {\\n                Recipe recObj = map.get(rec);\\n                recObj.ingredients = ingrObjs;\\n            } else {\\n                Recipe recObj = new Recipe(rec, ingrObjs);\\n                map.put(rec, recObj);\\n            }\\n        }\\n        \\n        List<String> ans = new ArrayList<String>();\\n        Map<String, Boolean> recipeMap = new HashMap<String, Boolean>();\\n        for(int s=0; s<supplies.length; s++) {\\n            recipeMap.put(supplies[s], true);\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            String recipe = recipes[i];\\n            if(!recipeMap.containsKey(recipe)) {\\n                Recipe recipeObj = map.get(recipe);\\n                checkIfPossible(recipeObj, recipeMap);\\n            }\\n            \\n            if(recipeMap.get(recipe)) {\\n                ans.add(recipe);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public boolean checkIfPossible(Recipe recipe, Map<String, Boolean> recipeMap) {\\n        if(recipeMap.containsKey(recipe.name)) {\\n            return recipeMap.get(recipe.name);\\n        }\\n        \\n        List<Recipe> ingredients = recipe.ingredients;\\n        if(ingredients == null || ingredients.size() == 0) {\\n            recipeMap.put(recipe.name, false);\\n            return false;\\n        }\\n        \\n        boolean possible = true;\\n        for(Recipe ingredient: ingredients) {\\n            boolean ingrPossible = checkIfPossible(ingredient, recipeMap);\\n            possible = possible && ingrPossible;\\n        }\\n        \\n        recipeMap.put(recipe.name, possible);\\n        return possible;\\n    }\\n    \\n    class Recipe {\\n        String name;\\n        List<Recipe> ingredients;\\n        \\n        Recipe(String name) {\\n            this.name = name;\\n        }\\n        \\n        Recipe(String name, List<Recipe> ingredients) {\\n            this.name = name;\\n            this.ingredients = ingredients;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2404186,
                "title": "java-c-98-status-checking",
                "content": "Intuition:\\n- Check each recipe one by one;\\n- For recipes that have been checked, mark em as `CHECKED`;\\n- Add recipe to result if it passes the check;\\n\\nMem used:\\n- `status`: to represent if the ith recipe has been checked;\\n- `suppliesSet`: to store the ingredients that can be supplied;\\n- `recipesMap`: to store `<K = recipe, V = index>`;\\n\\nAlgorithm:\\n- if found recipe that has not been **checked**, do checking:\\n\\t- Mark the current recipe as **CHECKED**;\\n\\t- Check each ingredient:\\n\\t\\t- If we can find ingredient in `suppliesSet`, check the next ingredient;\\n\\t\\t- if we cannot find ingredient in `suppliesSet`, then check if it\\'s in other recipes;\\n\\t\\t\\t- if not, then the required ingredient is missing -> `return false`;\\n\\t\\t\\t- if yes, then it means that the ingredient is some other recipe:\\n\\t\\t\\t\\t- If that recipe has been checked, `return false` because if that recipe can be created, it will be added to `suppliesSet`;\\n\\t\\t\\t\\t- otherwise, recursively check that recipe;\\n\\t- Once all ingredients can be found, add the current recipe to `suppliesSet` & add to result;\\n\\t- `return true;`\\n\\nNote that the status is used to prevent dead recursion (e.g: recipe A needs recipe B as ingredient & B also requires A) because whenever we enter the checking of one recipe, we immediately mark that recipe as checked. If other recipe recursively checks back to previous recipes, we will return false (detecting such conflict).\\n\\nComplexity:\\n- In such way, we actually only checked each recipe once. \\n- Runtime will be O(N * M) where N = the number of recipes, and M = the avg number of ingredients; \\n- Space: O(N);\\n\\n**Java**\\n```\\nclass Solution {\\n    int[] status;\\n    int CHECKED = 1;\\n    HashSet<String> suppliesSet = new HashSet();\\n    HashMap<String, Integer> recipesMap = new HashMap();\\n    List<String> res = new ArrayList();\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        status = new int[recipes.length];\\n        for (String supply : supplies) suppliesSet.add(supply);\\n        for (int i = 0; i < recipes.length; i++) recipesMap.put(recipes[i], i);\\n        for (int i = 0; i < recipes.length; i++) {\\n            if (status[i] != CHECKED) check(recipes, ingredients, i);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean check(String[] recipes, List<List<String>> ingredients, int i) {\\n        status[i] = CHECKED;\\n        for (String ingredient : ingredients.get(i)) {\\n            if (suppliesSet.contains(ingredient)) continue;\\n            if (!recipesMap.containsKey(ingredient)) return false;\\n            else {\\n                int index = recipesMap.get(ingredient);\\n                if (status[index] == CHECKED) return false;\\n                if (!check(recipes, ingredients, index)) return false;\\n            }\\n        }\\n        \\n        res.add(recipes[i]);\\n        suppliesSet.add(recipes[i]);\\n        return true;\\n    }\\n}\\n```\\n\\n**C++**\\n```\\n# define CHECKED 1\\nclass Solution {\\npublic:\\n    vector<int> status;\\n    unordered_set<string> suppliesSet;\\n    unordered_map<string, int> recipesMap;\\n    vector<string> res;\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        status = vector<int>(recipes.size());\\n        for (string supply : supplies) suppliesSet.insert(supply);\\n        for (int i = 0; i < recipes.size(); i++) recipesMap[recipes[i]] = i;\\n        for (int i = 0; i < recipes.size(); i++) {\\n            if (status[i] != CHECKED) check(recipes, ingredients, i);\\n        }\\n        return res;\\n    }\\n    \\n    bool check(vector<string>& recipes, vector<vector<string>>& ingredients, int i) {\\n        status[i] = CHECKED;\\n        for (string ingredient : ingredients[i]) {\\n            if (suppliesSet.find(ingredient) != suppliesSet.end()) continue;\\n            if (recipesMap.find(ingredient) == recipesMap.end()) return false;\\n            else {\\n                int index = recipesMap[ingredient];\\n                if (status[index] == CHECKED) return false;\\n                if (!check(recipes, ingredients, index)) return false;\\n            }\\n        }\\n        res.push_back(recipes[i]);\\n        suppliesSet.insert(recipes[i]);\\n        return true;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int[] status;\\n    int CHECKED = 1;\\n    HashSet<String> suppliesSet = new HashSet();\\n    HashMap<String, Integer> recipesMap = new HashMap();\\n    List<String> res = new ArrayList();\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        status = new int[recipes.length];\\n        for (String supply : supplies) suppliesSet.add(supply);\\n        for (int i = 0; i < recipes.length; i++) recipesMap.put(recipes[i], i);\\n        for (int i = 0; i < recipes.length; i++) {\\n            if (status[i] != CHECKED) check(recipes, ingredients, i);\\n        }\\n        return res;\\n    }\\n    \\n    private boolean check(String[] recipes, List<List<String>> ingredients, int i) {\\n        status[i] = CHECKED;\\n        for (String ingredient : ingredients.get(i)) {\\n            if (suppliesSet.contains(ingredient)) continue;\\n            if (!recipesMap.containsKey(ingredient)) return false;\\n            else {\\n                int index = recipesMap.get(ingredient);\\n                if (status[index] == CHECKED) return false;\\n                if (!check(recipes, ingredients, index)) return false;\\n            }\\n        }\\n        \\n        res.add(recipes[i]);\\n        suppliesSet.add(recipes[i]);\\n        return true;\\n    }\\n}\\n```\n```\\n# define CHECKED 1\\nclass Solution {\\npublic:\\n    vector<int> status;\\n    unordered_set<string> suppliesSet;\\n    unordered_map<string, int> recipesMap;\\n    vector<string> res;\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        status = vector<int>(recipes.size());\\n        for (string supply : supplies) suppliesSet.insert(supply);\\n        for (int i = 0; i < recipes.size(); i++) recipesMap[recipes[i]] = i;\\n        for (int i = 0; i < recipes.size(); i++) {\\n            if (status[i] != CHECKED) check(recipes, ingredients, i);\\n        }\\n        return res;\\n    }\\n    \\n    bool check(vector<string>& recipes, vector<vector<string>>& ingredients, int i) {\\n        status[i] = CHECKED;\\n        for (string ingredient : ingredients[i]) {\\n            if (suppliesSet.find(ingredient) != suppliesSet.end()) continue;\\n            if (recipesMap.find(ingredient) == recipesMap.end()) return false;\\n            else {\\n                int index = recipesMap[ingredient];\\n                if (status[index] == CHECKED) return false;\\n                if (!check(recipes, ingredients, index)) return false;\\n            }\\n        }\\n        res.push_back(recipes[i]);\\n        suppliesSet.insert(recipes[i]);\\n        return true;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2371676,
                "title": "java-topological-sort-with-explanation",
                "content": "We can utilize a topological sort to find all recipes we can cook. This will yield a **Time Complexity of O(S+R\\\\*I)** and **Space Complexity of O(S+R+I)**, where S is number of supplies, R is number of recipes, and I is ingredients per recipe.\\nThe graph will consist of ingredients (can be a recipe) as nodes and the initial input ingredients per recipe as directed edges.\\nWe can think of each recipe as a child and its ingredients are its parents, since we must be able to cook all ingredients before cooking the recipe. This relation will setup our indegree mapping.\\nThe graph will only contain ingredients that we do not already have in our supplies.\\nSince we need to consider all input recipes, we can utilize an array to represent the amount of prereqs to cook before making the ith recipe.\\n\\nWe will start our sort with a queue containing all recipes without a prereq.\\nThen we update the indegree mappings of each of the recipe\\'s children since its been cooked and is no longer a prereq. If the child\\'s prereqs is now 0, we can cook it, so we add it to our queue.\\n\\n```\\npublic List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n\\t\\tint recipeCount = recipes.length;\\n\\t\\tHashSet<String> supplySet = new HashSet<>(); // Use a set for O(1) lookup\\n\\t\\tfor(String supply : supplies)\\n\\t\\t\\tsupplySet.add(supply);\\n\\t\\tHashMap<String, Integer> index = new HashMap<>(); // Need mapping from ingredient to recipe\\n\\t\\tfor(int i=0;i<recipeCount;i++)\\n\\t\\t\\tindex.put(recipes[i], i);\\n\\t\\tQueue<Integer> queue = new LinkedList<>();\\n\\t\\tList<String> resultList = new ArrayList<>();\\n\\t\\tHashMap<String, List<Integer>> graph = new HashMap<>();\\n\\t\\tint[] inDegreeMap = new int[recipeCount]; // Total prereqs needed until we can cook the recipe\\n\\t\\tfor(int child=0;child<recipeCount;child++){\\n\\t\\t\\tfor(String parent : ingredients.get(child)){\\n\\t\\t\\t\\tif(!supplySet.contains(parent)){ // Only care about what we do not have\\n\\t\\t\\t\\t\\tgraph.putIfAbsent(parent, new ArrayList<>());\\n\\t\\t\\t\\t\\tgraph.get(parent).add(child);\\n\\t\\t\\t\\t\\tinDegreeMap[child]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i=0;i<recipeCount;i++)\\n\\t\\t\\tif(inDegreeMap[i] == 0) queue.add(i); // Add any recipe that has no prereqs\\n\\t\\twhile(!queue.isEmpty()){\\n\\t\\t\\tint recipe = queue.poll();\\n\\t\\t\\tresultList.add(recipes[recipe]);\\n\\t\\t\\tif(!graph.containsKey(recipes[recipe])) continue; // Can skip the rest if we do not need the recipe for others\\n\\t\\t\\tList<Integer> ingrs = graph.get(recipes[recipe]);\\n\\t\\t\\tfor(int item : ingrs)\\n\\t\\t\\t\\tif(--inDegreeMap[item] == 0) queue.add(item); // remove prereq from children since we just completed this recipe\\n\\t\\t}\\n\\t\\treturn resultList;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\npublic List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n\\t\\tint recipeCount = recipes.length;\\n\\t\\tHashSet<String> supplySet = new HashSet<>(); // Use a set for O(1) lookup\\n\\t\\tfor(String supply : supplies)\\n\\t\\t\\tsupplySet.add(supply);\\n\\t\\tHashMap<String, Integer> index = new HashMap<>(); // Need mapping from ingredient to recipe\\n\\t\\tfor(int i=0;i<recipeCount;i++)\\n\\t\\t\\tindex.put(recipes[i], i);\\n\\t\\tQueue<Integer> queue = new LinkedList<>();\\n\\t\\tList<String> resultList = new ArrayList<>();\\n\\t\\tHashMap<String, List<Integer>> graph = new HashMap<>();\\n\\t\\tint[] inDegreeMap = new int[recipeCount]; // Total prereqs needed until we can cook the recipe\\n\\t\\tfor(int child=0;child<recipeCount;child++){\\n\\t\\t\\tfor(String parent : ingredients.get(child)){\\n\\t\\t\\t\\tif(!supplySet.contains(parent)){ // Only care about what we do not have\\n\\t\\t\\t\\t\\tgraph.putIfAbsent(parent, new ArrayList<>());\\n\\t\\t\\t\\t\\tgraph.get(parent).add(child);\\n\\t\\t\\t\\t\\tinDegreeMap[child]++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor(int i=0;i<recipeCount;i++)\\n\\t\\t\\tif(inDegreeMap[i] == 0) queue.add(i); // Add any recipe that has no prereqs\\n\\t\\twhile(!queue.isEmpty()){\\n\\t\\t\\tint recipe = queue.poll();\\n\\t\\t\\tresultList.add(recipes[recipe]);\\n\\t\\t\\tif(!graph.containsKey(recipes[recipe])) continue; // Can skip the rest if we do not need the recipe for others\\n\\t\\t\\tList<Integer> ingrs = graph.get(recipes[recipe]);\\n\\t\\t\\tfor(int item : ingrs)\\n\\t\\t\\t\\tif(--inDegreeMap[item] == 0) queue.add(item); // remove prereq from children since we just completed this recipe\\n\\t\\t}\\n\\t\\treturn resultList;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2370241,
                "title": "swift-topological-sort",
                "content": "\\nrecipes = [\"bread\"], ingredients = [[\"yeast\",\"flour\"]], supplies = [\"yeast\",\"flour\",\"corn\"]\\n\\n\\t\\t\\t\\tyeast       flour\\n\\t\\t\\t\\t\\t  \\\\     /\\n\\t\\t\\tmeat      Bread\\n\\t\\t\\t  \\\\        /\\n\\t\\t\\t  SandWhich\\n\\n```\\nclass Solution {\\n    func findAllRecipes(_ recipes: [String], _ ingredients: [[String]], _ supplies: [String]) -> [String] {\\n        var graph = [String: [String]]()\\n        var inDegree = [String: Int]()\\n        // This points every ingredient to its corresponding recipe\\n        for (recipe, recipeIngredients) in zip(recipes, ingredients) {\\n            for ingredient in recipeIngredients {\\n                graph[ingredient, default: []].append(recipe)\\n                inDegree[recipe, default: 0] += 1\\n            }\\n        }\\n        \\n        // We start the queue with supplies as all supplies are of inDegree 0\\n        var queue = supplies\\n        var doableRecipes = [String]()\\n        while !queue.isEmpty {\\n            // \"food\" because the queue might have ingredients or recipes as well\\n            let food = queue.remove(at: 0)\\n            \\n            // We know graph only references recipes\\n            for recipe in graph[food] ?? [] {\\n                inDegree[recipe]! -= 1\\n                if inDegree[recipe] == 0 {\\n                    // If a recipe is of inDegree 0 that mean we can make it\\n                    doableRecipes.append(recipe)\\n                    // And we also have to check if a recipe is further used to make another recipe\\n                    queue.append(recipe)\\n                }\\n            }\\n        }\\n        \\n        return doableRecipes\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func findAllRecipes(_ recipes: [String], _ ingredients: [[String]], _ supplies: [String]) -> [String] {\\n        var graph = [String: [String]]()\\n        var inDegree = [String: Int]()\\n        // This points every ingredient to its corresponding recipe\\n        for (recipe, recipeIngredients) in zip(recipes, ingredients) {\\n            for ingredient in recipeIngredients {\\n                graph[ingredient, default: []].append(recipe)\\n                inDegree[recipe, default: 0] += 1\\n            }\\n        }\\n        \\n        // We start the queue with supplies as all supplies are of inDegree 0\\n        var queue = supplies\\n        var doableRecipes = [String]()\\n        while !queue.isEmpty {\\n            // \"food\" because the queue might have ingredients or recipes as well\\n            let food = queue.remove(at: 0)\\n            \\n            // We know graph only references recipes\\n            for recipe in graph[food] ?? [] {\\n                inDegree[recipe]! -= 1\\n                if inDegree[recipe] == 0 {\\n                    // If a recipe is of inDegree 0 that mean we can make it\\n                    doableRecipes.append(recipe)\\n                    // And we also have to check if a recipe is further used to make another recipe\\n                    queue.append(recipe)\\n                }\\n            }\\n        }\\n        \\n        return doableRecipes\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2369146,
                "title": "c-topological-sort-single-threaded-multithreaded-just-for-fun",
                "content": "- **Approach-1, Topological Sort**\\n  - [Logic](#l)\\n  - [Complexity](#c)\\n  - [Code](#co)\\n- **Multithreaded Approach**\\n  - [1. condition_variable = semaphore](#cv)\\n  - [2. std::atomic_flag = spinlock](#sl)\\n  - [3. mutex](#m)\\n\\n### Approach-1, Topological Sort\\n<a name=l></a>\\n#### Logic\\n- _1._ Create a graph of only recipies\\n```c\\n    recipes = {\"bread\",\"sandwich\",\"burger\"};\\n   ingredients = {{\"yeast\",\"flour\"},{\"bread\",\"meat\"},{\"sandwich\",\"meat\",\"bread\"}}; \\n                |-------- flour         //supplies = {\"yeast\",\"flour\",\"meat\"};\\n                \\\\/\\n    burger <-- bread <-- yeast\\n     /\\\\ /\\\\      \\\\/\\n     |  |---- sandwitch\\n     |          /\\\\\\n     Meat -------|\\n\\nCreate Graph of Reciepies(without supplies)\\n    burger <-- bread\\n     /\\\\         \\\\/\\n      |--------sandwitch\\n```\\n- _2._ Perform Topological sort on graph, note output in vector and return.\\n\\n<a name=c></a>\\n#### Complexity\\n- **Time:** O(mn). //reciepes: n, ingredients: m\\n- **Space:** O(k + 2n). //supplies:k\\n\\n<a name=co></a>\\n#### Code\\n**CPP**\\n```cpp\\n#include<iostream>\\n#include<vector>\\n#include<string>\\n#include<thread>\\n#include<mutex>\\n#include<atomic>\\n#include<condition_variable>\\n#include<unordered_map>\\n#include<queue>\\n#include<unordered_set>\\nusing vecS = std::vector<std::string>;\\nusing vecVecS = std::vector<vecS>;\\nusing String = std::string;\\nusing graph = std::unordered_map<String, std::unordered_set<String>>;\\n\\nclass Solution {\\n    graph g;\\npublic:\\n    vecS findAllRecipes(vecS& recipes, vecVecS& ingredients, vecS& supplies) {\\n        vecS out;\\n        std::unordered_map<String, vecS> graph;\\n        std::unordered_set<String> s;\\n        for(auto&x : supplies)\\n            s.insert(x);            //store all the supplies in unordered set\\n\\t\\t\\n        std::unordered_map<String,int> indegree;   //to store the indegree of all recipes\\n        for(auto&x : recipes)indegree[x] = 0;                      //initially take the indegree of all recipes to be 0\\n    \\n/*\\n    recipes = {\"bread\",\"sandwich\",\"burger\"};\\n   ingredients = {{\"yeast\",\"flour\"},{\"bread\",\"meat\"},{\"sandwich\",\"meat\",\"bread\"}}; \\n                |-------- flour         //supplies = {\"yeast\",\"flour\",\"meat\"};\\n                \\\\/\\n    burger <-- bread <-- yeast\\n     /\\\\ /\\\\      \\\\/\\n     |  |---- sandwitch\\n     |          /\\\\\\n     Meat -------|\\n\\nCreate Graph of Reciepies(without supplies)\\n    burger <-- bread\\n     /\\\\         \\\\/\\n      |--------sandwitch\\n*/\\n        //For every reciepe, check ingredients.\\n        //if ingredient is not a supply, That means it can be a recipe\\n        //And create a edge to reciepe from ingredient\\n        for(int i = 0; i < recipes.size(); i++){\\n\\n            //Check all ingredients of this reciepe\\n            for(int j = 0; j < (int)ingredients[i].size(); j++){\\n\\n                //Donot include any supplies in Graph\\n                if(s.find(ingredients[i][j]) == s.end()){\\n                    graph[ingredients[i][j]].push_back(recipes[i]);\\n                    indegree[recipes[i]]++;\\n                }\\n            }\\n        }\\n\\n/*\\n    indegree   |burger, 2|bread, 0|sandwitch, 1|\\n*/\\n        //KAHN\\'S ALGORITHM\\n        std::queue<String> q;\\n        for(auto&i : indegree){\\n            if(i.second == 0)\\n                q.push(i.first);\\n        }\\n/*\\n    burger <-- bread\\n     /\\\\         \\\\/\\n      |--------sandwitch\\n                                                out\\n    q |bread|                                   bread\\n    indegree   |burger, 1|sandwitch, 0|\\n\\n    q |sandwitch|                               bread, sandwitch\\n    indegree   |burger, 0|\\n\\n    q |burger|                                  bread, sandwitch, burger\\n*/\\n        while(!q.empty()){\\n            String front = q.front();\\n            q.pop();\\n            out.push_back(front);\\n            for(auto&i : graph[front]){\\n                indegree[i]--;\\n                if(indegree[i] == 0)\\n                    q.push(i);\\n            }\\n        }\\n\\n        return out;\\n    }\\n};\\nint main() {\\n    //vecS recipes = {\"bread\",\"sandwich\",\"burger\"};\\n    //vecVecS ingredients = {{\"yeast\",\"flour\"},{\"bread\",\"meat\"},{\"sandwich\",\"meat\",\"bread\"}}; \\n    //vecS supplies = {\"yeast\",\"flour\",\"meat\"};\\n    vecS recipes = {\"bread\"}; \\n    vecVecS ingredients = {{\"yeast\",\"flour\"}};\\n    vecS supplies = {\"yeast\",\"flour\",\"corn\"};\\n    Solution s;\\n    vecS out = s.findAllRecipes(recipes, ingredients, supplies);\\n    for (auto i:out)\\n        std::cout << i << \",\";\\n}\\n```\\n\\n### Multithreaded Approach\\n<a name=cv></a>\\n#### condition_variable\\n```cpp\\n#include<iostream>\\n#include<vector>\\n#include<string>\\n#include<thread>\\n#include<mutex>\\n#include<atomic>\\n#include<condition_variable>\\n#include<unordered_map>\\n#include<queue>\\n#include<unordered_set>\\n#include<atomic>\\nusing vecS = std::vector<std::string>;\\nusing vecVecS = std::vector<vecS>;\\nusing String = std::string;\\nusing graph = std::unordered_map<String, std::unordered_set<String>>;\\nbool bStart = false;\\nstd::condition_variable cv;\\nstd::mutex m;\\nusing vecS = std::vector<std::string>;\\nusing vecVecS = std::vector<vecS>;\\nusing String = std::string;\\nusing graph = std::unordered_map<String, std::unordered_set<String>>;\\nbool bStart = false;\\nstd::condition_variable cv;\\n\\nclass Solution {\\n    graph g;\\n    std::unordered_map<String, vecS> graph;\\n    std::unordered_set<String> s;\\n    std::unordered_map<String,int> indegree;   //to store the indegree of all recipes\\n    vecS out;\\npublic:\\n    vecS findAllRecipes(vecS& recipes, vecVecS& ingredients, vecS& supplies) {\\n         std::thread t1(&Solution::createGraph, this, ref(recipes), ref(ingredients), ref(supplies));\\n         std::thread t2(&Solution::kahnAlgo, this);\\n         t1.join();\\n         t2.join();\\n         return out;\\n    }\\n\\n    void createGraph(vecS& recipes, vecVecS& ingredients, vecS& supplies) {\\n        std::mutex m;\\n        std::unique_lock<std::mutex> ulock(m);\\n        cv.wait(ulock, []{\\n            return (bStart==false);     //Wait condition should be true to go in\\n            }\\n        );\\n\\n        for(auto&x : supplies)\\n            s.insert(x);            //store all the supplies in unordered set\\n\\n        for(auto&x : recipes)       //initially take the indegree of all recipes to be 0\\n            indegree[x] = 0;\\n\\n        //For every reciepe, check ingredients.\\n        //if ingredient is not a supply, That means it can be a recipe\\n        //And create a edge to reciepe from ingredient\\n        for(int i = 0; i < recipes.size(); i++){\\n\\n            //Check all ingredients of this reciepe\\n            for(int j = 0; j < (int)ingredients[i].size(); j++){\\n\\n                //Donot include any supplies in Graph\\n                if(s.find(ingredients[i][j]) == s.end()){\\n                    graph[ingredients[i][j]].push_back(recipes[i]);\\n                    indegree[recipes[i]]++;\\n                }\\n            }\\n        }\\n        bStart = true;\\n        ulock.unlock();\\n        cv.notify_one();\\n    }\\n\\n    //Perform topological sort on graph using KAHN\\'S ALGORITHM\\n    void kahnAlgo(){\\n        std::mutex m;\\n        std::unique_lock<std::mutex> ulock(m);\\n        cv.wait(ulock, []{\\n            return (bStart==true);     //Wait condition should be true to go in\\n            }\\n        );\\n\\n    //indegree   |burger, 2|bread, 0|sandwitch, 1|\\n        std::queue<String> q;\\n        for(auto&i : indegree){\\n            if(i.second == 0)\\n                q.push(i.first);\\n        }\\n\\n        while(!q.empty()){\\n            String front = q.front();\\n            q.pop();\\n            out.push_back(front);\\n            for(auto&i : graph[front]){\\n                indegree[i]--;\\n                if(indegree[i] == 0)\\n                    q.push(i);\\n            }\\n        }\\n        bStart = false;\\n        ulock.unlock();\\n        cv.notify_one();\\n    }\\n};\\n```\\n\\n<a name=sl></a>\\n#### spinlock\\n```cpp\\n#include<iostream>\\n#include<vector>\\n#include<string>\\n#include<thread>\\n#include<mutex>\\n#include<atomic>\\n#include<condition_variable>\\n#include<unordered_map>\\n#include<queue>\\n#include<unordered_set>\\n#include<atomic>\\nusing vecS = std::vector<std::string>;\\nusing vecVecS = std::vector<vecS>;\\nusing String = std::string;\\nusing graph = std::unordered_map<String, std::unordered_set<String>>;\\nbool bStart = false;\\n\\nclass Spinlock{\\n  std::atomic_flag flag;\\npublic:\\n  Spinlock(): flag(ATOMIC_FLAG_INIT)        //flag=false\\n  {}\\n\\n  void lock(){\\n    while( flag.test_and_set() );           //flag=true\\n  }\\n\\n  void unlock(){\\n    flag.clear();                          //flag=false\\n  }\\n};\\n\\nclass Solution {\\n    graph g;\\n    std::unordered_map<String, vecS> graph;\\n    std::unordered_set<String> s;\\n    std::unordered_map<String,int> indegree;   //to store the indegree of all recipes\\n    vecS out;\\n    Spinlock spinlock;\\npublic:\\n    vecS findAllRecipes(vecS& recipes, vecVecS& ingredients, vecS& supplies) {\\n         std::thread t1(&Solution::createGraph, this, ref(recipes), ref(ingredients), ref(supplies));\\n         std::thread t2(&Solution::kahnAlgo, this);\\n         t1.join();\\n         t2.join();\\n         return out;\\n    }\\n\\n    void createGraph(vecS& recipes, vecVecS& ingredients, vecS& supplies) {\\n        spinlock.lock();\\n        \\n        for(auto&x : supplies)\\n            s.insert(x);            //store all the supplies in unordered set\\n\\n        for(auto&x : recipes)       //initially take the indegree of all recipes to be 0\\n            indegree[x] = 0;\\n\\n        //For every reciepe, check ingredients.\\n        //if ingredient is not a supply, That means it can be a recipe\\n        //And create a edge to reciepe from ingredient\\n        for(int i = 0; i < recipes.size(); i++){\\n\\n            //Check all ingredients of this reciepe\\n            for(int j = 0; j < (int)ingredients[i].size(); j++){\\n\\n                //Donot include any supplies in Graph\\n                if(s.find(ingredients[i][j]) == s.end()){\\n                    graph[ingredients[i][j]].push_back(recipes[i]);\\n                    indegree[recipes[i]]++;\\n                }\\n            }\\n        }\\n        spinlock.unlock();\\n    }\\n\\n    //Perform topological sort on graph using KAHN\\'S ALGORITHM\\n    void kahnAlgo(){\\n        spinlock.lock();\\n\\n    //indegree   |burger, 2|bread, 0|sandwitch, 1|\\n        std::queue<String> q;\\n        for(auto&i : indegree){\\n            if(i.second == 0)\\n                q.push(i.first);\\n        }\\n\\n        while(!q.empty()){\\n            String front = q.front();\\n            q.pop();\\n            out.push_back(front);\\n            for(auto&i : graph[front]){\\n                indegree[i]--;\\n                if(indegree[i] == 0)\\n                    q.push(i);\\n            }\\n        }\\n        spinlock.unlock();\\n    }\\n};\\n```\\n\\n<a name=m></a>\\n#### 3. mutex\\n```cpp\\nusing vecS = std::vector<std::string>;\\nusing vecVecS = std::vector<vecS>;\\nusing String = std::string;\\nusing graph = std::unordered_map<String, std::unordered_set<String>>;\\nbool bStart = false;\\n\\nclass os_implementaion{\\npublic:\\n    class Mutex{\\n    protected:\\n        std::mutex m;       //In Win10 its CRITICAL_SECTION\\n    };\\n};\\nclass os_mutex:private os_implementaion::Mutex{\\npublic:\\n    os_mutex(){\\n        //Initialize mutex\\n    }\\n    ~os_mutex(){\\n        //Destroy mutex     pthread_mutex_destroy()\\n    }\\n    void lock(){\\n        m.lock();       //EnterCriticalSection()\\n    }\\n    void unlock(){\\n        m.unlock();\\n    }\\n};\\nclass WorkerThreadPool {\\n    os_mutex m_mutex;\\n    bool m_blocked;\\npublic:\\n    WorkerThreadPool(){}\\n    void lock(){\\n        m_mutex.lock();\\n        m_blocked = true;\\n    }\\n    void unlock(){\\n        m_mutex.unlock();\\n        m_blocked = false;\\n    }\\n};\\n\\nclass Solution {\\n    WorkerThreadPool w;\\n    graph g;\\n    std::unordered_map<String, vecS> graph;\\n    std::unordered_set<String> s;\\n    std::unordered_map<String,int> indegree;   //to store the indegree of all recipes\\n    vecS out;\\npublic:\\n    vecS findAllRecipes(vecS& recipes, vecVecS& ingredients, vecS& supplies) {\\n         std::thread t1(&Solution::createGraph, this, ref(recipes), ref(ingredients), ref(supplies));\\n         std::thread t2(&Solution::kahnAlgo, this);\\n         t1.join();\\n         t2.join();\\n         return out;\\n    }\\n\\n    void createGraph(vecS& recipes, vecVecS& ingredients, vecS& supplies) {\\n        w.lock();\\n        \\n        for(auto&x : supplies)\\n            s.insert(x);            //store all the supplies in unordered set\\n\\n        for(auto&x : recipes)       //initially take the indegree of all recipes to be 0\\n            indegree[x] = 0;\\n\\n        //For every reciepe, check ingredients.\\n        //if ingredient is not a supply, That means it can be a recipe\\n        //And create a edge to reciepe from ingredient\\n        for(int i = 0; i < recipes.size(); i++){\\n\\n            //Check all ingredients of this reciepe\\n            for(int j = 0; j < (int)ingredients[i].size(); j++){\\n\\n                //Donot include any supplies in Graph\\n                if(s.find(ingredients[i][j]) == s.end()){\\n                    graph[ingredients[i][j]].push_back(recipes[i]);\\n                    indegree[recipes[i]]++;\\n                }\\n            }\\n        }\\n        w.unlock();\\n    }\\n\\n    //Perform topological sort on graph using KAHN\\'S ALGORITHM\\n    void kahnAlgo(){\\n        w.lock();\\n\\n    //indegree   |burger, 2|bread, 0|sandwitch, 1|\\n        std::queue<String> q;\\n        for(auto&i : indegree){\\n            if(i.second == 0)\\n                q.push(i.first);\\n        }\\n\\n        while(!q.empty()){\\n            String front = q.front();\\n            q.pop();\\n            out.push_back(front);\\n            for(auto&i : graph[front]){\\n                indegree[i]--;\\n                if(indegree[i] == 0)\\n                    q.push(i);\\n            }\\n        }\\n        w.unlock();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c\\n    recipes = {\"bread\",\"sandwich\",\"burger\"};\\n   ingredients = {{\"yeast\",\"flour\"},{\"bread\",\"meat\"},{\"sandwich\",\"meat\",\"bread\"}}; \\n                |-------- flour         //supplies = {\"yeast\",\"flour\",\"meat\"};\\n                \\\\/\\n    burger <-- bread <-- yeast\\n     /\\\\ /\\\\      \\\\/\\n     |  |---- sandwitch\\n     |          /\\\\\\n     Meat -------|\\n\\nCreate Graph of Reciepies(without supplies)\\n    burger <-- bread\\n     /\\\\         \\\\/\\n      |--------sandwitch\\n```\n```cpp\\n#include<iostream>\\n#include<vector>\\n#include<string>\\n#include<thread>\\n#include<mutex>\\n#include<atomic>\\n#include<condition_variable>\\n#include<unordered_map>\\n#include<queue>\\n#include<unordered_set>\\nusing vecS = std::vector<std::string>;\\nusing vecVecS = std::vector<vecS>;\\nusing String = std::string;\\nusing graph = std::unordered_map<String, std::unordered_set<String>>;\\n\\nclass Solution {\\n    graph g;\\npublic:\\n    vecS findAllRecipes(vecS& recipes, vecVecS& ingredients, vecS& supplies) {\\n        vecS out;\\n        std::unordered_map<String, vecS> graph;\\n        std::unordered_set<String> s;\\n        for(auto&x : supplies)\\n            s.insert(x);            //store all the supplies in unordered set\\n\\t\\t\\n        std::unordered_map<String,int> indegree;   //to store the indegree of all recipes\\n        for(auto&x : recipes)indegree[x] = 0;                      //initially take the indegree of all recipes to be 0\\n    \\n/*\\n    recipes = {\"bread\",\"sandwich\",\"burger\"};\\n   ingredients = {{\"yeast\",\"flour\"},{\"bread\",\"meat\"},{\"sandwich\",\"meat\",\"bread\"}}; \\n                |-------- flour         //supplies = {\"yeast\",\"flour\",\"meat\"};\\n                \\\\/\\n    burger <-- bread <-- yeast\\n     /\\\\ /\\\\      \\\\/\\n     |  |---- sandwitch\\n     |          /\\\\\\n     Meat -------|\\n\\nCreate Graph of Reciepies(without supplies)\\n    burger <-- bread\\n     /\\\\         \\\\/\\n      |--------sandwitch\\n*/\\n        //For every reciepe, check ingredients.\\n        //if ingredient is not a supply, That means it can be a recipe\\n        //And create a edge to reciepe from ingredient\\n        for(int i = 0; i < recipes.size(); i++){\\n\\n            //Check all ingredients of this reciepe\\n            for(int j = 0; j < (int)ingredients[i].size(); j++){\\n\\n                //Donot include any supplies in Graph\\n                if(s.find(ingredients[i][j]) == s.end()){\\n                    graph[ingredients[i][j]].push_back(recipes[i]);\\n                    indegree[recipes[i]]++;\\n                }\\n            }\\n        }\\n\\n/*\\n    indegree   |burger, 2|bread, 0|sandwitch, 1|\\n*/\\n        //KAHN\\'S ALGORITHM\\n        std::queue<String> q;\\n        for(auto&i : indegree){\\n            if(i.second == 0)\\n                q.push(i.first);\\n        }\\n/*\\n    burger <-- bread\\n     /\\\\         \\\\/\\n      |--------sandwitch\\n                                                out\\n    q |bread|                                   bread\\n    indegree   |burger, 1|sandwitch, 0|\\n\\n    q |sandwitch|                               bread, sandwitch\\n    indegree   |burger, 0|\\n\\n    q |burger|                                  bread, sandwitch, burger\\n*/\\n        while(!q.empty()){\\n            String front = q.front();\\n            q.pop();\\n            out.push_back(front);\\n            for(auto&i : graph[front]){\\n                indegree[i]--;\\n                if(indegree[i] == 0)\\n                    q.push(i);\\n            }\\n        }\\n\\n        return out;\\n    }\\n};\\nint main() {\\n    //vecS recipes = {\"bread\",\"sandwich\",\"burger\"};\\n    //vecVecS ingredients = {{\"yeast\",\"flour\"},{\"bread\",\"meat\"},{\"sandwich\",\"meat\",\"bread\"}}; \\n    //vecS supplies = {\"yeast\",\"flour\",\"meat\"};\\n    vecS recipes = {\"bread\"}; \\n    vecVecS ingredients = {{\"yeast\",\"flour\"}};\\n    vecS supplies = {\"yeast\",\"flour\",\"corn\"};\\n    Solution s;\\n    vecS out = s.findAllRecipes(recipes, ingredients, supplies);\\n    for (auto i:out)\\n        std::cout << i << \",\";\\n}\\n```\n```cpp\\n#include<iostream>\\n#include<vector>\\n#include<string>\\n#include<thread>\\n#include<mutex>\\n#include<atomic>\\n#include<condition_variable>\\n#include<unordered_map>\\n#include<queue>\\n#include<unordered_set>\\n#include<atomic>\\nusing vecS = std::vector<std::string>;\\nusing vecVecS = std::vector<vecS>;\\nusing String = std::string;\\nusing graph = std::unordered_map<String, std::unordered_set<String>>;\\nbool bStart = false;\\nstd::condition_variable cv;\\nstd::mutex m;\\nusing vecS = std::vector<std::string>;\\nusing vecVecS = std::vector<vecS>;\\nusing String = std::string;\\nusing graph = std::unordered_map<String, std::unordered_set<String>>;\\nbool bStart = false;\\nstd::condition_variable cv;\\n\\nclass Solution {\\n    graph g;\\n    std::unordered_map<String, vecS> graph;\\n    std::unordered_set<String> s;\\n    std::unordered_map<String,int> indegree;   //to store the indegree of all recipes\\n    vecS out;\\npublic:\\n    vecS findAllRecipes(vecS& recipes, vecVecS& ingredients, vecS& supplies) {\\n         std::thread t1(&Solution::createGraph, this, ref(recipes), ref(ingredients), ref(supplies));\\n         std::thread t2(&Solution::kahnAlgo, this);\\n         t1.join();\\n         t2.join();\\n         return out;\\n    }\\n\\n    void createGraph(vecS& recipes, vecVecS& ingredients, vecS& supplies) {\\n        std::mutex m;\\n        std::unique_lock<std::mutex> ulock(m);\\n        cv.wait(ulock, []{\\n            return (bStart==false);     //Wait condition should be true to go in\\n            }\\n        );\\n\\n        for(auto&x : supplies)\\n            s.insert(x);            //store all the supplies in unordered set\\n\\n        for(auto&x : recipes)       //initially take the indegree of all recipes to be 0\\n            indegree[x] = 0;\\n\\n        //For every reciepe, check ingredients.\\n        //if ingredient is not a supply, That means it can be a recipe\\n        //And create a edge to reciepe from ingredient\\n        for(int i = 0; i < recipes.size(); i++){\\n\\n            //Check all ingredients of this reciepe\\n            for(int j = 0; j < (int)ingredients[i].size(); j++){\\n\\n                //Donot include any supplies in Graph\\n                if(s.find(ingredients[i][j]) == s.end()){\\n                    graph[ingredients[i][j]].push_back(recipes[i]);\\n                    indegree[recipes[i]]++;\\n                }\\n            }\\n        }\\n        bStart = true;\\n        ulock.unlock();\\n        cv.notify_one();\\n    }\\n\\n    //Perform topological sort on graph using KAHN\\'S ALGORITHM\\n    void kahnAlgo(){\\n        std::mutex m;\\n        std::unique_lock<std::mutex> ulock(m);\\n        cv.wait(ulock, []{\\n            return (bStart==true);     //Wait condition should be true to go in\\n            }\\n        );\\n\\n    //indegree   |burger, 2|bread, 0|sandwitch, 1|\\n        std::queue<String> q;\\n        for(auto&i : indegree){\\n            if(i.second == 0)\\n                q.push(i.first);\\n        }\\n\\n        while(!q.empty()){\\n            String front = q.front();\\n            q.pop();\\n            out.push_back(front);\\n            for(auto&i : graph[front]){\\n                indegree[i]--;\\n                if(indegree[i] == 0)\\n                    q.push(i);\\n            }\\n        }\\n        bStart = false;\\n        ulock.unlock();\\n        cv.notify_one();\\n    }\\n};\\n```\n```cpp\\n#include<iostream>\\n#include<vector>\\n#include<string>\\n#include<thread>\\n#include<mutex>\\n#include<atomic>\\n#include<condition_variable>\\n#include<unordered_map>\\n#include<queue>\\n#include<unordered_set>\\n#include<atomic>\\nusing vecS = std::vector<std::string>;\\nusing vecVecS = std::vector<vecS>;\\nusing String = std::string;\\nusing graph = std::unordered_map<String, std::unordered_set<String>>;\\nbool bStart = false;\\n\\nclass Spinlock{\\n  std::atomic_flag flag;\\npublic:\\n  Spinlock(): flag(ATOMIC_FLAG_INIT)        //flag=false\\n  {}\\n\\n  void lock(){\\n    while( flag.test_and_set() );           //flag=true\\n  }\\n\\n  void unlock(){\\n    flag.clear();                          //flag=false\\n  }\\n};\\n\\nclass Solution {\\n    graph g;\\n    std::unordered_map<String, vecS> graph;\\n    std::unordered_set<String> s;\\n    std::unordered_map<String,int> indegree;   //to store the indegree of all recipes\\n    vecS out;\\n    Spinlock spinlock;\\npublic:\\n    vecS findAllRecipes(vecS& recipes, vecVecS& ingredients, vecS& supplies) {\\n         std::thread t1(&Solution::createGraph, this, ref(recipes), ref(ingredients), ref(supplies));\\n         std::thread t2(&Solution::kahnAlgo, this);\\n         t1.join();\\n         t2.join();\\n         return out;\\n    }\\n\\n    void createGraph(vecS& recipes, vecVecS& ingredients, vecS& supplies) {\\n        spinlock.lock();\\n        \\n        for(auto&x : supplies)\\n            s.insert(x);            //store all the supplies in unordered set\\n\\n        for(auto&x : recipes)       //initially take the indegree of all recipes to be 0\\n            indegree[x] = 0;\\n\\n        //For every reciepe, check ingredients.\\n        //if ingredient is not a supply, That means it can be a recipe\\n        //And create a edge to reciepe from ingredient\\n        for(int i = 0; i < recipes.size(); i++){\\n\\n            //Check all ingredients of this reciepe\\n            for(int j = 0; j < (int)ingredients[i].size(); j++){\\n\\n                //Donot include any supplies in Graph\\n                if(s.find(ingredients[i][j]) == s.end()){\\n                    graph[ingredients[i][j]].push_back(recipes[i]);\\n                    indegree[recipes[i]]++;\\n                }\\n            }\\n        }\\n        spinlock.unlock();\\n    }\\n\\n    //Perform topological sort on graph using KAHN\\'S ALGORITHM\\n    void kahnAlgo(){\\n        spinlock.lock();\\n\\n    //indegree   |burger, 2|bread, 0|sandwitch, 1|\\n        std::queue<String> q;\\n        for(auto&i : indegree){\\n            if(i.second == 0)\\n                q.push(i.first);\\n        }\\n\\n        while(!q.empty()){\\n            String front = q.front();\\n            q.pop();\\n            out.push_back(front);\\n            for(auto&i : graph[front]){\\n                indegree[i]--;\\n                if(indegree[i] == 0)\\n                    q.push(i);\\n            }\\n        }\\n        spinlock.unlock();\\n    }\\n};\\n```\n```cpp\\nusing vecS = std::vector<std::string>;\\nusing vecVecS = std::vector<vecS>;\\nusing String = std::string;\\nusing graph = std::unordered_map<String, std::unordered_set<String>>;\\nbool bStart = false;\\n\\nclass os_implementaion{\\npublic:\\n    class Mutex{\\n    protected:\\n        std::mutex m;       //In Win10 its CRITICAL_SECTION\\n    };\\n};\\nclass os_mutex:private os_implementaion::Mutex{\\npublic:\\n    os_mutex(){\\n        //Initialize mutex\\n    }\\n    ~os_mutex(){\\n        //Destroy mutex     pthread_mutex_destroy()\\n    }\\n    void lock(){\\n        m.lock();       //EnterCriticalSection()\\n    }\\n    void unlock(){\\n        m.unlock();\\n    }\\n};\\nclass WorkerThreadPool {\\n    os_mutex m_mutex;\\n    bool m_blocked;\\npublic:\\n    WorkerThreadPool(){}\\n    void lock(){\\n        m_mutex.lock();\\n        m_blocked = true;\\n    }\\n    void unlock(){\\n        m_mutex.unlock();\\n        m_blocked = false;\\n    }\\n};\\n\\nclass Solution {\\n    WorkerThreadPool w;\\n    graph g;\\n    std::unordered_map<String, vecS> graph;\\n    std::unordered_set<String> s;\\n    std::unordered_map<String,int> indegree;   //to store the indegree of all recipes\\n    vecS out;\\npublic:\\n    vecS findAllRecipes(vecS& recipes, vecVecS& ingredients, vecS& supplies) {\\n         std::thread t1(&Solution::createGraph, this, ref(recipes), ref(ingredients), ref(supplies));\\n         std::thread t2(&Solution::kahnAlgo, this);\\n         t1.join();\\n         t2.join();\\n         return out;\\n    }\\n\\n    void createGraph(vecS& recipes, vecVecS& ingredients, vecS& supplies) {\\n        w.lock();\\n        \\n        for(auto&x : supplies)\\n            s.insert(x);            //store all the supplies in unordered set\\n\\n        for(auto&x : recipes)       //initially take the indegree of all recipes to be 0\\n            indegree[x] = 0;\\n\\n        //For every reciepe, check ingredients.\\n        //if ingredient is not a supply, That means it can be a recipe\\n        //And create a edge to reciepe from ingredient\\n        for(int i = 0; i < recipes.size(); i++){\\n\\n            //Check all ingredients of this reciepe\\n            for(int j = 0; j < (int)ingredients[i].size(); j++){\\n\\n                //Donot include any supplies in Graph\\n                if(s.find(ingredients[i][j]) == s.end()){\\n                    graph[ingredients[i][j]].push_back(recipes[i]);\\n                    indegree[recipes[i]]++;\\n                }\\n            }\\n        }\\n        w.unlock();\\n    }\\n\\n    //Perform topological sort on graph using KAHN\\'S ALGORITHM\\n    void kahnAlgo(){\\n        w.lock();\\n\\n    //indegree   |burger, 2|bread, 0|sandwitch, 1|\\n        std::queue<String> q;\\n        for(auto&i : indegree){\\n            if(i.second == 0)\\n                q.push(i.first);\\n        }\\n\\n        while(!q.empty()){\\n            String front = q.front();\\n            q.pop();\\n            out.push_back(front);\\n            for(auto&i : graph[front]){\\n                indegree[i]--;\\n                if(indegree[i] == 0)\\n                    q.push(i);\\n            }\\n        }\\n        w.unlock();\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2305320,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvector<string> findAllRecipes(vector<string>& r, vector<vector<string>>& in, vector<string>& sup) {\\n\\t\\tint n = r.size();\\n\\t\\tunordered_set<string> s;\\n        \\n\\t\\tfor (auto &e : sup) s.insert(e); //store all the supplies in unordered set\\n\\n\\t\\tunordered_map<string, vector<string>> adj; //adj list\\n\\t\\tunordered_map<string, int> inDegree; //to store the indegree of all recipes\\n\\n\\t\\tfor (auto &e : r) inDegree[e] = 0;  //initially take the indegree of all recipes to be 0\\n\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tfor (int j = 0; j < in[i].size(); ++j) {\\n\\t\\t\\t\\tstring u = r[i], v = in[i][j];\\n\\n\\t\\t\\t\\tif (s.find(v) == s.end()) {     //if the ingredient required to make a recipe is not in supplies then\\n\\t\\t\\t\\t\\tadj[v].push_back(u);         //we need to make a directed edge from that ingredient to recipe\\n\\t\\t\\t\\t\\t++inDegree[u];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n          //KAHN\\'S ALGORITHM\\n\\t\\tqueue<string> q;\\n\\t\\tfor (auto &i : r) if (inDegree[i] == 0) q.push(i);\\n\\n\\t\\tvector<string> ans;\\n\\n\\t\\twhile (q.size()) {\\n\\t\\t\\tint sz = q.size();\\n\\t\\t\\twhile (sz--) {\\n\\t\\t\\t\\tauto node = q.front(); q.pop();\\n\\t\\t\\t\\tans.push_back(node);\\n\\n\\t\\t\\t\\tfor (auto &e : adj[node]) {\\n\\t\\t\\t\\t\\tif (--inDegree[e] == 0) q.push(e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<string> findAllRecipes(vector<string>& r, vector<vector<string>>& in, vector<string>& sup) {\\n\\t\\tint n = r.size();\\n\\t\\tunordered_set<string> s;\\n        \\n\\t\\tfor (auto &e : sup) s.insert(e); //store all the supplies in unordered set\\n\\n\\t\\tunordered_map<string, vector<string>> adj; //adj list\\n\\t\\tunordered_map<string, int> inDegree; //to store the indegree of all recipes\\n\\n\\t\\tfor (auto &e : r) inDegree[e] = 0;  //initially take the indegree of all recipes to be 0\\n\\n\\t\\tfor (int i = 0; i < n; ++i) {\\n\\t\\t\\tfor (int j = 0; j < in[i].size(); ++j) {\\n\\t\\t\\t\\tstring u = r[i], v = in[i][j];\\n\\n\\t\\t\\t\\tif (s.find(v) == s.end()) {     //if the ingredient required to make a recipe is not in supplies then\\n\\t\\t\\t\\t\\tadj[v].push_back(u);         //we need to make a directed edge from that ingredient to recipe\\n\\t\\t\\t\\t\\t++inDegree[u];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n          //KAHN\\'S ALGORITHM\\n\\t\\tqueue<string> q;\\n\\t\\tfor (auto &i : r) if (inDegree[i] == 0) q.push(i);\\n\\n\\t\\tvector<string> ans;\\n\\n\\t\\twhile (q.size()) {\\n\\t\\t\\tint sz = q.size();\\n\\t\\t\\twhile (sz--) {\\n\\t\\t\\t\\tauto node = q.front(); q.pop();\\n\\t\\t\\t\\tans.push_back(node);\\n\\n\\t\\t\\t\\tfor (auto &e : adj[node]) {\\n\\t\\t\\t\\t\\tif (--inDegree[e] == 0) q.push(e);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2299282,
                "title": "c-topological-sort-aka-kahn-s-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n=recipes.size();\\n         unordered_map<string,vector<string>>mp;// use unordered map for better time complexity \\n         unordered_map<string,int>in;\\n        for(int i=0;i<n;i++){\\n            for(string s:ingredients[i]){\\n                in[recipes[i]]++; // storing indegree\\n                mp[s].push_back(recipes[i]);\\n            }\\n        }\\n           queue<string>q;\\n         for(int i=0;i<supplies.size();i++){\\n           q.push(supplies[i]); // pushing all the elements with indegree 0\\n        }\\n        \\n        vector<string>ans;\\n        while(q.empty()==false){\\n            string s=q.front();\\n            q.pop();\\n            for(string x:mp[s]){\\n                if(--in[x]==0){ // checking if indegree is zero. the recipe is made\\n                    ans.push_back(x);\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "String",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n=recipes.size();\\n         unordered_map<string,vector<string>>mp;// use unordered map for better time complexity \\n         unordered_map<string,int>in;\\n        for(int i=0;i<n;i++){\\n            for(string s:ingredients[i]){\\n                in[recipes[i]]++; // storing indegree\\n                mp[s].push_back(recipes[i]);\\n            }\\n        }\\n           queue<string>q;\\n         for(int i=0;i<supplies.size();i++){\\n           q.push(supplies[i]); // pushing all the elements with indegree 0\\n        }\\n        \\n        vector<string>ans;\\n        while(q.empty()==false){\\n            string s=q.front();\\n            q.pop();\\n            for(string x:mp[s]){\\n                if(--in[x]==0){ // checking if indegree is zero. the recipe is made\\n                    ans.push_back(x);\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2297059,
                "title": "python-for-dummies-with-complexity-inline-comment-explanation",
                "content": "```python\\nclass Solution: # time o(n) space o(n)\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        suppliesSet = set(supplies) # include unique supplies only\\n        recipesMap = {} # map the recipes to its ingredients\\n        for i in range(len(recipes)): # loop through all the recipes to map them\\n            recipesMap[recipes[i]] = ingredients[i]\\n        output = [] # initialize output array\\n        for recipe in recipesMap: # loop through all the recipes\\n            if self.canMake(recipe, suppliesSet, recipesMap, set()): # if the recipe can be made\\n                output.append(recipe) # then append it to the output\\n        return output\\n    def canMake(self, recipe, suppliesSet, recipesMap, seen): # adds makeable recipes to our supply set\\n        if recipe in suppliesSet: # if the recipe is already in our supplies\\n            return True # then it can be made\\n        if recipe in seen: # if we considered this recipe before in our dfs\\n            return False # then don\\'t consider it again\\n        if recipe not in recipesMap: # if the recipe is not in our map of recipes\\n            return False # then it can\\'t be made\\n        seen.add(recipe) # add this recipe to seen because we have considered it now\\n        for ingredient in recipesMap[recipe]: # loop through every ingredient of this recipe\\n            if self.canMake(ingredient, suppliesSet, recipesMap, seen) == False: # if ingredient not a potential recipe\\n                return False # then return false\\n        suppliesSet.add(recipe) # add this recipe as a new supply in our supply set\\n        return True",
                "solutionTags": [],
                "code": "class Solution: # time o(n) space o(n)\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        suppliesSet = set(supplies) # include unique supplies only\\n        recipesMap = {}",
                "codeTag": "Java"
            },
            {
                "id": 2284451,
                "title": "simple-o-v-e-faster-than-98-25-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] suppliesArray) {\\n        Set<String> supplies = new HashSet<>();\\n        for(String supply : suppliesArray) {\\n            supplies.add(supply);\\n        }\\n        Map<String, List<String>> recipiesAndIngredients = new HashMap<>();\\n        for(int i = 0; i < recipes.length; i++) {\\n            recipiesAndIngredients.put(recipes[i], ingredients.get(i));\\n        }\\n        Set<String> visited = new HashSet<>();\\n        Set<String> currentPath = new HashSet<>();\\n        \\n        List<String> result = new ArrayList<>();\\n        \\n        for(int i = 0; i < recipes.length; i++) {\\n            if(dfs(recipiesAndIngredients, supplies, visited, currentPath, recipes[i])) {\\n                result.add(recipes[i]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n   \\n    boolean dfs(Map<String, List<String>> recipiesAndIngredients, Set<String> supplies, Set<String> visited, Set<String> currentPath, String recipe) {\\n        if(currentPath.contains(recipe)) {\\n            return false;\\n        }\\n        if(visited.contains(recipe)) {\\n            return true;\\n        }\\n        currentPath.add(recipe);\\n        visited.add(recipe);\\n        List<String> ingredients = recipiesAndIngredients.get(recipe);\\n        \\n        if(ingredients == null) {\\n            return false;\\n        }\\n        \\n        for(String ingredient : ingredients) {\\n            if(!supplies.contains(ingredient) && !dfs(recipiesAndIngredients, supplies, visited, currentPath, ingredient)) {\\n                return false;\\n            }\\n        }\\n        \\n        currentPath.remove(recipe);\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] suppliesArray) {\\n        Set<String> supplies = new HashSet<>();\\n        for(String supply : suppliesArray) {\\n            supplies.add(supply);\\n        }\\n        Map<String, List<String>> recipiesAndIngredients = new HashMap<>();\\n        for(int i = 0; i < recipes.length; i++) {\\n            recipiesAndIngredients.put(recipes[i], ingredients.get(i));\\n        }\\n        Set<String> visited = new HashSet<>();\\n        Set<String> currentPath = new HashSet<>();\\n        \\n        List<String> result = new ArrayList<>();\\n        \\n        for(int i = 0; i < recipes.length; i++) {\\n            if(dfs(recipiesAndIngredients, supplies, visited, currentPath, recipes[i])) {\\n                result.add(recipes[i]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n   \\n    boolean dfs(Map<String, List<String>> recipiesAndIngredients, Set<String> supplies, Set<String> visited, Set<String> currentPath, String recipe) {\\n        if(currentPath.contains(recipe)) {\\n            return false;\\n        }\\n        if(visited.contains(recipe)) {\\n            return true;\\n        }\\n        currentPath.add(recipe);\\n        visited.add(recipe);\\n        List<String> ingredients = recipiesAndIngredients.get(recipe);\\n        \\n        if(ingredients == null) {\\n            return false;\\n        }\\n        \\n        for(String ingredient : ingredients) {\\n            if(!supplies.contains(ingredient) && !dfs(recipiesAndIngredients, supplies, visited, currentPath, ingredient)) {\\n                return false;\\n            }\\n        }\\n        \\n        currentPath.remove(recipe);\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2279420,
                "title": "java-simple-hashmap-hashset",
                "content": "```\\nclass Solution {\\n    \\n    HashSet<String> sups = new HashSet<>();\\n    HashMap<String, List<String>> map = new HashMap<>();\\n    String[] recipes;\\n    HashSet<String> recStack = new HashSet<>();\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        \\n        for (int i = 0; i < recipes.length; i++) {\\n            map.put(recipes[i], ingredients.get(i));\\n        }\\n        \\n        for (String s : supplies) {\\n            sups.add(s);\\n        }\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for (String recipe : recipes) {\\n            if (canBeMade(recipe)) {\\n                res.add(recipe);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public boolean canBeMade(String recipe) {\\n\\n        if (sups.contains(recipe)) {\\n            return true;\\n        }\\n        if (recStack.contains(recipe)) {\\n            return false;\\n        }\\n        \\n        recStack.add(recipe);\\n        \\n        for (String ingr : map.get(recipe)) {\\n            if (sups.contains(ingr) || (map.containsKey(ingr) && canBeMade(ingr))) {\\n                continue;\\n            }\\n            return false;\\n        }\\n        \\n        \\n        \\n        recStack.remove(recipe);\\n        \\n        sups.add(recipe);\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    HashSet<String> sups = new HashSet<>();\\n    HashMap<String, List<String>> map = new HashMap<>();\\n    String[] recipes;\\n    HashSet<String> recStack = new HashSet<>();\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        \\n        for (int i = 0; i < recipes.length; i++) {\\n            map.put(recipes[i], ingredients.get(i));\\n        }\\n        \\n        for (String s : supplies) {\\n            sups.add(s);\\n        }\\n        \\n        List<String> res = new ArrayList<>();\\n        \\n        for (String recipe : recipes) {\\n            if (canBeMade(recipe)) {\\n                res.add(recipe);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    public boolean canBeMade(String recipe) {\\n\\n        if (sups.contains(recipe)) {\\n            return true;\\n        }\\n        if (recStack.contains(recipe)) {\\n            return false;\\n        }\\n        \\n        recStack.add(recipe);\\n        \\n        for (String ingr : map.get(recipe)) {\\n            if (sups.contains(ingr) || (map.containsKey(ingr) && canBeMade(ingr))) {\\n                continue;\\n            }\\n            return false;\\n        }\\n        \\n        \\n        \\n        recStack.remove(recipe);\\n        \\n        sups.add(recipe);\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2272128,
                "title": "dfs-with-memoization-dp-python",
                "content": "This solution recursive checks if a recipie is possible to be made. If one of the ingredients is a recipie , it recursively checks if the recipie is possible to be made and so on.\\n\\n```\\nclass Solution(object):\\n    def findAllRecipes(self, recipes, ingredients, supplies):\\n        \"\"\"\\n        :type recipes: List[str]\\n        :type ingredients: List[List[str]]\\n        :type supplies: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        supplies=set(supplies)\\n        graph={}\\n        can_make={}\\n        \\n        def recur(r):\\n            if(r in supplies):\\n                return True\\n            if(r not in supplies and r not in graph):\\n                return False\\n            if(r not in can_make):\\n                can_make[r]=False\\n                rs=False\\n                for ing in graph[r]:   #All ingredients for that reciepe should be possible to be made\\n                    if(recur(ing)):    # True if it is either in supplies or it was a recipie which as possible to be made\\n                        rs=True\\n                    else:\\n                        rs=False\\n                        break\\n                can_make[r]=rs\\n            return can_make[r]\\n                        \\n            \\n        #Convert to graph\\n        for i in range(len(recipes)):\\n            recipe=recipes[i]\\n            graph[recipe]=[]\\n            for ing in ingredients[i]:\\n                graph[recipe].append(ing)\\n        \\n        #Check if each recipie is possible\\n        res=[]\\n        for rec in recipes:\\n            if(recur(rec)):\\n                res.append(rec)\\n        return res\\n        \\n   ```\\n   \\n   Please upvote if this solution deserved one",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def findAllRecipes(self, recipes, ingredients, supplies):\\n        \"\"\"\\n        :type recipes: List[str]\\n        :type ingredients: List[List[str]]\\n        :type supplies: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        \\n        supplies=set(supplies)\\n        graph={}\\n        can_make={}\\n        \\n        def recur(r):\\n            if(r in supplies):\\n                return True\\n            if(r not in supplies and r not in graph):\\n                return False\\n            if(r not in can_make):\\n                can_make[r]=False\\n                rs=False\\n                for ing in graph[r]:   #All ingredients for that reciepe should be possible to be made\\n                    if(recur(ing)):    # True if it is either in supplies or it was a recipie which as possible to be made\\n                        rs=True\\n                    else:\\n                        rs=False\\n                        break\\n                can_make[r]=rs\\n            return can_make[r]\\n                        \\n            \\n        #Convert to graph\\n        for i in range(len(recipes)):\\n            recipe=recipes[i]\\n            graph[recipe]=[]\\n            for ing in ingredients[i]:\\n                graph[recipe].append(ing)\\n        \\n        #Check if each recipie is possible\\n        res=[]\\n        for rec in recipes:\\n            if(recur(rec)):\\n                res.append(rec)\\n        return res\\n        \\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 2247956,
                "title": "dfs-c-solution",
                "content": "```\\n vector<string> res;\\n    bool dfs(unordered_map<string,vector<string>>& imap, unordered_set<string>& s, unordered_map<string,bool>& canDo, string i, unordered_set<string>& recStack) {\\n        recStack.insert(i);\\n        for (auto it=imap[i].begin(); it!=imap[i].end(); it++) {\\n            if (imap.find(*it) != imap.end()) {\\n                if (canDo[*it]) {\\n                    continue;\\n                }\\n                else {\\n                    if (recStack.find(*it) != recStack.end() || !dfs(imap,s,canDo,*it, recStack)) {\\n                        return false;\\n                    }    \\n                }\\n            }\\n            else {\\n                if (s.find(*it) == s.end()) {\\n                    return false;\\n                }\\n            }    \\n        }\\n        canDo[i] = true;\\n        recStack.erase(i);\\n        return true;\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        unordered_map<string, vector<string>> imap;\\n        for (int i=0; i<recipes.size(); i++) {\\n            imap[recipes[i]] = ingredients[i];\\n                \\n        }\\n        unordered_set<string> s;\\n        for (int i=0; i<supplies.size(); i++) {\\n            s.insert(supplies[i]);\\n        }\\n        unordered_map<string,bool> canDo;\\n        for (int i=0; i<recipes.size(); i++) {\\n            canDo[recipes[i]] = false;\\n        }\\n        unordered_set<string> recStack;\\n        for (int i=0; i<recipes.size(); i++) {\\n            if (dfs(imap,s,canDo,recipes[i], recStack)) {\\n                res.push_back(recipes[i]);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n vector<string> res;\\n    bool dfs(unordered_map<string,vector<string>>& imap, unordered_set<string>& s, unordered_map<string,bool>& canDo, string i, unordered_set<string>& recStack) {\\n        recStack.insert(i);\\n        for (auto it=imap[i].begin(); it!=imap[i].end(); it++) {\\n            if (imap.find(*it) != imap.end()) {\\n                if (canDo[*it]) {\\n                    continue;\\n                }\\n                else {\\n                    if (recStack.find(*it) != recStack.end() || !dfs(imap,s,canDo,*it, recStack)) {\\n                        return false;\\n                    }    \\n                }\\n            }\\n            else {\\n                if (s.find(*it) == s.end()) {\\n                    return false;\\n                }\\n            }    \\n        }\\n        canDo[i] = true;\\n        recStack.erase(i);\\n        return true;\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        unordered_map<string, vector<string>> imap;\\n        for (int i=0; i<recipes.size(); i++) {\\n            imap[recipes[i]] = ingredients[i];\\n                \\n        }\\n        unordered_set<string> s;\\n        for (int i=0; i<supplies.size(); i++) {\\n            s.insert(supplies[i]);\\n        }\\n        unordered_map<string,bool> canDo;\\n        for (int i=0; i<recipes.size(); i++) {\\n            canDo[recipes[i]] = false;\\n        }\\n        unordered_set<string> recStack;\\n        for (int i=0; i<recipes.size(); i++) {\\n            if (dfs(imap,s,canDo,recipes[i], recStack)) {\\n                res.push_back(recipes[i]);\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2234486,
                "title": "python-topsort-solution-for-dummies",
                "content": "```\\n# Topological Sorting Approach: First of all, let\\'s recall the topsort algo, which is a linear ordering of \\n# vertices such that for every directed edge (u, v), vertex \\'u\\' comes before \\'v\\' in the ordering. TopSort \\n# is ONLY possible for Directed Acyclic Graph (DAG). Additionally, we need to point out the concepts of \\n# outdegree (number of outgoing edges) and indegree (number of incoming edges) of a particular vertex. \\n# So, let\\'s treat the problem as a DAG. Also, let\\'s assume supplies are vertices with zero indegree. So the  \\n# vertices with zero indegree will be removed from the graph interatively and more vertices with zero indegree\\n# would appear. Recipe vertices that become zero-indegree in this process would be the expected recipe list:\\n```\\n\\n```\\ndef findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n\\t# Create indegree map: Per DAG theory, \\n\\t# supplies would be the known vertices with zero indegree:\\n\\tindegree = {}\\n\\tfor i in range(len(ingredients)):\\n\\t\\tindegree[recipes[i]] = len(ingredients[i])\\n\\n\\t# Build adjacency list:\\n\\t# Each ingredient will be related to its corresponding recipe:\\n\\tingredientsForRecipes = collections.defaultdict(list)  \\n\\tfor idx in range(len(recipes)):\\n\\t\\tfor ingredient in ingredients[idx]:\\n\\t\\t\\tingredientsForRecipes[ingredient].append(recipes[idx])\\n\\n\\toutput = [] # Create output list\\n\\n\\t# Supplies would be the vertices with zero indegree:\\n\\tfor supply in supplies:\\n\\n\\t\\t# 1) Edge Case: Ingredient is not used in any recipe:\\n\\t\\tif supply not in ingredientsForRecipes:\\n\\t\\t\\tcontinue\\n\\n\\t\\t# Remove supply vertex from the graph and the indegree \\n\\t\\t# of all vertices supply was pointing to decreases by 1:\\n\\t\\tfor recipe in ingredientsForRecipes[supply]:\\n\\t\\t\\tindegree[recipe] -= 1\\n\\n\\t\\t\\t# Check if vertex is a new zero-indegree vertex:\\n\\t\\t\\t# Recipe vertices that become zero-indegree are the result:\\n\\t\\t\\tif indegree[recipe] == 0: \\n\\t\\t\\t\\t# Recipes can also become ingredients:\\n\\t\\t\\t\\tsupplies.append(recipe)\\n\\t\\t\\t\\toutput.append(recipe)\\n\\n\\treturn output\\n\\t\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\n# Topological Sorting Approach: First of all, let\\'s recall the topsort algo, which is a linear ordering of \\n# vertices such that for every directed edge (u, v), vertex \\'u\\' comes before \\'v\\' in the ordering. TopSort \\n# is ONLY possible for Directed Acyclic Graph (DAG). Additionally, we need to point out the concepts of \\n# outdegree (number of outgoing edges) and indegree (number of incoming edges) of a particular vertex. \\n# So, let\\'s treat the problem as a DAG. Also, let\\'s assume supplies are vertices with zero indegree. So the  \\n# vertices with zero indegree will be removed from the graph interatively and more vertices with zero indegree\\n# would appear. Recipe vertices that become zero-indegree in this process would be the expected recipe list:\\n```\n```\\ndef findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n\\t# Create indegree map: Per DAG theory, \\n\\t# supplies would be the known vertices with zero indegree:\\n\\tindegree = {}\\n\\tfor i in range(len(ingredients)):\\n\\t\\tindegree[recipes[i]] = len(ingredients[i])\\n\\n\\t# Build adjacency list:\\n\\t# Each ingredient will be related to its corresponding recipe:\\n\\tingredientsForRecipes = collections.defaultdict(list)  \\n\\tfor idx in range(len(recipes)):\\n\\t\\tfor ingredient in ingredients[idx]:\\n\\t\\t\\tingredientsForRecipes[ingredient].append(recipes[idx])\\n\\n\\toutput = [] # Create output list\\n\\n\\t# Supplies would be the vertices with zero indegree:\\n\\tfor supply in supplies:\\n\\n\\t\\t# 1) Edge Case: Ingredient is not used in any recipe:\\n\\t\\tif supply not in ingredientsForRecipes:\\n\\t\\t\\tcontinue\\n\\n\\t\\t# Remove supply vertex from the graph and the indegree \\n\\t\\t# of all vertices supply was pointing to decreases by 1:\\n\\t\\tfor recipe in ingredientsForRecipes[supply]:\\n\\t\\t\\tindegree[recipe] -= 1\\n\\n\\t\\t\\t# Check if vertex is a new zero-indegree vertex:\\n\\t\\t\\t# Recipe vertices that become zero-indegree are the result:\\n\\t\\t\\tif indegree[recipe] == 0: \\n\\t\\t\\t\\t# Recipes can also become ingredients:\\n\\t\\t\\t\\tsupplies.append(recipe)\\n\\t\\t\\t\\toutput.append(recipe)\\n\\n\\treturn output\\n\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2211324,
                "title": "python-toplogical-sort-zero-indegree-approach",
                "content": "One thought is that this question could reduce to the classic course prerequisite question with a bit variation. By comparing to the course question, supplies would be the known vertices with zero indegree. We remove vertices with zero indegree from the graph interatively and more vertices with zero indegree would appear. Recipe vertices that become zero-indegree in this process would be the results that we are looking for.\\n\\n```python\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        indegree = {recipes[idx]: len(ingredients[idx]) for idx in range(len(ingredients))} # recipe name: indegree mapping\\n        \\n\\t\\t# build adjacency list\\n\\t\\tadj = {}\\n        \\n        for idx in range(len(recipes)):\\n            food = recipes[idx]\\n            for ingredient in ingredients[idx]:\\n                if ingredient not in adj:\\n                    adj[ingredient] = []\\n                adj[ingredient].append(food)\\n                \\n        res = [] # keeps the result\\n\\t\\t\\n        for supply in supplies: # known zero indegree supply / recipe\\n            \\n            if supply not in adj: # not used by others at all\\n                continue\\n            \\n\\t\\t\\t# remove supply vertex from the graph and the indegree of all vertices supply was pointing to decreases by 1 \\n            for recipe in adj[supply]: \\n                indegree[recipe] -= 1\\n                \\n                if indegree[recipe] == 0: # a new zero-indegree vertex appears\\n                    supplies.append(recipe) # (need to check whether it is good to modify the input)\\n                    res.append(recipe)\\n                    \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```python\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        indegree = {recipes[idx]: len(ingredients[idx]) for idx in range(len(ingredients))} # recipe name: indegree mapping\\n        \\n\\t\\t# build adjacency list\\n\\t\\tadj = {}\\n        \\n        for idx in range(len(recipes)):\\n            food = recipes[idx]\\n            for ingredient in ingredients[idx]:\\n                if ingredient not in adj:\\n                    adj[ingredient] = []\\n                adj[ingredient].append(food)\\n                \\n        res = [] # keeps the result\\n\\t\\t\\n        for supply in supplies: # known zero indegree supply / recipe\\n            \\n            if supply not in adj: # not used by others at all\\n                continue\\n            \\n\\t\\t\\t# remove supply vertex from the graph and the indegree of all vertices supply was pointing to decreases by 1 \\n            for recipe in adj[supply]: \\n                indegree[recipe] -= 1\\n                \\n                if indegree[recipe] == 0: # a new zero-indegree vertex appears\\n                    supplies.append(recipe) # (need to check whether it is good to modify the input)\\n                    res.append(recipe)\\n                    \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192484,
                "title": "python-topological-sort-kahns-algo-easy-understanding-explanation",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        # Typical Topological Sort + Khans Algorithm\\n        \\n        # First Create a set of all supplies (helpful for O(1) lookup)\\n        supplies_set = set(supplies)\\n        \\n        # indegree notation (zero when no dependancy) # everything zero at initialization\\n        indegree_map = {recipie: 0 for recipie in recipes}\\n        \\n        # Create adjcency list\\n        # for the receipies whose ingredients are not directly available in supplies\\n        adjListRepresentation = defaultdict(list)\\n        \\n        for receipie_index, ingredients_list in enumerate(ingredients):\\n            for ingridient in ingredients_list:\\n                # check if an ingridient is avaialble in given supplies \\n                # if not, then there is a dependancy, which can be represented as graph\\n                # ingridient -> respective recepie \\n                # also indegree of this recepie must be incremented.\\n                if ingridient not in supplies_set:\\n                    adjListRepresentation[ingridient].append(recipes[receipie_index])\\n                    indegree_map[recipes[receipie_index]] += 1\\n                    \\n        # create a queue to process the recipes\\n        qu = deque()\\n        \\n        # result\\n        result = list()\\n        \\n        # add all those recipes that have zero indegree\\n        for rec, deg in indegree_map.items():\\n            if deg == 0:\\n                qu.append(rec)\\n                \\n        while qu:\\n            top = qu.popleft()\\n            # this recipe can be cooked (because of zero indegree and no dependancy)\\n            result.append(top)\\n            \\n            # check if this recipie is an ingredient for any other and reduce their indegree\\n            for neigh_recip in adjListRepresentation[top]:\\n                indegree_map[neigh_recip] -= 1\\n                # check if any new recip has zero indegree\\n                if indegree_map[neigh_recip] == 0:\\n                    # now this recip can be cooked so add it to the qu\\n                    qu.append(neigh_recip)\\n                    \\n        # return result\\n        return result\\n```\\n\\t\\t\\t\\t\\nInspired from the awesome explanation of https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/discuss/1646622/C%2B%2B-oror-topological-sort-oror-Kahn\\'s-Algo",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        # Typical Topological Sort + Khans Algorithm\\n        \\n        # First Create a set of all supplies (helpful for O(1) lookup)\\n        supplies_set = set(supplies)\\n        \\n        # indegree notation (zero when no dependancy) # everything zero at initialization\\n        indegree_map = {recipie: 0 for recipie in recipes}\\n        \\n        # Create adjcency list\\n        # for the receipies whose ingredients are not directly available in supplies\\n        adjListRepresentation = defaultdict(list)\\n        \\n        for receipie_index, ingredients_list in enumerate(ingredients):\\n            for ingridient in ingredients_list:\\n                # check if an ingridient is avaialble in given supplies \\n                # if not, then there is a dependancy, which can be represented as graph\\n                # ingridient -> respective recepie \\n                # also indegree of this recepie must be incremented.\\n                if ingridient not in supplies_set:\\n                    adjListRepresentation[ingridient].append(recipes[receipie_index])\\n                    indegree_map[recipes[receipie_index]] += 1\\n                    \\n        # create a queue to process the recipes\\n        qu = deque()\\n        \\n        # result\\n        result = list()\\n        \\n        # add all those recipes that have zero indegree\\n        for rec, deg in indegree_map.items():\\n            if deg == 0:\\n                qu.append(rec)\\n                \\n        while qu:\\n            top = qu.popleft()\\n            # this recipe can be cooked (because of zero indegree and no dependancy)\\n            result.append(top)\\n            \\n            # check if this recipie is an ingredient for any other and reduce their indegree\\n            for neigh_recip in adjListRepresentation[top]:\\n                indegree_map[neigh_recip] -= 1\\n                # check if any new recip has zero indegree\\n                if indegree_map[neigh_recip] == 0:\\n                    # now this recip can be cooked so add it to the qu\\n                    qu.append(neigh_recip)\\n                    \\n        # return result\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186787,
                "title": "c-easy-understanding-without-cycle-detection",
                "content": "Simple Solution Using Hashing \\n```\\n vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n=recipes.size();\\n        unordered_set<string>st(supplies.begin(), supplies.end());\\n        vector<string>res;\\n        vector<bool>vis(n,0);\\n        bool flag=true;\\n        //Here flag is used for checking whether previously made recipe is resonsible for making a new  recipe i.e till a new recipes is making we have chances to make a current going recipes\\n        while(flag)\\n        {\\n            flag=false;\\n            for(int i=0; i<n; i++)\\n            {\\n                if(vis[i])\\n                {\\n                    continue;\\n                }\\n                \\n                    bool t=true;\\n                for(string s:ingredients[i])\\n                {\\n                    if(st.find(s)==st.end())\\n                    {\\n                        t=false;\\n                        break;\\n                    }\\n                }\\n                if(t)\\n                {\\n                    st.insert(recipes[i]);\\n                    vis[i]=true;\\n                    flag=true;\\n                    res.push_back(recipes[i]);\\n                }\\n                \\n            }\\n        }\\n        return res;\\n    }\\n```\\nPlease Upvote  if you find easy to understand the core concept",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n=recipes.size();\\n        unordered_set<string>st(supplies.begin(), supplies.end());\\n        vector<string>res;\\n        vector<bool>vis(n,0);\\n        bool flag=true;\\n        //Here flag is used for checking whether previously made recipe is resonsible for making a new  recipe i.e till a new recipes is making we have chances to make a current going recipes\\n        while(flag)\\n        {\\n            flag=false;\\n            for(int i=0; i<n; i++)\\n            {\\n                if(vis[i])\\n                {\\n                    continue;\\n                }\\n                \\n                    bool t=true;\\n                for(string s:ingredients[i])\\n                {\\n                    if(st.find(s)==st.end())\\n                    {\\n                        t=false;\\n                        break;\\n                    }\\n                }\\n                if(t)\\n                {\\n                    st.insert(recipes[i]);\\n                    vis[i]=true;\\n                    flag=true;\\n                    res.push_back(recipes[i]);\\n                }\\n                \\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2168950,
                "title": "c-2-solutions-topological-sort-graph-coloring-kahn-s-algo-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/\\n    \\n    SOLUTION 1\\n    Idea is to convert the recipes and ingredients into a graph, we use an adj list for this.\\n    The main vertex nodes are the recipes and the neighbors are the items needed.\\n    \\n    Then using graph coloring and topological sort, we find whether it is possible to get a recipe \\n    made. For a node under processing, mark it as 0 and once processing finishes it becomes 1.\\n    \\n    TC: O(V + E)\\n    SC: O(N)\\n    \\n    SOLUTION 2\\n    Idea is to convert the recipes and ingredients into a graph, we use an adj list for this.\\n    The main vertex nodes are the ingredients and the neighbors are the recipes needed.\\n    \\n    Then using kahn\\'s algo for topological sort, we find whether it is possible to get a recipe \\n    made. \\n    \\n    TC: O(V + E)\\n    SC: O(N)\\n*/\\nclass Solution {\\npublic:\\n    bool dfs(string curr, unordered_map<string, vector<string> >& graph,\\n            unordered_map<string, int>& visited, unordered_set<string>& all_supplies) {\\n        // mark as processed\\n        visited[curr] = 0;\\n        \\n        // visit unvisited neighbors\\n        for(auto neighbor: graph[curr]) {\\n            // if the ingredient is one of the supply ingredients and it\\'s unavailable,\\n            // then can\\'t create the dish\\n            if(!graph.count(neighbor) && !all_supplies.count(neighbor))\\n                return false;\\n            // if the ingredient is one of the recipes and is already under processing, means there is a cycle\\n            if(visited.count(neighbor) && visited[neighbor] == 0)\\n                return false;\\n            // ingredients is a recipe which has not been processed\\n            if(!visited.count(neighbor) && !dfs(neighbor, graph, visited, all_supplies))\\n                return false;\\n        }\\n        \\n        // finish processing\\n        visited[curr] = 1;\\n        return true;\\n    }\\n    \\n    // SOLUTION 1: TOPOLOGICAL SORT + GRAPH COLORING\\n    vector<string> topologicalDFS(unordered_set<string>& all_supplies,\\n                                 vector<string>& recipes, vector<vector<string>>& ingredients) {\\n        unordered_map<string, int> visited;\\n        vector<string> result;\\n        \\n        // <recipe, [ingredients,..]>\\n        unordered_map<string, vector<string> > graph;\\n        // create a graph with ingredients and recipes. \\n        for(int i = 0; i < recipes.size(); i++) {\\n            for(auto ingredient: ingredients[i])\\n                graph[recipes[i]].emplace_back(ingredient);\\n        }\\n        \\n        // For each recipe check whether it can be made or not\\n        for(int i = 0; i < recipes.size(); i++) {\\n            // Node has not been processed\\n            if(!visited.count(recipes[i]))\\n                dfs(recipes[i], graph, visited, all_supplies);\\n            // If the node has been processed fully\\n            if(visited[recipes[i]] == 1)\\n                result.emplace_back(recipes[i]);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // SOLUTION 2: KAHN\\'S TOPOLOGICAL SORT\\n    // TC: O(V + E)\\n    // SC: O(N)\\n    vector<string> topologicalKahn(unordered_set<string>& all_supplies,\\n                                 vector<string>& recipes, vector<vector<string>>& ingredients) {\\n        unordered_map<string, int> indegree;\\n        // <ingredients, [recipe,..]>\\n        unordered_map<string, vector<string> > graph;\\n        vector<string> result;\\n        \\n        // For each recipe, find the dependency ingredients\\n        // If an ingredient is not in supply, then that counts towrds\\n        // the indegree\\n        for(int i = 0; i < recipes.size(); i++) {\\n            indegree[recipes[i]] = 0;\\n            for(auto ingredient: ingredients[i]) {\\n                // ingredient is not supply, hence might be a recipe\\n                // so it is a dependency\\n                if(!all_supplies.count(ingredient))\\n                    ++indegree[recipes[i]];\\n                graph[ingredient].emplace_back(recipes[i]);\\n            }\\n        }\\n        \\n        queue<string> q;\\n        // indegree nodes will always be some recipe, find the\\n        // ones which has all the req ingredients first\\n        for(auto [node, degree]: indegree) \\n            if(indegree[node] == 0)\\n                q.emplace(node);\\n        \\n        while(!q.empty()) {\\n            auto curr = q.front();\\n            q.pop();\\n            \\n            result.emplace_back(curr);\\n            // For the current recipe, check if it is an ingredient\\n            // for some other recipe\\n            for(auto neighbor: graph[curr]) {\\n                --indegree[neighbor];\\n                if(indegree[neighbor] == 0)\\n                    q.emplace(neighbor);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        unordered_set<string> all_supplies(supplies.begin(), supplies.end());\\n        // For each node, there are two states: {1 (fully processed), 0 (partially processed)}\\n        \\n        // Solution 1\\n        return topologicalDFS(all_supplies, recipes, ingredients);\\n        // Solution 2: Kahn\\'s Algo\\n        // return topologicalKahn(all_supplies, recipes, ingredients);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/\\n    \\n    SOLUTION 1\\n    Idea is to convert the recipes and ingredients into a graph, we use an adj list for this.\\n    The main vertex nodes are the recipes and the neighbors are the items needed.\\n    \\n    Then using graph coloring and topological sort, we find whether it is possible to get a recipe \\n    made. For a node under processing, mark it as 0 and once processing finishes it becomes 1.\\n    \\n    TC: O(V + E)\\n    SC: O(N)\\n    \\n    SOLUTION 2\\n    Idea is to convert the recipes and ingredients into a graph, we use an adj list for this.\\n    The main vertex nodes are the ingredients and the neighbors are the recipes needed.\\n    \\n    Then using kahn\\'s algo for topological sort, we find whether it is possible to get a recipe \\n    made. \\n    \\n    TC: O(V + E)\\n    SC: O(N)\\n*/\\nclass Solution {\\npublic:\\n    bool dfs(string curr, unordered_map<string, vector<string> >& graph,\\n            unordered_map<string, int>& visited, unordered_set<string>& all_supplies) {\\n        // mark as processed\\n        visited[curr] = 0;\\n        \\n        // visit unvisited neighbors\\n        for(auto neighbor: graph[curr]) {\\n            // if the ingredient is one of the supply ingredients and it\\'s unavailable,\\n            // then can\\'t create the dish\\n            if(!graph.count(neighbor) && !all_supplies.count(neighbor))\\n                return false;\\n            // if the ingredient is one of the recipes and is already under processing, means there is a cycle\\n            if(visited.count(neighbor) && visited[neighbor] == 0)\\n                return false;\\n            // ingredients is a recipe which has not been processed\\n            if(!visited.count(neighbor) && !dfs(neighbor, graph, visited, all_supplies))\\n                return false;\\n        }\\n        \\n        // finish processing\\n        visited[curr] = 1;\\n        return true;\\n    }\\n    \\n    // SOLUTION 1: TOPOLOGICAL SORT + GRAPH COLORING\\n    vector<string> topologicalDFS(unordered_set<string>& all_supplies,\\n                                 vector<string>& recipes, vector<vector<string>>& ingredients) {\\n        unordered_map<string, int> visited;\\n        vector<string> result;\\n        \\n        // <recipe, [ingredients,..]>\\n        unordered_map<string, vector<string> > graph;\\n        // create a graph with ingredients and recipes. \\n        for(int i = 0; i < recipes.size(); i++) {\\n            for(auto ingredient: ingredients[i])\\n                graph[recipes[i]].emplace_back(ingredient);\\n        }\\n        \\n        // For each recipe check whether it can be made or not\\n        for(int i = 0; i < recipes.size(); i++) {\\n            // Node has not been processed\\n            if(!visited.count(recipes[i]))\\n                dfs(recipes[i], graph, visited, all_supplies);\\n            // If the node has been processed fully\\n            if(visited[recipes[i]] == 1)\\n                result.emplace_back(recipes[i]);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    // SOLUTION 2: KAHN\\'S TOPOLOGICAL SORT\\n    // TC: O(V + E)\\n    // SC: O(N)\\n    vector<string> topologicalKahn(unordered_set<string>& all_supplies,\\n                                 vector<string>& recipes, vector<vector<string>>& ingredients) {\\n        unordered_map<string, int> indegree;\\n        // <ingredients, [recipe,..]>\\n        unordered_map<string, vector<string> > graph;\\n        vector<string> result;\\n        \\n        // For each recipe, find the dependency ingredients\\n        // If an ingredient is not in supply, then that counts towrds\\n        // the indegree\\n        for(int i = 0; i < recipes.size(); i++) {\\n            indegree[recipes[i]] = 0;\\n            for(auto ingredient: ingredients[i]) {\\n                // ingredient is not supply, hence might be a recipe\\n                // so it is a dependency\\n                if(!all_supplies.count(ingredient))\\n                    ++indegree[recipes[i]];\\n                graph[ingredient].emplace_back(recipes[i]);\\n            }\\n        }\\n        \\n        queue<string> q;\\n        // indegree nodes will always be some recipe, find the\\n        // ones which has all the req ingredients first\\n        for(auto [node, degree]: indegree) \\n            if(indegree[node] == 0)\\n                q.emplace(node);\\n        \\n        while(!q.empty()) {\\n            auto curr = q.front();\\n            q.pop();\\n            \\n            result.emplace_back(curr);\\n            // For the current recipe, check if it is an ingredient\\n            // for some other recipe\\n            for(auto neighbor: graph[curr]) {\\n                --indegree[neighbor];\\n                if(indegree[neighbor] == 0)\\n                    q.emplace(neighbor);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n    \\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        unordered_set<string> all_supplies(supplies.begin(), supplies.end());\\n        // For each node, there are two states: {1 (fully processed), 0 (partially processed)}\\n        \\n        // Solution 1\\n        return topologicalDFS(all_supplies, recipes, ingredients);\\n        // Solution 2: Kahn\\'s Algo\\n        // return topologicalKahn(all_supplies, recipes, ingredients);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2165919,
                "title": "java-topological-sort-khan-s-algo-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, List<String>> adjacencyList = new HashMap();\\n        Map<String, Integer> inDegree = new HashMap();\\n        int n = recipes.length;\\n        for(int i = 0; i<n; i++){\\n            for(String igd: ingredients.get(i)){\\n                adjacencyList.putIfAbsent(igd, new ArrayList());\\n                adjacencyList.get(igd).add(recipes[i]);\\n            }\\n            inDegree.put(recipes[i], ingredients.get(i).size());\\n        }\\n        Queue<String> q = new LinkedList();\\n        for(String s : supplies){\\n            q.offer(s);\\n        }\\n        List<String> res = new LinkedList();\\n        while(!q.isEmpty()){\\n                String ing = q.poll();\\n                if(adjacencyList.containsKey(ing)){\\n                    for(String rec : adjacencyList.get(ing)){\\n                        inDegree.put(rec, inDegree.get(rec)-1);\\n                        if(inDegree.get(rec)==0){\\n                            res.add(rec);\\n                            q.add(rec);\\n                        }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, List<String>> adjacencyList = new HashMap();\\n        Map<String, Integer> inDegree = new HashMap();\\n        int n = recipes.length;\\n        for(int i = 0; i<n; i++){\\n            for(String igd: ingredients.get(i)){\\n                adjacencyList.putIfAbsent(igd, new ArrayList());\\n                adjacencyList.get(igd).add(recipes[i]);\\n            }\\n            inDegree.put(recipes[i], ingredients.get(i).size());\\n        }\\n        Queue<String> q = new LinkedList();\\n        for(String s : supplies){\\n            q.offer(s);\\n        }\\n        List<String> res = new LinkedList();\\n        while(!q.isEmpty()){\\n                String ing = q.poll();\\n                if(adjacencyList.containsKey(ing)){\\n                    for(String rec : adjacencyList.get(ing)){\\n                        inDegree.put(rec, inDegree.get(rec)-1);\\n                        if(inDegree.get(rec)==0){\\n                            res.add(rec);\\n                            q.add(rec);\\n                        }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162048,
                "title": "readable-dfs-with-memoizaiton-java",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashSet<String> suppliesSet = new HashSet<>();\\n        HashMap<String, HashSet<String>> adjList = new HashMap<>();\\n        List<String> ans = new ArrayList<>();\\n        HashSet<String> visited = new HashSet<>();\\n        \\n        for (String supply : supplies) suppliesSet.add(supply);\\n        for (int i = 0; i < recipes.length; i++) adjList.put(recipes[i], new HashSet<>(ingredients.get(i)));\\n\\n        for (String recipe : recipes) {\\n            if (dfs(recipe, adjList, suppliesSet, visited)) {\\n                ans.add(recipe);\\n            }\\n        }\\n        \\n        return ans;        \\n    }\\n    \\n    private boolean dfs(String parent, HashMap<String, HashSet<String>> adjList, HashSet<String> suppliesSet, HashSet<String> visited) {\\n        if (suppliesSet.contains(parent)) return true;\\n        if (visited.contains(parent) || !adjList.containsKey(parent)) return false;\\n        visited.add(parent);\\n        int countIngredients = 0;\\n        for (String neighbor : adjList.get(parent)) {\\n            if (dfs(neighbor, adjList, suppliesSet, visited)) countIngredients++;\\n        }\\n        \\n        if (countIngredients == adjList.get(parent).size()) {\\n            suppliesSet.add(parent);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Memoization",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashSet<String> suppliesSet = new HashSet<>();\\n        HashMap<String, HashSet<String>> adjList = new HashMap<>();\\n        List<String> ans = new ArrayList<>();\\n        HashSet<String> visited = new HashSet<>();\\n        \\n        for (String supply : supplies) suppliesSet.add(supply);\\n        for (int i = 0; i < recipes.length; i++) adjList.put(recipes[i], new HashSet<>(ingredients.get(i)));\\n\\n        for (String recipe : recipes) {\\n            if (dfs(recipe, adjList, suppliesSet, visited)) {\\n                ans.add(recipe);\\n            }\\n        }\\n        \\n        return ans;        \\n    }\\n    \\n    private boolean dfs(String parent, HashMap<String, HashSet<String>> adjList, HashSet<String> suppliesSet, HashSet<String> visited) {\\n        if (suppliesSet.contains(parent)) return true;\\n        if (visited.contains(parent) || !adjList.containsKey(parent)) return false;\\n        visited.add(parent);\\n        int countIngredients = 0;\\n        for (String neighbor : adjList.get(parent)) {\\n            if (dfs(neighbor, adjList, suppliesSet, visited)) countIngredients++;\\n        }\\n        \\n        if (countIngredients == adjList.get(parent).size()) {\\n            suppliesSet.add(parent);\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2155173,
                "title": "java-dfs-solution-beginner-friendly",
                "content": "The basic idea is to iterate for every recipe all the required ingredients , if the required ingredients contains another recipe and it turns out to be achievable so we also mark that recipe as true so as to avoid iterating twice.\\n\\n```\\nclass Solution {\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashMap<String,List<String>> map = new HashMap<>();\\n        for(int i=0;i<recipes.length;i++){\\n            map.put(recipes[i],ingredients.get(i));\\n        }\\n        HashSet<String> sup = new HashSet<>();\\n        for(String a : supplies) sup.add(a);\\n        List<String> ans = new ArrayList<>();\\n        HashSet<String> cont = new HashSet<>();\\n        HashSet<String> vis = new HashSet<>();\\n        for(String s : recipes){\\n            if(!cont.contains(s)){\\n                if(dfs(s,map,sup,cont,vis)) ans.add(s);\\n            }\\n            else ans.add(s);\\n        }\\n        return ans;\\n    }\\n    \\n    boolean dfs(String s,HashMap<String,List<String>> map,HashSet<String> sup,HashSet<String> cont,HashSet<String> vis){\\n        if(vis.contains(s)) return false;\\n        if(cont.contains(s)) return true;\\n        if(!map.containsKey(s)) return sup.contains(s);\\n        boolean a =true;\\n        vis.add(s);\\n        for(String h : map.get(s)){\\n            if(!dfs(h,map,sup,cont,vis)) return false;\\n        }\\n        cont.add(s);\\n        vis.remove(s);\\n        return true;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashMap<String,List<String>> map = new HashMap<>();\\n        for(int i=0;i<recipes.length;i++){\\n            map.put(recipes[i],ingredients.get(i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2154100,
                "title": "c-simple-topo-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        map<string,vector<string>> adj;  // adj list using map.\\n        map<string,int> indegree;        // indegree track using map.\\n        \\n        for(int i=0;i<ingredients.size();i++){      // inserting values to adj and indegree.\\n            for(int j=0;j<ingredients[i].size();j++){\\n                \\n                adj[ingredients[i][j]].push_back(recipes[i]);\\n                indegree[recipes[i]]++;\\n                \\n            }\\n        }\\n        \\n        queue<string> q;\\n        vector<string> ans;\\n        \\n        for(int i=0;i<supplies.size();i++) q.push(supplies[i]); // supplies will have indeg as 0 .\\n        \\n        while(!q.empty()){                      // doing basic topplogical sort stuff.\\n            string node = q.front();\\n            q.pop();\\n            \\n            for(auto it:adj[node]){\\n                indegree[it]--;\\n                if(indegree[it] == 0){\\n                    q.push(it);\\n                    ans.push_back(it);          // whenever indegree is 0 that means it can be made.\\n                } \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        map<string,vector<string>> adj;  // adj list using map.\\n        map<string,int> indegree;        // indegree track using map.\\n        \\n        for(int i=0;i<ingredients.size();i++){      // inserting values to adj and indegree.\\n            for(int j=0;j<ingredients[i].size();j++){\\n                \\n                adj[ingredients[i][j]].push_back(recipes[i]);\\n                indegree[recipes[i]]++;\\n                \\n            }\\n        }\\n        \\n        queue<string> q;\\n        vector<string> ans;\\n        \\n        for(int i=0;i<supplies.size();i++) q.push(supplies[i]); // supplies will have indeg as 0 .\\n        \\n        while(!q.empty()){                      // doing basic topplogical sort stuff.\\n            string node = q.front();\\n            q.pop();\\n            \\n            for(auto it:adj[node]){\\n                indegree[it]--;\\n                if(indegree[it] == 0){\\n                    q.push(it);\\n                    ans.push_back(it);          // whenever indegree is 0 that means it can be made.\\n                } \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136327,
                "title": "topological-sort-simple-solution",
                "content": "SElf explanatory code as purely based on topological sort and maintained the degree and dependency for a node and proceeded further.\\n\\t\\n\\tpublic List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, Integer> outDegree = new HashMap<>();\\n        Map<String, List<String>> dependentElement = new HashMap<>();\\n        List<String> result = new ArrayList<>();\\n        \\n        for(int i = 0 ; i< recipes.length ; i++){\\n            for(int j = 0 ; j < ingredients.get(i).size(); j++){\\n                String ingredient = ingredients.get(i).get(j);\\n                dependentElement.computeIfAbsent(ingredient, k -> new ArrayList<>()).add(recipes[i]);\\n            }\\n             outDegree.put(recipes[i], ingredients.get(i).size());\\n        }\\n        \\n        Queue<String> suppliesQueue = new LinkedList<>();\\n        \\n        for(int i = 0 ; i< supplies.length ; i++){\\n            suppliesQueue.add(supplies[i]);\\n        }\\n        \\n        while(!suppliesQueue.isEmpty()){\\n            String supply = suppliesQueue.poll();\\n            if(dependentElement.containsKey(supply)){\\n                for(String dependent : dependentElement.get(supply)){\\n                    int degree = outDegree.computeIfPresent(dependent, (k,v) -> v-1);\\n                    if(degree == 0){\\n                        suppliesQueue.add(dependent);\\n                        result.add(dependent);\\n                    }\\n                }\\n            }\\n        }\\n        \\n       return result;\\n        \\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "SElf explanatory code as purely based on topological sort and maintained the degree and dependency for a node and proceeded further.\\n\\t\\n\\tpublic List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, Integer> outDegree = new HashMap<>();\\n        Map<String, List<String>> dependentElement = new HashMap<>();\\n        List<String> result = new ArrayList<>();\\n        \\n        for(int i = 0 ; i< recipes.length ; i++){\\n            for(int j = 0 ; j < ingredients.get(i).size(); j++){\\n                String ingredient = ingredients.get(i).get(j);\\n                dependentElement.computeIfAbsent(ingredient, k -> new ArrayList<>()).add(recipes[i]);\\n            }\\n             outDegree.put(recipes[i], ingredients.get(i).size());\\n        }\\n        \\n        Queue<String> suppliesQueue = new LinkedList<>();\\n        \\n        for(int i = 0 ; i< supplies.length ; i++){\\n            suppliesQueue.add(supplies[i]);\\n        }\\n        \\n        while(!suppliesQueue.isEmpty()){\\n            String supply = suppliesQueue.poll();\\n            if(dependentElement.containsKey(supply)){\\n                for(String dependent : dependentElement.get(supply)){\\n                    int degree = outDegree.computeIfPresent(dependent, (k,v) -> v-1);\\n                    if(degree == 0){\\n                        suppliesQueue.add(dependent);\\n                        result.add(dependent);\\n                    }\\n                }\\n            }\\n        }\\n        \\n       return result;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2125625,
                "title": "c-tle-easy-understanding",
                "content": "class Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        \\n        int n=recipes.size();\\n        unordered_set<string> supply(supplies.begin(),supplies.end());\\n        cout<<supply.size();\\n        unordered_set<int> done;\\n        vector<string> ans;\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n        \\n            for(int i=0;i<n;i++)\\n            // traverse on recipes\\n              {\\n            \\n            \\n            \\n            if(done.find(i)==done.end())\\n            {\\n                \\n            bool can_make=true;\\n            for(int k=0;k<ingredients[i].size();k++)\\n            {\\n                if(supply.find(ingredients[i][k])==supply.end())\\n                {\\n                    can_make=false;\\n                    break;\\n                }\\n            }\\n            \\n            if(can_make==true)\\n            {\\n                supply.insert(recipes[i]);\\n                ans.push_back(recipes[i]);\\n                done.insert(i);\\n            }\\n            \\n        }\\n          \\n            \\n        }\\n        }\\n        \\n    \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        \\n        int n=recipes.size();\\n        unordered_set<string> supply(supplies.begin(),supplies.end());\\n        cout<<supply.size();\\n        unordered_set<int> done;\\n        vector<string> ans;\\n        \\n        for(int j=0;j<n;j++)\\n        {\\n        \\n            for(int i=0;i<n;i++)\\n            // traverse on recipes\\n              {\\n            \\n            \\n            \\n            if(done.find(i)==done.end())\\n            {\\n                \\n            bool can_make=true;\\n            for(int k=0;k<ingredients[i].size();k++)\\n            {\\n                if(supply.find(ingredients[i][k])==supply.end())\\n                {\\n                    can_make=false;\\n                    break;\\n                }",
                "codeTag": "C++"
            },
            {
                "id": 2099892,
                "title": "rust-topological-sort-with-cow-borrowed-100ms",
                "content": "`std::borrow::Cow` helps to avoid cloning the strings.\\n\\n```rust\\nuse std::borrow::Cow;\\nuse std::collections::{HashMap, HashSet, VecDeque};\\n\\nimpl Solution {\\n    pub fn find_all_recipes(\\n        recipes: Vec<String>,\\n        ingredients: Vec<Vec<String>>,\\n        supplies: Vec<String>,\\n    ) -> Vec<String> {\\n        let (graph, mut indegree) = Self::build_graph(&recipes, &ingredients);\\n        let recipes = recipes.iter().collect::<HashSet<_>>();\\n        let supplies = supplies.into_iter().collect::<HashSet<_>>();\\n\\n        let mut queue = supplies.iter().collect::<VecDeque<_>>();\\n        let mut result = vec![];\\n\\n        while let Some(node) = queue.pop_front() {\\n            if recipes.contains(node) {\\n                result.push(node.clone());\\n            }\\n\\n            for adjacent in graph.get(node).into_iter().flatten() {\\n                let node_indegree = indegree.get_mut(adjacent).unwrap();\\n                *node_indegree -= 1;\\n                if *node_indegree == 0 {\\n                    queue.push_back(adjacent);\\n                }\\n            }\\n        }\\n\\n        result\\n    }\\n\\n    fn build_graph<\\'a>(\\n        recipes: &\\'a [String],\\n        ingredients: &\\'a Vec<Vec<String>>,\\n    ) -> (HashMap<Cow<\\'a, String>, Vec<Cow<\\'a, String>>>, HashMap<Cow<\\'a, String>, i32>) {\\n        let mut graph = HashMap::new();\\n        let mut indegree = HashMap::new();\\n        for (recipe, recipe_ingredients) in recipes.iter().zip(ingredients) {\\n            for ingredient in recipe_ingredients {\\n                graph\\n                    .entry(Cow::Borrowed(ingredient))\\n                    .or_insert_with(|| Vec::with_capacity(recipe_ingredients.len()))\\n                    .push(Cow::Borrowed(recipe));\\n                *indegree.entry(Cow::Borrowed(recipe)).or_insert(0) += 1;\\n            }\\n        }\\n\\n        (graph, indegree)\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```rust\\nuse std::borrow::Cow;\\nuse std::collections::{HashMap, HashSet, VecDeque};\\n\\nimpl Solution {\\n    pub fn find_all_recipes(\\n        recipes: Vec<String>,\\n        ingredients: Vec<Vec<String>>,\\n        supplies: Vec<String>,\\n    ) -> Vec<String> {\\n        let (graph, mut indegree) = Self::build_graph(&recipes, &ingredients);\\n        let recipes = recipes.iter().collect::<HashSet<_>>();\\n        let supplies = supplies.into_iter().collect::<HashSet<_>>();\\n\\n        let mut queue = supplies.iter().collect::<VecDeque<_>>();\\n        let mut result = vec![];\\n\\n        while let Some(node) = queue.pop_front() {\\n            if recipes.contains(node) {\\n                result.push(node.clone());\\n            }\\n\\n            for adjacent in graph.get(node).into_iter().flatten() {\\n                let node_indegree = indegree.get_mut(adjacent).unwrap();\\n                *node_indegree -= 1;\\n                if *node_indegree == 0 {\\n                    queue.push_back(adjacent);\\n                }\\n            }\\n        }\\n\\n        result\\n    }\\n\\n    fn build_graph<\\'a>(\\n        recipes: &\\'a [String],\\n        ingredients: &\\'a Vec<Vec<String>>,\\n    ) -> (HashMap<Cow<\\'a, String>, Vec<Cow<\\'a, String>>>, HashMap<Cow<\\'a, String>, i32>) {\\n        let mut graph = HashMap::new();\\n        let mut indegree = HashMap::new();\\n        for (recipe, recipe_ingredients) in recipes.iter().zip(ingredients) {\\n            for ingredient in recipe_ingredients {\\n                graph\\n                    .entry(Cow::Borrowed(ingredient))\\n                    .or_insert_with(|| Vec::with_capacity(recipe_ingredients.len()))\\n                    .push(Cow::Borrowed(recipe));\\n                *indegree.entry(Cow::Borrowed(recipe)).or_insert(0) += 1;\\n            }\\n        }\\n\\n        (graph, indegree)\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2095796,
                "title": "python-dfs-no-topo-sort",
                "content": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        res = set()\\n        for r, recipe in enumerate(recipes):\\n            self.dfs(recipe, recipes, ingredients[r], ingredients, supplies, res, set())\\n        return list(res)\\n            \\n    def dfs(self, recipe: str, recipes: List[str], ingredients: List[str], all_ingredients: List[List[str]], supplies: List[str], res: List[str], visited):\\n        possible = True\\n        for ingredient in ingredients:\\n            if ingredient in supplies:\\n                continue\\n            if ingredient in res:\\n                continue\\n            if ingredient in recipes:\\n                if ingredient not in visited:\\n                    visited.add(ingredient)\\n                    self.dfs(ingredient, recipes, all_ingredients[recipes.index(ingredient)], all_ingredients, supplies, res, visited)\\n                    if ingredient in res:\\n                        continue\\n            possible = False\\n            break\\n        if possible:\\n            res.add(recipe)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        res = set()\\n        for r, recipe in enumerate(recipes):\\n            self.dfs(recipe, recipes, ingredients[r], ingredients, supplies, res, set())\\n        return list(res)\\n            \\n    def dfs(self, recipe: str, recipes: List[str], ingredients: List[str], all_ingredients: List[List[str]], supplies: List[str], res: List[str], visited):\\n        possible = True\\n        for ingredient in ingredients:\\n            if ingredient in supplies:\\n                continue\\n            if ingredient in res:\\n                continue\\n            if ingredient in recipes:\\n                if ingredient not in visited:\\n                    visited.add(ingredient)\\n                    self.dfs(ingredient, recipes, all_ingredients[recipes.index(ingredient)], all_ingredients, supplies, res, visited)\\n                    if ingredient in res:\\n                        continue\\n            possible = False\\n            break\\n        if possible:\\n            res.add(recipe)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2094690,
                "title": "python-simplified-topological-sort",
                "content": "\\n\\nhere I simplified the topological sort process, compared with other top sort algs posted in the duscuss.\\n\\n```\\ndef findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        ## topological sort approach 5/31/2022\\n        indeg={}\\n        g=defaultdict(set)\\n        for rec,ingre in zip(recipes, ingredients):\\n            for ing in ingre:\\n                g[ing].add(rec)\\n                indeg[rec]=indeg.get(rec,0)+1\\n        ## search the graph\\n        wanted=set(recipes)\\n        res=[]\\n        dq=deque([])\\n        for rec in supplies:\\n            dq.append(rec)\\n        while dq:\\n            rec=dq.popleft()\\n            if rec in wanted:\\n                res.append(rec)\\n            for nxt in g.pop(rec,set()):\\n                indeg[nxt]-=1\\n                if indeg[nxt]==0:\\n                    dq.append(nxt)\\n        return res",
                "solutionTags": [],
                "code": "\\n\\nhere I simplified the topological sort process, compared with other top sort algs posted in the duscuss.\\n\\n```\\ndef findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        ## topological sort approach 5/31/2022\\n        indeg={}\\n        g=defaultdict(set)\\n        for rec,ingre in zip(recipes, ingredients):\\n            for ing in ingre:\\n                g[ing].add(rec)\\n                indeg[rec]=indeg.get(rec,0)+1\\n        ## search the graph\\n        wanted=set(recipes)\\n        res=[]\\n        dq=deque([])\\n        for rec in supplies:\\n            dq.append(rec)\\n        while dq:\\n            rec=dq.popleft()\\n            if rec in wanted:\\n                res.append(rec)\\n            for nxt in g.pop(rec,set()):\\n                indeg[nxt]-=1\\n                if indeg[nxt]==0:\\n                    dq.append(nxt)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2074719,
                "title": "python-bfs-set",
                "content": "Would like to share my solution using set and BFS.\\n\\nThe idea is to use a set to represent recipe and update the set each time a new recipe is made. \\n\\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        if recipes is None or ingredients is None or supplies is None:\\n            return []\\n        # each time we examine the supplies and ingredients to see if we can get\\n        # new recipe done\\n        # we add them to the supplies for future use\\n        suppliesSet = set()\\n        for supply in supplies:\\n            suppliesSet.add(supply)\\n        returnRecipe = []\\n        # Interate until no new recipes can be made in a full cycle\\n        while True:\\n            terminate = True\\n            for i in range(len(ingredients)):\\n                if recipes[i] in suppliesSet:\\n                    continue\\n                made = True\\n                for ingredient in ingredients[i]:\\n                    if ingredient not in suppliesSet:\\n                        made = False\\n                        break\\n                # if one recipe could be made, append it to suppliesSet\\n                if made:\\n                    returnRecipe.append(recipes[i])\\n                    suppliesSet.add(recipes[i])\\n                    terminate = False\\n            if terminate: break\\n                \\n        return returnRecipe\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        if recipes is None or ingredients is None or supplies is None:\\n            return []\\n        # each time we examine the supplies and ingredients to see if we can get\\n        # new recipe done\\n        # we add them to the supplies for future use\\n        suppliesSet = set()\\n        for supply in supplies:\\n            suppliesSet.add(supply)\\n        returnRecipe = []\\n        # Interate until no new recipes can be made in a full cycle\\n        while True:\\n            terminate = True\\n            for i in range(len(ingredients)):\\n                if recipes[i] in suppliesSet:\\n                    continue\\n                made = True\\n                for ingredient in ingredients[i]:\\n                    if ingredient not in suppliesSet:\\n                        made = False\\n                        break\\n                # if one recipe could be made, append it to suppliesSet\\n                if made:\\n                    returnRecipe.append(recipes[i])\\n                    suppliesSet.add(recipes[i])\\n                    terminate = False\\n            if terminate: break\\n                \\n        return returnRecipe\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2065045,
                "title": "java-standard-topological-sort-solution",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        final Map<String, Integer> indegreeMap = new HashMap<>();\\n        final Map<String, List<String>> dependencyMap = new HashMap<>();\\n        \\n        List<String> supplyList = new ArrayList<>();\\n        for(String s : supplies)\\n        {\\n            supplyList.add(s);\\n        }\\n        \\n        for(String s : recipes)\\n        {\\n            indegreeMap.put(s, 0);\\n            dependencyMap.put(s, new ArrayList<String>());\\n        }\\n        \\n        for(int i = 0; i < ingredients.size(); i++)\\n        {\\n            List<String> list = ingredients.get(i);\\n            for(String s : list)\\n            {\\n                if(indegreeMap.containsKey(s))\\n                {\\n                    String item = recipes[i];\\n                    indegreeMap.put(item, indegreeMap.get(item) + 1);\\n                    dependencyMap.get(item).add(s);\\n                }\\n            }\\n        }\\n        \\n        // Start with those items that do not have any dependency on recipe\\n        // i.e they need simple ingredients        \\n        final Queue<String> queue = new LinkedList<>();\\n        \\n        for(String s : indegreeMap.keySet())\\n        {\\n            if(indegreeMap.get(s) == 0)\\n            {\\n                queue.add(s);\\n            }\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        \\n        while(!queue.isEmpty())\\n        {\\n            String item = queue.poll();\\n            indegreeMap.remove(item);\\n            dependencyMap.remove(item);\\n            \\n            // see if this item can be prepared.\\n            int idx = 0;\\n            for(int i=0;i<recipes.length;i++)\\n            {\\n                if(recipes[i].equals(item))\\n                {\\n                    idx = i;\\n                    break;\\n                }\\n            }\\n            \\n            List<String> remainingIngredients = ingredients.get(idx);\\n            for(String s : supplyList)\\n            {\\n                if(remainingIngredients.contains(s))\\n                {\\n                    remainingIngredients.remove(s);\\n                }\\n            }        \\n            \\n            if(remainingIngredients.size() == 0)\\n            {\\n                result.add(item);\\n                supplyList.add(item);\\n            }\\n            \\n            for(String s : dependencyMap.keySet())\\n            {\\n                if(dependencyMap.get(s).contains(item))\\n                {\\n                    dependencyMap.get(s).remove(item);\\n                    indegreeMap.put(s, indegreeMap.get(s) - 1);\\n                    \\n                    if(indegreeMap.get(s) == 0)\\n                    {\\n                        queue.add(s);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        final Map<String, Integer> indegreeMap = new HashMap<>();\\n        final Map<String, List<String>> dependencyMap = new HashMap<>();\\n        \\n        List<String> supplyList = new ArrayList<>();\\n        for(String s : supplies)\\n        {\\n            supplyList.add(s);\\n        }\\n        \\n        for(String s : recipes)\\n        {\\n            indegreeMap.put(s, 0);\\n            dependencyMap.put(s, new ArrayList<String>());\\n        }\\n        \\n        for(int i = 0; i < ingredients.size(); i++)\\n        {\\n            List<String> list = ingredients.get(i);\\n            for(String s : list)\\n            {\\n                if(indegreeMap.containsKey(s))\\n                {\\n                    String item = recipes[i];\\n                    indegreeMap.put(item, indegreeMap.get(item) + 1);\\n                    dependencyMap.get(item).add(s);\\n                }\\n            }\\n        }\\n        \\n        // Start with those items that do not have any dependency on recipe\\n        // i.e they need simple ingredients        \\n        final Queue<String> queue = new LinkedList<>();\\n        \\n        for(String s : indegreeMap.keySet())\\n        {\\n            if(indegreeMap.get(s) == 0)\\n            {\\n                queue.add(s);\\n            }\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        \\n        while(!queue.isEmpty())\\n        {\\n            String item = queue.poll();\\n            indegreeMap.remove(item);\\n            dependencyMap.remove(item);\\n            \\n            // see if this item can be prepared.\\n            int idx = 0;\\n            for(int i=0;i<recipes.length;i++)\\n            {\\n                if(recipes[i].equals(item))\\n                {\\n                    idx = i;\\n                    break;\\n                }\\n            }\\n            \\n            List<String> remainingIngredients = ingredients.get(idx);\\n            for(String s : supplyList)\\n            {\\n                if(remainingIngredients.contains(s))\\n                {\\n                    remainingIngredients.remove(s);\\n                }\\n            }        \\n            \\n            if(remainingIngredients.size() == 0)\\n            {\\n                result.add(item);\\n                supplyList.add(item);\\n            }\\n            \\n            for(String s : dependencyMap.keySet())\\n            {\\n                if(dependencyMap.get(s).contains(item))\\n                {\\n                    dependencyMap.get(s).remove(item);\\n                    indegreeMap.put(s, indegreeMap.get(s) - 1);\\n                    \\n                    if(indegreeMap.get(s) == 0)\\n                    {\\n                        queue.add(s);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058147,
                "title": "google-frequently-asked-topological-sort-java",
                "content": "I tried to provide detailed comments below for the more logic intensive part of the code. The first 2/3 of this solution, though, is spent initializing our different data structures. Please comment below if you have any doubts and upvote if you found this implementation helpful!\\n\\nTime Complexity: O(R * MAX(I)), where R = length of recipes array and MAX(I) = max length of ArrayList in ingredients\\nSpace Complexity: O(MAX(S, R, I)), where S = supplied, R = recipes, and I = ingredients\\n\\n```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        List<String> allRecipes = new ArrayList<>();\\n        Queue<String> que = new LinkedList<>();\\n        for (String s : supplies) {\\n            que.offer(s);\\n        }\\n        \\n        Map<String, List<String>> adjacency = new HashMap<>();\\n        Map<String, Integer> indegree = new HashMap<>();\\n        /*\\n\\t\\tInitialize our two Maps. Indegree is a mapping of {Recipe : indegree} and adjacency is a map of {ingredient, list of recipes}\\n\\t\\t*/\\n        for (int i = 0; i < recipes.length; i++) {\\n            for (String ingredient : ingredients.get(i)) {\\n                adjacency.putIfAbsent(ingredient, new ArrayList<>());\\n                adjacency.get(ingredient).add(recipes[i]);\\n                indegree.put(recipes[i], indegree.getOrDefault(recipes[i], 0) + 1);\\n            }\\n        }\\n        /*\\n\\t\\tThis next section is the only non-initialization part of the process. We begin by polling one of our supplies from the queue.\\n\\t\\tIf this supply is an ingredient for one of our recipes, proceed into the FOR loop. Since at this point we know it\\'s in at least\\n\\t\\tone of our recipes, we loop through to see if it\\'s used in others as well. For each recipe we find, decrement that recipe\\'s\\n\\t\\tindegree. \\n\\t\\t\\n\\t\\tOnce a recipe has an indegree of 0, this means that we successfully baked that food, and we can now add it to our result\\n\\t\\tArrayList. Also, make sure to add it to the queue, since we can use this baked good to help us bake other goods now.\\n\\t\\t*/\\n        while (!que.isEmpty()) {\\n            String supply = que.poll();\\n            if (adjacency.containsKey(supply)) {\\n                for (String desiredRecipe : adjacency.get(supply)) {\\n                    indegree.put(desiredRecipe, indegree.get(desiredRecipe) - 1);\\n                    if (indegree.get(desiredRecipe) == 0) {\\n                        que.offer(desiredRecipe);\\n                        allRecipes.add(desiredRecipe);\\n                    }\\n                }\\n            }\\n        }\\n        return allRecipes;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        List<String> allRecipes = new ArrayList<>();\\n        Queue<String> que = new LinkedList<>();\\n        for (String s : supplies) {\\n            que.offer(s);\\n        }\\n        \\n        Map<String, List<String>> adjacency = new HashMap<>();\\n        Map<String, Integer> indegree = new HashMap<>();\\n        /*\\n\\t\\tInitialize our two Maps. Indegree is a mapping of {Recipe : indegree} and adjacency is a map of {ingredient, list of recipes}\\n\\t\\t*/\\n        for (int i = 0; i < recipes.length; i++) {\\n            for (String ingredient : ingredients.get(i)) {\\n                adjacency.putIfAbsent(ingredient, new ArrayList<>());\\n                adjacency.get(ingredient).add(recipes[i]);\\n                indegree.put(recipes[i], indegree.getOrDefault(recipes[i], 0) + 1);\\n            }\\n        }\\n        /*\\n\\t\\tThis next section is the only non-initialization part of the process. We begin by polling one of our supplies from the queue.\\n\\t\\tIf this supply is an ingredient for one of our recipes, proceed into the FOR loop. Since at this point we know it\\'s in at least\\n\\t\\tone of our recipes, we loop through to see if it\\'s used in others as well. For each recipe we find, decrement that recipe\\'s\\n\\t\\tindegree. \\n\\t\\t\\n\\t\\tOnce a recipe has an indegree of 0, this means that we successfully baked that food, and we can now add it to our result\\n\\t\\tArrayList. Also, make sure to add it to the queue, since we can use this baked good to help us bake other goods now.\\n\\t\\t*/\\n        while (!que.isEmpty()) {\\n            String supply = que.poll();\\n            if (adjacency.containsKey(supply)) {\\n                for (String desiredRecipe : adjacency.get(supply)) {\\n                    indegree.put(desiredRecipe, indegree.get(desiredRecipe) - 1);\\n                    if (indegree.get(desiredRecipe) == 0) {\\n                        que.offer(desiredRecipe);\\n                        allRecipes.add(desiredRecipe);\\n                    }\\n                }\\n            }\\n        }\\n        return allRecipes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2051218,
                "title": "java-bfs-using-kahn-s-algorithm",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, Set<String>> map = new HashMap<>();\\n        Map<String, Integer> indegree = new HashMap<>();\\n        int n = ingredients.size();\\n        \\n        /*Let\\'s build our adjaceny map and our indegree map.\\n        So this is how your map is going to look like for the 3 examples\\n        Example 1: \\n        Adjacency map: {flour=[bread], yeast=[bread]}\\n        Indegree map:  {bread=2}\\n        \\n        Example 2: \\n        Adjacency map: {bread=[sandwich], flour=[bread], meat=[sandwich], yeast=[bread]}\\n        Indegree map:  {bread=2, sandwich=2}\\n        \\n        Example 3: \\n        Adjacency map: {bread=[burger, sandwich], flour=[bread], meat=[burger, sandwich], sandwich=[burger], yeast=[bread]}\\n        Indegree map:  {bread=2, burger=3, sandwich=2}\\n        */\\n        for(int i=0; i<n; i++){\\n           for(String item : ingredients.get(i)){\\n               map.putIfAbsent(item, new HashSet<>());\\n               map.get(item).add(recipes[i]);\\n               indegree.put(recipes[i], indegree.getOrDefault(recipes[i], 0) + 1);\\n           }\\n        }\\n        \\n        Queue<String> queue = new ArrayDeque<>();\\n        /*You start with all the supplies, so let\\'s push them at the\\n        beginning of the queue*/\\n        for(String supply: supplies)\\n            queue.offer(supply);\\n        \\n        /*Do the BFS now, and add it in queue only when indegree is 0,\\n        as suggested by Kahn. Don\\'t forget to reduce the indegree of the\\n        adjacent nodes.*/\\n        while(!queue.isEmpty()){\\n            String current = queue.poll();\\n            if(map.containsKey(current)){\\n                for(String child: map.get(current)){\\n                    indegree.put(child, indegree.get(child) - 1);\\n                    if(indegree.get(child) == 0)\\n                        queue.add(child);\\n                }\\n            }\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        \\n        /*Check the recipes which you were able to reach, they would have\\n        indegree 0*/\\n        for(Map.Entry<String,Integer> entry : indegree.entrySet()){\\n            if(entry.getValue() == 0)\\n                result.add(entry.getKey());\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, Set<String>> map = new HashMap<>();\\n        Map<String, Integer> indegree = new HashMap<>();\\n        int n = ingredients.size();\\n        \\n        /*Let\\'s build our adjaceny map and our indegree map.\\n        So this is how your map is going to look like for the 3 examples\\n        Example 1: \\n        Adjacency map: {flour=[bread], yeast=[bread]}\\n        Indegree map:  {bread=2}\\n        \\n        Example 2: \\n        Adjacency map: {bread=[sandwich], flour=[bread], meat=[sandwich], yeast=[bread]}\\n        Indegree map:  {bread=2, sandwich=2}\\n        \\n        Example 3: \\n        Adjacency map: {bread=[burger, sandwich], flour=[bread], meat=[burger, sandwich], sandwich=[burger], yeast=[bread]}\\n        Indegree map:  {bread=2, burger=3, sandwich=2}\\n        */\\n        for(int i=0; i<n; i++){\\n           for(String item : ingredients.get(i)){\\n               map.putIfAbsent(item, new HashSet<>());\\n               map.get(item).add(recipes[i]);\\n               indegree.put(recipes[i], indegree.getOrDefault(recipes[i], 0) + 1);\\n           }\\n        }\\n        \\n        Queue<String> queue = new ArrayDeque<>();\\n        /*You start with all the supplies, so let\\'s push them at the\\n        beginning of the queue*/\\n        for(String supply: supplies)\\n            queue.offer(supply);\\n        \\n        /*Do the BFS now, and add it in queue only when indegree is 0,\\n        as suggested by Kahn. Don\\'t forget to reduce the indegree of the\\n        adjacent nodes.*/\\n        while(!queue.isEmpty()){\\n            String current = queue.poll();\\n            if(map.containsKey(current)){\\n                for(String child: map.get(current)){\\n                    indegree.put(child, indegree.get(child) - 1);\\n                    if(indegree.get(child) == 0)\\n                        queue.add(child);\\n                }\\n            }\\n        }\\n        \\n        List<String> result = new ArrayList<>();\\n        \\n        /*Check the recipes which you were able to reach, they would have\\n        indegree 0*/\\n        for(Map.Entry<String,Integer> entry : indegree.entrySet()){\\n            if(entry.getValue() == 0)\\n                result.add(entry.getKey());\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2047916,
                "title": "c-topology-solution-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& r, vector<vector<string>>& ing, vector<string>& w) {\\n        const short n = r.size();\\n        unordered_set<string> hash;\\n        unordered_map<string,vector<short>> m;\\n        int indCount[n];\\n        queue<short> q;\\n        vector<string> ans;\\n        for(const string &i:w) hash.insert(i);\\n        \\n        for(short i = 0;i<n;i++){\\n            indCount[i] = 0;\\n            for(const string &s:ing[i]){\\n                m[s].emplace_back(i);   \\n                if(hash.find(s) == hash.end()) indCount[i]++;\\n            }\\n            if(indCount[i] == 0) q.push(i);\\n        }      \\n        while(!q.empty()){   \\n            int node = q.front();\\n            q.pop();\\n            ans.emplace_back(r[node]);\\n            for(const short &it:m[r[node]]){\\n                indCount[it]--;\\n                if(indCount[it] == 0) q.push(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& r, vector<vector<string>>& ing, vector<string>& w) {\\n        const short n = r.size();\\n        unordered_set<string> hash;\\n        unordered_map<string,vector<short>> m;\\n        int indCount[n];\\n        queue<short> q;\\n        vector<string> ans;\\n        for(const string &i:w) hash.insert(i);\\n        \\n        for(short i = 0;i<n;i++){\\n            indCount[i] = 0;\\n            for(const string &s:ing[i]){\\n                m[s].emplace_back(i);   \\n                if(hash.find(s) == hash.end()) indCount[i]++;\\n            }\\n            if(indCount[i] == 0) q.push(i);\\n        }      \\n        while(!q.empty()){   \\n            int node = q.front();\\n            q.pop();\\n            ans.emplace_back(r[node]);\\n            for(const short &it:m[r[node]]){\\n                indCount[it]--;\\n                if(indCount[it] == 0) q.push(it);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044897,
                "title": "c-solution-topological-sort-kahn-s-algorithm",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n = recipes.size();\\n        int current = 0;\\n\\n        unordered_map<string,vector<string>> outgoing;\\n        unordered_map<string,int> incoming;\\n        for (auto ingredient : ingredients) {\\n            for (auto i : ingredient) {\\n                outgoing[i].push_back(recipes[current]);\\n                incoming[recipes[current]]++;\\n            }\\n            current++;\\n        }\\n        \\n        queue<string> que;\\n        for (auto supply : supplies) {\\n            que.push(supply);\\n        }\\n        \\n        vector<string> answer;\\n        while (!que.empty()) {\\n            auto ingredient = que.front();\\n            que.pop();\\n\\n            for (auto next : outgoing[ingredient]) {\\n                incoming[next]--;\\n                if (incoming[next] == 0) {\\n                    answer.push_back(next);\\n                    que.push(next);\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n = recipes.size();\\n        int current = 0;\\n\\n        unordered_map<string,vector<string>> outgoing;\\n        unordered_map<string,int> incoming;\\n        for (auto ingredient : ingredients) {\\n            for (auto i : ingredient) {\\n                outgoing[i].push_back(recipes[current]);\\n                incoming[recipes[current]]++;\\n            }\\n            current++;\\n        }\\n        \\n        queue<string> que;\\n        for (auto supply : supplies) {\\n            que.push(supply);\\n        }\\n        \\n        vector<string> answer;\\n        while (!que.empty()) {\\n            auto ingredient = que.front();\\n            que.pop();\\n\\n            for (auto next : outgoing[ingredient]) {\\n                incoming[next]--;\\n                if (incoming[next] == 0) {\\n                    answer.push_back(next);\\n                    que.push(next);\\n                }\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2008703,
                "title": "dfs-memoization-cycle-aversion",
                "content": "There was no way I could have done this in an interview in 15 minutes, proud to present - DFS + memoization + cycle aversion\\n```\\npublic List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        int i = 0;\\n        for(String rec : recipes) {\\n            map.put(rec, ingredients.get(i));\\n            for(String item: ingredients.get(i)) {\\n                if(!map.containsKey(item))\\n                map.put(item, null);\\n            }\\n            i++;\\n        }\\n        \\n        Map<String, Boolean> supplyMap = new HashMap<>();\\n        for(String supply : supplies) {\\n            supplyMap.put(supply, true);\\n        }\\n        for(String rec : recipes) {\\n            if(!supplyMap.containsKey(rec)) {\\n               dfs(rec, map, supplyMap);\\n            }\\n        }\\n        List<String> out = new ArrayList<>();\\n        Set<String> set = supplyMap.keySet();\\n        for(String rec : recipes) {\\n            if(supplyMap.containsKey(rec) && supplyMap.get(rec)) {\\n             out.add(rec);   \\n            }\\n        }\\n        return out;\\n    }\\n    boolean dfs(String recIng, Map<String, List<String>> map, Map<String, Boolean> supplyMap) {\\n        if(supplyMap.containsKey(recIng)) {\\n            return supplyMap.get(recIng);\\n        }\\n        if(map.get(recIng) == null) { //ingre\\n            supplyMap.put(recIng, false);\\n            return false;\\n        }\\n        else { //recepie\\n            if(supplyMap.containsKey(recIng) && !supplyMap.get(recIng)) {\\n                return false; //cycle\\n            }\\n            supplyMap.put(recIng, false);\\n            for(int i = 0; i < map.get(recIng).size(); i++) {                \\n                if(dfs(map.get(recIng).get(i), map, supplyMap)) {\\n                    supplyMap.put(map.get(recIng).get(i), true);\\n                }\\n                else {\\n                    return false;\\n                }\\n            }\\n            supplyMap.put(recIng, true);\\n            return true;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, List<String>> map = new HashMap<>();\\n        int i = 0;\\n        for(String rec : recipes) {\\n            map.put(rec, ingredients.get(i));\\n            for(String item: ingredients.get(i)) {\\n                if(!map.containsKey(item))\\n                map.put(item, null);\\n            }\\n            i++;\\n        }\\n        \\n        Map<String, Boolean> supplyMap = new HashMap<>();\\n        for(String supply : supplies) {\\n            supplyMap.put(supply, true);\\n        }\\n        for(String rec : recipes) {\\n            if(!supplyMap.containsKey(rec)) {\\n               dfs(rec, map, supplyMap);\\n            }\\n        }\\n        List<String> out = new ArrayList<>();\\n        Set<String> set = supplyMap.keySet();\\n        for(String rec : recipes) {\\n            if(supplyMap.containsKey(rec) && supplyMap.get(rec)) {\\n             out.add(rec);   \\n            }\\n        }\\n        return out;\\n    }\\n    boolean dfs(String recIng, Map<String, List<String>> map, Map<String, Boolean> supplyMap) {\\n        if(supplyMap.containsKey(recIng)) {\\n            return supplyMap.get(recIng);\\n        }\\n        if(map.get(recIng) == null) { //ingre\\n            supplyMap.put(recIng, false);\\n            return false;\\n        }\\n        else { //recepie\\n            if(supplyMap.containsKey(recIng) && !supplyMap.get(recIng)) {\\n                return false; //cycle\\n            }\\n            supplyMap.put(recIng, false);\\n            for(int i = 0; i < map.get(recIng).size(); i++) {                \\n                if(dfs(map.get(recIng).get(i), map, supplyMap)) {\\n                    supplyMap.put(map.get(recIng).get(i), true);\\n                }\\n                else {\\n                    return false;\\n                }\\n            }\\n            supplyMap.put(recIng, true);\\n            return true;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2007615,
                "title": "java-topological-sorting-elegant-and-concise-solution",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        HashSet<String> recipesSet = new HashSet<>();\\n        HashSet<String> ingredientsSet = new HashSet<>();\\n        \\n        HashMap<String, Integer> inorderMap = new HashMap<>();\\n        int recipeNum = 0;\\n        for(List<String> ingredientList : ingredients){\\n            for(String ingredient : ingredientList){\\n                map.computeIfAbsent(ingredient, k -> new ArrayList<>()).add(recipes[recipeNum]);\\n                ingredientsSet.add(ingredient);\\n                inorderMap.put(recipes[recipeNum], inorderMap.getOrDefault(recipes[recipeNum], 0) + 1);\\n            }\\n            \\n            recipesSet.add(recipes[recipeNum]);\\n            recipeNum++;\\n        }\\n        \\n        HashSet<String> suppliesSet = new HashSet<>();\\n        for(String s : supplies){\\n            suppliesSet.add(s);\\n        }\\n        \\n        // Do the topological sorting\\n        Stack<String> st = new Stack<>();\\n        for(String ingredient : ingredientsSet){\\n            if(!inorderMap.containsKey(ingredient) && suppliesSet.contains(ingredient)){\\n                st.push(ingredient);\\n            }\\n        }\\n        \\n        List<String> ans = new ArrayList<>();\\n        while(!st.isEmpty()){\\n            String ele = st.pop();\\n            \\n            if(recipesSet.contains(ele)) ans.add(ele);\\n            if(!map.containsKey(ele)) continue;\\n            \\n            for(String s : map.get(ele)){\\n                // Decrease the inorder by 1\\n                inorderMap.put(s, inorderMap.getOrDefault(s, 0) - 1);\\n                \\n                if(inorderMap.get(s) == 0) st.push(s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        HashMap<String, List<String>> map = new HashMap<>();\\n        HashSet<String> recipesSet = new HashSet<>();\\n        HashSet<String> ingredientsSet = new HashSet<>();\\n        \\n        HashMap<String, Integer> inorderMap = new HashMap<>();\\n        int recipeNum = 0;\\n        for(List<String> ingredientList : ingredients){\\n            for(String ingredient : ingredientList){\\n                map.computeIfAbsent(ingredient, k -> new ArrayList<>()).add(recipes[recipeNum]);\\n                ingredientsSet.add(ingredient);\\n                inorderMap.put(recipes[recipeNum], inorderMap.getOrDefault(recipes[recipeNum], 0) + 1);\\n            }\\n            \\n            recipesSet.add(recipes[recipeNum]);\\n            recipeNum++;\\n        }\\n        \\n        HashSet<String> suppliesSet = new HashSet<>();\\n        for(String s : supplies){\\n            suppliesSet.add(s);\\n        }\\n        \\n        // Do the topological sorting\\n        Stack<String> st = new Stack<>();\\n        for(String ingredient : ingredientsSet){\\n            if(!inorderMap.containsKey(ingredient) && suppliesSet.contains(ingredient)){\\n                st.push(ingredient);\\n            }\\n        }\\n        \\n        List<String> ans = new ArrayList<>();\\n        while(!st.isEmpty()){\\n            String ele = st.pop();\\n            \\n            if(recipesSet.contains(ele)) ans.add(ele);\\n            if(!map.containsKey(ele)) continue;\\n            \\n            for(String s : map.get(ele)){\\n                // Decrease the inorder by 1\\n                inorderMap.put(s, inorderMap.getOrDefault(s, 0) - 1);\\n                \\n                if(inorderMap.get(s) == 0) st.push(s);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004832,
                "title": "python-with-explanation-topological-based-approach",
                "content": "```\\n/*\\nCurrently I am thinking to tackle this problem using topological sort\\n    construct a graph from given recipes and ingredients\\n    graph:\\n    node | the ingredients it needs\\n    \\n    yeast | bread\\n    flour | bread\\n    bread | burger, sandwich\\n    meat | burger, sandwich\\n    sandwich | burger\\n    burger | ()\\n    \\n    indegree map\\n    yeast | 0\\n    flour | 0\\n    bread | 2\\n    meat | 0\\n    sandwich | 2\\n    burger | 3\\n    \\n    enqueue all the nodes in graph with indegree of 0. That becomes our starting point\\n    and for every ingredient keep updating the indegress of it\\'s neighbors. if for any neighbor\\n    indegree reaches 0, that means, that node can also be prepared and hence add it to our recipe\\n    list. Continue this while there is no more ingredient to process in the list\\n*/\\n```\\n\\t\\nImplementation\\n```\\nclass Solution:\\n   \\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        graph = {node: set() for node in supplies}\\n        indegrees = {node: 0 for node in supplies}\\n        for recipe in recipes:\\n            graph[recipe] = set()\\n            indegrees[recipe] = 0\\n            \\n        for i, ing in enumerate(ingredients):\\n            for single_ing in ing:\\n                if single_ing in graph:\\n                    graph[single_ing].add(recipes[i])\\n                else:\\n                    graph[single_ing] = set({recipes[i]})\\n            indegrees[recipes[i]]+=len(ing)\\n            \\n        # print(graph)\\n        # print(indegrees)\\n        nodes_with_no_incoming_edges = [key for key, value in indegrees.items() if value == 0]\\n        topo = set()\\n        while len(nodes_with_no_incoming_edges):\\n            node = nodes_with_no_incoming_edges.pop()\\n            topo.add(node)\\n            for neighbor in graph[node]:\\n                indegrees[neighbor]-=1\\n                if indegrees[neighbor] == 0:\\n                    nodes_with_no_incoming_edges.append(neighbor)\\n                    \\n        return set(recipes).intersection(topo)\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\n/*\\nCurrently I am thinking to tackle this problem using topological sort\\n    construct a graph from given recipes and ingredients\\n    graph:\\n    node | the ingredients it needs\\n    \\n    yeast | bread\\n    flour | bread\\n    bread | burger, sandwich\\n    meat | burger, sandwich\\n    sandwich | burger\\n    burger | ()\\n    \\n    indegree map\\n    yeast | 0\\n    flour | 0\\n    bread | 2\\n    meat | 0\\n    sandwich | 2\\n    burger | 3\\n    \\n    enqueue all the nodes in graph with indegree of 0. That becomes our starting point\\n    and for every ingredient keep updating the indegress of it\\'s neighbors. if for any neighbor\\n    indegree reaches 0, that means, that node can also be prepared and hence add it to our recipe\\n    list. Continue this while there is no more ingredient to process in the list\\n*/\\n```\n```\\nclass Solution:\\n   \\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        graph = {node: set() for node in supplies}\\n        indegrees = {node: 0 for node in supplies}\\n        for recipe in recipes:\\n            graph[recipe] = set()\\n            indegrees[recipe] = 0\\n            \\n        for i, ing in enumerate(ingredients):\\n            for single_ing in ing:\\n                if single_ing in graph:\\n                    graph[single_ing].add(recipes[i])\\n                else:\\n                    graph[single_ing] = set({recipes[i]})\\n            indegrees[recipes[i]]+=len(ing)\\n            \\n        # print(graph)\\n        # print(indegrees)\\n        nodes_with_no_incoming_edges = [key for key, value in indegrees.items() if value == 0]\\n        topo = set()\\n        while len(nodes_with_no_incoming_edges):\\n            node = nodes_with_no_incoming_edges.pop()\\n            topo.add(node)\\n            for neighbor in graph[node]:\\n                indegrees[neighbor]-=1\\n                if indegrees[neighbor] == 0:\\n                    nodes_with_no_incoming_edges.append(neighbor)\\n                    \\n        return set(recipes).intersection(topo)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986809,
                "title": "c-bfs-dfs-two-solutions",
                "content": "**BFS Kahn\\'s Algorithm Solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        int n = recipes.size();\\n        \\n        unordered_set<string> suppliesSet(begin(supplies), end(supplies));\\n        suppliesSet.insert(begin(recipes), end(recipes));\\n        \\n        unordered_map<string, vector<string>> graph;\\n        unordered_map<string, int> indegrees;\\n        \\n        for (int i = 0; i < n; i++) {\\n            string recipe = recipes[i];\\n            indegrees[recipe];\\n            for (string &ingredient : ingredients[i]) {\\n                if (suppliesSet.find(ingredient) != suppliesSet.end()) {\\n                    graph[ingredient].push_back(recipe);                    \\n                }\\n                indegrees[recipe]++;\\n                indegrees[ingredient];\\n            }\\n        }\\n        \\n        queue<string> todo;\\n        for (auto &indegree : indegrees) {\\n            if (indegree.second == 0) {\\n                todo.push(indegree.first);\\n            }            \\n        }\\n        \\n        vector<string> result;\\n        while (!todo.empty()) {\\n            string cur = todo.front();\\n            todo.pop();\\n            for (string &neigh : graph[cur]) {\\n                indegrees[neigh]--;\\n                if (indegrees[neigh] == 0) {\\n                    todo.push(neigh);\\n                    result.push_back(neigh);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n**DFS Coloring Solution**\\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        unordered_map<string, vector<string>> graph;\\n        unordered_map<string, int> color;\\n        int n = recipes.size();\\n        for (int i = 0; i < n; i++) {\\n            string node = recipes[i];\\n            for (string &neighbor : ingredients[i]) {\\n                graph[node].push_back(neighbor);\\n                color[neighbor] = 0;\\n            }\\n            color[node] = 0;\\n        }\\n        \\n        unordered_set<string> suppliesSet(begin(supplies), end(supplies));\\n        vector<string> result;\\n        unordered_map<string, pair<bool, bool>> memo;\\n        for (int i = 0; i < n; i++) {\\n            string cur = recipes[i];\\n            auto[ cycleFound, canBeMade ] = dfs(cur, graph, color, suppliesSet, memo);\\n            if (cycleFound == false && canBeMade == true) {\\n                result.push_back(cur);\\n            }   \\n        }\\n        \\n        return result;\\n    }\\n    \\n    // COLORS => 0: white(unprocessed), 1: gray(unsafe), 2: black(safe)\\n    pair<bool, bool> dfs(string cur, unordered_map<string, vector<string>> &graph, unordered_map<string, int> &color, unordered_set<string> &suppliesSet, unordered_map<string, pair<bool, bool>> &memo) {\\n        \\n        if (memo.find(cur) != memo.end()) {\\n            return memo[cur];\\n        }\\n        \\n        bool isRecipe = graph.find(cur) != graph.end();\\n        bool hasIngredentFound = suppliesSet.find(cur) != suppliesSet.end();\\n        bool canBeMadeSoFar = (isRecipe == true) || (isRecipe == false && hasIngredentFound);\\n        \\n        if (color[cur] > 0) {\\n            return { color[cur] == 1, canBeMadeSoFar };\\n        }\\n        \\n        color[cur] = 1;\\n        \\n        for (string &neigh : graph[cur]) {\\n            auto[ cycleFound, canBeMade ] = dfs(neigh, graph, color, suppliesSet, memo);\\n            if (cycleFound || canBeMade == false) {\\n                return { true, false };\\n            }\\n        }\\n        \\n        color[cur] = 2;\\n        memo[cur] = { false, canBeMadeSoFar };\\n        return memo[cur];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        int n = recipes.size();\\n        \\n        unordered_set<string> suppliesSet(begin(supplies), end(supplies));\\n        suppliesSet.insert(begin(recipes), end(recipes));\\n        \\n        unordered_map<string, vector<string>> graph;\\n        unordered_map<string, int> indegrees;\\n        \\n        for (int i = 0; i < n; i++) {\\n            string recipe = recipes[i];\\n            indegrees[recipe];\\n            for (string &ingredient : ingredients[i]) {\\n                if (suppliesSet.find(ingredient) != suppliesSet.end()) {\\n                    graph[ingredient].push_back(recipe);                    \\n                }\\n                indegrees[recipe]++;\\n                indegrees[ingredient];\\n            }\\n        }\\n        \\n        queue<string> todo;\\n        for (auto &indegree : indegrees) {\\n            if (indegree.second == 0) {\\n                todo.push(indegree.first);\\n            }            \\n        }\\n        \\n        vector<string> result;\\n        while (!todo.empty()) {\\n            string cur = todo.front();\\n            todo.pop();\\n            for (string &neigh : graph[cur]) {\\n                indegrees[neigh]--;\\n                if (indegrees[neigh] == 0) {\\n                    todo.push(neigh);\\n                    result.push_back(neigh);\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        \\n        unordered_map<string, vector<string>> graph;\\n        unordered_map<string, int> color;\\n        int n = recipes.size();\\n        for (int i = 0; i < n; i++) {\\n            string node = recipes[i];\\n            for (string &neighbor : ingredients[i]) {\\n                graph[node].push_back(neighbor);\\n                color[neighbor] = 0;\\n            }\\n            color[node] = 0;\\n        }\\n        \\n        unordered_set<string> suppliesSet(begin(supplies), end(supplies));\\n        vector<string> result;\\n        unordered_map<string, pair<bool, bool>> memo;\\n        for (int i = 0; i < n; i++) {\\n            string cur = recipes[i];\\n            auto[ cycleFound, canBeMade ] = dfs(cur, graph, color, suppliesSet, memo);\\n            if (cycleFound == false && canBeMade == true) {\\n                result.push_back(cur);\\n            }   \\n        }\\n        \\n        return result;\\n    }\\n    \\n    // COLORS => 0: white(unprocessed), 1: gray(unsafe), 2: black(safe)\\n    pair<bool, bool> dfs(string cur, unordered_map<string, vector<string>> &graph, unordered_map<string, int> &color, unordered_set<string> &suppliesSet, unordered_map<string, pair<bool, bool>> &memo) {\\n        \\n        if (memo.find(cur) != memo.end()) {\\n            return memo[cur];\\n        }\\n        \\n        bool isRecipe = graph.find(cur) != graph.end();\\n        bool hasIngredentFound = suppliesSet.find(cur) != suppliesSet.end();\\n        bool canBeMadeSoFar = (isRecipe == true) || (isRecipe == false && hasIngredentFound);\\n        \\n        if (color[cur] > 0) {\\n            return { color[cur] == 1, canBeMadeSoFar };\\n        }\\n        \\n        color[cur] = 1;\\n        \\n        for (string &neigh : graph[cur]) {\\n            auto[ cycleFound, canBeMade ] = dfs(neigh, graph, color, suppliesSet, memo);\\n            if (cycleFound || canBeMade == false) {\\n                return { true, false };\\n            }\\n        }\\n        \\n        color[cur] = 2;\\n        memo[cur] = { false, canBeMadeSoFar };\\n        return memo[cur];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1967453,
                "title": "topological-sort-exactly-same-as-207-course-schedule-problem-just-a-small-variation",
                "content": "I suggest if you haven\\'t done https://leetcode.com/problems/course-schedule/. Do it first. The solution is exactly same as that. If u can understand that solution, this is cake walk.\\n\\n```\\nclass GraphNode():\\n    def __init__(self):\\n        self.inDegree = 0\\n        self.outNodes = []\\n        \\n    def __repr__(self):\\n        return f\"{self.inDegree}, {self.outNodes}\"\\n\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        # to access supplies in constant time\\n        # and also to add newly created recipes into supply again\\n        supplyset = set(supplies)\\n        \\n        graph = defaultdict(GraphNode)\\n        \\n        # used later as a break case\\n        totalDep = 0\\n\\n        for rcp, ing in zip(recipes, ingredients):\\n            for i in ing:\\n                graph[i].outNodes.append(rcp)\\n                graph[rcp].inDegree += 1\\n                totalDep += 1\\n        \\n        # add nodes with 0 dependencies first\\n        nodesWithNoDep = []\\n        for node in graph:\\n            if graph[node].inDegree == 0:\\n                nodesWithNoDep.append(node)\\n        \\n        solvedEdges = 0\\n        ans = []\\n        while nodesWithNoDep:\\n            node = nodesWithNoDep.pop()\\n            \\n            for outgoingNode in graph[node].outNodes:\\n                if node in supplyset:\\n                    graph[outgoingNode].inDegree -= 1\\n                    solvedEdges += 1\\n                \\n                if graph[outgoingNode].inDegree == 0:\\n                    ans.append(outgoingNode)\\n                    supplyset.add(outgoingNode)\\n                    nodesWithNoDep.append(outgoingNode)\\n        \\n            if solvedEdges == totalDep:\\n                break\\n                \\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass GraphNode():\\n    def __init__(self):\\n        self.inDegree = 0\\n        self.outNodes = []\\n        \\n    def __repr__(self):\\n        return f\"{self.inDegree}, {self.outNodes}\"\\n\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        # to access supplies in constant time\\n        # and also to add newly created recipes into supply again\\n        supplyset = set(supplies)\\n        \\n        graph = defaultdict(GraphNode)\\n        \\n        # used later as a break case\\n        totalDep = 0\\n\\n        for rcp, ing in zip(recipes, ingredients):\\n            for i in ing:\\n                graph[i].outNodes.append(rcp)\\n                graph[rcp].inDegree += 1\\n                totalDep += 1\\n        \\n        # add nodes with 0 dependencies first\\n        nodesWithNoDep = []\\n        for node in graph:\\n            if graph[node].inDegree == 0:\\n                nodesWithNoDep.append(node)\\n        \\n        solvedEdges = 0\\n        ans = []\\n        while nodesWithNoDep:\\n            node = nodesWithNoDep.pop()\\n            \\n            for outgoingNode in graph[node].outNodes:\\n                if node in supplyset:\\n                    graph[outgoingNode].inDegree -= 1\\n                    solvedEdges += 1\\n                \\n                if graph[outgoingNode].inDegree == 0:\\n                    ans.append(outgoingNode)\\n                    supplyset.add(outgoingNode)\\n                    nodesWithNoDep.append(outgoingNode)\\n        \\n            if solvedEdges == totalDep:\\n                break\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958382,
                "title": "java-solution-using-topological-sort",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, List<String>> map = new HashMap();\\n        for (int i=0; i<recipes.length; i++) {\\n            List<String> list = ingredients.get(i);\\n            for (String ingredient: list) {\\n                if (!map.containsKey(ingredient)) {\\n                    map.put(ingredient, new ArrayList());\\n                }\\n                map.get(ingredient).add(recipes[i]);\\n            }\\n        }\\n        \\n        List<String> result = new ArrayList();\\n        Map<String, Integer> indegree = new HashMap();\\n        for (int i=0; i<recipes.length; i++) {\\n            if (!indegree.containsKey(recipes[i])){\\n                indegree.put(recipes[i], 0);\\n            }\\n            indegree.put(recipes[i], ingredients.get(i).size());\\n            if (ingredients.get(i).size() == 0) {\\n                result.add(recipes[i]);\\n            }\\n        }\\n        \\n        \\n        Queue<String> queue = new LinkedList();\\n        for (String supply: supplies) {\\n            queue.add(supply);\\n        }\\n        \\n        while (queue.size() > 0) {\\n            String supply = queue.poll();\\n            if (map.containsKey(supply)) {\\n                for(String recipe: map.get(supply)) {\\n                    if (indegree.containsKey(recipe)) {\\n                        indegree.put(recipe, indegree.get(recipe)-1);\\n                        if (indegree.get(recipe) == 0) {\\n                            queue.add(recipe);\\n                            result.add(recipe);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, List<String>> map = new HashMap();\\n        for (int i=0; i<recipes.length; i++) {\\n            List<String> list = ingredients.get(i);\\n            for (String ingredient: list) {\\n                if (!map.containsKey(ingredient)) {\\n                    map.put(ingredient, new ArrayList());\\n                }\\n                map.get(ingredient).add(recipes[i]);\\n            }\\n        }\\n        \\n        List<String> result = new ArrayList();\\n        Map<String, Integer> indegree = new HashMap();\\n        for (int i=0; i<recipes.length; i++) {\\n            if (!indegree.containsKey(recipes[i])){\\n                indegree.put(recipes[i], 0);\\n            }\\n            indegree.put(recipes[i], ingredients.get(i).size());\\n            if (ingredients.get(i).size() == 0) {\\n                result.add(recipes[i]);\\n            }\\n        }\\n        \\n        \\n        Queue<String> queue = new LinkedList();\\n        for (String supply: supplies) {\\n            queue.add(supply);\\n        }\\n        \\n        while (queue.size() > 0) {\\n            String supply = queue.poll();\\n            if (map.containsKey(supply)) {\\n                for(String recipe: map.get(supply)) {\\n                    if (indegree.containsKey(recipe)) {\\n                        indegree.put(recipe, indegree.get(recipe)-1);\\n                        if (indegree.get(recipe) == 0) {\\n                            queue.add(recipe);\\n                            result.add(recipe);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1950474,
                "title": "python-soltuion",
                "content": "```\\n    from collections import deque, defaultdict\\n\\tdef findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        result = []\\n        graph = defaultdict(list)\\n        recipe_dict = defaultdict(int)\\n        recipe_set = set(recipes)\\n        for recipe, ingredient in zip(recipes, ingredients):\\n            for i in ingredient:\\n                graph[i].append(recipe)\\n                recipe_dict[recipe] += 1\\n\\n        q = deque(supplies)\\n       \\n        while q:\\n            node = q.popleft()\\n            if node in recipe_set:\\n                result.append(node)\\n            for i in graph[node]:\\n                recipe_dict[i] -= 1\\n                if recipe_dict[i] == 0:\\n                    q.append(i)\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\n    from collections import deque, defaultdict\\n\\tdef findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        result = []\\n        graph = defaultdict(list)\\n        recipe_dict = defaultdict(int)\\n        recipe_set = set(recipes)\\n        for recipe, ingredient in zip(recipes, ingredients):\\n            for i in ingredient:\\n                graph[i].append(recipe)\\n                recipe_dict[recipe] += 1\\n\\n        q = deque(supplies)\\n       \\n        while q:\\n            node = q.popleft()\\n            if node in recipe_set:\\n                result.append(node)\\n            for i in graph[node]:\\n                recipe_dict[i] -= 1\\n                if recipe_dict[i] == 0:\\n                    q.append(i)\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1946329,
                "title": "99-faster-75-less-memory-python-topological-sort-dfs-graphical-way",
                "content": "The first solution is not the fastest, but easy to understand (as it is in form of Graphs and nodes)\\nThe second solution is faster by  99% and uses less memory.\\n\\nBoth solutions are Code Using DFS +. Topological sorting.\\n\\n\\nFirst we create the graph. Then we apply topological sorting to solve the problem.\\n\\n```\\nclass Node:\\n    def __init__(self, val):\\n        self.inp = 0\\n        self.val = val\\n        self.next = set()\\n    \\n    def add_connection(self, nxt_node):\\n        nxt_node.inp += 1\\n        self.next.add(nxt_node)\\n    \\ndef build_graph(recipes_lst, ingredients_lst, supplies_lst):\\n    node_map = dict()\\n    entry_nodes = list()\\n    for supplie in supplies_lst:\\n        supplie_node = Node(supplie)\\n        node_map[supplie] = supplie_node\\n        \\n    for recipe, indg_lst in zip(recipes_lst, ingredients_lst):\\n        if recipe not in node_map:\\n            recipe_node = Node(recipe)\\n            node_map[recipe] = recipe_node\\n        else:\\n            recipe_node = node_map[recipe]\\n        for indg in indg_lst:\\n            indg_node = Node(indg) if indg not in node_map else node_map[indg]                \\n            indg_node.add_connection(recipe_node)\\n            node_map[indg] = indg_node\\n    return node_map\\n        \\ndef dfs(curr_node, recipes_set, output):\\n    if curr_node.inp == 0 and curr_node.val in recipes_set:\\n        output.append(curr_node.val)\\n    for nxt_node in curr_node.next:\\n        nxt_node.inp -= 1\\n        if nxt_node.inp == 0:\\n            dfs(nxt_node, recipes_set, output)\\n        \\n\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies_lst: List[str]) -> List[str]:\\n        output = list()\\n        node_map = build_graph(recipes, ingredients, supplies_lst)\\n        for supplies in supplies_lst:\\n            supplies_node = node_map[supplies]\\n            dfs(supplies_node, set(recipes), output)\\n        return output\\n```\\n\\nThe Second solution is 99% Faster and consummes 75% less memory:\\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        output = set()\\n        graph = dict()\\n        supplies_set = set(supplies)\\n        in_nodes = dict(default=0)\\n        for rec, indg_lst in zip(recipes, ingredients):\\n            dependency = 0\\n            for indg in indg_lst:\\n                if indg not in supplies_set and indg not in output:\\n                    dependency+=1\\n                    if indg not in graph:\\n                        graph[indg] = list()\\n                    graph[indg].append(rec)\\n                    in_nodes[rec] = (in_nodes[rec] + 1) if rec in in_nodes else 1\\n            if dependency == 0:\\n                output.add(rec)\\n                if rec in graph:\\n                    q = [rec]\\n                    while q:\\n                        indg = q.pop(0)\\n                        if indg in graph:\\n                            impacting_recipes_lst = graph[indg]\\n                            for impacting_recipe in impacting_recipes_lst:\\n                                in_nodes[impacting_recipe] -= 1\\n                                if in_nodes[impacting_recipe] == 0:\\n                                    output.add(impacting_recipe)\\n                                    q.append(impacting_recipe)\\n        \\n        return list(output)\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph",
                    "Topological Sort",
                    "Recursion"
                ],
                "code": "```\\nclass Node:\\n    def __init__(self, val):\\n        self.inp = 0\\n        self.val = val\\n        self.next = set()\\n    \\n    def add_connection(self, nxt_node):\\n        nxt_node.inp += 1\\n        self.next.add(nxt_node)\\n    \\ndef build_graph(recipes_lst, ingredients_lst, supplies_lst):\\n    node_map = dict()\\n    entry_nodes = list()\\n    for supplie in supplies_lst:\\n        supplie_node = Node(supplie)\\n        node_map[supplie] = supplie_node\\n        \\n    for recipe, indg_lst in zip(recipes_lst, ingredients_lst):\\n        if recipe not in node_map:\\n            recipe_node = Node(recipe)\\n            node_map[recipe] = recipe_node\\n        else:\\n            recipe_node = node_map[recipe]\\n        for indg in indg_lst:\\n            indg_node = Node(indg) if indg not in node_map else node_map[indg]                \\n            indg_node.add_connection(recipe_node)\\n            node_map[indg] = indg_node\\n    return node_map\\n        \\ndef dfs(curr_node, recipes_set, output):\\n    if curr_node.inp == 0 and curr_node.val in recipes_set:\\n        output.append(curr_node.val)\\n    for nxt_node in curr_node.next:\\n        nxt_node.inp -= 1\\n        if nxt_node.inp == 0:\\n            dfs(nxt_node, recipes_set, output)\\n        \\n\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies_lst: List[str]) -> List[str]:\\n        output = list()\\n        node_map = build_graph(recipes, ingredients, supplies_lst)\\n        for supplies in supplies_lst:\\n            supplies_node = node_map[supplies]\\n            dfs(supplies_node, set(recipes), output)\\n        return output\\n```\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        output = set()\\n        graph = dict()\\n        supplies_set = set(supplies)\\n        in_nodes = dict(default=0)\\n        for rec, indg_lst in zip(recipes, ingredients):\\n            dependency = 0\\n            for indg in indg_lst:\\n                if indg not in supplies_set and indg not in output:\\n                    dependency+=1\\n                    if indg not in graph:\\n                        graph[indg] = list()\\n                    graph[indg].append(rec)\\n                    in_nodes[rec] = (in_nodes[rec] + 1) if rec in in_nodes else 1\\n            if dependency == 0:\\n                output.add(rec)\\n                if rec in graph:\\n                    q = [rec]\\n                    while q:\\n                        indg = q.pop(0)\\n                        if indg in graph:\\n                            impacting_recipes_lst = graph[indg]\\n                            for impacting_recipe in impacting_recipes_lst:\\n                                in_nodes[impacting_recipe] -= 1\\n                                if in_nodes[impacting_recipe] == 0:\\n                                    output.add(impacting_recipe)\\n                                    q.append(impacting_recipe)\\n        \\n        return list(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936389,
                "title": "c-easy-to-understand-98-memory-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        unordered_set<string> avail(supplies.begin(),supplies.end());\\n        vector<string> ans;\\n        while(recipes.size()!=0)\\n        {\\n            int c=0;\\n            for(int i=0;i<recipes.size();i++)\\n            {\\n                bool ok=true;\\n                for(auto &s:ingredients[i])\\n                {\\n                    if(avail.find(s)==avail.end())\\n                    {\\n                        ok=false;\\n                        break;\\n                    }\\n                }\\n                if(ok)\\n                {\\n                    ans.push_back(recipes[i]);\\n                    avail.insert(recipes[i]);\\n                    recipes.erase(recipes.begin()+i);\\n                    ingredients.erase(ingredients.begin()+i);\\n                    c++;\\n                }\\n            }\\n            if(c==0)\\n            break;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        unordered_set<string> avail(supplies.begin(),supplies.end());\\n        vector<string> ans;\\n        while(recipes.size()!=0)\\n        {\\n            int c=0;\\n            for(int i=0;i<recipes.size();i++)\\n            {\\n                bool ok=true;\\n                for(auto &s:ingredients[i])\\n                {\\n                    if(avail.find(s)==avail.end())\\n                    {\\n                        ok=false;\\n                        break;\\n                    }\\n                }\\n                if(ok)\\n                {\\n                    ans.push_back(recipes[i]);\\n                    avail.insert(recipes[i]);\\n                    recipes.erase(recipes.begin()+i);\\n                    ingredients.erase(ingredients.begin()+i);\\n                    c++;\\n                }\\n            }\\n            if(c==0)\\n            break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1905549,
                "title": "topo-sort",
                "content": "Normal Topo sort  , catch is just follow ingredients to  recepies it will form a DAG  and rest will be handle by topo sort .\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        //for ans \\n        vector<string> v;\\n        \\n        //for storing graph\\n        map<string,vector<string>> adj;\\n        \\n        //for indegree\\n        map<string,int>  in;\\n        \\n      \\n        int n = recipes.size();\\n        \\n        //preparing  DAG  graph and calculating indegree\\n        for(int i=0;i<n;i++){\\n            for(auto child:ingredients[i]){\\n                adj[child].push_back(recipes[i]);\\n                in[recipes[i]]++;\\n            }\\n        }\\n        \\n        //Normal bfs \\n        queue<string> q;\\n        for(auto x:supplies){\\n            //As default value by map is 0 , thus explictly checking \\n            if(adj.find(x)!=adj.end()){\\n                if(in[x]==0){\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        \\n        \\n        while(!q.empty()){\\n            \\n           string node = q.front();\\n            q.pop();\\n            \\n            //we only want  recipe not ingredients\\n            if(find(recipes.begin(),recipes.end(),node)!=recipes.end())\\n                    v.push_back(node);\\n            \\n            \\n            for(auto child:adj[node]){\\n                in[child]--;\\n                if(in[child]==0)\\n                    q.push(child);\\n            }   \\n        }\\n        return v;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        //for ans \\n        vector<string> v;\\n        \\n        //for storing graph\\n        map<string,vector<string>> adj;\\n        \\n        //for indegree\\n        map<string,int>  in;\\n        \\n      \\n        int n = recipes.size();\\n        \\n        //preparing  DAG  graph and calculating indegree\\n        for(int i=0;i<n;i++){\\n            for(auto child:ingredients[i]){\\n                adj[child].push_back(recipes[i]);\\n                in[recipes[i]]++;\\n            }\\n        }\\n        \\n        //Normal bfs \\n        queue<string> q;\\n        for(auto x:supplies){\\n            //As default value by map is 0 , thus explictly checking \\n            if(adj.find(x)!=adj.end()){\\n                if(in[x]==0){\\n                    q.push(x);\\n                }\\n            }\\n        }\\n        \\n        \\n        while(!q.empty()){\\n            \\n           string node = q.front();\\n            q.pop();\\n            \\n            //we only want  recipe not ingredients\\n            if(find(recipes.begin(),recipes.end(),node)!=recipes.end())\\n                    v.push_back(node);\\n            \\n            \\n            for(auto child:adj[node]){\\n                in[child]--;\\n                if(in[child]==0)\\n                    q.push(child);\\n            }   \\n        }\\n        return v;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895202,
                "title": "easy-java-topological-sort",
                "content": "```\\nclass Solution {\\n    \\n    Set<String> supplySet;\\n    HashMap<String,Integer> indegree;\\n    Set<String> recipesSet;\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        \\n        supplySet = new HashSet<>();\\n        indegree = new HashMap<>();\\n        recipesSet = new HashSet<>();\\n        \\n        // for topological sort\\n        Queue<String> queue = new LinkedList<>();\\n        \\n        for(String s : supplies){\\n            supplySet.add(s);\\n            queue.add(s);\\n        }\\n        \\n        // Build Graph\\n        Map<String,List<String>> graph = new HashMap<>();\\n        \\n        for(int i=0;i<recipes.length;i++){\\n            \\n            String recipy = recipes[i];   \\n            recipesSet.add(recipy);\\n            indegree.put(recipy ,ingredients.get(i).size());\\n            \\n            for(String ingredient : ingredients.get(i)){\\n                graph.computeIfAbsent(ingredient, list -> new ArrayList<>()).add(recipy);\\n            }\\n        }\\n        \\n        \\n        // Topological sort\\n        // kahn\\'s algo\\n        List<String> ans = new ArrayList<>();\\n        \\n        while(!queue.isEmpty()){\\n            \\n            String top = queue.poll();\\n            \\n            if(recipesSet.contains(top) && supplySet.contains(top))\\n                ans.add(top);\\n            \\n            for(String v : graph.getOrDefault(top, new ArrayList<>())){\\n                \\n                indegree.put(v,indegree.get(v)-1);\\n                if(indegree.get(v)==0) {\\n                    queue.offer(v);\\n                    // item prepared, so add it to supplySet\\n                    supplySet.add(v); \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "class Solution {\\n    \\n    Set<String> supplySet;\\n    HashMap<String,Integer> indegree;\\n    Set<String> recipesSet;\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        \\n        supplySet = new HashSet<>();\\n        indegree = new HashMap<>();\\n        recipesSet = new HashSet<>();\\n        \\n        // for topological sort\\n        Queue<String> queue = new LinkedList<>();\\n        \\n        for(String s : supplies){\\n            supplySet.add(s);\\n            queue.add(s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1891782,
                "title": "python-recursive-dfs",
                "content": "\\tclass Solution:\\n\\t\\tdef findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n\\n\\n\\t\\t\\ts = {i for i in supplies}\\n\\n\\t\\t\\tg = {}\\n\\n\\t\\t\\tvisited = set()\\n\\n\\t\\t\\tfor i in range(len(recipes)):\\n\\t\\t\\t\\tg[recipes[i]] = ingredients[i]\\n\\n\\n\\t\\t\\tdef DFS(node):\\n\\n\\t\\t\\t\\tif node in visited:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tif node in s:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\tif node not in g:\\n\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tvisited.add(node)\\n\\n\\t\\t\\t\\tfor dest in g[node]:\\n\\t\\t\\t\\t\\tif DFS(dest):\\n\\t\\t\\t\\t\\t\\ts.add(dest)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\treturn True\\n\\n\\t\\t\\tret = []\\n\\t\\t\\tfor recipe in recipes:\\n\\t\\t\\t\\tvisited = set()\\n\\t\\t\\t\\tif DFS(recipe):\\n\\t\\t\\t\\t\\tret.append(recipe)\\n\\n\\t\\t\\treturn ret\\n",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n\\n\\n\\t\\t\\ts = {i for i in supplies}",
                "codeTag": "Java"
            },
            {
                "id": 1792558,
                "title": "python-topological-sort",
                "content": "Time complexity for topological sort in a DAG: O(|V|+|E|)\\n\\n```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        # topological sort\\n        graph={}\\n        indegree={}\\n        \\n        for i in range(len(ingredients)):\\n            for ing in ingredients[i]:\\n                graph[ing]=graph.get(ing,[])+[recipes[i]]\\n                indegree[recipes[i]]=indegree.get(recipes[i],0)+1\\n        \\n        stack=supplies\\n        output=[]\\n        recipes=set(recipes)\\n        \\n        while stack:\\n            ing=stack.pop()\\n            if ing in recipes:\\n                output.append(ing)\\n            \\n            for adj in graph.get(ing,[]):\\n                indegree[adj]-=1\\n                if indegree[adj]==0:\\n                    stack.append(adj)\\n                    del indegree[adj]\\n        \\n        return output",
                "solutionTags": [],
                "code": "class Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        # topological sort\\n        graph={}",
                "codeTag": "Java"
            },
            {
                "id": 1790768,
                "title": "topo-sort-100-faster-dfs",
                "content": "```\\nclass Solution {\\n    Map<String,Integer> nodes;\\n    Set<String> set;\\n    List<List<String>> adj;\\n    Stack<String> stack;\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients,String[] supplies) {\\n        int len = recipes.length;\\n        \\n        boolean visited[] = new boolean[len];\\n        boolean dfsVisited[] = new boolean[len];\\n        List<String> ans = new ArrayList<>();\\n        \\n        adj=ingredients;\\n        set = new HashSet<>();\\n        stack = new Stack<>();\\n        nodes = new HashMap<>();\\n        \\n        for(String supply : supplies){\\n            set.add(supply);\\n        }\\n        \\n        for(int i=0;i<len;i++){\\n            nodes.put(recipes[i],i);\\n        }\\n        \\n        for(int i=0;i<len;i++){\\n            if(!visited[i]){\\n                if(!dfs(i,recipes,visited,dfsVisited)){\\n                    continue;\\n                }\\n            }\\n        }\\n        \\n        while(!stack.isEmpty()){\\n            ans.add(stack.pop());\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean dfs(int recipie,String recipes[],boolean[] visited,boolean[] dfsVisited){\\n        if(dfsVisited[recipie]){\\n            return false;\\n        }\\n        \\n        if(visited[recipie]){\\n            return true;\\n        }\\n        \\n        visited[recipie]=true;\\n        dfsVisited[recipie]=true;\\n        \\n        for(String ingredient : adj.get(recipie)){\\n            if(set.contains(ingredient)){\\n                continue;\\n            }\\n            if(nodes.containsKey(ingredient)){\\n                int idx = nodes.get(ingredient);  \\n                if(!dfs(idx,recipes,visited,dfsVisited)){\\n                    return false;\\n                }\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        stack.push(recipes[recipie]);\\n        dfsVisited[recipie]=false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    Map<String,Integer> nodes;\\n    Set<String> set;\\n    List<List<String>> adj;\\n    Stack<String> stack;\\n    \\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients,String[] supplies) {\\n        int len = recipes.length;\\n        \\n        boolean visited[] = new boolean[len];\\n        boolean dfsVisited[] = new boolean[len];\\n        List<String> ans = new ArrayList<>();\\n        \\n        adj=ingredients;\\n        set = new HashSet<>();\\n        stack = new Stack<>();\\n        nodes = new HashMap<>();\\n        \\n        for(String supply : supplies){\\n            set.add(supply);\\n        }\\n        \\n        for(int i=0;i<len;i++){\\n            nodes.put(recipes[i],i);\\n        }\\n        \\n        for(int i=0;i<len;i++){\\n            if(!visited[i]){\\n                if(!dfs(i,recipes,visited,dfsVisited)){\\n                    continue;\\n                }\\n            }\\n        }\\n        \\n        while(!stack.isEmpty()){\\n            ans.add(stack.pop());\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private boolean dfs(int recipie,String recipes[],boolean[] visited,boolean[] dfsVisited){\\n        if(dfsVisited[recipie]){\\n            return false;\\n        }\\n        \\n        if(visited[recipie]){\\n            return true;\\n        }\\n        \\n        visited[recipie]=true;\\n        dfsVisited[recipie]=true;\\n        \\n        for(String ingredient : adj.get(recipie)){\\n            if(set.contains(ingredient)){\\n                continue;\\n            }\\n            if(nodes.containsKey(ingredient)){\\n                int idx = nodes.get(ingredient);  \\n                if(!dfs(idx,recipes,visited,dfsVisited)){\\n                    return false;\\n                }\\n            }else{\\n                return false;\\n            }\\n        }\\n        \\n        stack.push(recipes[recipie]);\\n        dfsVisited[recipie]=false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787604,
                "title": "clean-python-solution-self-explained-easy-to-understand",
                "content": "```python\\n\"\"\"\\nUse Topological Sort\\n1. Build an adj list and inbound.\\n2. Starts from supplies topologically traverse the map.\\n3. For each node popping up, if it is in recipes, add it to ans.\\n\\nTime: O(N), N is the number of \"nodes\" (ingredients+recipes)\\nSpace: O(N).\\n\"\"\"\\nclass Solution(object):\\n    def findAllRecipes(self, recipes, ingredients, supplies):\\n        N = len(recipes)\\n        adj = collections.defaultdict(list)\\n        inbounds = collections.Counter()\\n        q = collections.deque(supplies)\\n        recipeSet = set(recipes)\\n        ans = []\\n        \\n        for i, recipe in enumerate(recipes):\\n            for ingredient in ingredients[i]:\\n                adj[ingredient].append(recipe)\\n                inbounds[recipe] += 1\\n        \\n        while q:\\n            node = q.popleft()\\n            \\n            if node in recipeSet: ans.append(node)\\n            \\n            for nei in adj[node]:\\n                inbounds[nei] -= 1\\n                if inbounds[nei]==0: q.append(nei)\\n        \\n        return ans\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nUse Topological Sort\\n1. Build an adj list and inbound.\\n2. Starts from supplies topologically traverse the map.\\n3. For each node popping up, if it is in recipes, add it to ans.\\n\\nTime: O(N), N is the number of \"nodes\" (ingredients+recipes)\\nSpace: O(N).\\n\"\"\"\\nclass Solution(object):\\n    def findAllRecipes(self, recipes, ingredients, supplies):\\n        N = len(recipes)\\n        adj = collections.defaultdict(list)\\n        inbounds = collections.Counter()\\n        q = collections.deque(supplies)\\n        recipeSet = set(recipes)\\n        ans = []\\n        \\n        for i, recipe in enumerate(recipes):\\n            for ingredient in ingredients[i]:\\n                adj[ingredient].append(recipe)\\n                inbounds[recipe] += 1\\n        \\n        while q:\\n            node = q.popleft()\\n            \\n            if node in recipeSet: ans.append(node)\\n            \\n            for nei in adj[node]:\\n                inbounds[nei] -= 1\\n                if inbounds[nei]==0: q.append(nei)\\n        \\n        return ans\\n\\t\\t\\n\"\"\"\\nFor interview preparation, similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764897,
                "title": "javascript",
                "content": "```\\nconst findAllRecipes = (recipes, ingredients, supplies) => {\\n  let output = new Set();\\n  // create a set of the supplies\\n  let suppliesSet = new Set(supplies);\\n\\n  // create an adjacency list of the recipes along with the ingredients\\n  let adjacencyList = new Map();\\n  recipes.forEach((recipe, index) => adjacencyList.set(recipe, ingredients[index]));\\n\\n  // helper function canMakeWith\\n  const canMakeWith = (items) => {\\n    for (let item of items) {\\n      if (!suppliesSet.has(item)) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  // helper function updateSuppliesSet\\n  const updateSuppliesSet = () => {\\n    for (let [key, values] of adjacencyList) {\\n      if (canMakeWith(values)) {\\n        suppliesSet.add(key);\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < recipes.length; i++) {\\n    updateSuppliesSet()\\n  };\\n\\n  for (let element of suppliesSet) {\\n    if (adjacencyList.has(element)) {\\n      output.add(element)\\n    }\\n  }\\n  return [...output];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nconst findAllRecipes = (recipes, ingredients, supplies) => {\\n  let output = new Set();\\n  // create a set of the supplies\\n  let suppliesSet = new Set(supplies);\\n\\n  // create an adjacency list of the recipes along with the ingredients\\n  let adjacencyList = new Map();\\n  recipes.forEach((recipe, index) => adjacencyList.set(recipe, ingredients[index]));\\n\\n  // helper function canMakeWith\\n  const canMakeWith = (items) => {\\n    for (let item of items) {\\n      if (!suppliesSet.has(item)) {\\n        return false;\\n      }\\n    }\\n    return true;\\n  }\\n\\n  // helper function updateSuppliesSet\\n  const updateSuppliesSet = () => {\\n    for (let [key, values] of adjacencyList) {\\n      if (canMakeWith(values)) {\\n        suppliesSet.add(key);\\n      }\\n    }\\n  }\\n\\n  for (let i = 0; i < recipes.length; i++) {\\n    updateSuppliesSet()\\n  };\\n\\n  for (let element of suppliesSet) {\\n    if (adjacencyList.has(element)) {\\n      output.add(element)\\n    }\\n  }\\n  return [...output];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1754156,
                "title": "c-2-methods-1-kahn-s-algorithm-2-dfs-with-memoization",
                "content": "Method 1 - Kahn\\'s Algorithm\\n```\\nclass Solution\\n{\\n    public:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies)\\n    {\\n        unordered_map<string,vector<string>>graph;\\n        unordered_map<string,int>indegree;\\n        \\n        for(int i=0;i<recipes.size();i++)\\n        {\\n            for(auto ing:ingredients[i])\\n            {\\n                graph[ing].push_back(recipes[i]);\\n                indegree[recipes[i]]++;\\n            }\\n        }\\n        \\n        queue<string>Q;\\n        for(auto supply:supplies)\\n        {\\n            if(indegree[supply]==0)\\n                Q.push(supply);\\n        }\\n        \\n        vector<string>ans;\\n        while(!Q.empty())\\n        {\\n            int size=Q.size();\\n            while(size--)\\n            {\\n                string ing=Q.front();\\n                Q.pop();\\n                for(auto item:graph[ing])\\n                {\\n                    indegree[item]--;\\n                    if(indegree[item]==0)\\n                    {\\n                        Q.push(item);\\n                        ans.push_back(item);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nMethod 2 - DFS with Memoization\\n```\\nclass Solution\\n{\\n    public:\\n    bool dfs(unordered_map<string,vector<string>>& graph, string item, unordered_map<string,int>& visited, unordered_map<string,int>& available)\\n    {\\n        if(visited[item]==0)\\n        {\\n            visited[item]=1;\\n            if(!graph[item].empty())\\n            {\\n                bool possible=true;\\n                for(auto ing:graph[item])\\n                {\\n                    if(!dfs(graph,ing,visited,available))\\n                    {\\n                        possible=false;\\n                        break;\\n                    }\\n                }\\n                if(possible)\\n                    available[item]=1;\\n            }\\n        }\\n        return available[item];\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies)\\n    {\\n        unordered_map<string,int>available;\\n        unordered_map<string,int>visited;\\n        unordered_map<string,vector<string>>graph;\\n        \\n        for(int i=0;i<recipes.size();i++)\\n        {\\n            available[recipes[i]]=0;\\n            visited[recipes[i]]=0;\\n            graph[recipes[i]]=ingredients[i];\\n        }\\n        for(auto vec:ingredients)\\n        {\\n            for(auto val:vec)\\n            {\\n                available[val]=0;\\n                visited[val]=0;\\n            }\\n        }\\n        for(auto val:supplies)\\n        {\\n            available[val]=1;\\n            visited[val]=0;\\n        }\\n        \\n        for(auto recipe:recipes)\\n        {\\n            if(visited[recipe]==0)\\n                dfs(graph,recipe,visited,available);\\n        }\\n        \\n        vector<string>ans;\\n        for(auto recipe:recipes)\\n        {\\n            if(available[recipe])\\n                ans.push_back(recipe);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies)\\n    {\\n        unordered_map<string,vector<string>>graph;\\n        unordered_map<string,int>indegree;\\n        \\n        for(int i=0;i<recipes.size();i++)\\n        {\\n            for(auto ing:ingredients[i])\\n            {\\n                graph[ing].push_back(recipes[i]);\\n                indegree[recipes[i]]++;\\n            }\\n        }\\n        \\n        queue<string>Q;\\n        for(auto supply:supplies)\\n        {\\n            if(indegree[supply]==0)\\n                Q.push(supply);\\n        }\\n        \\n        vector<string>ans;\\n        while(!Q.empty())\\n        {\\n            int size=Q.size();\\n            while(size--)\\n            {\\n                string ing=Q.front();\\n                Q.pop();\\n                for(auto item:graph[ing])\\n                {\\n                    indegree[item]--;\\n                    if(indegree[item]==0)\\n                    {\\n                        Q.push(item);\\n                        ans.push_back(item);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\n    public:\\n    bool dfs(unordered_map<string,vector<string>>& graph, string item, unordered_map<string,int>& visited, unordered_map<string,int>& available)\\n    {\\n        if(visited[item]==0)\\n        {\\n            visited[item]=1;\\n            if(!graph[item].empty())\\n            {\\n                bool possible=true;\\n                for(auto ing:graph[item])\\n                {\\n                    if(!dfs(graph,ing,visited,available))\\n                    {\\n                        possible=false;\\n                        break;\\n                    }\\n                }\\n                if(possible)\\n                    available[item]=1;\\n            }\\n        }\\n        return available[item];\\n    }\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies)\\n    {\\n        unordered_map<string,int>available;\\n        unordered_map<string,int>visited;\\n        unordered_map<string,vector<string>>graph;\\n        \\n        for(int i=0;i<recipes.size();i++)\\n        {\\n            available[recipes[i]]=0;\\n            visited[recipes[i]]=0;\\n            graph[recipes[i]]=ingredients[i];\\n        }\\n        for(auto vec:ingredients)\\n        {\\n            for(auto val:vec)\\n            {\\n                available[val]=0;\\n                visited[val]=0;\\n            }\\n        }\\n        for(auto val:supplies)\\n        {\\n            available[val]=1;\\n            visited[val]=0;\\n        }\\n        \\n        for(auto recipe:recipes)\\n        {\\n            if(visited[recipe]==0)\\n                dfs(graph,recipe,visited,available);\\n        }\\n        \\n        vector<string>ans;\\n        for(auto recipe:recipes)\\n        {\\n            if(available[recipe])\\n                ans.push_back(recipe);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751059,
                "title": "java-dfs-o-v-e",
                "content": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, Set<String>> recipeDependencies = new HashMap<>();\\n        for (int i = 0; i < recipes.length; i++) {\\n            recipeDependencies.put(recipes[i], new HashSet<>(ingredients.get(i)));\\n        }\\n        Map<String, Boolean> canMake = new HashMap<>();\\n        for (String supply : supplies) {\\n            canMake.put(supply, true);\\n        }\\n        List<String> canCreate = new ArrayList<>();\\n        for (String recipe : recipeDependencies.keySet()) {\\n            if (canMake(recipeDependencies, recipe, canMake)) {\\n                canCreate.add(recipe);\\n            }\\n        }\\n        return canCreate;\\n    }\\n    \\n    public boolean canMake(Map<String, Set<String>> recipeDependencies, String recipe, Map<String, Boolean> canMake) {\\n        if (!canMake.containsKey(recipe)) {\\n            // next line handles cycles as well as \\n            // base ingredients that are not in recipeDependencies\\n            // and were not given as supplies\\n            canMake.put(recipe, false); \\n            if (recipeDependencies.containsKey(recipe)) {\\n                for (String dependency : recipeDependencies.get(recipe)) {\\n                    if (!canMake(recipeDependencies, dependency, canMake)) {\\n                        return false;\\n                    }\\n                }\\n                canMake.put(recipe, true);\\n            }\\n        }\\n        return canMake.get(recipe);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> findAllRecipes(String[] recipes, List<List<String>> ingredients, String[] supplies) {\\n        Map<String, Set<String>> recipeDependencies = new HashMap<>();\\n        for (int i = 0; i < recipes.length; i++) {\\n            recipeDependencies.put(recipes[i], new HashSet<>(ingredients.get(i)));\\n        }\\n        Map<String, Boolean> canMake = new HashMap<>();\\n        for (String supply : supplies) {\\n            canMake.put(supply, true);\\n        }\\n        List<String> canCreate = new ArrayList<>();\\n        for (String recipe : recipeDependencies.keySet()) {\\n            if (canMake(recipeDependencies, recipe, canMake)) {\\n                canCreate.add(recipe);\\n            }\\n        }\\n        return canCreate;\\n    }\\n    \\n    public boolean canMake(Map<String, Set<String>> recipeDependencies, String recipe, Map<String, Boolean> canMake) {\\n        if (!canMake.containsKey(recipe)) {\\n            // next line handles cycles as well as \\n            // base ingredients that are not in recipeDependencies\\n            // and were not given as supplies\\n            canMake.put(recipe, false); \\n            if (recipeDependencies.containsKey(recipe)) {\\n                for (String dependency : recipeDependencies.get(recipe)) {\\n                    if (!canMake(recipeDependencies, dependency, canMake)) {\\n                        return false;\\n                    }\\n                }\\n                canMake.put(recipe, true);\\n            }\\n        }\\n        return canMake.get(recipe);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1734855,
                "title": "short-python3-brute-force-solution",
                "content": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        res=set()\\n        s=set(supplies)\\n        mydict={}\\n        \\n        for j in range(len(recipes)):\\n            for i in range(len(recipes)):\\n                recipe=recipes[i]\\n                req=ingredients[i]\\n\\t\\t\\t\\tif recipe not in s:\\n\\t\\t\\t\\t\\tif all(val in s for val in req):\\n\\t\\t\\t\\t\\t\\tres.add(recipe)\\n\\t\\t\\t\\t\\t\\tif len(res)==len(recipes):\\n\\t\\t\\t\\t\\t\\t\\treturn list(res)\\n\\t\\t\\t\\t\\t\\ts.add(recipe)\\n        \\n        return list(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findAllRecipes(self, recipes: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\\n        \\n        res=set()\\n        s=set(supplies)\\n        mydict={}\\n        \\n        for j in range(len(recipes)):\\n            for i in range(len(recipes)):\\n                recipe=recipes[i]\\n                req=ingredients[i]\\n\\t\\t\\t\\tif recipe not in s:\\n\\t\\t\\t\\t\\tif all(val in s for val in req):\\n\\t\\t\\t\\t\\t\\tres.add(recipe)\\n\\t\\t\\t\\t\\t\\tif len(res)==len(recipes):\\n\\t\\t\\t\\t\\t\\t\\treturn list(res)\\n\\t\\t\\t\\t\\t\\ts.add(recipe)\\n        \\n        return list(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731130,
                "title": "c-toposort",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n= recipes.size();\\n        unordered_map<string,vector<string>> graph;\\n        unordered_map<string,int> indegree;\\n       \\n        for(int i=0;i<n;i++){\\n            for(auto &it: ingredients[i]){\\n                graph[it].push_back(recipes[i]);\\n                indegree[recipes[i]]++;\\n            }\\n        }\\n    \\n    queue<string> Q;vector<string> ans;\\n        for(auto &it: supplies)\\n            Q.push(it);\\n        \\n        while(!Q.empty()){\\n            int size = Q.size();\\n            while(size--){\\n                string current = Q.front();\\n                    Q.pop();\\n                for(auto &it: graph[current]){\\n                    if(--indegree[it]==0)\\n                    Q.push(it),ans.push_back(it);    \\n                }\\n                  \\n            }\\n                 \\n        }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> findAllRecipes(vector<string>& recipes, vector<vector<string>>& ingredients, vector<string>& supplies) {\\n        int n= recipes.size();\\n        unordered_map<string,vector<string>> graph;\\n        unordered_map<string,int> indegree;\\n       \\n        for(int i=0;i<n;i++){\\n            for(auto &it: ingredients[i]){\\n                graph[it].push_back(recipes[i]);\\n                indegree[recipes[i]]++;\\n            }\\n        }\\n    \\n    queue<string> Q;vector<string> ans;\\n        for(auto &it: supplies)\\n            Q.push(it);\\n        \\n        while(!Q.empty()){\\n            int size = Q.size();\\n            while(size--){\\n                string current = Q.front();\\n                    Q.pop();\\n                for(auto &it: graph[current]){\\n                    if(--indegree[it]==0)\\n                    Q.push(it),ans.push_back(it);    \\n                }\\n                  \\n            }\\n                 \\n        }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724675,
                "title": "topological-sort-hash-easy-to-understand-clean-code-c",
                "content": "```\\nvector<string> findAllRecipes(vector<string>& R, vector<vector<string>>& I, vector<string>& S) {\\n        int N = R.size();\\n        vector<string> Ans;\\n        unordered_set<string> sup(S.begin(),S.end()),item;\\n        unordered_map<string,vector<string>> gr;\\n        unordered_map<string,int> In;\\n        queue<string> Q;\\n        \\n        \\n        // making the adjacency list\\n        for(int i = 0;i < N; i++){\\n            bool ok = 1;\\n            for(auto k : I[i]){\\n                // storing each unique item\\n                item.insert(k);\\n                gr[k].push_back(R[i]);\\n            }\\n        }\\n        \\n        // making dependency/In count array\\n        for(auto i : item){\\n            for(auto k : gr[i]){\\n                if(sup.find(i) == sup.end()) In[k]++;\\n                else In[k];\\n            }\\n        }\\n        \\n        // pushing all the recipe with zero dependancy in bfs queue\\n        for(auto i : In){\\n            if(i.second == 0) Q.push(i.first);\\n        }\\n        \\n        // topological sort\\n        while(!Q.empty()){\\n            string curr = Q.front(); Q.pop();\\n            Ans.push_back(curr);\\n            for(auto k : gr[curr]){\\n                In[k]--;\\n                if(In[k] == 0) Q.push(k);\\n            }\\n        }\\n        return Ans;\\n    }\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nvector<string> findAllRecipes(vector<string>& R, vector<vector<string>>& I, vector<string>& S) {\\n        int N = R.size();\\n        vector<string> Ans;\\n        unordered_set<string> sup(S.begin(),S.end()),item;\\n        unordered_map<string,vector<string>> gr;\\n        unordered_map<string,int> In;\\n        queue<string> Q;\\n        \\n        \\n        // making the adjacency list\\n        for(int i = 0;i < N; i++){\\n            bool ok = 1;\\n            for(auto k : I[i]){\\n                // storing each unique item\\n                item.insert(k);\\n                gr[k].push_back(R[i]);\\n            }\\n        }\\n        \\n        // making dependency/In count array\\n        for(auto i : item){\\n            for(auto k : gr[i]){\\n                if(sup.find(i) == sup.end()) In[k]++;\\n                else In[k];\\n            }\\n        }\\n        \\n        // pushing all the recipe with zero dependancy in bfs queue\\n        for(auto i : In){\\n            if(i.second == 0) Q.push(i.first);\\n        }\\n        \\n        // topological sort\\n        while(!Q.empty()){\\n            string curr = Q.front(); Q.pop();\\n            Ans.push_back(curr);\\n            for(auto k : gr[curr]){\\n                In[k]--;\\n                if(In[k] == 0) Q.push(k);\\n            }\\n        }\\n        return Ans;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1951467,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I'm not sure if a woman joke will be acceptable here. "
                    },
                    {
                        "username": "svikramsingh287",
                        "content": "may be i can solve if someone give my blowjob during coding\\n"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/1638eb86-64de-445c-8a08-31ee445f0c9a_1640453734.8884196.png)\\nAny  corrections, suggestions or optimizations are welcomed :)\\nIf you found this post helpful then please like and comment to increase it\\'s reach. :)"
                    },
                    {
                        "username": "dhruv-chaudhary",
                        "content": "I am getting stackoverflow exception in this test case\\n\\n`recipes =\\n[\"ju\",\"fzjnm\",\"x\",\"e\",\"zpmcz\",\"h\",\"q\"]`\\n\\n`ingredients =\\n[[\"d\"],[\"hveml\",\"f\",\"cpivl\"],[\"cpivl\",\"zpmcz\",\"h\",\"e\",\"fzjnm\",\"ju\"],[\"cpivl\",\"hveml\",\"zpmcz\",\"ju\",\"h\"],[\"h\",\"fzjnm\",\"e\",\"q\",\"x\"],[\"d\",\"hveml\",\"cpivl\",\"q\",\"zpmcz\",\"ju\",\"e\",\"x\"],[\"f\",\"hveml\",\"cpivl\"]]`\\n\\n`supplies =\\n[\"f\",\"hveml\",\"cpivl\",\"d\"]`\\n\\nIf you see, in the above test case, the recipe \"zpmcz\" depends on the recipe \"h\", while the recipe \"h\" again depends upon \"zpmcz\". Clearly this is a cyclic dependency which is causing the stack overflow. I want to understand if this test case is wrong or my understanding of the problem (that there would be no cycles) is wrong. And if the test case is wrong, how come other solutions have been accepted?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "i also thought same , got wrong ans after 56th test case , test case can be cyclic dependent "
                    },
                    {
                        "username": "kos2kos",
                        "content": "Probably need to add a visited HashSet to avoid cycles"
                    },
                    {
                        "username": "zrzzgy",
                        "content": "The question stated that 2 recipes may have each other as ingredients. That\\'s a known situation."
                    },
                    {
                        "username": "rewill11",
                        "content": "a same question like this was asked in a div3 round of codeforces"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Yeah.. Round 888 Problem E"
                    },
                    {
                        "username": "Limon020",
                        "content": "Good question, topological sort and caching is fun"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "All 3 of the test cases are working with me and I am returning List<String> In Java the framework is throwing error \"output [] Expected \"bread\"\""
                    }
                ]
            },
            {
                "id": 1842409,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I'm not sure if a woman joke will be acceptable here. "
                    },
                    {
                        "username": "svikramsingh287",
                        "content": "may be i can solve if someone give my blowjob during coding\\n"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/1638eb86-64de-445c-8a08-31ee445f0c9a_1640453734.8884196.png)\\nAny  corrections, suggestions or optimizations are welcomed :)\\nIf you found this post helpful then please like and comment to increase it\\'s reach. :)"
                    },
                    {
                        "username": "dhruv-chaudhary",
                        "content": "I am getting stackoverflow exception in this test case\\n\\n`recipes =\\n[\"ju\",\"fzjnm\",\"x\",\"e\",\"zpmcz\",\"h\",\"q\"]`\\n\\n`ingredients =\\n[[\"d\"],[\"hveml\",\"f\",\"cpivl\"],[\"cpivl\",\"zpmcz\",\"h\",\"e\",\"fzjnm\",\"ju\"],[\"cpivl\",\"hveml\",\"zpmcz\",\"ju\",\"h\"],[\"h\",\"fzjnm\",\"e\",\"q\",\"x\"],[\"d\",\"hveml\",\"cpivl\",\"q\",\"zpmcz\",\"ju\",\"e\",\"x\"],[\"f\",\"hveml\",\"cpivl\"]]`\\n\\n`supplies =\\n[\"f\",\"hveml\",\"cpivl\",\"d\"]`\\n\\nIf you see, in the above test case, the recipe \"zpmcz\" depends on the recipe \"h\", while the recipe \"h\" again depends upon \"zpmcz\". Clearly this is a cyclic dependency which is causing the stack overflow. I want to understand if this test case is wrong or my understanding of the problem (that there would be no cycles) is wrong. And if the test case is wrong, how come other solutions have been accepted?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "i also thought same , got wrong ans after 56th test case , test case can be cyclic dependent "
                    },
                    {
                        "username": "kos2kos",
                        "content": "Probably need to add a visited HashSet to avoid cycles"
                    },
                    {
                        "username": "zrzzgy",
                        "content": "The question stated that 2 recipes may have each other as ingredients. That\\'s a known situation."
                    },
                    {
                        "username": "rewill11",
                        "content": "a same question like this was asked in a div3 round of codeforces"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Yeah.. Round 888 Problem E"
                    },
                    {
                        "username": "Limon020",
                        "content": "Good question, topological sort and caching is fun"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "All 3 of the test cases are working with me and I am returning List<String> In Java the framework is throwing error \"output [] Expected \"bread\"\""
                    }
                ]
            },
            {
                "id": 1568694,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I'm not sure if a woman joke will be acceptable here. "
                    },
                    {
                        "username": "svikramsingh287",
                        "content": "may be i can solve if someone give my blowjob during coding\\n"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/1638eb86-64de-445c-8a08-31ee445f0c9a_1640453734.8884196.png)\\nAny  corrections, suggestions or optimizations are welcomed :)\\nIf you found this post helpful then please like and comment to increase it\\'s reach. :)"
                    },
                    {
                        "username": "dhruv-chaudhary",
                        "content": "I am getting stackoverflow exception in this test case\\n\\n`recipes =\\n[\"ju\",\"fzjnm\",\"x\",\"e\",\"zpmcz\",\"h\",\"q\"]`\\n\\n`ingredients =\\n[[\"d\"],[\"hveml\",\"f\",\"cpivl\"],[\"cpivl\",\"zpmcz\",\"h\",\"e\",\"fzjnm\",\"ju\"],[\"cpivl\",\"hveml\",\"zpmcz\",\"ju\",\"h\"],[\"h\",\"fzjnm\",\"e\",\"q\",\"x\"],[\"d\",\"hveml\",\"cpivl\",\"q\",\"zpmcz\",\"ju\",\"e\",\"x\"],[\"f\",\"hveml\",\"cpivl\"]]`\\n\\n`supplies =\\n[\"f\",\"hveml\",\"cpivl\",\"d\"]`\\n\\nIf you see, in the above test case, the recipe \"zpmcz\" depends on the recipe \"h\", while the recipe \"h\" again depends upon \"zpmcz\". Clearly this is a cyclic dependency which is causing the stack overflow. I want to understand if this test case is wrong or my understanding of the problem (that there would be no cycles) is wrong. And if the test case is wrong, how come other solutions have been accepted?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "i also thought same , got wrong ans after 56th test case , test case can be cyclic dependent "
                    },
                    {
                        "username": "kos2kos",
                        "content": "Probably need to add a visited HashSet to avoid cycles"
                    },
                    {
                        "username": "zrzzgy",
                        "content": "The question stated that 2 recipes may have each other as ingredients. That\\'s a known situation."
                    },
                    {
                        "username": "rewill11",
                        "content": "a same question like this was asked in a div3 round of codeforces"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Yeah.. Round 888 Problem E"
                    },
                    {
                        "username": "Limon020",
                        "content": "Good question, topological sort and caching is fun"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "All 3 of the test cases are working with me and I am returning List<String> In Java the framework is throwing error \"output [] Expected \"bread\"\""
                    }
                ]
            },
            {
                "id": 1759117,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I'm not sure if a woman joke will be acceptable here. "
                    },
                    {
                        "username": "svikramsingh287",
                        "content": "may be i can solve if someone give my blowjob during coding\\n"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/1638eb86-64de-445c-8a08-31ee445f0c9a_1640453734.8884196.png)\\nAny  corrections, suggestions or optimizations are welcomed :)\\nIf you found this post helpful then please like and comment to increase it\\'s reach. :)"
                    },
                    {
                        "username": "dhruv-chaudhary",
                        "content": "I am getting stackoverflow exception in this test case\\n\\n`recipes =\\n[\"ju\",\"fzjnm\",\"x\",\"e\",\"zpmcz\",\"h\",\"q\"]`\\n\\n`ingredients =\\n[[\"d\"],[\"hveml\",\"f\",\"cpivl\"],[\"cpivl\",\"zpmcz\",\"h\",\"e\",\"fzjnm\",\"ju\"],[\"cpivl\",\"hveml\",\"zpmcz\",\"ju\",\"h\"],[\"h\",\"fzjnm\",\"e\",\"q\",\"x\"],[\"d\",\"hveml\",\"cpivl\",\"q\",\"zpmcz\",\"ju\",\"e\",\"x\"],[\"f\",\"hveml\",\"cpivl\"]]`\\n\\n`supplies =\\n[\"f\",\"hveml\",\"cpivl\",\"d\"]`\\n\\nIf you see, in the above test case, the recipe \"zpmcz\" depends on the recipe \"h\", while the recipe \"h\" again depends upon \"zpmcz\". Clearly this is a cyclic dependency which is causing the stack overflow. I want to understand if this test case is wrong or my understanding of the problem (that there would be no cycles) is wrong. And if the test case is wrong, how come other solutions have been accepted?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "i also thought same , got wrong ans after 56th test case , test case can be cyclic dependent "
                    },
                    {
                        "username": "kos2kos",
                        "content": "Probably need to add a visited HashSet to avoid cycles"
                    },
                    {
                        "username": "zrzzgy",
                        "content": "The question stated that 2 recipes may have each other as ingredients. That\\'s a known situation."
                    },
                    {
                        "username": "rewill11",
                        "content": "a same question like this was asked in a div3 round of codeforces"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Yeah.. Round 888 Problem E"
                    },
                    {
                        "username": "Limon020",
                        "content": "Good question, topological sort and caching is fun"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "All 3 of the test cases are working with me and I am returning List<String> In Java the framework is throwing error \"output [] Expected \"bread\"\""
                    }
                ]
            },
            {
                "id": 2053388,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I'm not sure if a woman joke will be acceptable here. "
                    },
                    {
                        "username": "svikramsingh287",
                        "content": "may be i can solve if someone give my blowjob during coding\\n"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/1638eb86-64de-445c-8a08-31ee445f0c9a_1640453734.8884196.png)\\nAny  corrections, suggestions or optimizations are welcomed :)\\nIf you found this post helpful then please like and comment to increase it\\'s reach. :)"
                    },
                    {
                        "username": "dhruv-chaudhary",
                        "content": "I am getting stackoverflow exception in this test case\\n\\n`recipes =\\n[\"ju\",\"fzjnm\",\"x\",\"e\",\"zpmcz\",\"h\",\"q\"]`\\n\\n`ingredients =\\n[[\"d\"],[\"hveml\",\"f\",\"cpivl\"],[\"cpivl\",\"zpmcz\",\"h\",\"e\",\"fzjnm\",\"ju\"],[\"cpivl\",\"hveml\",\"zpmcz\",\"ju\",\"h\"],[\"h\",\"fzjnm\",\"e\",\"q\",\"x\"],[\"d\",\"hveml\",\"cpivl\",\"q\",\"zpmcz\",\"ju\",\"e\",\"x\"],[\"f\",\"hveml\",\"cpivl\"]]`\\n\\n`supplies =\\n[\"f\",\"hveml\",\"cpivl\",\"d\"]`\\n\\nIf you see, in the above test case, the recipe \"zpmcz\" depends on the recipe \"h\", while the recipe \"h\" again depends upon \"zpmcz\". Clearly this is a cyclic dependency which is causing the stack overflow. I want to understand if this test case is wrong or my understanding of the problem (that there would be no cycles) is wrong. And if the test case is wrong, how come other solutions have been accepted?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "i also thought same , got wrong ans after 56th test case , test case can be cyclic dependent "
                    },
                    {
                        "username": "kos2kos",
                        "content": "Probably need to add a visited HashSet to avoid cycles"
                    },
                    {
                        "username": "zrzzgy",
                        "content": "The question stated that 2 recipes may have each other as ingredients. That\\'s a known situation."
                    },
                    {
                        "username": "rewill11",
                        "content": "a same question like this was asked in a div3 round of codeforces"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Yeah.. Round 888 Problem E"
                    },
                    {
                        "username": "Limon020",
                        "content": "Good question, topological sort and caching is fun"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "All 3 of the test cases are working with me and I am returning List<String> In Java the framework is throwing error \"output [] Expected \"bread\"\""
                    }
                ]
            },
            {
                "id": 2056791,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I'm not sure if a woman joke will be acceptable here. "
                    },
                    {
                        "username": "svikramsingh287",
                        "content": "may be i can solve if someone give my blowjob during coding\\n"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/1638eb86-64de-445c-8a08-31ee445f0c9a_1640453734.8884196.png)\\nAny  corrections, suggestions or optimizations are welcomed :)\\nIf you found this post helpful then please like and comment to increase it\\'s reach. :)"
                    },
                    {
                        "username": "dhruv-chaudhary",
                        "content": "I am getting stackoverflow exception in this test case\\n\\n`recipes =\\n[\"ju\",\"fzjnm\",\"x\",\"e\",\"zpmcz\",\"h\",\"q\"]`\\n\\n`ingredients =\\n[[\"d\"],[\"hveml\",\"f\",\"cpivl\"],[\"cpivl\",\"zpmcz\",\"h\",\"e\",\"fzjnm\",\"ju\"],[\"cpivl\",\"hveml\",\"zpmcz\",\"ju\",\"h\"],[\"h\",\"fzjnm\",\"e\",\"q\",\"x\"],[\"d\",\"hveml\",\"cpivl\",\"q\",\"zpmcz\",\"ju\",\"e\",\"x\"],[\"f\",\"hveml\",\"cpivl\"]]`\\n\\n`supplies =\\n[\"f\",\"hveml\",\"cpivl\",\"d\"]`\\n\\nIf you see, in the above test case, the recipe \"zpmcz\" depends on the recipe \"h\", while the recipe \"h\" again depends upon \"zpmcz\". Clearly this is a cyclic dependency which is causing the stack overflow. I want to understand if this test case is wrong or my understanding of the problem (that there would be no cycles) is wrong. And if the test case is wrong, how come other solutions have been accepted?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "i also thought same , got wrong ans after 56th test case , test case can be cyclic dependent "
                    },
                    {
                        "username": "kos2kos",
                        "content": "Probably need to add a visited HashSet to avoid cycles"
                    },
                    {
                        "username": "zrzzgy",
                        "content": "The question stated that 2 recipes may have each other as ingredients. That\\'s a known situation."
                    },
                    {
                        "username": "rewill11",
                        "content": "a same question like this was asked in a div3 round of codeforces"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Yeah.. Round 888 Problem E"
                    },
                    {
                        "username": "Limon020",
                        "content": "Good question, topological sort and caching is fun"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "All 3 of the test cases are working with me and I am returning List<String> In Java the framework is throwing error \"output [] Expected \"bread\"\""
                    }
                ]
            },
            {
                "id": 2040507,
                "content": [
                    {
                        "username": "shivasaineelam",
                        "content": "this is hard"
                    },
                    {
                        "username": "_srahul_",
                        "content": "I'm not sure if a woman joke will be acceptable here. "
                    },
                    {
                        "username": "svikramsingh287",
                        "content": "may be i can solve if someone give my blowjob during coding\\n"
                    },
                    {
                        "username": "Fly_ing__Rhi_no",
                        "content": "![image](https://assets.leetcode.com/users/images/1638eb86-64de-445c-8a08-31ee445f0c9a_1640453734.8884196.png)\\nAny  corrections, suggestions or optimizations are welcomed :)\\nIf you found this post helpful then please like and comment to increase it\\'s reach. :)"
                    },
                    {
                        "username": "dhruv-chaudhary",
                        "content": "I am getting stackoverflow exception in this test case\\n\\n`recipes =\\n[\"ju\",\"fzjnm\",\"x\",\"e\",\"zpmcz\",\"h\",\"q\"]`\\n\\n`ingredients =\\n[[\"d\"],[\"hveml\",\"f\",\"cpivl\"],[\"cpivl\",\"zpmcz\",\"h\",\"e\",\"fzjnm\",\"ju\"],[\"cpivl\",\"hveml\",\"zpmcz\",\"ju\",\"h\"],[\"h\",\"fzjnm\",\"e\",\"q\",\"x\"],[\"d\",\"hveml\",\"cpivl\",\"q\",\"zpmcz\",\"ju\",\"e\",\"x\"],[\"f\",\"hveml\",\"cpivl\"]]`\\n\\n`supplies =\\n[\"f\",\"hveml\",\"cpivl\",\"d\"]`\\n\\nIf you see, in the above test case, the recipe \"zpmcz\" depends on the recipe \"h\", while the recipe \"h\" again depends upon \"zpmcz\". Clearly this is a cyclic dependency which is causing the stack overflow. I want to understand if this test case is wrong or my understanding of the problem (that there would be no cycles) is wrong. And if the test case is wrong, how come other solutions have been accepted?"
                    },
                    {
                        "username": "rawatvishal",
                        "content": "i also thought same , got wrong ans after 56th test case , test case can be cyclic dependent "
                    },
                    {
                        "username": "kos2kos",
                        "content": "Probably need to add a visited HashSet to avoid cycles"
                    },
                    {
                        "username": "zrzzgy",
                        "content": "The question stated that 2 recipes may have each other as ingredients. That\\'s a known situation."
                    },
                    {
                        "username": "rewill11",
                        "content": "a same question like this was asked in a div3 round of codeforces"
                    },
                    {
                        "username": "prakhars31",
                        "content": "Yeah.. Round 888 Problem E"
                    },
                    {
                        "username": "Limon020",
                        "content": "Good question, topological sort and caching is fun"
                    },
                    {
                        "username": "adeelaslam_arbisoft",
                        "content": "All 3 of the test cases are working with me and I am returning List<String> In Java the framework is throwing error \"output [] Expected \"bread\"\""
                    }
                ]
            }
        ]
    }
]