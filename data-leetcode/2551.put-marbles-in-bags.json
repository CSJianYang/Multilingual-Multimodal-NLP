[
    {
        "title": "Put Marbles in Bags",
        "question_content": "You have k bags. You are given a 0-indexed integer array weights where weights[i] is the weight of the ith marble. You are also given the integer k.\nDivide the marbles into the k bags according to the following rules:\n\n\tNo bag is empty.\n\tIf the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.\n\tIf a bag consists of all the marbles with an index from i to j inclusively, then the cost of the bag is weights[i] + weights[j].\n\nThe score after distributing the marbles is the sum of the costs of all the k bags.\nReturn the difference between the maximum and minimum scores among marble distributions.\n&nbsp;\nExample 1:\n\nInput: weights = [1,3,5,1], k = 2\nOutput: 4\nExplanation: \nThe distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) = 6. \nThe distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1) = 10. \nThus, we return their difference 10 - 6 = 4.\n\nExample 2:\n\nInput: weights = [1, 3], k = 2\nOutput: 0\nExplanation: The only distribution possible is [1],[3]. \nSince both the maximal and minimal score are the same, we return 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= k <= weights.length <= 105\n\t1 <= weights[i] <= 109",
        "solutions": [
            {
                "id": 3111642,
                "title": "simple-c-solution-using-sort-idea-explained",
                "content": "# Approach\\nFirst, there are two special cases: when $k=1$ or $n=k$, there is just one possible distribution. When $k=1$ we can do nothing but put all marbles in one bag. When $n=k$, we can only put one marble in each bag. Since there is just one possible distribution, the difference between the one with maximum score and the one with minimum score would obviously be 0. \\n\\nNow let\\'s think about the general case. Suppose there are $n$ marbles and $k$ bags. We can observe that regardless how we put the marbles, the weight of the first marble and the last marble would always be counted. The score differs among different distributions which depends on how we split the marbles in the middle. \\n\\nConsider the marbles (I will just note the indices below): $[0, 1, 2, ..., n-1]$. To split them into $k$ different bags, we just need to put $k-1$ bars in the gaps of the marbles. That being said, we have $n-1$ gaps, and we put $k-1$ bars there. When we put a bar after $i$-th marble, the score of such distribution would increase by $weights[i] + weights[i+1]$\\n\\nTaking $n=10, k = 3$ as an example, One possible distribution is $[0, 1, 2, | 3, 4, 5, 6, 7, | 8, 9]$. When we put a bar after marble 2, the score increases by $weights[2] + weights[3]$. \\n\\nHence, the problem turns into that, with $n-1$ gaps, and the score added after placing a bar after $i$-th marble is $weights[i] + weights[i+1]$, we want to find the minimum/maximum score after placing $k-1$ bars.\\n\\nWith this understanding, the solution is simple: record $weights[i] + weights[i+1]$ for each $0 \\\\leq i < n-1$, sort them, select $k-1$ smallest/largest ones from them, and find the difference in score. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n\\\\log n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        if (k == 1 || n == k) return 0;\\n        vector<int> candidates;\\n        for (int i = 0; i < n-1; i++)\\n        {\\n            candidates.push_back(weights[i] + weights[i+1]);\\n        }\\n        sort(candidates.begin(), candidates.end());\\n        long long mins = 0, maxs = 0;\\n        for (int i = 0; i < k-1; i++)\\n        {\\n            mins += candidates[i];\\n            maxs += candidates[n-2-i];\\n        }\\n        return maxs - mins;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        if (k == 1 || n == k) return 0;\\n        vector<int> candidates;\\n        for (int i = 0; i < n-1; i++)\\n        {\\n            candidates.push_back(weights[i] + weights[i+1]);\\n        }\\n        sort(candidates.begin(), candidates.end());\\n        long long mins = 0, maxs = 0;\\n        for (int i = 0; i < k-1; i++)\\n        {\\n            mins += candidates[i];\\n            maxs += candidates[n-2-i];\\n        }\\n        return maxs - mins;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111736,
                "title": "java-c-python-3-approachs-best-o-n",
                "content": "\\n# **Intuition**\\nSeems a `O(nk)` dp problem at the first galance,\\nwhen observe the effect of different cut points,\\nI realize it\\'s more like problem,\\nto pick `k` largest/smallest from `n` numbers.\\n<br>\\n\\n# **Explanation**\\nFirst for any of distributions,\\nwe will sum up `A[0]` and `A[n - 1]` in the total socre,\\nso this won\\'t make any difference between max and min.\\n\\nTo split into `k` bags,\\nwe actually choose `k-1` cut points:\\nA[0]...A[i1]\\nA[i1+1]....A[i2]\\nA[i2+1]....A[i3]\\n....\\nA[ik+1]....A[n-1]\\n\\nThe result score is:\\n`(A[0] + A[i1]) + (A[i2] + A[i3]) +..... + (A[ik+1] + A[n-1])`\\nequals to\\n`A[0] + (A[i1] + A[i1+1]) + (A[i2] + A[i2+1]) + ....`\\n\\nSo the problem turns out to be,\\ncalculate the max/min sum of `k - 1` numbers in\\nA[0] + A[1], A[1] + A[2],..., A[n-1] + A[n].\\n\\nWe can simply sort them in `O(sort)`\\nor we can apply a priority queue in `O(nlogk)`.\\n<br>\\n\\n# Solution 1: Sort\\n**Java**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n```java\\n    public long putMarbles(int[] A, int k) {\\n        int n = A.length - 1;\\n        long B[] = new long[n], res = 0;\\n        for (int i = 0; i < B.length; i++) {\\n            B[i] = A[i] + A[i + 1];\\n        }\\n        Arrays.sort(B);\\n        for (int i = 0; i < k - 1; i++) {\\n            res += B[n - 1 - i] - B[i];\\n        }\\n        return res;\\n    }\\n```\\n**C++**\\nTime `O(nlogn)`\\nSpace `O(n)`\\n```cpp\\n    long long putMarbles(vector<int> A, int k) {\\n        long long res = 0, n  = A.size() - 1;\\n        for (int i = 0; i < n; ++i)\\n            A[i] += A[i + 1];\\n        A.pop_back();\\n        sort(A.begin(), A.end());\\n        for (int i = 0; i < k - 1; ++i)\\n            res += A[n - 1 - i] - A[i];\\n        return res;\\n    }\\n```\\n<br>\\n\\n# **Solution 2: Priority Queue**\\n**Python3**\\nTime `O(nlogk)`\\nSpace `O(k)`\\n```py\\n    def putMarbles(self, A: List[int], k: int) -> int:\\n        B = [a + b for a,b in pairwise(A)]\\n        return sum(nlargest(k - 1, B)) - sum(nsmallest(k - 1, B))\\n```\\n<br>\\n\\n# **Solution 3: Quick Select**\\nUsing `nth_element` in C++\\nTime `O(n)`\\nSpace `O(n)`\\n```cpp\\n    long long putMarbles(vector<int> A, int k) {\\n        long long res = 0, n  = A.size() - 1;\\n        for (int i = 0; i < n; ++i)\\n            A[i] += A[i + 1];\\n        A.pop_back();\\n        nth_element(A.begin(), A.begin() + k - 1, A.end());\\n        for (int i = 0; i < k - 1; ++i)\\n            res -= A[i];\\n        nth_element(A.begin(), A.begin() + n - k + 1, A.end());\\n        for (int i = 0; i < k - 1; ++i)\\n            res += A[n - 1 - i];\\n        return res;\\n    }\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public long putMarbles(int[] A, int k) {\\n        int n = A.length - 1;\\n        long B[] = new long[n], res = 0;\\n        for (int i = 0; i < B.length; i++) {\\n            B[i] = A[i] + A[i + 1];\\n        }\\n        Arrays.sort(B);\\n        for (int i = 0; i < k - 1; i++) {\\n            res += B[n - 1 - i] - B[i];\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    long long putMarbles(vector<int> A, int k) {\\n        long long res = 0, n  = A.size() - 1;\\n        for (int i = 0; i < n; ++i)\\n            A[i] += A[i + 1];\\n        A.pop_back();\\n        sort(A.begin(), A.end());\\n        for (int i = 0; i < k - 1; ++i)\\n            res += A[n - 1 - i] - A[i];\\n        return res;\\n    }\\n```\n```py\\n    def putMarbles(self, A: List[int], k: int) -> int:\\n        B = [a + b for a,b in pairwise(A)]\\n        return sum(nlargest(k - 1, B)) - sum(nsmallest(k - 1, B))\\n```\n```cpp\\n    long long putMarbles(vector<int> A, int k) {\\n        long long res = 0, n  = A.size() - 1;\\n        for (int i = 0; i < n; ++i)\\n            A[i] += A[i + 1];\\n        A.pop_back();\\n        nth_element(A.begin(), A.begin() + k - 1, A.end());\\n        for (int i = 0; i < k - 1; ++i)\\n            res -= A[i];\\n        nth_element(A.begin(), A.begin() + n - k + 1, A.end());\\n        for (int i = 0; i < k - 1; ++i)\\n            res += A[n - 1 - i];\\n        return res;\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3735251,
                "title": "intution-building-explanation-c",
                "content": "# **Intution**\\nSuppose array is  [a,b,c,d,e,f,g,h]\\n\\n* Lets think what happen if **k = 1 our maximum is a + h**, because all marble need to put up in same bag. (Easy)\\n\\n* Lets think what happen if **k = 2** our maximum still consist of **a   + two extra variable + h** what are those two extra variable, we don\\'t know these two extra variable but yes these two must be **adjacent** (Important) For now let\\'s say these two extra variable is c and d so our answer is now **a  + (c + d) + h** and two bag consist of marble **a,b,c** and **d, e, f, g, h**\\n\\n* Lets think what happen if k = 3 our maximum still consist of **a  + (c + d) + two extra variable + h**, what are those two extra variable, we don\\'t know these two extra variable but yes these two must be **adjacent** (Important) For now let\\'s say these two extra variable is g and h so our answer is now **a  + (c + d) + (g + h) + h** and our bag consist of marbles **a,b,c and d, e, f, g and h** for 3 bags respectively and same goes for  k = 4 , 5 , 6 .......\\n\\n1. For maximum (c+d) > (g+h) and so on....\\n2. For minimum  (c+d) < (g+h) and so on....\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& v, int k) {\\n            \\n            int n = v.size();\\n            \\n            long long  mx = v[0] + v[n-1]; // Maximum Value \\n            long long  mn = v[0] + v[n-1]; // Minimum Value\\n            \\n            vector<long long > adjSum; // For storing adjacent sum\\n            \\n            for(int i = 0;i<n-1;i++)\\n                    adjSum.push_back(v[i] + v[i+1]);  // Storing adjacent sum\\n            \\n            \\n            sort(adjSum.begin(),adjSum.end(),greater<int>()); // Sorting in descending order\\n            \\n            \\n            \\n            for(int i = 0;i<k-1;i++)\\n                    mx +=(long long) adjSum[i], // adding maximum to mx\\n                    mn +=(long long) adjSum[n-i-2]; // adding minimum to mn\\n            \\n          \\n            \\n           \\n            \\n          \\n            return (mx- mn); // difference is the answer\\n            \\n            \\n            \\n            \\n        \\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& v, int k) {\\n            \\n            int n = v.size();\\n            \\n            long long  mx = v[0] + v[n-1]; // Maximum Value \\n            long long  mn = v[0] + v[n-1]; // Minimum Value\\n            \\n            vector<long long > adjSum; // For storing adjacent sum\\n            \\n            for(int i = 0;i<n-1;i++)\\n                    adjSum.push_back(v[i] + v[i+1]);  // Storing adjacent sum\\n            \\n            \\n            sort(adjSum.begin(),adjSum.end(),greater<int>()); // Sorting in descending order\\n            \\n            \\n            \\n            for(int i = 0;i<k-1;i++)\\n                    mx +=(long long) adjSum[i], // adding maximum to mx\\n                    mn +=(long long) adjSum[n-i-2]; // adding minimum to mn\\n            \\n          \\n            \\n           \\n            \\n          \\n            return (mx- mn); // difference is the answer\\n            \\n            \\n            \\n            \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734172,
                "title": "2-aprroaches-easy-to-understand-code-explanation-c-java-python-video",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe approach lies in the problem if u see carefully we will always add two consecutive element when we do partion so if we store all the sum of two consecutive element and take k-1 max summations and k-1 min summations will give particular max and min score. \\nthe result will be their difference.\\n\\nFor detailed explanation you can refer to my youtube channel (Hindi Language) \\nhttps://youtu.be/RPUA6GIoBvM\\nor link in my profile.Here,you can find any solution in playlists monthwise from June 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\nor\\nsearch \\uD83D\\uDC49`Put Marbles in Bags\\n by Let\\'s Code Together` on youtube\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long l1 = 0, l2 = 0;\\n        k--;\\n        int n = weights.size();\\n        vector<long long> res1;\\n\\n        for (int i = 1; i < n; i++) {\\n            res1.push_back(weights[i] + weights[i - 1]);\\n        }\\n\\n        sort(res1.begin(), res1.end(), greater<long long>());\\n\\n        int n1 = res1.size();\\n\\n        for (int i = 0; i < k; i++) {\\n            l2 += res1[i];\\n            l1 += res1[n1 - 1 - i];\\n        }\\n\\n        return (l2 - l1);\\n    }\\n};\\n\\n```\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$  \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code2(more optimised avoiding extra computataions)\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\npriority_queue<int> pq1;\\n    priority_queue<int, vector<int>, greater<int>> pq2;k--;\\n   for (int i = 0; i < weights.size() - 1; i++) {\\n    pq1.push(weights[i] + weights[i + 1]);\\n    pq2.push(weights[i] + weights[i + 1]);\\n    if (pq1.size() > k ) {\\n        pq1.pop();\\n        pq2.pop();\\n    }\\n    }\\n   long long ans1 = 0, ans2 = 0;\\n   while (!pq1.empty()) {\\n    ans1 += pq1.top();\\n    ans2 += pq2.top();\\n    pq1.pop();\\n    pq2.pop();\\n   }\\n    return ans2 - ans1;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity:$$O(nlogk)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(k)$$  \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![upvote-this-you.jpg](https://assets.leetcode.com/users/images/60d84fff-25dc-4394-a446-e7724e10bd5a_1688789376.5947142.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long l1 = 0, l2 = 0;\\n        k--;\\n        int n = weights.size();\\n        vector<long long> res1;\\n\\n        for (int i = 1; i < n; i++) {\\n            res1.push_back(weights[i] + weights[i - 1]);\\n        }\\n\\n        sort(res1.begin(), res1.end(), greater<long long>());\\n\\n        int n1 = res1.size();\\n\\n        for (int i = 0; i < k; i++) {\\n            l2 += res1[i];\\n            l1 += res1[n1 - 1 - i];\\n        }\\n\\n        return (l2 - l1);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\npriority_queue<int> pq1;\\n    priority_queue<int, vector<int>, greater<int>> pq2;k--;\\n   for (int i = 0; i < weights.size() - 1; i++) {\\n    pq1.push(weights[i] + weights[i + 1]);\\n    pq2.push(weights[i] + weights[i + 1]);\\n    if (pq1.size() > k ) {\\n        pq1.pop();\\n        pq2.pop();\\n    }\\n    }\\n   long long ans1 = 0, ans2 = 0;\\n   while (!pq1.empty()) {\\n    ans1 += pq1.top();\\n    ans2 += pq2.top();\\n    pq1.pop();\\n    pq2.pop();\\n   }\\n    return ans2 - ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111583,
                "title": "python3-sort-the-separators-o-n-log-n-2-lines",
                "content": "# Intuition\\nAll of our bags are continuous slices of the array and all marbles must be in a bag and all bags are nonempty, so we\\'re constructing a partition of the array with k slices and summing the first and last element of each slice.\\n\\nNo matter what, the first element of the array will count in the first slice and the last element of the array will count in the last slice.\\n\\nOtherwise, we can think of our k slices as adding k - 1 separators to the array, where a separators is placed between index i and index i + 1 and adds the value at both indices to the overall score (since the former will be the last element of the previous slice and the latter will be the last element of the next one). The maximal partition will use the k - 1 separators that have the largest sum and the minimal solution will use the k - 1 separators that have the smallest sum.\\n\\n# Approach\\nFind the value of each separator, sort them, and take the largest k - 1 and subtract the smallest k - 1. We don\\'t have to care about the value of the first index and the value of the last index, since they are present in both the maximal and minimal partition.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def putMarbles(self, w: List[int], k: int) -> int:\\n        p = sorted([w[i] + w[i + 1] for i in range(len(w) - 1)])\\n        return sum(p[len(p) - k + 1:]) - sum(p[:k - 1])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, w: List[int], k: int) -> int:\\n        p = sorted([w[i] + w[i + 1] for i in range(len(w) - 1)])\\n        return sum(p[len(p) - k + 1:]) - sum(p[:k - 1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111862,
                "title": "nlogn-straight-forward-3-java-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- We are asked to divide the array into k sub-arrays\\n- the score is the sum of the beginning value and end value for all sub-arrays\\n- if k is the same as array length, there\\'s only 1 way:\\n    - Each element is a subarray iself\\n    - In this case the score diff between max and min is 0\\n-  To divide an array into k sub-arrays means to find k-1 delimiters (\"|\" in below) within the array to divide the aray\\n    - [1,2|3,4|5,6]: two \"|\" divides the array into three sub arrays\\n    - each \"|\" will increase the total score by ```weights[i-1] + weights[i]```, say index before and after \"|\" is ```i-1``` and ```i```\\n- Now our goal is to find the largest k-1 \"|\" and the smallest k-1 \"|\", how?\\n    - create a new array of ```weights.length-1```, (you could re-use the same array, but for simplicity, we\\'ll use a new one)\\n    - put the sum at each \"|\" (```weights[i-1] + weights[i]```) into new array\\n    - sort it\\n    - now you get the top ```k-1``` and smallest ```k-1``` sum, return the difference\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) or O(1) if you reuse the same array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```java\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        if (k == n) return 0;\\n        int[] W = new int[n-1];\\n        for (int i = 1; i < n; i++) W[i-1] = weights[i] + weights[i-1];\\n        Arrays.sort(W);\\n\\n        return max(W, k-1) - min(W, k-1);\\n    }\\n    \\n    private long max(int[] W, int k) {\\n        int n = W.length;\\n        long res = 0;\\n        for (int i = n-1; i >= n-k; i--) res += W[i];\\n        return res;\\n    }\\n\\n    private long min(int[] W, int k) {\\n        long res = 0;\\n        for (int i = 0; i < k; i++) res += W[i];\\n        return res;\\n    }\\n}\\n```\\n# O(1) Space\\n```java\\nclass Solution {\\n    public long putMarbles(int[] W, int k) {\\n        int n = W.length;\\n        if (k == n) return 0;\\n        for (int i = 1; i < n; i++) W[i-1] = W[i] + W[i-1];\\n        W[n-1] = Integer.MAX_VALUE;\\n        Arrays.sort(W);\\n\\n        return max(W, k-1) - min(W, k-1);\\n    }\\n    \\n    private long max(int[] W, int k) {\\n        int n = W.length;\\n        long res = 0;\\n        for (int i = n-2; i >= n-k-1; i--) res += W[i];\\n        return res;\\n    }\\n\\n    private long min(int[] W, int k) {\\n        long res = 0;\\n        for (int i = 0; i < k; i++) res += W[i];\\n        return res;\\n    }\\n}\\n```\\n# one pass\\n```java\\nclass Solution {\\n    public long putMarbles(int[] W, int k) {\\n        int n = W.length;\\n        if (k == n) return 0;\\n        for (int i = 1; i < n; i++) W[i-1] = W[i] + W[i-1];\\n        W[n-1] = Integer.MAX_VALUE;\\n        Arrays.sort(W);\\n\\n        long res = 0L;\\n\\n        for (int i = 0; i < k-1; i++)\\n            res += W[n-2-i] - W[i];\\n\\n        return res;\\n    }\\n}\\n```\\nPLEASE UPVOTE IF YOU FIND THIS POST HELPFUL, THANK YOU!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```weights[i-1] + weights[i]```\n```i-1```\n```i```\n```weights.length-1```\n```weights[i-1] + weights[i]```\n```k-1```\n```k-1```\n```java\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        if (k == n) return 0;\\n        int[] W = new int[n-1];\\n        for (int i = 1; i < n; i++) W[i-1] = weights[i] + weights[i-1];\\n        Arrays.sort(W);\\n\\n        return max(W, k-1) - min(W, k-1);\\n    }\\n    \\n    private long max(int[] W, int k) {\\n        int n = W.length;\\n        long res = 0;\\n        for (int i = n-1; i >= n-k; i--) res += W[i];\\n        return res;\\n    }\\n\\n    private long min(int[] W, int k) {\\n        long res = 0;\\n        for (int i = 0; i < k; i++) res += W[i];\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public long putMarbles(int[] W, int k) {\\n        int n = W.length;\\n        if (k == n) return 0;\\n        for (int i = 1; i < n; i++) W[i-1] = W[i] + W[i-1];\\n        W[n-1] = Integer.MAX_VALUE;\\n        Arrays.sort(W);\\n\\n        return max(W, k-1) - min(W, k-1);\\n    }\\n    \\n    private long max(int[] W, int k) {\\n        int n = W.length;\\n        long res = 0;\\n        for (int i = n-2; i >= n-k-1; i--) res += W[i];\\n        return res;\\n    }\\n\\n    private long min(int[] W, int k) {\\n        long res = 0;\\n        for (int i = 0; i < k; i++) res += W[i];\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public long putMarbles(int[] W, int k) {\\n        int n = W.length;\\n        if (k == n) return 0;\\n        for (int i = 1; i < n; i++) W[i-1] = W[i] + W[i-1];\\n        W[n-1] = Integer.MAX_VALUE;\\n        Arrays.sort(W);\\n\\n        long res = 0L;\\n\\n        for (int i = 0; i < k-1; i++)\\n            res += W[n-2-i] - W[i];\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734432,
                "title": "java-sorting-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/26460f9c-230a-4037-93e2-ac4f4163b14c_1688787643.5261037.jpeg)\\n\\n\\n```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        int[] pairs = new int[n - 1];\\n        for (int i = 1; i < n; i++) {\\n            pairs[i - 1] = weights[i] + weights[i - 1];\\n        }\\n        Arrays.sort(pairs);\\n        long minScore = 0;\\n        long maxScore = 0;\\n        for (int i = 0; i < k - 1; i++) {\\n            minScore += pairs[i];\\n            maxScore += pairs[n - i - 2];\\n        }\\n        return maxScore - minScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        int[] pairs = new int[n - 1];\\n        for (int i = 1; i < n; i++) {\\n            pairs[i - 1] = weights[i] + weights[i - 1];\\n        }\\n        Arrays.sort(pairs);\\n        long minScore = 0;\\n        long maxScore = 0;\\n        for (int i = 0; i < k - 1; i++) {\\n            minScore += pairs[i];\\n            maxScore += pairs[n - i - 2];\\n        }\\n        return maxScore - minScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112789,
                "title": "heap-sorting-both-approach-very-simple-and-easy-to-understand-solution",
                "content": "# Intuition\\nWe can see that the last and first will be always added in both max and min evaluation and will get cancel out each other.\\nSo now the question modified as, find out k-1 separation points in the given list so that there sum will be max and min.\\n\\n\\n# Approach\\n1. To achieve this we can simple need to track the top k-1 pairs whose sum is max and k-1 pirs whose sum is min.\\nTo get this we can use minHeap and maxHeap to accumulate the values and at the end of evaluation of each pair take sum of each of the top k-1 values in both the heap and return the difference.\\n\\n2. Second approach could be take another array which stores the sum of two consicutive values possible and simply sort it.\\nThen take the sum of largest k-1 elements and sum of smallest k-1 values and return ans as the diff of these two.\\n\\n\\n# Complexity\\n- Time complexity:\\nWe need to push at max k element to the heap: O(nlogk)\\n\\n- Space complexity:\\nAt max we need to store N elements, so its O(N)\\n\\n# Code\\n\\n1. Using heap solution:\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        priority_queue<int> pqMin;\\n        priority_queue<int, vector<int>, greater<int>> pqMax;\\n        for(int i = 1; i < weights.size(); ++i){\\n            pqMax.push(weights[i] + weights[i-1]);\\n            pqMin.push(weights[i] + weights[i-1]);\\n            if(pqMax.size() >= k) { pqMax.pop(); pqMin.pop(); }\\n        }\\n        long long ans = 0;\\n        while(pqMax.size() > 0){\\n            ans += pqMax.top() - pqMin.top();\\n            pqMax.pop(); pqMin.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n2. Using Sorting:\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long ans = 0;\\n        vector<int> psum;\\n        for(int i = 1; i < weights.size(); ++i){ psum.push_back(weights[i] + weights[i-1]); }\\n        sort(psum.begin(), psum.end());\\n        for(int i = 0; i < k-1; i++ ){ ans += psum[psum.size() - 1 - i] - psum[i];  }\\n        return ans;\\n    }\\n};\\n```\\n\\nHere is an article of my recent interview experience at Amazon, you may like : \\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        priority_queue<int> pqMin;\\n        priority_queue<int, vector<int>, greater<int>> pqMax;\\n        for(int i = 1; i < weights.size(); ++i){\\n            pqMax.push(weights[i] + weights[i-1]);\\n            pqMin.push(weights[i] + weights[i-1]);\\n            if(pqMax.size() >= k) { pqMax.pop(); pqMin.pop(); }\\n        }\\n        long long ans = 0;\\n        while(pqMax.size() > 0){\\n            ans += pqMax.top() - pqMin.top();\\n            pqMax.pop(); pqMin.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long ans = 0;\\n        vector<int> psum;\\n        for(int i = 1; i < weights.size(); ++i){ psum.push_back(weights[i] + weights[i-1]); }\\n        sort(psum.begin(), psum.end());\\n        for(int i = 0; i < k-1; i++ ){ ans += psum[psum.size() - 1 - i] - psum[i];  }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734206,
                "title": "c-greedy-approach-explaination-with-examples",
                "content": "# Explaination\\nJust see the pattern of how partition is made. We don\\'t care about the middle elements of the Subarray, We just care about the boundaries of the Partition. \\n\\nLet say arr= [a,b,c,d,e,f,g,h,i,j] and k=4\\nif i do partition like this:\\na | b c d | e f g | h i j\\nsum= a+a + b+d + e+g + h+j\\nsum = a+ (a+b) + (d+e) + (g+h) + j;\\n........................|__________________|\\nSo we need maximize and minimize this part to get the answer.\\n\\nSo, We store sum of pair of consecutive elements in a vector and then sort it.\\nAfter that we just give the Difference between maxi and mini.\\n\\n\\nex: arr=[1 , 3 , 5 , 1]  k=2;\\n\\n* 1 | 3 5 1 , sum is 1+1 + 3+1  => 1+ (1+3) +1\\n* 1 3 | 5 1 , sum is 1+3 + 5+1  => 1+ (3+5) +1\\n* 1 3 5 | 1 , sum is 1+5 + 1+1  => 1+ (5+1) +1\\n\\n\\n\\n# Complexity\\n- Time complexity: O(NlogN), We sort the store vector.\\n\\n- Space complexity: O(N), we made a store vector\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long> store;\\n        for(int i=1;i<weights.size();i++){\\n            store.push_back(weights[i]+weights[i-1]);\\n        }\\n        sort(store.begin(),store.end());\\n        int n=store.size();\\n        long long mini=0;\\n        for(int i=0;i<k-1;i++){\\n            mini+= store[i];\\n        }\\n\\n        long long maxi=0;\\n        for(int i=0;i<k-1;i++){\\n            maxi+= store[n-1-i];\\n        }\\n        return maxi - mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long> store;\\n        for(int i=1;i<weights.size();i++){\\n            store.push_back(weights[i]+weights[i-1]);\\n        }\\n        sort(store.begin(),store.end());\\n        int n=store.size();\\n        long long mini=0;\\n        for(int i=0;i<k-1;i++){\\n            mini+= store[i];\\n        }\\n\\n        long long maxi=0;\\n        for(int i=0;i<k-1;i++){\\n            maxi+= store[n-1-i];\\n        }\\n        return maxi - mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734284,
                "title": "sort-video-solution",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/K0opAL-J07U\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    public long putMarbles(int[] W, int k) {\\n        int n = W.length;\\n        int [] pairs = new int[n-1];\\n        for(int i = 1;i<n;i++){\\n            pairs[i-1] = W[i]+W[i-1];\\n        }\\n        Arrays.sort(pairs);\\n        long min = 0;long max = 0;\\n        for(int i = 0;i<k-1;i++){\\n            min+=pairs[i];\\n            max+=pairs[n-i-2];\\n        }\\n        return max-min;\\n    }\\n}\\n```\\n```\\nclass Solution {\\npublic:\\n    long putMarbles(std::vector<int>& W, int k) {\\n        int n = W.size();\\n        std::vector<int> pairs(n - 1);\\n        for (int i = 1; i < n; i++) {\\n            pairs[i - 1] = W[i] + W[i - 1];\\n        }\\n        std::sort(pairs.begin(), pairs.end());\\n        \\n        long min = 0;\\n        long max = 0;\\n        for (int i = 0; i < k - 1; i++) {\\n            min += pairs[i];\\n            max += pairs[n - i - 2];\\n        }\\n        \\n        return max - min;\\n    }\\n};\\n```\\n\\n```\\nclass Solution:\\n    def putMarbles(self, W: List[int], k: int) -> int:\\n        n = len(W)\\n        pairs = [0] * (n - 1)\\n        for i in range(1, n):\\n            pairs[i - 1] = W[i] + W[i - 1]\\n        pairs.sort()\\n        \\n        min_sum = 0\\n        max_sum = 0\\n        for i in range(k - 1):\\n            min_sum += pairs[i]\\n            max_sum += pairs[n - i - 2]\\n        \\n        return max_sum - min_sum\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] W, int k) {\\n        int n = W.length;\\n        int [] pairs = new int[n-1];\\n        for(int i = 1;i<n;i++){\\n            pairs[i-1] = W[i]+W[i-1];\\n        }\\n        Arrays.sort(pairs);\\n        long min = 0;long max = 0;\\n        for(int i = 0;i<k-1;i++){\\n            min+=pairs[i];\\n            max+=pairs[n-i-2];\\n        }\\n        return max-min;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    long putMarbles(std::vector<int>& W, int k) {\\n        int n = W.size();\\n        std::vector<int> pairs(n - 1);\\n        for (int i = 1; i < n; i++) {\\n            pairs[i - 1] = W[i] + W[i - 1];\\n        }\\n        std::sort(pairs.begin(), pairs.end());\\n        \\n        long min = 0;\\n        long max = 0;\\n        for (int i = 0; i < k - 1; i++) {\\n            min += pairs[i];\\n            max += pairs[n - i - 2];\\n        }\\n        \\n        return max - min;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def putMarbles(self, W: List[int], k: int) -> int:\\n        n = len(W)\\n        pairs = [0] * (n - 1)\\n        for i in range(1, n):\\n            pairs[i - 1] = W[i] + W[i - 1]\\n        pairs.sort()\\n        \\n        min_sum = 0\\n        max_sum = 0\\n        for i in range(k - 1):\\n            min_sum += pairs[i]\\n            max_sum += pairs[n - i - 2]\\n        \\n        return max_sum - min_sum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111859,
                "title": "tle-dp-solution",
                "content": "For me DP is the most intuitive way to solve. Unfortunately it couldn\\'t pass the grader since it has a complexity of n^2 * k \\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], K: int) -> int:\\n        # dp[i][j] = min/max value of only considering the first j + 1 weights divided into i parts\\n        # dp[i][j] = min(dp[i - 1][k] + weights[k + 1] + weights[j]) for 1 <= k < j\\n        n = len(weights)\\n        min_dp = [[float(\\'inf\\')] * n for _ in range(K + 1)]\\n        max_dp = [[float(\\'-inf\\')] * n for _ in range(K + 1)]\\n        for i in range(n):\\n            min_dp[1][i] = weights[0] + weights[i]\\n            max_dp[1][i] = weights[0] + weights[i]\\n            \\n        for i in range(2, K + 1):\\n            for j in range(n):\\n                for k in range(j):\\n                    min_dp[i][j] = min(min_dp[i - 1][k] + weights[k + 1] + weights[j], min_dp[i][j])\\n                    max_dp[i][j] = max(max_dp[i - 1][k] + weights[k + 1] + weights[j], max_dp[i][j])\\n\\n        return max_dp[K][n - 1] - min_dp[K][n - 1]\\n```\\nAny improvements are welcome!",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], K: int) -> int:\\n        # dp[i][j] = min/max value of only considering the first j + 1 weights divided into i parts\\n        # dp[i][j] = min(dp[i - 1][k] + weights[k + 1] + weights[j]) for 1 <= k < j\\n        n = len(weights)\\n        min_dp = [[float(\\'inf\\')] * n for _ in range(K + 1)]\\n        max_dp = [[float(\\'-inf\\')] * n for _ in range(K + 1)]\\n        for i in range(n):\\n            min_dp[1][i] = weights[0] + weights[i]\\n            max_dp[1][i] = weights[0] + weights[i]\\n            \\n        for i in range(2, K + 1):\\n            for j in range(n):\\n                for k in range(j):\\n                    min_dp[i][j] = min(min_dp[i - 1][k] + weights[k + 1] + weights[j], min_dp[i][j])\\n                    max_dp[i][j] = max(max_dp[i - 1][k] + weights[k + 1] + weights[j], max_dp[i][j])\\n\\n        return max_dp[K][n - 1] - min_dp[K][n - 1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111723,
                "title": "java-sorting-explained",
                "content": "---\\n# Please Upvote \\uD83D\\uDE07\\n---\\nIt is been observed that, whenever we make a partition, and add the costs of the bags, we always get a pair sum like this:\\n\\n*current bag\\'s `j`th weight and next bag\\'s `i`th weight*\\n\\n![image.png](https://assets.leetcode.com/users/images/e1512b5a-1f11-4bca-9653-c30835a5042b_1674975455.079999.png)\\n\\n\\nSo we can make as many partitions and we will always have `w[j] (current bag) + W[i] (next bag)` present in the score.\\n\\nAnd our score is nothing but sum of all such pairs:\\n\\n![image.png](https://assets.leetcode.com/users/images/deae3f9e-4541-4c97-a0b2-cb1507817adb_1674976428.7052581.png)\\n\\n\\nSo every `w[k] + w[k + 1]` will be present in the score when we make all possible partitions.\\n\\nSo we will store `w[k] + w[k + 1]` in an array and sort it.\\n\\n![image.png](https://assets.leetcode.com/users/images/06405b30-85bd-4b2d-b057-5422bd241477_1674976202.2843637.png)\\n\\nSo for `k` bags, number of partitions put will be `k - 1`.\\nWe know sum of all costs gives us the score.\\nSo we will run a loop on the array which stores our bag costs:\\n- The first `k - 1` cost sum will be our minimum possible score.\\n- The last `k - 1` cost sum will be our maximum possible score.\\n\\n``` java []\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        // if number of bags = number of marbles\\n        // minimum score = sum of cost of each bag/marble\\n        // maximum score = sum of cost of each bag/marble\\n        // so both are equal hence difference is 0\\n        if (k == n) {\\n            return 0;\\n        }\\n        \\n        int[] costs = new int[n-1];\\n        for (int i = 0; i < n - 1; i++) { \\n            costs[i] = weights[i] + weights[i+1];\\n        }\\n        \\n        Arrays.sort(costs);\\n        \\n        long min = 0, max = 0;\\n        for (int i = 0; i < k - 1; i++) {\\n            min += costs[i];\\n            max += costs[n-i-2];    \\n            // length of costs is n-1 \\n            // so last index is n-1-1 = n-2\\n        }\\n        \\n        return max - min;\\n    }\\n}\\n```\\n### Time complexity: $$O(n) + O(n * logn) => O(n * logn)$$\\n### Space complexity: $$O(n)$$\\n",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        // if number of bags = number of marbles\\n        // minimum score = sum of cost of each bag/marble\\n        // maximum score = sum of cost of each bag/marble\\n        // so both are equal hence difference is 0\\n        if (k == n) {\\n            return 0;\\n        }\\n        \\n        int[] costs = new int[n-1];\\n        for (int i = 0; i < n - 1; i++) { \\n            costs[i] = weights[i] + weights[i+1];\\n        }\\n        \\n        Arrays.sort(costs);\\n        \\n        long min = 0, max = 0;\\n        for (int i = 0; i < k - 1; i++) {\\n            min += costs[i];\\n            max += costs[n-i-2];    \\n            // length of costs is n-1 \\n            // so last index is n-1-1 = n-2\\n        }\\n        \\n        return max - min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111602,
                "title": "and-i-thought-it-is-binary-search",
                "content": "***Am i alone or anyone else who think of same ?***\\n\\n```\\nclass Solution {\\n\\n    public long putMarbles(int[] A, int k) {\\n        int n = A.length - 1;\\n        long B[] = new long[n], res = 0;\\n        for (int i = 0; i < B.length; i++) {\\n            B[i] = A[i] + A[i + 1];\\n        }\\n        Arrays.sort(B);\\n        for (int i = 0; i < k - 1; i++) {\\n            res += B[n - 1 - i] - B[i];\\n        }\\n        return res;\\n    }\\n}\\n\\n```\\n\\n![image](https://media.tenor.com/sWyJSZPGPX4AAAAd/im-fine-fine.gif)\\n",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long putMarbles(int[] A, int k) {\\n        int n = A.length - 1;\\n        long B[] = new long[n], res = 0;\\n        for (int i = 0; i < B.length; i++) {\\n            B[i] = A[i] + A[i + 1];\\n        }\\n        Arrays.sort(B);\\n        for (int i = 0; i < k - 1; i++) {\\n            res += B[n - 1 - i] - B[i];\\n        }\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735488,
                "title": "c-very-easy-trick-with-sorting-96-56-69-76",
                "content": "# Intuition\\n-> OBSERVE: first and last will always be included (hence common in both min and max)\\n\\n-> To divide into k, we need to put k-1 walls in between\\n\\n-> Each new wall after index `i` costs `weights[i]+weights[i+1]`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        int n = w.size();\\n        if (k==1||n==k){ \\n            return 0;\\n        }\\n        vector<int> v;\\n        for (int i = 0; i < n-1; i++)\\n        {\\n            v.push_back(w[i] + w[i+1]);\\n        }\\n        sort(v.begin(), v.end());\\n        long long mini = 0;\\n        long long maxi = 0;\\n        for (int i = 0; i < k-1; i++)\\n        {\\n            mini += v[i];\\n            maxi += v[n-2-i];\\n        }\\n        return maxi - mini;\\n    }\\n};\\n```\\n\\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        int n = w.size();\\n        if (k==1||n==k){ \\n            return 0;\\n        }\\n        vector<int> v;\\n        for (int i = 0; i < n-1; i++)\\n        {\\n            v.push_back(w[i] + w[i+1]);\\n        }\\n        sort(v.begin(), v.end());\\n        long long mini = 0;\\n        long long maxi = 0;\\n        for (int i = 0; i < k-1; i++)\\n        {\\n            mini += v[i];\\n            maxi += v[n-2-i];\\n        }\\n        return maxi - mini;\\n    }\\n};\\n```\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734241,
                "title": "python-3-2-lines-w-explanation-t-m-97-56",
                "content": "For the sake of discussion, consider the example:\\n```\\n            weights = [ 2, 5, 7, 2, 1, 1, 10], k = 4\\n```\\nIt can be shown that the distributions with the maximum and minimum costs respectively are \\n```\\nMin: [2], [5,7,2], [1], [1,10]    Max: [2,5], [7], [2,1,1], [10],\\n```\\nIt follows that:\\n```\\nCost of Min: (2+2) + (5+2) + (1+1) +  (1+10) = 2+ (2+5) + (2+1) +  (1+1) + 10 = 2 + 12 +10 = 24\\nCost of Max: (2+5) + (7+7) + (2+1) + (10+10) = 2+ (5+7) + (7+2) + (1+10) + 10 = 2 + 32 +10 = 44\\n\\nAnswer: Cost of Max - Cost of Min = (2 + 32 +10) - (2 + 12 +10) = 32 - 12 = 20\\n```\\nThere\\'s still some more thinking to do here, but this example should point you in the right direction.\\n\\nHere\\'s my code:\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n\\n        arr = sorted(map(sum,(pairwise(weights))))\\n\\n        return  sum(arr[len(arr)-k+1:]) - sum(arr[:k-1]) \\n```\\n[https://leetcode.com/problems/put-marbles-in-bags/submissions/989337481/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*log*N*) and space complexity is *O*(*N*), in which *N* ~ `len(nums)`.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n            weights = [ 2, 5, 7, 2, 1, 1, 10], k = 4\\n```\n```\\nMin: [2], [5,7,2], [1], [1,10]    Max: [2,5], [7], [2,1,1], [10],\\n```\n```\\nCost of Min: (2+2) + (5+2) + (1+1) +  (1+10) = 2+ (2+5) + (2+1) +  (1+1) + 10 = 2 + 12 +10 = 24\\nCost of Max: (2+5) + (7+7) + (2+1) + (10+10) = 2+ (5+7) + (7+2) + (1+10) + 10 = 2 + 32 +10 = 44\\n\\nAnswer: Cost of Max - Cost of Min = (2 + 32 +10) - (2 + 12 +10) = 32 - 12 = 20\\n```\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n\\n        arr = sorted(map(sum,(pairwise(weights))))\\n\\n        return  sum(arr[len(arr)-k+1:]) - sum(arr[:k-1]) \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734391,
                "title": "max-min-heap-based",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& v, int k) {\\n        priority_queue<int> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n        for(int i = 0; i < v.size()-1; i++){\\n            pq1.push(v[i]+v[i+1]);\\n            pq2.push(v[i]+v[i+1]);\\n            if(pq1.size()>k-1){\\n                pq1.pop();\\n                pq2.pop();\\n            }\\n        }\\n        long long int ans1 = 0, ans2 = 0;\\n        while(!pq1.empty()){\\n            ans1 += pq1.top();\\n            ans2 += pq2.top();\\n            pq1.pop();pq2.pop();\\n        }\\n        return ans2-ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& v, int k) {\\n        priority_queue<int> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n        for(int i = 0; i < v.size()-1; i++){\\n            pq1.push(v[i]+v[i+1]);\\n            pq2.push(v[i]+v[i+1]);\\n            if(pq1.size()>k-1){\\n                pq1.pop();\\n                pq2.pop();\\n            }\\n        }\\n        long long int ans1 = 0, ans2 = 0;\\n        while(!pq1.empty()){\\n            ans1 += pq1.top();\\n            ans2 += pq2.top();\\n            pq1.pop();pq2.pop();\\n        }\\n        return ans2-ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734243,
                "title": "explain-partition-c-python-greedy-sort-vs-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[Please turn on english subtitles if neccessary]\\n[https://youtu.be/XMOqSMrbz_Q](https://youtu.be/XMOqSMrbz_Q)\\n# What is the essential meaning for a partition?\\n\\nA partition refers to dividing something, such as a set or array, into separate sections or subsets.\\n\\n# Can you explain how to find k-1 pairs based on the weights in a partition?\\n\\nTo find k-1 pairs based on the weights in a partition, we need to determine the end index for each subarray in the partition. For each i-th subarray, denoted by P[i], we look at the weights[P[i]] and weights[P[i]+1] elements. We continue this process for all the subarrays in the partition.\\n\\n\\n# What is the score of a partition?\\n\\nThe score of a partition, denoted as score(P), is calculated by summing certain weights. We start with weights[0] and weights[n-1], and then for each subarray i, we add the weights[P[i]] and weights[P[i]+1] together. This sum is repeated for all subarrays in the partition.\\n\\n$$\\nscore(P)=\\\\\\\\(weights[0]+weights[P[0]])+(weights[P[0]+1]+weights[P[1]])+\\\\\\\\ \\\\cdots\\n+(weights[P[i-1]+1]+weights[P[i]])+\\\\\\\\\\n\\\\cdots+(weights[P[k-2]+1]+weights[n-1])\\n\\\\\\\\\\n=weights[0]+weights[n-1]+\\\\sum_i (weights[P[i]]+weights[P[i]+1])\\n$$\\n\\nLook at this example. Let \"|\" denote the partition. Since k=4, there are exactly 3 partitions.\\n[54,6,34,66,63|52,39,62,46,75,28,65,18,37,18|13,33,69,19,40,13|10,43,61,72] \\n\\nP[0]=4, weights[P[0]]=63, weights[P[0]+1]=52 partition[0]=63+52\\np[1]=14, weights[P[1]]=18, weights[P[1]+1]=13, partition[1]=18+13\\n# What is the desired answer in terms of the scores of different partitions?\\n\\nThe desired answer is the difference between the maximum score of all partitions ($\\\\max_P score(P)$) and the minimum score of all partitions ($\\\\min_P score(P)$).\\n\\n# How many partitions are there at most?\\n\\nThere can be at most $n-1$ partitions.\\n\\n# How can you find the maximum and minimum scores of all partitions?\\n\\nTo find the maximum and minimum scores of all partitions, you can either sort the partition scores (partition[i] = weights[i] + weights[i+1]) or use heaps (a data structure). Once the scores are sorted or stored in a heap, it becomes easy to identify the maximum and minimum scores.\\n\\n<!-- Describe your approach to solving the problem. -->\\ntest case\\n```\\n[54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72]\\n4\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n \\\\log n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        if (n<=2 || n==k) return 0;\\n        vector<int> P(n-1, 0);\\n        for (int i=0; i<n-1; i++)\\n            P[i]=weights[i]+weights[i+1];\\n        \\n        sort(P.begin(), P.end());\\n\\n        // without weights[0]+weights[n-1]\\n        long long minP=accumulate(P.begin(), P.begin()+(k-1), 0LL), \\n        maxP=accumulate(P.begin()+(n-k), P.end(), 0LL);\\n        \\n        return maxP-minP;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        n=len(weights)\\n        if n<=2 or n==k:\\n            return 0\\n        partition=[0]*(n-1)\\n        for i in range(n-1):\\n            partition[i]=weights[i]+weights[i+1]\\n\\n        partition.sort()\\n\\n        maxP=sum(partition[n-k:]) #without weights[0]+weights[n-1]\\n        minP=sum(partition[:k-1])\\n        return maxP-minP\\n```\\n\\n# 2nd Approach using priority queue is slower but theoretically faster time complexity O(n log k)\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        if (n<=2) return 0;\\n\\n        priority_queue<int> maxHeap;\\n        priority_queue<int, vector<int>, greater<int> > minHeap;\\n        long long maxP=0, minP=0;\\n        for (int i=0; i<k-1; i++){\\n            int partition=weights[i]+weights[i+1];\\n            maxP+=partition;\\n            maxHeap.push(partition);\\n            minHeap.push(partition);\\n        }\\n        minP=maxP; \\n\\n        //without weights[0]+weights[n-1]\\n        for(int i=k-1; i<n-1; i++){\\n            int partition=weights[i]+weights[i+1];\\n            maxHeap.push(partition);\\n            minP+=partition-maxHeap.top();\\n            maxHeap.pop();\\n            minHeap.push(partition);\\n            maxP+=partition-minHeap.top();\\n            minHeap.pop();\\n        }\\n        return maxP-minP;\\n    }\\n};\\n```\\n![DALL\\xB7E 2023-07-08 12.08.18 - Next to the dog, there are many open bags with marbles in a realistic style.png](https://assets.leetcode.com/users/images/226bafc1-fe58-4d31-8b64-3a471bd061c9_1688789396.5242088.png)\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Greedy",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n[54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72]\\n4\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        if (n<=2 || n==k) return 0;\\n        vector<int> P(n-1, 0);\\n        for (int i=0; i<n-1; i++)\\n            P[i]=weights[i]+weights[i+1];\\n        \\n        sort(P.begin(), P.end());\\n\\n        // without weights[0]+weights[n-1]\\n        long long minP=accumulate(P.begin(), P.begin()+(k-1), 0LL), \\n        maxP=accumulate(P.begin()+(n-k), P.end(), 0LL);\\n        \\n        return maxP-minP;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        n=len(weights)\\n        if n<=2 or n==k:\\n            return 0\\n        partition=[0]*(n-1)\\n        for i in range(n-1):\\n            partition[i]=weights[i]+weights[i+1]\\n\\n        partition.sort()\\n\\n        maxP=sum(partition[n-k:]) #without weights[0]+weights[n-1]\\n        minP=sum(partition[:k-1])\\n        return maxP-minP\\n```\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        if (n<=2) return 0;\\n\\n        priority_queue<int> maxHeap;\\n        priority_queue<int, vector<int>, greater<int> > minHeap;\\n        long long maxP=0, minP=0;\\n        for (int i=0; i<k-1; i++){\\n            int partition=weights[i]+weights[i+1];\\n            maxP+=partition;\\n            maxHeap.push(partition);\\n            minHeap.push(partition);\\n        }\\n        minP=maxP; \\n\\n        //without weights[0]+weights[n-1]\\n        for(int i=k-1; i<n-1; i++){\\n            int partition=weights[i]+weights[i+1];\\n            maxHeap.push(partition);\\n            minP+=partition-maxHeap.top();\\n            maxHeap.pop();\\n            minHeap.push(partition);\\n            maxP+=partition-minHeap.top();\\n            minHeap.pop();\\n        }\\n        return maxP-minP;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111897,
                "title": "don-t-calculate-weights",
                "content": "# Intuition\\nEffectively we are not putting marbles to k bags we rather set k-1 boundaries in array. E.g. given\\n```\\n[1, 4, 2, 5, 2]\\n```\\nthere are 4 placeholders for boundaries (where commas are), and we can place two boundaries e.g.\\n```\\n1, 4| 2| 5, 2\\n```\\nThat gives us bags [[1,4],[2],[5,2]] or (1+4)+(2+2)+(5+2) = 16 scores.\\nIn total there are (n-1)(n-2) ... (n-k) combinations\\n\\n# Approach\\nSince we at the end need to output only difference between weights instead of calculating weights we actually can calculate *weight increments*. That means how greatly weight will be increased when we place the boundary. And to our luck the weight contribution always equals sum of the neighbouring boundary weights. E.g. in example above:\\n```\\n1, 4| 2| 5, 2\\n    \\u2191  \\u2191\\n   1st 2nd\\n```\\nweight contribution for the 1st and the 2nd boundary is\\n```\\nw1 = weights[1] + weights[2] = 4 + 2 = 6\\nw2 = weights[2] + weights[3] = 2 + 5 = 7\\n```\\n\\nIn other words we don\\'t need to calculate differences of scores, because we can calculate differences between increments.\\n\\nThus approach will be like this:\\n1. Create array of boundary weight increments. (I used JavaScript array method map and slice for that)\\n2. sort the array of boundary weight increments from lowest to highest\\n3. Calculate maximal contribution by summing k-1 last element of the sorted array. In JavaScript I am using reduce.\\n4. Calculate minimal contribution by summing k-1 first element of the sorted array\\n5. Return the difference between the maximal and the minimal contributions. \\n\\nSince we need only to do direct calculation of each element O(n) and do sorting O(n*log(n)) and index k elements that give us complexity O(n*log(n))\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} weights\\n * @param {number} k\\n * @return {number}\\n */\\nvar putMarbles = function (weights, k) {\\n  if (weights.length === k) return 0;\\n  let getEdgeWeights = weights.map((n, i, a) => (i < a.length - 1 ? n + a[i + 1] : 0));\\n  getEdgeWeights = getEdgeWeights.slice(0, weights.length - 1);\\n  getEdgeWeights = getEdgeWeights.sort((a, b) => a - b);\\n  let maxScores = getEdgeWeights.slice(getEdgeWeights.length - k + 1).reduce((a, b) => a + b, 0);\\n  let minScores = getEdgeWeights.slice(0, k - 1).reduce((a, b) => a + b, 0);\\n  return maxScores - minScores;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n[1, 4, 2, 5, 2]\\n```\n```\\n1, 4| 2| 5, 2\\n```\n```\\n1, 4| 2| 5, 2\\n    \\u2191  \\u2191\\n   1st 2nd\\n```\n```\\nw1 = weights[1] + weights[2] = 4 + 2 = 6\\nw2 = weights[2] + weights[3] = 2 + 5 = 7\\n```\n```\\n/**\\n * @param {number[]} weights\\n * @param {number} k\\n * @return {number}\\n */\\nvar putMarbles = function (weights, k) {\\n  if (weights.length === k) return 0;\\n  let getEdgeWeights = weights.map((n, i, a) => (i < a.length - 1 ? n + a[i + 1] : 0));\\n  getEdgeWeights = getEdgeWeights.slice(0, weights.length - 1);\\n  getEdgeWeights = getEdgeWeights.sort((a, b) => a - b);\\n  let maxScores = getEdgeWeights.slice(getEdgeWeights.length - k + 1).reduce((a, b) => a + b, 0);\\n  let minScores = getEdgeWeights.slice(0, k - 1).reduce((a, b) => a + b, 0);\\n  return maxScores - minScores;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3735950,
                "title": "c-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n       vector<long long>partitions; \\n       for(int i=1;i<weights.size();i++){\\n          long long sum = weights[i] + weights[i-1];\\n           partitions.push_back(sum);\\n       }\\n       sort(partitions.begin(),partitions.end()); \\n       int n = partitions.size();\\n       long long mx=0,mn=0;\\n       for(int i=0;i<k-1;i++)mn += partitions[i];\\n       for(int i=n-1;i>=n-k+1;i--)mx += partitions[i];\\n       return mx - mn;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/ce4b954a-8425-4d27-86ff-76829c2ada95_1688812718.6206923.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n       vector<long long>partitions; \\n       for(int i=1;i<weights.size();i++){\\n          long long sum = weights[i] + weights[i-1];\\n           partitions.push_back(sum);\\n       }\\n       sort(partitions.begin(),partitions.end()); \\n       int n = partitions.size();\\n       long long mx=0,mn=0;\\n       for(int i=0;i<k-1;i++)mn += partitions[i];\\n       for(int i=n-1;i>=n-k+1;i--)mx += partitions[i];\\n       return mx - mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734308,
                "title": "java-easy-solution-2-approaches-using-arraylist-array-sorting",
                "content": "# Code 1\\n```\\nclass Solution {\\n\\n    public long putMarbles(int[] weights, int k) {\\n        if(k==1 || k==weights.length)\\n        {\\n            return 0;\\n        }\\n        int[] score = new int[weights.length - 1];\\n        for(int i=0;i<weights.length-1;i++)\\n        {\\n            score[i] = weights[i] + weights[i+1];\\n        }\\n        Arrays.sort(score);\\n        long min_sum = 0,max_sum=0;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            min_sum += score[i];\\n            max_sum += score[score.length - i -1];\\n        }\\n        return (max_sum - min_sum);\\n    } \\n}\\n```\\n\\n#Code 2\\n``` \\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        if(k==1 || k==weights.length)\\n        {\\n            return 0;\\n        }\\n         List<Long> list1 = new ArrayList<>();\\n         List<Long> list2 = new ArrayList<>();\\n\\n         for(int i=0;i<weights.length-1;i++)\\n         {\\n             list1.add((long)weights[i] + weights[i + 1]);\\n             list2.add((long)weights[i] + weights[i + 1]);\\n         }\\n         Collections.sort(list1);\\n         Collections.sort(list2, Collections.reverseOrder());\\n         long min_sum = 0,max_sum=0;\\n         for(int i=0;i<k-1;i++)\\n         {\\n             min_sum += list1.get(i);\\n             max_sum += list2.get(i);\\n         }\\n        \\n        return (max_sum - min_sum);\\n    } \\n}\\n```\\n![cat.jpg](https://assets.leetcode.com/users/images/d328a611-391e-46a1-94d6-64f1435a9ad0_1688789458.9193842.jpeg)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long putMarbles(int[] weights, int k) {\\n        if(k==1 || k==weights.length)\\n        {\\n            return 0;\\n        }\\n        int[] score = new int[weights.length - 1];\\n        for(int i=0;i<weights.length-1;i++)\\n        {\\n            score[i] = weights[i] + weights[i+1];\\n        }\\n        Arrays.sort(score);\\n        long min_sum = 0,max_sum=0;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            min_sum += score[i];\\n            max_sum += score[score.length - i -1];\\n        }\\n        return (max_sum - min_sum);\\n    } \\n}\\n```\n``` \\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        if(k==1 || k==weights.length)\\n        {\\n            return 0;\\n        }\\n         List<Long> list1 = new ArrayList<>();\\n         List<Long> list2 = new ArrayList<>();\\n\\n         for(int i=0;i<weights.length-1;i++)\\n         {\\n             list1.add((long)weights[i] + weights[i + 1]);\\n             list2.add((long)weights[i] + weights[i + 1]);\\n         }\\n         Collections.sort(list1);\\n         Collections.sort(list2, Collections.reverseOrder());\\n         long min_sum = 0,max_sum=0;\\n         for(int i=0;i<k-1;i++)\\n         {\\n             min_sum += list1.get(i);\\n             max_sum += list2.get(i);\\n         }\\n        \\n        return (max_sum - min_sum);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111598,
                "title": "java-solution-with-detailed-explanation",
                "content": "When we split the array into k subsegments, we would end up having [al, ar], [bl, br] \\u2026\\u2026 [kl,kr]  where l and r represents the index of the first and last elements of a segment\\nNotice that al would be the first element of the array and kr would be the last element of the array. Also, bl = ar + 1, likewise cl = br + 1 and so on.\\nHence the values [al, ar], [bl, br] \\u2026\\u2026 [kl,kr] would contain the first and last element and k - 1 adjacent pairs. We could then find each adjacent pair sum and store them in a list. Selecting k - 1 largest adjacent pair sum would give the maximum score. Likewise, selecting the k - 1 smallest adjacent pair sum gives the minimum score.\\n\\nTime Complexity is O(n log n) due to sorting\\n\\nPlease upvote if you like the solution :)\\n\\n```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        List<Integer> sums = new ArrayList<>();\\n        \\n        for (int i = 1; i < weights.length; ++i) {\\n            sums.add(weights[i] + weights[i - 1]);\\n        }\\n        \\n        Collections.sort(sums);\\n        \\n        long smaller = 0;\\n        \\n        for (int i = 0; i < k - 1; ++i) {\\n            smaller += sums.get(i);\\n        }\\n        \\n        long larger = 0;\\n        \\n        Collections.reverse(sums);\\n        \\n        for (int i = 0; i < k - 1; ++i) {\\n            larger += sums.get(i);\\n        }\\n        \\n        return larger - smaller;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        List<Integer> sums = new ArrayList<>();\\n        \\n        for (int i = 1; i < weights.length; ++i) {\\n            sums.add(weights[i] + weights[i - 1]);\\n        }\\n        \\n        Collections.sort(sums);\\n        \\n        long smaller = 0;\\n        \\n        for (int i = 0; i < k - 1; ++i) {\\n            smaller += sums.get(i);\\n        }\\n        \\n        long larger = 0;\\n        \\n        Collections.reverse(sums);\\n        \\n        for (int i = 0; i < k - 1; ++i) {\\n            larger += sums.get(i);\\n        }\\n        \\n        return larger - smaller;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734696,
                "title": "c-greedy-heap-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Upon initial analysis of the code, it appears to be solving a problem related to marbles and their weights. Here are my initial thoughts on how the problem is being solved:\\n\\n1. The code takes a vector `weights` and an integer `k` as inputs. The vector `weights` represents the weights of marbles.\\n2. The code initializes two priority queues: `maxh` as a max heap and `minh` as a min heap. These heaps will be used to store the sums of consecutive marble weights.\\n3. A loop iterates through the vector `weights` from the second element to the last, and for each pair of consecutive weights, the sum of their weights is calculated and pushed into both `maxh` and `minh`.\\n4. Two variables, `maxSum` and `minSum`, are initialized to zero. They will be used to store the maximum and minimum sums of marble weights.\\n5. The variable `k` is decremented by 1 to account for the first marble that is already put.\\n6. A loop is executed `k` times, in each iteration:\\n   - The top element (maximum) of `maxh` is popped and added to `maxSum`.\\n   - The top element (minimum) of `minh` is popped and added to `minSum`.\\n7. Finally, the difference between `maxSum` and `minSum` is returned as the result.\\n\\nThese are my initial thoughts based on the code provided. However, without further context or a problem statement, it is difficult to provide a more comprehensive solution analysis.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n + k log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        priority_queue <int> maxh; // Max heap to store the sums of consecutive marble weights in descending order\\n        priority_queue <int,vector<int>,greater<int>> minh; // Min heap to store the sums of consecutive marble weights in ascending order\\n        \\n        // Calculate the sums of consecutive marble weights and add them to both heaps\\n        for(int i=1;i<n;i++){\\n            maxh.push(weights[i]+weights[i-1]);\\n            minh.push(weights[i]+weights[i-1]);\\n        }\\n        \\n        long long maxSum = 0;\\n        long long minSum = 0;\\n        k--; // Decrease k by 1 since the first marble is already put\\n        \\n        // Remove the k largest and k smallest sums from the heaps and calculate the maximum and minimum sums\\n        while(k--){\\n            maxSum += maxh.top();\\n            maxh.pop();\\n            minSum += minh.top();\\n            minh.pop();\\n        }\\n        \\n        // Return the difference between the maximum and minimum sums\\n        return maxSum - minSum;\\n    }\\n};\\n\\n```\\n![Leetcode.jpeg](https://assets.leetcode.com/users/images/c925302c-d778-4340-8726-9188e0229f9b_1688792234.2630477.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        priority_queue <int> maxh; // Max heap to store the sums of consecutive marble weights in descending order\\n        priority_queue <int,vector<int>,greater<int>> minh; // Min heap to store the sums of consecutive marble weights in ascending order\\n        \\n        // Calculate the sums of consecutive marble weights and add them to both heaps\\n        for(int i=1;i<n;i++){\\n            maxh.push(weights[i]+weights[i-1]);\\n            minh.push(weights[i]+weights[i-1]);\\n        }\\n        \\n        long long maxSum = 0;\\n        long long minSum = 0;\\n        k--; // Decrease k by 1 since the first marble is already put\\n        \\n        // Remove the k largest and k smallest sums from the heaps and calculate the maximum and minimum sums\\n        while(k--){\\n            maxSum += maxh.top();\\n            maxh.pop();\\n            minSum += minh.top();\\n            minh.pop();\\n        }\\n        \\n        // Return the difference between the maximum and minimum sums\\n        return maxSum - minSum;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3157688,
                "title": "weights-j-weights-j-1",
                "content": "The intuition for this problem could be tricky to see.\\n\\nIf we make a division after point `j`, it adds `w[j] + w[j + 1]` to the score.\\n\\nWe make `k - 1` divisions, and the total score includes weights of all division pairs, plus the weight of the first and last marble.\\n\\nFor the maximum/minimum score, we need to pick `k - 1` division pairs with the highest/lowest combined weight. \\n\\n## Sort\\nEasier, but not as efficient as nth element.\\n\\nIf `k` is greater than half of the array, min/max pairs will overlap. In that case, we only need to get `n - k` pairs.\\n\\n**C++**\\n```cpp\\nlong long putMarbles(vector<int>& w, int k) {\\n    if (k == 1 || k == w.size())\\n        return 0;\\n    vector<long long> gaps;\\n    transform(begin(w), prev(end(w)), begin(w) + 1, back_inserter(gaps), plus());    \\n    sort(begin(gaps), end(gaps));\\n    k = min(k, (int)w.size() - k + 1);\\n    return transform_reduce(rbegin(gaps), rbegin(gaps) + k - 1, begin(gaps), 0LL, plus(), minus());\\n}\\n```\\n\\n## Nth Element\\nThe runtime of this solution is ~50% better, since we do not need scores in a perfect order.\\n\\n**C++**\\n```cpp\\nlong long putMarbles(vector<int>& w, int k) {\\n    if (k == 1)\\n        return 0;    \\n    vector<long long> gaps;\\n    transform(begin(w), prev(end(w)), begin(w) + 1, back_inserter(gaps), plus());\\n    k = min(k, (int)w.size() - k + 1);\\n    nth_element(begin(gaps), begin(gaps) + k - 1, end(gaps));\\n    nth_element(begin(gaps) + k, begin(gaps) + gaps.size() - k, end(gaps));\\n    return transform_reduce(rbegin(gaps), rbegin(gaps) + k - 1, begin(gaps), 0LL, plus(), minus());\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nlong long putMarbles(vector<int>& w, int k) {\\n    if (k == 1 || k == w.size())\\n        return 0;\\n    vector<long long> gaps;\\n    transform(begin(w), prev(end(w)), begin(w) + 1, back_inserter(gaps), plus());    \\n    sort(begin(gaps), end(gaps));\\n    k = min(k, (int)w.size() - k + 1);\\n    return transform_reduce(rbegin(gaps), rbegin(gaps) + k - 1, begin(gaps), 0LL, plus(), minus());\\n}\\n```\n```cpp\\nlong long putMarbles(vector<int>& w, int k) {\\n    if (k == 1)\\n        return 0;    \\n    vector<long long> gaps;\\n    transform(begin(w), prev(end(w)), begin(w) + 1, back_inserter(gaps), plus());\\n    k = min(k, (int)w.size() - k + 1);\\n    nth_element(begin(gaps), begin(gaps) + k - 1, end(gaps));\\n    nth_element(begin(gaps) + k, begin(gaps) + gaps.size() - k, end(gaps));\\n    return transform_reduce(rbegin(gaps), rbegin(gaps) + k - 1, begin(gaps), 0LL, plus(), minus());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3111641,
                "title": "easy-short-efficient-clean-code",
                "content": "**Observations:**\\n-> We need to make exactly \\'k\\' non-empty contiguous partitions of the array (arr).\\n-> The first partition starts at index 0 and last partitions ends at n-1, where n is the size of arr.\\n-> Any point at which one partition ends and the next partition starts from, let us call it \\'pivot\\'\\n-> Thus there are 2*k total points that make n-1 pivots.\\n-> Thus there are k-1 pivots.\\n-> Each pivote is of the form (i, i+1).\\n-> The value of a pivot is arr[i]+arr[i+1]\\n-> Thus the overall max is arr[0]+ sum of scores of the k-1 highest valued pivots + arr[n-1]\\n-> Thus the overall min is arr[0]+ sum of scores of the k-1 smallest valued pivots + arr[n-1]\\n-> Final answer is max-min.\\n-> In general, how do we iterate over a sequence and find k of the n highest/smallest items?\\n-> The answer is piority_queue\\n```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\nlong long putMarbles(vector<int>&v, int k) {\\n    priority_queue<ll>pqmx;\\n    priority_queue<ll,vector<ll>,greater<ll>>pqmn;\\n    ll n=v.size();\\n    for(ll i=0;i<n-1;++i){\\n        pqmx.push(v[i]+v[i+1]), pqmn.push(v[i]+v[i+1]);\\n        if(pqmx.size()>k-1){\\n            pqmx.pop(), pqmn.pop();\\n        }\\n    }\\n    ll ans=0;\\n    while(!pqmx.empty()){\\n        ans+=pqmn.top()-pqmx.top();\\n        pqmx.pop(), pqmn.pop();\\n    }\\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\ntypedef long long ll;\\nlong long putMarbles(vector<int>&v, int k) {\\n    priority_queue<ll>pqmx;\\n    priority_queue<ll,vector<ll>,greater<ll>>pqmn;\\n    ll n=v.size();\\n    for(ll i=0;i<n-1;++i){\\n        pqmx.push(v[i]+v[i+1]), pqmn.push(v[i]+v[i+1]);\\n        if(pqmx.size()>k-1){\\n            pqmx.pop(), pqmn.pop();\\n        }\\n    }\\n    ll ans=0;\\n    while(!pqmx.empty()){\\n        ans+=pqmn.top()-pqmx.top();\\n        pqmx.pop(), pqmn.pop();\\n    }\\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735129,
                "title": "attention-dp-minded-folks",
                "content": "# Analysis Of Dynamic Programming\\nGreedy Choice property..\\n        Greedily picking the spliting point which gives the max sum/ min sum. Total k - 1 splits needed. to produce k partitions\\n        For efficienty picking the greedy choice, we preprocess the input. The input is the adjacent pair sums.\\n        This boils down to one clear distiction between Dynamic programming and greedy algos:\\n The greedy choice makes sure that the choice is the safest choice for the current problem. like this is the best split for the first split. This choice doesnt care what splits are required in the future splits. It builds top down fundamentally.\\n        Dynamic programming mkes choice only after taking care of l the future choices to smaller subproblems. It builds bottom up fundamentally.\\n        For efficient processing of greedy choice we use sorting or data structures like priority queue and hence perform preprocessing on input for better retrieval.\\n\\n# Code via DP\\n```\\nclass Solution {\\n    int putMarblesMax(int k, int i, bool first, bool last, vector<int>& weights, vector<vector<vector<vector<int>>>> &dp1) {\\n        if(k <= 0 && i < weights.size()) return -1e9;\\n        if(i == weights.size()) {\\n             return k == 0 ? 0 : -1e9;         \\n        } \\n        if(dp1[i][first][last][k] != -1) return dp1[i][first][last][k];\\n        // int choose_first = 1e9, choose_both = 1e9, choose_last = 1e9, dont_choose = 1e9;\\n        vector<int> choices(4,-1e9);\\n        if(first) {\\n            // Choose both as first and last\\n            choices[1] = weights[i] * 2 + putMarblesMax(k - 1, i + 1, true, false, weights, dp1);\\n            // Choose as first only\\n            choices[0] = weights[i] + putMarblesMax(k, i + 1, false, true, weights, dp1);\\n        }\\n        // Dont choose as first and neither last.\\n        if(i) choices[3] = putMarblesMax(k, i + 1, false, true, weights, dp1);\\n        if(last) {           \\n\\n            // Choose as last\\n            choices[2] = weights[i] + putMarblesMax(k - 1, i + 1, true, false, weights, dp1);\\n\\n        }\\n        return dp1[i][first][last][k] = *max_element(choices.begin(), choices.end());\\n\\n    }\\n   int putMarblesMin(int k, int i, bool first, bool last, vector<int>& weights, vector<vector<vector<vector<int>>>> &dp2) {\\n        if(k <= 0 && i < weights.size()) return 1e9;\\n        if(i == weights.size()) {\\n             return k == 0 ? 0 : 1e9;         \\n        } \\n        if(dp2[i][first][last][k] != -1) return dp2[i][first][last][k];\\n        // int choose_first = 1e9, choose_both = 1e9, choose_last = 1e9, dont_choose = 1e9;\\n        vector<int> choices(4, 1e9);\\n        if(first) {\\n            // Choose both as first and last\\n            choices[1] = weights[i] * 2 + putMarblesMin(k - 1, i + 1, true, false, weights, dp2);\\n            // Choose as first only\\n            choices[0] = weights[i] + putMarblesMin(k, i + 1, false, true, weights, dp2);\\n        }\\n       \\n        if(last) {           \\n             // Dont choose as first and neither last.\\n            choices[3] = putMarblesMin(k, i + 1, false, true, weights, dp2);\\n            // Choose as last\\n            choices[2] = weights[i] + putMarblesMin(k - 1, i + 1, true, false, weights, dp2);\\n\\n        }\\n        return dp2[i][first][last][k] = *min_element(choices.begin(), choices.end());\\n\\n    }\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        vector<vector<vector<vector<int>>>> dp1(n, vector<vector<vector<int>>> (2, vector<vector<int>> (2, vector<int>(k + 1, -1)))), dp2(n, vector<vector<vector<int>>> (2, vector<vector<int>> (2, vector<int>(k + 1, -1))));\\n        \\n        return putMarblesMax(k, 0, true, false, weights, dp1) - putMarblesMin(k, 0, true, false, weights, dp2) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    int putMarblesMax(int k, int i, bool first, bool last, vector<int>& weights, vector<vector<vector<vector<int>>>> &dp1) {\\n        if(k <= 0 && i < weights.size()) return -1e9;\\n        if(i == weights.size()) {\\n             return k == 0 ? 0 : -1e9;         \\n        } \\n        if(dp1[i][first][last][k] != -1) return dp1[i][first][last][k];\\n        // int choose_first = 1e9, choose_both = 1e9, choose_last = 1e9, dont_choose = 1e9;\\n        vector<int> choices(4,-1e9);\\n        if(first) {\\n            // Choose both as first and last\\n            choices[1] = weights[i] * 2 + putMarblesMax(k - 1, i + 1, true, false, weights, dp1);\\n            // Choose as first only\\n            choices[0] = weights[i] + putMarblesMax(k, i + 1, false, true, weights, dp1);\\n        }\\n        // Dont choose as first and neither last.\\n        if(i) choices[3] = putMarblesMax(k, i + 1, false, true, weights, dp1);\\n        if(last) {           \\n\\n            // Choose as last\\n            choices[2] = weights[i] + putMarblesMax(k - 1, i + 1, true, false, weights, dp1);\\n\\n        }\\n        return dp1[i][first][last][k] = *max_element(choices.begin(), choices.end());\\n\\n    }\\n   int putMarblesMin(int k, int i, bool first, bool last, vector<int>& weights, vector<vector<vector<vector<int>>>> &dp2) {\\n        if(k <= 0 && i < weights.size()) return 1e9;\\n        if(i == weights.size()) {\\n             return k == 0 ? 0 : 1e9;         \\n        } \\n        if(dp2[i][first][last][k] != -1) return dp2[i][first][last][k];\\n        // int choose_first = 1e9, choose_both = 1e9, choose_last = 1e9, dont_choose = 1e9;\\n        vector<int> choices(4, 1e9);\\n        if(first) {\\n            // Choose both as first and last\\n            choices[1] = weights[i] * 2 + putMarblesMin(k - 1, i + 1, true, false, weights, dp2);\\n            // Choose as first only\\n            choices[0] = weights[i] + putMarblesMin(k, i + 1, false, true, weights, dp2);\\n        }\\n       \\n        if(last) {           \\n             // Dont choose as first and neither last.\\n            choices[3] = putMarblesMin(k, i + 1, false, true, weights, dp2);\\n            // Choose as last\\n            choices[2] = weights[i] + putMarblesMin(k - 1, i + 1, true, false, weights, dp2);\\n\\n        }\\n        return dp2[i][first][last][k] = *min_element(choices.begin(), choices.end());\\n\\n    }\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        vector<vector<vector<vector<int>>>> dp1(n, vector<vector<vector<int>>> (2, vector<vector<int>> (2, vector<int>(k + 1, -1)))), dp2(n, vector<vector<vector<int>>> (2, vector<vector<int>> (2, vector<int>(k + 1, -1))));\\n        \\n        return putMarblesMax(k, 0, true, false, weights, dp1) - putMarblesMin(k, 0, true, false, weights, dp2) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734537,
                "title": "beat-100-o-n-most-optimal-solution-no-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n  * A bag is just a segment in the array.\\n  * The cost of a bag is simply the sum of the first and last element of the segment.\\n  * The sum of all costs is simply the sum of first and last elements, plus the sum of all \"boundary pairs\".\\n  * To find the difference of max and min sums, we only need to consider the sum of \"boundary pairs\".\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  * We find the \"cost\" of all the adjacent pairs.\\n  * We use selection algorithm to find the sum of largest $k - 1$ pairs and smallest $k - 1$ pairs. Their difference is the answer.\\n  * We further optimized the code by requiring k is smaller than half the pair array. For example, for `[1, 2, 3, 4, 5]`, the largest 3 minus the smallest 3 is the same as the largest 2 minus the smallest 2, because the middle element cancels. This allows us to call `std::nth_element()` more efficiently such that the second call uses the partial result of the first call.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(N)$$ on average.\\n$$\\\\Theta(N \\\\log N)$$ worse case.\\n\\nThis is the result of using C++ `std::nth_element()` library. It is possible to implement selection algorithm such that the worse case is also $\\\\Theta(N)$, but practically speaking it\\'s not going to be faster.\\n\\nNote the `std::nth_element()` is on average several times faster than sorting.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$\\\\Theta(1)$$ extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  long long putMarbles(vector<int>& weights, int k) {\\n    if (k <= 1) {\\n      return 0;\\n    }\\n    --k;\\n    for (int i = 1; i < weights.size(); ++i) {\\n      weights[i - 1] += weights[i];\\n    }\\n    weights.pop_back();\\n\\n    if (k * 2 > weights.size()) {\\n      k = weights.size() - k;\\n    }\\n    std::nth_element(weights.begin(), weights.begin() + k, weights.end());\\n    int64_t small = std::accumulate(weights.begin(), weights.begin() + k, int64_t(0));\\n    std::nth_element(weights.begin() + k, weights.end() - k, weights.end());\\n    int64_t large = std::accumulate(weights.end() - k, weights.end(), int64_t(0));\\n    return large - small;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Quickselect"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  long long putMarbles(vector<int>& weights, int k) {\\n    if (k <= 1) {\\n      return 0;\\n    }\\n    --k;\\n    for (int i = 1; i < weights.size(); ++i) {\\n      weights[i - 1] += weights[i];\\n    }\\n    weights.pop_back();\\n\\n    if (k * 2 > weights.size()) {\\n      k = weights.size() - k;\\n    }\\n    std::nth_element(weights.begin(), weights.begin() + k, weights.end());\\n    int64_t small = std::accumulate(weights.begin(), weights.begin() + k, int64_t(0));\\n    std::nth_element(weights.begin() + k, weights.end() - k, weights.end());\\n    int64_t large = std::accumulate(weights.end() - k, weights.end(), int64_t(0));\\n    return large - small;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112741,
                "title": "accepted-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<n-1;i++)\\n        nums[i]+=nums[i+1];\\n        nums.pop_back();\\n        sort(nums.begin(), nums.end());\\n        long long ans=0;\\n        for(int i=0;i<k-1;i++)\\n        ans+=nums[n-i-2]-nums[i];\\n        return ans;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        for(int i=0;i<n-1;i++)\\n        nums[i]+=nums[i+1];\\n        nums.pop_back();\\n        sort(nums.begin(), nums.end());\\n        long long ans=0;\\n        for(int i=0;i<k-1;i++)\\n        ans+=nums[n-i-2]-nums[i];\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112280,
                "title": "greedy-approach-with-heap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt the first glance, it seems to be a DP problem, because it asks for splitting the array into k consecutive subarrays, and both the max split sum and the min split sum can be computed by solving the subproblems. Let\\'s take the max split sum as an example, let max_sum[k][i] be the max sum when there are k splits among weights[0:i + 1], and max_sum[k][i] = max(max_sum[k][i - 1], max_sum[k - 1][i - 1] + weights[i] + weights[i + 1]). This approach runs O(k * n) time and unfortunatelly got TLE. >_<\\n\\nSince dynamic programming doesn\\'t work, maybe greedy algorithm works. Let\\'s consider weights[0], weights[1], ..., weights[i] split into k subsrrays, which indices are [0, s(0)], [s(0) + 1, s(1)], ..., [s(k-2), i], then the sum = sum(weights[s(j)] + weights[s(j) + 1]) + weights[0] + weights[i], for 0 <= j <= k - 2. This means we can greedy select the k-1 largest or smallest s(j) and s(j) + 1 pairs among all the possible splits. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIterate all the pairs of i and i + 1, compute their sum v = weights[i] + weights[i + 1] for selection. Since we only need k - 1 largest or smallest sums of pairs, heap would be nice to maintain such information. Here a max heap and a min heap are used to store the top k - 1 smallest/largest sums. If the size of a heap is more than k - 1, a pop operation is performed.\\n\\nReturn the difference of the sum of the two heaps. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThere are n iterations, and in each iteration, there are 2 heap push and 0 or 2 heap pop operations on two heaps of size k - 1, with O(log(k)) time, so the running time is O(nlog(k)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nEach heap has at most k - 1 items, so the space complexity is O(k).\\n\\n# Code\\n```\\nimport heapq\\n\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        max_heap, min_heap = [], []\\n        for i in range(len(weights) - 1):\\n            v = weights[i] + weights[i + 1]\\n            heapq.heappush(min_heap, v)\\n            heapq.heappush(max_heap, -v)\\n            if len(min_heap) > k - 1:\\n                heapq.heappop(min_heap)\\n                heapq.heappop(max_heap)\\n        return sum(min_heap) + sum(max_heap)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        max_heap, min_heap = [], []\\n        for i in range(len(weights) - 1):\\n            v = weights[i] + weights[i + 1]\\n            heapq.heappush(min_heap, v)\\n            heapq.heappush(max_heap, -v)\\n            if len(min_heap) > k - 1:\\n                heapq.heappop(min_heap)\\n                heapq.heappop(max_heap)\\n        return sum(min_heap) + sum(max_heap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734202,
                "title": "quick-and-easy-js-solution",
                "content": "# Intuition\\n\\nIn general, we want to make cuts in the line of marbles in such a way, that elements \"inside\"\\xA0 the bag (between the cut\\'s border) are either maximum or minimum weight. So if we make a cut between elements with weights $$2$$ and $$3$$ cost of this cut will be $$5$$. Note that $$k - 1$$ cuts create $$k$$ bags. Let\\'s compare all cut costs, and choose $$k - 1$$ highest for the maximization task and\\xA0$$k - 1$$ lowest for the minimization task.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(n)$$ for storing costs of cuts\\n\\n# Code\\n```\\n/**\\n * @param {number[]} weights\\n * @param {number} k\\n * @return {number}\\n */\\nvar putMarbles = function(weights, k) {\\n    const costs = []\\n    // Creating all cuts costs array\\n    for (let i = 0; i < weights.length - 1; i++) {\\n        costs.push(weights[i] + weights[i+1])\\n    }\\n    // We sort costs, since we need k lowest and k highest\\n    costs.sort((a, b) => a - b)\\n\\n    let result = 0\\n    // We need only difference, so no need to slice array\\n    // We running it once, and adding difference to result\\n    for (let i = 0; i < k - 1; i++) {\\n        result += costs[costs.length - 1 - i] - costs[i]\\n    }\\n\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} weights\\n * @param {number} k\\n * @return {number}\\n */\\nvar putMarbles = function(weights, k) {\\n    const costs = []\\n    // Creating all cuts costs array\\n    for (let i = 0; i < weights.length - 1; i++) {\\n        costs.push(weights[i] + weights[i+1])\\n    }\\n    // We sort costs, since we need k lowest and k highest\\n    costs.sort((a, b) => a - b)\\n\\n    let result = 0\\n    // We need only difference, so no need to slice array\\n    // We running it once, and adding difference to result\\n    for (let i = 0; i < k - 1; i++) {\\n        result += costs[costs.length - 1 - i] - costs[i]\\n    }\\n\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3608799,
                "title": "max-min-heap-based-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& v, int k) {\\n        priority_queue<int> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n        for(int i = 0; i < v.size()-1; i++){\\n            pq1.push(v[i]+v[i+1]);\\n            pq2.push(v[i]+v[i+1]);\\n            if(pq1.size()>k-1){\\n                pq1.pop();\\n                pq2.pop();\\n            }\\n        }\\n        long long int ans1 = 0, ans2 = 0;\\n        while(!pq1.empty()){\\n            ans1 += pq1.top();\\n            ans2 += pq2.top();\\n            pq1.pop();pq2.pop();\\n        }\\n        return ans2-ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& v, int k) {\\n        priority_queue<int> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n        for(int i = 0; i < v.size()-1; i++){\\n            pq1.push(v[i]+v[i+1]);\\n            pq2.push(v[i]+v[i+1]);\\n            if(pq1.size()>k-1){\\n                pq1.pop();\\n                pq2.pop();\\n            }\\n        }\\n        long long int ans1 = 0, ans2 = 0;\\n        while(!pq1.empty()){\\n            ans1 += pq1.top();\\n            ans2 += pq2.top();\\n            pq1.pop();pq2.pop();\\n        }\\n        return ans2-ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737218,
                "title": "easy-c-fully-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSuppose array is [a,b,c,d,e,f,g,h]\\n\\n- Lets think what happen if k = 1 our maximum is a + h, because all marble need to put up in same bag. (Easy)\\n\\n- Lets think what happen if k = 2 our maximum still consist of a + two extra variable + h what are those two extra variable, we don\\'t know these two extra variable but yes these two must be adjacent (Important) For now let\\'s say these two extra variable is c and d so our answer is now a + (c + d) + h and two bag consist of marble a,b,c and d, e, f, g, h\\n\\n- Lets think what happen if k = 3 our maximum still consist of a + (c + d) + two extra variable + h, what are those two extra variable, we don\\'t know these two extra variable but yes these two must be adjacent (Important) For now let\\'s say these two extra variable is g and h so our answer is now a + (c + d) + (g + h) + h and our bag consist of marbles a,b,c and d, e, f, g and h for 3 bags respectively and same goes for k = 4 , 5 , 6 .......\\n\\n- For maximum (c+d) > (g+h) and so on....\\n- For minimum (c+d) < (g+h) and so on....\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We\\'ll find the possible adjacent sums in a vector or in priority-queue.\\n- If vector then sort it in decreasing order.\\n- Then loop upto k and find the maximum_possible_adjSum and minimum_possible_adjSum.\\n- At last return the difference of them.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        int n = w.size();\\n        long long mx = w[0] + w[n-1]; // maximum val\\n        long long mn= w[0] + w[n-1]; // min val\\n\\n        // we\\'ll be storing the adjacent sums in priority queue\\n        vector<long long> adjSum; \\n\\n        for(int i=0; i<n-1; i++){\\n            adjSum.push_back(w[i] + w[i+1]);\\n        }\\n\\n        sort(adjSum.begin(), adjSum.end(), greater<int>()); // sorting in decending order\\n\\n        for(int i=0; i<k-1; i++){\\n            mx += (long long) adjSum[i];\\n            mn += (long long) adjSum[n-i-2];\\n        }\\n        return (mx-mn);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        int n = w.size();\\n        long long mx = w[0] + w[n-1]; // maximum val\\n        long long mn= w[0] + w[n-1]; // min val\\n\\n        // we\\'ll be storing the adjacent sums in priority queue\\n        vector<long long> adjSum; \\n\\n        for(int i=0; i<n-1; i++){\\n            adjSum.push_back(w[i] + w[i+1]);\\n        }\\n\\n        sort(adjSum.begin(), adjSum.end(), greater<int>()); // sorting in decending order\\n\\n        for(int i=0; i<k-1; i++){\\n            mx += (long long) adjSum[i];\\n            mn += (long long) adjSum[n-i-2];\\n        }\\n        return (mx-mn);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736807,
                "title": "c-easy-solution-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        int n = w.size();\\n        if(k == 1 || k == n)\\n        return 0;\\n        vector<int> temp;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            temp.push_back(w[i]+w[i+1]);\\n        }\\n        sort(temp.begin(),temp.end());\\n        long long mini=0, maxi=0;\\n        for(int i=0; i<k-1; i++)\\n        {\\n            mini+=temp[i];\\n            maxi+=temp[n-2-i];\\n        }\\n        long long ans=maxi-mini;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        int n = w.size();\\n        if(k == 1 || k == n)\\n        return 0;\\n        vector<int> temp;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            temp.push_back(w[i]+w[i+1]);\\n        }\\n        sort(temp.begin(),temp.end());\\n        long long mini=0, maxi=0;\\n        for(int i=0; i<k-1; i++)\\n        {\\n            mini+=temp[i];\\n            maxi+=temp[n-2-i];\\n        }\\n        long long ans=maxi-mini;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736685,
                "title": "java-full-intuition-building-beats-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe question is marked hard because many will not be able to get the intuition about the solution. If you see the first example,\\n`weights=[1,3,5,1];` we have to distribute the marbels such that we get max score and min score respectively. \\n> Now if we see score for any distribution say [1,3 ||  5,1], ($$||$$ signifies partition), we can find the score as, (1+3)+(5+1)=10.\\n\\n> Lets take some other distribution, say [1,3,5 || 1], we see the score is given by, (1+5)+(1+1)=8.\\n\\nNow, if you notice `first element` and `last element` will always be present, but one thing which is worth noticing is that `the element at end of a partition and the start of another partition,` is always present in the score, which means consecutive elements which are present left and right at the partition wall are always present in the score. eg:-(3,5) in first example and (5,1) in second example.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow to execute our intuition we would first take an array `pairs` and \\nfind the sum of every consecutive pairs,and `sort` it. \\n> The first k-1 elements of the sorted array will correspond to the minimum score and last k-1 elments of the sum will correspond to the maximum score.k-1 due to the fact that the no of partition pairs will be one less than k(try counting).\\nTo find all pair sum:-\\n```\\nint pairs[]= new int[weights.length-1];\\n        int index=0;\\n        for(int i=0,j=1;i<weights.length-1;i++,j++){\\n            pairs[index]=weights[i]+weights[j];\\n            index+=1;}\\n```\\nTo find maximum and minimum score:-\\n```\\nlong min=0,max=0;\\n        for(int i=0,j=pairs.length-1;i<k-1;i++,j--){\\n            min+=pairs[i];\\n            max+=pairs[j];\\n        }\\n```\\n# Complexity\\n- Time complexity:    O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:    O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nPlease `Like` if you liked the explanation!!\\n\\n# Code\\n```java []\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        if(k==weights.length){\\n            return 0;\\n        }\\n        int pairs[]= new int[weights.length-1];\\n        int index=0;\\n        for(int i=0,j=1;i<weights.length-1;i++,j++){\\n            pairs[index]=weights[i]+weights[j];\\n            index+=1;}\\n        Arrays.sort(pairs);\\n        long min=0,max=0;\\n        for(int i=0,j=pairs.length-1;i<k-1;i++,j--){\\n            min+=pairs[i];\\n            max+=pairs[j];\\n        }\\n        return max-min;\\n        \\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nint pairs[]= new int[weights.length-1];\\n        int index=0;\\n        for(int i=0,j=1;i<weights.length-1;i++,j++){\\n            pairs[index]=weights[i]+weights[j];\\n            index+=1;}\\n```\n```\\nlong min=0,max=0;\\n        for(int i=0,j=pairs.length-1;i<k-1;i++,j--){\\n            min+=pairs[i];\\n            max+=pairs[j];\\n        }\\n```\n```java []\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        if(k==weights.length){\\n            return 0;\\n        }\\n        int pairs[]= new int[weights.length-1];\\n        int index=0;\\n        for(int i=0,j=1;i<weights.length-1;i++,j++){\\n            pairs[index]=weights[i]+weights[j];\\n            index+=1;}\\n        Arrays.sort(pairs);\\n        long min=0,max=0;\\n        for(int i=0,j=pairs.length-1;i<k-1;i++,j--){\\n            min+=pairs[i];\\n            max+=pairs[j];\\n        }\\n        return max-min;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736238,
                "title": "priority-queue-based-solution",
                "content": "# Intuition\\nYou have to partition the array into k segments. First and last element will always included for both minimum and maximum answer hence it will contribute 0 to the required answer.\\n\\nNow, We just have to put k-1 walls on the array. Each wall will contribute $$weights[i]-weights[i-1]$$ to the max and min answer.\\nNow, we just have to select k-1 from them. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing max heap and min heap we take out k-1 ,maximum and minimum contributing answers and subtract them to get the required answer.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long ans=0;\\n        int n=weights.size();\\n        priority_queue<long long> maxpq;\\n        priority_queue<long long,vector<long long>,greater<long long>> minpq;\\n\\n        for(int i=1;i<n;i++){\\n            maxpq.push(weights[i]+weights[i-1]);\\n            minpq.push(weights[i]+weights[i-1]);\\n        }\\n        while(--k){\\n            ans+=maxpq.top()-minpq.top();\\n            maxpq.pop();\\n            minpq.pop();\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long ans=0;\\n        int n=weights.size();\\n        priority_queue<long long> maxpq;\\n        priority_queue<long long,vector<long long>,greater<long long>> minpq;\\n\\n        for(int i=1;i<n;i++){\\n            maxpq.push(weights[i]+weights[i-1]);\\n            minpq.push(weights[i]+weights[i-1]);\\n        }\\n        while(--k){\\n            ans+=maxpq.top()-minpq.top();\\n            maxpq.pop();\\n            minpq.pop();\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735599,
                "title": "bestest-explanation-you-have-ever-encountered",
                "content": "Let\\'s do a brute force simulation.  ``` arr= [1,4,2,5,2]   k= 3 ```\\nThere are 4 possible partition positions. Lets name them \\'a\\', \\'b\\', \\'c\\', \\'d\\'.\\n```\\n1 | 4 | 2 | 5 | 2\\n  a   b   c   d\\n```\\nAmong these 4 position we need to choose any 2 position (as k=3)\\n* Let suppose among all possibilities we choose position \\'a\\' and \\'c\\'. That is ``` 1 | 4 2 | 5 2 ```. The cost for this arrangement : (1+4) + (2+5) = 12.\\n* Choosing spot \\'a\\' add cost (1+4) to totalCost. Similaly choosing spot \\'c\\' add cost (2+5) to totalCost. \\n* That means each partition spot has a cost associated with it which will add to our totalCost. [for eg. Cost of choosing \\'a\\' is sum of element on either side of \\'a\\', i.e (1+4)]\\n```\\narr:                     [ 1 | 4 | 2 | 5 | 2 ]\\npartition spot:              a   b   c   d\\npartition cost:              5   6   7   7\\n```\\n* So minimum total score can be achieved by choosing 2 partition spots which has lowest cost : i.e choosing spot \\'a\\' and \\'b\\', incurring cost ```5+6= 11```. \\n The arrangement is ``` [ 1 | 4 | 2 5 2 ] ```.\\n* Similarly, maximum total score can be achieved by choosing 2 partition spots which has highest cost : i.e choosing spot \\'c\\' and \\'d\\', incurring cost ```7+7= 14```. \\nThe arrangement is ``` [ 1 4  2 | 5 | 2 ] ```.\\n* Answer for this case is : 14-11 = 3.\\n\\n**Implementation:**\\n* Store all the partition cost (basically sum of adjecent elements) [here costs are : 5, 6, 7, 7]\\n* Pick the smallest k-1 costs and add them [minimum score, say mini]\\n* Pick the largest k-1 costs and add them [maximum score, say maxi]\\n* return maxi-mini;\\n\\n**CODE:**\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& wt, int k) {\\n        int n= wt.size();\\n        priority_queue<int, vector<int>> maxPQ;\\n        priority_queue<int, vector<int>, greater<int>> minPQ;\\n        \\n        for(int i=0; i<n-1; i++){\\n            maxPQ.push(wt[i]+wt[i+1]); // adding each costs to max heap\\n            minPQ.push(wt[i]+wt[i+1]); // adding each costs to min heap\\n        }\\n        \\n        long long maxi=0; long long mini=0; k--;\\n        while(k--){\\n            maxi+=maxPQ.top(); maxPQ.pop();\\n            mini+=minPQ.top(); minPQ.pop();\\n        }\\n        return maxi-mini;\\n    }\\n};\\n```\\nTime Complexity: O(NlogN)\\nSpace Complexity: O(N) [can be optimised to O(K) too]\\n\\nThanks. If you liked it, please do upvote !",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "``` arr= [1,4,2,5,2]   k= 3 ```\n```\\n1 | 4 | 2 | 5 | 2\\n  a   b   c   d\\n```\n``` 1 | 4 2 | 5 2 ```\n```\\narr:                     [ 1 | 4 | 2 | 5 | 2 ]\\npartition spot:              a   b   c   d\\npartition cost:              5   6   7   7\\n```\n```5+6= 11```\n``` [ 1 | 4 | 2 5 2 ] ```\n```7+7= 14```\n``` [ 1 4  2 | 5 | 2 ] ```\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& wt, int k) {\\n        int n= wt.size();\\n        priority_queue<int, vector<int>> maxPQ;\\n        priority_queue<int, vector<int>, greater<int>> minPQ;\\n        \\n        for(int i=0; i<n-1; i++){\\n            maxPQ.push(wt[i]+wt[i+1]); // adding each costs to max heap\\n            minPQ.push(wt[i]+wt[i+1]); // adding each costs to min heap\\n        }\\n        \\n        long long maxi=0; long long mini=0; k--;\\n        while(k--){\\n            maxi+=maxPQ.top(); maxPQ.pop();\\n            mini+=minPQ.top(); minPQ.pop();\\n        }\\n        return maxi-mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735366,
                "title": "marble-distribution-minimizing-the-difference-between-maximum-and-minimum-scores",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can observe that the bags can be formed by dividing the marbles into groups such that each group contains adjacent marbles. The goal is to distribute the marbles into bags in a way that minimizes the difference between the maximum and minimum scores.\\n\\nWe can start by considering all possible distributions of marbles into bags. To minimize the difference, we want to evenly distribute the marbles among the bags while considering the costs of each bag. If we sort the marble weights in ascending order, we can start by assigning the smallest weights to different bags. Then, we gradually assign larger weights to the remaining bags. This approach ensures that the difference between the maximum and minimum scores is minimized.\\n# Approach\\n    1. Sort the marble weights in ascending order.\\n\\n    2. Create two variables to keep track of the minimum and maximum scores: minScore and maxScore. Initialize both variables to 0.\\n\\n    3. Iterate over the marble weights from index 1 to n-1, where n is the length of the weights array. Calculate the cost of each bag as the sum of the current weight and the previous weight.\\n\\n    4. Update the minScore by adding the costs of the first k-1 bags and the maxScore by adding the costs of the last k-1 bags.\\n\\n    5. Return the difference between maxScore and minScore.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n log n), where n is the number of marbles. The sorting operation takes O(n log n) time, and the iteration over the marble weights takes O(n) time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity: O(n), where n is the number of marbles. We need additional space to store the sorted marble weights.\\n# Code\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        \\n        // Calculate the sums of pairs of adjacent marbles\\n        int[] pairs = new int[n - 1];\\n        for (int i = 1; i < n; i++) {\\n            pairs[i - 1] = weights[i] + weights[i - 1];\\n        }\\n        \\n        // Sort the pairs in ascending order\\n        Arrays.sort(pairs);\\n        \\n        long minScore = 0;\\n        long maxScore = 0;\\n        \\n        // Calculate the minimum and maximum scores\\n        for (int i = 0; i < k - 1; i++) {\\n            minScore += pairs[i];  // Add the smallest pairs to the minimum score\\n            maxScore += pairs[n - i - 2];  // Add the largest pairs to the maximum score\\n        }\\n        \\n        return maxScore - minScore;  // Return the difference between the maximum and minimum scores\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        \\n        // Calculate the sums of pairs of adjacent marbles\\n        int[] pairs = new int[n - 1];\\n        for (int i = 1; i < n; i++) {\\n            pairs[i - 1] = weights[i] + weights[i - 1];\\n        }\\n        \\n        // Sort the pairs in ascending order\\n        Arrays.sort(pairs);\\n        \\n        long minScore = 0;\\n        long maxScore = 0;\\n        \\n        // Calculate the minimum and maximum scores\\n        for (int i = 0; i < k - 1; i++) {\\n            minScore += pairs[i];  // Add the smallest pairs to the minimum score\\n            maxScore += pairs[n - i - 2];  // Add the largest pairs to the maximum score\\n        }\\n        \\n        return maxScore - minScore;  // Return the difference between the maximum and minimum scores\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735012,
                "title": "c-well-explained-solution-o-nlogn",
                "content": "At first look it looks like a dp problem but looking at the contrains we can rule out dp. Now it is very hard to guess if you are seeing this problem for the first time but the devil lies in the details and here it is in the dividing of array. Take some examples and dry to get a better understanding.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        //Approach\\n        //On observation we find that first and last indices will always be included irrespective of how we divide the marbles and their difference will always be 0\\n        //Now we need to put k-1 dividers in n-1 gaps present\\n        //we observe that if we put the divider at the ith gap numbers i and i+1 will get included in the sum as they are now the corners of their group\\n        //using this fact we can see that we only need to count the maximum and minimum of those dividers\\n        //Now let\\'s see the code\\n        --k;//as we need to make k-1 cuts in the array\\n        int n = weights.size();\\n        for(int i=0;i<n-1;i++){\\n            weights[i] += weights[i+1];//update the array to contain the value if we place a divider here\\n        }\\n        weights.pop_back();//as the divider can\\'t be placed after last element\\n        \\n        //now the task is simple to find the top/bottom k-1 (here k as already reduced k) elements and get their difference\\n        //that can be done either by sorting or by using pq\\n        //here i have used pq\\n        \\n        \\n        priority_queue<int> pq1;//max_heap(this will contain k smallest elements at the end)\\n        priority_queue<int,vector<int>,greater<int>> pq2;//min_heap(this will contain k largest elements at the end)\\n        for(auto x:weights){\\n            pq1.push(x);\\n            pq2.push(x);\\n            if(pq1.size()>k)\\n                pq1.pop();//pop the largest element if size becomes > k\\n            if(pq2.size()>k)\\n                pq2.pop();//pop the smallest element if size becomes > k\\n        }\\n        long long maxi=0,mini=0;\\n        for(int i=0;i<k;i++){\\n            maxi += 1L*pq2.top();pq2.pop();\\n            mini += 1L*pq1.top();pq1.pop();\\n        }\\n        return maxi-mini;\\n    }\\n};```\\n\\nPlease upvote if it helped you understand the concept.",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        //Approach\\n        //On observation we find that first and last indices will always be included irrespective of how we divide the marbles and their difference will always be 0\\n        //Now we need to put k-1 dividers in n-1 gaps present\\n        //we observe that if we put the divider at the ith gap numbers i and i+1 will get included in the sum as they are now the corners of their group\\n        //using this fact we can see that we only need to count the maximum and minimum of those dividers\\n        //Now let\\'s see the code\\n        --k;//as we need to make k-1 cuts in the array\\n        int n = weights.size();\\n        for(int i=0;i<n-1;i++){\\n            weights[i] += weights[i+1];//update the array to contain the value if we place a divider here\\n        }\\n        weights.pop_back();//as the divider can\\'t be placed after last element\\n        \\n        //now the task is simple to find the top/bottom k-1 (here k as already reduced k) elements and get their difference\\n        //that can be done either by sorting or by using pq\\n        //here i have used pq\\n        \\n        \\n        priority_queue<int> pq1;//max_heap(this will contain k smallest elements at the end)\\n        priority_queue<int,vector<int>,greater<int>> pq2;//min_heap(this will contain k largest elements at the end)\\n        for(auto x:weights){\\n            pq1.push(x);\\n            pq2.push(x);\\n            if(pq1.size()>k)\\n                pq1.pop();//pop the largest element if size becomes > k\\n            if(pq2.size()>k)\\n                pq2.pop();//pop the smallest element if size becomes > k\\n        }\\n        long long maxi=0,mini=0;\\n        for(int i=0;i<k;i++){\\n            maxi += 1L*pq2.top();pq2.pop();\\n            mini += 1L*pq1.top();pq1.pop();\\n        }\\n        return maxi-mini;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3734700,
                "title": "110-understandable-o-n-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe have to divide the array into `k` subarray . it means we have to put `(k-1)` bars in array.\\n`w[0]` and `w[n-1]` element will always add to the subarray sum and at last we have to take `difference` so these elments will cancel out from each other.\\nwhenever a bar is putting between `i` and `i-1` , it is adding the value of `w[i]` and `w[i-1]` in our sum (sum is considered here the total sum after putting the bar).\\n\\n---\\n\\n\\nlet illustrate it by an example:\\nwe have an array $${1,3,5,1}$$ and\\n$$ k=2;$$\\n\\nso i can put barr (k-1) :\\n between 1,3 then `[1],[3,5,1] `sum =(1+1) + (3+1) ==6  (here can see i put bar between 1 and 3 ,sum is increase by 1 and 3)\\nbetween 3,5 then `[1,3],[5,1]` sum=(1+3) + (5+1) ==10 (again can see i put bar between 3 and 5 ,sum is increase by 3 and 5)\\nbetween 5,1 then `[1,3,5],[1]` sum=(1+5) + (1+1) ==8 (same, i put bar between 5 and 1 ,sum is increase by 5 and 1)\\ndifference between maximum and minimum is : 10-6 ==4\\n\\n# Approach\\nfor take the simply sort . \\n(see the code for better understanding)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n\\n    \\n  \\n    long long putMarbles(vector<int>& w, int k) {\\n        \\n        int n=w.size();\\n        \\n        long long mx=w[0]+w[n-1]; // i have taken here for better understanding (as they will always add ) otherwise you can take 0 too\\n        long long mn=w[0]+w[n-1]; \\n        \\n        vector<int> consum; //store the consecutive sum of i and i-1\\n        for(int i=1;i<n;i++)\\n        {\\n            consum.push_back(w[i]+w[i-1]);\\n        }\\n        \\n        sort(consum.begin(),consum.end());\\n        int l=consum.size();\\n        \\n        for(int i=0;i<k-1;i++)\\n        {\\n             mx+=consum[l-1-i]; //as maximum sum near the last indexes \\n             mn+=consum[i]; // minimum sum near the first indexes \\n        }\\n        \\n        return (mx-mn);\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n\\n    \\n  \\n    long long putMarbles(vector<int>& w, int k) {\\n        \\n        int n=w.size();\\n        \\n        long long mx=w[0]+w[n-1]; // i have taken here for better understanding (as they will always add ) otherwise you can take 0 too\\n        long long mn=w[0]+w[n-1]; \\n        \\n        vector<int> consum; //store the consecutive sum of i and i-1\\n        for(int i=1;i<n;i++)\\n        {\\n            consum.push_back(w[i]+w[i-1]);\\n        }\\n        \\n        sort(consum.begin(),consum.end());\\n        int l=consum.size();\\n        \\n        for(int i=0;i<k-1;i++)\\n        {\\n             mx+=consum[l-1-i]; //as maximum sum near the last indexes \\n             mn+=consum[i]; // minimum sum near the first indexes \\n        }\\n        \\n        return (mx-mn);\\n        \\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3734549,
                "title": "c-solution-for-put-marbles-in-bags-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to maximize and minimize the scores by distributing the marbles in the bags based on certain rules. The goal is to find the difference between the maximum and minimum scores.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Calculate the weight of each pair of marbles and store them in the pairWeights array.\\n- Sort the pairWeights array in non-decreasing order.\\n- Calculate the maximum score by adding the weights of the first and last marble and the sum of the k - 1 largest pair weights.\\n- Calculate the minimum score by adding the weights of the first and last marble and the sum of the k - 1 smallest pair weights.\\n- Return the difference between the maximum and minimum scores as the answer.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is determined by the sorting step, which takes O((n-1)log(n-1)) time, where n is the length of the weights array. The rest of the operations, such as calculating the scores, take O(1) time. Therefore, the overall time complexity is O(nlogn).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is O(n) since we create an additional array pairWeights of size n-1 to store the weights of each pair of marbles.\\n\\n# Code\\n```\\npublic class Solution {\\n    public long PutMarbles(int[] weights, int k) {\\n         int n = weights.Length;\\n    int[] pairWeights = new int[n - 1];\\n\\n    for (int i = 1; i < n; i++)\\n        pairWeights[i - 1] = weights[i] + weights[i - 1];\\n\\n    Array.Sort(pairWeights);\\n\\n    long maxScore = weights[0] + weights[n - 1];\\n    long minScore = weights[0] + weights[n - 1];\\n\\n    for (int i = n - k; i < n - 1; i++)\\n        maxScore += pairWeights[i];\\n\\n    for (int i = 0; i < k - 1; i++)\\n        minScore += pairWeights[i];\\n\\n    return maxScore - minScore;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public long PutMarbles(int[] weights, int k) {\\n         int n = weights.Length;\\n    int[] pairWeights = new int[n - 1];\\n\\n    for (int i = 1; i < n; i++)\\n        pairWeights[i - 1] = weights[i] + weights[i - 1];\\n\\n    Array.Sort(pairWeights);\\n\\n    long maxScore = weights[0] + weights[n - 1];\\n    long minScore = weights[0] + weights[n - 1];\\n\\n    for (int i = n - k; i < n - 1; i++)\\n        maxScore += pairWeights[i];\\n\\n    for (int i = 0; i < k - 1; i++)\\n        minScore += pairWeights[i];\\n\\n    return maxScore - minScore;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112124,
                "title": "easy-c-sort-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst and last one is always considered in final answer. At all the points of partition, we are considering two consecutive elements(marbles).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo divide the array into k subarrays, we need k-1 partitions. Thus we will traverse the array and put sum of consecutive elements in another array. Then sort it. We will take sum of first k-1 elements of new array to get minimum score possible and similarly the last k-1 elements to get the maximum sum possible.\\nWe can also use the priority_queue() to reduce the time complexity.\\n# Complexity\\n- Time complexity: $$O(n*log(n))$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        ll n=weights.size(), mn=0, mx=0;\\n        if(k==1 || k==n){return 0;}\\n        vector<ll> v;\\n        for(ll i=0; i<n-1; i++){\\n            v.push_back(weights[i]+weights[i+1]);\\n        }\\n        sort(v.begin(), v.end());\\n        for(ll i=0; i<k-1; i++){\\n            mn += v[i];\\n            mx += v[v.size()-i-1];\\n        }\\n        return mx - mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Sliding Window",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        ll n=weights.size(), mn=0, mx=0;\\n        if(k==1 || k==n){return 0;}\\n        vector<ll> v;\\n        for(ll i=0; i<n-1; i++){\\n            v.push_back(weights[i]+weights[i+1]);\\n        }\\n        sort(v.begin(), v.end());\\n        for(ll i=0; i<k-1; i++){\\n            mn += v[i];\\n            mx += v[v.size()-i-1];\\n        }\\n        return mx - mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735805,
                "title": "simple-logic-o-n-k-log-k-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        priority_queue<long long int,vector<long long int>,greater<long long int>>min_h;\\n        priority_queue<long long int>max_h;\\n        int mn=0,n=weights.size();\\n        for(int i=0;i<n-1;i++){\\n            long long int x=weights[i]+weights[i+1];\\n            min_h.push(x);\\n            max_h.push(x);\\n            if(min_h.size()>=k)min_h.pop();\\n            if(max_h.size()>=k)max_h.pop();\\n        }\\n        long long int res=0;\\n        while(!min_h.empty()){\\n            res+=min_h.top();\\n            min_h.pop();\\n        }\\n        while(!max_h.empty()){\\n            res-=max_h.top();\\n            max_h.pop();\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n\\nTime Complexity = O(n*k*log(k)) \\nSpace Complexity = O(k+k) ~ O(k)",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        priority_queue<long long int,vector<long long int>,greater<long long int>>min_h;\\n        priority_queue<long long int>max_h;\\n        int mn=0,n=weights.size();\\n        for(int i=0;i<n-1;i++){\\n            long long int x=weights[i]+weights[i+1];\\n            min_h.push(x);\\n            max_h.push(x);\\n            if(min_h.size()>=k)min_h.pop();\\n            if(max_h.size()>=k)max_h.pop();\\n        }\\n        long long int res=0;\\n        while(!min_h.empty()){\\n            res+=min_h.top();\\n            min_h.pop();\\n        }\\n        while(!max_h.empty()){\\n            res-=max_h.top();\\n            max_h.pop();\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735705,
                "title": "point-the-wrong-in-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long solve1(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[index]+wt[wt.size()-1];\\n        }\\n\\n        long long maxi_ans=INT_MIN;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans += (wt[s]+wt[i]) + solve1(i+1,i+1,k,cnt+1,wt);\\n            maxi_ans=max(maxi_ans,ans);\\n        }\\n\\n        return maxi_ans;\\n    }\\n\\n     long long solve2(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[s]+wt[wt.size()-1];\\n        }\\n\\n        long long mini_ans=INT_MAX;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans+= (wt[s]+wt[i]) + solve2(s+1,i+1,k,cnt+1,wt);\\n            mini_ans=min(mini_ans,ans);\\n        }\\n\\n        return mini_ans;\\n    }\\n    \\n    long long putMarbles(vector<int>& weights, int k) {\\n        k=k-1;\\n        long long maxiAns = solve1(0,0,k,0,weights);\\n        long long miniAns = solve2(0,0,k,0,weights);\\n\\n        //cout<<maxiAns<<\\' \\'<<miniAns;\\n        return miniAns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long solve1(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[index]+wt[wt.size()-1];\\n        }\\n\\n        long long maxi_ans=INT_MIN;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans += (wt[s]+wt[i]) + solve1(i+1,i+1,k,cnt+1,wt);\\n            maxi_ans=max(maxi_ans,ans);\\n        }\\n\\n        return maxi_ans;\\n    }\\n\\n     long long solve2(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[s]+wt[wt.size()-1];\\n        }\\n\\n        long long mini_ans=INT_MAX;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans+= (wt[s]+wt[i]) + solve2(s+1,i+1,k,cnt+1,wt);\\n            mini_ans=min(mini_ans,ans);\\n        }\\n\\n        return mini_ans;\\n    }\\n    \\n    long long putMarbles(vector<int>& weights, int k) {\\n        k=k-1;\\n        long long maxiAns = solve1(0,0,k,0,weights);\\n        long long miniAns = solve2(0,0,k,0,weights);\\n\\n        //cout<<maxiAns<<\\' \\'<<miniAns;\\n        return miniAns;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3735299,
                "title": "ruby-petition-to-demote-to-easy",
                "content": "# Code\\n\\n```ruby\\ndef put_marbles(weights, k)\\n  a = weights.each_cons(2).map(&:sum).sort!\\n  a.last(k - 1).sum - a.first(k - 1).sum\\nend\\n```\\n\\n# Time complexity\\n\\n$$\\\\mathcal{O}(n \\\\log n)$$\\n\\n# Space complexity\\n\\n$$\\\\mathcal{O}(n)$$",
                "solutionTags": [
                    "Ruby",
                    "Array"
                ],
                "code": "```ruby\\ndef put_marbles(weights, k)\\n  a = weights.each_cons(2).map(&:sum).sort!\\n  a.last(k - 1).sum - a.first(k - 1).sum\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3735239,
                "title": "java-10-liner-easy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        if(k == n) return 0;\\n        int costs[] = new int[n - 1];\\n        for(int i = 0; i < n - 1; i ++) {\\n            costs[i] = weights[i] + weights[ i + 1];\\n        }\\n        Arrays.sort(costs);\\n        long min = 0, max = 0;\\n        for(int i = 0; i < k - 1; i ++) {\\n            min += costs[i];\\n            max += costs[n - i - 2];\\n        }\\n        return max - min;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        if(k == n) return 0;\\n        int costs[] = new int[n - 1];\\n        for(int i = 0; i < n - 1; i ++) {\\n            costs[i] = weights[i] + weights[ i + 1];\\n        }\\n        Arrays.sort(costs);\\n        long min = 0, max = 0;\\n        for(int i = 0; i < k - 1; i ++) {\\n            min += costs[i];\\n            max += costs[n - i - 2];\\n        }\\n        return max - min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734709,
                "title": "c-simple-sort-with-explanation",
                "content": "The approach is simple . Suppose you have k bags then we have to do k-1 partition in the array weights. suppose you have two bags then you have to do 1 partition . Notice the left most element and right most elemet always gets added to the score whether it be minimum or maximum. We just have to consider other partition.Suppose we make partion after i th index then weight[i] && weight[i+1] gets added to score to get max score we have to consider k-2 pairs having highest sum of weights[i] and weights[i+1].K-2 because we had taken first and last element already. For min k-2 pair consider k-2 lowest pair for that we use sort.\\n\\n**Please Upvote if it helped!**\\n\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n       \\n        long long ans;\\n        long long maxi=0;\\n        long long mini=0;\\n        int n= weights.size();\\n         if(k==0 || k==n) return 0;\\n        vector<int>sums;\\n        for(int i=0; i<n-1; i++){\\n            int curr= weights[i]+weights[i+1];\\n            sums.push_back(curr);\\n            \\n        }\\n        sort(sums.begin(),sums.end());\\n        for(int i=0 ; i<k-1; i++){\\n            mini+= sums[i];\\n            maxi+= sums[n-2-i];\\n        }\\n        return maxi-mini;\\n        \\n        \\n        \\n    }\\n};\\n",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n       \\n        long long ans;\\n        long long maxi=0;\\n        long long mini=0;\\n        int n= weights.size();\\n         if(k==0 || k==n) return 0;\\n        vector<int>sums;\\n        for(int i=0; i<n-1; i++){\\n            int curr= weights[i]+weights[i+1];\\n            sums.push_back(curr);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3734419,
                "title": "c-difference-between-back-sum-and-front-sum-till-k",
                "content": "# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#ifdef freakin23\\n#include \"library/debug.cpp\"\\n#else\\n#define debug(...)\\n#endif\\n\\n#define LL long long\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<LL> v;\\n        for (int i = 0; i < (int)weights.size() - 1; i++) {\\n            v.push_back(weights[i] + weights[i + 1]);\\n        }\\n        LL front = 0,back = 0;\\n        sort(v.begin(), v.end());\\n        for (int i = 0; i < k - 1; i++) {\\n            front += v[i];\\n        }\\n        reverse(v.begin(), v.end());\\n        for (int i = 0; i < k - 1; i++) {\\n            back += v[i];\\n        }\\n        return back - front;\\n    }\\n};\\n\\n#ifdef freakin23\\nint main(){\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}\\n#endif\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#ifdef freakin23\\n#include \"library/debug.cpp\"\\n#else\\n#define debug(...)\\n#endif\\n\\n#define LL long long\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<LL> v;\\n        for (int i = 0; i < (int)weights.size() - 1; i++) {\\n            v.push_back(weights[i] + weights[i + 1]);\\n        }\\n        LL front = 0,back = 0;\\n        sort(v.begin(), v.end());\\n        for (int i = 0; i < k - 1; i++) {\\n            front += v[i];\\n        }\\n        reverse(v.begin(), v.end());\\n        for (int i = 0; i < k - 1; i++) {\\n            back += v[i];\\n        }\\n        return back - front;\\n    }\\n};\\n\\n#ifdef freakin23\\nint main(){\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}\\n#endif\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3734418,
                "title": "c-difference-between-back-sum-and-front-sum-till-k",
                "content": "# Code\\n```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#ifdef freakin23\\n#include \"library/debug.cpp\"\\n#else\\n#define debug(...)\\n#endif\\n\\n#define LL long long\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<LL> v;\\n        for (int i = 0; i < (int)weights.size() - 1; i++) {\\n            v.push_back(weights[i] + weights[i + 1]);\\n        }\\n        LL front = 0,back = 0;\\n        sort(v.begin(), v.end());\\n        for (int i = 0; i < k - 1; i++) {\\n            front += v[i];\\n        }\\n        reverse(v.begin(), v.end());\\n        for (int i = 0; i < k - 1; i++) {\\n            back += v[i];\\n        }\\n        return back - front;\\n    }\\n};\\n\\n#ifdef freakin23\\nint main(){\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}\\n#endif\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\nusing namespace std;\\n\\n#ifdef freakin23\\n#include \"library/debug.cpp\"\\n#else\\n#define debug(...)\\n#endif\\n\\n#define LL long long\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<LL> v;\\n        for (int i = 0; i < (int)weights.size() - 1; i++) {\\n            v.push_back(weights[i] + weights[i + 1]);\\n        }\\n        LL front = 0,back = 0;\\n        sort(v.begin(), v.end());\\n        for (int i = 0; i < k - 1; i++) {\\n            front += v[i];\\n        }\\n        reverse(v.begin(), v.end());\\n        for (int i = 0; i < k - 1; i++) {\\n            back += v[i];\\n        }\\n        return back - front;\\n    }\\n};\\n\\n#ifdef freakin23\\nint main(){\\n    ios::sync_with_stdio(false);\\n    cin.tie(0);\\n    return 0;\\n}\\n#endif\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3734233,
                "title": "simple-c-code-with-intution",
                "content": "# Intuition\\n1.create a minheap and a max heap.\\n2.store the sum of consecutive elements.\\n3.if the size exceeds (k-1). then pop an item.\\n4.the sum of elements in both min and max heap are scores of two bags.\\n5.return difference between them.\\n# Approach\\nIf we pick an index i as starting point then (i-1) is the ending point. ans as we know both are included in the score.0th and (n-1)th are starting and ending points in every case. so while caluclating difference they are ignored.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogk)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        priority_queue<int> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n        for(int i=1;i<n;i++){\\n            pq1.push(weights[i-1]+weights[i]);\\n            pq2.push(weights[i-1]+weights[i]);\\n            if(pq1.size()>k-1)\\n            pq1.pop();\\n             if(pq2.size()>k-1)\\n            pq2.pop();\\n        }\\n        long long s1=0,s2=0;\\n        while(!pq1.empty()){\\n            s1+=pq1.top();\\n            s2+=pq2.top();\\n            pq1.pop();\\n            pq2.pop();\\n        }\\n        return abs(s1-s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        priority_queue<int> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n        for(int i=1;i<n;i++){\\n            pq1.push(weights[i-1]+weights[i]);\\n            pq2.push(weights[i-1]+weights[i]);\\n            if(pq1.size()>k-1)\\n            pq1.pop();\\n             if(pq2.size()>k-1)\\n            pq2.pop();\\n        }\\n        long long s1=0,s2=0;\\n        while(!pq1.empty()){\\n            s1+=pq1.top();\\n            s2+=pq2.top();\\n            pq1.pop();\\n            pq2.pop();\\n        }\\n        return abs(s1-s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734212,
                "title": "c-easy-sorting",
                "content": "\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        ll n=weights.size(), mn=0, mx=0;\\n        if(k==1 || k==n){return 0;}\\n        vector<ll> v;\\n        for(ll i=0; i<n-1; i++){\\n            v.push_back(weights[i]+weights[i+1]);\\n        }\\n        sort(v.begin(), v.end());\\n        for(ll i=0; i<k-1; i++){\\n            mn += v[i];\\n            mx += v[v.size()-i-1];\\n        }\\n        return mx - mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        ll n=weights.size(), mn=0, mx=0;\\n        if(k==1 || k==n){return 0;}\\n        vector<ll> v;\\n        for(ll i=0; i<n-1; i++){\\n            v.push_back(weights[i]+weights[i+1]);\\n        }\\n        sort(v.begin(), v.end());\\n        for(ll i=0; i<k-1; i++){\\n            mn += v[i];\\n            mx += v[v.size()-i-1];\\n        }\\n        return mx - mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734186,
                "title": "rust-28ms-3-5-mb",
                "content": "# Code\\n```rust\\nimpl Solution {\\n    pub fn put_marbles(weights: Vec<i32>, k: i32) -> i64 {\\n        let n = weights.len();\\n        let mut pair_weights: Vec<_> = (0..n - 1)\\n            .map(|i| weights[i] + weights[i + 1])\\n            .collect();\\n\\n        pair_weights.sort_unstable();\\n\\n        (0..(k - 1) as usize).fold(0i64, |ans, i| {\\n            ans + (pair_weights[n - 2 - i] - pair_weights[i]) as i64\\n        })\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn put_marbles(weights: Vec<i32>, k: i32) -> i64 {\\n        let n = weights.len();\\n        let mut pair_weights: Vec<_> = (0..n - 1)\\n            .map(|i| weights[i] + weights[i + 1])\\n            .collect();\\n\\n        pair_weights.sort_unstable();\\n\\n        (0..(k - 1) as usize).fold(0i64, |ans, i| {\\n            ans + (pair_weights[n - 2 - i] - pair_weights[i]) as i64\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432118,
                "title": "simple-sorting-c-code",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long n=weights.size();\\n        long long ans=weights[0]+weights[n-1];\\n        long long ans2=ans;\\n        vector<long long> cuts;\\n        for(long long i=0;i<n-1;i++){\\n            cuts.push_back(weights[i]+weights[i+1]);\\n        }\\n        sort(cuts.begin(),cuts.end(),greater<long long>());\\n        for(int i=0;i<k-1;i++){\\n             ans+=cuts[i];\\n             ans2+=cuts[cuts.size()-1-i];\\n        }\\n        return ans-ans2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long n=weights.size();\\n        long long ans=weights[0]+weights[n-1];\\n        long long ans2=ans;\\n        vector<long long> cuts;\\n        for(long long i=0;i<n-1;i++){\\n            cuts.push_back(weights[i]+weights[i+1]);\\n        }\\n        sort(cuts.begin(),cuts.end(),greater<long long>());\\n        for(int i=0;i<k-1;i++){\\n             ans+=cuts[i];\\n             ans2+=cuts[cuts.size()-1-i];\\n        }\\n        return ans-ans2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136287,
                "title": "optimal-marble-allocation-with-explanation",
                "content": "![WhatsApp Image 2023-02-03 at 18.50.30.jpg](https://assets.leetcode.com/users/images/71b8698f-2b45-4aac-b772-e2907cbadf58_1675430462.8482938.jpeg)\\n\\n```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n=weights.length-1;\\n        long arr[]=new long[n];\\n        for(int i=0;i<n;i++){\\n         arr[i]=weights[i]+weights[i+1];   \\n        }\\n        Arrays.sort(arr);\\n        long min=0,max=0;\\n        for(int i=0;i<k-1;i++){\\n            min+=arr[i];\\n            max+=arr[n-i-1];\\n        }\\n        return max-min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n=weights.length-1;\\n        long arr[]=new long[n];\\n        for(int i=0;i<n;i++){\\n         arr[i]=weights[i]+weights[i+1];   \\n        }\\n        Arrays.sort(arr);\\n        long min=0,max=0;\\n        for(int i=0;i<k-1;i++){\\n            min+=arr[i];\\n            max+=arr[n-i-1];\\n        }\\n        return max-min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128685,
                "title": "python-greedy-solution-solution-with-explanation-beats-95",
                "content": "# Intuition\\nSince the problem mentions minimum and maximum 1st approach is to use DP but it fails to pass the time complexity so our go to method is greedy (usually faster than DP)\\n\\nIf w1,w2,w3,w4,w5,w6,w7,w8 are the weights and we are required to split it in 3 bags,then following would be the solution.\\n\\nFor this problem one needs to convince himself/herself for couple of things:\\n\\n1) For k bags one need to make k-1 splits. For the given example 3 bags mean 2 splits.\\n\\n2) Assume (for the maximum case) we make the 1st split between w2 and w3, 2nd split between w5 and w6 then the answer would be\\n\\n\\n    Max:\\n    **w1**+w2 (bag 1) + w3+w5 (bag2) + w6+**w8** (bag3)\\n\\n    For the minimum case, we make 1st split between w3 and w4, 2nd split between w6 and w7\\n\\n    Min:\\n    **w1**+w3 (bag 1) + w4+w6 (bag 2) + w7+**w8** (bag3)\\n\\n\\n    Obserse, **w1 and w8 is present in both min and max case**. Therefore effectively what we need to calculate is:\\n\\n    For max case: w2+w3, w5+w6 \\n    For min case: w3+w4, w6+w7\\n\\n    Which means sum of two adjacent weights.\\n\\nIf you are convinced for above two things then reading the code makes it easier to follow.\\n\\nTry it with any dummy array and see if it makes sense.\\n\\n \\n\\n# Approach\\nCalculate all the adjacent weights and sort them.\\n\\nFor max case pick top k-1 adjacent weights and\\nFor min case pick lowest k-1 adjacet weights.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n\\n        if len(weights) == k or k == 1:\\n            return 0\\n\\n        wt_sum = [weights[i]+weights[i+1] for i in range(len(weights)-1)]\\n        wt_sum.sort()\\n\\n        return sum(wt_sum[-(k-1):]) - sum(wt_sum[:k-1])\\n\\n```\\n\\n\\n\\nPlease upvote \\u2B06\\uFE0F if you found this usefull and comment if you need any clarification/explanation \\uD83D\\uDCA1 for any part, I\\'m happy to help \\uD83D\\uDE07",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n\\n        if len(weights) == k or k == 1:\\n            return 0\\n\\n        wt_sum = [weights[i]+weights[i+1] for i in range(len(weights)-1)]\\n        wt_sum.sort()\\n\\n        return sum(wt_sum[-(k-1):]) - sum(wt_sum[:k-1])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114377,
                "title": "fastest-java-solution-using-sorting",
                "content": "# class Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        ArrayList<Integer> a=new ArrayList<>();\\n        for(int i=1;i<weights.length;i++)\\n        {\\n            a.add(weights[i]+weights[i-1]);\\n        }\\n        Collections.sort(a);\\n        long min=0,max=0;\\n        int x=a.size()-1;\\n        for(int i=1;i<k;i++)\\n        {\\n           min+=a.get(i-1);\\n           max+=a.get(x);\\n            x--;\\n        }\\n        return max-min;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        ArrayList<Integer> a=new ArrayList<>();\\n        for(int i=1;i<weights.length;i++)\\n        {\\n            a.add(weights[i]+weights[i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3114267,
                "title": "1d-dynamic-programing-tle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe DP formula and base case are as followings:\\n```\\n    dp[k][i] - min cost with i marbles being put to k bags\\n    dp[k][i] = min{ dp[k-1][j] + w[j] + w[i-1] } for all j < i \\n    dp[0][i] = 0    if i == 0\\n               inf  otherwise\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe need 2D data structure to store the memory, but since `dp[k]` only depends on `dp[k-1]`, we can try to use a 1D array instead.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(k.n^2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        n = len(weights)\\n        min_dp = [0] + [float(\\'inf\\')] * n\\n        max_dp = [0] + [-float(\\'inf\\')] * n\\n\\n        for b in range(1, k+1):\\n            min_dp_, max_dp_ = min_dp[:], max_dp[:]\\n            min_dp = [float(\\'inf\\')] * (n+1)\\n            for i in range(n+1):\\n                for j in range(i):\\n                    min_dp[i] = min(min_dp[i], min_dp_[j] + weights[j] + weights[i-1])\\n                    max_dp[i] = max(max_dp[i], max_dp_[j] + weights[j] + weights[i-1])\\n\\n        return max_dp[n] - min_dp[n]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n    dp[k][i] - min cost with i marbles being put to k bags\\n    dp[k][i] = min{ dp[k-1][j] + w[j] + w[i-1] } for all j < i \\n    dp[0][i] = 0    if i == 0\\n               inf  otherwise\\n```\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        n = len(weights)\\n        min_dp = [0] + [float(\\'inf\\')] * n\\n        max_dp = [0] + [-float(\\'inf\\')] * n\\n\\n        for b in range(1, k+1):\\n            min_dp_, max_dp_ = min_dp[:], max_dp[:]\\n            min_dp = [float(\\'inf\\')] * (n+1)\\n            for i in range(n+1):\\n                for j in range(i):\\n                    min_dp[i] = min(min_dp[i], min_dp_[j] + weights[j] + weights[i-1])\\n                    max_dp[i] = max(max_dp[i], max_dp_[j] + weights[j] + weights[i-1])\\n\\n        return max_dp[n] - min_dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113756,
                "title": "python3-golang-sorting-solution",
                "content": "We create a sorted list **pairs_sum** of adjacent marble weights. We need it to calculate two sums of pair scores: **min_scores** - the smallest possible scores (pairs_sum[:-k + 1]) and **max_scores** - the largest possble scores (pairs_sum[k - 1:]). Then we calculate the difference between these scores and return it as an answer.\\n\\n**Python3**:\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        if k == 1 or k == len(weights):\\n            return 0\\n        \\n        pairs_sum = sorted([weights[i] + weights[i + 1] for i in range(len(weights) - 1)])\\n        min_scores, max_scores = sum(pairs_sum[:-k + 1]), sum(pairs_sum[k - 1:])\\n                \\n        return max_scores - min_scores\\n```\\n\\n**Golang**:\\n```\\nfunc putMarbles(weights []int, k int) int64 {\\n    if k == 1 || k == len(weights) {\\n        return 0\\n    }\\n    min_scores, max_scores := 0, 0\\n    pairs_sum := make([]int, len(weights) - 1)\\n    \\n    for i := 0; i < len(weights) - 1; i++ {\\n        pairs_sum[i] = weights[i] + weights[i + 1]\\n    }\\n    sort.Ints(pairs_sum)\\n    for _, num := range pairs_sum[k - 1:] {\\n        max_scores += num\\n    }\\n    sort.Sort(sort.Reverse(sort.IntSlice(pairs_sum)))\\n    for _, num := range pairs_sum[k - 1:] {\\n        min_scores += num\\n    }\\n    return int64(max_scores - min_scores)\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        if k == 1 or k == len(weights):\\n            return 0\\n        \\n        pairs_sum = sorted([weights[i] + weights[i + 1] for i in range(len(weights) - 1)])\\n        min_scores, max_scores = sum(pairs_sum[:-k + 1]), sum(pairs_sum[k - 1:])\\n                \\n        return max_scores - min_scores\\n```\n```\\nfunc putMarbles(weights []int, k int) int64 {\\n    if k == 1 || k == len(weights) {\\n        return 0\\n    }\\n    min_scores, max_scores := 0, 0\\n    pairs_sum := make([]int, len(weights) - 1)\\n    \\n    for i := 0; i < len(weights) - 1; i++ {\\n        pairs_sum[i] = weights[i] + weights[i + 1]\\n    }\\n    sort.Ints(pairs_sum)\\n    for _, num := range pairs_sum[k - 1:] {\\n        max_scores += num\\n    }\\n    sort.Sort(sort.Reverse(sort.IntSlice(pairs_sum)))\\n    for _, num := range pairs_sum[k - 1:] {\\n        min_scores += num\\n    }\\n    return int64(max_scores - min_scores)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112032,
                "title": "simple-c-solution-using-priority-queue-o-klogn",
                "content": "![image](https://assets.leetcode.com/users/images/ad964a86-0b7f-4179-b686-33a1741f528e_1674969248.936288.jpeg)\\n\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n   \\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        vector<ll> v;\\n        for(int i=1;i<n;i++)\\n        {\\n            v.push_back((weights[i]+weights[i-1]));\\n        }\\n        priority_queue<ll> pq;\\n        priority_queue<ll,vector<ll>,greater<ll>> pq1;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            pq.push(v[i]);\\n            pq1.push(v[i]);\\n        }\\n        // we have to put k-1 bars to divide them into k subarray\\n        \\n        // starting and ending element included in both but we have to find difference so both are subtracted \\n        ll ans1=0,ans2=0;\\n        k--;\\n        while(k--)\\n        {\\n            ans1+=pq.top();\\n            ans2+=pq1.top();\\n            pq.pop();\\n            pq1.pop();\\n        }\\n        return ans1-ans2;\\n       \\n        \\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n   \\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        vector<ll> v;\\n        for(int i=1;i<n;i++)\\n        {\\n            v.push_back((weights[i]+weights[i-1]));\\n        }\\n        priority_queue<ll> pq;\\n        priority_queue<ll,vector<ll>,greater<ll>> pq1;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            pq.push(v[i]);\\n            pq1.push(v[i]);\\n        }\\n        // we have to put k-1 bars to divide them into k subarray\\n        \\n        // starting and ending element included in both but we have to find difference so both are subtracted \\n        ll ans1=0,ans2=0;\\n        k--;\\n        while(k--)\\n        {\\n            ans1+=pq.top();\\n            ans2+=pq1.top();\\n            pq.pop();\\n            pq1.pop();\\n        }\\n        return ans1-ans2;\\n       \\n        \\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111828,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        if k==1 or k==len(weights):\\n            return 0\\n\\n        m=sorted(weights[i]+weights[i+1] for i in range(len(weights)-1))\\n\\n        return sum(m[-k+1:])-sum(m[:k-1])        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        if k==1 or k==len(weights):\\n            return 0\\n\\n        m=sorted(weights[i]+weights[i+1] for i in range(len(weights)-1))\\n\\n        return sum(m[-k+1:])-sum(m[:k-1])        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111701,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        if k == 1 or k == len(weights):\\n            return 0\\n        ans = 0\\n        ans1 = 0\\n        k -= 1\\n        res1 = [weights[i] + weights[i+1] for i in range(len(weights) - 1)]\\n        res = [weights[i] + weights[i+1] for i in range(len(weights) - 1)]\\n        res1.sort(reverse=True)\\n        res.sort()\\n        for i in range(k):\\n            ans1 += res1[i]\\n        for i in range(k):\\n            ans += res[i]\\n        return (ans1 - ans)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        if k == 1 or k == len(weights):\\n            return 0\\n        ans = 0\\n        ans1 = 0\\n        k -= 1\\n        res1 = [weights[i] + weights[i+1] for i in range(len(weights) - 1)]\\n        res = [weights[i] + weights[i+1] for i in range(len(weights) - 1)]\\n        res1.sort(reverse=True)\\n        res.sort()\\n        for i in range(k):\\n            ans1 += res1[i]\\n        for i in range(k):\\n            ans += res[i]\\n        return (ans1 - ans)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111675,
                "title": "python-fast-o-nlogk-no-sort",
                "content": "# Intuition\\nGet the k-1 largest/smallest pair sum togther with the first and last numbert.\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n $$O(nlogk))$$\\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        n = len(weights)\\n        if n < k:\\n            return -1\\n        s = [weights[i] + weights[i+1] for i in range(n-1)]\\n        \\n        large = small = weights[0] + weights[-1]\\n\\n        large += sum(heapq.nlargest(k-1, s))\\n        small += sum(heapq.nsmallest(k-1, s))\\n        return large - small\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        n = len(weights)\\n        if n < k:\\n            return -1\\n        s = [weights[i] + weights[i+1] for i in range(n-1)]\\n        \\n        large = small = weights[0] + weights[-1]\\n\\n        large += sum(heapq.nlargest(k-1, s))\\n        small += sum(heapq.nsmallest(k-1, s))\\n        return large - small\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740647,
                "title": "easy-to-understand-5-lines-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k,long long a=0) {\\n        vector<int> vec;\\n        for(int i=1;i<weights.size();i++) vec.push_back(weights[i]+weights[i-1]);\\n        sort(vec.rbegin(),vec.rend());\\n        for(int i=0;i<k-1;i++) a+=(vec[i]-vec[vec.size()-i-1]);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k,long long a=0) {\\n        vector<int> vec;\\n        for(int i=1;i<weights.size();i++) vec.push_back(weights[i]+weights[i-1]);\\n        sort(vec.rbegin(),vec.rend());\\n        for(int i=0;i<k-1;i++) a+=(vec[i]-vec[vec.size()-i-1]);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738298,
                "title": "greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& a, int k) {\\n        \\n        int n = a.size();\\n        if(k==1 || n == k)\\n            return 0;\\n        \\n        vector<int> res;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            res.push_back(a[i]+a[i+1]);\\n        }\\n        \\n        sort(res.begin(),res.end());\\n        n = res.size();\\n        \\n        long long int mn=0,mx=0;\\n        for(int i =0;i<k-1;i++)\\n        {\\n            mn+=res[i];\\n        }\\n        \\n        for(int i =n-k+1;i<n;i++)\\n        {\\n            mx+=res[i];\\n        }\\n        \\n        return mx-mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& a, int k) {\\n        \\n        int n = a.size();\\n        if(k==1 || n == k)\\n            return 0;\\n        \\n        vector<int> res;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            res.push_back(a[i]+a[i+1]);\\n        }\\n        \\n        sort(res.begin(),res.end());\\n        n = res.size();\\n        \\n        long long int mn=0,mx=0;\\n        for(int i =0;i<k-1;i++)\\n        {\\n            mn+=res[i];\\n        }\\n        \\n        for(int i =n-k+1;i<n;i++)\\n        {\\n            mx+=res[i];\\n        }\\n        \\n        return mx-mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738189,
                "title": "python-1-liner-heap-priorityqueue-functional-programming",
                "content": "# Approach\\nTL;DR, Similar to [Editorial solution](https://leetcode.com/problems/put-marbles-in-bags/editorial/) but written functionally and using heaps instead of sorting.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def putMarbles(self, weights: list[int], k: int) -> int:\\n        return (lambda xs: sum(nlargest(k - 1, xs)) - sum(nsmallest(k - 1, xs)))(tuple(map(sum, pairwise(weights))))\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\nclass Solution:\\n    def putMarbles(self, weights: list[int], k: int) -> int:\\n        return (lambda xs: sum(nlargest(k - 1, xs)) - sum(nsmallest(k - 1, xs)))(tuple(map(sum, pairwise(weights))))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738127,
                "title": "simple-solution-fully-explained-o-nlogn-time-o-n-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is really a hard nut to crack. It requires great obersvation skills and can be only understood, if we look at the examples properly. Let me try to explain with an example\\n\\n**Let the array be [1,3,5,1,3,4] and k = 2**\\n\\nNow what are the cases that are possible\\n\\nThe cases are as follows\\n\\n**[1] + [3,5,1,3,4] = > (1+1) + (3+4) => 9**\\n\\n**[1,3] + [5,1,3,4] => (1+3) + (5+4) => 13**\\n\\n**[1,3,5] + [1,3,4] => (1+5) + (1+4) => 11**\\n\\n**[1,3,5,1] + [3,4] => (1+1) + (3+4) => 9**\\n\\n**[1,3,5,1,3] + [4] => (1+3) + (4+4) => 12**\\n\\nNow, what can be observe in every case, \\n\\n**There are 2 numbers which come in every case,  that is index no 0 and index no last(5)**, **the no 1 and 4 are added in every sum**, it means however we do the partitions , **index no 0 and last index are always going to come in our sum**,\\n\\nIf they are coming again and again , **the question arises do we need to take them** , because if we see \\n\\nOur question says that we need to do **max-min** , but this 1 and 4 will be present in max and as well as min\\n\\nso it means that if we don\\'t include this 1 and 4 **there wont be an affect on our ans** \\n\\nNow the question arises , **how do we find the sum of other pairs**\\n\\nFor that we need some **cute observation** \\n\\nLet us take the above example only \\n\\nLet us do the partition like this => \\n\\n[1,3] + [5,1,3,4] => Here, the sum is (1+3) and (5+4 ) but as i said above 1 and 4 are not important so we can remove that so the remaining numbers are 3 and 5 , which is 8\\n\\nNow , we can see a **pattern** here \\n\\nThe pattern is, if we take them sum from (**weight[zero index] + weights[some i]) + (weight[i+1]+weight[last_index])** we see that we only need to do the sum of **(weight[i]+weight[i+1])**, \\n\\nYou can see in the above case also, we did a sum of 3+5 **which is i and i+1**\\n\\nSo how do we find all the pairs now, it is simple \\n\\nJust make an array say partition and insert the sum of **weight[i]+weight[i+1] for every index** , This is the sum of every pair presnt in the array \\n\\nso for the above example that is [1,3,5,1,3,4] , the partition array will be [4,8,6,4,7]\\n\\n***Partition array is the sum of every pair present in the array (THIS IS THE CRUX OF THE QUESTION)***,\\n\\nNow how do we get the max and min , the ans is simple \\n\\n**sort the array and just subtract the smallest element from the biggest element**\\n\\nNow, here i took an example where k was 2, so we could have only 1 partition so that is why we subtacted the smallest element from the max element in the partition array\\n\\nIf k==3, then what changes we will make \\n\\nIf k is 3, it means we require 2 pairs , and we have the list of sum of all pairs \\n\\npartition  = [4,8,6,4,7] which after sorting becomes [4,4,6,7,8], so **now we just need to (7+8)-(4+4)** because we require 2 pairs , so **max will have 2 pairs and min will have 2 pairs** \\n\\nThis is how we solve these type of questions\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) Make a vector named partition which will have sum of all the pairs\\n\\n2) Run your loop for n-1 times as we if we have n elements then we will have n-1 pairs and for every index just store weight[i]+weight[i+1]\\n\\n3) Now just sort your partion array and find the sum of first k-1 elemtts in the partition array to get the minimum sum and find the sum of last k-1 elemets to get the max sum\\n\\n4) Subtract both of them and return your ans :)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWe are sorting the array so **O(N*LOGN)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWe are making a partition array so **O(N)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        \\n        vector<long long int>pq;\\n\\n        for(int i=0; i<weights.size()-1; i++)\\n        {\\n            long long int a = weights[i]+weights[i+1];\\n            pq.push_back(a);\\n        }\\n\\n        sort(pq.begin(),pq.end());\\n\\n        long long int a = 0;\\n\\n        for(int i=0; i<k; i++)\\n        {\\n            a+=pq[i];\\n        }\\n        long long int b = 0;\\n        int i = pq.size()-1;\\n        \\n        while(k>0)\\n        {\\n            b+=pq[i];\\n            i--;\\n            k--;\\n        }\\n        long long int ans ;\\n        ans  = b-a;\\n        return ans;\\n    }\\n};\\n```\\n\\n**TIME FOR A MEME NOW**\\n\\n![WhatsApp Image 2023-07-09 at 00.59.49.jpeg](https://assets.leetcode.com/users/images/91da0c4e-3752-40bf-a485-2b6704bfd19f_1688844644.599897.jpeg)\\n\\n***IF YOU LIKE MY SOLUTION , PLEASE UPVOTE***",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        \\n        vector<long long int>pq;\\n\\n        for(int i=0; i<weights.size()-1; i++)\\n        {\\n            long long int a = weights[i]+weights[i+1];\\n            pq.push_back(a);\\n        }\\n\\n        sort(pq.begin(),pq.end());\\n\\n        long long int a = 0;\\n\\n        for(int i=0; i<k; i++)\\n        {\\n            a+=pq[i];\\n        }\\n        long long int b = 0;\\n        int i = pq.size()-1;\\n        \\n        while(k>0)\\n        {\\n            b+=pq[i];\\n            i--;\\n            k--;\\n        }\\n        long long int ans ;\\n        ans  = b-a;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737825,
                "title": "easy-c-solution-using-sorting",
                "content": "\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        vector<int>pairSum;\\n        int n = w.size();\\n\\n        //pairSum stores costs of partition between every index.\\n        //Basically all possible costs are stored\\n        for(int i=0;i<n-1;i++)\\n        {\\n            pairSum.push_back(w[i]+w[i+1]);\\n        }\\n        \\n        sort(pairSum.begin(),pairSum.end());\\n\\n        long long max_score=0, min_score=0;\\n\\n        //for k bags, the number of partitions done are k-1 hence we calculate\\n        //score for only smallest k-1 costs and largest k-1 costs.\\n        for(int i=0;i<k-1;i++)\\n        {\\n            min_score += pairSum[i];\\n            max_score += pairSum[n-2-i];\\n        }\\n\\n        return max_score - min_score;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        vector<int>pairSum;\\n        int n = w.size();\\n\\n        //pairSum stores costs of partition between every index.\\n        //Basically all possible costs are stored\\n        for(int i=0;i<n-1;i++)\\n        {\\n            pairSum.push_back(w[i]+w[i+1]);\\n        }\\n        \\n        sort(pairSum.begin(),pairSum.end());\\n\\n        long long max_score=0, min_score=0;\\n\\n        //for k bags, the number of partitions done are k-1 hence we calculate\\n        //score for only smallest k-1 costs and largest k-1 costs.\\n        for(int i=0;i<k-1;i++)\\n        {\\n            min_score += pairSum[i];\\n            max_score += pairSum[n-2-i];\\n        }\\n\\n        return max_score - min_score;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737764,
                "title": "simple-java-solution-100-beats",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        if(k==1 || k==weights.length)\\n        {\\n            return 0;\\n        }\\n        int[] score = new int[weights.length - 1];\\n        for(int i=0;i<weights.length-1;i++)\\n        {\\n            score[i] = weights[i] + weights[i+1];\\n        }\\n        Arrays.sort(score);\\n        long minsum = 0,maxsum=0;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            minsum += score[i];\\n            maxsum += score[score.length - i -1];\\n        }\\n        return (maxsum - minsum);\\n    }\\n}\\n\\n```\\n![image.png](https://assets.leetcode.com/users/images/e5f90e96-1e87-4c93-a6c8-b723cdfe4bbc_1688839025.1036968.png)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        if(k==1 || k==weights.length)\\n        {\\n            return 0;\\n        }\\n        int[] score = new int[weights.length - 1];\\n        for(int i=0;i<weights.length-1;i++)\\n        {\\n            score[i] = weights[i] + weights[i+1];\\n        }\\n        Arrays.sort(score);\\n        long minsum = 0,maxsum=0;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            minsum += score[i];\\n            maxsum += score[score.length - i -1];\\n        }\\n        return (maxsum - minsum);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737678,
                "title": "c-super-easy-clean-code-beats-100-runtime-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        \\n        int n = weights.size() - 1;\\n        if(n == 0) return 0;\\n        int arr[n];\\n        for(int i=0; i<n; i++){\\n            arr[i] = weights[i] + weights[i+1];\\n        }\\n        sort(arr,arr+n);\\n        long long ans = 0;\\n        for(int i=0; i<k-1; i++){\\n            ans += arr[n-i-1] - arr[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        \\n        int n = weights.size() - 1;\\n        if(n == 0) return 0;\\n        int arr[n];\\n        for(int i=0; i<n; i++){\\n            arr[i] = weights[i] + weights[i+1];\\n        }\\n        sort(arr,arr+n);\\n        long long ans = 0;\\n        for(int i=0; i<k-1; i++){\\n            ans += arr[n-i-1] - arr[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737616,
                "title": "js-sort-pairs-of-weights",
                "content": "# Intuition\\nWe can represent the bags as a list of indexes, where each index is the position where the last bag starts, and the next one ends. This works because it is not permitted to have any unused marbles - therefore, there will be no gaps between bags. \\n\\nOnce we consider it thustly, we just need to find the best values for these indexes - without any requirement that we find them in order.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe build an array of \\'pairs\\' - where a pair is the sum of a weight and the weight that comes after it. Because we don\\'t need to find the pairs in any specific order, we can just sort the list of pairs and pick the leading and trailing k-1 values, and take the difference between the sums.\\n\\n\\n```text\\na is the start of a bag, b is the end of a bag. \\nAny (b) is an index that we\\'ve chosen.\\n\\nk=3, [50, 51, 30, 1, 9, 9, 1]\\n--------------------------------\\na              (b)  a   (b)   ab  79  <- smallest\\n50   51   30   1    9    9    1 \\na(b) a(b) a                   b  233 <- largest\\n```\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*log(n))$$ - the time it takes to sort the pairs.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$ - could also be done in $$O(1)$$ by reusing the input array.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} weights\\n * @param {number} k\\n * @return {number}\\n */\\nvar putMarbles = function(weights, k) {\\n    let weightPairs = new Uint32Array(weights.length-1);\\n    for(let i = 1; i < weights.length; ++i) {\\n        weightPairs[i-1] = weights[i] + weights[i-1];\\n    }\\n    weights = null;\\n    weightPairs.sort();\\n\\n    let ret = 0;\\n\\n    for(let i = 0; i < (k-1); ++i) {\\n        ret += weightPairs[(weightPairs.length-1)-i];\\n        ret -= weightPairs[i];\\n    }\\n\\n    return ret;\\n};\\n\\n```\\n\\nBeats 100%.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```text\\na is the start of a bag, b is the end of a bag. \\nAny (b) is an index that we\\'ve chosen.\\n\\nk=3, [50, 51, 30, 1, 9, 9, 1]\\n--------------------------------\\na              (b)  a   (b)   ab  79  <- smallest\\n50   51   30   1    9    9    1 \\na(b) a(b) a                   b  233 <- largest\\n```\n```\\n/**\\n * @param {number[]} weights\\n * @param {number} k\\n * @return {number}\\n */\\nvar putMarbles = function(weights, k) {\\n    let weightPairs = new Uint32Array(weights.length-1);\\n    for(let i = 1; i < weights.length; ++i) {\\n        weightPairs[i-1] = weights[i] + weights[i-1];\\n    }\\n    weights = null;\\n    weightPairs.sort();\\n\\n    let ret = 0;\\n\\n    for(let i = 0; i < (k-1); ++i) {\\n        ret += weightPairs[(weightPairs.length-1)-i];\\n        ret -= weightPairs[i];\\n    }\\n\\n    return ret;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3736809,
                "title": "simple-solution",
                "content": "\\nPair Weight approach\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} weights\\n * @param {number} k\\n * @return {number}\\n */\\nvar putMarbles = function(weights, k) {\\n    let pairsum = [];\\n    let len = weights.length;\\n    for(let i=0;i<len-1;i++)\\n        pairsum.push(weights[i]+weights[i+1]);\\n    pairsum.sort((a,b)=>{return a-b});\\n    let minscore = weights[0]+weights[len-1];\\n    let maxscore = minscore;\\n    for(let i=0;i<k-1;i++){\\n        minscore+=pairsum[i];\\n        maxscore+=pairsum[len-i-2];\\n    }\\n    return maxscore-minscore;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} weights\\n * @param {number} k\\n * @return {number}\\n */\\nvar putMarbles = function(weights, k) {\\n    let pairsum = [];\\n    let len = weights.length;\\n    for(let i=0;i<len-1;i++)\\n        pairsum.push(weights[i]+weights[i+1]);\\n    pairsum.sort((a,b)=>{return a-b});\\n    let minscore = weights[0]+weights[len-1];\\n    let maxscore = minscore;\\n    for(let i=0;i<k-1;i++){\\n        minscore+=pairsum[i];\\n        maxscore+=pairsum[len-i-2];\\n    }\\n    return maxscore-minscore;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3736712,
                "title": "approach-that-focuses-on-the-thought-process-behind-the-answer-heaps",
                "content": "# Intuition\\nThe first step in building the solution is to identify how we can maximize and minimize the subgroups we take. It can be observed that the maximum value of score $$sum(weights) * 2$$ will be obtained when each of the elements are in their own group and the minimum $$weights[0]  + weights[n-1]$$ when the whole list is one group.\\n\\nWe are also met with the constraint that we must have k groups, hence we can start of with the maximum possible score and keep decreasing the score as we go along joining the elements/groups.\\n\\n# Approach\\n\\nInorder to get the maximum value of Score we must join sets such that their loss when joining is minimum when finding the maximum score i.e (Score of A + Score of B) - Score of AB and must be maximum when trying to find the minimum value of score.\\n\\n---\\n\\nThis can be found simply by calculating the loss at each index of the list and then joining then ones with the smallest and highest loss respectively for $$n - k$$ times.\\n\\nHowever performing this operation for n elements in the array at worst case will lead to a TC of $$(n-k)*n$$ which is not accepted.\\nThis repeated finding of smallest/largest loss can be done by implementating heap that always position the largest/smallest element at it\\'s $$0th$$ position with each retrieval operation taking $$logn$$ time.\\n\\n\\nThe solution is obtained by identifying one major pattern:\\n1. The loss incurred when joining two sets i and i + 1 is given by `loss = (set[i][start] + set[i][end] + set[i + 1][start] + set[i + 1][end]) - (set[i][start] + set[i + 1][end])`.\\n2. However this can be simplified as `loss = set[i][end] + set[i + 1][start]`, From this, we draw conclusion that the loss incurred at each joining of **i and i + 1** in the set is not dependent on the left or right sets and only on the **ith and i+1th element**.\\n\\n\\nWe now implement two heaps, one that maintains the highest loss on top and another that maintains the lowest, we repeatedly pop elements from the two heaps for $$(n-k)$$ times and subtract it from the highest score to obtain the minimum and maximum Score obtainable for k groups and return the difference of the two.\\n\\n# Complexity\\n- Time complexity:\\nTC  = **nlogn** for creating the heap + **(n-k)*logn*** for each pop operation on the heap = $$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$ for heap of size **n - 1**\\n\\n# Code\\n```\\nfrom heapq import heapify, heappop\\n\\nclass Solution:\\n    def putMarbles(self, weights: list[int], k: int) -> int:\\n        \\n        mx, mn = [0] * (len(weights) - 1), [0] * (len(weights) - 1)\\n\\n        for i in range(len(weights) - 1):\\n        \\t# loss = (weights[i] * 2  + weights[i + 1] * 2) - (weights[i] + weights[i + 1])\\n            # This can be further written as : \\n            loss = weights[i] + weights[i + 1]\\n            # -loss for implementing max heap in python since it\\'s min heap by default\\n            mx[i], mn[i] = loss, -loss\\n\\n        heapify(mx)\\n        heapify(mn)\\n\\n\\n        maxScore, minScore = sum(weights) * 2, sum(weights) * 2\\n\\n        for i in range(len(weights) - k):\\n        \\tmaxScore -= heappop(mx)\\n        \\tminScore -= -heappop(mn)\\n\\n        return maxScore - minScore\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfrom heapq import heapify, heappop\\n\\nclass Solution:\\n    def putMarbles(self, weights: list[int], k: int) -> int:\\n        \\n        mx, mn = [0] * (len(weights) - 1), [0] * (len(weights) - 1)\\n\\n        for i in range(len(weights) - 1):\\n        \\t# loss = (weights[i] * 2  + weights[i + 1] * 2) - (weights[i] + weights[i + 1])\\n            # This can be further written as : \\n            loss = weights[i] + weights[i + 1]\\n            # -loss for implementing max heap in python since it\\'s min heap by default\\n            mx[i], mn[i] = loss, -loss\\n\\n        heapify(mx)\\n        heapify(mn)\\n\\n\\n        maxScore, minScore = sum(weights) * 2, sum(weights) * 2\\n\\n        for i in range(len(weights) - k):\\n        \\tmaxScore -= heappop(mx)\\n        \\tminScore -= -heappop(mn)\\n\\n        return maxScore - minScore\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736445,
                "title": "c-linq-one-liner",
                "content": "```csharp\\npublic long PutMarbles(int[] weights, int k) => weights\\n\\t.Zip(weights.Skip(1), (a, b) => (long)a + b)\\n\\t.OrderBy(r => r)\\n\\t.Select((p, i) => (i > weights.Length - k - 1 ? p : 0) - (i < k - 1 ? p : 0))\\n\\t.Sum();\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic long PutMarbles(int[] weights, int k) => weights\\n\\t.Zip(weights.Skip(1), (a, b) => (long)a + b)\\n\\t.OrderBy(r => r)\\n\\t.Select((p, i) => (i > weights.Length - k - 1 ? p : 0) - (i < k - 1 ? p : 0))\\n\\t.Sum();\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3736377,
                "title": "java-solution-pair-sum-approach",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn) (sorting)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        // Approach:- We will create a Pair Sum Array in which we will keep values of pair and their sum, since if we are splitting array from a point (i) then its pair sum will be i, i+1 or i, i-1 based on our understanding.\\n        // we are neglecting the first and last values as they are common in every pair \\n        // We will sort the pair sum and calculate our result by taking k - 1 elements for both min and max\\n        int n = weights.length;\\n        long[] pairSum = new long[n - 1];\\n        for(int i = 0; i < n - 1; i++){\\n            pairSum[i] = (long)weights[i] + (long)weights[i + 1];\\n        }\\n        Arrays.sort(pairSum);\\n        long min = 0; \\n        long max = 0;\\n        for(int i = 0; i < k - 1; i++){\\n            min += pairSum[i];\\n            max += pairSum[n - 2 - i];\\n        }\\n        return max - min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        // Approach:- We will create a Pair Sum Array in which we will keep values of pair and their sum, since if we are splitting array from a point (i) then its pair sum will be i, i+1 or i, i-1 based on our understanding.\\n        // we are neglecting the first and last values as they are common in every pair \\n        // We will sort the pair sum and calculate our result by taking k - 1 elements for both min and max\\n        int n = weights.length;\\n        long[] pairSum = new long[n - 1];\\n        for(int i = 0; i < n - 1; i++){\\n            pairSum[i] = (long)weights[i] + (long)weights[i + 1];\\n        }\\n        Arrays.sort(pairSum);\\n        long min = 0; \\n        long max = 0;\\n        for(int i = 0; i < k - 1; i++){\\n            min += pairSum[i];\\n            max += pairSum[n - 2 - i];\\n        }\\n        return max - min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736185,
                "title": "python-elegant-short-two-lines",
                "content": "# Complexity\\n- Time complexity: $$O(n * log_{2} n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        cost = [l + r for l, r in pairwise(weights)]\\n        return sum(nlargest(k - 1, cost)) - sum(nsmallest(k - 1, cost))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        cost = [l + r for l, r in pairwise(weights)]\\n        return sum(nlargest(k - 1, cost)) - sum(nsmallest(k - 1, cost))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735972,
                "title": "c-solution",
                "content": "```\\nint cmp(void *a, void *b){\\n    return *(int*) a - *(int*) b;\\n}\\nlong long putMarbles(int* weights, int weightsSize, int k){\\n    \\n    int* pairs = calloc(weightsSize, sizeof(int));\\n    for (int i = 0; i < weightsSize - 1; i++)\\n        pairs[i] = weights[i] + weights[i + 1];\\n    \\n    qsort(pairs, weightsSize - 1, sizeof(int), cmp);\\n    \\n    long long ret = 0;\\n    for (int i = 0; i < k - 1; i++)\\n        ret += pairs[weightsSize - 2 - i] - pairs[i];\\n\\t\\t\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmp(void *a, void *b){\\n    return *(int*) a - *(int*) b;\\n}\\nlong long putMarbles(int* weights, int weightsSize, int k){\\n    \\n    int* pairs = calloc(weightsSize, sizeof(int));\\n    for (int i = 0; i < weightsSize - 1; i++)\\n        pairs[i] = weights[i] + weights[i + 1];\\n    \\n    qsort(pairs, weightsSize - 1, sizeof(int), cmp);\\n    \\n    long long ret = 0;\\n    for (int i = 0; i < k - 1; i++)\\n        ret += pairs[weightsSize - 2 - i] - pairs[i];\\n\\t\\t\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3735926,
                "title": "easy-for-python-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def putMarbles(self, weights, k):\\n        i=0\\n        j=0\\n        l=[]\\n        for j in range(len(weights)-1):\\n            sum=weights[j]+weights[j+1]\\n            l.append(sum)\\n            sum=0\\n        l.sort()\\n        p=len(l)-1\\n        sum1=0\\n        sum2=0\\n        while k>1:\\n            sum1=sum1+l[i]\\n            sum2=sum2+l[p]\\n            i=i+1\\n            p=p-1\\n            k=k-1\\n        return sum2-sum1\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def putMarbles(self, weights, k):\\n        i=0\\n        j=0\\n        l=[]\\n        for j in range(len(weights)-1):\\n            sum=weights[j]+weights[j+1]\\n            l.append(sum)\\n            sum=0\\n        l.sort()\\n        p=len(l)-1\\n        sum1=0\\n        sum2=0\\n        while k>1:\\n            sum1=sum1+l[i]\\n            sum2=sum2+l[p]\\n            i=i+1\\n            p=p-1\\n            k=k-1\\n        return sum2-sum1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735728,
                "title": "intuition-building-image-explanation-heap-c-beginners",
                "content": "**Time** : O( Nlog(N) ) , **Space** : O(N)\\n\\n*Here i have written how you can observe and build intuition based on those observations*\\n![image](https://assets.leetcode.com/users/images/68cc3487-163e-4213-a7c4-474564983011_1688807695.719539.jpeg)\\n.\\n\\n![image](https://assets.leetcode.com/users/images/1688fec4-9696-40ca-9b5a-bb546fea7e28_1688807695.7634351.jpeg)\\n\\n**Code:**\\nYou can write more space optimal code but for the sake of better understanding you can refer this .\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k==1) return 0;\\n\\n        priority_queue<pair<long , float>> maxheap; // stores [max_consecutive_sum,{(ind1+ind2)/2}]\\n\\t\\t// note that (ind1+ind2)/2 is float value eg. 2.5 or 6.5 and it will give us the index of integers which make value : max_consecutive_sum\\n\\t\\t// ind: [0 ,1,  2 ,  3, 4]\\n\\t\\t// eg.  [1, 3 , 100 ,5 ,1]\\n\\t\\t//sum:[1+3 = 4 ->{ind:0 + ind:1}/2 = 0.5 ]\\n\\t\\t//sum:[3+100 = 103 -> {ind:1 + ind:2}/2 = 1.5]\\n\\t\\t//sum[100+5 = 105 -> {ind:2 + ind:3}/2 = 2.5]\\n\\t\\t// ... and so on hence maxheap will contain ->[{105 , 2.5} , {103 , 1.5} , {6 , 3.5} , {4 , 0.5} ]\\n        priority_queue<pair<long , float> , vector<pair<long , float>> , greater<pair<long , float>>> minheap;\\n        for(int i=1 ; i<n ; i++){\\n            maxheap.push({nums[i]+nums[i-1] , ((i+i-1)/2)});\\n            minheap.push({nums[i]+nums[i-1] , ((i+i-1)/2)});\\n        }\\n        //  hence maxheap will contain ->[ {4 , 0.5} , 6 , 3.5} , {103 , 1.5}  , {105 , 2.5} ]\\n        priority_queue<float , vector<float> , greater<float>> mh1 , mh2;\\n        for(int i=0 ; i<k-1 ; i++){\\n            mh1.push(maxheap.top().second); maxheap.pop();\\n            mh2.push(minheap.top().second); minheap.pop();\\n        }\\n        \\n        long long maxval = 0ll;\\n        float prev = 0;\\n\\t\\t// finding split with maxSum , such K-1 splits will give rise to K different bags\\n        while(mh1.size()>0){\\n            float t = mh1.top(); mh1.pop(); // lets say if t = 3.5 and mh1.top.first = 100 i.e current_sum\\n            int v1 = t , v2 = t+1; //cout<<v1<<\" \"<<v2<<endl; // if t=3.5 then v1 = 3 and v2 = 4 , hence we get both indexed of this current_sum i.e 100\\n            maxval+=(nums[prev]+nums[v1]); //is same as image_2 -> point_4(implementation) -> whats written in red\\n            prev = v2;\\n        }\\n        maxval+=(nums[prev]+nums[n-1]);\\n        \\n        prev = 0;\\n        long long minval = 0ll;\\n\\t\\t// finding split with minSum  , such K-1 splits will give rise to K different bags\\n        while(mh2.size()>0){\\n            float t = mh2.top(); mh2.pop();\\n            int v1 = t , v2 = t+1;\\n            minval+=(nums[prev]+nums[v1]);  //is same as image_2 -> point_4(implementation) -> whats written in red\\n            prev = v2;\\n        }\\n        minval+=(nums[prev]+nums[n-1]);\\n        \\n        return maxval-minval;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        if(k==1) return 0;\\n\\n        priority_queue<pair<long , float>> maxheap; // stores [max_consecutive_sum,{(ind1+ind2)/2}]\\n\\t\\t// note that (ind1+ind2)/2 is float value eg. 2.5 or 6.5 and it will give us the index of integers which make value : max_consecutive_sum\\n\\t\\t// ind: [0 ,1,  2 ,  3, 4]\\n\\t\\t// eg.  [1, 3 , 100 ,5 ,1]\\n\\t\\t//sum:[1+3 = 4 ->{ind:0 + ind:1}/2 = 0.5 ]\\n\\t\\t//sum:[3+100 = 103 -> {ind:1 + ind:2}/2 = 1.5]\\n\\t\\t//sum[100+5 = 105 -> {ind:2 + ind:3}/2 = 2.5]\\n\\t\\t// ... and so on hence maxheap will contain ->[{105 , 2.5} , {103 , 1.5} , {6 , 3.5} , {4 , 0.5} ]\\n        priority_queue<pair<long , float> , vector<pair<long , float>> , greater<pair<long , float>>> minheap;\\n        for(int i=1 ; i<n ; i++){\\n            maxheap.push({nums[i]+nums[i-1] , ((i+i-1)/2)});\\n            minheap.push({nums[i]+nums[i-1] , ((i+i-1)/2)});\\n        }\\n        //  hence maxheap will contain ->[ {4 , 0.5} , 6 , 3.5} , {103 , 1.5}  , {105 , 2.5} ]\\n        priority_queue<float , vector<float> , greater<float>> mh1 , mh2;\\n        for(int i=0 ; i<k-1 ; i++){\\n            mh1.push(maxheap.top().second); maxheap.pop();\\n            mh2.push(minheap.top().second); minheap.pop();\\n        }\\n        \\n        long long maxval = 0ll;\\n        float prev = 0;\\n\\t\\t// finding split with maxSum , such K-1 splits will give rise to K different bags\\n        while(mh1.size()>0){\\n            float t = mh1.top(); mh1.pop(); // lets say if t = 3.5 and mh1.top.first = 100 i.e current_sum\\n            int v1 = t , v2 = t+1; //cout<<v1<<\" \"<<v2<<endl; // if t=3.5 then v1 = 3 and v2 = 4 , hence we get both indexed of this current_sum i.e 100\\n            maxval+=(nums[prev]+nums[v1]); //is same as image_2 -> point_4(implementation) -> whats written in red\\n            prev = v2;\\n        }\\n        maxval+=(nums[prev]+nums[n-1]);\\n        \\n        prev = 0;\\n        long long minval = 0ll;\\n\\t\\t// finding split with minSum  , such K-1 splits will give rise to K different bags\\n        while(mh2.size()>0){\\n            float t = mh2.top(); mh2.pop();\\n            int v1 = t , v2 = t+1;\\n            minval+=(nums[prev]+nums[v1]);  //is same as image_2 -> point_4(implementation) -> whats written in red\\n            prev = v2;\\n        }\\n        minval+=(nums[prev]+nums[n-1]);\\n        \\n        return maxval-minval;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3735670,
                "title": "easy-solution-with-2-priority-queue",
                "content": "# Intuition\\nThe approach lies in the problem if u see carefully we will always add two consecutive element when we do partion so if we store all the sum of two consecutive element and take k-1 max summations and k-1 min summations will give particular max and min score.\\nthe result will be their difference.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n*logn)\\n\\n- Space complexity:\\n- O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        if(k==1 || k==n) return 0; \\n        PriorityQueue <Integer> maxPQ = new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue <Integer> minPQ = new PriorityQueue<>();\\n        //stores sum of each adjacent element in max and min priority queues;\\n        for(int i=0;i<n-1;i++){\\n            maxPQ.add(weights[i]+weights[i+1]); //it gives us the max sum pair of adjacent element \\n            minPQ.add(weights[i]+weights[i+1]); //it gives us the min sum pair of adjacent element\\n        }\\n        //for every vaue of k, we have to cut the array from  k-1 places;\\n        long max=0, min=0;\\n        for(int i=0; i<k-1; i++){\\n            max+=maxPQ.remove();\\n            min+=minPQ.remove();\\n        }\\n        return max-min;\\n    }\\n}\\n\\n\\n/*\\nfor max sum of min sum first and last values are same;\\neg: max= 1+8+9+2   // 1 3 6 8 | 9 5 3 1 7 2  \\n    min=1+1+3+2    // // 1 | 3 6 8 9 5 3 1 7 2\\n\\nfor k=3, no. of cut is 2\\n1 3 6 8 | 9 5 3 1 | 7 2\\n*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        if(k==1 || k==n) return 0; \\n        PriorityQueue <Integer> maxPQ = new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue <Integer> minPQ = new PriorityQueue<>();\\n        //stores sum of each adjacent element in max and min priority queues;\\n        for(int i=0;i<n-1;i++){\\n            maxPQ.add(weights[i]+weights[i+1]); //it gives us the max sum pair of adjacent element \\n            minPQ.add(weights[i]+weights[i+1]); //it gives us the min sum pair of adjacent element\\n        }\\n        //for every vaue of k, we have to cut the array from  k-1 places;\\n        long max=0, min=0;\\n        for(int i=0; i<k-1; i++){\\n            max+=maxPQ.remove();\\n            min+=minPQ.remove();\\n        }\\n        return max-min;\\n    }\\n}\\n\\n\\n/*\\nfor max sum of min sum first and last values are same;\\neg: max= 1+8+9+2   // 1 3 6 8 | 9 5 3 1 7 2  \\n    min=1+1+3+2    // // 1 | 3 6 8 9 5 3 1 7 2\\n\\nfor k=3, no. of cut is 2\\n1 3 6 8 | 9 5 3 1 | 7 2\\n*/\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735477,
                "title": "put-marbles-in-bags-c",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        if(n==k||k==1)\\n        {\\n            long long ans=0;\\n            return ans;\\n        }\\n        vector<int> diff;\\n       for(int i=0;i<n-1;i++)\\n       {\\n           diff.push_back(weights[i]+weights[i+1]);\\n       } \\n\\n       sort(diff.begin(),diff.end());\\n       n=diff.size();\\n       long long mini=0,maxi=0;\\n       for(int i=0;i<k-1;i++)\\n       {\\n           mini+=diff[i];\\n           maxi+=diff[n-i-1];\\n       }\\n\\n       long long ans=maxi-mini;\\n\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        if(n==k||k==1)\\n        {\\n            long long ans=0;\\n            return ans;\\n        }\\n        vector<int> diff;\\n       for(int i=0;i<n-1;i++)\\n       {\\n           diff.push_back(weights[i]+weights[i+1]);\\n       } \\n\\n       sort(diff.begin(),diff.end());\\n       n=diff.size();\\n       long long mini=0,maxi=0;\\n       for(int i=0;i<k-1;i++)\\n       {\\n           mini+=diff[i];\\n           maxi+=diff[n-i-1];\\n       }\\n\\n       long long ans=maxi-mini;\\n\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735425,
                "title": "c-solution-sorting-and-greedy-supereasy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n```\\n                     Sorting and Greedy\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. `int n = weights.size()`;: This line initializes an integer variable `n` with the size of the `weights` vector, which represents the number of marbles.\\n\\n2. `vector<int> temp`;: This creates an empty vector temp to store the sums of adjacent marble weights.\\n\\n3. `for (int i = 0; i < n-1; i++)`: This loop iterates over the weights vector up to the second-to-last element (index n-1) because the last element does not have a next element to add with.\\n\\n4. Inside the loop, `temp.push_back(weights[i] + weights[i+1])`; calculates the sum of the current marble weight (`weights[i]`) and the next marble weight (`weights[i+1]`), and adds it to the temp vector.\\n\\n5. `sort(temp.begin(), temp.end())`;: This sorts the temp vector in ascending order. Now, temp contains the sums of adjacent marble weights in non-decreasing order.\\n\\n6. `long long miniSum = 0, maxiSum = 0`;: These variables are initialized to 0 to store the minimum and maximum sums of adjacent marble weights.\\n\\n7. `for (int i = 0; i < k-1; i++)`: This loop iterates k-1 times, where k represents the number of marbles to be put. It calculates the minimum and maximum sums of adjacent marble weights by considering the first k-1 elements of the sorted temp vector and the last k-1 elements in reverse order.\\n\\n8. Inside the loop, `miniSum += temp[i]`; adds the i-th element of temp to the miniSum.\\n\\n9. `maxiSum += temp[n-2-i]`; adds the n-2-i-th element of temp to the maxiSum, which represents the reverse order.\\n\\n10. Finally, return `maxiSum - miniSum`; calculates the difference between the maximum and minimum sums of adjacent marble weights and returns it as the result of the putMarbles function.\\n\\n# Complexity\\n- Time complexity:$$O(n\\u22C5log\\u2061n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        \\n        int n=weights.size();\\n\\n      \\n        vector<int>temp;\\n        \\n        for(int i=0;i<n-1;i++){\\n            temp.push_back(weights[i]+weights[i+1]);\\n        }\\n\\n        sort(temp.begin(),temp.end());\\n       \\n       long long miniSum=0,maxiSum=0;\\n\\n        for(int i=0;i<k-1;i++){\\n           miniSum+= temp[i];\\n           maxiSum+= temp[n-2-i];\\n        }\\n\\n        return maxiSum-miniSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n                     Sorting and Greedy\\n```\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        \\n        int n=weights.size();\\n\\n      \\n        vector<int>temp;\\n        \\n        for(int i=0;i<n-1;i++){\\n            temp.push_back(weights[i]+weights[i+1]);\\n        }\\n\\n        sort(temp.begin(),temp.end());\\n       \\n       long long miniSum=0,maxiSum=0;\\n\\n        for(int i=0;i<k-1;i++){\\n           miniSum+= temp[i];\\n           maxiSum+= temp[n-2-i];\\n        }\\n\\n        return maxiSum-miniSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735315,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long n=weights.size();\\n        vector<long long> tts;\\n        for(long long i=1;i<n;i++){\\n            tts.push_back(weights[i]+weights[i-1]);\\n        }\\n        sort(tts.begin(),tts.end());\\n        long long mi=0,mx=0;\\n        for(long long i=0;i<k-1;i++){\\n            mi+=tts[i];\\n        }\\n        sort(tts.rbegin(),tts.rend());\\n        for(long long i=0;i<k-1;i++){\\n            mx+=tts[i];\\n        }\\n        return mx-mi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long n=weights.size();\\n        vector<long long> tts;\\n        for(long long i=1;i<n;i++){\\n            tts.push_back(weights[i]+weights[i-1]);\\n        }\\n        sort(tts.begin(),tts.end());\\n        long long mi=0,mx=0;\\n        for(long long i=0;i<k-1;i++){\\n            mi+=tts[i];\\n        }\\n        sort(tts.rbegin(),tts.rend());\\n        for(long long i=0;i<k-1;i++){\\n            mx+=tts[i];\\n        }\\n        return mx-mi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735309,
                "title": "easily-explained-with-example-beats-100",
                "content": "# Intuition\\nThe code aims to find the sum of differences between the highest k-1 and lowest k-1 pair costs among the given weights. The pair cost is calculated by summing the weights of consecutive marbles. The goal is to determine the minimum cost required to put k marbles together.\\n\\n# Approach with easy example\\nLet\\'s consider an example to understand the approach better. Suppose we have an array of weights [1, 3, 2, 5, 4] and k = 3.\\n1. Calculate pair costs:\\n    - Start with the first weight and add it to the next weight: 1 + 3 = 4\\n    - Move to the next pair: 3 + 2 = 5\\n    - Continue this process for all pairs: [4, 5, 7, 9]\\n2. Sort the pair costs in ascending order: [4, 5, 7, 9]\\n3. Calculate the sum of differences for the highest k-1 and lowest k-1 pair costs:\\n    - For k = 3, we need to consider the top 2 and bottom 2 pair costs.\\n    - The sum of differences would be (9 - 4) + (7 - 5) = 7.\\n4. Return the result: 7\\n\\n\\n# Complexity\\n- Time complexity: $$O(n log n + k)$$\\n    - The code involves iterating through the given weights array once to calculate the pair costs, which takes O(n) time, where n is the length of the weights array.\\n    - Sorting the pair costs array takes O(n log n) time.\\nFinally, calculating the sum of differences requires iterating k-1 times, resulting in O(k) time.\\n    - Therefore, the overall time complexity is O(n log n + k).\\n\\n- Space complexity: $$O(n)$$\\n    - The space complexity is O(n) since the code uses an additional array, pairCosts, to store the pair costs.\\n\\n![image.png](https://assets.leetcode.com/users/images/9e14fc42-7306-472d-9c58-b02b8e1746a1_1688801410.332213.png)\\n\\n\\n> IF YOU FOUND IT HELPFUL GIVE IT A `UPVOTE \\u2B06` SO THAT OTHER PEOPLE ALSO CAN FIND IT EASILY\\nTHANK YOU FOR YOUR TIME \\u231A\\n\\n# Javascript Code\\n```\\n/**\\n * @param {number[]} weights\\n * @param {number} k\\n * @return {number}\\n */\\nvar putMarbles = function (weights, k) {\\n    let pairCosts = new Array(weights.length - 1);\\n\\n    // store all the possible Pairs sum\\n    for (let i = 0; i < pairCosts.length; i++) {\\n        pairCosts[i] = weights[i] + weights[i + 1];\\n    }\\n\\n    // ascending order sorting\\n    pairCosts.sort((a, b) => a - b);\\n\\n    let ans = 0;\\n    // get the sum for all pairs differences\\n    for (let i = 0; i < k - 1; i++) {\\n        ans += pairCosts[pairCosts.length - 1 - i] - pairCosts[i];\\n    }\\n\\n    return ans;\\n};\\n```\\n\\n---\\n\\n# Typescript Code\\n```\\nfunction putMarbles(weights: number[], k: number): number {\\n    let pairCosts: number[] = new Array(weights.length - 1);\\n\\n    // store all the possible Pairs sum\\n    for (let i: number = 0; i < pairCosts.length; i++) {\\n        pairCosts[i] = weights[i] + weights[i + 1];\\n    }\\n\\n    // ascending order sorting\\n    pairCosts.sort((a, b) => a - b);\\n\\n    let ans: number = 0;\\n    // get the sum for all pairs differences\\n    for (let i: number = 0; i < k - 1; i++) {\\n        ans += pairCosts[pairCosts.length - 1 - i] - pairCosts[i];\\n    }\\n\\n    return ans;\\n};\\n```\\n---\\n\\n# Python Code\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        # create an array of weights.length-1\\n        pairCosts = [0] * (len(weights)-1)\\n        \\n        # store all the possible Pairs sum\\n        for i in range(len(weights) - 1):\\n            pairCosts[i] = weights[i] + weights[i + 1]\\n\\n        # ascending order sorting\\n        pairCosts.sort()\\n\\n        ans = 0;\\n        # get the sum for all pairs differences\\n        for i in range(k - 1):\\n            ans += pairCosts[len(pairCosts) - 1 - i] - pairCosts[i]\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} weights\\n * @param {number} k\\n * @return {number}\\n */\\nvar putMarbles = function (weights, k) {\\n    let pairCosts = new Array(weights.length - 1);\\n\\n    // store all the possible Pairs sum\\n    for (let i = 0; i < pairCosts.length; i++) {\\n        pairCosts[i] = weights[i] + weights[i + 1];\\n    }\\n\\n    // ascending order sorting\\n    pairCosts.sort((a, b) => a - b);\\n\\n    let ans = 0;\\n    // get the sum for all pairs differences\\n    for (let i = 0; i < k - 1; i++) {\\n        ans += pairCosts[pairCosts.length - 1 - i] - pairCosts[i];\\n    }\\n\\n    return ans;\\n};\\n```\n```\\nfunction putMarbles(weights: number[], k: number): number {\\n    let pairCosts: number[] = new Array(weights.length - 1);\\n\\n    // store all the possible Pairs sum\\n    for (let i: number = 0; i < pairCosts.length; i++) {\\n        pairCosts[i] = weights[i] + weights[i + 1];\\n    }\\n\\n    // ascending order sorting\\n    pairCosts.sort((a, b) => a - b);\\n\\n    let ans: number = 0;\\n    // get the sum for all pairs differences\\n    for (let i: number = 0; i < k - 1; i++) {\\n        ans += pairCosts[pairCosts.length - 1 - i] - pairCosts[i];\\n    }\\n\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        # create an array of weights.length-1\\n        pairCosts = [0] * (len(weights)-1)\\n        \\n        # store all the possible Pairs sum\\n        for i in range(len(weights) - 1):\\n            pairCosts[i] = weights[i] + weights[i + 1]\\n\\n        # ascending order sorting\\n        pairCosts.sort()\\n\\n        ans = 0;\\n        # get the sum for all pairs differences\\n        for i in range(k - 1):\\n            ans += pairCosts[len(pairCosts) - 1 - i] - pairCosts[i]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735257,
                "title": "c-sorting-easy-to-understand-2551-put-marbles-in-bags-hard-problem",
                "content": "# C++ | Sorting | Easy to Understand | 2551. Put Marbles in Bags | Hard Problem\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long minans = weights[0] + weights[weights.size()-1];\\n        long long maxans = minans;\\n        priority_queue<int> pqmax;\\n        priority_queue<int, vector<int>, greater<int>> pqmin;\\n        for(int i=1;i<weights.size();i++)\\n        {\\n            pqmin.push(weights[i] + weights[i-1]);\\n            pqmax.push(weights[i] + weights[i-1]);\\n        } \\n        for(int i=1;i<k;i++)\\n        {\\n            minans += pqmin.top();\\n            maxans += pqmax.top();\\n            pqmin.pop();\\n            pqmax.pop();\\n        }\\n        return (maxans - minans);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long minans = weights[0] + weights[weights.size()-1];\\n        long long maxans = minans;\\n        priority_queue<int> pqmax;\\n        priority_queue<int, vector<int>, greater<int>> pqmin;\\n        for(int i=1;i<weights.size();i++)\\n        {\\n            pqmin.push(weights[i] + weights[i-1]);\\n            pqmax.push(weights[i] + weights[i-1]);\\n        } \\n        for(int i=1;i<k;i++)\\n        {\\n            minans += pqmin.top();\\n            maxans += pqmax.top();\\n            pqmin.pop();\\n            pqmax.pop();\\n        }\\n        return (maxans - minans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735214,
                "title": "probably-the-shortest-java-simple-beginner-friendly",
                "content": "\\n# Approach\\nsort the sum of the interval positions and find the sum of top and bottom k-1. and find the difference\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long putMarbles(int[] w, int k) {\\n        for(int i=0;i<w.length-1;i++) w[i]+=w[i+1];\\n        w[w.length-1]=0;\\n        Arrays.sort(w);\\n        long sum=0;\\n        for(int i=1;i<k;i++) sum+=w[w.length-i]-w[i];\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] w, int k) {\\n        for(int i=0;i<w.length-1;i++) w[i]+=w[i+1];\\n        w[w.length-1]=0;\\n        Arrays.sort(w);\\n        long sum=0;\\n        for(int i=1;i<k;i++) sum+=w[w.length-i]-w[i];\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735125,
                "title": "typescript-two-priorityqueues-both-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. In the array, we get a composition of subarrays (bag-subarray) with only the head and tail elements and adjacent to each other.\\n2. In the result, both the head and tail elements of the whole array will be removed.\\n3. The rest of the selected element of the head and tail elements of the bags-subarrays are formed to the two-element subarrays, presenting the borders of the bags-subarray.\\n4. The border-subarrays can overlap with at most one elements.\\n5. The score can only be got from border-subarrays (border score)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize two PriorityQueues, one for the min values and the max ones\\n2. Iterate elements of `weights`\\n    1. For each index, sum the `i` one and `i + 1` one\\n    2. Collect the sum by both Min and Max PriorityQueues\\n3. Get the first `k - 1` elements of the PriorityQueues\\n4. Sum all the subtract result of the gotten max one and min one\\n\\n\\n# Complexity\\n- Time complexity:\\n  <!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  - $$O(n * log(n))$$\\n  - $$n$$ for the iteration of each elements, $$log(n)$$ for processing of the PriorityQueues\\n\\n- Space complexity:\\n  <!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n  - $$O(n)$$\\n  - Each PriorityQueue will store all of the elements of `weights`\\n\\n\\n# Code\\n```\\nfunction putMarbles(weights: number[], k: number): number {\\n    // In LeetCode \\n    // the version of datastructures-js/priority-queue is 5.3.0\\n    \\n    // @ts-ignore\\n    const maxPq = new MaxPriorityQueue<number>();\\n    // @ts-ignore\\n    const minPq = new MinPriorityQueue<number>();\\n\\n    for (let i = 0; i < weights.length - 1; i++) {\\n        const borderScore = weights[i] + weights[i + 1];\\n        maxPq.enqueue(borderScore);\\n        minPq.enqueue(borderScore);\\n    }\\n\\n    let result = 0;\\n    for (let i = 0; i < k - 1; i++) {\\n        const max = maxPq.dequeue().element;\\n        const min = minPq.dequeue().element;\\n        result += (max - min);\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nfunction putMarbles(weights: number[], k: number): number {\\n    // In LeetCode \\n    // the version of datastructures-js/priority-queue is 5.3.0\\n    \\n    // @ts-ignore\\n    const maxPq = new MaxPriorityQueue<number>();\\n    // @ts-ignore\\n    const minPq = new MinPriorityQueue<number>();\\n\\n    for (let i = 0; i < weights.length - 1; i++) {\\n        const borderScore = weights[i] + weights[i + 1];\\n        maxPq.enqueue(borderScore);\\n        minPq.enqueue(borderScore);\\n    }\\n\\n    let result = 0;\\n    for (let i = 0; i < k - 1; i++) {\\n        const max = maxPq.dequeue().element;\\n        const min = minPq.dequeue().element;\\n        result += (max - min);\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3735029,
                "title": "c-solution-using-priorityqueue-greedy-o-nlogn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhen diving stones in k bags, basically we need k subarrays and for k subarrays we need to consider the points where the array is partitioned into subarray.\\ne.g.\\n\\n[1,3,5] => [1|3,5]\\n\\nSo, in above example we need to consider the elements before and after the partition(i.e. 1 and 3).\\n\\nHence, we can store the sum of all such partitions in PrioritityQueues (minHeap and maxHeap)\\n\\nGet k elements from both PriorityQueues and difference of sum of these k-1 elements will be the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public long PutMarbles(int[] weights, int k) {\\n        PriorityQueue<int, int> max = new PriorityQueue<int, int>();\\n        PriorityQueue<int, int> min = new PriorityQueue<int, int>();\\n\\n        for(int i=0; i<weights.Length-1; i++){\\n            int sum = weights[i] + weights[i+1];\\n            max.Enqueue(sum, -sum);\\n            min.Enqueue(sum, sum);\\n        }\\n\\n        long maxSum = 0;\\n        long minSum = 0;\\n\\n        for(int i=0; i<k-1; i++){\\n            maxSum += max.Dequeue();\\n            minSum += min.Dequeue();\\n        }\\n\\n        return maxSum - minSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public long PutMarbles(int[] weights, int k) {\\n        PriorityQueue<int, int> max = new PriorityQueue<int, int>();\\n        PriorityQueue<int, int> min = new PriorityQueue<int, int>();\\n\\n        for(int i=0; i<weights.Length-1; i++){\\n            int sum = weights[i] + weights[i+1];\\n            max.Enqueue(sum, -sum);\\n            min.Enqueue(sum, sum);\\n        }\\n\\n        long maxSum = 0;\\n        long minSum = 0;\\n\\n        for(int i=0; i<k-1; i++){\\n            maxSum += max.Dequeue();\\n            minSum += min.Dequeue();\\n        }\\n\\n        return maxSum - minSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735011,
                "title": "simple-solution-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        for(int i=0;i<weights.length-1;i++){\\n            arr.add(weights[i]+weights[i+1]);\\n        }\\n        Collections.sort(arr);\\n        long minimum=0;\\n        long maximum=0;\\n        for(int i=0;i<k-1;i++){\\n            minimum+=arr.get(i);\\n            maximum+=arr.get(arr.size()-1-i);\\n        } \\n        return maximum-minimum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        for(int i=0;i<weights.length-1;i++){\\n            arr.add(weights[i]+weights[i+1]);\\n        }\\n        Collections.sort(arr);\\n        long minimum=0;\\n        long maximum=0;\\n        for(int i=0;i<k-1;i++){\\n            minimum+=arr.get(i);\\n            maximum+=arr.get(arr.size()-1-i);\\n        } \\n        return maximum-minimum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734939,
                "title": "c-greedy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        if(k==1)return 0;\\n        vector<long long>parti;\\n        for(int i=1;i<weights.size();i++){\\n            parti.push_back(weights[i-1]+weights[i]);\\n        }\\n        sort(parti.begin(),parti.end());\\n        long long mini=0,maxi=0;\\n        k--;\\n        for(int i=0;i<k;i++){\\n            mini+=parti[i];\\n            maxi+=parti[parti.size()-1-i];\\n        }\\n        return maxi-mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        if(k==1)return 0;\\n        vector<long long>parti;\\n        for(int i=1;i<weights.size();i++){\\n            parti.push_back(weights[i-1]+weights[i]);\\n        }\\n        sort(parti.begin(),parti.end());\\n        long long mini=0,maxi=0;\\n        k--;\\n        for(int i=0;i<k;i++){\\n            mini+=parti[i];\\n            maxi+=parti[parti.size()-1-i];\\n        }\\n        return maxi-mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734816,
                "title": "dart-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Sorting\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\cdot\\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int putMarbles(List<int> weights, int k) {\\n    int n = weights.length;\\n    final pairWeights = List<int>.filled(n - 1, 0);\\n    for (int i = 0; i < n - 1; i++) {\\n      pairWeights[i] = weights[i] + weights[i + 1];\\n    }\\n    pairWeights.sort();\\n    int result = 0;\\n    for (int i = 0; i < k - 1; i++) {\\n      result += pairWeights[n - 2 - i] - pairWeights[i];\\n    }\\n    return result;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int putMarbles(List<int> weights, int k) {\\n    int n = weights.length;\\n    final pairWeights = List<int>.filled(n - 1, 0);\\n    for (int i = 0; i < n - 1; i++) {\\n      pairWeights[i] = weights[i] + weights[i + 1];\\n    }\\n    pairWeights.sort();\\n    int result = 0;\\n    for (int i = 0; i < k - 1; i++) {\\n      result += pairWeights[n - 2 - i] - pairWeights[i];\\n    }\\n    return result;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734735,
                "title": "java-solution-with-proper-explanation-and-examples",
                "content": "**Intution**\\nFirst and last element are always included \\nIf a partition is made at index i then ith and i+1th element will be in the ans \\n![image](https://assets.leetcode.com/users/images/da418925-0075-4995-bb1c-e3f7041a255d_1688792933.6068158.png)\\n![image](https://assets.leetcode.com/users/images/a5f40dd1-2ff7-4091-a2ae-6c28c2776ee0_1688792941.5950904.png)\\n```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        ArrayList<Integer>cost=new ArrayList<>();\\n        if(k==1||k==weights.length)//if k==1 then no partitions need to be made then the sum for max and min remains same so it results to 0  similarly if k==n then partition needs to be made after every element in case of min as well as max so it also results in ans=0\\n            return 0L;\\n        //storing the sum of all consecutive pairs\\n        for(int i=0;i<weights.length-1;i++)\\n        {\\n            cost.add(weights[i]+weights[i+1]);\\n        }\\n        //sorting the array\\n        Collections.sort(cost);\\n        long ans=0;\\n        int len=cost.size();\\n        //we need to pick first k-1 pairs for min ans and last k-1 pairs for max ans\\n        for(int i=0;i<k-1;i++)\\n        {\\n            //cost(len-i-1)is the cost for max \\n            ans+=(cost.get(len-i-1)-cost.get(i));\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**Do upvote if you find it useful**",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        ArrayList<Integer>cost=new ArrayList<>();\\n        if(k==1||k==weights.length)//if k==1 then no partitions need to be made then the sum for max and min remains same so it results to 0  similarly if k==n then partition needs to be made after every element in case of min as well as max so it also results in ans=0\\n            return 0L;\\n        //storing the sum of all consecutive pairs\\n        for(int i=0;i<weights.length-1;i++)\\n        {\\n            cost.add(weights[i]+weights[i+1]);\\n        }\\n        //sorting the array\\n        Collections.sort(cost);\\n        long ans=0;\\n        int len=cost.size();\\n        //we need to pick first k-1 pairs for min ans and last k-1 pairs for max ans\\n        for(int i=0;i<k-1;i++)\\n        {\\n            //cost(len-i-1)is the cost for max \\n            ans+=(cost.get(len-i-1)-cost.get(i));\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734705,
                "title": "step-by-step-solution-with-intuition-and-video-explanation",
                "content": "[https://youtu.be/bamO8wmsRSg]()\\n\\n# Complexity\\n- Time complexity:\\n    nlong\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        if(n<=k) return 0;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i=1;i<n;i++){\\n            list.add(weights[i]+weights[i-1]);\\n        }\\n        Collections.sort(list);\\n\\n        long min = 0;\\n        long max = 0;\\n\\n        for(int i=1;i<k;i++){\\n            min += list.get(i-1);\\n            max += list.get(n-1-i);\\n        }\\n\\n        return max-min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        if(n<=k) return 0;\\n        \\n        List<Integer> list = new ArrayList<>();\\n        for(int i=1;i<n;i++){\\n            list.add(weights[i]+weights[i-1]);\\n        }\\n        Collections.sort(list);\\n\\n        long min = 0;\\n        long max = 0;\\n\\n        for(int i=1;i<k;i++){\\n            min += list.get(i-1);\\n            max += list.get(n-1-i);\\n        }\\n\\n        return max-min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734642,
                "title": "c-sol-explanation-code-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem optimally, I have used **Greedy approach**. \\nWe could use **Dynamic Programming** also, as **we have to divide the array into k subarrays**. We need to put (k-1)partitions in (n-1) locations. While placing a partition we have always the option of placing it after a index (let\\'s say idx) or we can also place it after idx+1. \\nSo we have two chose between options which we use in DP. If we are given n and k, then we need to place k-1 partitions in n-1 locations.\\nBut this approach will have the time complexity of **(n-1)C(k-1)** which is exponential.\\n**So the Greedy approach seems better** to think about right now.\\n- If we read the problem, we understand that I should be only concerned with the maximum and minimum sum.\\n- And  the sums are the summation of the k pairs which consists of the first and last elements of each k subarray.\\n***If the array input is :-***\\na   b   c   d   e   f   g\\nand k = 3.\\nAnd if i just randomly partition it in following way:-\\na   b   |   c   d   e   |   f   g\\nThe summation will be (a+b) + (c+e) + (f+g)\\n**You can partition it in any way and you will oberve few points such as -** \\n- The sum always consists of the last and first element of array.\\n- The remaining elements (in the sum) are in pairs of adjacent elements such as (b,c),(e,f).\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- So why don\\'t we just find out the summation of all the adjacent element pairs and push them into a new vector. And then we can just sort the **new vector** and find the summation of the **smallest and biggest k-1 pairs**.\\n- If array is a,b,c,d,e,f,g. Push (a+b,b+c,c+d,e+f,f+g) and sort the vector. \\n- And our answer will be the difference between the biggest k-1 pairs summation and smallest k-1 pairs summation solution.\\n\\n# Complexity\\nLet n be the length of the weights array.\\n\\nSorting the \"new\" vector takes O(nlogn) time complexity.\\nThe iteration to calculate the minimum and maximum scores takes O(k) time complexity.\\nThus, the overall time complexity of the solution is O(nlogn).\\nThe space complexity is O(n) to store the \"new\" vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        vector<int> pairs;\\n        for (int i = 0; i < n-1; i++)\\n            pairs.push_back(weights[i] + weights[i+1]);\\n        sort(pairs.begin(), pairs.end());\\n        long long mini = 0, maxi = 0;\\n        for (int i = 0; i < k-1; i++){\\n            mini += pairs[i];\\n            maxi += pairs[n-2-i];\\n        }\\n        return maxi - mini;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        vector<int> pairs;\\n        for (int i = 0; i < n-1; i++)\\n            pairs.push_back(weights[i] + weights[i+1]);\\n        sort(pairs.begin(), pairs.end());\\n        long long mini = 0, maxi = 0;\\n        for (int i = 0; i < k-1; i++){\\n            mini += pairs[i];\\n            maxi += pairs[n-2-i];\\n        }\\n        return maxi - mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734603,
                "title": "simple-easy-to-understand-solution-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long putMarbles(int[] W, int k) {\\n        int n = W.length;\\n        int [] pairs = new int[n-1];\\n        for(int i = 1;i<n;i++){\\n            pairs[i-1] = W[i]+W[i-1];\\n        }\\n        Arrays.sort(pairs);\\n        long min = 0;long max = 0;\\n        for(int i = 0;i<k-1;i++){\\n            min+=pairs[i];\\n            max+=pairs[n-i-2];\\n        }\\n        return max-min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] W, int k) {\\n        int n = W.length;\\n        int [] pairs = new int[n-1];\\n        for(int i = 1;i<n;i++){\\n            pairs[i-1] = W[i]+W[i-1];\\n        }\\n        Arrays.sort(pairs);\\n        long min = 0;long max = 0;\\n        for(int i = 0;i<k-1;i++){\\n            min+=pairs[i];\\n            max+=pairs[n-i-2];\\n        }\\n        return max-min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734586,
                "title": "q2551-accepted-c-greedy-heap-easiest-method",
                "content": "CRUX\\n1) We need to find the maximum and minimum weights [Acc. to the criteria] and return the difference.\\n2) Point to observe, the element left and right to the partition would always be included.\\n3) Example: 1 2 3 4 5 6 7 8 9 , k =3    1 2 3 | 4 5 6 7 | 8 9 , (1+3) + (4+7) + (8+9). Notice that start and end would always be the part of maxSum and minSum, therefore it will not create differentiation in the answer. \\n4) But consider the above sum as (3+4) + (7+8)  its the sum of sonsecutive terms.\\n5) Put them into maxHeap and minHeap and calculate the sum till (k-1).\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        priority_queue <int> maxh;\\n        priority_queue <int,vector<int>,greater<int>> minh;\\n        for(int i=1;i<n;i++){\\n            maxh.push(weights[i]+weights[i-1]);\\n            minh.push(weights[i]+weights[i-1]);\\n        }\\n        long long maxSum = 0;\\n        long long minSum = 0;\\n        k--;\\n        while(k--){\\n            maxSum += maxh.top();\\n            maxh.pop();\\n            minSum +=minh.top();\\n            minh.pop();\\n        }\\n        return maxSum - minSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        priority_queue <int> maxh;\\n        priority_queue <int,vector<int>,greater<int>> minh;\\n        for(int i=1;i<n;i++){\\n            maxh.push(weights[i]+weights[i-1]);\\n            minh.push(weights[i]+weights[i-1]);\\n        }\\n        long long maxSum = 0;\\n        long long minSum = 0;\\n        k--;\\n        while(k--){\\n            maxSum += maxh.top();\\n            maxh.pop();\\n            minSum +=minh.top();\\n            minh.pop();\\n        }\\n        return maxSum - minSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734582,
                "title": "simple-c-code-0-nlogk-time-complexity",
                "content": "# Complexity\\n- Time complexity: **0(nlogk)** As we maintain the **k** size priority queue\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:**0(k)**  size of priority queue\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        if(k==1||n==k)return 0;\\n        priority_queue<long long>mxpq;\\n        priority_queue<long long,vector<long long>,greater<long long>>mnpq;\\n        for(int i=0;i<n-1;i++){\\n            mxpq.push(weights[i]+weights[i+1]);\\n            mnpq.push(weights[i]+weights[i+1]);\\n            if(i>=k-1){\\n                mxpq.pop(),mnpq.pop();\\n            }\\n        }\\n        \\n        long long ans1=0,ans2=0;\\n        for(int i=0;i<k-1;i++){\\n           ans1+=mnpq.top();\\n           ans2+=mxpq.top();\\n           mnpq.pop(),mxpq.pop();\\n        }\\n        return abs(ans1-ans2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        if(k==1||n==k)return 0;\\n        priority_queue<long long>mxpq;\\n        priority_queue<long long,vector<long long>,greater<long long>>mnpq;\\n        for(int i=0;i<n-1;i++){\\n            mxpq.push(weights[i]+weights[i+1]);\\n            mnpq.push(weights[i]+weights[i+1]);\\n            if(i>=k-1){\\n                mxpq.pop(),mnpq.pop();\\n            }\\n        }\\n        \\n        long long ans1=0,ans2=0;\\n        for(int i=0;i<k-1;i++){\\n           ans1+=mnpq.top();\\n           ans2+=mxpq.top();\\n           mnpq.pop(),mxpq.pop();\\n        }\\n        return abs(ans1-ans2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734508,
                "title": "dart-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n  int putMarbles(List<int> weights, int k) {\\n    if (--k == 0) return 0;\\n\\n    List<int> adjs = [];\\n    for (int i = 1; i < weights.length; i++)\\n      adjs.add(weights[i - 1] + weights[i]);\\n\\n    adjs.sort();\\n\\n    var res = 0;\\n\\n    for (int i = adjs.length - 1; i >= adjs.length - k; i--)\\n      res += adjs[i];\\n    for (int i = 0; i < k; i++)\\n      res -= adjs[i];\\n\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int putMarbles(List<int> weights, int k) {\\n    if (--k == 0) return 0;\\n\\n    List<int> adjs = [];\\n    for (int i = 1; i < weights.length; i++)\\n      adjs.add(weights[i - 1] + weights[i]);\\n\\n    adjs.sort();\\n\\n    var res = 0;\\n\\n    for (int i = adjs.length - 1; i >= adjs.length - k; i--)\\n      res += adjs[i];\\n    for (int i = 0; i < k; i++)\\n      res -= adjs[i];\\n\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734482,
                "title": "kotlin-priorityqueue",
                "content": "![image.png](https://assets.leetcode.com/users/images/0266de8c-9c1b-4ebf-87ac-b370530136f4_1688788395.230992.png)\\n#### Join me on Telegram\\nhttps://t.me/leetcode_daily_unstoppable/269\\n#### Problem TLDR\\n`abs(max - min)`, where `max` and `min` are the sum of `k` interval borders\\n#### Intuition\\nLet\\'s observe some examples:\\n```\\n        // 1 3 2 3 5 4 5 7 6\\n        // *   * *   \\n        // 1+3 2+2 3+6 = 4+4+9 = 17\\n        // * * *\\n        // 1+1 3+3 2+6 = 2+6+8 = 16\\n        // *             * * = 1+5 7+7 6+6\\n        // 1 9 1 9 1 9 1 9 1    k = 3\\n        // *   *           *    s = 1+9+1+9+1+1\\n        // * *   *              s = 1+1+9+1+9+1\\n        // 1 1 9 9 1 1 9 9 1    k = 3\\n        // * *       *          s = 1+1+1+1+1+1\\n        // *     *       *      s = 1+9+9+9+9+1\\n        // 1 1 1 9 1 9 9 9 1    k = 3\\n        // * * *                s = 1+1+1+1+1+1\\n        // *         . * *      s = 1+9+9+9+9+1\\n        // 1 4 2 5 2            k = 3\\n        // . * . *              1+1+4+2+5+2\\n        //   . * *              1+4+2+2+5+2\\n        // . *   . *            1+1+4+5+2+2\\n```\\nOne thing to note, we must choose `k-1` border pairs `i-1, i` with `min` or `max` sum.\\n\\n#### Approach\\nLet\\'s use PriorityQueue.\\n#### Complexity\\n- Time complexity:\\n$$O(nlog(k))$$\\n- Space complexity:\\n$$O(k)$$\\n#### Code\\n```\\n    fun putMarbles(weights: IntArray, k: Int): Long {\\n\\n        val pqMax = PriorityQueue<Int>(compareBy( { weights[it].toLong() + weights[it - 1].toLong() } ))\\n        val pqMin = PriorityQueue<Int>(compareByDescending( { weights[it].toLong() + weights[it - 1].toLong() } ))\\n        for (i in 1..weights.lastIndex) {\\n          pqMax.add(i)\\n          if (pqMax.size > k - 1) pqMax.poll()\\n          pqMin.add(i)\\n          if (pqMin.size > k - 1) pqMin.poll()\\n        }\\n        return Math.abs(pqMax.map { weights[it].toLong() + weights[it - 1].toLong() }.sum()!! - \\n                        pqMin.map { weights[it].toLong() + weights[it - 1].toLong() }.sum()!!)\\n    }\\n\\n```\\n#### Bonus\\nQuickselect solution\\n![image.png](https://assets.leetcode.com/users/images/505d42fb-4329-48af-84cf-f7041ecce893_1688836158.62454.png)\\n\\n",
                "solutionTags": [
                    "Kotlin",
                    "Heap (Priority Queue)",
                    "Quickselect"
                ],
                "code": "```\\n        // 1 3 2 3 5 4 5 7 6\\n        // *   * *   \\n        // 1+3 2+2 3+6 = 4+4+9 = 17\\n        // * * *\\n        // 1+1 3+3 2+6 = 2+6+8 = 16\\n        // *             * * = 1+5 7+7 6+6\\n        // 1 9 1 9 1 9 1 9 1    k = 3\\n        // *   *           *    s = 1+9+1+9+1+1\\n        // * *   *              s = 1+1+9+1+9+1\\n        // 1 1 9 9 1 1 9 9 1    k = 3\\n        // * *       *          s = 1+1+1+1+1+1\\n        // *     *       *      s = 1+9+9+9+9+1\\n        // 1 1 1 9 1 9 9 9 1    k = 3\\n        // * * *                s = 1+1+1+1+1+1\\n        // *         . * *      s = 1+9+9+9+9+1\\n        // 1 4 2 5 2            k = 3\\n        // . * . *              1+1+4+2+5+2\\n        //   . * *              1+4+2+2+5+2\\n        // . *   . *            1+1+4+5+2+2\\n```\n```\\n    fun putMarbles(weights: IntArray, k: Int): Long {\\n\\n        val pqMax = PriorityQueue<Int>(compareBy( { weights[it].toLong() + weights[it - 1].toLong() } ))\\n        val pqMin = PriorityQueue<Int>(compareByDescending( { weights[it].toLong() + weights[it - 1].toLong() } ))\\n        for (i in 1..weights.lastIndex) {\\n          pqMax.add(i)\\n          if (pqMax.size > k - 1) pqMax.poll()\\n          pqMin.add(i)\\n          if (pqMin.size > k - 1) pqMin.poll()\\n        }\\n        return Math.abs(pqMax.map { weights[it].toLong() + weights[it - 1].toLong() }.sum()!! - \\n                        pqMin.map { weights[it].toLong() + weights[it - 1].toLong() }.sum()!!)\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3734400,
                "title": "python-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        if k == 1 or k == len(weights): return 0\\n        cut_index = len(weights) - 1\\n        res = 0\\n        arr = [0]*cut_index\\n        for i in range(cut_index):\\n            arr[i] = weights[i] + weights[i+1]\\n        arr.sort()\\n        # only need cut k-1 time, so k-1 cut \\n        for i in range(k-1):\\n            # each result is max - min,and since max is starting from last index, which is cut_index-1 in python\\n            # as the arr is length of cut_index\\n            res += arr[cut_index-1-i] - arr[i]\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        if k == 1 or k == len(weights): return 0\\n        cut_index = len(weights) - 1\\n        res = 0\\n        arr = [0]*cut_index\\n        for i in range(cut_index):\\n            arr[i] = weights[i] + weights[i+1]\\n        arr.sort()\\n        # only need cut k-1 time, so k-1 cut \\n        for i in range(k-1):\\n            # each result is max - min,and since max is starting from last index, which is cut_index-1 in python\\n            # as the arr is length of cut_index\\n            res += arr[cut_index-1-i] - arr[i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734396,
                "title": "2-approches-easy-to-understand-c-greedy",
                "content": "### Connect with me on LinkedIn : https://www.linkedin.com/in/aditya-jhunjhunwala-51b586195/\\n# Complexity\\n```\\n- Time complexity:\\n1st Approach : O(nlogn)\\n2nd Approach : O(nlogk)\\n```\\n\\n```\\n- Space complexity:\\nO(n)\\n```\\n\\n# Code\\n## **Please Upvote if u liked my Solution**\\uD83E\\uDD17\\n# 1st Approach(Sorting):-\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        long maxi=0,mini=0;\\n        if(n==k)\\n            return 0;\\n        vector<int> vec(n-1);\\n        for(int i=1;i<n;i++)\\n            vec[i-1]=weights[i]+weights[i-1];\\n        sort(vec.begin(),vec.end());\\n        for(int i=0;i<k-1;i++){\\n            mini+=vec[i];\\n            maxi+=vec[n-i-2];  //(n-i-2)=({n-1}-i-1)\\n        }\\n        return maxi-mini;\\n    }\\n};\\n```\\n# 2nd Approach(Using MaxHeap & MinHeap):-\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        priority_queue<long,vector<long>,greater<long>> minPQ;\\n        priority_queue<long> maxPQ;\\n        int n = weights.size(), x = 0;\\n        long maxi = 0, mini = 0;\\n        for(int i = 0 ; i < n - 1 ; i++){\\n            x = weights[i] + weights[i + 1];\\n            minPQ.push(x);\\n            maxPQ.push(x);\\n            if(minPQ.size() > k - 1){\\n                minPQ.pop();\\n                maxPQ.pop();\\n            }\\n        }\\n        while(maxPQ.size()){\\n            mini += maxPQ.top();\\n            maxi += minPQ.top();\\n            maxPQ.pop();\\n            minPQ.pop();\\n        }\\n        return maxi - mini;\\n    }\\n};\\n```\\n![e2515d84-99cf-4499-80fb-fe458e1bbae2_1678932606.8004954.png](https://assets.leetcode.com/users/images/a9a03ac7-d366-4672-9dd9-76d65668e2fb_1688786666.6043673.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n- Time complexity:\\n1st Approach : O(nlogn)\\n2nd Approach : O(nlogk)\\n```\n```\\n- Space complexity:\\nO(n)\\n```\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        long maxi=0,mini=0;\\n        if(n==k)\\n            return 0;\\n        vector<int> vec(n-1);\\n        for(int i=1;i<n;i++)\\n            vec[i-1]=weights[i]+weights[i-1];\\n        sort(vec.begin(),vec.end());\\n        for(int i=0;i<k-1;i++){\\n            mini+=vec[i];\\n            maxi+=vec[n-i-2];  //(n-i-2)=({n-1}-i-1)\\n        }\\n        return maxi-mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        priority_queue<long,vector<long>,greater<long>> minPQ;\\n        priority_queue<long> maxPQ;\\n        int n = weights.size(), x = 0;\\n        long maxi = 0, mini = 0;\\n        for(int i = 0 ; i < n - 1 ; i++){\\n            x = weights[i] + weights[i + 1];\\n            minPQ.push(x);\\n            maxPQ.push(x);\\n            if(minPQ.size() > k - 1){\\n                minPQ.pop();\\n                maxPQ.pop();\\n            }\\n        }\\n        while(maxPQ.size()){\\n            mini += maxPQ.top();\\n            maxi += minPQ.top();\\n            maxPQ.pop();\\n            minPQ.pop();\\n        }\\n        return maxi - mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734369,
                "title": "c-easy-to-understand-beats-90",
                "content": "# Complexity\\n- Time complexity:\\nO(n.log(n))\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        vector<int> pairWeights(n - 1, 0);\\n        for (int i = 0; i < n - 1; i++) {\\n            pairWeights[i] += weights[i] + weights[i + 1];\\n        }\\n\\n        sort(pairWeights.begin(), pairWeights.end());\\n\\n        long long result = 0;\\n        for (int i = 0; i < k - 1; i++) {\\n            result += pairWeights[n - 2 - i] - pairWeights[i];\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        vector<int> pairWeights(n - 1, 0);\\n        for (int i = 0; i < n - 1; i++) {\\n            pairWeights[i] += weights[i] + weights[i + 1];\\n        }\\n\\n        sort(pairWeights.begin(), pairWeights.end());\\n\\n        long long result = 0;\\n        for (int i = 0; i < k - 1; i++) {\\n            result += pairWeights[n - 2 - i] - pairWeights[i];\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734299,
                "title": "c-beginner-friendly-solution-with-explanation",
                "content": "# Approach\\n- We can reframe the problem statement like this we need to find `K` subarrays such that sum of costs of all subarrays is minimum inorder to find minimum cost and should be maximum to find maximum cost. \\n\\n- To get `K` subarrays we need to make `K-1` cuts and let say we make the cut at `i-th` index then `weights[i-1]` will be the last element of left subarray and `weights[i]` will be the first element of right subarray.\\n- So __Cost__ would be equals to `weights[0] + (weights[i1-1] + weights[i1]) + (weights[i2-1] + weights[i2]) + ..(k-1 pairs)... + weights[n-1]`\\n- To find minimum cost we wants such `(k-1)` consecutive pairs having __minimum sum__.\\n- To find maximum cost we wants such `(k-1)` consecutive pair having __maximum sum__.\\n- Difference between maximum cost - minimum cost will be our answer.\\n\\n# Video Explanation\\nWatch my youtube video for better and clear understanding of the concept. I will guarantee you if you watch the complete video you will able to solve this problem.\\n\\n[https://www.youtube.com/watch?v=Nd7ICvSmstw]()\\n\\n\\n# Code 1: (using sorting)\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long minans = weights[0] + weights[weights.size()-1];\\n        long long maxans = minans;\\n        priority_queue<int> pqmax;\\n        priority_queue<int, vector<int>, greater<int>> pqmin;\\n        for(int i=1;i<weights.size();i++)\\n        {\\n            pqmin.push(weights[i] + weights[i-1]);\\n            pqmax.push(weights[i] + weights[i-1]);\\n        } \\n        for(int i=1;i<k;i++)\\n        {\\n            minans += pqmin.top();\\n            maxans += pqmax.top();\\n            pqmin.pop();\\n            pqmax.pop();\\n        }\\n        return (maxans - minans);\\n    }\\n};\\n```\\n\\n# Code 2: (using priority queue)\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<int> v;\\n        for(int i=1;i<weights.size();i++)\\n        {\\n            v.push_back(weights[i] + weights[i-1]);\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        long long lo = 0,up = 0;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            lo += v[i];\\n            up += v[(v.size()-1-i)];\\n        }\\n        return (up - lo);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Sort",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long minans = weights[0] + weights[weights.size()-1];\\n        long long maxans = minans;\\n        priority_queue<int> pqmax;\\n        priority_queue<int, vector<int>, greater<int>> pqmin;\\n        for(int i=1;i<weights.size();i++)\\n        {\\n            pqmin.push(weights[i] + weights[i-1]);\\n            pqmax.push(weights[i] + weights[i-1]);\\n        } \\n        for(int i=1;i<k;i++)\\n        {\\n            minans += pqmin.top();\\n            maxans += pqmax.top();\\n            pqmin.pop();\\n            pqmax.pop();\\n        }\\n        return (maxans - minans);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<int> v;\\n        for(int i=1;i<weights.size();i++)\\n        {\\n            v.push_back(weights[i] + weights[i-1]);\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        long long lo = 0,up = 0;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            lo += v[i];\\n            up += v[(v.size()-1-i)];\\n        }\\n        return (up - lo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734252,
                "title": "python-sorting-explained-clean-code-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\nWe can convert this problem to putting \"dividers\" between each pair of numbers.\\n\\n# Approach\\n- Create a list storing the sum of both sides of dividers.\\n- Sort the list.\\n- Answer will be largest `k-1` elements in list minus smallest `k-1` elements.\\n- The head and tail of `weights` is counted in both minimum score and maximum score so we don\\'t need to worry about it.\\n\\n# Complexity\\n- Time complexity: $O(n\\\\log n)$\\n\\n- Space complexity: $O(n)$\\n\\n# Code\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        # list of \"dividers\"\\n        v = []\\n        n = len(weights)\\n        \\n        for i in range(n-1):\\n            v.append(weights[i] + weights[i+1])\\n        \\n        v.sort()\\n\\n        return sum(v[n-k:]) - sum(v[:k-1])\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        # list of \"dividers\"\\n        v = []\\n        n = len(weights)\\n        \\n        for i in range(n-1):\\n            v.append(weights[i] + weights[i+1])\\n        \\n        v.sort()\\n\\n        return sum(v[n-k:]) - sum(v[:k-1])\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734234,
                "title": "simple-c-code-with-intution",
                "content": "# Intuition\\n1.create a minheap and a max heap.\\n2.store the sum of consecutive elements.\\n3.if the size exceeds (k-1). then pop an item.\\n4.the sum of elements in both min and max heap are scores of two bags.\\n5.return difference between them.\\n# Approach\\nIf we pick an index i as starting point then (i-1) is the ending point. ans as we know both are included in the score.0th and (n-1)th are starting and ending points in every case. so while caluclating difference they are ignored.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogk)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        priority_queue<int> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n        for(int i=1;i<n;i++){\\n            pq1.push(weights[i-1]+weights[i]);\\n            pq2.push(weights[i-1]+weights[i]);\\n            if(pq1.size()>k-1)\\n            pq1.pop();\\n             if(pq2.size()>k-1)\\n            pq2.pop();\\n        }\\n        long long s1=0,s2=0;\\n        while(!pq1.empty()){\\n            s1+=pq1.top();\\n            s2+=pq2.top();\\n            pq1.pop();\\n            pq2.pop();\\n        }\\n        return abs(s1-s2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        priority_queue<int> pq1;\\n        priority_queue<int,vector<int>,greater<int>> pq2;\\n        for(int i=1;i<n;i++){\\n            pq1.push(weights[i-1]+weights[i]);\\n            pq2.push(weights[i-1]+weights[i]);\\n            if(pq1.size()>k-1)\\n            pq1.pop();\\n             if(pq2.size()>k-1)\\n            pq2.pop();\\n        }\\n        long long s1=0,s2=0;\\n        while(!pq1.empty()){\\n            s1+=pq1.top();\\n            s2+=pq2.top();\\n            pq1.pop();\\n            pq2.pop();\\n        }\\n        return abs(s1-s2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734220,
                "title": "go-just-a-thinking-pattern",
                "content": "# Intuition\\n- Put marbles to K bags is like starting from 1 bag and keep separating them until K. \\n- Separating a bag is like creating a cutting point and the adjacent weights are added to the total weight.\\n- The first weight and last weigth will always be there, because they will be in bags.\\n\\n# Approach\\nSo just create an (n-1) length array containing the sum of 2 consecutive weights.\\nMax will be the sum of `K` biggest numbers\\nMin will be the sum of `K` smallest numbers\\n\\n# Complexity\\n- Time complexity: $$O(n*logn)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nfunc putMarbles(weights []int, k int) int64 {\\n    n := len(weights)\\n\\n    if k == 1 {\\n        return int64(0)\\n    }\\n\\n\\n    max := 0\\n    min := 0\\n\\n    think := make([]int, n-1)\\n    for i:=0; i<n-1; i++ {\\n        think[i] = weights[i]+weights[i+1]\\n    }\\n\\n    sort.Ints(think)\\n    \\n    for i := 0; i<k-1; i++ {\\n        min += think[i] \\n    }\\n    for i := n-2; i>n-1-k; i-- {\\n        max += think[i] \\n    }\\n\\n    return int64(max - min)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc putMarbles(weights []int, k int) int64 {\\n    n := len(weights)\\n\\n    if k == 1 {\\n        return int64(0)\\n    }\\n\\n\\n    max := 0\\n    min := 0\\n\\n    think := make([]int, n-1)\\n    for i:=0; i<n-1; i++ {\\n        think[i] = weights[i]+weights[i+1]\\n    }\\n\\n    sort.Ints(think)\\n    \\n    for i := 0; i<k-1; i++ {\\n        min += think[i] \\n    }\\n    for i := n-2; i>n-1-k; i-- {\\n        max += think[i] \\n    }\\n\\n    return int64(max - min)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3734215,
                "title": "rust",
                "content": "Suppose we have a sequence: `a,....x,y,...,b` and plan to cut between `x` and `y`, we define this cut\\'s value is `x + y` because `new_sum = old_sum + x + y`.\\n\\nThen we can use priority queue to catch `big cut` for maximum result and `small cut` for mimimum result.\\n```\\nimpl Solution {\\n    pub fn put_marbles(weights: Vec<i32>, k: i32) -> i64 {\\n        use std::collections::BinaryHeap;\\n        use std::cmp::Reverse;\\n\\n        let mut a = BinaryHeap::with_capacity(weights.len() - 1);\\n        let mut b = BinaryHeap::with_capacity(weights.len() - 1);\\n\\n        for i in 1..weights.len() {\\n            a.push(weights[i] + weights[i - 1]);\\n            b.push(Reverse(weights[i] + weights[i - 1]));\\n        }\\n\\n        let mut min = (weights[0] + weights[weights.len() - 1]) as i64;\\n        let mut max = min;\\n\\n        for _ in 1..k {\\n            max += a.pop().unwrap() as i64;\\n            min += b.pop().unwrap().0 as i64;\\n        }\\n        max - min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn put_marbles(weights: Vec<i32>, k: i32) -> i64 {\\n        use std::collections::BinaryHeap;\\n        use std::cmp::Reverse;\\n\\n        let mut a = BinaryHeap::with_capacity(weights.len() - 1);\\n        let mut b = BinaryHeap::with_capacity(weights.len() - 1);\\n\\n        for i in 1..weights.len() {\\n            a.push(weights[i] + weights[i - 1]);\\n            b.push(Reverse(weights[i] + weights[i - 1]));\\n        }\\n\\n        let mut min = (weights[0] + weights[weights.len() - 1]) as i64;\\n        let mut max = min;\\n\\n        for _ in 1..k {\\n            max += a.pop().unwrap() as i64;\\n            min += b.pop().unwrap().0 as i64;\\n        }\\n        max - min\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3734170,
                "title": "typescript-solution-based-on-editorial",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Consider we have `n` marbles distributed in `k` bags. The start and end of each bag would be: \\n    - `bag[0]`: `weights[0], weights[a1]`\\n    - `bag[1]`: `weights[a1+1], weights[a2]`\\n    - ...\\n    - `bag[k-1]`: `weights[a(k-1)+1], weights[n-1]`\\n- Define the pairs as `pair[i] = weights[i] + weights[i+1]`, we would have `n-1` pairs, and the score would be `weights[0] + weights[n-1] + (k-1) pairs`. \\n- To get the maximum and minimum score, we need to sort the pairs first, and pick top and bottom `k-1` pairs. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Construct the `pairs` with `pair[i] = weights[i] + weights[i+1]`, then sort the `pairs` in ascending order. \\n2. Calculate the maximum and minimum score as `maxScore` and `minScore` by adding top and bottom `k-1` elements of `pairs`. \\n3. Return `maxScore - minScore`. \\n**Note:** You can try to combine them into one loop. \\n\\n# Complexity\\n- Time complexity: $$O(n \\\\cdot \\\\log n)$$\\n    - Construct `pairs`: $$O(n)$$\\n    - Sort `pairs`: $$O(n \\\\cdot \\\\log n)$$\\n    - Calculate `maxScore` and `minScore`: $$O(k)$$, k<n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n    - `pairs`: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction putMarbles(weights: number[], k: number): number {\\n    const pairs: number[] = [];\\n    const n = weights.length;\\n\\n    for(let i=0; i<n-1; i++){\\n        const pair = weights[i] + weights[i+1];\\n        pairs.push(pair);\\n    }\\n\\n    pairs.sort((x,y)=>x-y); // sort asc. \\n\\n    let minScore = weights[0] + weights[n-1]; \\n    for(let i=0; i<k-1; i++){\\n        minScore += pairs[i];\\n    }\\n\\n    let maxScore = weights[0] + weights[n-1]; \\n    for(let i=0; i<k-1; i++){\\n        maxScore += pairs[n-2-i];\\n    }\\n\\n    return maxScore - minScore\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nfunction putMarbles(weights: number[], k: number): number {\\n    const pairs: number[] = [];\\n    const n = weights.length;\\n\\n    for(let i=0; i<n-1; i++){\\n        const pair = weights[i] + weights[i+1];\\n        pairs.push(pair);\\n    }\\n\\n    pairs.sort((x,y)=>x-y); // sort asc. \\n\\n    let minScore = weights[0] + weights[n-1]; \\n    for(let i=0; i<k-1; i++){\\n        minScore += pairs[i];\\n    }\\n\\n    let maxScore = weights[0] + weights[n-1]; \\n    for(let i=0; i<k-1; i++){\\n        maxScore += pairs[n-2-i];\\n    }\\n\\n    return maxScore - minScore\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3734123,
                "title": "daily-leetcoding-challenge-july-day-8",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 8.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/put-marbles-in-bags/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sorting\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/put-marbles-in-bags/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3186840,
                "title": "swift-one-liner",
                "content": "**One-Liner, terse (accepted answer)**\\n```\\nclass Solution {\\n    func putMarbles(_ w: [Int], _ k: Int) -> Int {\\n        [zip(w,w[1...]).map{$0.0+$0.1}.sorted()].map{zip($0[0..<k-1],$0[w.count-k..<w.count-1]).reduce(0){$0+$1.1-$1.0}}[0]\\n    }\\n}\\n```\\n\\n---\\n\\n**One-Liner, expanded and annotated (accepted answer)**\\n```\\nclass Solution {\\n    func putMarbles(_ weights: [Int], _ k: Int) -> Int {\\n        [\\n            (0 ..< weights.count-1).reduce(into: [Int]()) { array, i in\\n                array.append(weights[i] + weights[i+1])\\n            }\\n            .sorted()\\n        ] // wrap result into one-element array to create monad\\n        .map { sortedSums in\\n\\t\\t\\t// just need to difference the sums, order is not really important\\n            zip(sortedSums[0 ..< k-1], sortedSums[weights.count-k ..< weights.count-1]) \\n              .reduce(0) { sum, tuple in\\n                let (minValue, maxValue) = tuple\\n                return sum + maxValue - minValue\\n              }\\n        }[0] // unwrap monad\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func putMarbles(_ w: [Int], _ k: Int) -> Int {\\n        [zip(w,w[1...]).map{$0.0+$0.1}.sorted()].map{zip($0[0..<k-1],$0[w.count-k..<w.count-1]).reduce(0){$0+$1.1-$1.0}}[0]\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func putMarbles(_ weights: [Int], _ k: Int) -> Int {\\n        [\\n            (0 ..< weights.count-1).reduce(into: [Int]()) { array, i in\\n                array.append(weights[i] + weights[i+1])\\n            }\\n            .sorted()\\n        ] // wrap result into one-element array to create monad\\n        .map { sortedSums in\\n\\t\\t\\t// just need to difference the sums, order is not really important\\n            zip(sortedSums[0 ..< k-1], sortedSums[weights.count-k ..< weights.count-1]) \\n              .reduce(0) { sum, tuple in\\n                let (minValue, maxValue) = tuple\\n                return sum + maxValue - minValue\\n              }\\n        }[0] // unwrap monad\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136136,
                "title": "intuitive-approach-and-then-optimization-greedy",
                "content": "// first as a usual i thought to do it by recursion +dp and i did the same\\uD83D\\uDE0A but only 93 test cases were passed out of 103\\uD83E\\uDD72 after that i thought of something like placing k-1 bars between n carpets and when u place a barr between any two caprpet let\\'s say i\\'th carpet then cost is increased by a[i]+a[i+1], so what if we slect some first k-1 largest pair of a[i]+a[i+1] ( k-1 bars are placed  because to devide array in k parts we need k-1 bars hence also k-1 largest pair of a[i]+a[i-1] ). \\n\\n// so first we will make a vector which will contain all a[i]+a[i+1] and then we will  sort it and then for max cost we will select last k-1 elements( beacuse of increasing order ) and then first k-1 element for min cost and take sum and return the difference \\n```\\n   # UPVOTE IF U LIKE THE APPROACH\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    \\n    // by perfect division of marbels in to k bags throught recursion even though it\\'s efficient more than expected\\n    /*\\n    \\n    \\n    int n;\\n    \\n    vector<vector<long long>> dp;\\n     vector<vector<long long>> dp1;\\n    long long solve (vector<int> &a, int i, int k)\\n    {\\n        if(k==0) return INT_MIN;\\n        if(i==n-1 && k==1) return a[i];\\n        else if(i==n-1 && k>1) return INT_MIN;\\n        \\n         if(dp[i][k]!=-1) return dp[i][k];\\n        if(i==0)\\n        {\\n           \\n            return  dp[i][k]= a[i]+max(solve(a,i+1,k-1)+a[i]+a[i+1],solve(a,i+1,k));\\n    \\n        }\\n        \\n        \\n       \\n        return dp[i][k]= max(solve(a,i+1,k-1)+a[i]+a[i+1],solve(a,i+1,k));\\n      \\n    }\\n    \\n    long long solve1 (vector<int> &a, int i, int k)\\n    {\\n         if(k==0) return INT_MAX;\\n        if(i==n-1 && k==1) return a[i];\\n        else if(i==n-1 && k>1) return INT_MAX;\\n       \\n          if(dp1[i][k]!=-1) return dp1[i][k];\\n        if(i==0)\\n        {\\n           \\n            return dp1[i][k]= a[i]+min(solve1(a,i+1,k-1)+a[i]+a[i+1],solve1(a,i+1,k));\\n           \\n        }\\n        \\n        \\n        //long long res=0;\\n       \\n        return dp1[i][k]= min(solve1(a,i+1,k-1)+a[i]+a[i+1],solve1(a,i+1,k));\\n      \\n        \\n    }\\n    long long putMarbles(vector<int>& a, int k) \\n    {\\n        n=a.size();\\n        dp.resize( n+1 , vector<long long>( n+1,-1) );\\n         dp1.resize( n+1 , vector<long long>( n+1,-1) );\\n\\n        cout<<solve(a,0,k)<<\"  \"<<solve1(a,0,k)<<endl;\\n        return solve(a,0,k)-solve1(a,0,k);\\n        \\n    }\\n    \\n    \\n    */\\n\\t\\n\\t\\n\\t// optimised version\\n    long long putMarbles(vector<int>& a, int k) \\n    {\\n        int n=a.size();\\n        if (k==1|k==n) return 0;\\n        \\n        vector<long long> v;\\n        for(int i=0; i<n-1; i++)\\n        {\\n            v.push_back(a[i]+a[i+1]);\\n        }\\n        \\n        sort(v.begin(),v.end());\\n        \\n        long  long maxi=0;\\n        long long mini=0;\\n        \\n        for(int i=0; i<k-1; i++) // to devide marbels in to k groups we need to pplace k\\n        {\\n            maxi+=v[n-2-i];\\n            mini+=v[i];\\n        }\\n        \\n        return maxi-mini;\\n        \\n    }\\n    \\n    \\n    \\n    \\n    \\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\n   # UPVOTE IF U LIKE THE APPROACH\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3122482,
                "title": "c-priority-queue-o-n-log-k",
                "content": "## Approach:\\n* We are only concerned about the start and end elements in bag\\n* If our starting and ending element of current bag are A[i] and A[j], then starting element of next bag is A[j+1]\\n* Try to maximize sum of `A[j]+A[j+1]` for **K-1** elements\\n* Total Score  = A[0] + max sum of `A[j]+A[j+1]` for `k-1` elements + A[n-1]\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        priority_queue<ll> qmin;\\n        priority_queue<ll,vector<ll>,greater<ll>> qmax;\\n        ll smin = nums[0]+nums[n-1], smax = nums[0]+nums[n-1];\\n        for(int i = 0; i<n-1;++i){\\n            qmin.push(nums[i]+nums[i+1]); qmax.push(nums[i]+nums[i+1]);\\n            smin+=nums[i]+nums[i+1],smax+=nums[i]+nums[i+1];\\n            if(qmin.size()>k-1){\\n                smin-=qmin.top(); qmin.pop();\\n            }\\n            if(qmax.size()>k-1){\\n                smax-=qmax.top(); qmax.pop();\\n            }\\n        }\\n        return smax-smin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        priority_queue<ll> qmin;\\n        priority_queue<ll,vector<ll>,greater<ll>> qmax;\\n        ll smin = nums[0]+nums[n-1], smax = nums[0]+nums[n-1];\\n        for(int i = 0; i<n-1;++i){\\n            qmin.push(nums[i]+nums[i+1]); qmax.push(nums[i]+nums[i+1]);\\n            smin+=nums[i]+nums[i+1],smax+=nums[i]+nums[i+1];\\n            if(qmin.size()>k-1){\\n                smin-=qmin.top(); qmin.pop();\\n            }\\n            if(qmax.size()>k-1){\\n                smax-=qmax.top(); qmax.pop();\\n            }\\n        }\\n        return smax-smin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113563,
                "title": "simple-commented-please-upvote",
                "content": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        \\n        if (w.size()==k || k==1)\\n            return 0;\\n        \\n        int n=w.size();\\n//         we need to select 2*k indices\\n//         we have to take first index and last index for sure \\n//         rest 2k-2 indexes are need to be selected \\n//         that means we need to select k-1 pairs adjacent\\n//         so we will create prefin array of adj sums \\n//         for maximum we will consider max pair and for min we will take min pair \\n        \\n        vector<long long int>ps1,ps2;\\n        for (int i=0;i<n-1;i++)\\n        {\\n            ps1.push_back(w[i+1]+w[i]);\\n            ps2.push_back(w[i+1]+w[i]);\\n        }\\n        sort(ps1.begin(),ps1.end());\\n        sort(ps2.begin(),ps2.end(),greater<int>());\\n        long long int ans=0;\\n        \\n        for (int i=0;i<k-1;i++)\\n        {\\n            ans+=ps2[i]-ps1[i];\\n        }\\n            \\n        return ans;\\n        \\n    }\\n};****please do upvote****\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        \\n        if (w.size()==k || k==1)\\n            return 0;\\n        \\n        int n=w.size();\\n//         we need to select 2*k indices\\n//         we have to take first index and last index for sure \\n//         rest 2k-2 indexes are need to be selected \\n//         that means we need to select k-1 pairs adjacent\\n//         so we will create prefin array of adj sums \\n//         for maximum we will consider max pair and for min we will take min pair \\n        \\n        vector<long long int>ps1,ps2;\\n        for (int i=0;i<n-1;i++)\\n        {\\n            ps1.push_back(w[i+1]+w[i]);\\n            ps2.push_back(w[i+1]+w[i]);\\n        }\\n        sort(ps1.begin(),ps1.end());\\n        sort(ps2.begin(),ps2.end(),greater<int>());\\n        long long int ans=0;\\n        \\n        for (int i=0;i<k-1;i++)\\n        {\\n            ans+=ps2[i]-ps1[i];\\n        }\\n            \\n        return ans;\\n        \\n    }\\n};****please do upvote****\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112320,
                "title": "best-ever-solution",
                "content": "# Intuition\\nJust think for a time what we are doing in this problem \\ni)for maximum we are just finding the k points where i and i+1 are maximum \\nii)for minimum we are just finding the k points where i and i+1 are minimum \\n\\nDon\\'t worry what i wrote above, i understand \\uD83D\\uDE08 take a look on below example.\\n\\n[1,3,5,1],k=2\\n\\nfind those indices where i and i+1 are maximum for that we just make a array for two consecutive array sum indices\\n\\n[4,8,6]\\n\\nsort this array : [4,6,8]\\n\\nwe have take k=2 cut points where sum is maximum means just we have to find maximum beacuse this array contains all i and i+1 sum where we get maximum and where we got minimum \\n\\njust take k-1 points from this array for minimum \\n\\nagain sort this array in descending order and take k-1 points for maximum.\\n\\nfor above example \\nminimum for k=2:=  4\\nmaximum for k=2:=  8\\n\\nreturn maximum-minimum==>>>(8-4)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:O(nlogn) for sorting \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n) for tracking of two consecutive \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nusing ll=long long;\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& wei, int k) {\\n        vector<ll> v;\\n        int n=wei.size();\\n        for(int i=1; i<n; i++)\\n        {\\n            v.push_back(wei[i]+wei[i-1]);\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        ll mn=0;\\n        \\n        for(int i=1; i<k; i++)\\n            mn+=v[i-1];\\n\\n        \\n        \\n        sort(v.rbegin(), v.rend());\\n        ll mx=0;\\n        \\n        for(int i=1; i<k; i++)\\n            mx+=v[i-1];\\n\\n        \\n        return mx-mn;\\n    }\\n};\\n```\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nusing ll=long long;\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& wei, int k) {\\n        vector<ll> v;\\n        int n=wei.size();\\n        for(int i=1; i<n; i++)\\n        {\\n            v.push_back(wei[i]+wei[i-1]);\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        ll mn=0;\\n        \\n        for(int i=1; i<k; i++)\\n            mn+=v[i-1];\\n\\n        \\n        \\n        sort(v.rbegin(), v.rend());\\n        ll mx=0;\\n        \\n        for(int i=1; i<k; i++)\\n            mx+=v[i-1];\\n\\n        \\n        return mx-mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111936,
                "title": "c",
                "content": "```\\nint cmp(const void* a, const void* b){\\n    return *(int*)a - *(int*)b ;\\n}\\nlong long putMarbles(int* weights, int weightsSize, int k){\\n    int n = weightsSize;\\n    if(n == k || k == 1 )\\n        return 0 ;\\n    int* data = malloc( (n-1) * sizeof(int)) ;\\n    for(int i = 0; i < n-1; i++){\\n        data[i] = weights[i] + weights[i+1] ;\\n    }\\n    qsort(data, n-1, sizeof(int), cmp) ;\\n    long long min = weights[0] + weights[n-1] ;\\n    long long max = weights[0] + weights[n-1] ;\\n    for(int i = 0; i < k-1; i++){\\n        min += data[i] ;\\n        max += data[n-2-i] ;\\n    }\\n    return max - min ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmp(const void* a, const void* b){\\n    return *(int*)a - *(int*)b ;\\n}\\nlong long putMarbles(int* weights, int weightsSize, int k){\\n    int n = weightsSize;\\n    if(n == k || k == 1 )\\n        return 0 ;\\n    int* data = malloc( (n-1) * sizeof(int)) ;\\n    for(int i = 0; i < n-1; i++){\\n        data[i] = weights[i] + weights[i+1] ;\\n    }\\n    qsort(data, n-1, sizeof(int), cmp) ;\\n    long long min = weights[0] + weights[n-1] ;\\n    long long max = weights[0] + weights[n-1] ;\\n    for(int i = 0; i < k-1; i++){\\n        min += data[i] ;\\n        max += data[n-2-i] ;\\n    }\\n    return max - min ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3111649,
                "title": "c-priority-queue-code-with-explanation",
                "content": "- To get maximum value, we need to cut the array where weight sum is max at i and i + 1, and min weight for minimum sum.\\n\\nFor eg. Input: weights = [1,3,5,1], k = 2\\n\\nSince first and last element is constant in max and min weights, let\\'s ignore those. Now, for k = 2, imagine that we need to cut the array for k - 1 times, i.e 1.\\n\\t- There are following options to make a cut:\\n\\t\\t- 1, 3\\n\\t\\t- 3, 5\\n\\t\\t- 5, 1\\n\\nFor getting maximum value, we should pick 3, 5 and to pick minimum value, we should pick 1, 3\\nand the diff will be (5 + 3) - (1 + 3) = 4;\\n\\nUsing above property, if we keep top k - 1 pairs in min and max heap, we can get the difference in O(nlogk) time.\\n-  keep top k - 1 pairs in max pq and min pq and return the difference in the end\\n\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        priority_queue<int> maxQ;\\n        priority_queue<int, vector<int>, greater<int>> minQ;\\n        \\n        int n = weights.size();\\n        for (int i = 0; i < n - 1; i++) {\\n            maxQ.push(weights[i] + weights[i + 1]);\\n            if (maxQ.size() == k) {\\n                maxQ.pop();\\n            }\\n            \\n            minQ.push(weights[i] + weights[i + 1]);\\n            if (minQ.size() == k) {\\n                minQ.pop();\\n            }\\n        }\\n        \\n        \\n        long long diff = 0;\\n        while (!minQ.empty()) {\\n            diff += minQ.top() - maxQ.top();\\n            minQ.pop(); maxQ.pop();\\n        }\\n        \\n        return diff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        priority_queue<int> maxQ;\\n        priority_queue<int, vector<int>, greater<int>> minQ;\\n        \\n        int n = weights.size();\\n        for (int i = 0; i < n - 1; i++) {\\n            maxQ.push(weights[i] + weights[i + 1]);\\n            if (maxQ.size() == k) {\\n                maxQ.pop();\\n            }\\n            \\n            minQ.push(weights[i] + weights[i + 1]);\\n            if (minQ.size() == k) {\\n                minQ.pop();\\n            }\\n        }\\n        \\n        \\n        long long diff = 0;\\n        while (!minQ.empty()) {\\n            diff += minQ.top() - maxQ.top();\\n            minQ.pop(); maxQ.pop();\\n        }\\n        \\n        return diff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056712,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> (b-a));\\n        PriorityQueue<Integer> pqm = new PriorityQueue<>((a,b) -> (a-b));\\n        for(int i = 0; i < weights.length - 1; i++){\\n            pq.add(weights[i] + weights[i + 1]);\\n            pqm.add(weights[i] + weights[i + 1]);\\n        }\\n\\n        long  ans = 0;\\n        for(int i = 0; i < k - 1 ; i++){\\n            ans = ans + pq.poll() - pqm.poll();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a,b) -> (b-a));\\n        PriorityQueue<Integer> pqm = new PriorityQueue<>((a,b) -> (a-b));\\n        for(int i = 0; i < weights.length - 1; i++){\\n            pq.add(weights[i] + weights[i + 1]);\\n            pqm.add(weights[i] + weights[i + 1]);\\n        }\\n\\n        long  ans = 0;\\n        for(int i = 0; i < k - 1 ; i++){\\n            ans = ans + pq.poll() - pqm.poll();\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035132,
                "title": "beats-100-o-n",
                "content": "# Intuition\\nThe continuous distribution we want to do is equivalent to putting sticks between the array of marbles. Then, the total sum of each distribution is equa to `weights[0]+weight[-1]+$$\\\\sum_{i=1}^{k-1} paint[i]$$` where `pair[i]` is the sum of two neighboring weights around the stick line. Therefore, we only care about these pairs and we can compute all possible pairs and select Min / Max of the sum of `k-1` of them. \\n\\n# Complexity\\n- Time complexity: $$O(n)$$ --> Go over arrays only once.\\n\\n- Space complexity: $$O(n)$$ --> To store the sum of all pairs\\n\\n# Code\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        if k == 1:\\n            return 0\\n        pair = []\\n        for i in range(len(weights)-1):\\n            pair.append(weights[i]+weights[i+1])\\n        pair.sort()\\n        return sum(pair[-k+1:]) - sum(pair[:k-1])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        if k == 1:\\n            return 0\\n        pair = []\\n        for i in range(len(weights)-1):\\n            pair.append(weights[i]+weights[i+1])\\n        pair.sort()\\n        return sum(pair[-k+1:]) - sum(pair[:k-1])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017694,
                "title": "easy-simple-100ms-greedy",
                "content": "\\n# Complexity\\n- Time complexity: O(n (log n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int ans = weights[0]+ weights[weights.size()-1];\\n        vector<int> temp; \\n        for(int i =0; i< weights.size()-1; i++){\\n            temp.push_back(weights[i]+weights[i+1]); \\n        }\\n        if(!temp.empty())sort(temp.begin(), temp.end()); \\n        long long left = ans, right = ans; \\n        for(int i = 0; i< k-1; i++){\\n            left += temp[i]; \\n            right += temp[temp.size()-1-i]; \\n        }\\n\\n        return right - left; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int ans = weights[0]+ weights[weights.size()-1];\\n        vector<int> temp; \\n        for(int i =0; i< weights.size()-1; i++){\\n            temp.push_back(weights[i]+weights[i+1]); \\n        }\\n        if(!temp.empty())sort(temp.begin(), temp.end()); \\n        long long left = ans, right = ans; \\n        for(int i = 0; i< k-1; i++){\\n            left += temp[i]; \\n            right += temp[temp.size()-1-i]; \\n        }\\n\\n        return right - left; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013345,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        \\n        long long int ans = 0;\\n\\n        int n = w.size();\\n\\n        vector <long long int> pairsum(n-1,0);\\n\\n        for ( int i=0; i<n-1; i++ ) {\\n            pairsum[i] = w[i] + w[i+1];\\n        }\\n\\n        sort(pairsum.begin(),pairsum.end());\\n\\n        int i = n-2;\\n        int m = k;\\n\\n        while ( m>1 ) {\\n            ans += pairsum[i--];\\n            m--;\\n        }\\n\\n        i = 0;\\n\\n        while ( i<k-1 ) {\\n            ans -= pairsum[i++];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        \\n        long long int ans = 0;\\n\\n        int n = w.size();\\n\\n        vector <long long int> pairsum(n-1,0);\\n\\n        for ( int i=0; i<n-1; i++ ) {\\n            pairsum[i] = w[i] + w[i+1];\\n        }\\n\\n        sort(pairsum.begin(),pairsum.end());\\n\\n        int i = n-2;\\n        int m = k;\\n\\n        while ( m>1 ) {\\n            ans += pairsum[i--];\\n            m--;\\n        }\\n\\n        i = 0;\\n\\n        while ( i<k-1 ) {\\n            ans -= pairsum[i++];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969173,
                "title": "99-05-beats-easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        int n=w.size();\\n        priority_queue<int>mx;\\n        vector<int> vec;\\n        priority_queue<int,vector<int>,greater<int>>mn;\\n        for(int i=0;i<n-1;i++){\\n            int temp=w[i]+w[i+1];\\n            vec.push_back(temp);\\n        }\\n        sort(vec.begin(),vec.end());\\n         long long mxs=0,mns=0;\\n        //  for(auto a:vec) cout<<a<<endl;\\n          int count=1;\\n        for(int i=0; count<k and i<vec.size();i++) {\\n            mns+=vec[i];\\n            count++;\\n            }\\n         count=1;\\n        for(int i=vec.size()-1; i>=0 and count<k;i--){\\n        mxs+=vec[i];\\n        count++;\\n        }\\n        return mxs-mns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        int n=w.size();\\n        priority_queue<int>mx;\\n        vector<int> vec;\\n        priority_queue<int,vector<int>,greater<int>>mn;\\n        for(int i=0;i<n-1;i++){\\n            int temp=w[i]+w[i+1];\\n            vec.push_back(temp);\\n        }\\n        sort(vec.begin(),vec.end());\\n         long long mxs=0,mns=0;\\n        //  for(auto a:vec) cout<<a<<endl;\\n          int count=1;\\n        for(int i=0; count<k and i<vec.size();i++) {\\n            mns+=vec[i];\\n            count++;\\n            }\\n         count=1;\\n        for(int i=vec.size()-1; i>=0 and count<k;i--){\\n        mxs+=vec[i];\\n        count++;\\n        }\\n        return mxs-mns;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3950061,
                "title": "simple-c-solution-with-heaps",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(nlogk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& a, int k) {\\n        if(k==1 || k==a.size())\\n        return 0;\\n        priority_queue<int,vector<int> ,greater<int> >q1;\\n        priority_queue<int> q2;\\n        long long int low=a[0]+a[a.size()-1],high=a[0]+a[a.size()-1];\\n        int k1=k-1;\\n        for(int i=0;i<a.size()-1;i++)\\n        {\\n            long long int x=(long long int)(a[i]+a[i+1]);\\n            if(k1>0)\\n            {\\n                q2.push(x);\\n                low+=x;\\n                k1--;\\n            }\\n            else if(q2.top()>x)\\n            {\\n                low-=q2.top();\\n                q2.pop();\\n                low+=x;\\n                q2.push(x);\\n            }\\n        }\\n        k1=k-1;\\n        for(int i=0;i<a.size()-1;i++)\\n        {\\n            long long int x=(long long int)(a[i]+a[i+1]);\\n            if(k1>0)\\n            {\\n                q1.push(x);\\n                high+=x;\\n                k1--;\\n            }\\n            else if(q1.top()<x)\\n            {\\n                high-=q1.top();\\n                q1.pop();\\n                high+=x;\\n                q1.push(x);\\n            }\\n        }\\n        return high-low;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& a, int k) {\\n        if(k==1 || k==a.size())\\n        return 0;\\n        priority_queue<int,vector<int> ,greater<int> >q1;\\n        priority_queue<int> q2;\\n        long long int low=a[0]+a[a.size()-1],high=a[0]+a[a.size()-1];\\n        int k1=k-1;\\n        for(int i=0;i<a.size()-1;i++)\\n        {\\n            long long int x=(long long int)(a[i]+a[i+1]);\\n            if(k1>0)\\n            {\\n                q2.push(x);\\n                low+=x;\\n                k1--;\\n            }\\n            else if(q2.top()>x)\\n            {\\n                low-=q2.top();\\n                q2.pop();\\n                low+=x;\\n                q2.push(x);\\n            }\\n        }\\n        k1=k-1;\\n        for(int i=0;i<a.size()-1;i++)\\n        {\\n            long long int x=(long long int)(a[i]+a[i+1]);\\n            if(k1>0)\\n            {\\n                q1.push(x);\\n                high+=x;\\n                k1--;\\n            }\\n            else if(q1.top()<x)\\n            {\\n                high-=q1.top();\\n                q1.pop();\\n                high+=x;\\n                q1.push(x);\\n            }\\n        }\\n        return high-low;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935931,
                "title": "best-java-solution-sorting-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long putMarbles(int[] arr, int k) {\\n        int n = arr.length;\\n        if(k==n) return 0;\\n\\n        int ans[] = new int[n-1];\\n\\n        for(int i=0; i<n-1; i++){\\n            ans[i] = arr[i]+arr[i+1];\\n        }    \\n\\n        Arrays.sort(ans);\\n\\n        long min =  0;\\n        long max = 0;\\n\\n        int i=0;\\n        int j=ans.length-1;\\n\\n        while(k-1>0){\\n            min+=ans[i++];\\n            max+=ans[j--];\\n            k--;\\n        }\\n\\n        return max-min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] arr, int k) {\\n        int n = arr.length;\\n        if(k==n) return 0;\\n\\n        int ans[] = new int[n-1];\\n\\n        for(int i=0; i<n-1; i++){\\n            ans[i] = arr[i]+arr[i+1];\\n        }    \\n\\n        Arrays.sort(ans);\\n\\n        long min =  0;\\n        long max = 0;\\n\\n        int i=0;\\n        int j=ans.length-1;\\n\\n        while(k-1>0){\\n            min+=ans[i++];\\n            max+=ans[j--];\\n            k--;\\n        }\\n\\n        return max-min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899633,
                "title": "dp-solution-java-memoization-recursion",
                "content": "# Intuition\\nDynamic Programming Solution | memory-limit-exceeded |\\nAny suggestions are more than welcome.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public long putMaxMarble(int start, int k, int n, int[] weights, long[][] dpMax)\\n    {\\n        if(k==1){\\n            return weights[start]+weights[n-1];\\n        }\\n        if(dpMax[start][k]!=-1)\\n            return dpMax[start][k];\\n        long max = 2*weights[start]+putMaxMarble(start+1,k-1,n,weights,dpMax);\\n        for(int i = start+1;i<=weights.length-k;i++){\\n            long sum = weights[i]+weights[start]+putMaxMarble(i+1,k-1,n,weights,dpMax);\\n            if(sum>max)\\n                max = sum;\\n        }\\n        return dpMax[start][k] = max;\\n    }\\n\\n    public long putMinMarble(int start, int k, int n, int[] weights, long[][] dpMin)\\n    {\\n        if(k==1){\\n            return weights[start]+weights[n-1];\\n        }\\n        if(dpMin[start][k]!=-1)\\n            return dpMin[start][k];\\n        long min = 2*weights[start]+putMinMarble(start+1,k-1,n,weights,dpMin);\\n        for(int i = start+1;i<=weights.length-k;i++){\\n            long sum = weights[i]+weights[start]+putMinMarble(i+1,k-1,n,weights,dpMin);\\n            if(sum<min)\\n                min = sum;\\n        }\\n        return dpMin[start][k] = min;\\n    }\\n\\n\\n\\n    public long putMarbles(int[] weights, int k) {\\n        long[][] dpMin = new long[weights.length][k+1];\\n        for (int i = 0; i < weights.length; i++) {\\n            Arrays.fill(dpMin[i],-1);\\n        }\\n        long[][] dpMax = new long[weights.length][k+1];\\n        for (int i = 0; i < weights.length; i++) {\\n            Arrays.fill(dpMax[i],-1);\\n        }\\n        long max = putMaxMarble(0,k,weights.length,weights,dpMax);\\n        long min = putMinMarble(0,k,weights.length,weights,dpMin);\\n        return max-min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public long putMaxMarble(int start, int k, int n, int[] weights, long[][] dpMax)\\n    {\\n        if(k==1){\\n            return weights[start]+weights[n-1];\\n        }\\n        if(dpMax[start][k]!=-1)\\n            return dpMax[start][k];\\n        long max = 2*weights[start]+putMaxMarble(start+1,k-1,n,weights,dpMax);\\n        for(int i = start+1;i<=weights.length-k;i++){\\n            long sum = weights[i]+weights[start]+putMaxMarble(i+1,k-1,n,weights,dpMax);\\n            if(sum>max)\\n                max = sum;\\n        }\\n        return dpMax[start][k] = max;\\n    }\\n\\n    public long putMinMarble(int start, int k, int n, int[] weights, long[][] dpMin)\\n    {\\n        if(k==1){\\n            return weights[start]+weights[n-1];\\n        }\\n        if(dpMin[start][k]!=-1)\\n            return dpMin[start][k];\\n        long min = 2*weights[start]+putMinMarble(start+1,k-1,n,weights,dpMin);\\n        for(int i = start+1;i<=weights.length-k;i++){\\n            long sum = weights[i]+weights[start]+putMinMarble(i+1,k-1,n,weights,dpMin);\\n            if(sum<min)\\n                min = sum;\\n        }\\n        return dpMin[start][k] = min;\\n    }\\n\\n\\n\\n    public long putMarbles(int[] weights, int k) {\\n        long[][] dpMin = new long[weights.length][k+1];\\n        for (int i = 0; i < weights.length; i++) {\\n            Arrays.fill(dpMin[i],-1);\\n        }\\n        long[][] dpMax = new long[weights.length][k+1];\\n        for (int i = 0; i < weights.length; i++) {\\n            Arrays.fill(dpMax[i],-1);\\n        }\\n        long max = putMaxMarble(0,k,weights.length,weights,dpMax);\\n        long min = putMinMarble(0,k,weights.length,weights,dpMin);\\n        return max-min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885360,
                "title": "how-to-solve-with-sort-and-greedy-en-th-with-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI\\'m not very good at English.\\nwe know that we should choose k contiguous range and we have 2 absolute point taht we choose is in the front and back of vector.\\n\\n\\u0E08\\u0E32\\u0E01\\u0E42\\u0E08\\u0E17\\u0E22\\u0E4C\\u0E40\\u0E23\\u0E32\\u0E08\\u0E30\\u0E23\\u0E39\\u0E49\\u0E27\\u0E48\\u0E32\\u0E40\\u0E23\\u0E32\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E40\\u0E25\\u0E37\\u0E2D\\u0E01 k \\u0E0A\\u0E48\\u0E27\\u0E07\\u0E17\\u0E35\\u0E48\\u0E15\\u0E34\\u0E14\\u0E01\\u0E31\\u0E19 \\u0E41\\u0E25\\u0E30\\u0E40\\u0E23\\u0E32\\u0E23\\u0E39\\u0E49\\u0E27\\u0E48\\u0E32\\u0E40\\u0E23\\u0E32\\u0E08\\u0E33\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E40\\u0E25\\u0E37\\u0E2D\\u0E01\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19 \\u0E41\\u0E25\\u0E30\\u0E08\\u0E38\\u0E01\\u0E2A\\u0E34\\u0E49\\u0E19\\u0E2A\\u0E38\\u0E14\\u0E40\\u0E2A\\u0E21\\u0E2D.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif we want to select k contiguous range we should choose 2*k point in vector but we know we should choose front and back 1 each so our problem is choose 2*k-2 point left.\\n\\nnext we know that if we choose i-th index in vector we need to choose (i+1)-th index in vector absolutly so we prepate the new vector for sum of 2 index i and i+1 for 0 <= i < n-1.\\n\\nwe need to choose 2*k-2 point or we can write as w*(k-1), it is we need to choose only k-1 sum of index i and i+1 that we want like if we want the maximum we should choose k-1 maximal sum.\\n\\n\\u0E16\\u0E49\\u0E32\\u0E40\\u0E23\\u0E32\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E01\\u0E32\\u0E23\\u0E40\\u0E25\\u0E37\\u0E2D\\u0E01 k \\u0E0A\\u0E48\\u0E27\\u0E07\\u0E17\\u0E35\\u0E48\\u0E15\\u0E34\\u0E14\\u0E01\\u0E31\\u0E19\\u0E19\\u0E31\\u0E48\\u0E19\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E16\\u0E36\\u0E07\\u0E40\\u0E23\\u0E32\\u0E08\\u0E33\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E40\\u0E25\\u0E37\\u0E2D\\u0E01 2*k \\u0E08\\u0E38\\u0E14\\u0E43\\u0E19 vector \\u0E17\\u0E27\\u0E48\\u0E32\\u0E40\\u0E23\\u0E32\\u0E21\\u0E35\\u0E08\\u0E38\\u0E14\\u0E17\\u0E35\\u0E48\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E40\\u0E25\\u0E37\\u0E2D\\u0E01\\u0E2D\\u0E22\\u0E39\\u0E48\\u0E41\\u0E25\\u0E49\\u0E27 2 \\u0E08\\u0E38\\u0E14\\u0E04\\u0E37\\u0E2D\\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E34\\u0E48\\u0E21\\u0E15\\u0E49\\u0E19 \\u0E41\\u0E25\\u0E30\\u0E08\\u0E38\\u0E14\\u0E2A\\u0E34\\u0E49\\u0E19\\u0E2A\\u0E38\\u0E14 \\u0E14\\u0E31\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E08\\u0E38\\u0E14\\u0E17\\u0E35\\u0E48\\u0E40\\u0E2B\\u0E25\\u0E37\\u0E2D\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E40\\u0E25\\u0E37\\u0E2D\\u0E01\\u0E04\\u0E37\\u0E2D 2*k-2 \\u0E08\\u0E38\\u0E14\\n\\n\\u0E2A\\u0E34\\u0E48\\u0E07\\u0E15\\u0E48\\u0E2D\\u0E44\\u0E1B\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E2A\\u0E31\\u0E07\\u0E40\\u0E01\\u0E15\\u0E44\\u0E14\\u0E49\\u0E04\\u0E37\\u0E2D\\u0E16\\u0E49\\u0E32\\u0E40\\u0E23\\u0E32\\u0E40\\u0E25\\u0E37\\u0E2D\\u0E01\\u0E08\\u0E38\\u0E14\\u0E17\\u0E35\\u0E48 i-th index \\u0E43\\u0E19 vector \\u0E40\\u0E23\\u0E32\\u0E08\\u0E33\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E40\\u0E25\\u0E37\\u0E2D\\u0E01 (i+1)-th index \\u0E43\\u0E19 vector \\u0E40\\u0E2A\\u0E21\\u0E2D\\u0E14\\u0E31\\u0E07\\u0E19\\u0E31\\u0E49\\u0E19\\u0E2B\\u0E32\\u0E14\\u0E23\\u0E32\\u0E1E\\u0E34\\u0E08\\u0E32\\u0E23\\u0E13\\u0E32\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E04\\u0E39\\u0E48\\u0E46 \\u0E40\\u0E23\\u0E32\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E40\\u0E15\\u0E23\\u0E35\\u0E22\\u0E21 vector \\u0E43\\u0E2B\\u0E21\\u0E48\\u0E17\\u0E35\\u0E48\\u0E40\\u0E01\\u0E47\\u0E1A\\u0E1C\\u0E25\\u0E23\\u0E27\\u0E21\\u0E23\\u0E30\\u0E2B\\u0E27\\u0E48\\u0E32\\u0E07 i-th and (i+1)-th index \\u0E44\\u0E27\\u0E49\\u0E40\\u0E21\\u0E37\\u0E48\\u0E2D 0 <= i < n-1.\\n\\n\\u0E08\\u0E32\\u0E01\\u0E17\\u0E35\\u0E48\\u0E40\\u0E23\\u0E32\\u0E23\\u0E39\\u0E49\\u0E40\\u0E23\\u0E32\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E40\\u0E25\\u0E37\\u0E2D\\u0E01 2*k-2 \\u0E08\\u0E38\\u0E14\\u0E40\\u0E23\\u0E32\\u0E2A\\u0E32\\u0E21\\u0E32\\u0E23\\u0E16\\u0E40\\u0E02\\u0E35\\u0E22\\u0E19\\u0E44\\u0E14\\u0E49\\u0E43\\u0E2B\\u0E21\\u0E48\\u0E40\\u0E1B\\u0E47\\u0E2F 2*(k-1) \\u0E19\\u0E31\\u0E48\\u0E19\\u0E2B\\u0E21\\u0E32\\u0E22\\u0E16\\u0E36\\u0E07\\u0E2B\\u0E32\\u0E01\\u0E40\\u0E23\\u0E32\\u0E21\\u0E2D\\u0E07\\u0E40\\u0E1B\\u0E47\\u0E19\\u0E04\\u0E39\\u0E48\\u0E46 \\u0E40\\u0E23\\u0E32\\u0E08\\u0E30\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E40\\u0E25\\u0E37\\u0E2D\\u0E01\\u0E17\\u0E31\\u0E49\\u0E07\\u0E2B\\u0E21\\u0E14 k-1 \\u0E04\\u0E39\\u0E49\\u0E17\\u0E35\\u0E48\\u0E40\\u0E2B\\u0E25\\u0E37\\u0E2D \\u0E15\\u0E48\\u0E2D\\u0E44\\u0E1B\\u0E40\\u0E23\\u0E32\\u0E01\\u0E47\\u0E41\\u0E04\\u0E48\\u0E17\\u0E33\\u0E01\\u0E32\\u0E23 sort vector or sum that we create \\u0E41\\u0E25\\u0E49\\u0E27\\u0E19\\u0E33\\u0E44\\u0E1B\\u0E2B\\u0E32\\u0E04\\u0E48\\u0E32\\u0E17\\u0E35\\u0E48\\u0E15\\u0E49\\u0E2D\\u0E07\\u0E01\\u0E32\\u0E23\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log n) because we use sort\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        vector<int> sp2;\\n        for(int i=0;i<n-1;++i){\\n            sp2.push_back(weights[i]+weights[i+1]);\\n        }\\n\\n        sort(sp2.begin(), sp2.end());\\n        long long smin = 0, smax = 0;\\n        for(int i=0;i<k-1;++i) smin += (long long)sp2[i];\\n        for(int i=n-2;i>=n-k;--i) smax += (long long)sp2[i];\\n\\n        return smax - smin;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        vector<int> sp2;\\n        for(int i=0;i<n-1;++i){\\n            sp2.push_back(weights[i]+weights[i+1]);\\n        }\\n\\n        sort(sp2.begin(), sp2.end());\\n        long long smin = 0, smax = 0;\\n        for(int i=0;i<k-1;++i) smin += (long long)sp2[i];\\n        for(int i=n-2;i>=n-k;--i) smax += (long long)sp2[i];\\n\\n        return smax - smin;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876091,
                "title": "best-rust-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet all pairs added together. Use the original Vec, to save memory. Sort, and take the difference between the lowest and highest k.\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn put_marbles(mut weights: Vec<i32>, k: i32) -> i64 {\\n        \\n        for i in 0..(weights.len() - 1) {\\n            weights[i] += weights[i+1];\\n        }\\n        weights.pop();\\n\\n        weights.sort_unstable();\\n\\n        let least: i64 = weights.iter().take((k-1) as _).map(|&x| x as i64).sum();\\n        let most: i64 = weights.iter().rev().take((k-1) as _).map(|&x| x as i64).sum();\\n\\n        return most - least;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn put_marbles(mut weights: Vec<i32>, k: i32) -> i64 {\\n        \\n        for i in 0..(weights.len() - 1) {\\n            weights[i] += weights[i+1];\\n        }\\n        weights.pop();\\n\\n        weights.sort_unstable();\\n\\n        let least: i64 = weights.iter().take((k-1) as _).map(|&x| x as i64).sum();\\n        let most: i64 = weights.iter().rev().take((k-1) as _).map(|&x| x as i64).sum();\\n\\n        return most - least;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3858092,
                "title": "c-solution-pattern-based-intuition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        vector<int> help;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            help.push_back(weights[i]+weights[i+1]);\\n        }\\n        sort(help.begin(),help.end());\\n        long long min_sum=0,max_sum=0;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            min_sum+=help[i];\\n            max_sum+=help[n-2-i];\\n        }\\n        return max_sum-min_sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        vector<int> help;\\n        for(int i=0;i<n-1;i++)\\n        {\\n            help.push_back(weights[i]+weights[i+1]);\\n        }\\n        sort(help.begin(),help.end());\\n        long long min_sum=0,max_sum=0;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            min_sum+=help[i];\\n            max_sum+=help[n-2-i];\\n        }\\n        return max_sum-min_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3850319,
                "title": "sort-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n\\u22C5log(n))$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        if k == 1:\\n            return 0\\n        pairs = sorted(w1 + w2 for w1, w2 in zip(weights, weights[1:]))\\n        return sum(pairs[-k + 1:]) - sum(pairs[:k - 1])\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        if k == 1:\\n            return 0\\n        pairs = sorted(w1 + w2 for w1, w2 in zip(weights, weights[1:]))\\n        return sum(pairs[-k + 1:]) - sum(pairs[:k - 1])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3848096,
                "title": "simple-c-solution-min-max-heap",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long putMarbles(vector<int>& arr, int k) {\\n        ll n=arr.size(),less=0,more=0;\\n        priority_queue<ll>bigger;\\n        priority_queue<ll,vector<ll>,greater<ll>>smaller;\\n        for(ll i=1;i<n;i++){\\n            bigger.push(arr[i]+arr[i-1]);\\n            smaller.push(arr[i]+arr[i-1]);\\n        }\\n        ll temp=k-1;\\n        while(temp--){\\n            less+=smaller.top();\\n            smaller.pop();\\n        }\\n        temp=k-1;\\n        while(temp--){\\n            more+=bigger.top();\\n            bigger.pop();\\n        }\\n        return more-less;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    long long putMarbles(vector<int>& arr, int k) {\\n        ll n=arr.size(),less=0,more=0;\\n        priority_queue<ll>bigger;\\n        priority_queue<ll,vector<ll>,greater<ll>>smaller;\\n        for(ll i=1;i<n;i++){\\n            bigger.push(arr[i]+arr[i-1]);\\n            smaller.push(arr[i]+arr[i-1]);\\n        }\\n        ll temp=k-1;\\n        while(temp--){\\n            less+=smaller.top();\\n            smaller.pop();\\n        }\\n        temp=k-1;\\n        while(temp--){\\n            more+=bigger.top();\\n            bigger.pop();\\n        }\\n        return more-less;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841358,
                "title": "go-implementation-using-heap-o-nlogk",
                "content": "```\\ntype IntHeap []int64\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x any) {\\n\\t*h = append(*h, x.(int64))\\n}\\n\\nfunc (h *IntHeap) Pop() any {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc putMarbles(weights []int, k int) int64 {\\n    n := len(weights)\\n    divs := make([]int64, n-1)\\n    for i := 0; i < n-1; i++ {\\n        divs[i] = int64(weights[i]) + int64(weights[i+1])\\n    }\\n    mins := make(IntHeap, 0, k)\\n    maxs := make(IntHeap, 0, k)\\n    for _, a := range(divs) {\\n        heap.Push(&mins, -a)\\n        if len(mins) > k-1 {\\n            heap.Pop(&mins)\\n        }\\n        heap.Push(&maxs, a)\\n        if len(maxs) > k-1 {\\n            heap.Pop(&maxs)\\n        }\\n    }\\n    var res int64 = 0\\n    for i := 0; i < k-1; i++ {\\n        res = res + mins[i] + maxs[i]\\n    }\\n    return res\\n}\\n```\\nIf we have a C++ like nth_element() function in Go, time complexity can be further improved to O(n).",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntype IntHeap []int64\\n\\nfunc (h IntHeap) Len() int           { return len(h) }\\nfunc (h IntHeap) Less(i, j int) bool { return h[i] < h[j] }\\nfunc (h IntHeap) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }\\n\\nfunc (h *IntHeap) Push(x any) {\\n\\t*h = append(*h, x.(int64))\\n}\\n\\nfunc (h *IntHeap) Pop() any {\\n\\told := *h\\n\\tn := len(old)\\n\\tx := old[n-1]\\n\\t*h = old[0 : n-1]\\n\\treturn x\\n}\\n\\nfunc putMarbles(weights []int, k int) int64 {\\n    n := len(weights)\\n    divs := make([]int64, n-1)\\n    for i := 0; i < n-1; i++ {\\n        divs[i] = int64(weights[i]) + int64(weights[i+1])\\n    }\\n    mins := make(IntHeap, 0, k)\\n    maxs := make(IntHeap, 0, k)\\n    for _, a := range(divs) {\\n        heap.Push(&mins, -a)\\n        if len(mins) > k-1 {\\n            heap.Pop(&mins)\\n        }\\n        heap.Push(&maxs, a)\\n        if len(maxs) > k-1 {\\n            heap.Pop(&maxs)\\n        }\\n    }\\n    var res int64 = 0\\n    for i := 0; i < k-1; i++ {\\n        res = res + mins[i] + maxs[i]\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3821188,
                "title": "python-2-line-easy-solution-beat-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea is to think of the problem from another perspective. Let\\'s revisit the description:\\n> If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.\\n\\nAs the bags have to contain all marbles in between, we can now actually think about the problem as having a long strip of numbers and we need to \"cut\" it into `k` segments, i.e. deciding where to place our `k-1` \"cuts\". \\n\\nNow we can move on and see how the scores are calculated. We use a simple example of `weights`:\\n`[a b c d e f g]`\\nwhich has an original score of $a+g$. \\n\\nAssuming we want to have `k=2` bags, i.e making 1 \"cut\", and let\\'s say we cut it between $d$ and $e$:\\n`[a b c d | e f g]`\\nThe total score of the 2 bags is now $(a+d)+(e+g)=(a+g)+(d+e)$. We can see that the \"cut\" has effectively added `d` and `e` to the score. This means that every \"cut\" you make is equivalent to adding the `weights` either side of the \"cut\" to the total score. \\n\\nKnowing this, we can then compute and sort sums of each pair of `weights`. The \"cuts\" resulting the maximum score is found by the greedy approach, i.e. simply choosing the `k-1` largest pairs, and vice versa for the minimum score. Their difference is therefore just the difference between the sum of `k-1` largest pairs and the sum of `k-1` smallest pairs.\\n\\nP.S. First time posting here so hopefully the explanation is clear enough!\\n\\n# Complexity\\n- Time complexity: $$O(n\\\\log n)$$\\n- Space complexity: $$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        pairs = sorted([i+j for i, j in zip(weights[:-1],weights[1:])])\\n\\n        return sum(pairs[len(pairs)-k+1:]) - sum(pairs[:k-1])\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        pairs = sorted([i+j for i, j in zip(weights[:-1],weights[1:])])\\n\\n        return sum(pairs[len(pairs)-k+1:]) - sum(pairs[:k-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3819070,
                "title": "beats-100-c-simplest-solution-5-lines-of-code",
                "content": "# Intuition\\n![s.png](https://assets.leetcode.com/users/images/0197f32e-0828-4d93-95c7-a8f6e46db224_1690374516.639171.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N lg N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n# Code\\n```\\n/*\\nAlgo (sort and greedy):\\n1. Problem is how to partition the weights into k parts to get min and max scores.\\n2. Score of a partition scheme is simply sum of \"boundary weights\", i.e.,\\n   given neighboring partitions P_i and P_j, the score is the sum of \\n   all such P_i\\'s right weight plus P_j left weight -- w[i] + w[i+1]\\n3. Sum all such neighboring weights and use greedy approach to guide the partition scheme. \\n*/\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        // Add up the boundaries of each partition.\\n        for (int i = 0; i < w.size() - 1; w[i] += w[i+1], i++);\\n        w.pop_back();\\n        sort(w.begin(), w.end());\\n        int64_t sum = 0;\\n        // sum = sum of max w minus sum of min w \\n        for (int i = 0; i < k - 1; sum += w[w.size() - 1 - i] - w[i], i++);\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/*\\nAlgo (sort and greedy):\\n1. Problem is how to partition the weights into k parts to get min and max scores.\\n2. Score of a partition scheme is simply sum of \"boundary weights\", i.e.,\\n   given neighboring partitions P_i and P_j, the score is the sum of \\n   all such P_i\\'s right weight plus P_j left weight -- w[i] + w[i+1]\\n3. Sum all such neighboring weights and use greedy approach to guide the partition scheme. \\n*/\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& w, int k) {\\n        // Add up the boundaries of each partition.\\n        for (int i = 0; i < w.size() - 1; w[i] += w[i+1], i++);\\n        w.pop_back();\\n        sort(w.begin(), w.end());\\n        int64_t sum = 0;\\n        // sum = sum of max w minus sum of min w \\n        for (int i = 0; i < k - 1; sum += w[w.size() - 1 - i] - w[i], i++);\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810815,
                "title": "c-faster-than-85-sorting-easy-solution-o-log-n-n",
                "content": "# Intuition\\nCreate auxiliary array with sum of 2 adjacent items from array `weights`.\\n\\n# Approach\\nCreate auxiliary array with sum of 2 adjacent items from array `weights`:\\n```\\nvar aux = new int[weights.Length - 1];\\nfor (int i = 0; i < weights.Length - 1; i++)\\n{\\n    aux[i] = weights[i] + weights[i + 1];\\n}\\n```\\n, then sort it:\\n```\\nArray.Sort(aux);\\n```\\nand then take for the result k - 1 first and last items:\\n```\\nvar rs = 0L;\\nfor (int i = 0; i < k - 1; i++)\\n{\\n    rs += (aux[aux.Length - 1 - i] - aux[i]);\\n}\\nreturn rs;\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(log(n)*n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public long PutMarbles(int[] weights, int k) {\\n        var aux = new int[weights.Length - 1];\\n        for (int i = 0; i < weights.Length - 1; i++)\\n        {\\n            aux[i] = weights[i] + weights[i + 1];\\n        }\\n        Array.Sort(aux);\\n        var rs = 0L;\\n        for (int i = 0; i < k - 1; i++) rs += (aux[aux.Length - 1 - i] - aux[i]);\\n        return rs;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sorting"
                ],
                "code": "```\\nvar aux = new int[weights.Length - 1];\\nfor (int i = 0; i < weights.Length - 1; i++)\\n{\\n    aux[i] = weights[i] + weights[i + 1];\\n}\\n```\n```\\nArray.Sort(aux);\\n```\n```\\nvar rs = 0L;\\nfor (int i = 0; i < k - 1; i++)\\n{\\n    rs += (aux[aux.Length - 1 - i] - aux[i]);\\n}\\nreturn rs;\\n```\n```\\npublic class Solution {\\n    public long PutMarbles(int[] weights, int k) {\\n        var aux = new int[weights.Length - 1];\\n        for (int i = 0; i < weights.Length - 1; i++)\\n        {\\n            aux[i] = weights[i] + weights[i + 1];\\n        }\\n        Array.Sort(aux);\\n        var rs = 0L;\\n        for (int i = 0; i < k - 1; i++) rs += (aux[aux.Length - 1 - i] - aux[i]);\\n        return rs;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807352,
                "title": "c-greedy-approach",
                "content": "~~~\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& a, int k) {\\n        ll n = a.size();\\n        vector <ll> x;\\n        for (ll i=1; i<n; i++)\\n            x.push_back(a[i]+a[i-1]);\\n        \\n        sort (x.begin(), x.end());\\n        \\n        ll mx = 0;\\n        ll mn = 0;\\n        \\n        for (ll i=0; i<k-1; i++)\\n        {\\n            mn += x[i];\\n            mx += x[n-2-i];\\n        }\\n        \\n        return mx-mn;\\n    }\\n};\\n~~~",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    long long putMarbles(vector<int>& a, int k) {\\n        ll n = a.size();\\n        vector <ll> x;\\n        for (ll i=1; i<n; i++)\\n            x.push_back(a[i]+a[i-1]);\\n        \\n        sort (x.begin(), x.end());\\n        \\n        ll mx = 0;\\n        ll mn = 0;\\n        \\n        for (ll i=0; i<k-1; i++)\\n        {\\n            mn += x[i];\\n            mx += x[n-2-i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3785741,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n[xxxx|xxxx|xxxx]\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        //[xxxx | xxxx | xxxx ]\\n        vector<int> res; \\n        const int n = weights.size();\\n        for(int i = 0; i < n - 1; i++){\\n            res.push_back(weights[i] + weights[i + 1]);\\n        }\\n        sort(res.begin(), res.end());\\n        long long cur = 0;\\n        for(int i = 0; i < k - 1; i++)cur+=res[i];\\n        reverse(res.begin(), res.end());\\n        for(int i = 0; i < k - 1; i++)cur-=res[i];\\n        return abs(cur);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        //[xxxx | xxxx | xxxx ]\\n        vector<int> res; \\n        const int n = weights.size();\\n        for(int i = 0; i < n - 1; i++){\\n            res.push_back(weights[i] + weights[i + 1]);\\n        }\\n        sort(res.begin(), res.end());\\n        long long cur = 0;\\n        for(int i = 0; i < k - 1; i++)cur+=res[i];\\n        reverse(res.begin(), res.end());\\n        for(int i = 0; i < k - 1; i++)cur-=res[i];\\n        return abs(cur);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766313,
                "title": "c-sorting-greedy",
                "content": "//T.C :--  O(Nlogn)\\n//S.C :--- O(N)\\n\\nclass Solution {\\npublic:\\n\\n    long long putMarbles(vector<int>& weights, int k) {\\n        \\n        int n = weights.size();\\n        \\n        //pairSum size -> m\\n        int m = n-1;\\n        vector<int> pairSum(m, 0);\\n        \\n        for(int i=0; i<m; i++) {\\n            pairSum[i] = weights[i] + weights[i+1];\\n        }\\n        \\n        sort(pairSum.begin(), pairSum.end());\\n        \\n        long minSum = 0;  //pick starting of pairSum\\n        long maxSum = 0;  //pick ending of pairSum\\n        \\n        for(int i=0; i<k-1; i++) {  //k-1 pair\\n            minSum += pairSum[i];\\n            maxSum += pairSum[m-1-i];\\n        }\\n        \\n        return (maxSum - minSum);\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n\\n    long long putMarbles(vector<int>& weights, int k) {\\n        \\n        int n = weights.size();\\n        \\n        //pairSum size -> m\\n        int m = n-1;\\n        vector<int> pairSum(m, 0);\\n        \\n        for(int i=0; i<m; i++) {\\n            pairSum[i] = weights[i] + weights[i+1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3762912,
                "title": "simple-c-solution-greedy-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long>small;\\n        vector<long long>big;\\n        for(int i=0;i<weights.size()-1;i++){\\n            small.push_back((long long)weights[i]+(long long)weights[i+1]);\\n            big.push_back((long long)weights[i]+(long long)weights[i+1]);\\n        }\\n        sort(small.begin(),small.end());\\n        sort(big.rbegin(),big.rend());\\n        long long low=0;\\n        long long high=0;\\n        long long low_count=0;\\n        long long high_count=0;\\n        for(int i=0;i<small.size();i++){\\n            low=low+small[i];\\n            low_count=low_count+1;\\n            if(low_count==k-1)break;\\n        }\\n                for(int i=0;i<big.size();i++){\\n            high=high+big[i];\\n            high_count=high_count+1;\\n            if(high_count==k-1)break;\\n        }\\n        long long ans=high-low;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long>small;\\n        vector<long long>big;\\n        for(int i=0;i<weights.size()-1;i++){\\n            small.push_back((long long)weights[i]+(long long)weights[i+1]);\\n            big.push_back((long long)weights[i]+(long long)weights[i+1]);\\n        }\\n        sort(small.begin(),small.end());\\n        sort(big.rbegin(),big.rend());\\n        long long low=0;\\n        long long high=0;\\n        long long low_count=0;\\n        long long high_count=0;\\n        for(int i=0;i<small.size();i++){\\n            low=low+small[i];\\n            low_count=low_count+1;\\n            if(low_count==k-1)break;\\n        }\\n                for(int i=0;i<big.size();i++){\\n            high=high+big[i];\\n            high_count=high_count+1;\\n            if(high_count==k-1)break;\\n        }\\n        long long ans=high-low;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762173,
                "title": "easy-approach-using-pair-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe last and first element will be in at least 1/2 partition  (as  subarray ) so we can just ignore them and calculate sum of each adjacent pair and find K min sums and k max sums to get the final answer.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        if(k>=n){return 0;}\\n        vector<int> pairSum(n-1);\\n        for(int i=0; i< n-1; i++){\\n            pairSum[i]= weights[i]+weights[i+1];\\n        }\\n        sort(pairSum.begin(), pairSum.end());\\n        long long minSum =0, maxSum =0;\\n        for(int i=0; i<k-1 ; i++){\\n            minSum+= pairSum[i];\\n            maxSum+= pairSum[n-i-2];\\n            cout<< pairSum[i]<<endl;\\n        }\\n        return maxSum - minSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n = weights.size();\\n        if(k>=n){return 0;}\\n        vector<int> pairSum(n-1);\\n        for(int i=0; i< n-1; i++){\\n            pairSum[i]= weights[i]+weights[i+1];\\n        }\\n        sort(pairSum.begin(), pairSum.end());\\n        long long minSum =0, maxSum =0;\\n        for(int i=0; i<k-1 ; i++){\\n            minSum+= pairSum[i];\\n            maxSum+= pairSum[n-i-2];\\n            cout<< pairSum[i]<<endl;\\n        }\\n        return maxSum - minSum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3755811,
                "title": "unraveling-the-put-marbles-in-bags-leetcode-challenge",
                "content": "# Intuition\\nAt first glance, this problem seems to be about finding the optimal distribution of marbles into bags. The key insight here is that the cost of a bag is determined by the sum of the weights of the first and last marble in the bag. This suggests that we should focus on pairs of marbles and their combined weights.\\n\\nhttps://youtu.be/5c8x79laM9g\\n\\n# Approach\\nOur approach is to first calculate the combined weights of all adjacent pairs of marbles. We then sort these combined weights. The difference between the maximum and minimum scores is then calculated by summing the differences between the largest \\'k - 1\\' values and the smallest \\'k - 1\\' values. This is done by iterating over the sorted list of combined weights.\\n\\n# Complexity\\n- Time complexity: The time complexity is O(n log n) due to the sorting of the \\'pair_weights\\' list. Here, \\'n\\' is the number of marbles.\\n- Space complexity: The space complexity is O(n) as we store the combined weights of all pairs of marbles in the \\'pair_weights\\' list.\\n\\n# Code\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        # We collect and sort the value of all n - 1 pairs. \\n        n = len(weights) \\n        pair_weights = [0] * (n - 1) \\n        for i in range(n - 1): \\n            pair_weights[i] = weights[i] + weights[i + 1] \\n        pair_weights.sort() \\n        # Get the difference between the largest k - 1 values and the smallest k - 1 values. \\n        answer = 0 \\n        for i in range(k - 1): \\n            answer += pair_weights[n - 2 - i] - pair_weights[i] \\n        return answer \\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        # We collect and sort the value of all n - 1 pairs. \\n        n = len(weights) \\n        pair_weights = [0] * (n - 1) \\n        for i in range(n - 1): \\n            pair_weights[i] = weights[i] + weights[i + 1] \\n        pair_weights.sort() \\n        # Get the difference between the largest k - 1 values and the smallest k - 1 values. \\n        answer = 0 \\n        for i in range(k - 1): \\n            answer += pair_weights[n - 2 - i] - pair_weights[i] \\n        return answer \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755078,
                "title": "greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        if(n==k || k==1){\\n            return 0;\\n        }\\n        vector<int>candidates;\\n        for(int i=0;i<n-1;i++){\\n            candidates.push_back(weights[i]+weights[i+1]);\\n        }\\n        sort(candidates.begin(),candidates.end());\\n        long long mi=0;\\n        long long ma=0;\\n        int l=candidates.size();\\n        for(int i=0;i<k-1;i++){\\n            mi+=candidates[i];\\n            ma+=candidates[l-1-i];\\n        }\\n        return ma-mi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        int n=weights.size();\\n        if(n==k || k==1){\\n            return 0;\\n        }\\n        vector<int>candidates;\\n        for(int i=0;i<n-1;i++){\\n            candidates.push_back(weights[i]+weights[i+1]);\\n        }\\n        sort(candidates.begin(),candidates.end());\\n        long long mi=0;\\n        long long ma=0;\\n        int l=candidates.size();\\n        for(int i=0;i<k-1;i++){\\n            mi+=candidates[i];\\n            ma+=candidates[l-1-i];\\n        }\\n        return ma-mi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3753671,
                "title": "2551-put-marbles-in-bags",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code aims to distribute marbles into k bags while minimizing the difference between the maximum and minimum scores. The scores are determined by the sum of adjacent elements in the weights list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Calculate the sum of adjacent elements (current element + next element) in the weights list and store them in the adjacent_element_sum list.\\n2. Sort the adjacent_element_sum list in ascending order.\\n3. Iterate k-1 times, accumulating the minimum score by selecting elements from the beginning of the sorted adjacent_element_sum list and the maximum score by selecting elements from the end of the list\\n4. Calculate the result as the difference between the maximum and minimum scores.\\n5. Return the result.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the code is determined by the sorting operation, which takes** O(nlogn)** time, where n is the length of the weights list. The rest of the operations, such as calculating the adjacent_element_sum and iterating k-1 times, have linear time complexity and do not significantly impact the overall time complexity. Therefore, the overall time complexity is **O(nlogn)**.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the code depends on the storage of the adjacent_element_sum list. The size of this list is (n-1), where n is the length of the weights list. Therefore, the space complexity is **O(n)** to store the adjacent_element_sum list. The other variables used in the code have constant space requirements and do not affect the overall space complexity.\\n# Code\\n```\\nclass Solution:\\n\\tdef putMarbles(self, weights: List[int], k: int) -> int:\\n\\t\\tresult = 0\\n\\t\\tadjacent_element_sum = []\\n\\t\\tfor index in range(len(weights)-1):\\n\\t\\t\\tadjacent_element_sum.append(weights[index] + weights[index + 1])\\n\\t\\tadjacent_element_sum = sorted(adjacent_element_sum)\\n\\t\\tmax_score , min_score = 0 , 0\\n\\t\\tfor bag_no in range(k-1):\\n\\t\\t\\tmin_score = min_score + adjacent_element_sum[bag_no]\\n\\t\\t\\tmax_score = max_score + adjacent_element_sum[-(bag_no + 1)]\\n\\t\\tresult = max_score - min_score\\n\\t\\treturn result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef putMarbles(self, weights: List[int], k: int) -> int:\\n\\t\\tresult = 0\\n\\t\\tadjacent_element_sum = []\\n\\t\\tfor index in range(len(weights)-1):\\n\\t\\t\\tadjacent_element_sum.append(weights[index] + weights[index + 1])\\n\\t\\tadjacent_element_sum = sorted(adjacent_element_sum)\\n\\t\\tmax_score , min_score = 0 , 0\\n\\t\\tfor bag_no in range(k-1):\\n\\t\\t\\tmin_score = min_score + adjacent_element_sum[bag_no]\\n\\t\\t\\tmax_score = max_score + adjacent_element_sum[-(bag_no + 1)]\\n\\t\\tresult = max_score - min_score\\n\\t\\treturn result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752182,
                "title": "go-solution",
                "content": "# Intuition\\nhttps://github.com/ganeshskudva/Leetcode-Golang\\n\\n# Code\\n```\\nfunc putMarbles(weights []int, k int) int64 {\\n\\tn, pairs := len(weights), make([]int, len(weights)-1)\\n\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tpairs[i - 1] = weights[i] + weights[i - 1]\\n\\t}\\n\\tsort.Ints(pairs)\\n\\tminScore, maxScore := 0, 0\\n\\tfor i := 0; i < k - 1; i++ {\\n\\t\\tminScore += pairs[i]\\n\\t\\tmaxScore += pairs[n - i - 2]\\n\\t}\\n\\t\\n\\treturn int64(maxScore - minScore)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc putMarbles(weights []int, k int) int64 {\\n\\tn, pairs := len(weights), make([]int, len(weights)-1)\\n\\n\\tfor i := 1; i < n; i++ {\\n\\t\\tpairs[i - 1] = weights[i] + weights[i - 1]\\n\\t}\\n\\tsort.Ints(pairs)\\n\\tminScore, maxScore := 0, 0\\n\\tfor i := 0; i < k - 1; i++ {\\n\\t\\tminScore += pairs[i]\\n\\t\\tmaxScore += pairs[n - i - 2]\\n\\t}\\n\\t\\n\\treturn int64(maxScore - minScore)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3750411,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint cmp(void *a, void *b){\\n    return *(int*) a - *(int*) b;\\n}\\nlong long putMarbles(int* weights, int weightsSize, int k){\\n    \\n    int* pairs = calloc(weightsSize, sizeof(int));\\n    for (int i = 0; i < weightsSize - 1; i++)\\n        pairs[i] = weights[i] + weights[i + 1];\\n    \\n    qsort(pairs, weightsSize - 1, sizeof(int), cmp);\\n    \\n    long long ret = 0;\\n    for (int i = 0; i < k - 1; i++)\\n        ret += pairs[weightsSize - 2 - i] - pairs[i];\\n\\t\\t\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint cmp(void *a, void *b){\\n    return *(int*) a - *(int*) b;\\n}\\nlong long putMarbles(int* weights, int weightsSize, int k){\\n    \\n    int* pairs = calloc(weightsSize, sizeof(int));\\n    for (int i = 0; i < weightsSize - 1; i++)\\n        pairs[i] = weights[i] + weights[i + 1];\\n    \\n    qsort(pairs, weightsSize - 1, sizeof(int), cmp);\\n    \\n    long long ret = 0;\\n    for (int i = 0; i < k - 1; i++)\\n        ret += pairs[weightsSize - 2 - i] - pairs[i];\\n\\t\\t\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3750326,
                "title": "100-beats-beginners-friendly-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntry to go for differnent approach rather than going for end values of\\nsubarray go for sum of partion sum approach\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy approach, beginner friendly , 100% beats \\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n-1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n      vector<int>v;\\n      for(int i=1;i<weights.size();i++)\\n      {\\n        v.push_back(weights[i]+weights[i-1]);\\n      }\\n      sort(v.begin(),v.end());\\n      long long max=0;\\n      long long min=0; \\n      for(int i=0;i<k-1;i++)\\n      {\\n        min+=v[i];\\n        max+=v[v.size()-i-1];\\n      }\\n      return max-min;\\n    }\\n};\\n           \\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n      vector<int>v;\\n      for(int i=1;i<weights.size();i++)\\n      {\\n        v.push_back(weights[i]+weights[i-1]);\\n      }\\n      sort(v.begin(),v.end());\\n      long long max=0;\\n      long long min=0; \\n      for(int i=0;i<k-1;i++)\\n      {\\n        min+=v[i];\\n        max+=v[v.size()-i-1];\\n      }\\n      return max-min;\\n    }\\n};\\n           \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747964,
                "title": "python3-sum-and-sort-solution-with-some-explanations",
                "content": "Assume the weights = $$\\\\{w_i\\\\}_{i=1}^{n}$$\\n\\nCreate a new array $$s$$ by summing the two consecutive weigths\\n$$s = \\\\{s_i\\\\}_{i=1}^{n-1}$$ where $$s_i = w_i+w_{i+1}$$\\n\\nThen we define\\n$$s_{max} := sum\\\\ of\\\\ the\\\\ hightest\\\\ (k-1)\\\\ elements\\\\ in\\\\ s$$\\n$$s_{min} := sum\\\\ of\\\\ the\\\\ lowest\\\\ (k-1)\\\\ elements\\\\ in\\\\ s$$\\n\\nNext we have by inspection\\n$$max\\\\ score = w_0+s_{max}+w_n$$\\n$$min\\\\ score = w_0+s_{min}+w_n$$\\n\\nFinally\\n$$ans=max\\\\ score - min\\\\ score=s_{max}-s_{min}$$\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        if k == 1 or k == len(weights): return 0\\n\\n        s = []\\n\\n        for i in range(len(weights)-1):\\n            s.append(weights[i]+weights[i+1])\\n\\n\\n        s.sort()\\n\\n        return sum(s[-k+1:])-sum(s[:k-1])\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        if k == 1 or k == len(weights): return 0\\n\\n        s = []\\n\\n        for i in range(len(weights)-1):\\n            s.append(weights[i]+weights[i+1])\\n\\n\\n        s.sort()\\n\\n        return sum(s[-k+1:])-sum(s[:k-1])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747760,
                "title": "c",
                "content": "\\n# Code\\n```\\nint asscend_func(const void * a, const void * b){\\n    return *(int*)a - *(int*) b;\\n}\\n\\nlong long putMarbles(int* weights, int weightsSize, int k){\\n    //if there is only one bag or mags equal to size of weights then the min max will be 0\\n    if(k==1 || weightsSize == k){return 0;}\\n    int* sum_of_weights = (int*)calloc(weightsSize - 1, sizeof(int));\\n    //we will populate array of sum with sumation of all the weights\\n    for(int iter =0; iter < weightsSize - 1; iter++){\\n        sum_of_weights[iter] = weights[iter] + weights[iter + 1];\\n    }\\n    qsort(sum_of_weights,weightsSize - 1, sizeof(int),asscend_func);\\n    //min_max value represents the minimum count and the maximum count in bag\\n    long long min_count = weights[0] + weights[weightsSize -1];\\n    long long max_count = weights[0] + weights[weightsSize -1];\\n    for(int iter = 0; iter < k - 1; iter++){\\n        min_count += sum_of_weights[iter];\\n        max_count += sum_of_weights[weightsSize - 2 - iter];\\n    }\\n    return max_count - min_count;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint asscend_func(const void * a, const void * b){\\n    return *(int*)a - *(int*) b;\\n}\\n\\nlong long putMarbles(int* weights, int weightsSize, int k){\\n    //if there is only one bag or mags equal to size of weights then the min max will be 0\\n    if(k==1 || weightsSize == k){return 0;}\\n    int* sum_of_weights = (int*)calloc(weightsSize - 1, sizeof(int));\\n    //we will populate array of sum with sumation of all the weights\\n    for(int iter =0; iter < weightsSize - 1; iter++){\\n        sum_of_weights[iter] = weights[iter] + weights[iter + 1];\\n    }\\n    qsort(sum_of_weights,weightsSize - 1, sizeof(int),asscend_func);\\n    //min_max value represents the minimum count and the maximum count in bag\\n    long long min_count = weights[0] + weights[weightsSize -1];\\n    long long max_count = weights[0] + weights[weightsSize -1];\\n    for(int iter = 0; iter < k - 1; iter++){\\n        min_count += sum_of_weights[iter];\\n        max_count += sum_of_weights[weightsSize - 2 - iter];\\n    }\\n    return max_count - min_count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746026,
                "title": "python-solution-with-sorting-and-intuition-behind",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwith greedy method find min and max values from paritions:\\neg. a b c d e f g h i and k=3\\nif we spilts as: a | b c d e | f g h i\\nsum as: (a+a)+(b+e)+(f+i)\\nrefomated: a+(a+b)+(e+f)+i <-- that k-1 pairs of consecutive items plus first and last ones\\n**so they answer is: find k-1 max-values/min-values of consecutive pair\\nand substracted them.**\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nedge case:k=1 means whole array just only one paition so max=min=a[-1]+a[0],answer=0\\n1. sum up every consecutive pair of items in array\\n2. sort them \\n3. select first k-1 and last k-1 items and sum up: answer=sum(sums[-k+1:])-sum(sums[:k-1]) \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N*lgN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def putMarbles(self, weights, k):\\n        \"\"\"\\n        :type weights: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if k==1:return 0\\n        sums=[0]*(len(weights)-1)\\n        for i in range(1,len(weights)):sums[i-1]=weights[i-1]+weights[i]\\n        sums=sorted(sums)\\n        return sum(sums[-k+1:])-sum(sums[:k-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution(object):\\n    def putMarbles(self, weights, k):\\n        \"\"\"\\n        :type weights: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        if k==1:return 0\\n        sums=[0]*(len(weights)-1)\\n        for i in range(1,len(weights)):sums[i-1]=weights[i-1]+weights[i]\\n        sums=sorted(sums)\\n        return sum(sums[-k+1:])-sum(sums[:k-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3745221,
                "title": "building-up-from-basic-intuition",
                "content": "# Intuition\\nLet\\'s go with the natural intution of having to form k-1 boundaries and then taking the sum of first and last element of each subarray enclosed within two consecutive boundaries.\\nBut there are a lot of ways to arrange those boundaries and hence the subarrays enclosed.\\nLet\\'s make the implementation easier with the following observation:\\nSuppose weights array is\\n`1 2 3 11 4 6 7` and `k = 2`\\n\\nand say you insert boundary like this\\n`1 2 3 | 11 4 6 7`\\n\\nNow when you move on to find max_score (say) you do\\n`wt[0] + wt[boundary_pos-1] + wt[boundary_pos+1] + wt[n-1]`\\n\\nYou won\\'t be inserting the boundaries practically so, -1 and +1 in indices need to be adjusted accordingly\\n\\n# Approach\\n\\nNow that you know that only the elements to the left and right of a boundary matter, you can simply form an array of size n-1 which has sum of all adjacent pairs.\\n\\nthen,\\nmax_score= `a[0] + a[len-1] + summation of largest k-1 values from a`,\\nmin_score= `a[0] + a[len-1] + summation of smallest k-1 values from a`\\nthen when you take difference the first and last elements lose their role thus it just **boils down to (largest k-1 - smallest k-1) adjacent pair sums**\\n\\nWohoo! we\\'re done with the thought process and build-up part, now what\\'s remaining is to code it.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& wt, int k) {\\n\\n        //form boundaries instead of forming partitions\\n        //find top k-1 elements from all x, x+1s i.e. to say boundary exists b/w x & x+1\\n\\n        int n=wt.size();\\n        vector<ll> a;\\n        \\n        for(int i=1; i<n; i++){\\n            a.push_back(wt[i-1]+wt[i]);\\n        }\\n\\n        //max_score=f+l+ largest k-1 in [1,n-2]\\n        //min_score=f+l+ smallest k-1 in [1,n-2]\\n\\n        k-=1;\\n        sort(a.begin(), a.end());\\n        ll min_score=0, max_score=0;\\n        n=a.size();\\n\\n        for(int i=0;i<k;i++)min_score+=a[i];\\n        for(int i=n-k;i<n;i++)max_score+=a[i];\\n\\n        return max_score-min_score;      \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& wt, int k) {\\n\\n        //form boundaries instead of forming partitions\\n        //find top k-1 elements from all x, x+1s i.e. to say boundary exists b/w x & x+1\\n\\n        int n=wt.size();\\n        vector<ll> a;\\n        \\n        for(int i=1; i<n; i++){\\n            a.push_back(wt[i-1]+wt[i]);\\n        }\\n\\n        //max_score=f+l+ largest k-1 in [1,n-2]\\n        //min_score=f+l+ smallest k-1 in [1,n-2]\\n\\n        k-=1;\\n        sort(a.begin(), a.end());\\n        ll min_score=0, max_score=0;\\n        n=a.size();\\n\\n        for(int i=0;i<k;i++)min_score+=a[i];\\n        for(int i=n-k;i<n;i++)max_score+=a[i];\\n\\n        return max_score-min_score;      \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744559,
                "title": "intuitive-explaination",
                "content": "# Intuition\\nThe question is pretty hard one and requires observation to solve it.\\nAfter going through a lot of solution I was able to understand the logic and would try to explain as much as I can.\\n\\nThis question is very important question and pattern used here could be used to solve many hard-level problems.\\n\\n# Approach\\n- Suppose we have an array like [a,b,c,d,e,f,g] and we need to make 3 partitions. So in all we need to make 2 cuts. (For k partitions in array perform k-1 cuts)\\n- Suppose, We make first cut between b and c, second cut between e and f.\\n- So our score would be {a+b} +{c+e} +{f+g}.\\n- Now one thing to observe is that first value and last value would come in all the cuts. (I.E a and g would come in all the cuts).\\n- So if we are to subtract max sum - min sum, and we are sure that \\'a\\' and \\'g\\' would come in all the partitions  that means it would come in our maxSum parition as well as minimumSum partition. So we can ignore it, since it is going to cancel out.\\n- Now with the remaining numbers left we have {b}{c+e}{f}\\n- So we can observe that wherever we made a cut, the left element and right element is there. Here we made a cut between b and c, so we are having b+c, similarly we are also having e+f.\\n- **So we can say that if we are to find all the partitions, then we can consider all the pair sum. Because partition will be between any 2 elements, and as proved above they will form our ans.**\\n- So we will find sum of consecutive 2 elements, and store it in our ans vector. Sort it and from there, to find maxSum we can take ending k-1 elements from sorted array  to find MinSum we can take starting k-1 elements from sorted array\\n\\n# Complexity\\n- **Time complexity**:\\nWe are just sorting the array, TC O(nlogn)\\n\\n-**Space complexity**:\\nIn order to store the pairsum we would require SC O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long> v;\\n        for(int i=1;i<weights.size();i++){\\n            v.push_back(weights[i]+weights[i-1]);\\n        }\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        long long mini=0;\\n        for(int i=0;i<k-1;i++){\\n            mini+= v[i];\\n        }\\n\\n        long long maxi=0;\\n        for(int i=0;i<k-1;i++){\\n            maxi+= v[n-1-i];\\n        }\\n        return maxi - mini;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long> v;\\n        for(int i=1;i<weights.size();i++){\\n            v.push_back(weights[i]+weights[i-1]);\\n        }\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        long long mini=0;\\n        for(int i=0;i<k-1;i++){\\n            mini+= v[i];\\n        }\\n\\n        long long maxi=0;\\n        for(int i=0;i<k-1;i++){\\n            maxi+= v[n-1-i];\\n        }\\n        return maxi - mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743774,
                "title": "javascript-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} weights\\n * @param {number} k\\n * @return {number}\\n */\\nvar putMarbles = function(weights, k) {\\n\\n    let n = weights.length\\n    let vals = []\\n\\n    for(i=0; i<weights.length-1; i++){\\n        vals.push(weights[i]+weights[i+1])\\n    }\\n\\n    vals.sort((a,b) => a-b)\\n    console.log(vals)\\n\\n    let sumMax = 0\\n\\n    for (i=0; i<k-1; i++){\\n        sumMax += vals[vals.length -1 - i]\\n        sumMax -= vals[i] \\n    }\\n\\n    return sumMax\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} weights\\n * @param {number} k\\n * @return {number}\\n */\\nvar putMarbles = function(weights, k) {\\n\\n    let n = weights.length\\n    let vals = []\\n\\n    for(i=0; i<weights.length-1; i++){\\n        vals.push(weights[i]+weights[i+1])\\n    }\\n\\n    vals.sort((a,b) => a-b)\\n    console.log(vals)\\n\\n    let sumMax = 0\\n\\n    for (i=0; i<k-1; i++){\\n        sumMax += vals[vals.length -1 - i]\\n        sumMax -= vals[i] \\n    }\\n\\n    return sumMax\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743397,
                "title": "greedy-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nReading the question initially, it seems to have all the constituents of a DP problem, but after seeing the bounds, we quickly have to refresh our approach. An optimization problem with high bounds is always a good recipe for greedy. Here is a video solution:  \\n\\nhttps://www.youtube.com/watch?v=GreUNm4FU-M\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(nlog(n))$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        long[] A = new long[n];\\n        for (int i = 0; i < n; i++) {\\n            A[i] = weights[i];\\n        }\\n        long net = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            net += A[i];\\n        }\\n\\n        net = net + net;\\n\\n        ArrayList<Long> sums = new ArrayList<Long>();\\n        for (int i = 0; i < n-1; i++) {\\n            sums.add(A[i] + A[i+1]);\\n        }\\n\\n        Collections.sort(sums);\\n        long max = net;\\n        long min = net;\\n\\n        for (int i = 0; i < n-k; i++) {\\n            max -= sums.get(i);\\n        }\\n\\n        for (int i = (n-2) - (n-k) + 1; i <= n-2; i++) {\\n            min -= sums.get(i);\\n        }\\n\\n        return max - min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long putMarbles(int[] weights, int k) {\\n        int n = weights.length;\\n        long[] A = new long[n];\\n        for (int i = 0; i < n; i++) {\\n            A[i] = weights[i];\\n        }\\n        long net = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            net += A[i];\\n        }\\n\\n        net = net + net;\\n\\n        ArrayList<Long> sums = new ArrayList<Long>();\\n        for (int i = 0; i < n-1; i++) {\\n            sums.add(A[i] + A[i+1]);\\n        }\\n\\n        Collections.sort(sums);\\n        long max = net;\\n        long min = net;\\n\\n        for (int i = 0; i < n-k; i++) {\\n            max -= sums.get(i);\\n        }\\n\\n        for (int i = (n-2) - (n-k) + 1; i <= n-2; i++) {\\n            min -= sums.get(i);\\n        }\\n\\n        return max - min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739398,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long n=weights.size(), min=0, max=0;\\n        if(k==1 || k==n){return 0;}\\n        vector<long long> v;\\n        for(int i=0;i<n-1;i++){\\n            v.push_back(weights[i]+weights[i+1]);\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<k-1;i++){\\n            min+=v[i];\\n            max+=v[v.size()-1-i];\\n        }\\n        return max-min;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        long long n=weights.size(), min=0, max=0;\\n        if(k==1 || k==n){return 0;}\\n        vector<long long> v;\\n        for(int i=0;i<n-1;i++){\\n            v.push_back(weights[i]+weights[i+1]);\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<k-1;i++){\\n            min+=v[i];\\n            max+=v[v.size()-1-i];\\n        }\\n        return max-min;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3738911,
                "title": "time-efficient-7-line-solution-using-sorting-and-greedy-property",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this solution was that the actual order did not really matter, all that mattered was how they were seperated into k bags, and specifically the sum of the first and last element in these bags. Hence, a greedy solution locally, this will apply globally is that we just need to select positions to break the list into bags, and these can be sums where the right and left elements are either minimal or maximal. The shift to evaluating paris next to eachoither is ok as at the end we are summing them up, and hence we are in actuality looking for an end to the first bag and start to the second bag that is minimal. This also allows for easy accounting of the first and last element.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we make a new array that is the sum of all possible two adjacent weights. Including the first and the last. Then we sort it in increasing order. From here we return the sum of the first k-1 and last k-1 elements of the sorted array. We do k-1 instead of k to account for the first and last element always being a part of the sum. Should they be part of the optimal bags, then they will always be double counted (as this implies a abg of either first and or last element only). We only count them once and do niot add them again, as we would theoretically add the first and last value to every min and max score, and since we are taking the difference of two socres, these one time appearances would be eliminated. \\n\\nNote: len(weights) is always 1 element larger than break_sums, which when subtracting k give len(break_sums) - k + 1, which wehn on the left side of the splice leads to k-1 last elements.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n log(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        break_sums = []\\n        prev = weights[0]\\n\\n        for i in range(1, len(weights)):\\n            break_sums.append(prev + weights[i])\\n            prev = weights[i]\\n\\n        break_sums.sort()\\n        return (sum(break_sums[len(weights) - k:]) - sum(break_sums[:k - 1]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def putMarbles(self, weights: List[int], k: int) -> int:\\n        break_sums = []\\n        prev = weights[0]\\n\\n        for i in range(1, len(weights)):\\n            break_sums.append(prev + weights[i])\\n            prev = weights[i]\\n\\n        break_sums.sort()\\n        return (sum(break_sums[len(weights) - k:]) - sum(break_sums[:k - 1]))\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1779614,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1779303,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1778647,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1960495,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1960707,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1779524,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1961012,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1779325,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1960784,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1788100,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1779614,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1779303,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1778647,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1960495,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1960707,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1779524,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1961012,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1779325,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1960784,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1788100,
                "content": [
                    {
                        "username": "bhaskar123u",
                        "content": "1. you have to put k-1 partitions\\n2. Bags cannot be empty hence the smallest first partition that you can make is after 1st element\\n3. Whatever partition you make the first and last element will always be added\\n4. Let\\'s say you have done some partition and sum till now is (x), if you put another partition at index j, the sum will increase by arr[j] + arr[j+1] and it will become (x + arr[j] + arr[j+1])\\n5. If you pre-calculate in some way the cost of partition at each index then you can choose max k among them and min k among then\\n6. The difference obtained in step 5 will be your answer"
                    },
                    {
                        "username": "Nischay-Raj",
                        "content": "Thanks for the hint man"
                    },
                    {
                        "username": "Kunal19880711",
                        "content": "Thanks for your hint."
                    },
                    {
                        "username": "Govind_jha_01",
                        "content": "Just wow! Commendable explanation .\\n"
                    },
                    {
                        "username": "Baymax_",
                        "content": "This explanation is clean, precise and simple.\n\n![Upvote from me.jpg](https://assets.leetcode.com/users/images/54729994-dcc5-470a-8c38-cb315eb47f66_1688796665.6087735.jpeg)"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "you made this problem look simpler. aabhar ho bhaskarbhai"
                    },
                    {
                        "username": "tehpolecat",
                        "content": "damn, i was close. I started thinking of it as picking 2*k numbers but ran into issues because picking one number means you have to pick the one next to it, i didn't make the next step of thinking of the numbers in groups of two. Needs a shift of perspective from thinking about (start ,end) to thinking about (end,start) instead. I should have made the connection since you are required to pick the first and last number."
                    },
                    {
                        "username": "yingtu35",
                        "content": "It\\'s incredible to look at the problem this way. Thank you for the hint!"
                    },
                    {
                        "username": "cursydd",
                        "content": "thank you for these hints"
                    },
                    {
                        "username": "benp68384",
                        "content": "I wonder how did the Problem setter get the intuition for this question. \\nI would like to see similar problems like this."
                    },
                    {
                        "username": "feng3245",
                        "content": "It goes like this... think of a problem that you can figure out with a simple solution... find a way to word it such that it doesn\\'t tell people what you did to solve the problem and throw in some words and terms that give false intuition. Voila a mfkin hard question!"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Really?! this has to be one of my least favourite problems, very hard to understand, because of the convoluted description. And once you understand what is actually being asked it is boring to solve. The first two hints are actually just the requirements but explained clearly.  And the last hint is BS, since the best solutions don't use PQ at all, I as sorting before, changed it two PQ because of the hint, only to see the official and best solutions use sorting."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@theRadFad](/theRadFad) Exactly, because no real life problem would actually be so weird and senseless"
                    },
                    {
                        "username": "theRadFad",
                        "content": "It sounds like the kind of problem that you start from defining the solution for and then you have to devise a proper problem statement for this solution."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "I was messing up with DP this whole time \\uD83E\\uDEE5\\uD83D\\uDE11\\uD83D\\uDE36"
                    },
                    {
                        "username": "cecilia5",
                        "content": "[@rohit__27](/rohit__27) DP is all about what subproblem answers you wish to have, and for this problem it is pretty obvious. Whatever you do, the first bag of marble must contain the 0th marble - we don\\'t know where it ends yet, but let\\'s say we do, that it ends at the xth marble. Now what would you like to do next?\\n\\nYou will wish to have the answer to the subproblem of picking marbles [x+1 .... n) into k - 1 bags, right? That\\'s pretty much all of it. Once you have the right subproblem designed, the recursion formula is right there for you.\\n\\nThe maximum way to split [0..n) into k bag is the maximum across all x, cost of first bag + subproblem answer = weights[0] + weights[x] + dp[x + 1][k - 1]\\n\\n> Of course - you also do the minimum, that is completely symmetric.\\n\\nThis is going to be an awful solution with time $$ O(n^2k) $$  because now you need to compute $$ O(nk) $$ answers in the dp array and every computation involve taking a maximum over all possible $$ x $$.\\n\\nBut wait - if we are computing the dp values, can\\'t we just compute the running maximum as well? That will allow us to skip the minimum computation and bring the complexity to $$ O(nk) $$, which is still not enough.\\n\\nThe sad part is that this is the end of it. If the dp array has $$ nk $$ holes to fill, you can\\'t possibly get any faster than $$ O(nk) $$, and it is obvious that $$ O(nk) $$ is not going to pass the judge given the constraints."
                    },
                    {
                        "username": "rohit__27",
                        "content": "[@cecilia5](/cecilia5)  Atleast you applied Dp successfully, I wasn\\'t even able to do that"
                    },
                    {
                        "username": "cecilia5",
                        "content": "I spent two hours trying to optimize the DP just to realize it is a futile attempt.\\n\\nThe obvious DP is O(nk) and I was hoping to make it O(k log n). Tried crazy things like segment tree, RMQ, nothing works.\\n\\nIf you ask n questions per k, you will have at least O(nk), no way to get any faster.\\n\\nI just come to realize that seemingly stupid fact too late.\\n\\nOnce I make up my mind to drop DP, the rest is obvious.\\n\\nI guess it is a lesson on give up. The difficult part of giving up on the DP approach is that it works! But work doesn\\'t mean much if it doesn\\'t run fast enough.\\n\\nIn a competition settings, if I don\\'t give up fast enough, I will lose. I need to learn to give up fast. "
                    },
                    {
                        "username": "tehpolecat",
                        "content": "[@AKXYN](/AKXYN) I try not to use the tags as you won\\'t have them in practice and part of problem solving is figuring out which approach to use. It\\'s reasonable to ask for constraints in an interview though."
                    },
                    {
                        "username": "poddar28",
                        "content": "The topic tags and the constraints helped me from trying DP \\uD83D\\uDE05"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "[@VinayV9](/VinayV9) right. I got TLE even if the DP solution was completely correct. "
                    },
                    {
                        "username": "VinayV9",
                        "content": "n is 10^5 so for DP we may get N^2 solution which 10 ^ 10 which will lead to time out. this will help you which approach is better max 10 ^ 8 operations can be done."
                    },
                    {
                        "username": "a801a28cb4b6e70a",
                        "content": "[@math3846](/math3846) me too!"
                    },
                    {
                        "username": "math3846",
                        "content": "Me too lol"
                    },
                    {
                        "username": "anwendeng",
                        "content": "Try to transform this question to the form what I can understand!\nWhat is the essential meaning for a partition?\nFind k-1 pairs (weights[P[i]], weights[P[i]+1])   where P[i] denotes the end index for the i-th subarray for this partition P . The  score  for the this partition P is \n$$\nscore(P)=weights[0]+weights[n-1]+\\sum_i (weights[P[i]]+weights[P[i]+1])\n$$\nThe wanted answer is\n$$\n\\max_P score(P)-\\min_P score(P)\n$$"
                    },
                    {
                        "username": "rahulsiloniya",
                        "content": "Thanks, this worked like wonder. Got accepted in one submission.\\n\\nFor someone who didn\\'t understand it mathematically, in the above explanation the idea is to add ends of adjacent subarrays instead of the ends of the same subarray.\\n\\nThen sort the sums and select the total of k - 1 from top and bottom and return the difference."
                    },
                    {
                        "username": "zenshaun",
                        "content": "I\\'m perhaps the only one feeling like an idiot, not being able to come up with a solution \\n-- (Saying this after reading people\\'s comments calling this problem easier than hard :( )"
                    },
                    {
                        "username": "AssortedFantasy",
                        "content": "The code is very easy. The description is terrible."
                    },
                    {
                        "username": "Baymax_",
                        "content": "[@Shaurya](/zenshaun) You should not feel that way bro... <i>The categorization of <b>Easy/Medium/Hard</b> problems </i>will not always be simply on the way it needs to be solved. <i>Sometimes it\\'ll also be on how difficult it is to understand the problem too (multiple factors affect this)... So, this time, it is simply the later. "
                    },
                    {
                        "username": "zenshaun",
                        "content": "[@Kaltu](/Kaltu) Damn right my man! :\\')"
                    },
                    {
                        "username": "Kaltu",
                        "content": "not your fault, the description is intentially deceiving you to think about marbles and ommiting crutial information like you need to used up all the marbles or a bag can only have one continous streak of marbles, while the problem is actually focus on the boundaries of the cut where you partition the marbles\nit is a hard problem only because the outstandingly bad description,\nif the question ask you directly to find the difference between the sum of max and sum of min pairs in an array, it becomes an easy problem."
                    },
                    {
                        "username": "alin99",
                        "content": "Wow I thought this was a dp question lol"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Problem:** Unintuitive\\n**Hint 1:** Already mentioned in problem\\n**Hint 2:** Already mentioned in problem\\n**Hint 3:** No logic, just use priority Queue\\n**Me:** \\uD83D\\uDE11\\uD83D\\uDE11"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Sad thing is, I don\\'t know priority queue."
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "hint 3 mentioned in Related Topics"
                    },
                    {
                        "username": "HealthySG",
                        "content": "we need to distribute all marbles."
                    },
                    {
                        "username": "Kaltu",
                        "content": "This should be said in the description. \\nBased on the description, the problem is easy or medium, the minimum is always smallest k marbles and the maximumis always largest k marbles, each in a bag alone, leaving the rest of marbles out."
                    },
                    {
                        "username": "kchong0506",
                        "content": "This hint is the most useless one I have seen \\uD83D\\uDE35\\u200D\\uD83D\\uDCAB"
                    },
                    {
                        "username": "stefan1096",
                        "content": "Look at this https://leetcode.com/problems/largest-magic-square/"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "So it seems that the only \"hard\" part of this question is figuring out that you don\\'t need DP or other fancy methods xD\\nc\\'mon... "
                    }
                ]
            },
            {
                "id": 1961677,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "I don\\'t know what should bother me more. The fact that I couldn\\'t solve this problem or the fact that people out here are claiming that this problem should be in the Easy section?"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "This was a nice question.. really feels good when you figure out the solution !"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Third hint: Try to use Priority queue\nlol even the editorial doesn't use it"
                    },
                    {
                        "username": "Kaltu",
                        "content": "the editorial sort it directly so it took O(n log n) which is slower than the priority queue if a min heap and a max heap were used, then that will be O(n + 2 k log n)"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "This problem should be a medium."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@life_is_lie](/life_is_lie) Even thought based it\\'s a medium. The problem is that the question is not explained clearly at all, and there are no useful examples."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "implementation based yes, thought based no"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "how come the acceptance rate is more than 67% ? am i the only one struggling in understanding even example test cases :)"
                    },
                    {
                        "username": "ivzap",
                        "content": "How one sees the trick of a[j] + a[j+1] is beyond me..."
                    },
                    {
                        "username": "julkar9",
                        "content": "same here"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Remember that if a bag contains only 1 marble from position 'i' then\nThe weight of that bag is `weight[ i ] + weight[ i ]`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Once you think it mathmatically, it becomes very simple and straightforward."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "You will kill yourself after looking at the solution "
                    },
                    {
                        "username": "jincanchamber",
                        "content": "don\\'t tempt me "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "I actually thought this question gonna be solved by DP. \nNot give a second and started coding build the logic but due to constraint it gives TLE.\nAnd also Leetcode sucks at giving hints(in this question):\n1. every bag contain subarray\n2. endpoints matter\n3. use priority queue"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "[@Kaltu](/Kaltu)  yeap \\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp is a valid solution to the problem, we just having a tigher constraint"
                    }
                ]
            },
            {
                "id": 1960788,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "I don\\'t know what should bother me more. The fact that I couldn\\'t solve this problem or the fact that people out here are claiming that this problem should be in the Easy section?"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "This was a nice question.. really feels good when you figure out the solution !"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Third hint: Try to use Priority queue\nlol even the editorial doesn't use it"
                    },
                    {
                        "username": "Kaltu",
                        "content": "the editorial sort it directly so it took O(n log n) which is slower than the priority queue if a min heap and a max heap were used, then that will be O(n + 2 k log n)"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "This problem should be a medium."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@life_is_lie](/life_is_lie) Even thought based it\\'s a medium. The problem is that the question is not explained clearly at all, and there are no useful examples."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "implementation based yes, thought based no"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "how come the acceptance rate is more than 67% ? am i the only one struggling in understanding even example test cases :)"
                    },
                    {
                        "username": "ivzap",
                        "content": "How one sees the trick of a[j] + a[j+1] is beyond me..."
                    },
                    {
                        "username": "julkar9",
                        "content": "same here"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Remember that if a bag contains only 1 marble from position 'i' then\nThe weight of that bag is `weight[ i ] + weight[ i ]`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Once you think it mathmatically, it becomes very simple and straightforward."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "You will kill yourself after looking at the solution "
                    },
                    {
                        "username": "jincanchamber",
                        "content": "don\\'t tempt me "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "I actually thought this question gonna be solved by DP. \nNot give a second and started coding build the logic but due to constraint it gives TLE.\nAnd also Leetcode sucks at giving hints(in this question):\n1. every bag contain subarray\n2. endpoints matter\n3. use priority queue"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "[@Kaltu](/Kaltu)  yeap \\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp is a valid solution to the problem, we just having a tigher constraint"
                    }
                ]
            },
            {
                "id": 1960838,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "I don\\'t know what should bother me more. The fact that I couldn\\'t solve this problem or the fact that people out here are claiming that this problem should be in the Easy section?"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "This was a nice question.. really feels good when you figure out the solution !"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Third hint: Try to use Priority queue\nlol even the editorial doesn't use it"
                    },
                    {
                        "username": "Kaltu",
                        "content": "the editorial sort it directly so it took O(n log n) which is slower than the priority queue if a min heap and a max heap were used, then that will be O(n + 2 k log n)"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "This problem should be a medium."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@life_is_lie](/life_is_lie) Even thought based it\\'s a medium. The problem is that the question is not explained clearly at all, and there are no useful examples."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "implementation based yes, thought based no"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "how come the acceptance rate is more than 67% ? am i the only one struggling in understanding even example test cases :)"
                    },
                    {
                        "username": "ivzap",
                        "content": "How one sees the trick of a[j] + a[j+1] is beyond me..."
                    },
                    {
                        "username": "julkar9",
                        "content": "same here"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Remember that if a bag contains only 1 marble from position 'i' then\nThe weight of that bag is `weight[ i ] + weight[ i ]`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Once you think it mathmatically, it becomes very simple and straightforward."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "You will kill yourself after looking at the solution "
                    },
                    {
                        "username": "jincanchamber",
                        "content": "don\\'t tempt me "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "I actually thought this question gonna be solved by DP. \nNot give a second and started coding build the logic but due to constraint it gives TLE.\nAnd also Leetcode sucks at giving hints(in this question):\n1. every bag contain subarray\n2. endpoints matter\n3. use priority queue"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "[@Kaltu](/Kaltu)  yeap \\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp is a valid solution to the problem, we just having a tigher constraint"
                    }
                ]
            },
            {
                "id": 1960647,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "I don\\'t know what should bother me more. The fact that I couldn\\'t solve this problem or the fact that people out here are claiming that this problem should be in the Easy section?"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "This was a nice question.. really feels good when you figure out the solution !"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Third hint: Try to use Priority queue\nlol even the editorial doesn't use it"
                    },
                    {
                        "username": "Kaltu",
                        "content": "the editorial sort it directly so it took O(n log n) which is slower than the priority queue if a min heap and a max heap were used, then that will be O(n + 2 k log n)"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "This problem should be a medium."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@life_is_lie](/life_is_lie) Even thought based it\\'s a medium. The problem is that the question is not explained clearly at all, and there are no useful examples."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "implementation based yes, thought based no"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "how come the acceptance rate is more than 67% ? am i the only one struggling in understanding even example test cases :)"
                    },
                    {
                        "username": "ivzap",
                        "content": "How one sees the trick of a[j] + a[j+1] is beyond me..."
                    },
                    {
                        "username": "julkar9",
                        "content": "same here"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Remember that if a bag contains only 1 marble from position 'i' then\nThe weight of that bag is `weight[ i ] + weight[ i ]`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Once you think it mathmatically, it becomes very simple and straightforward."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "You will kill yourself after looking at the solution "
                    },
                    {
                        "username": "jincanchamber",
                        "content": "don\\'t tempt me "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "I actually thought this question gonna be solved by DP. \nNot give a second and started coding build the logic but due to constraint it gives TLE.\nAnd also Leetcode sucks at giving hints(in this question):\n1. every bag contain subarray\n2. endpoints matter\n3. use priority queue"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "[@Kaltu](/Kaltu)  yeap \\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp is a valid solution to the problem, we just having a tigher constraint"
                    }
                ]
            },
            {
                "id": 1961807,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "I don\\'t know what should bother me more. The fact that I couldn\\'t solve this problem or the fact that people out here are claiming that this problem should be in the Easy section?"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "This was a nice question.. really feels good when you figure out the solution !"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Third hint: Try to use Priority queue\nlol even the editorial doesn't use it"
                    },
                    {
                        "username": "Kaltu",
                        "content": "the editorial sort it directly so it took O(n log n) which is slower than the priority queue if a min heap and a max heap were used, then that will be O(n + 2 k log n)"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "This problem should be a medium."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@life_is_lie](/life_is_lie) Even thought based it\\'s a medium. The problem is that the question is not explained clearly at all, and there are no useful examples."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "implementation based yes, thought based no"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "how come the acceptance rate is more than 67% ? am i the only one struggling in understanding even example test cases :)"
                    },
                    {
                        "username": "ivzap",
                        "content": "How one sees the trick of a[j] + a[j+1] is beyond me..."
                    },
                    {
                        "username": "julkar9",
                        "content": "same here"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Remember that if a bag contains only 1 marble from position 'i' then\nThe weight of that bag is `weight[ i ] + weight[ i ]`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Once you think it mathmatically, it becomes very simple and straightforward."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "You will kill yourself after looking at the solution "
                    },
                    {
                        "username": "jincanchamber",
                        "content": "don\\'t tempt me "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "I actually thought this question gonna be solved by DP. \nNot give a second and started coding build the logic but due to constraint it gives TLE.\nAnd also Leetcode sucks at giving hints(in this question):\n1. every bag contain subarray\n2. endpoints matter\n3. use priority queue"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "[@Kaltu](/Kaltu)  yeap \\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp is a valid solution to the problem, we just having a tigher constraint"
                    }
                ]
            },
            {
                "id": 1961772,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "I don\\'t know what should bother me more. The fact that I couldn\\'t solve this problem or the fact that people out here are claiming that this problem should be in the Easy section?"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "This was a nice question.. really feels good when you figure out the solution !"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Third hint: Try to use Priority queue\nlol even the editorial doesn't use it"
                    },
                    {
                        "username": "Kaltu",
                        "content": "the editorial sort it directly so it took O(n log n) which is slower than the priority queue if a min heap and a max heap were used, then that will be O(n + 2 k log n)"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "This problem should be a medium."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@life_is_lie](/life_is_lie) Even thought based it\\'s a medium. The problem is that the question is not explained clearly at all, and there are no useful examples."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "implementation based yes, thought based no"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "how come the acceptance rate is more than 67% ? am i the only one struggling in understanding even example test cases :)"
                    },
                    {
                        "username": "ivzap",
                        "content": "How one sees the trick of a[j] + a[j+1] is beyond me..."
                    },
                    {
                        "username": "julkar9",
                        "content": "same here"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Remember that if a bag contains only 1 marble from position 'i' then\nThe weight of that bag is `weight[ i ] + weight[ i ]`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Once you think it mathmatically, it becomes very simple and straightforward."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "You will kill yourself after looking at the solution "
                    },
                    {
                        "username": "jincanchamber",
                        "content": "don\\'t tempt me "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "I actually thought this question gonna be solved by DP. \nNot give a second and started coding build the logic but due to constraint it gives TLE.\nAnd also Leetcode sucks at giving hints(in this question):\n1. every bag contain subarray\n2. endpoints matter\n3. use priority queue"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "[@Kaltu](/Kaltu)  yeap \\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp is a valid solution to the problem, we just having a tigher constraint"
                    }
                ]
            },
            {
                "id": 1960630,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "I don\\'t know what should bother me more. The fact that I couldn\\'t solve this problem or the fact that people out here are claiming that this problem should be in the Easy section?"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "This was a nice question.. really feels good when you figure out the solution !"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Third hint: Try to use Priority queue\nlol even the editorial doesn't use it"
                    },
                    {
                        "username": "Kaltu",
                        "content": "the editorial sort it directly so it took O(n log n) which is slower than the priority queue if a min heap and a max heap were used, then that will be O(n + 2 k log n)"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "This problem should be a medium."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@life_is_lie](/life_is_lie) Even thought based it\\'s a medium. The problem is that the question is not explained clearly at all, and there are no useful examples."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "implementation based yes, thought based no"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "how come the acceptance rate is more than 67% ? am i the only one struggling in understanding even example test cases :)"
                    },
                    {
                        "username": "ivzap",
                        "content": "How one sees the trick of a[j] + a[j+1] is beyond me..."
                    },
                    {
                        "username": "julkar9",
                        "content": "same here"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Remember that if a bag contains only 1 marble from position 'i' then\nThe weight of that bag is `weight[ i ] + weight[ i ]`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Once you think it mathmatically, it becomes very simple and straightforward."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "You will kill yourself after looking at the solution "
                    },
                    {
                        "username": "jincanchamber",
                        "content": "don\\'t tempt me "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "I actually thought this question gonna be solved by DP. \nNot give a second and started coding build the logic but due to constraint it gives TLE.\nAnd also Leetcode sucks at giving hints(in this question):\n1. every bag contain subarray\n2. endpoints matter\n3. use priority queue"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "[@Kaltu](/Kaltu)  yeap \\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp is a valid solution to the problem, we just having a tigher constraint"
                    }
                ]
            },
            {
                "id": 1960536,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "I don\\'t know what should bother me more. The fact that I couldn\\'t solve this problem or the fact that people out here are claiming that this problem should be in the Easy section?"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "This was a nice question.. really feels good when you figure out the solution !"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Third hint: Try to use Priority queue\nlol even the editorial doesn't use it"
                    },
                    {
                        "username": "Kaltu",
                        "content": "the editorial sort it directly so it took O(n log n) which is slower than the priority queue if a min heap and a max heap were used, then that will be O(n + 2 k log n)"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "This problem should be a medium."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@life_is_lie](/life_is_lie) Even thought based it\\'s a medium. The problem is that the question is not explained clearly at all, and there are no useful examples."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "implementation based yes, thought based no"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "how come the acceptance rate is more than 67% ? am i the only one struggling in understanding even example test cases :)"
                    },
                    {
                        "username": "ivzap",
                        "content": "How one sees the trick of a[j] + a[j+1] is beyond me..."
                    },
                    {
                        "username": "julkar9",
                        "content": "same here"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Remember that if a bag contains only 1 marble from position 'i' then\nThe weight of that bag is `weight[ i ] + weight[ i ]`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Once you think it mathmatically, it becomes very simple and straightforward."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "You will kill yourself after looking at the solution "
                    },
                    {
                        "username": "jincanchamber",
                        "content": "don\\'t tempt me "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "I actually thought this question gonna be solved by DP. \nNot give a second and started coding build the logic but due to constraint it gives TLE.\nAnd also Leetcode sucks at giving hints(in this question):\n1. every bag contain subarray\n2. endpoints matter\n3. use priority queue"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "[@Kaltu](/Kaltu)  yeap \\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp is a valid solution to the problem, we just having a tigher constraint"
                    }
                ]
            },
            {
                "id": 1960866,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "I don\\'t know what should bother me more. The fact that I couldn\\'t solve this problem or the fact that people out here are claiming that this problem should be in the Easy section?"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "This was a nice question.. really feels good when you figure out the solution !"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Third hint: Try to use Priority queue\nlol even the editorial doesn't use it"
                    },
                    {
                        "username": "Kaltu",
                        "content": "the editorial sort it directly so it took O(n log n) which is slower than the priority queue if a min heap and a max heap were used, then that will be O(n + 2 k log n)"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "This problem should be a medium."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@life_is_lie](/life_is_lie) Even thought based it\\'s a medium. The problem is that the question is not explained clearly at all, and there are no useful examples."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "implementation based yes, thought based no"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "how come the acceptance rate is more than 67% ? am i the only one struggling in understanding even example test cases :)"
                    },
                    {
                        "username": "ivzap",
                        "content": "How one sees the trick of a[j] + a[j+1] is beyond me..."
                    },
                    {
                        "username": "julkar9",
                        "content": "same here"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Remember that if a bag contains only 1 marble from position 'i' then\nThe weight of that bag is `weight[ i ] + weight[ i ]`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Once you think it mathmatically, it becomes very simple and straightforward."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "You will kill yourself after looking at the solution "
                    },
                    {
                        "username": "jincanchamber",
                        "content": "don\\'t tempt me "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "I actually thought this question gonna be solved by DP. \nNot give a second and started coding build the logic but due to constraint it gives TLE.\nAnd also Leetcode sucks at giving hints(in this question):\n1. every bag contain subarray\n2. endpoints matter\n3. use priority queue"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "[@Kaltu](/Kaltu)  yeap \\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp is a valid solution to the problem, we just having a tigher constraint"
                    }
                ]
            },
            {
                "id": 1960721,
                "content": [
                    {
                        "username": "soumyajit_0",
                        "content": "I don\\'t know what should bother me more. The fact that I couldn\\'t solve this problem or the fact that people out here are claiming that this problem should be in the Easy section?"
                    },
                    {
                        "username": "bhakat_debabrata",
                        "content": "This was a nice question.. really feels good when you figure out the solution !"
                    },
                    {
                        "username": "sandeepmourya0720",
                        "content": "Third hint: Try to use Priority queue\nlol even the editorial doesn't use it"
                    },
                    {
                        "username": "Kaltu",
                        "content": "the editorial sort it directly so it took O(n log n) which is slower than the priority queue if a min heap and a max heap were used, then that will be O(n + 2 k log n)"
                    },
                    {
                        "username": "MezoBlast",
                        "content": "This problem should be a medium."
                    },
                    {
                        "username": "dev-null0",
                        "content": "[@life_is_lie](/life_is_lie) Even thought based it\\'s a medium. The problem is that the question is not explained clearly at all, and there are no useful examples."
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "implementation based yes, thought based no"
                    },
                    {
                        "username": "ujjawal_OP",
                        "content": "how come the acceptance rate is more than 67% ? am i the only one struggling in understanding even example test cases :)"
                    },
                    {
                        "username": "ivzap",
                        "content": "How one sees the trick of a[j] + a[j+1] is beyond me..."
                    },
                    {
                        "username": "julkar9",
                        "content": "same here"
                    },
                    {
                        "username": "deCodeIt",
                        "content": "Remember that if a bag contains only 1 marble from position 'i' then\nThe weight of that bag is `weight[ i ] + weight[ i ]`"
                    },
                    {
                        "username": "JackChen890311",
                        "content": "Once you think it mathmatically, it becomes very simple and straightforward."
                    },
                    {
                        "username": "Shivang_101",
                        "content": "You will kill yourself after looking at the solution "
                    },
                    {
                        "username": "jincanchamber",
                        "content": "don\\'t tempt me "
                    },
                    {
                        "username": "krhemant172003",
                        "content": "I actually thought this question gonna be solved by DP. \nNot give a second and started coding build the logic but due to constraint it gives TLE.\nAnd also Leetcode sucks at giving hints(in this question):\n1. every bag contain subarray\n2. endpoints matter\n3. use priority queue"
                    },
                    {
                        "username": "krhemant172003",
                        "content": "[@Kaltu](/Kaltu)  yeap \\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp is a valid solution to the problem, we just having a tigher constraint"
                    }
                ]
            },
            {
                "id": 1960690,
                "content": [
                    {
                        "username": "bj-jiwrajka",
                        "content": "Leetcode and its testcases\\uD83D\\uDE42"
                    },
                    {
                        "username": "svinther",
                        "content": "First time I\\'ve seen a hard that can be solved in 2 lines"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Am I the only one who finds comprehending the problem description tough ?"
                    },
                    {
                        "username": "ms232gg",
                        "content": "It should have been mentioned that you have to distribute all the marbles in the bag"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? I used backtrack to enumerate every possibility.\\n[54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72]  with k = 4 expected 289, but my result is 271. this is really hard to verify by hand...\\n```\\nclass Solution {\\n    long long smin = LONG_MAX;\\n    long long smax = 0;\\n\\n   public:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        if (k >= weights.size()) return 0;\\n        vector<int> splits(k - 1, 0);\\n        helper(weights, splits, 0, 1, k);\\n        return smax - smin;\\n    }\\n    void helper(vector<int>& weights, vector<int>& splits, int scount, int start, int k) {\\n        if (scount >= k - 1) {\\n            long long curr = weights[0] + weights[weights.size() - 1];\\n            for (int i = 0; i < scount; ++i) {\\n                int split = splits[i];\\n                if (split != 0) curr += weights[split - 1];\\n                if (split != weights.size() - 1) curr += weights[split];\\n            }\\n\\n            smin = min(smin, curr);\\n            smax = max(smax, curr);\\n            // print(\"=======splits:\");\\n            // print(splits);\\n            // std::cout << curr << \",\" << smin << \",\" << smax << \"###########################\" << endl;\\n            return;\\n        }\\n        // 0.1.2.3.4.5.6.7.8.9 0 3  <= 7\\n        //\\n        // int end = weights.size() - (k - scount);\\n        if (start >= weights.size()) return;\\n        // if (start > end) return;\\n\\n        // select\\n        splits[scount] = start;\\n        helper(weights, splits, scount + 1, start + 1, k);\\n\\n        // dont select\\n        helper(weights, splits, scount, start + 1, k);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "uniqs",
                        "content": "[@yangbo02](/yangbo02) The problem with my code is two: firstly time exceed. Secondly these two lines is wrong:\n```\n                if (split != 0) curr += weights[split - 1];\n                if (split != weights.size() - 1) curr += weights[split];\n```\nthere is no need to check the if anymore. if we put the first split at position 0 | 1 the value[0] still need to be added."
                    },
                    {
                        "username": "uniqs",
                        "content": "[@bparanj](/bparanj) Thanks for your reply, I have got the answer by sorting a list of pair sums yesterday.  It is really tricky and funny. Really hard to associate this position sensitive problem with sorting."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your backtracking approach looks conceptually correct for enumerating all possible ways to partition the array, but it does seem to be missing an important part of the problem.\\n\\nSpecifically, in the problem statement, we\\'re asked to maximize the sum of the first and last marble in each bag, and to minimize the same quantity. Therefore, when you\\'re creating your partitions, you should add not just the value at the partition index, but also the one next to it.\\n\\nAlso, the way you\\'re partitioning the array seems to miss the point that we are splitting the array into k+1 subarrays. For instance, if you have the weights [1, 2, 3, 4] and you choose k=1, you\\'ll have two bags: [1, 2] and [3, 4].\\n\\nGiven the constraints of the problem, a backtracking solution might lead to a Time Limit Exceeded error, since it has a time complexity of O(n^k), which is not feasible for larger inputs. The hints suggest using a priority queue, and a more efficient approach involves sorting a list of pair sums. However, your current approach is a good way to thoroughly understand the problem and how the partitioning works."
                    },
                    {
                        "username": "yangbo02",
                        "content": "54 ... 6 | 34 ... 18 | 13 ... 13 | 10 ... 72\\n54 ... 66 | 63 ... 46 | 75 ... 61 | 72 ... 72"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Took me some time and a glimpse at discussions to figure out it got nothing to do with DP. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "Focus on the boundaries, not the marbles.\\n\\nThe problem description may look like it failed to mention you should use up all the marbles, but this is actually a hint in disguise.\\nBecause if you are tricked into thinking you can simply find k bags with each bag having exactly one marble and leaving out the rest of the marbles, then you will come to a \"solution\" that the k smallest marbles and k largest marbles are the answer. Well, you are wrong but actually quite close to the real one.\\n You just need to see the problem from a new angle and shift the focus from the marbles to the boundaries between the marbles."
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I spent days working on a fast enough Dynamic Programming solution. I finally got the performance to `O(nk - k^2)`.\\nThis still failed with Time Limit Exceeded.\\n\\nOnce I twigged on the correct approach it took me two minutes to write a completely new solution that worked."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Why does it seem like \"I searched God for years and could not find him, I looked inside my heart and found him in a second\" \\uD83D\\uDE00"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint:\\n\\nThe problem involves finding the difference between the sum of the largest k sums and the sum of the smallest k sums of consecutive elements in the array.\\nTo efficiently find the largest and smallest sums, you can use two heaps: a MaxHeap and a MinHeap.\\nThe MaxHeap will help you quickly access the largest sums, and the MinHeap will help you quickly access the smallest sums.\\nPopulate both heaps while iterating over the array of consecutive sums.\\nIf the size of either heap becomes greater than k, use the appropriate heap operation to maintain only the top k elements in the heap.\\nFinally, calculate the difference between the sum of elements in the MaxHeap and the sum of elements in the MinHeap to obtain the result.\\nKeep in mind that understanding how to use the heaps and their operations will be crucial to efficiently solve this problem. Happy coding!"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint: This issue can be resolved by utilizing a binary search methodology to identify the lowest and highest scores. Initially, we arrange the weight array in ascending order. Subsequently, we examine each potential score (ranging from the minimum attainable to the maximum attainable) to determine whether it is feasible to distribute the marbles into k bags with a score that is less than or equal to the current score. If such distribution is possible, we adjust the minimum score accordingly. Conversely, if the distribution is not feasible, we adjust the maximum score. The discrepancy between the highest and lowest scores will serve as the final solution."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "I don\\'t understand expected outcome for testcase weights=[1,4,2,5,2] and k=3.\\n\\nMax score split should be 1,4 | 2 | 5 | 2. Score is 23.\\nMin score split should be 1 | 4 | 2, 5 | 2 OR 1 | 4 | 2 | 5,2. Score is 21.\\n\\nSo, the expected outcome should be 2. Why is it 3?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`k` is the number of groups, so you actaully needs `k - 1` \"cuts\", you are making `k` cuts so you have `k + 1` groups\\n[1, 4, 2], [5], [2] = (1 + 2) + (5 + 5) + (2 + 2) = 17\\n[1], [4], [2, 5, 2] = (1 + 1) + (4 + 4) + (2 + 2) = 14\\n17 - 14 = 3"
                    }
                ]
            },
            {
                "id": 1960642,
                "content": [
                    {
                        "username": "bj-jiwrajka",
                        "content": "Leetcode and its testcases\\uD83D\\uDE42"
                    },
                    {
                        "username": "svinther",
                        "content": "First time I\\'ve seen a hard that can be solved in 2 lines"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Am I the only one who finds comprehending the problem description tough ?"
                    },
                    {
                        "username": "ms232gg",
                        "content": "It should have been mentioned that you have to distribute all the marbles in the bag"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? I used backtrack to enumerate every possibility.\\n[54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72]  with k = 4 expected 289, but my result is 271. this is really hard to verify by hand...\\n```\\nclass Solution {\\n    long long smin = LONG_MAX;\\n    long long smax = 0;\\n\\n   public:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        if (k >= weights.size()) return 0;\\n        vector<int> splits(k - 1, 0);\\n        helper(weights, splits, 0, 1, k);\\n        return smax - smin;\\n    }\\n    void helper(vector<int>& weights, vector<int>& splits, int scount, int start, int k) {\\n        if (scount >= k - 1) {\\n            long long curr = weights[0] + weights[weights.size() - 1];\\n            for (int i = 0; i < scount; ++i) {\\n                int split = splits[i];\\n                if (split != 0) curr += weights[split - 1];\\n                if (split != weights.size() - 1) curr += weights[split];\\n            }\\n\\n            smin = min(smin, curr);\\n            smax = max(smax, curr);\\n            // print(\"=======splits:\");\\n            // print(splits);\\n            // std::cout << curr << \",\" << smin << \",\" << smax << \"###########################\" << endl;\\n            return;\\n        }\\n        // 0.1.2.3.4.5.6.7.8.9 0 3  <= 7\\n        //\\n        // int end = weights.size() - (k - scount);\\n        if (start >= weights.size()) return;\\n        // if (start > end) return;\\n\\n        // select\\n        splits[scount] = start;\\n        helper(weights, splits, scount + 1, start + 1, k);\\n\\n        // dont select\\n        helper(weights, splits, scount, start + 1, k);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "uniqs",
                        "content": "[@yangbo02](/yangbo02) The problem with my code is two: firstly time exceed. Secondly these two lines is wrong:\n```\n                if (split != 0) curr += weights[split - 1];\n                if (split != weights.size() - 1) curr += weights[split];\n```\nthere is no need to check the if anymore. if we put the first split at position 0 | 1 the value[0] still need to be added."
                    },
                    {
                        "username": "uniqs",
                        "content": "[@bparanj](/bparanj) Thanks for your reply, I have got the answer by sorting a list of pair sums yesterday.  It is really tricky and funny. Really hard to associate this position sensitive problem with sorting."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your backtracking approach looks conceptually correct for enumerating all possible ways to partition the array, but it does seem to be missing an important part of the problem.\\n\\nSpecifically, in the problem statement, we\\'re asked to maximize the sum of the first and last marble in each bag, and to minimize the same quantity. Therefore, when you\\'re creating your partitions, you should add not just the value at the partition index, but also the one next to it.\\n\\nAlso, the way you\\'re partitioning the array seems to miss the point that we are splitting the array into k+1 subarrays. For instance, if you have the weights [1, 2, 3, 4] and you choose k=1, you\\'ll have two bags: [1, 2] and [3, 4].\\n\\nGiven the constraints of the problem, a backtracking solution might lead to a Time Limit Exceeded error, since it has a time complexity of O(n^k), which is not feasible for larger inputs. The hints suggest using a priority queue, and a more efficient approach involves sorting a list of pair sums. However, your current approach is a good way to thoroughly understand the problem and how the partitioning works."
                    },
                    {
                        "username": "yangbo02",
                        "content": "54 ... 6 | 34 ... 18 | 13 ... 13 | 10 ... 72\\n54 ... 66 | 63 ... 46 | 75 ... 61 | 72 ... 72"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Took me some time and a glimpse at discussions to figure out it got nothing to do with DP. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "Focus on the boundaries, not the marbles.\\n\\nThe problem description may look like it failed to mention you should use up all the marbles, but this is actually a hint in disguise.\\nBecause if you are tricked into thinking you can simply find k bags with each bag having exactly one marble and leaving out the rest of the marbles, then you will come to a \"solution\" that the k smallest marbles and k largest marbles are the answer. Well, you are wrong but actually quite close to the real one.\\n You just need to see the problem from a new angle and shift the focus from the marbles to the boundaries between the marbles."
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I spent days working on a fast enough Dynamic Programming solution. I finally got the performance to `O(nk - k^2)`.\\nThis still failed with Time Limit Exceeded.\\n\\nOnce I twigged on the correct approach it took me two minutes to write a completely new solution that worked."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Why does it seem like \"I searched God for years and could not find him, I looked inside my heart and found him in a second\" \\uD83D\\uDE00"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint:\\n\\nThe problem involves finding the difference between the sum of the largest k sums and the sum of the smallest k sums of consecutive elements in the array.\\nTo efficiently find the largest and smallest sums, you can use two heaps: a MaxHeap and a MinHeap.\\nThe MaxHeap will help you quickly access the largest sums, and the MinHeap will help you quickly access the smallest sums.\\nPopulate both heaps while iterating over the array of consecutive sums.\\nIf the size of either heap becomes greater than k, use the appropriate heap operation to maintain only the top k elements in the heap.\\nFinally, calculate the difference between the sum of elements in the MaxHeap and the sum of elements in the MinHeap to obtain the result.\\nKeep in mind that understanding how to use the heaps and their operations will be crucial to efficiently solve this problem. Happy coding!"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint: This issue can be resolved by utilizing a binary search methodology to identify the lowest and highest scores. Initially, we arrange the weight array in ascending order. Subsequently, we examine each potential score (ranging from the minimum attainable to the maximum attainable) to determine whether it is feasible to distribute the marbles into k bags with a score that is less than or equal to the current score. If such distribution is possible, we adjust the minimum score accordingly. Conversely, if the distribution is not feasible, we adjust the maximum score. The discrepancy between the highest and lowest scores will serve as the final solution."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "I don\\'t understand expected outcome for testcase weights=[1,4,2,5,2] and k=3.\\n\\nMax score split should be 1,4 | 2 | 5 | 2. Score is 23.\\nMin score split should be 1 | 4 | 2, 5 | 2 OR 1 | 4 | 2 | 5,2. Score is 21.\\n\\nSo, the expected outcome should be 2. Why is it 3?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`k` is the number of groups, so you actaully needs `k - 1` \"cuts\", you are making `k` cuts so you have `k + 1` groups\\n[1, 4, 2], [5], [2] = (1 + 2) + (5 + 5) + (2 + 2) = 17\\n[1], [4], [2, 5, 2] = (1 + 1) + (4 + 4) + (2 + 2) = 14\\n17 - 14 = 3"
                    }
                ]
            },
            {
                "id": 1960635,
                "content": [
                    {
                        "username": "bj-jiwrajka",
                        "content": "Leetcode and its testcases\\uD83D\\uDE42"
                    },
                    {
                        "username": "svinther",
                        "content": "First time I\\'ve seen a hard that can be solved in 2 lines"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Am I the only one who finds comprehending the problem description tough ?"
                    },
                    {
                        "username": "ms232gg",
                        "content": "It should have been mentioned that you have to distribute all the marbles in the bag"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? I used backtrack to enumerate every possibility.\\n[54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72]  with k = 4 expected 289, but my result is 271. this is really hard to verify by hand...\\n```\\nclass Solution {\\n    long long smin = LONG_MAX;\\n    long long smax = 0;\\n\\n   public:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        if (k >= weights.size()) return 0;\\n        vector<int> splits(k - 1, 0);\\n        helper(weights, splits, 0, 1, k);\\n        return smax - smin;\\n    }\\n    void helper(vector<int>& weights, vector<int>& splits, int scount, int start, int k) {\\n        if (scount >= k - 1) {\\n            long long curr = weights[0] + weights[weights.size() - 1];\\n            for (int i = 0; i < scount; ++i) {\\n                int split = splits[i];\\n                if (split != 0) curr += weights[split - 1];\\n                if (split != weights.size() - 1) curr += weights[split];\\n            }\\n\\n            smin = min(smin, curr);\\n            smax = max(smax, curr);\\n            // print(\"=======splits:\");\\n            // print(splits);\\n            // std::cout << curr << \",\" << smin << \",\" << smax << \"###########################\" << endl;\\n            return;\\n        }\\n        // 0.1.2.3.4.5.6.7.8.9 0 3  <= 7\\n        //\\n        // int end = weights.size() - (k - scount);\\n        if (start >= weights.size()) return;\\n        // if (start > end) return;\\n\\n        // select\\n        splits[scount] = start;\\n        helper(weights, splits, scount + 1, start + 1, k);\\n\\n        // dont select\\n        helper(weights, splits, scount, start + 1, k);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "uniqs",
                        "content": "[@yangbo02](/yangbo02) The problem with my code is two: firstly time exceed. Secondly these two lines is wrong:\n```\n                if (split != 0) curr += weights[split - 1];\n                if (split != weights.size() - 1) curr += weights[split];\n```\nthere is no need to check the if anymore. if we put the first split at position 0 | 1 the value[0] still need to be added."
                    },
                    {
                        "username": "uniqs",
                        "content": "[@bparanj](/bparanj) Thanks for your reply, I have got the answer by sorting a list of pair sums yesterday.  It is really tricky and funny. Really hard to associate this position sensitive problem with sorting."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your backtracking approach looks conceptually correct for enumerating all possible ways to partition the array, but it does seem to be missing an important part of the problem.\\n\\nSpecifically, in the problem statement, we\\'re asked to maximize the sum of the first and last marble in each bag, and to minimize the same quantity. Therefore, when you\\'re creating your partitions, you should add not just the value at the partition index, but also the one next to it.\\n\\nAlso, the way you\\'re partitioning the array seems to miss the point that we are splitting the array into k+1 subarrays. For instance, if you have the weights [1, 2, 3, 4] and you choose k=1, you\\'ll have two bags: [1, 2] and [3, 4].\\n\\nGiven the constraints of the problem, a backtracking solution might lead to a Time Limit Exceeded error, since it has a time complexity of O(n^k), which is not feasible for larger inputs. The hints suggest using a priority queue, and a more efficient approach involves sorting a list of pair sums. However, your current approach is a good way to thoroughly understand the problem and how the partitioning works."
                    },
                    {
                        "username": "yangbo02",
                        "content": "54 ... 6 | 34 ... 18 | 13 ... 13 | 10 ... 72\\n54 ... 66 | 63 ... 46 | 75 ... 61 | 72 ... 72"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Took me some time and a glimpse at discussions to figure out it got nothing to do with DP. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "Focus on the boundaries, not the marbles.\\n\\nThe problem description may look like it failed to mention you should use up all the marbles, but this is actually a hint in disguise.\\nBecause if you are tricked into thinking you can simply find k bags with each bag having exactly one marble and leaving out the rest of the marbles, then you will come to a \"solution\" that the k smallest marbles and k largest marbles are the answer. Well, you are wrong but actually quite close to the real one.\\n You just need to see the problem from a new angle and shift the focus from the marbles to the boundaries between the marbles."
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I spent days working on a fast enough Dynamic Programming solution. I finally got the performance to `O(nk - k^2)`.\\nThis still failed with Time Limit Exceeded.\\n\\nOnce I twigged on the correct approach it took me two minutes to write a completely new solution that worked."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Why does it seem like \"I searched God for years and could not find him, I looked inside my heart and found him in a second\" \\uD83D\\uDE00"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint:\\n\\nThe problem involves finding the difference between the sum of the largest k sums and the sum of the smallest k sums of consecutive elements in the array.\\nTo efficiently find the largest and smallest sums, you can use two heaps: a MaxHeap and a MinHeap.\\nThe MaxHeap will help you quickly access the largest sums, and the MinHeap will help you quickly access the smallest sums.\\nPopulate both heaps while iterating over the array of consecutive sums.\\nIf the size of either heap becomes greater than k, use the appropriate heap operation to maintain only the top k elements in the heap.\\nFinally, calculate the difference between the sum of elements in the MaxHeap and the sum of elements in the MinHeap to obtain the result.\\nKeep in mind that understanding how to use the heaps and their operations will be crucial to efficiently solve this problem. Happy coding!"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint: This issue can be resolved by utilizing a binary search methodology to identify the lowest and highest scores. Initially, we arrange the weight array in ascending order. Subsequently, we examine each potential score (ranging from the minimum attainable to the maximum attainable) to determine whether it is feasible to distribute the marbles into k bags with a score that is less than or equal to the current score. If such distribution is possible, we adjust the minimum score accordingly. Conversely, if the distribution is not feasible, we adjust the maximum score. The discrepancy between the highest and lowest scores will serve as the final solution."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "I don\\'t understand expected outcome for testcase weights=[1,4,2,5,2] and k=3.\\n\\nMax score split should be 1,4 | 2 | 5 | 2. Score is 23.\\nMin score split should be 1 | 4 | 2, 5 | 2 OR 1 | 4 | 2 | 5,2. Score is 21.\\n\\nSo, the expected outcome should be 2. Why is it 3?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`k` is the number of groups, so you actaully needs `k - 1` \"cuts\", you are making `k` cuts so you have `k + 1` groups\\n[1, 4, 2], [5], [2] = (1 + 2) + (5 + 5) + (2 + 2) = 17\\n[1], [4], [2, 5, 2] = (1 + 1) + (4 + 4) + (2 + 2) = 14\\n17 - 14 = 3"
                    }
                ]
            },
            {
                "id": 1960631,
                "content": [
                    {
                        "username": "bj-jiwrajka",
                        "content": "Leetcode and its testcases\\uD83D\\uDE42"
                    },
                    {
                        "username": "svinther",
                        "content": "First time I\\'ve seen a hard that can be solved in 2 lines"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Am I the only one who finds comprehending the problem description tough ?"
                    },
                    {
                        "username": "ms232gg",
                        "content": "It should have been mentioned that you have to distribute all the marbles in the bag"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? I used backtrack to enumerate every possibility.\\n[54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72]  with k = 4 expected 289, but my result is 271. this is really hard to verify by hand...\\n```\\nclass Solution {\\n    long long smin = LONG_MAX;\\n    long long smax = 0;\\n\\n   public:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        if (k >= weights.size()) return 0;\\n        vector<int> splits(k - 1, 0);\\n        helper(weights, splits, 0, 1, k);\\n        return smax - smin;\\n    }\\n    void helper(vector<int>& weights, vector<int>& splits, int scount, int start, int k) {\\n        if (scount >= k - 1) {\\n            long long curr = weights[0] + weights[weights.size() - 1];\\n            for (int i = 0; i < scount; ++i) {\\n                int split = splits[i];\\n                if (split != 0) curr += weights[split - 1];\\n                if (split != weights.size() - 1) curr += weights[split];\\n            }\\n\\n            smin = min(smin, curr);\\n            smax = max(smax, curr);\\n            // print(\"=======splits:\");\\n            // print(splits);\\n            // std::cout << curr << \",\" << smin << \",\" << smax << \"###########################\" << endl;\\n            return;\\n        }\\n        // 0.1.2.3.4.5.6.7.8.9 0 3  <= 7\\n        //\\n        // int end = weights.size() - (k - scount);\\n        if (start >= weights.size()) return;\\n        // if (start > end) return;\\n\\n        // select\\n        splits[scount] = start;\\n        helper(weights, splits, scount + 1, start + 1, k);\\n\\n        // dont select\\n        helper(weights, splits, scount, start + 1, k);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "uniqs",
                        "content": "[@yangbo02](/yangbo02) The problem with my code is two: firstly time exceed. Secondly these two lines is wrong:\n```\n                if (split != 0) curr += weights[split - 1];\n                if (split != weights.size() - 1) curr += weights[split];\n```\nthere is no need to check the if anymore. if we put the first split at position 0 | 1 the value[0] still need to be added."
                    },
                    {
                        "username": "uniqs",
                        "content": "[@bparanj](/bparanj) Thanks for your reply, I have got the answer by sorting a list of pair sums yesterday.  It is really tricky and funny. Really hard to associate this position sensitive problem with sorting."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your backtracking approach looks conceptually correct for enumerating all possible ways to partition the array, but it does seem to be missing an important part of the problem.\\n\\nSpecifically, in the problem statement, we\\'re asked to maximize the sum of the first and last marble in each bag, and to minimize the same quantity. Therefore, when you\\'re creating your partitions, you should add not just the value at the partition index, but also the one next to it.\\n\\nAlso, the way you\\'re partitioning the array seems to miss the point that we are splitting the array into k+1 subarrays. For instance, if you have the weights [1, 2, 3, 4] and you choose k=1, you\\'ll have two bags: [1, 2] and [3, 4].\\n\\nGiven the constraints of the problem, a backtracking solution might lead to a Time Limit Exceeded error, since it has a time complexity of O(n^k), which is not feasible for larger inputs. The hints suggest using a priority queue, and a more efficient approach involves sorting a list of pair sums. However, your current approach is a good way to thoroughly understand the problem and how the partitioning works."
                    },
                    {
                        "username": "yangbo02",
                        "content": "54 ... 6 | 34 ... 18 | 13 ... 13 | 10 ... 72\\n54 ... 66 | 63 ... 46 | 75 ... 61 | 72 ... 72"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Took me some time and a glimpse at discussions to figure out it got nothing to do with DP. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "Focus on the boundaries, not the marbles.\\n\\nThe problem description may look like it failed to mention you should use up all the marbles, but this is actually a hint in disguise.\\nBecause if you are tricked into thinking you can simply find k bags with each bag having exactly one marble and leaving out the rest of the marbles, then you will come to a \"solution\" that the k smallest marbles and k largest marbles are the answer. Well, you are wrong but actually quite close to the real one.\\n You just need to see the problem from a new angle and shift the focus from the marbles to the boundaries between the marbles."
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I spent days working on a fast enough Dynamic Programming solution. I finally got the performance to `O(nk - k^2)`.\\nThis still failed with Time Limit Exceeded.\\n\\nOnce I twigged on the correct approach it took me two minutes to write a completely new solution that worked."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Why does it seem like \"I searched God for years and could not find him, I looked inside my heart and found him in a second\" \\uD83D\\uDE00"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint:\\n\\nThe problem involves finding the difference between the sum of the largest k sums and the sum of the smallest k sums of consecutive elements in the array.\\nTo efficiently find the largest and smallest sums, you can use two heaps: a MaxHeap and a MinHeap.\\nThe MaxHeap will help you quickly access the largest sums, and the MinHeap will help you quickly access the smallest sums.\\nPopulate both heaps while iterating over the array of consecutive sums.\\nIf the size of either heap becomes greater than k, use the appropriate heap operation to maintain only the top k elements in the heap.\\nFinally, calculate the difference between the sum of elements in the MaxHeap and the sum of elements in the MinHeap to obtain the result.\\nKeep in mind that understanding how to use the heaps and their operations will be crucial to efficiently solve this problem. Happy coding!"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint: This issue can be resolved by utilizing a binary search methodology to identify the lowest and highest scores. Initially, we arrange the weight array in ascending order. Subsequently, we examine each potential score (ranging from the minimum attainable to the maximum attainable) to determine whether it is feasible to distribute the marbles into k bags with a score that is less than or equal to the current score. If such distribution is possible, we adjust the minimum score accordingly. Conversely, if the distribution is not feasible, we adjust the maximum score. The discrepancy between the highest and lowest scores will serve as the final solution."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "I don\\'t understand expected outcome for testcase weights=[1,4,2,5,2] and k=3.\\n\\nMax score split should be 1,4 | 2 | 5 | 2. Score is 23.\\nMin score split should be 1 | 4 | 2, 5 | 2 OR 1 | 4 | 2 | 5,2. Score is 21.\\n\\nSo, the expected outcome should be 2. Why is it 3?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`k` is the number of groups, so you actaully needs `k - 1` \"cuts\", you are making `k` cuts so you have `k + 1` groups\\n[1, 4, 2], [5], [2] = (1 + 2) + (5 + 5) + (2 + 2) = 17\\n[1], [4], [2, 5, 2] = (1 + 1) + (4 + 4) + (2 + 2) = 14\\n17 - 14 = 3"
                    }
                ]
            },
            {
                "id": 1960553,
                "content": [
                    {
                        "username": "bj-jiwrajka",
                        "content": "Leetcode and its testcases\\uD83D\\uDE42"
                    },
                    {
                        "username": "svinther",
                        "content": "First time I\\'ve seen a hard that can be solved in 2 lines"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Am I the only one who finds comprehending the problem description tough ?"
                    },
                    {
                        "username": "ms232gg",
                        "content": "It should have been mentioned that you have to distribute all the marbles in the bag"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? I used backtrack to enumerate every possibility.\\n[54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72]  with k = 4 expected 289, but my result is 271. this is really hard to verify by hand...\\n```\\nclass Solution {\\n    long long smin = LONG_MAX;\\n    long long smax = 0;\\n\\n   public:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        if (k >= weights.size()) return 0;\\n        vector<int> splits(k - 1, 0);\\n        helper(weights, splits, 0, 1, k);\\n        return smax - smin;\\n    }\\n    void helper(vector<int>& weights, vector<int>& splits, int scount, int start, int k) {\\n        if (scount >= k - 1) {\\n            long long curr = weights[0] + weights[weights.size() - 1];\\n            for (int i = 0; i < scount; ++i) {\\n                int split = splits[i];\\n                if (split != 0) curr += weights[split - 1];\\n                if (split != weights.size() - 1) curr += weights[split];\\n            }\\n\\n            smin = min(smin, curr);\\n            smax = max(smax, curr);\\n            // print(\"=======splits:\");\\n            // print(splits);\\n            // std::cout << curr << \",\" << smin << \",\" << smax << \"###########################\" << endl;\\n            return;\\n        }\\n        // 0.1.2.3.4.5.6.7.8.9 0 3  <= 7\\n        //\\n        // int end = weights.size() - (k - scount);\\n        if (start >= weights.size()) return;\\n        // if (start > end) return;\\n\\n        // select\\n        splits[scount] = start;\\n        helper(weights, splits, scount + 1, start + 1, k);\\n\\n        // dont select\\n        helper(weights, splits, scount, start + 1, k);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "uniqs",
                        "content": "[@yangbo02](/yangbo02) The problem with my code is two: firstly time exceed. Secondly these two lines is wrong:\n```\n                if (split != 0) curr += weights[split - 1];\n                if (split != weights.size() - 1) curr += weights[split];\n```\nthere is no need to check the if anymore. if we put the first split at position 0 | 1 the value[0] still need to be added."
                    },
                    {
                        "username": "uniqs",
                        "content": "[@bparanj](/bparanj) Thanks for your reply, I have got the answer by sorting a list of pair sums yesterday.  It is really tricky and funny. Really hard to associate this position sensitive problem with sorting."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your backtracking approach looks conceptually correct for enumerating all possible ways to partition the array, but it does seem to be missing an important part of the problem.\\n\\nSpecifically, in the problem statement, we\\'re asked to maximize the sum of the first and last marble in each bag, and to minimize the same quantity. Therefore, when you\\'re creating your partitions, you should add not just the value at the partition index, but also the one next to it.\\n\\nAlso, the way you\\'re partitioning the array seems to miss the point that we are splitting the array into k+1 subarrays. For instance, if you have the weights [1, 2, 3, 4] and you choose k=1, you\\'ll have two bags: [1, 2] and [3, 4].\\n\\nGiven the constraints of the problem, a backtracking solution might lead to a Time Limit Exceeded error, since it has a time complexity of O(n^k), which is not feasible for larger inputs. The hints suggest using a priority queue, and a more efficient approach involves sorting a list of pair sums. However, your current approach is a good way to thoroughly understand the problem and how the partitioning works."
                    },
                    {
                        "username": "yangbo02",
                        "content": "54 ... 6 | 34 ... 18 | 13 ... 13 | 10 ... 72\\n54 ... 66 | 63 ... 46 | 75 ... 61 | 72 ... 72"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Took me some time and a glimpse at discussions to figure out it got nothing to do with DP. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "Focus on the boundaries, not the marbles.\\n\\nThe problem description may look like it failed to mention you should use up all the marbles, but this is actually a hint in disguise.\\nBecause if you are tricked into thinking you can simply find k bags with each bag having exactly one marble and leaving out the rest of the marbles, then you will come to a \"solution\" that the k smallest marbles and k largest marbles are the answer. Well, you are wrong but actually quite close to the real one.\\n You just need to see the problem from a new angle and shift the focus from the marbles to the boundaries between the marbles."
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I spent days working on a fast enough Dynamic Programming solution. I finally got the performance to `O(nk - k^2)`.\\nThis still failed with Time Limit Exceeded.\\n\\nOnce I twigged on the correct approach it took me two minutes to write a completely new solution that worked."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Why does it seem like \"I searched God for years and could not find him, I looked inside my heart and found him in a second\" \\uD83D\\uDE00"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint:\\n\\nThe problem involves finding the difference between the sum of the largest k sums and the sum of the smallest k sums of consecutive elements in the array.\\nTo efficiently find the largest and smallest sums, you can use two heaps: a MaxHeap and a MinHeap.\\nThe MaxHeap will help you quickly access the largest sums, and the MinHeap will help you quickly access the smallest sums.\\nPopulate both heaps while iterating over the array of consecutive sums.\\nIf the size of either heap becomes greater than k, use the appropriate heap operation to maintain only the top k elements in the heap.\\nFinally, calculate the difference between the sum of elements in the MaxHeap and the sum of elements in the MinHeap to obtain the result.\\nKeep in mind that understanding how to use the heaps and their operations will be crucial to efficiently solve this problem. Happy coding!"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint: This issue can be resolved by utilizing a binary search methodology to identify the lowest and highest scores. Initially, we arrange the weight array in ascending order. Subsequently, we examine each potential score (ranging from the minimum attainable to the maximum attainable) to determine whether it is feasible to distribute the marbles into k bags with a score that is less than or equal to the current score. If such distribution is possible, we adjust the minimum score accordingly. Conversely, if the distribution is not feasible, we adjust the maximum score. The discrepancy between the highest and lowest scores will serve as the final solution."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "I don\\'t understand expected outcome for testcase weights=[1,4,2,5,2] and k=3.\\n\\nMax score split should be 1,4 | 2 | 5 | 2. Score is 23.\\nMin score split should be 1 | 4 | 2, 5 | 2 OR 1 | 4 | 2 | 5,2. Score is 21.\\n\\nSo, the expected outcome should be 2. Why is it 3?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`k` is the number of groups, so you actaully needs `k - 1` \"cuts\", you are making `k` cuts so you have `k + 1` groups\\n[1, 4, 2], [5], [2] = (1 + 2) + (5 + 5) + (2 + 2) = 17\\n[1], [4], [2, 5, 2] = (1 + 1) + (4 + 4) + (2 + 2) = 14\\n17 - 14 = 3"
                    }
                ]
            },
            {
                "id": 1960499,
                "content": [
                    {
                        "username": "bj-jiwrajka",
                        "content": "Leetcode and its testcases\\uD83D\\uDE42"
                    },
                    {
                        "username": "svinther",
                        "content": "First time I\\'ve seen a hard that can be solved in 2 lines"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Am I the only one who finds comprehending the problem description tough ?"
                    },
                    {
                        "username": "ms232gg",
                        "content": "It should have been mentioned that you have to distribute all the marbles in the bag"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? I used backtrack to enumerate every possibility.\\n[54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72]  with k = 4 expected 289, but my result is 271. this is really hard to verify by hand...\\n```\\nclass Solution {\\n    long long smin = LONG_MAX;\\n    long long smax = 0;\\n\\n   public:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        if (k >= weights.size()) return 0;\\n        vector<int> splits(k - 1, 0);\\n        helper(weights, splits, 0, 1, k);\\n        return smax - smin;\\n    }\\n    void helper(vector<int>& weights, vector<int>& splits, int scount, int start, int k) {\\n        if (scount >= k - 1) {\\n            long long curr = weights[0] + weights[weights.size() - 1];\\n            for (int i = 0; i < scount; ++i) {\\n                int split = splits[i];\\n                if (split != 0) curr += weights[split - 1];\\n                if (split != weights.size() - 1) curr += weights[split];\\n            }\\n\\n            smin = min(smin, curr);\\n            smax = max(smax, curr);\\n            // print(\"=======splits:\");\\n            // print(splits);\\n            // std::cout << curr << \",\" << smin << \",\" << smax << \"###########################\" << endl;\\n            return;\\n        }\\n        // 0.1.2.3.4.5.6.7.8.9 0 3  <= 7\\n        //\\n        // int end = weights.size() - (k - scount);\\n        if (start >= weights.size()) return;\\n        // if (start > end) return;\\n\\n        // select\\n        splits[scount] = start;\\n        helper(weights, splits, scount + 1, start + 1, k);\\n\\n        // dont select\\n        helper(weights, splits, scount, start + 1, k);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "uniqs",
                        "content": "[@yangbo02](/yangbo02) The problem with my code is two: firstly time exceed. Secondly these two lines is wrong:\n```\n                if (split != 0) curr += weights[split - 1];\n                if (split != weights.size() - 1) curr += weights[split];\n```\nthere is no need to check the if anymore. if we put the first split at position 0 | 1 the value[0] still need to be added."
                    },
                    {
                        "username": "uniqs",
                        "content": "[@bparanj](/bparanj) Thanks for your reply, I have got the answer by sorting a list of pair sums yesterday.  It is really tricky and funny. Really hard to associate this position sensitive problem with sorting."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your backtracking approach looks conceptually correct for enumerating all possible ways to partition the array, but it does seem to be missing an important part of the problem.\\n\\nSpecifically, in the problem statement, we\\'re asked to maximize the sum of the first and last marble in each bag, and to minimize the same quantity. Therefore, when you\\'re creating your partitions, you should add not just the value at the partition index, but also the one next to it.\\n\\nAlso, the way you\\'re partitioning the array seems to miss the point that we are splitting the array into k+1 subarrays. For instance, if you have the weights [1, 2, 3, 4] and you choose k=1, you\\'ll have two bags: [1, 2] and [3, 4].\\n\\nGiven the constraints of the problem, a backtracking solution might lead to a Time Limit Exceeded error, since it has a time complexity of O(n^k), which is not feasible for larger inputs. The hints suggest using a priority queue, and a more efficient approach involves sorting a list of pair sums. However, your current approach is a good way to thoroughly understand the problem and how the partitioning works."
                    },
                    {
                        "username": "yangbo02",
                        "content": "54 ... 6 | 34 ... 18 | 13 ... 13 | 10 ... 72\\n54 ... 66 | 63 ... 46 | 75 ... 61 | 72 ... 72"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Took me some time and a glimpse at discussions to figure out it got nothing to do with DP. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "Focus on the boundaries, not the marbles.\\n\\nThe problem description may look like it failed to mention you should use up all the marbles, but this is actually a hint in disguise.\\nBecause if you are tricked into thinking you can simply find k bags with each bag having exactly one marble and leaving out the rest of the marbles, then you will come to a \"solution\" that the k smallest marbles and k largest marbles are the answer. Well, you are wrong but actually quite close to the real one.\\n You just need to see the problem from a new angle and shift the focus from the marbles to the boundaries between the marbles."
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I spent days working on a fast enough Dynamic Programming solution. I finally got the performance to `O(nk - k^2)`.\\nThis still failed with Time Limit Exceeded.\\n\\nOnce I twigged on the correct approach it took me two minutes to write a completely new solution that worked."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Why does it seem like \"I searched God for years and could not find him, I looked inside my heart and found him in a second\" \\uD83D\\uDE00"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint:\\n\\nThe problem involves finding the difference between the sum of the largest k sums and the sum of the smallest k sums of consecutive elements in the array.\\nTo efficiently find the largest and smallest sums, you can use two heaps: a MaxHeap and a MinHeap.\\nThe MaxHeap will help you quickly access the largest sums, and the MinHeap will help you quickly access the smallest sums.\\nPopulate both heaps while iterating over the array of consecutive sums.\\nIf the size of either heap becomes greater than k, use the appropriate heap operation to maintain only the top k elements in the heap.\\nFinally, calculate the difference between the sum of elements in the MaxHeap and the sum of elements in the MinHeap to obtain the result.\\nKeep in mind that understanding how to use the heaps and their operations will be crucial to efficiently solve this problem. Happy coding!"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint: This issue can be resolved by utilizing a binary search methodology to identify the lowest and highest scores. Initially, we arrange the weight array in ascending order. Subsequently, we examine each potential score (ranging from the minimum attainable to the maximum attainable) to determine whether it is feasible to distribute the marbles into k bags with a score that is less than or equal to the current score. If such distribution is possible, we adjust the minimum score accordingly. Conversely, if the distribution is not feasible, we adjust the maximum score. The discrepancy between the highest and lowest scores will serve as the final solution."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "I don\\'t understand expected outcome for testcase weights=[1,4,2,5,2] and k=3.\\n\\nMax score split should be 1,4 | 2 | 5 | 2. Score is 23.\\nMin score split should be 1 | 4 | 2, 5 | 2 OR 1 | 4 | 2 | 5,2. Score is 21.\\n\\nSo, the expected outcome should be 2. Why is it 3?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`k` is the number of groups, so you actaully needs `k - 1` \"cuts\", you are making `k` cuts so you have `k + 1` groups\\n[1, 4, 2], [5], [2] = (1 + 2) + (5 + 5) + (2 + 2) = 17\\n[1], [4], [2, 5, 2] = (1 + 1) + (4 + 4) + (2 + 2) = 14\\n17 - 14 = 3"
                    }
                ]
            },
            {
                "id": 1781455,
                "content": [
                    {
                        "username": "bj-jiwrajka",
                        "content": "Leetcode and its testcases\\uD83D\\uDE42"
                    },
                    {
                        "username": "svinther",
                        "content": "First time I\\'ve seen a hard that can be solved in 2 lines"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Am I the only one who finds comprehending the problem description tough ?"
                    },
                    {
                        "username": "ms232gg",
                        "content": "It should have been mentioned that you have to distribute all the marbles in the bag"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? I used backtrack to enumerate every possibility.\\n[54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72]  with k = 4 expected 289, but my result is 271. this is really hard to verify by hand...\\n```\\nclass Solution {\\n    long long smin = LONG_MAX;\\n    long long smax = 0;\\n\\n   public:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        if (k >= weights.size()) return 0;\\n        vector<int> splits(k - 1, 0);\\n        helper(weights, splits, 0, 1, k);\\n        return smax - smin;\\n    }\\n    void helper(vector<int>& weights, vector<int>& splits, int scount, int start, int k) {\\n        if (scount >= k - 1) {\\n            long long curr = weights[0] + weights[weights.size() - 1];\\n            for (int i = 0; i < scount; ++i) {\\n                int split = splits[i];\\n                if (split != 0) curr += weights[split - 1];\\n                if (split != weights.size() - 1) curr += weights[split];\\n            }\\n\\n            smin = min(smin, curr);\\n            smax = max(smax, curr);\\n            // print(\"=======splits:\");\\n            // print(splits);\\n            // std::cout << curr << \",\" << smin << \",\" << smax << \"###########################\" << endl;\\n            return;\\n        }\\n        // 0.1.2.3.4.5.6.7.8.9 0 3  <= 7\\n        //\\n        // int end = weights.size() - (k - scount);\\n        if (start >= weights.size()) return;\\n        // if (start > end) return;\\n\\n        // select\\n        splits[scount] = start;\\n        helper(weights, splits, scount + 1, start + 1, k);\\n\\n        // dont select\\n        helper(weights, splits, scount, start + 1, k);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "uniqs",
                        "content": "[@yangbo02](/yangbo02) The problem with my code is two: firstly time exceed. Secondly these two lines is wrong:\n```\n                if (split != 0) curr += weights[split - 1];\n                if (split != weights.size() - 1) curr += weights[split];\n```\nthere is no need to check the if anymore. if we put the first split at position 0 | 1 the value[0] still need to be added."
                    },
                    {
                        "username": "uniqs",
                        "content": "[@bparanj](/bparanj) Thanks for your reply, I have got the answer by sorting a list of pair sums yesterday.  It is really tricky and funny. Really hard to associate this position sensitive problem with sorting."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your backtracking approach looks conceptually correct for enumerating all possible ways to partition the array, but it does seem to be missing an important part of the problem.\\n\\nSpecifically, in the problem statement, we\\'re asked to maximize the sum of the first and last marble in each bag, and to minimize the same quantity. Therefore, when you\\'re creating your partitions, you should add not just the value at the partition index, but also the one next to it.\\n\\nAlso, the way you\\'re partitioning the array seems to miss the point that we are splitting the array into k+1 subarrays. For instance, if you have the weights [1, 2, 3, 4] and you choose k=1, you\\'ll have two bags: [1, 2] and [3, 4].\\n\\nGiven the constraints of the problem, a backtracking solution might lead to a Time Limit Exceeded error, since it has a time complexity of O(n^k), which is not feasible for larger inputs. The hints suggest using a priority queue, and a more efficient approach involves sorting a list of pair sums. However, your current approach is a good way to thoroughly understand the problem and how the partitioning works."
                    },
                    {
                        "username": "yangbo02",
                        "content": "54 ... 6 | 34 ... 18 | 13 ... 13 | 10 ... 72\\n54 ... 66 | 63 ... 46 | 75 ... 61 | 72 ... 72"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Took me some time and a glimpse at discussions to figure out it got nothing to do with DP. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "Focus on the boundaries, not the marbles.\\n\\nThe problem description may look like it failed to mention you should use up all the marbles, but this is actually a hint in disguise.\\nBecause if you are tricked into thinking you can simply find k bags with each bag having exactly one marble and leaving out the rest of the marbles, then you will come to a \"solution\" that the k smallest marbles and k largest marbles are the answer. Well, you are wrong but actually quite close to the real one.\\n You just need to see the problem from a new angle and shift the focus from the marbles to the boundaries between the marbles."
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I spent days working on a fast enough Dynamic Programming solution. I finally got the performance to `O(nk - k^2)`.\\nThis still failed with Time Limit Exceeded.\\n\\nOnce I twigged on the correct approach it took me two minutes to write a completely new solution that worked."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Why does it seem like \"I searched God for years and could not find him, I looked inside my heart and found him in a second\" \\uD83D\\uDE00"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint:\\n\\nThe problem involves finding the difference between the sum of the largest k sums and the sum of the smallest k sums of consecutive elements in the array.\\nTo efficiently find the largest and smallest sums, you can use two heaps: a MaxHeap and a MinHeap.\\nThe MaxHeap will help you quickly access the largest sums, and the MinHeap will help you quickly access the smallest sums.\\nPopulate both heaps while iterating over the array of consecutive sums.\\nIf the size of either heap becomes greater than k, use the appropriate heap operation to maintain only the top k elements in the heap.\\nFinally, calculate the difference between the sum of elements in the MaxHeap and the sum of elements in the MinHeap to obtain the result.\\nKeep in mind that understanding how to use the heaps and their operations will be crucial to efficiently solve this problem. Happy coding!"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint: This issue can be resolved by utilizing a binary search methodology to identify the lowest and highest scores. Initially, we arrange the weight array in ascending order. Subsequently, we examine each potential score (ranging from the minimum attainable to the maximum attainable) to determine whether it is feasible to distribute the marbles into k bags with a score that is less than or equal to the current score. If such distribution is possible, we adjust the minimum score accordingly. Conversely, if the distribution is not feasible, we adjust the maximum score. The discrepancy between the highest and lowest scores will serve as the final solution."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "I don\\'t understand expected outcome for testcase weights=[1,4,2,5,2] and k=3.\\n\\nMax score split should be 1,4 | 2 | 5 | 2. Score is 23.\\nMin score split should be 1 | 4 | 2, 5 | 2 OR 1 | 4 | 2 | 5,2. Score is 21.\\n\\nSo, the expected outcome should be 2. Why is it 3?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`k` is the number of groups, so you actaully needs `k - 1` \"cuts\", you are making `k` cuts so you have `k + 1` groups\\n[1, 4, 2], [5], [2] = (1 + 2) + (5 + 5) + (2 + 2) = 17\\n[1], [4], [2, 5, 2] = (1 + 1) + (4 + 4) + (2 + 2) = 14\\n17 - 14 = 3"
                    }
                ]
            },
            {
                "id": 1987086,
                "content": [
                    {
                        "username": "bj-jiwrajka",
                        "content": "Leetcode and its testcases\\uD83D\\uDE42"
                    },
                    {
                        "username": "svinther",
                        "content": "First time I\\'ve seen a hard that can be solved in 2 lines"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Am I the only one who finds comprehending the problem description tough ?"
                    },
                    {
                        "username": "ms232gg",
                        "content": "It should have been mentioned that you have to distribute all the marbles in the bag"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? I used backtrack to enumerate every possibility.\\n[54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72]  with k = 4 expected 289, but my result is 271. this is really hard to verify by hand...\\n```\\nclass Solution {\\n    long long smin = LONG_MAX;\\n    long long smax = 0;\\n\\n   public:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        if (k >= weights.size()) return 0;\\n        vector<int> splits(k - 1, 0);\\n        helper(weights, splits, 0, 1, k);\\n        return smax - smin;\\n    }\\n    void helper(vector<int>& weights, vector<int>& splits, int scount, int start, int k) {\\n        if (scount >= k - 1) {\\n            long long curr = weights[0] + weights[weights.size() - 1];\\n            for (int i = 0; i < scount; ++i) {\\n                int split = splits[i];\\n                if (split != 0) curr += weights[split - 1];\\n                if (split != weights.size() - 1) curr += weights[split];\\n            }\\n\\n            smin = min(smin, curr);\\n            smax = max(smax, curr);\\n            // print(\"=======splits:\");\\n            // print(splits);\\n            // std::cout << curr << \",\" << smin << \",\" << smax << \"###########################\" << endl;\\n            return;\\n        }\\n        // 0.1.2.3.4.5.6.7.8.9 0 3  <= 7\\n        //\\n        // int end = weights.size() - (k - scount);\\n        if (start >= weights.size()) return;\\n        // if (start > end) return;\\n\\n        // select\\n        splits[scount] = start;\\n        helper(weights, splits, scount + 1, start + 1, k);\\n\\n        // dont select\\n        helper(weights, splits, scount, start + 1, k);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "uniqs",
                        "content": "[@yangbo02](/yangbo02) The problem with my code is two: firstly time exceed. Secondly these two lines is wrong:\n```\n                if (split != 0) curr += weights[split - 1];\n                if (split != weights.size() - 1) curr += weights[split];\n```\nthere is no need to check the if anymore. if we put the first split at position 0 | 1 the value[0] still need to be added."
                    },
                    {
                        "username": "uniqs",
                        "content": "[@bparanj](/bparanj) Thanks for your reply, I have got the answer by sorting a list of pair sums yesterday.  It is really tricky and funny. Really hard to associate this position sensitive problem with sorting."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your backtracking approach looks conceptually correct for enumerating all possible ways to partition the array, but it does seem to be missing an important part of the problem.\\n\\nSpecifically, in the problem statement, we\\'re asked to maximize the sum of the first and last marble in each bag, and to minimize the same quantity. Therefore, when you\\'re creating your partitions, you should add not just the value at the partition index, but also the one next to it.\\n\\nAlso, the way you\\'re partitioning the array seems to miss the point that we are splitting the array into k+1 subarrays. For instance, if you have the weights [1, 2, 3, 4] and you choose k=1, you\\'ll have two bags: [1, 2] and [3, 4].\\n\\nGiven the constraints of the problem, a backtracking solution might lead to a Time Limit Exceeded error, since it has a time complexity of O(n^k), which is not feasible for larger inputs. The hints suggest using a priority queue, and a more efficient approach involves sorting a list of pair sums. However, your current approach is a good way to thoroughly understand the problem and how the partitioning works."
                    },
                    {
                        "username": "yangbo02",
                        "content": "54 ... 6 | 34 ... 18 | 13 ... 13 | 10 ... 72\\n54 ... 66 | 63 ... 46 | 75 ... 61 | 72 ... 72"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Took me some time and a glimpse at discussions to figure out it got nothing to do with DP. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "Focus on the boundaries, not the marbles.\\n\\nThe problem description may look like it failed to mention you should use up all the marbles, but this is actually a hint in disguise.\\nBecause if you are tricked into thinking you can simply find k bags with each bag having exactly one marble and leaving out the rest of the marbles, then you will come to a \"solution\" that the k smallest marbles and k largest marbles are the answer. Well, you are wrong but actually quite close to the real one.\\n You just need to see the problem from a new angle and shift the focus from the marbles to the boundaries between the marbles."
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I spent days working on a fast enough Dynamic Programming solution. I finally got the performance to `O(nk - k^2)`.\\nThis still failed with Time Limit Exceeded.\\n\\nOnce I twigged on the correct approach it took me two minutes to write a completely new solution that worked."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Why does it seem like \"I searched God for years and could not find him, I looked inside my heart and found him in a second\" \\uD83D\\uDE00"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint:\\n\\nThe problem involves finding the difference between the sum of the largest k sums and the sum of the smallest k sums of consecutive elements in the array.\\nTo efficiently find the largest and smallest sums, you can use two heaps: a MaxHeap and a MinHeap.\\nThe MaxHeap will help you quickly access the largest sums, and the MinHeap will help you quickly access the smallest sums.\\nPopulate both heaps while iterating over the array of consecutive sums.\\nIf the size of either heap becomes greater than k, use the appropriate heap operation to maintain only the top k elements in the heap.\\nFinally, calculate the difference between the sum of elements in the MaxHeap and the sum of elements in the MinHeap to obtain the result.\\nKeep in mind that understanding how to use the heaps and their operations will be crucial to efficiently solve this problem. Happy coding!"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint: This issue can be resolved by utilizing a binary search methodology to identify the lowest and highest scores. Initially, we arrange the weight array in ascending order. Subsequently, we examine each potential score (ranging from the minimum attainable to the maximum attainable) to determine whether it is feasible to distribute the marbles into k bags with a score that is less than or equal to the current score. If such distribution is possible, we adjust the minimum score accordingly. Conversely, if the distribution is not feasible, we adjust the maximum score. The discrepancy between the highest and lowest scores will serve as the final solution."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "I don\\'t understand expected outcome for testcase weights=[1,4,2,5,2] and k=3.\\n\\nMax score split should be 1,4 | 2 | 5 | 2. Score is 23.\\nMin score split should be 1 | 4 | 2, 5 | 2 OR 1 | 4 | 2 | 5,2. Score is 21.\\n\\nSo, the expected outcome should be 2. Why is it 3?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`k` is the number of groups, so you actaully needs `k - 1` \"cuts\", you are making `k` cuts so you have `k + 1` groups\\n[1, 4, 2], [5], [2] = (1 + 2) + (5 + 5) + (2 + 2) = 17\\n[1], [4], [2, 5, 2] = (1 + 1) + (4 + 4) + (2 + 2) = 14\\n17 - 14 = 3"
                    }
                ]
            },
            {
                "id": 1987022,
                "content": [
                    {
                        "username": "bj-jiwrajka",
                        "content": "Leetcode and its testcases\\uD83D\\uDE42"
                    },
                    {
                        "username": "svinther",
                        "content": "First time I\\'ve seen a hard that can be solved in 2 lines"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Am I the only one who finds comprehending the problem description tough ?"
                    },
                    {
                        "username": "ms232gg",
                        "content": "It should have been mentioned that you have to distribute all the marbles in the bag"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? I used backtrack to enumerate every possibility.\\n[54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72]  with k = 4 expected 289, but my result is 271. this is really hard to verify by hand...\\n```\\nclass Solution {\\n    long long smin = LONG_MAX;\\n    long long smax = 0;\\n\\n   public:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        if (k >= weights.size()) return 0;\\n        vector<int> splits(k - 1, 0);\\n        helper(weights, splits, 0, 1, k);\\n        return smax - smin;\\n    }\\n    void helper(vector<int>& weights, vector<int>& splits, int scount, int start, int k) {\\n        if (scount >= k - 1) {\\n            long long curr = weights[0] + weights[weights.size() - 1];\\n            for (int i = 0; i < scount; ++i) {\\n                int split = splits[i];\\n                if (split != 0) curr += weights[split - 1];\\n                if (split != weights.size() - 1) curr += weights[split];\\n            }\\n\\n            smin = min(smin, curr);\\n            smax = max(smax, curr);\\n            // print(\"=======splits:\");\\n            // print(splits);\\n            // std::cout << curr << \",\" << smin << \",\" << smax << \"###########################\" << endl;\\n            return;\\n        }\\n        // 0.1.2.3.4.5.6.7.8.9 0 3  <= 7\\n        //\\n        // int end = weights.size() - (k - scount);\\n        if (start >= weights.size()) return;\\n        // if (start > end) return;\\n\\n        // select\\n        splits[scount] = start;\\n        helper(weights, splits, scount + 1, start + 1, k);\\n\\n        // dont select\\n        helper(weights, splits, scount, start + 1, k);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "uniqs",
                        "content": "[@yangbo02](/yangbo02) The problem with my code is two: firstly time exceed. Secondly these two lines is wrong:\n```\n                if (split != 0) curr += weights[split - 1];\n                if (split != weights.size() - 1) curr += weights[split];\n```\nthere is no need to check the if anymore. if we put the first split at position 0 | 1 the value[0] still need to be added."
                    },
                    {
                        "username": "uniqs",
                        "content": "[@bparanj](/bparanj) Thanks for your reply, I have got the answer by sorting a list of pair sums yesterday.  It is really tricky and funny. Really hard to associate this position sensitive problem with sorting."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your backtracking approach looks conceptually correct for enumerating all possible ways to partition the array, but it does seem to be missing an important part of the problem.\\n\\nSpecifically, in the problem statement, we\\'re asked to maximize the sum of the first and last marble in each bag, and to minimize the same quantity. Therefore, when you\\'re creating your partitions, you should add not just the value at the partition index, but also the one next to it.\\n\\nAlso, the way you\\'re partitioning the array seems to miss the point that we are splitting the array into k+1 subarrays. For instance, if you have the weights [1, 2, 3, 4] and you choose k=1, you\\'ll have two bags: [1, 2] and [3, 4].\\n\\nGiven the constraints of the problem, a backtracking solution might lead to a Time Limit Exceeded error, since it has a time complexity of O(n^k), which is not feasible for larger inputs. The hints suggest using a priority queue, and a more efficient approach involves sorting a list of pair sums. However, your current approach is a good way to thoroughly understand the problem and how the partitioning works."
                    },
                    {
                        "username": "yangbo02",
                        "content": "54 ... 6 | 34 ... 18 | 13 ... 13 | 10 ... 72\\n54 ... 66 | 63 ... 46 | 75 ... 61 | 72 ... 72"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Took me some time and a glimpse at discussions to figure out it got nothing to do with DP. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "Focus on the boundaries, not the marbles.\\n\\nThe problem description may look like it failed to mention you should use up all the marbles, but this is actually a hint in disguise.\\nBecause if you are tricked into thinking you can simply find k bags with each bag having exactly one marble and leaving out the rest of the marbles, then you will come to a \"solution\" that the k smallest marbles and k largest marbles are the answer. Well, you are wrong but actually quite close to the real one.\\n You just need to see the problem from a new angle and shift the focus from the marbles to the boundaries between the marbles."
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I spent days working on a fast enough Dynamic Programming solution. I finally got the performance to `O(nk - k^2)`.\\nThis still failed with Time Limit Exceeded.\\n\\nOnce I twigged on the correct approach it took me two minutes to write a completely new solution that worked."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Why does it seem like \"I searched God for years and could not find him, I looked inside my heart and found him in a second\" \\uD83D\\uDE00"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint:\\n\\nThe problem involves finding the difference between the sum of the largest k sums and the sum of the smallest k sums of consecutive elements in the array.\\nTo efficiently find the largest and smallest sums, you can use two heaps: a MaxHeap and a MinHeap.\\nThe MaxHeap will help you quickly access the largest sums, and the MinHeap will help you quickly access the smallest sums.\\nPopulate both heaps while iterating over the array of consecutive sums.\\nIf the size of either heap becomes greater than k, use the appropriate heap operation to maintain only the top k elements in the heap.\\nFinally, calculate the difference between the sum of elements in the MaxHeap and the sum of elements in the MinHeap to obtain the result.\\nKeep in mind that understanding how to use the heaps and their operations will be crucial to efficiently solve this problem. Happy coding!"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint: This issue can be resolved by utilizing a binary search methodology to identify the lowest and highest scores. Initially, we arrange the weight array in ascending order. Subsequently, we examine each potential score (ranging from the minimum attainable to the maximum attainable) to determine whether it is feasible to distribute the marbles into k bags with a score that is less than or equal to the current score. If such distribution is possible, we adjust the minimum score accordingly. Conversely, if the distribution is not feasible, we adjust the maximum score. The discrepancy between the highest and lowest scores will serve as the final solution."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "I don\\'t understand expected outcome for testcase weights=[1,4,2,5,2] and k=3.\\n\\nMax score split should be 1,4 | 2 | 5 | 2. Score is 23.\\nMin score split should be 1 | 4 | 2, 5 | 2 OR 1 | 4 | 2 | 5,2. Score is 21.\\n\\nSo, the expected outcome should be 2. Why is it 3?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`k` is the number of groups, so you actaully needs `k - 1` \"cuts\", you are making `k` cuts so you have `k + 1` groups\\n[1, 4, 2], [5], [2] = (1 + 2) + (5 + 5) + (2 + 2) = 17\\n[1], [4], [2, 5, 2] = (1 + 1) + (4 + 4) + (2 + 2) = 14\\n17 - 14 = 3"
                    }
                ]
            },
            {
                "id": 1986161,
                "content": [
                    {
                        "username": "bj-jiwrajka",
                        "content": "Leetcode and its testcases\\uD83D\\uDE42"
                    },
                    {
                        "username": "svinther",
                        "content": "First time I\\'ve seen a hard that can be solved in 2 lines"
                    },
                    {
                        "username": "parasmn4",
                        "content": "Am I the only one who finds comprehending the problem description tough ?"
                    },
                    {
                        "username": "ms232gg",
                        "content": "It should have been mentioned that you have to distribute all the marbles in the bag"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? I used backtrack to enumerate every possibility.\\n[54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72]  with k = 4 expected 289, but my result is 271. this is really hard to verify by hand...\\n```\\nclass Solution {\\n    long long smin = LONG_MAX;\\n    long long smax = 0;\\n\\n   public:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        if (k >= weights.size()) return 0;\\n        vector<int> splits(k - 1, 0);\\n        helper(weights, splits, 0, 1, k);\\n        return smax - smin;\\n    }\\n    void helper(vector<int>& weights, vector<int>& splits, int scount, int start, int k) {\\n        if (scount >= k - 1) {\\n            long long curr = weights[0] + weights[weights.size() - 1];\\n            for (int i = 0; i < scount; ++i) {\\n                int split = splits[i];\\n                if (split != 0) curr += weights[split - 1];\\n                if (split != weights.size() - 1) curr += weights[split];\\n            }\\n\\n            smin = min(smin, curr);\\n            smax = max(smax, curr);\\n            // print(\"=======splits:\");\\n            // print(splits);\\n            // std::cout << curr << \",\" << smin << \",\" << smax << \"###########################\" << endl;\\n            return;\\n        }\\n        // 0.1.2.3.4.5.6.7.8.9 0 3  <= 7\\n        //\\n        // int end = weights.size() - (k - scount);\\n        if (start >= weights.size()) return;\\n        // if (start > end) return;\\n\\n        // select\\n        splits[scount] = start;\\n        helper(weights, splits, scount + 1, start + 1, k);\\n\\n        // dont select\\n        helper(weights, splits, scount, start + 1, k);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "uniqs",
                        "content": "[@yangbo02](/yangbo02) The problem with my code is two: firstly time exceed. Secondly these two lines is wrong:\n```\n                if (split != 0) curr += weights[split - 1];\n                if (split != weights.size() - 1) curr += weights[split];\n```\nthere is no need to check the if anymore. if we put the first split at position 0 | 1 the value[0] still need to be added."
                    },
                    {
                        "username": "uniqs",
                        "content": "[@bparanj](/bparanj) Thanks for your reply, I have got the answer by sorting a list of pair sums yesterday.  It is really tricky and funny. Really hard to associate this position sensitive problem with sorting."
                    },
                    {
                        "username": "bparanj",
                        "content": "Your backtracking approach looks conceptually correct for enumerating all possible ways to partition the array, but it does seem to be missing an important part of the problem.\\n\\nSpecifically, in the problem statement, we\\'re asked to maximize the sum of the first and last marble in each bag, and to minimize the same quantity. Therefore, when you\\'re creating your partitions, you should add not just the value at the partition index, but also the one next to it.\\n\\nAlso, the way you\\'re partitioning the array seems to miss the point that we are splitting the array into k+1 subarrays. For instance, if you have the weights [1, 2, 3, 4] and you choose k=1, you\\'ll have two bags: [1, 2] and [3, 4].\\n\\nGiven the constraints of the problem, a backtracking solution might lead to a Time Limit Exceeded error, since it has a time complexity of O(n^k), which is not feasible for larger inputs. The hints suggest using a priority queue, and a more efficient approach involves sorting a list of pair sums. However, your current approach is a good way to thoroughly understand the problem and how the partitioning works."
                    },
                    {
                        "username": "yangbo02",
                        "content": "54 ... 6 | 34 ... 18 | 13 ... 13 | 10 ... 72\\n54 ... 66 | 63 ... 46 | 75 ... 61 | 72 ... 72"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Took me some time and a glimpse at discussions to figure out it got nothing to do with DP. "
                    },
                    {
                        "username": "Kaltu",
                        "content": "Focus on the boundaries, not the marbles.\\n\\nThe problem description may look like it failed to mention you should use up all the marbles, but this is actually a hint in disguise.\\nBecause if you are tricked into thinking you can simply find k bags with each bag having exactly one marble and leaving out the rest of the marbles, then you will come to a \"solution\" that the k smallest marbles and k largest marbles are the answer. Well, you are wrong but actually quite close to the real one.\\n You just need to see the problem from a new angle and shift the focus from the marbles to the boundaries between the marbles."
                    },
                    {
                        "username": "shepherd_a",
                        "content": "I spent days working on a fast enough Dynamic Programming solution. I finally got the performance to `O(nk - k^2)`.\\nThis still failed with Time Limit Exceeded.\\n\\nOnce I twigged on the correct approach it took me two minutes to write a completely new solution that worked."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Why does it seem like \"I searched God for years and could not find him, I looked inside my heart and found him in a second\" \\uD83D\\uDE00"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint:\\n\\nThe problem involves finding the difference between the sum of the largest k sums and the sum of the smallest k sums of consecutive elements in the array.\\nTo efficiently find the largest and smallest sums, you can use two heaps: a MaxHeap and a MinHeap.\\nThe MaxHeap will help you quickly access the largest sums, and the MinHeap will help you quickly access the smallest sums.\\nPopulate both heaps while iterating over the array of consecutive sums.\\nIf the size of either heap becomes greater than k, use the appropriate heap operation to maintain only the top k elements in the heap.\\nFinally, calculate the difference between the sum of elements in the MaxHeap and the sum of elements in the MinHeap to obtain the result.\\nKeep in mind that understanding how to use the heaps and their operations will be crucial to efficiently solve this problem. Happy coding!"
                    },
                    {
                        "username": "dddimcha",
                        "content": "Hint: This issue can be resolved by utilizing a binary search methodology to identify the lowest and highest scores. Initially, we arrange the weight array in ascending order. Subsequently, we examine each potential score (ranging from the minimum attainable to the maximum attainable) to determine whether it is feasible to distribute the marbles into k bags with a score that is less than or equal to the current score. If such distribution is possible, we adjust the minimum score accordingly. Conversely, if the distribution is not feasible, we adjust the maximum score. The discrepancy between the highest and lowest scores will serve as the final solution."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "I don\\'t understand expected outcome for testcase weights=[1,4,2,5,2] and k=3.\\n\\nMax score split should be 1,4 | 2 | 5 | 2. Score is 23.\\nMin score split should be 1 | 4 | 2, 5 | 2 OR 1 | 4 | 2 | 5,2. Score is 21.\\n\\nSo, the expected outcome should be 2. Why is it 3?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "`k` is the number of groups, so you actaully needs `k - 1` \"cuts\", you are making `k` cuts so you have `k + 1` groups\\n[1, 4, 2], [5], [2] = (1 + 2) + (5 + 5) + (2 + 2) = 17\\n[1], [4], [2, 5, 2] = (1 + 1) + (4 + 4) + (2 + 2) = 14\\n17 - 14 = 3"
                    }
                ]
            },
            {
                "id": 1966238,
                "content": [
                    {
                        "username": "Cristian16",
                        "content": "I have a question regarding my example: How is it possible the answer to be 28?\\nGiven: w = [1,9,8,7,1,1,1] and k = 3.\\nIt is impossible to obtain a maximum sum of 28, and even if you extract the minimum sum, it will be much lower.\\nI apologize if my English is not the best."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "Max score split is - 1 | 9 | 8 | 7,1,1,1. So sum will be on 1,1 , 9,9 , 8,8 , 7,1,1,1 which is 46."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "for minimum partiton  you can divide like [(1,9,8,7,1),(1),(1)] total minimum sum is [(1+1),(1+1),(1+1)] =6\\nfor max you can divide like [(1,9),(8),(7,1,1,1)] Total max sum is [(1+9),(8+8),(7+1)] which sums upto 34  \\nsince for cost we need to consider only boundary element\\n\\nSo we will get our difference 28 which is required answer  \\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "The tricky part in this questions is to find the pattern once you find the pattern it becomes easier. I myself headed over to the solution tab after trying this problem for half an hour and then found the pattern."
                    },
                    {
                        "username": "feng3245",
                        "content": "I got to the solution but somehow do not understand how and why it works... it just look wrong like does not add up...."
                    },
                    {
                        "username": "lone17",
                        "content": "The hard part of this problem is that it\\'s label as hard, which makes people overthink and go for a dp solution. If this were medium or easy, people would properly come up with the solution faster."
                    },
                    {
                        "username": "Diean233",
                        "content": "Did not read carefully at first, thought that bag with only one marble has the score of that single weight, and wasted a lot of time thinking in the wrong direction...\\nIt is an interesting problem to solve."
                    },
                    {
                        "username": "feng3245",
                        "content": "Try this question instead.\\nYou have 2 marbles that must cost you from index 0 and n-1\\nYou want to find out the biggest difference you can get by picking n-1 pairs where each pair resulted from indexes of j and j-1 where j >= 0 and <= n-1"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Definitely an overrated question. Should be normal middle or difficult easy question. "
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "How to know its not a DP problem?"
                    },
                    {
                        "username": "dguerri",
                        "content": "\"Divide the marbles ...\"\\nshould be read as divide _all_ the marbles."
                    },
                    {
                        "username": "027_gurdeep",
                        "content": "class Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long>v;\\n        for(int i= 1; i <weights.size(); i++){\\n            v.push_back(weights[i-1]+weights[i]);\\n        }\\n        sort(v.begin(),v.end());\\n        k--;\\n        int left = 0, right = v.size()-1;\\n        long long ans = 0;\\n        while(k > 0){\\n            ans += v[right]-v[left];\\n            right--;\\n            left++;\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1962455,
                "content": [
                    {
                        "username": "Cristian16",
                        "content": "I have a question regarding my example: How is it possible the answer to be 28?\\nGiven: w = [1,9,8,7,1,1,1] and k = 3.\\nIt is impossible to obtain a maximum sum of 28, and even if you extract the minimum sum, it will be much lower.\\nI apologize if my English is not the best."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "Max score split is - 1 | 9 | 8 | 7,1,1,1. So sum will be on 1,1 , 9,9 , 8,8 , 7,1,1,1 which is 46."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "for minimum partiton  you can divide like [(1,9,8,7,1),(1),(1)] total minimum sum is [(1+1),(1+1),(1+1)] =6\\nfor max you can divide like [(1,9),(8),(7,1,1,1)] Total max sum is [(1+9),(8+8),(7+1)] which sums upto 34  \\nsince for cost we need to consider only boundary element\\n\\nSo we will get our difference 28 which is required answer  \\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "The tricky part in this questions is to find the pattern once you find the pattern it becomes easier. I myself headed over to the solution tab after trying this problem for half an hour and then found the pattern."
                    },
                    {
                        "username": "feng3245",
                        "content": "I got to the solution but somehow do not understand how and why it works... it just look wrong like does not add up...."
                    },
                    {
                        "username": "lone17",
                        "content": "The hard part of this problem is that it\\'s label as hard, which makes people overthink and go for a dp solution. If this were medium or easy, people would properly come up with the solution faster."
                    },
                    {
                        "username": "Diean233",
                        "content": "Did not read carefully at first, thought that bag with only one marble has the score of that single weight, and wasted a lot of time thinking in the wrong direction...\\nIt is an interesting problem to solve."
                    },
                    {
                        "username": "feng3245",
                        "content": "Try this question instead.\\nYou have 2 marbles that must cost you from index 0 and n-1\\nYou want to find out the biggest difference you can get by picking n-1 pairs where each pair resulted from indexes of j and j-1 where j >= 0 and <= n-1"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Definitely an overrated question. Should be normal middle or difficult easy question. "
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "How to know its not a DP problem?"
                    },
                    {
                        "username": "dguerri",
                        "content": "\"Divide the marbles ...\"\\nshould be read as divide _all_ the marbles."
                    },
                    {
                        "username": "027_gurdeep",
                        "content": "class Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long>v;\\n        for(int i= 1; i <weights.size(); i++){\\n            v.push_back(weights[i-1]+weights[i]);\\n        }\\n        sort(v.begin(),v.end());\\n        k--;\\n        int left = 0, right = v.size()-1;\\n        long long ans = 0;\\n        while(k > 0){\\n            ans += v[right]-v[left];\\n            right--;\\n            left++;\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1962066,
                "content": [
                    {
                        "username": "Cristian16",
                        "content": "I have a question regarding my example: How is it possible the answer to be 28?\\nGiven: w = [1,9,8,7,1,1,1] and k = 3.\\nIt is impossible to obtain a maximum sum of 28, and even if you extract the minimum sum, it will be much lower.\\nI apologize if my English is not the best."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "Max score split is - 1 | 9 | 8 | 7,1,1,1. So sum will be on 1,1 , 9,9 , 8,8 , 7,1,1,1 which is 46."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "for minimum partiton  you can divide like [(1,9,8,7,1),(1),(1)] total minimum sum is [(1+1),(1+1),(1+1)] =6\\nfor max you can divide like [(1,9),(8),(7,1,1,1)] Total max sum is [(1+9),(8+8),(7+1)] which sums upto 34  \\nsince for cost we need to consider only boundary element\\n\\nSo we will get our difference 28 which is required answer  \\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "The tricky part in this questions is to find the pattern once you find the pattern it becomes easier. I myself headed over to the solution tab after trying this problem for half an hour and then found the pattern."
                    },
                    {
                        "username": "feng3245",
                        "content": "I got to the solution but somehow do not understand how and why it works... it just look wrong like does not add up...."
                    },
                    {
                        "username": "lone17",
                        "content": "The hard part of this problem is that it\\'s label as hard, which makes people overthink and go for a dp solution. If this were medium or easy, people would properly come up with the solution faster."
                    },
                    {
                        "username": "Diean233",
                        "content": "Did not read carefully at first, thought that bag with only one marble has the score of that single weight, and wasted a lot of time thinking in the wrong direction...\\nIt is an interesting problem to solve."
                    },
                    {
                        "username": "feng3245",
                        "content": "Try this question instead.\\nYou have 2 marbles that must cost you from index 0 and n-1\\nYou want to find out the biggest difference you can get by picking n-1 pairs where each pair resulted from indexes of j and j-1 where j >= 0 and <= n-1"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Definitely an overrated question. Should be normal middle or difficult easy question. "
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "How to know its not a DP problem?"
                    },
                    {
                        "username": "dguerri",
                        "content": "\"Divide the marbles ...\"\\nshould be read as divide _all_ the marbles."
                    },
                    {
                        "username": "027_gurdeep",
                        "content": "class Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long>v;\\n        for(int i= 1; i <weights.size(); i++){\\n            v.push_back(weights[i-1]+weights[i]);\\n        }\\n        sort(v.begin(),v.end());\\n        k--;\\n        int left = 0, right = v.size()-1;\\n        long long ans = 0;\\n        while(k > 0){\\n            ans += v[right]-v[left];\\n            right--;\\n            left++;\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1961953,
                "content": [
                    {
                        "username": "Cristian16",
                        "content": "I have a question regarding my example: How is it possible the answer to be 28?\\nGiven: w = [1,9,8,7,1,1,1] and k = 3.\\nIt is impossible to obtain a maximum sum of 28, and even if you extract the minimum sum, it will be much lower.\\nI apologize if my English is not the best."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "Max score split is - 1 | 9 | 8 | 7,1,1,1. So sum will be on 1,1 , 9,9 , 8,8 , 7,1,1,1 which is 46."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "for minimum partiton  you can divide like [(1,9,8,7,1),(1),(1)] total minimum sum is [(1+1),(1+1),(1+1)] =6\\nfor max you can divide like [(1,9),(8),(7,1,1,1)] Total max sum is [(1+9),(8+8),(7+1)] which sums upto 34  \\nsince for cost we need to consider only boundary element\\n\\nSo we will get our difference 28 which is required answer  \\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "The tricky part in this questions is to find the pattern once you find the pattern it becomes easier. I myself headed over to the solution tab after trying this problem for half an hour and then found the pattern."
                    },
                    {
                        "username": "feng3245",
                        "content": "I got to the solution but somehow do not understand how and why it works... it just look wrong like does not add up...."
                    },
                    {
                        "username": "lone17",
                        "content": "The hard part of this problem is that it\\'s label as hard, which makes people overthink and go for a dp solution. If this were medium or easy, people would properly come up with the solution faster."
                    },
                    {
                        "username": "Diean233",
                        "content": "Did not read carefully at first, thought that bag with only one marble has the score of that single weight, and wasted a lot of time thinking in the wrong direction...\\nIt is an interesting problem to solve."
                    },
                    {
                        "username": "feng3245",
                        "content": "Try this question instead.\\nYou have 2 marbles that must cost you from index 0 and n-1\\nYou want to find out the biggest difference you can get by picking n-1 pairs where each pair resulted from indexes of j and j-1 where j >= 0 and <= n-1"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Definitely an overrated question. Should be normal middle or difficult easy question. "
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "How to know its not a DP problem?"
                    },
                    {
                        "username": "dguerri",
                        "content": "\"Divide the marbles ...\"\\nshould be read as divide _all_ the marbles."
                    },
                    {
                        "username": "027_gurdeep",
                        "content": "class Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long>v;\\n        for(int i= 1; i <weights.size(); i++){\\n            v.push_back(weights[i-1]+weights[i]);\\n        }\\n        sort(v.begin(),v.end());\\n        k--;\\n        int left = 0, right = v.size()-1;\\n        long long ans = 0;\\n        while(k > 0){\\n            ans += v[right]-v[left];\\n            right--;\\n            left++;\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1961876,
                "content": [
                    {
                        "username": "Cristian16",
                        "content": "I have a question regarding my example: How is it possible the answer to be 28?\\nGiven: w = [1,9,8,7,1,1,1] and k = 3.\\nIt is impossible to obtain a maximum sum of 28, and even if you extract the minimum sum, it will be much lower.\\nI apologize if my English is not the best."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "Max score split is - 1 | 9 | 8 | 7,1,1,1. So sum will be on 1,1 , 9,9 , 8,8 , 7,1,1,1 which is 46."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "for minimum partiton  you can divide like [(1,9,8,7,1),(1),(1)] total minimum sum is [(1+1),(1+1),(1+1)] =6\\nfor max you can divide like [(1,9),(8),(7,1,1,1)] Total max sum is [(1+9),(8+8),(7+1)] which sums upto 34  \\nsince for cost we need to consider only boundary element\\n\\nSo we will get our difference 28 which is required answer  \\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "The tricky part in this questions is to find the pattern once you find the pattern it becomes easier. I myself headed over to the solution tab after trying this problem for half an hour and then found the pattern."
                    },
                    {
                        "username": "feng3245",
                        "content": "I got to the solution but somehow do not understand how and why it works... it just look wrong like does not add up...."
                    },
                    {
                        "username": "lone17",
                        "content": "The hard part of this problem is that it\\'s label as hard, which makes people overthink and go for a dp solution. If this were medium or easy, people would properly come up with the solution faster."
                    },
                    {
                        "username": "Diean233",
                        "content": "Did not read carefully at first, thought that bag with only one marble has the score of that single weight, and wasted a lot of time thinking in the wrong direction...\\nIt is an interesting problem to solve."
                    },
                    {
                        "username": "feng3245",
                        "content": "Try this question instead.\\nYou have 2 marbles that must cost you from index 0 and n-1\\nYou want to find out the biggest difference you can get by picking n-1 pairs where each pair resulted from indexes of j and j-1 where j >= 0 and <= n-1"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Definitely an overrated question. Should be normal middle or difficult easy question. "
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "How to know its not a DP problem?"
                    },
                    {
                        "username": "dguerri",
                        "content": "\"Divide the marbles ...\"\\nshould be read as divide _all_ the marbles."
                    },
                    {
                        "username": "027_gurdeep",
                        "content": "class Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long>v;\\n        for(int i= 1; i <weights.size(); i++){\\n            v.push_back(weights[i-1]+weights[i]);\\n        }\\n        sort(v.begin(),v.end());\\n        k--;\\n        int left = 0, right = v.size()-1;\\n        long long ans = 0;\\n        while(k > 0){\\n            ans += v[right]-v[left];\\n            right--;\\n            left++;\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1961837,
                "content": [
                    {
                        "username": "Cristian16",
                        "content": "I have a question regarding my example: How is it possible the answer to be 28?\\nGiven: w = [1,9,8,7,1,1,1] and k = 3.\\nIt is impossible to obtain a maximum sum of 28, and even if you extract the minimum sum, it will be much lower.\\nI apologize if my English is not the best."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "Max score split is - 1 | 9 | 8 | 7,1,1,1. So sum will be on 1,1 , 9,9 , 8,8 , 7,1,1,1 which is 46."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "for minimum partiton  you can divide like [(1,9,8,7,1),(1),(1)] total minimum sum is [(1+1),(1+1),(1+1)] =6\\nfor max you can divide like [(1,9),(8),(7,1,1,1)] Total max sum is [(1+9),(8+8),(7+1)] which sums upto 34  \\nsince for cost we need to consider only boundary element\\n\\nSo we will get our difference 28 which is required answer  \\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "The tricky part in this questions is to find the pattern once you find the pattern it becomes easier. I myself headed over to the solution tab after trying this problem for half an hour and then found the pattern."
                    },
                    {
                        "username": "feng3245",
                        "content": "I got to the solution but somehow do not understand how and why it works... it just look wrong like does not add up...."
                    },
                    {
                        "username": "lone17",
                        "content": "The hard part of this problem is that it\\'s label as hard, which makes people overthink and go for a dp solution. If this were medium or easy, people would properly come up with the solution faster."
                    },
                    {
                        "username": "Diean233",
                        "content": "Did not read carefully at first, thought that bag with only one marble has the score of that single weight, and wasted a lot of time thinking in the wrong direction...\\nIt is an interesting problem to solve."
                    },
                    {
                        "username": "feng3245",
                        "content": "Try this question instead.\\nYou have 2 marbles that must cost you from index 0 and n-1\\nYou want to find out the biggest difference you can get by picking n-1 pairs where each pair resulted from indexes of j and j-1 where j >= 0 and <= n-1"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Definitely an overrated question. Should be normal middle or difficult easy question. "
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "How to know its not a DP problem?"
                    },
                    {
                        "username": "dguerri",
                        "content": "\"Divide the marbles ...\"\\nshould be read as divide _all_ the marbles."
                    },
                    {
                        "username": "027_gurdeep",
                        "content": "class Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long>v;\\n        for(int i= 1; i <weights.size(); i++){\\n            v.push_back(weights[i-1]+weights[i]);\\n        }\\n        sort(v.begin(),v.end());\\n        k--;\\n        int left = 0, right = v.size()-1;\\n        long long ans = 0;\\n        while(k > 0){\\n            ans += v[right]-v[left];\\n            right--;\\n            left++;\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1961809,
                "content": [
                    {
                        "username": "Cristian16",
                        "content": "I have a question regarding my example: How is it possible the answer to be 28?\\nGiven: w = [1,9,8,7,1,1,1] and k = 3.\\nIt is impossible to obtain a maximum sum of 28, and even if you extract the minimum sum, it will be much lower.\\nI apologize if my English is not the best."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "Max score split is - 1 | 9 | 8 | 7,1,1,1. So sum will be on 1,1 , 9,9 , 8,8 , 7,1,1,1 which is 46."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "for minimum partiton  you can divide like [(1,9,8,7,1),(1),(1)] total minimum sum is [(1+1),(1+1),(1+1)] =6\\nfor max you can divide like [(1,9),(8),(7,1,1,1)] Total max sum is [(1+9),(8+8),(7+1)] which sums upto 34  \\nsince for cost we need to consider only boundary element\\n\\nSo we will get our difference 28 which is required answer  \\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "The tricky part in this questions is to find the pattern once you find the pattern it becomes easier. I myself headed over to the solution tab after trying this problem for half an hour and then found the pattern."
                    },
                    {
                        "username": "feng3245",
                        "content": "I got to the solution but somehow do not understand how and why it works... it just look wrong like does not add up...."
                    },
                    {
                        "username": "lone17",
                        "content": "The hard part of this problem is that it\\'s label as hard, which makes people overthink and go for a dp solution. If this were medium or easy, people would properly come up with the solution faster."
                    },
                    {
                        "username": "Diean233",
                        "content": "Did not read carefully at first, thought that bag with only one marble has the score of that single weight, and wasted a lot of time thinking in the wrong direction...\\nIt is an interesting problem to solve."
                    },
                    {
                        "username": "feng3245",
                        "content": "Try this question instead.\\nYou have 2 marbles that must cost you from index 0 and n-1\\nYou want to find out the biggest difference you can get by picking n-1 pairs where each pair resulted from indexes of j and j-1 where j >= 0 and <= n-1"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Definitely an overrated question. Should be normal middle or difficult easy question. "
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "How to know its not a DP problem?"
                    },
                    {
                        "username": "dguerri",
                        "content": "\"Divide the marbles ...\"\\nshould be read as divide _all_ the marbles."
                    },
                    {
                        "username": "027_gurdeep",
                        "content": "class Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long>v;\\n        for(int i= 1; i <weights.size(); i++){\\n            v.push_back(weights[i-1]+weights[i]);\\n        }\\n        sort(v.begin(),v.end());\\n        k--;\\n        int left = 0, right = v.size()-1;\\n        long long ans = 0;\\n        while(k > 0){\\n            ans += v[right]-v[left];\\n            right--;\\n            left++;\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1961797,
                "content": [
                    {
                        "username": "Cristian16",
                        "content": "I have a question regarding my example: How is it possible the answer to be 28?\\nGiven: w = [1,9,8,7,1,1,1] and k = 3.\\nIt is impossible to obtain a maximum sum of 28, and even if you extract the minimum sum, it will be much lower.\\nI apologize if my English is not the best."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "Max score split is - 1 | 9 | 8 | 7,1,1,1. So sum will be on 1,1 , 9,9 , 8,8 , 7,1,1,1 which is 46."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "for minimum partiton  you can divide like [(1,9,8,7,1),(1),(1)] total minimum sum is [(1+1),(1+1),(1+1)] =6\\nfor max you can divide like [(1,9),(8),(7,1,1,1)] Total max sum is [(1+9),(8+8),(7+1)] which sums upto 34  \\nsince for cost we need to consider only boundary element\\n\\nSo we will get our difference 28 which is required answer  \\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "The tricky part in this questions is to find the pattern once you find the pattern it becomes easier. I myself headed over to the solution tab after trying this problem for half an hour and then found the pattern."
                    },
                    {
                        "username": "feng3245",
                        "content": "I got to the solution but somehow do not understand how and why it works... it just look wrong like does not add up...."
                    },
                    {
                        "username": "lone17",
                        "content": "The hard part of this problem is that it\\'s label as hard, which makes people overthink and go for a dp solution. If this were medium or easy, people would properly come up with the solution faster."
                    },
                    {
                        "username": "Diean233",
                        "content": "Did not read carefully at first, thought that bag with only one marble has the score of that single weight, and wasted a lot of time thinking in the wrong direction...\\nIt is an interesting problem to solve."
                    },
                    {
                        "username": "feng3245",
                        "content": "Try this question instead.\\nYou have 2 marbles that must cost you from index 0 and n-1\\nYou want to find out the biggest difference you can get by picking n-1 pairs where each pair resulted from indexes of j and j-1 where j >= 0 and <= n-1"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Definitely an overrated question. Should be normal middle or difficult easy question. "
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "How to know its not a DP problem?"
                    },
                    {
                        "username": "dguerri",
                        "content": "\"Divide the marbles ...\"\\nshould be read as divide _all_ the marbles."
                    },
                    {
                        "username": "027_gurdeep",
                        "content": "class Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long>v;\\n        for(int i= 1; i <weights.size(); i++){\\n            v.push_back(weights[i-1]+weights[i]);\\n        }\\n        sort(v.begin(),v.end());\\n        k--;\\n        int left = 0, right = v.size()-1;\\n        long long ans = 0;\\n        while(k > 0){\\n            ans += v[right]-v[left];\\n            right--;\\n            left++;\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1961779,
                "content": [
                    {
                        "username": "Cristian16",
                        "content": "I have a question regarding my example: How is it possible the answer to be 28?\\nGiven: w = [1,9,8,7,1,1,1] and k = 3.\\nIt is impossible to obtain a maximum sum of 28, and even if you extract the minimum sum, it will be much lower.\\nI apologize if my English is not the best."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "Max score split is - 1 | 9 | 8 | 7,1,1,1. So sum will be on 1,1 , 9,9 , 8,8 , 7,1,1,1 which is 46."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "for minimum partiton  you can divide like [(1,9,8,7,1),(1),(1)] total minimum sum is [(1+1),(1+1),(1+1)] =6\\nfor max you can divide like [(1,9),(8),(7,1,1,1)] Total max sum is [(1+9),(8+8),(7+1)] which sums upto 34  \\nsince for cost we need to consider only boundary element\\n\\nSo we will get our difference 28 which is required answer  \\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "The tricky part in this questions is to find the pattern once you find the pattern it becomes easier. I myself headed over to the solution tab after trying this problem for half an hour and then found the pattern."
                    },
                    {
                        "username": "feng3245",
                        "content": "I got to the solution but somehow do not understand how and why it works... it just look wrong like does not add up...."
                    },
                    {
                        "username": "lone17",
                        "content": "The hard part of this problem is that it\\'s label as hard, which makes people overthink and go for a dp solution. If this were medium or easy, people would properly come up with the solution faster."
                    },
                    {
                        "username": "Diean233",
                        "content": "Did not read carefully at first, thought that bag with only one marble has the score of that single weight, and wasted a lot of time thinking in the wrong direction...\\nIt is an interesting problem to solve."
                    },
                    {
                        "username": "feng3245",
                        "content": "Try this question instead.\\nYou have 2 marbles that must cost you from index 0 and n-1\\nYou want to find out the biggest difference you can get by picking n-1 pairs where each pair resulted from indexes of j and j-1 where j >= 0 and <= n-1"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Definitely an overrated question. Should be normal middle or difficult easy question. "
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "How to know its not a DP problem?"
                    },
                    {
                        "username": "dguerri",
                        "content": "\"Divide the marbles ...\"\\nshould be read as divide _all_ the marbles."
                    },
                    {
                        "username": "027_gurdeep",
                        "content": "class Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long>v;\\n        for(int i= 1; i <weights.size(); i++){\\n            v.push_back(weights[i-1]+weights[i]);\\n        }\\n        sort(v.begin(),v.end());\\n        k--;\\n        int left = 0, right = v.size()-1;\\n        long long ans = 0;\\n        while(k > 0){\\n            ans += v[right]-v[left];\\n            right--;\\n            left++;\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1961767,
                "content": [
                    {
                        "username": "Cristian16",
                        "content": "I have a question regarding my example: How is it possible the answer to be 28?\\nGiven: w = [1,9,8,7,1,1,1] and k = 3.\\nIt is impossible to obtain a maximum sum of 28, and even if you extract the minimum sum, it will be much lower.\\nI apologize if my English is not the best."
                    },
                    {
                        "username": "tinkerbeast",
                        "content": "Max score split is - 1 | 9 | 8 | 7,1,1,1. So sum will be on 1,1 , 9,9 , 8,8 , 7,1,1,1 which is 46."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "for minimum partiton  you can divide like [(1,9,8,7,1),(1),(1)] total minimum sum is [(1+1),(1+1),(1+1)] =6\\nfor max you can divide like [(1,9),(8),(7,1,1,1)] Total max sum is [(1+9),(8+8),(7+1)] which sums upto 34  \\nsince for cost we need to consider only boundary element\\n\\nSo we will get our difference 28 which is required answer  \\n"
                    },
                    {
                        "username": "mozasuvesh",
                        "content": "The tricky part in this questions is to find the pattern once you find the pattern it becomes easier. I myself headed over to the solution tab after trying this problem for half an hour and then found the pattern."
                    },
                    {
                        "username": "feng3245",
                        "content": "I got to the solution but somehow do not understand how and why it works... it just look wrong like does not add up...."
                    },
                    {
                        "username": "lone17",
                        "content": "The hard part of this problem is that it\\'s label as hard, which makes people overthink and go for a dp solution. If this were medium or easy, people would properly come up with the solution faster."
                    },
                    {
                        "username": "Diean233",
                        "content": "Did not read carefully at first, thought that bag with only one marble has the score of that single weight, and wasted a lot of time thinking in the wrong direction...\\nIt is an interesting problem to solve."
                    },
                    {
                        "username": "feng3245",
                        "content": "Try this question instead.\\nYou have 2 marbles that must cost you from index 0 and n-1\\nYou want to find out the biggest difference you can get by picking n-1 pairs where each pair resulted from indexes of j and j-1 where j >= 0 and <= n-1"
                    },
                    {
                        "username": "rauanktl",
                        "content": "Definitely an overrated question. Should be normal middle or difficult easy question. "
                    },
                    {
                        "username": "Anshika_0924",
                        "content": "How to know its not a DP problem?"
                    },
                    {
                        "username": "dguerri",
                        "content": "\"Divide the marbles ...\"\\nshould be read as divide _all_ the marbles."
                    },
                    {
                        "username": "027_gurdeep",
                        "content": "class Solution {\\npublic:\\n    long long putMarbles(vector<int>& weights, int k) {\\n        vector<long long>v;\\n        for(int i= 1; i <weights.size(); i++){\\n            v.push_back(weights[i-1]+weights[i]);\\n        }\\n        sort(v.begin(),v.end());\\n        k--;\\n        int left = 0, right = v.size()-1;\\n        long long ans = 0;\\n        while(k > 0){\\n            ans += v[right]-v[left];\\n            right--;\\n            left++;\\n            k--;\\n        }\\n        return ans;\\n    }\\n};\\n"
                    }
                ]
            },
            {
                "id": 1961730,
                "content": [
                    {
                        "username": "rahulsharmadev",
                        "content": "The algorithm calculates the difference between the maximum and minimum sums of adjacent marble weights in the bags.\n\n1. The algorithm begins by initializing variables:\n      -  `n` stores the length of the weights array.\n      - `pairs` is an array to store the sum of weights of adjacent marbles.\n2. The algorithm then enters a loop starting from `i = 1` to `n - 1`. For each iteration:\n      - It calculates the sum of weights of adjacent marbles by adding weights `[i]` and weights `[i - 1]`.\n      - The calculated sum is stored in the pairs array at index `i - 1`.\n3. After the loop, the pairs array is sorted in ascending order using `Arrays.sort()`.\n4. The algorithm initializes variables min and max to store the minimum and maximum sums, respectively.\n\n5. The algorithm enters another loop starting from `i = 0` to `k - 2`. For each iteration:\n      - It adds the `i`th element of the sorted pairs array to min.\n      - It adds the `(n - i - 2)`th element of the sorted pairs array to max.\nNote: `(n - i - 2)` is used as an index to access the elements in reverse order.\n\n6. Finally, the algorithm returns the difference between max and min, which represents the maximum difference between the sums of marble weights in different bags.\n\nThe algorithm aims to distribute the marbles among the bags in a way that minimizes the difference between the maximum and minimum sums of adjacent marble weights. By calculating the difference between the maximum and minimum sums, the algorithm provides an indication of how well the marbles are distributed across the bags.\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I used a heap and solved it after LOTS of hints and watching the intro of a solution video that gave a good intuition and was immediately able to implement it. It was still only 10% faster 💀. Looked at the faster solutions and it was so obvious. I think this problem's hardest part is figuring out its not DP and getting the base intuition for it"
                    },
                    {
                        "username": "Sanjay_00",
                        "content": "Don't think of how to make exactly k-1 cuts , just do max no. of cuts then compare/see which all cuts are making maximum sum and which cuts make minimum . \n\n\n\n\n\nFor this you can store max cut answer(explained below), and sort the vector to get sorted vector of all possible outputs with max (n-1) cuts . Thus as per our requirement (k) we find min and max of how many 'pair' we want.\n\nTill now not understood then you see for a particular cut what is sum as per question . Its start + end + (if cut is at i th position then ) weights[i]+weights[i+1].\nSince start and end are always added and we have to find difference so we can ignore then ( since they will be cancelled).\n\nAnd as per our requirement for min we find sum of first k element of sorted vector and for max we find sum of last k elements then return difference.\n\nSorted vector have possible sum of each cut in sorted order.\n\nPossible cut of ith cut = weights[i] + weights[i+1]\n\nif i=0 it means cut is between 0th and 1st position.\n\n\n"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Very standard problem but the problem description is worst. Should have been a bit more descriptive."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the question is hard by its description but the problem code if you see is a child."
                    },
                    {
                        "username": "hewy96",
                        "content": "ay your mom yea"
                    },
                    {
                        "username": "nvrushabhwalke",
                        "content": "Problem should have condition to use all marbles. what if i don\\'t want to put marble at 0th index in bag and i goes for another marble. In example 1: min is (1+1) + (1+3) but if i=j is possible then i can take min as (1+1) + (1+1), similarly for maximum i can take (3+3) + (5+5). But clearly it\\'s not the case.\\n\\nCan someone tell what am i getting wrong?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "One must use all marbles, because it says to \"divide the marbles\".\\ni = j is possible, though."
                    },
                    {
                        "username": "aman1320",
                        "content": "I didn\\'t even tried this problem with full intuition becuase of the label of \"hard\" elsewhere the problem is super easy!!"
                    },
                    {
                        "username": "shyam_poduval02",
                        "content": "Does anyone know why the sorting solutions are getting better runtime than the priority queue solutions? I thought using a priority queue makes it O(n) and using sorting makes it O(n*log(n))?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "priority queue take O(n) to heapify and O(log n) for each pop, and we have to pop k - 1 times for the min heap and max heap, so the implementation is O(2n + 2k\\*log(n))\ndepents on k it's not guaranteed to be faster than the editorial solution O(n*log(n) + 2k)\nfor example if k ≒ n they are the same, but the maintaining two heaps make twice the constant overhead"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Me : Yoooo Let\\'s go finally weekend lets solve some good leetcode problems..\\n Leetcode: I\\'m waiting bitch come.."
                    }
                ]
            },
            {
                "id": 1961638,
                "content": [
                    {
                        "username": "rahulsharmadev",
                        "content": "The algorithm calculates the difference between the maximum and minimum sums of adjacent marble weights in the bags.\n\n1. The algorithm begins by initializing variables:\n      -  `n` stores the length of the weights array.\n      - `pairs` is an array to store the sum of weights of adjacent marbles.\n2. The algorithm then enters a loop starting from `i = 1` to `n - 1`. For each iteration:\n      - It calculates the sum of weights of adjacent marbles by adding weights `[i]` and weights `[i - 1]`.\n      - The calculated sum is stored in the pairs array at index `i - 1`.\n3. After the loop, the pairs array is sorted in ascending order using `Arrays.sort()`.\n4. The algorithm initializes variables min and max to store the minimum and maximum sums, respectively.\n\n5. The algorithm enters another loop starting from `i = 0` to `k - 2`. For each iteration:\n      - It adds the `i`th element of the sorted pairs array to min.\n      - It adds the `(n - i - 2)`th element of the sorted pairs array to max.\nNote: `(n - i - 2)` is used as an index to access the elements in reverse order.\n\n6. Finally, the algorithm returns the difference between max and min, which represents the maximum difference between the sums of marble weights in different bags.\n\nThe algorithm aims to distribute the marbles among the bags in a way that minimizes the difference between the maximum and minimum sums of adjacent marble weights. By calculating the difference between the maximum and minimum sums, the algorithm provides an indication of how well the marbles are distributed across the bags.\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I used a heap and solved it after LOTS of hints and watching the intro of a solution video that gave a good intuition and was immediately able to implement it. It was still only 10% faster 💀. Looked at the faster solutions and it was so obvious. I think this problem's hardest part is figuring out its not DP and getting the base intuition for it"
                    },
                    {
                        "username": "Sanjay_00",
                        "content": "Don't think of how to make exactly k-1 cuts , just do max no. of cuts then compare/see which all cuts are making maximum sum and which cuts make minimum . \n\n\n\n\n\nFor this you can store max cut answer(explained below), and sort the vector to get sorted vector of all possible outputs with max (n-1) cuts . Thus as per our requirement (k) we find min and max of how many 'pair' we want.\n\nTill now not understood then you see for a particular cut what is sum as per question . Its start + end + (if cut is at i th position then ) weights[i]+weights[i+1].\nSince start and end are always added and we have to find difference so we can ignore then ( since they will be cancelled).\n\nAnd as per our requirement for min we find sum of first k element of sorted vector and for max we find sum of last k elements then return difference.\n\nSorted vector have possible sum of each cut in sorted order.\n\nPossible cut of ith cut = weights[i] + weights[i+1]\n\nif i=0 it means cut is between 0th and 1st position.\n\n\n"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Very standard problem but the problem description is worst. Should have been a bit more descriptive."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the question is hard by its description but the problem code if you see is a child."
                    },
                    {
                        "username": "hewy96",
                        "content": "ay your mom yea"
                    },
                    {
                        "username": "nvrushabhwalke",
                        "content": "Problem should have condition to use all marbles. what if i don\\'t want to put marble at 0th index in bag and i goes for another marble. In example 1: min is (1+1) + (1+3) but if i=j is possible then i can take min as (1+1) + (1+1), similarly for maximum i can take (3+3) + (5+5). But clearly it\\'s not the case.\\n\\nCan someone tell what am i getting wrong?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "One must use all marbles, because it says to \"divide the marbles\".\\ni = j is possible, though."
                    },
                    {
                        "username": "aman1320",
                        "content": "I didn\\'t even tried this problem with full intuition becuase of the label of \"hard\" elsewhere the problem is super easy!!"
                    },
                    {
                        "username": "shyam_poduval02",
                        "content": "Does anyone know why the sorting solutions are getting better runtime than the priority queue solutions? I thought using a priority queue makes it O(n) and using sorting makes it O(n*log(n))?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "priority queue take O(n) to heapify and O(log n) for each pop, and we have to pop k - 1 times for the min heap and max heap, so the implementation is O(2n + 2k\\*log(n))\ndepents on k it's not guaranteed to be faster than the editorial solution O(n*log(n) + 2k)\nfor example if k ≒ n they are the same, but the maintaining two heaps make twice the constant overhead"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Me : Yoooo Let\\'s go finally weekend lets solve some good leetcode problems..\\n Leetcode: I\\'m waiting bitch come.."
                    }
                ]
            },
            {
                "id": 1961607,
                "content": [
                    {
                        "username": "rahulsharmadev",
                        "content": "The algorithm calculates the difference between the maximum and minimum sums of adjacent marble weights in the bags.\n\n1. The algorithm begins by initializing variables:\n      -  `n` stores the length of the weights array.\n      - `pairs` is an array to store the sum of weights of adjacent marbles.\n2. The algorithm then enters a loop starting from `i = 1` to `n - 1`. For each iteration:\n      - It calculates the sum of weights of adjacent marbles by adding weights `[i]` and weights `[i - 1]`.\n      - The calculated sum is stored in the pairs array at index `i - 1`.\n3. After the loop, the pairs array is sorted in ascending order using `Arrays.sort()`.\n4. The algorithm initializes variables min and max to store the minimum and maximum sums, respectively.\n\n5. The algorithm enters another loop starting from `i = 0` to `k - 2`. For each iteration:\n      - It adds the `i`th element of the sorted pairs array to min.\n      - It adds the `(n - i - 2)`th element of the sorted pairs array to max.\nNote: `(n - i - 2)` is used as an index to access the elements in reverse order.\n\n6. Finally, the algorithm returns the difference between max and min, which represents the maximum difference between the sums of marble weights in different bags.\n\nThe algorithm aims to distribute the marbles among the bags in a way that minimizes the difference between the maximum and minimum sums of adjacent marble weights. By calculating the difference between the maximum and minimum sums, the algorithm provides an indication of how well the marbles are distributed across the bags.\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I used a heap and solved it after LOTS of hints and watching the intro of a solution video that gave a good intuition and was immediately able to implement it. It was still only 10% faster 💀. Looked at the faster solutions and it was so obvious. I think this problem's hardest part is figuring out its not DP and getting the base intuition for it"
                    },
                    {
                        "username": "Sanjay_00",
                        "content": "Don't think of how to make exactly k-1 cuts , just do max no. of cuts then compare/see which all cuts are making maximum sum and which cuts make minimum . \n\n\n\n\n\nFor this you can store max cut answer(explained below), and sort the vector to get sorted vector of all possible outputs with max (n-1) cuts . Thus as per our requirement (k) we find min and max of how many 'pair' we want.\n\nTill now not understood then you see for a particular cut what is sum as per question . Its start + end + (if cut is at i th position then ) weights[i]+weights[i+1].\nSince start and end are always added and we have to find difference so we can ignore then ( since they will be cancelled).\n\nAnd as per our requirement for min we find sum of first k element of sorted vector and for max we find sum of last k elements then return difference.\n\nSorted vector have possible sum of each cut in sorted order.\n\nPossible cut of ith cut = weights[i] + weights[i+1]\n\nif i=0 it means cut is between 0th and 1st position.\n\n\n"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Very standard problem but the problem description is worst. Should have been a bit more descriptive."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the question is hard by its description but the problem code if you see is a child."
                    },
                    {
                        "username": "hewy96",
                        "content": "ay your mom yea"
                    },
                    {
                        "username": "nvrushabhwalke",
                        "content": "Problem should have condition to use all marbles. what if i don\\'t want to put marble at 0th index in bag and i goes for another marble. In example 1: min is (1+1) + (1+3) but if i=j is possible then i can take min as (1+1) + (1+1), similarly for maximum i can take (3+3) + (5+5). But clearly it\\'s not the case.\\n\\nCan someone tell what am i getting wrong?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "One must use all marbles, because it says to \"divide the marbles\".\\ni = j is possible, though."
                    },
                    {
                        "username": "aman1320",
                        "content": "I didn\\'t even tried this problem with full intuition becuase of the label of \"hard\" elsewhere the problem is super easy!!"
                    },
                    {
                        "username": "shyam_poduval02",
                        "content": "Does anyone know why the sorting solutions are getting better runtime than the priority queue solutions? I thought using a priority queue makes it O(n) and using sorting makes it O(n*log(n))?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "priority queue take O(n) to heapify and O(log n) for each pop, and we have to pop k - 1 times for the min heap and max heap, so the implementation is O(2n + 2k\\*log(n))\ndepents on k it's not guaranteed to be faster than the editorial solution O(n*log(n) + 2k)\nfor example if k ≒ n they are the same, but the maintaining two heaps make twice the constant overhead"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Me : Yoooo Let\\'s go finally weekend lets solve some good leetcode problems..\\n Leetcode: I\\'m waiting bitch come.."
                    }
                ]
            },
            {
                "id": 1961250,
                "content": [
                    {
                        "username": "rahulsharmadev",
                        "content": "The algorithm calculates the difference between the maximum and minimum sums of adjacent marble weights in the bags.\n\n1. The algorithm begins by initializing variables:\n      -  `n` stores the length of the weights array.\n      - `pairs` is an array to store the sum of weights of adjacent marbles.\n2. The algorithm then enters a loop starting from `i = 1` to `n - 1`. For each iteration:\n      - It calculates the sum of weights of adjacent marbles by adding weights `[i]` and weights `[i - 1]`.\n      - The calculated sum is stored in the pairs array at index `i - 1`.\n3. After the loop, the pairs array is sorted in ascending order using `Arrays.sort()`.\n4. The algorithm initializes variables min and max to store the minimum and maximum sums, respectively.\n\n5. The algorithm enters another loop starting from `i = 0` to `k - 2`. For each iteration:\n      - It adds the `i`th element of the sorted pairs array to min.\n      - It adds the `(n - i - 2)`th element of the sorted pairs array to max.\nNote: `(n - i - 2)` is used as an index to access the elements in reverse order.\n\n6. Finally, the algorithm returns the difference between max and min, which represents the maximum difference between the sums of marble weights in different bags.\n\nThe algorithm aims to distribute the marbles among the bags in a way that minimizes the difference between the maximum and minimum sums of adjacent marble weights. By calculating the difference between the maximum and minimum sums, the algorithm provides an indication of how well the marbles are distributed across the bags.\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I used a heap and solved it after LOTS of hints and watching the intro of a solution video that gave a good intuition and was immediately able to implement it. It was still only 10% faster 💀. Looked at the faster solutions and it was so obvious. I think this problem's hardest part is figuring out its not DP and getting the base intuition for it"
                    },
                    {
                        "username": "Sanjay_00",
                        "content": "Don't think of how to make exactly k-1 cuts , just do max no. of cuts then compare/see which all cuts are making maximum sum and which cuts make minimum . \n\n\n\n\n\nFor this you can store max cut answer(explained below), and sort the vector to get sorted vector of all possible outputs with max (n-1) cuts . Thus as per our requirement (k) we find min and max of how many 'pair' we want.\n\nTill now not understood then you see for a particular cut what is sum as per question . Its start + end + (if cut is at i th position then ) weights[i]+weights[i+1].\nSince start and end are always added and we have to find difference so we can ignore then ( since they will be cancelled).\n\nAnd as per our requirement for min we find sum of first k element of sorted vector and for max we find sum of last k elements then return difference.\n\nSorted vector have possible sum of each cut in sorted order.\n\nPossible cut of ith cut = weights[i] + weights[i+1]\n\nif i=0 it means cut is between 0th and 1st position.\n\n\n"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Very standard problem but the problem description is worst. Should have been a bit more descriptive."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the question is hard by its description but the problem code if you see is a child."
                    },
                    {
                        "username": "hewy96",
                        "content": "ay your mom yea"
                    },
                    {
                        "username": "nvrushabhwalke",
                        "content": "Problem should have condition to use all marbles. what if i don\\'t want to put marble at 0th index in bag and i goes for another marble. In example 1: min is (1+1) + (1+3) but if i=j is possible then i can take min as (1+1) + (1+1), similarly for maximum i can take (3+3) + (5+5). But clearly it\\'s not the case.\\n\\nCan someone tell what am i getting wrong?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "One must use all marbles, because it says to \"divide the marbles\".\\ni = j is possible, though."
                    },
                    {
                        "username": "aman1320",
                        "content": "I didn\\'t even tried this problem with full intuition becuase of the label of \"hard\" elsewhere the problem is super easy!!"
                    },
                    {
                        "username": "shyam_poduval02",
                        "content": "Does anyone know why the sorting solutions are getting better runtime than the priority queue solutions? I thought using a priority queue makes it O(n) and using sorting makes it O(n*log(n))?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "priority queue take O(n) to heapify and O(log n) for each pop, and we have to pop k - 1 times for the min heap and max heap, so the implementation is O(2n + 2k\\*log(n))\ndepents on k it's not guaranteed to be faster than the editorial solution O(n*log(n) + 2k)\nfor example if k ≒ n they are the same, but the maintaining two heaps make twice the constant overhead"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Me : Yoooo Let\\'s go finally weekend lets solve some good leetcode problems..\\n Leetcode: I\\'m waiting bitch come.."
                    }
                ]
            },
            {
                "id": 1961225,
                "content": [
                    {
                        "username": "rahulsharmadev",
                        "content": "The algorithm calculates the difference between the maximum and minimum sums of adjacent marble weights in the bags.\n\n1. The algorithm begins by initializing variables:\n      -  `n` stores the length of the weights array.\n      - `pairs` is an array to store the sum of weights of adjacent marbles.\n2. The algorithm then enters a loop starting from `i = 1` to `n - 1`. For each iteration:\n      - It calculates the sum of weights of adjacent marbles by adding weights `[i]` and weights `[i - 1]`.\n      - The calculated sum is stored in the pairs array at index `i - 1`.\n3. After the loop, the pairs array is sorted in ascending order using `Arrays.sort()`.\n4. The algorithm initializes variables min and max to store the minimum and maximum sums, respectively.\n\n5. The algorithm enters another loop starting from `i = 0` to `k - 2`. For each iteration:\n      - It adds the `i`th element of the sorted pairs array to min.\n      - It adds the `(n - i - 2)`th element of the sorted pairs array to max.\nNote: `(n - i - 2)` is used as an index to access the elements in reverse order.\n\n6. Finally, the algorithm returns the difference between max and min, which represents the maximum difference between the sums of marble weights in different bags.\n\nThe algorithm aims to distribute the marbles among the bags in a way that minimizes the difference between the maximum and minimum sums of adjacent marble weights. By calculating the difference between the maximum and minimum sums, the algorithm provides an indication of how well the marbles are distributed across the bags.\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I used a heap and solved it after LOTS of hints and watching the intro of a solution video that gave a good intuition and was immediately able to implement it. It was still only 10% faster 💀. Looked at the faster solutions and it was so obvious. I think this problem's hardest part is figuring out its not DP and getting the base intuition for it"
                    },
                    {
                        "username": "Sanjay_00",
                        "content": "Don't think of how to make exactly k-1 cuts , just do max no. of cuts then compare/see which all cuts are making maximum sum and which cuts make minimum . \n\n\n\n\n\nFor this you can store max cut answer(explained below), and sort the vector to get sorted vector of all possible outputs with max (n-1) cuts . Thus as per our requirement (k) we find min and max of how many 'pair' we want.\n\nTill now not understood then you see for a particular cut what is sum as per question . Its start + end + (if cut is at i th position then ) weights[i]+weights[i+1].\nSince start and end are always added and we have to find difference so we can ignore then ( since they will be cancelled).\n\nAnd as per our requirement for min we find sum of first k element of sorted vector and for max we find sum of last k elements then return difference.\n\nSorted vector have possible sum of each cut in sorted order.\n\nPossible cut of ith cut = weights[i] + weights[i+1]\n\nif i=0 it means cut is between 0th and 1st position.\n\n\n"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Very standard problem but the problem description is worst. Should have been a bit more descriptive."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the question is hard by its description but the problem code if you see is a child."
                    },
                    {
                        "username": "hewy96",
                        "content": "ay your mom yea"
                    },
                    {
                        "username": "nvrushabhwalke",
                        "content": "Problem should have condition to use all marbles. what if i don\\'t want to put marble at 0th index in bag and i goes for another marble. In example 1: min is (1+1) + (1+3) but if i=j is possible then i can take min as (1+1) + (1+1), similarly for maximum i can take (3+3) + (5+5). But clearly it\\'s not the case.\\n\\nCan someone tell what am i getting wrong?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "One must use all marbles, because it says to \"divide the marbles\".\\ni = j is possible, though."
                    },
                    {
                        "username": "aman1320",
                        "content": "I didn\\'t even tried this problem with full intuition becuase of the label of \"hard\" elsewhere the problem is super easy!!"
                    },
                    {
                        "username": "shyam_poduval02",
                        "content": "Does anyone know why the sorting solutions are getting better runtime than the priority queue solutions? I thought using a priority queue makes it O(n) and using sorting makes it O(n*log(n))?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "priority queue take O(n) to heapify and O(log n) for each pop, and we have to pop k - 1 times for the min heap and max heap, so the implementation is O(2n + 2k\\*log(n))\ndepents on k it's not guaranteed to be faster than the editorial solution O(n*log(n) + 2k)\nfor example if k ≒ n they are the same, but the maintaining two heaps make twice the constant overhead"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Me : Yoooo Let\\'s go finally weekend lets solve some good leetcode problems..\\n Leetcode: I\\'m waiting bitch come.."
                    }
                ]
            },
            {
                "id": 1961148,
                "content": [
                    {
                        "username": "rahulsharmadev",
                        "content": "The algorithm calculates the difference between the maximum and minimum sums of adjacent marble weights in the bags.\n\n1. The algorithm begins by initializing variables:\n      -  `n` stores the length of the weights array.\n      - `pairs` is an array to store the sum of weights of adjacent marbles.\n2. The algorithm then enters a loop starting from `i = 1` to `n - 1`. For each iteration:\n      - It calculates the sum of weights of adjacent marbles by adding weights `[i]` and weights `[i - 1]`.\n      - The calculated sum is stored in the pairs array at index `i - 1`.\n3. After the loop, the pairs array is sorted in ascending order using `Arrays.sort()`.\n4. The algorithm initializes variables min and max to store the minimum and maximum sums, respectively.\n\n5. The algorithm enters another loop starting from `i = 0` to `k - 2`. For each iteration:\n      - It adds the `i`th element of the sorted pairs array to min.\n      - It adds the `(n - i - 2)`th element of the sorted pairs array to max.\nNote: `(n - i - 2)` is used as an index to access the elements in reverse order.\n\n6. Finally, the algorithm returns the difference between max and min, which represents the maximum difference between the sums of marble weights in different bags.\n\nThe algorithm aims to distribute the marbles among the bags in a way that minimizes the difference between the maximum and minimum sums of adjacent marble weights. By calculating the difference between the maximum and minimum sums, the algorithm provides an indication of how well the marbles are distributed across the bags.\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I used a heap and solved it after LOTS of hints and watching the intro of a solution video that gave a good intuition and was immediately able to implement it. It was still only 10% faster 💀. Looked at the faster solutions and it was so obvious. I think this problem's hardest part is figuring out its not DP and getting the base intuition for it"
                    },
                    {
                        "username": "Sanjay_00",
                        "content": "Don't think of how to make exactly k-1 cuts , just do max no. of cuts then compare/see which all cuts are making maximum sum and which cuts make minimum . \n\n\n\n\n\nFor this you can store max cut answer(explained below), and sort the vector to get sorted vector of all possible outputs with max (n-1) cuts . Thus as per our requirement (k) we find min and max of how many 'pair' we want.\n\nTill now not understood then you see for a particular cut what is sum as per question . Its start + end + (if cut is at i th position then ) weights[i]+weights[i+1].\nSince start and end are always added and we have to find difference so we can ignore then ( since they will be cancelled).\n\nAnd as per our requirement for min we find sum of first k element of sorted vector and for max we find sum of last k elements then return difference.\n\nSorted vector have possible sum of each cut in sorted order.\n\nPossible cut of ith cut = weights[i] + weights[i+1]\n\nif i=0 it means cut is between 0th and 1st position.\n\n\n"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Very standard problem but the problem description is worst. Should have been a bit more descriptive."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the question is hard by its description but the problem code if you see is a child."
                    },
                    {
                        "username": "hewy96",
                        "content": "ay your mom yea"
                    },
                    {
                        "username": "nvrushabhwalke",
                        "content": "Problem should have condition to use all marbles. what if i don\\'t want to put marble at 0th index in bag and i goes for another marble. In example 1: min is (1+1) + (1+3) but if i=j is possible then i can take min as (1+1) + (1+1), similarly for maximum i can take (3+3) + (5+5). But clearly it\\'s not the case.\\n\\nCan someone tell what am i getting wrong?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "One must use all marbles, because it says to \"divide the marbles\".\\ni = j is possible, though."
                    },
                    {
                        "username": "aman1320",
                        "content": "I didn\\'t even tried this problem with full intuition becuase of the label of \"hard\" elsewhere the problem is super easy!!"
                    },
                    {
                        "username": "shyam_poduval02",
                        "content": "Does anyone know why the sorting solutions are getting better runtime than the priority queue solutions? I thought using a priority queue makes it O(n) and using sorting makes it O(n*log(n))?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "priority queue take O(n) to heapify and O(log n) for each pop, and we have to pop k - 1 times for the min heap and max heap, so the implementation is O(2n + 2k\\*log(n))\ndepents on k it's not guaranteed to be faster than the editorial solution O(n*log(n) + 2k)\nfor example if k ≒ n they are the same, but the maintaining two heaps make twice the constant overhead"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Me : Yoooo Let\\'s go finally weekend lets solve some good leetcode problems..\\n Leetcode: I\\'m waiting bitch come.."
                    }
                ]
            },
            {
                "id": 1961126,
                "content": [
                    {
                        "username": "rahulsharmadev",
                        "content": "The algorithm calculates the difference between the maximum and minimum sums of adjacent marble weights in the bags.\n\n1. The algorithm begins by initializing variables:\n      -  `n` stores the length of the weights array.\n      - `pairs` is an array to store the sum of weights of adjacent marbles.\n2. The algorithm then enters a loop starting from `i = 1` to `n - 1`. For each iteration:\n      - It calculates the sum of weights of adjacent marbles by adding weights `[i]` and weights `[i - 1]`.\n      - The calculated sum is stored in the pairs array at index `i - 1`.\n3. After the loop, the pairs array is sorted in ascending order using `Arrays.sort()`.\n4. The algorithm initializes variables min and max to store the minimum and maximum sums, respectively.\n\n5. The algorithm enters another loop starting from `i = 0` to `k - 2`. For each iteration:\n      - It adds the `i`th element of the sorted pairs array to min.\n      - It adds the `(n - i - 2)`th element of the sorted pairs array to max.\nNote: `(n - i - 2)` is used as an index to access the elements in reverse order.\n\n6. Finally, the algorithm returns the difference between max and min, which represents the maximum difference between the sums of marble weights in different bags.\n\nThe algorithm aims to distribute the marbles among the bags in a way that minimizes the difference between the maximum and minimum sums of adjacent marble weights. By calculating the difference between the maximum and minimum sums, the algorithm provides an indication of how well the marbles are distributed across the bags.\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I used a heap and solved it after LOTS of hints and watching the intro of a solution video that gave a good intuition and was immediately able to implement it. It was still only 10% faster 💀. Looked at the faster solutions and it was so obvious. I think this problem's hardest part is figuring out its not DP and getting the base intuition for it"
                    },
                    {
                        "username": "Sanjay_00",
                        "content": "Don't think of how to make exactly k-1 cuts , just do max no. of cuts then compare/see which all cuts are making maximum sum and which cuts make minimum . \n\n\n\n\n\nFor this you can store max cut answer(explained below), and sort the vector to get sorted vector of all possible outputs with max (n-1) cuts . Thus as per our requirement (k) we find min and max of how many 'pair' we want.\n\nTill now not understood then you see for a particular cut what is sum as per question . Its start + end + (if cut is at i th position then ) weights[i]+weights[i+1].\nSince start and end are always added and we have to find difference so we can ignore then ( since they will be cancelled).\n\nAnd as per our requirement for min we find sum of first k element of sorted vector and for max we find sum of last k elements then return difference.\n\nSorted vector have possible sum of each cut in sorted order.\n\nPossible cut of ith cut = weights[i] + weights[i+1]\n\nif i=0 it means cut is between 0th and 1st position.\n\n\n"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Very standard problem but the problem description is worst. Should have been a bit more descriptive."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the question is hard by its description but the problem code if you see is a child."
                    },
                    {
                        "username": "hewy96",
                        "content": "ay your mom yea"
                    },
                    {
                        "username": "nvrushabhwalke",
                        "content": "Problem should have condition to use all marbles. what if i don\\'t want to put marble at 0th index in bag and i goes for another marble. In example 1: min is (1+1) + (1+3) but if i=j is possible then i can take min as (1+1) + (1+1), similarly for maximum i can take (3+3) + (5+5). But clearly it\\'s not the case.\\n\\nCan someone tell what am i getting wrong?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "One must use all marbles, because it says to \"divide the marbles\".\\ni = j is possible, though."
                    },
                    {
                        "username": "aman1320",
                        "content": "I didn\\'t even tried this problem with full intuition becuase of the label of \"hard\" elsewhere the problem is super easy!!"
                    },
                    {
                        "username": "shyam_poduval02",
                        "content": "Does anyone know why the sorting solutions are getting better runtime than the priority queue solutions? I thought using a priority queue makes it O(n) and using sorting makes it O(n*log(n))?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "priority queue take O(n) to heapify and O(log n) for each pop, and we have to pop k - 1 times for the min heap and max heap, so the implementation is O(2n + 2k\\*log(n))\ndepents on k it's not guaranteed to be faster than the editorial solution O(n*log(n) + 2k)\nfor example if k ≒ n they are the same, but the maintaining two heaps make twice the constant overhead"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Me : Yoooo Let\\'s go finally weekend lets solve some good leetcode problems..\\n Leetcode: I\\'m waiting bitch come.."
                    }
                ]
            },
            {
                "id": 1961122,
                "content": [
                    {
                        "username": "rahulsharmadev",
                        "content": "The algorithm calculates the difference between the maximum and minimum sums of adjacent marble weights in the bags.\n\n1. The algorithm begins by initializing variables:\n      -  `n` stores the length of the weights array.\n      - `pairs` is an array to store the sum of weights of adjacent marbles.\n2. The algorithm then enters a loop starting from `i = 1` to `n - 1`. For each iteration:\n      - It calculates the sum of weights of adjacent marbles by adding weights `[i]` and weights `[i - 1]`.\n      - The calculated sum is stored in the pairs array at index `i - 1`.\n3. After the loop, the pairs array is sorted in ascending order using `Arrays.sort()`.\n4. The algorithm initializes variables min and max to store the minimum and maximum sums, respectively.\n\n5. The algorithm enters another loop starting from `i = 0` to `k - 2`. For each iteration:\n      - It adds the `i`th element of the sorted pairs array to min.\n      - It adds the `(n - i - 2)`th element of the sorted pairs array to max.\nNote: `(n - i - 2)` is used as an index to access the elements in reverse order.\n\n6. Finally, the algorithm returns the difference between max and min, which represents the maximum difference between the sums of marble weights in different bags.\n\nThe algorithm aims to distribute the marbles among the bags in a way that minimizes the difference between the maximum and minimum sums of adjacent marble weights. By calculating the difference between the maximum and minimum sums, the algorithm provides an indication of how well the marbles are distributed across the bags.\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I used a heap and solved it after LOTS of hints and watching the intro of a solution video that gave a good intuition and was immediately able to implement it. It was still only 10% faster 💀. Looked at the faster solutions and it was so obvious. I think this problem's hardest part is figuring out its not DP and getting the base intuition for it"
                    },
                    {
                        "username": "Sanjay_00",
                        "content": "Don't think of how to make exactly k-1 cuts , just do max no. of cuts then compare/see which all cuts are making maximum sum and which cuts make minimum . \n\n\n\n\n\nFor this you can store max cut answer(explained below), and sort the vector to get sorted vector of all possible outputs with max (n-1) cuts . Thus as per our requirement (k) we find min and max of how many 'pair' we want.\n\nTill now not understood then you see for a particular cut what is sum as per question . Its start + end + (if cut is at i th position then ) weights[i]+weights[i+1].\nSince start and end are always added and we have to find difference so we can ignore then ( since they will be cancelled).\n\nAnd as per our requirement for min we find sum of first k element of sorted vector and for max we find sum of last k elements then return difference.\n\nSorted vector have possible sum of each cut in sorted order.\n\nPossible cut of ith cut = weights[i] + weights[i+1]\n\nif i=0 it means cut is between 0th and 1st position.\n\n\n"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Very standard problem but the problem description is worst. Should have been a bit more descriptive."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the question is hard by its description but the problem code if you see is a child."
                    },
                    {
                        "username": "hewy96",
                        "content": "ay your mom yea"
                    },
                    {
                        "username": "nvrushabhwalke",
                        "content": "Problem should have condition to use all marbles. what if i don\\'t want to put marble at 0th index in bag and i goes for another marble. In example 1: min is (1+1) + (1+3) but if i=j is possible then i can take min as (1+1) + (1+1), similarly for maximum i can take (3+3) + (5+5). But clearly it\\'s not the case.\\n\\nCan someone tell what am i getting wrong?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "One must use all marbles, because it says to \"divide the marbles\".\\ni = j is possible, though."
                    },
                    {
                        "username": "aman1320",
                        "content": "I didn\\'t even tried this problem with full intuition becuase of the label of \"hard\" elsewhere the problem is super easy!!"
                    },
                    {
                        "username": "shyam_poduval02",
                        "content": "Does anyone know why the sorting solutions are getting better runtime than the priority queue solutions? I thought using a priority queue makes it O(n) and using sorting makes it O(n*log(n))?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "priority queue take O(n) to heapify and O(log n) for each pop, and we have to pop k - 1 times for the min heap and max heap, so the implementation is O(2n + 2k\\*log(n))\ndepents on k it's not guaranteed to be faster than the editorial solution O(n*log(n) + 2k)\nfor example if k ≒ n they are the same, but the maintaining two heaps make twice the constant overhead"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Me : Yoooo Let\\'s go finally weekend lets solve some good leetcode problems..\\n Leetcode: I\\'m waiting bitch come.."
                    }
                ]
            },
            {
                "id": 1961119,
                "content": [
                    {
                        "username": "rahulsharmadev",
                        "content": "The algorithm calculates the difference between the maximum and minimum sums of adjacent marble weights in the bags.\n\n1. The algorithm begins by initializing variables:\n      -  `n` stores the length of the weights array.\n      - `pairs` is an array to store the sum of weights of adjacent marbles.\n2. The algorithm then enters a loop starting from `i = 1` to `n - 1`. For each iteration:\n      - It calculates the sum of weights of adjacent marbles by adding weights `[i]` and weights `[i - 1]`.\n      - The calculated sum is stored in the pairs array at index `i - 1`.\n3. After the loop, the pairs array is sorted in ascending order using `Arrays.sort()`.\n4. The algorithm initializes variables min and max to store the minimum and maximum sums, respectively.\n\n5. The algorithm enters another loop starting from `i = 0` to `k - 2`. For each iteration:\n      - It adds the `i`th element of the sorted pairs array to min.\n      - It adds the `(n - i - 2)`th element of the sorted pairs array to max.\nNote: `(n - i - 2)` is used as an index to access the elements in reverse order.\n\n6. Finally, the algorithm returns the difference between max and min, which represents the maximum difference between the sums of marble weights in different bags.\n\nThe algorithm aims to distribute the marbles among the bags in a way that minimizes the difference between the maximum and minimum sums of adjacent marble weights. By calculating the difference between the maximum and minimum sums, the algorithm provides an indication of how well the marbles are distributed across the bags.\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I used a heap and solved it after LOTS of hints and watching the intro of a solution video that gave a good intuition and was immediately able to implement it. It was still only 10% faster 💀. Looked at the faster solutions and it was so obvious. I think this problem's hardest part is figuring out its not DP and getting the base intuition for it"
                    },
                    {
                        "username": "Sanjay_00",
                        "content": "Don't think of how to make exactly k-1 cuts , just do max no. of cuts then compare/see which all cuts are making maximum sum and which cuts make minimum . \n\n\n\n\n\nFor this you can store max cut answer(explained below), and sort the vector to get sorted vector of all possible outputs with max (n-1) cuts . Thus as per our requirement (k) we find min and max of how many 'pair' we want.\n\nTill now not understood then you see for a particular cut what is sum as per question . Its start + end + (if cut is at i th position then ) weights[i]+weights[i+1].\nSince start and end are always added and we have to find difference so we can ignore then ( since they will be cancelled).\n\nAnd as per our requirement for min we find sum of first k element of sorted vector and for max we find sum of last k elements then return difference.\n\nSorted vector have possible sum of each cut in sorted order.\n\nPossible cut of ith cut = weights[i] + weights[i+1]\n\nif i=0 it means cut is between 0th and 1st position.\n\n\n"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Very standard problem but the problem description is worst. Should have been a bit more descriptive."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the question is hard by its description but the problem code if you see is a child."
                    },
                    {
                        "username": "hewy96",
                        "content": "ay your mom yea"
                    },
                    {
                        "username": "nvrushabhwalke",
                        "content": "Problem should have condition to use all marbles. what if i don\\'t want to put marble at 0th index in bag and i goes for another marble. In example 1: min is (1+1) + (1+3) but if i=j is possible then i can take min as (1+1) + (1+1), similarly for maximum i can take (3+3) + (5+5). But clearly it\\'s not the case.\\n\\nCan someone tell what am i getting wrong?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "One must use all marbles, because it says to \"divide the marbles\".\\ni = j is possible, though."
                    },
                    {
                        "username": "aman1320",
                        "content": "I didn\\'t even tried this problem with full intuition becuase of the label of \"hard\" elsewhere the problem is super easy!!"
                    },
                    {
                        "username": "shyam_poduval02",
                        "content": "Does anyone know why the sorting solutions are getting better runtime than the priority queue solutions? I thought using a priority queue makes it O(n) and using sorting makes it O(n*log(n))?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "priority queue take O(n) to heapify and O(log n) for each pop, and we have to pop k - 1 times for the min heap and max heap, so the implementation is O(2n + 2k\\*log(n))\ndepents on k it's not guaranteed to be faster than the editorial solution O(n*log(n) + 2k)\nfor example if k ≒ n they are the same, but the maintaining two heaps make twice the constant overhead"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Me : Yoooo Let\\'s go finally weekend lets solve some good leetcode problems..\\n Leetcode: I\\'m waiting bitch come.."
                    }
                ]
            },
            {
                "id": 1961108,
                "content": [
                    {
                        "username": "rahulsharmadev",
                        "content": "The algorithm calculates the difference between the maximum and minimum sums of adjacent marble weights in the bags.\n\n1. The algorithm begins by initializing variables:\n      -  `n` stores the length of the weights array.\n      - `pairs` is an array to store the sum of weights of adjacent marbles.\n2. The algorithm then enters a loop starting from `i = 1` to `n - 1`. For each iteration:\n      - It calculates the sum of weights of adjacent marbles by adding weights `[i]` and weights `[i - 1]`.\n      - The calculated sum is stored in the pairs array at index `i - 1`.\n3. After the loop, the pairs array is sorted in ascending order using `Arrays.sort()`.\n4. The algorithm initializes variables min and max to store the minimum and maximum sums, respectively.\n\n5. The algorithm enters another loop starting from `i = 0` to `k - 2`. For each iteration:\n      - It adds the `i`th element of the sorted pairs array to min.\n      - It adds the `(n - i - 2)`th element of the sorted pairs array to max.\nNote: `(n - i - 2)` is used as an index to access the elements in reverse order.\n\n6. Finally, the algorithm returns the difference between max and min, which represents the maximum difference between the sums of marble weights in different bags.\n\nThe algorithm aims to distribute the marbles among the bags in a way that minimizes the difference between the maximum and minimum sums of adjacent marble weights. By calculating the difference between the maximum and minimum sums, the algorithm provides an indication of how well the marbles are distributed across the bags.\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "I used a heap and solved it after LOTS of hints and watching the intro of a solution video that gave a good intuition and was immediately able to implement it. It was still only 10% faster 💀. Looked at the faster solutions and it was so obvious. I think this problem's hardest part is figuring out its not DP and getting the base intuition for it"
                    },
                    {
                        "username": "Sanjay_00",
                        "content": "Don't think of how to make exactly k-1 cuts , just do max no. of cuts then compare/see which all cuts are making maximum sum and which cuts make minimum . \n\n\n\n\n\nFor this you can store max cut answer(explained below), and sort the vector to get sorted vector of all possible outputs with max (n-1) cuts . Thus as per our requirement (k) we find min and max of how many 'pair' we want.\n\nTill now not understood then you see for a particular cut what is sum as per question . Its start + end + (if cut is at i th position then ) weights[i]+weights[i+1].\nSince start and end are always added and we have to find difference so we can ignore then ( since they will be cancelled).\n\nAnd as per our requirement for min we find sum of first k element of sorted vector and for max we find sum of last k elements then return difference.\n\nSorted vector have possible sum of each cut in sorted order.\n\nPossible cut of ith cut = weights[i] + weights[i+1]\n\nif i=0 it means cut is between 0th and 1st position.\n\n\n"
                    },
                    {
                        "username": "aiyappa18",
                        "content": "Very standard problem but the problem description is worst. Should have been a bit more descriptive."
                    },
                    {
                        "username": "Jackson-Kujur",
                        "content": "the question is hard by its description but the problem code if you see is a child."
                    },
                    {
                        "username": "hewy96",
                        "content": "ay your mom yea"
                    },
                    {
                        "username": "nvrushabhwalke",
                        "content": "Problem should have condition to use all marbles. what if i don\\'t want to put marble at 0th index in bag and i goes for another marble. In example 1: min is (1+1) + (1+3) but if i=j is possible then i can take min as (1+1) + (1+1), similarly for maximum i can take (3+3) + (5+5). But clearly it\\'s not the case.\\n\\nCan someone tell what am i getting wrong?"
                    },
                    {
                        "username": "manifold1985",
                        "content": "One must use all marbles, because it says to \"divide the marbles\".\\ni = j is possible, though."
                    },
                    {
                        "username": "aman1320",
                        "content": "I didn\\'t even tried this problem with full intuition becuase of the label of \"hard\" elsewhere the problem is super easy!!"
                    },
                    {
                        "username": "shyam_poduval02",
                        "content": "Does anyone know why the sorting solutions are getting better runtime than the priority queue solutions? I thought using a priority queue makes it O(n) and using sorting makes it O(n*log(n))?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "priority queue take O(n) to heapify and O(log n) for each pop, and we have to pop k - 1 times for the min heap and max heap, so the implementation is O(2n + 2k\\*log(n))\ndepents on k it's not guaranteed to be faster than the editorial solution O(n*log(n) + 2k)\nfor example if k ≒ n they are the same, but the maintaining two heaps make twice the constant overhead"
                    },
                    {
                        "username": "misba_shoeib",
                        "content": "Me : Yoooo Let\\'s go finally weekend lets solve some good leetcode problems..\\n Leetcode: I\\'m waiting bitch come.."
                    }
                ]
            },
            {
                "id": 1961106,
                "content": [
                    {
                        "username": "user0999B",
                        "content": "1. divide n marbles into k bags means there are k-1 \\u2018cuts\\u2019 of array\\n2. For a \\u2018cut\\u2019 between marble i and i+1. The score of the \\u2018cut\\u2019 is weight[i]+weight[i+1]\\n3. the total score of particular ways of division = first marble weight+ last marble weight + every score of \\u2018cut\\u2019\\n4. calculate all n-1 score among n marbles, sort in ascending order. \\n5. The difference between the sum of last k-1 score and the sum of first k-1 score is the answer\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why I found greedy more difficult than DP"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Because it is"
                    },
                    {
                        "username": "Saphal",
                        "content": " `long long solve1(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[index]+wt[wt.size()-1];\\n        }\\n\\n        long long maxi_ans=INT_MIN;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans += (wt[s]+wt[i]) + solve1(i+1,i+1,k,cnt+1,wt);\\n            maxi_ans=max(maxi_ans,ans);\\n        }\\n\\n        return maxi_ans;\\n    }\\n\\n     long long solve2(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[s]+wt[wt.size()-1];\\n        }\\n\\n        long long mini_ans=INT_MAX;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans+= (wt[s]+wt[i]) + solve2(s+1,i+1,k,cnt+1,wt);\\n            mini_ans=min(mini_ans,ans);\\n        }\\n\\n        return mini_ans;\\n    }\\n    \\n    long long putMarbles(vector<int>& weights, int k) {\\n        k=k-1;\\n        long long maxiAns = solve1(0,0,k,0,weights);\\n        long long miniAns = solve2(0,0,k,0,weights);\\n\\n        cout<<maxiAns<<\\' \\'<<miniAns;\\n        return miniAns;\\n    }`\\n\\nHelp me what\\'s wrong with this dp?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp won\\'t be fast enough for the time limit"
                    },
                    {
                        "username": "dranZerKai",
                        "content": "This should be a medium level question.\nSimilar Question\n(https://codeforces.com/contest/1847/problem/A)"
                    },
                    {
                        "username": "charonme",
                        "content": "Wow, beautiful! If this was labeled \"easy\" I wouldn\\'t even question it, but I\\'d probably have much less satisfaction from the solution.\\n\\nspoiler tips: (hey leetcode, we need a spoiler tag!)\\n1) we\\'re adding the division start and end items to get the min sum and the max sum and they always come in consecutive pairs (end of previous division, start of next division)\\n2) both the min and max sums of all the start and end items always include the first and last weights and they get subtracted from each other at the end, so we can completely ignore those and only consider k-1 pairs of start and end points\\n3) there are n-1 possible pairs to consider and to get the min we need to sum k-1 of the smallest pairs and to get the max we need to sum k-1 of the largest pairs"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Constraints My god"
                    },
                    {
                        "username": "namerror",
                        "content": "This is really interesting. At first glance I also thought it was dp too. Then I was stuck for about half an hour until I looked at the titles of some solutions and immediately realized that I was on the wrong track.\\n\\nAs long as you know it\\'s not dp, it becomes pretty easy to solve."
                    },
                    {
                        "username": "gloom007",
                        "content": "1. As When we pick the ith and jth marble we have to pick all the marbles in the range as well [i...j]\\n2. as no bags can be empty so we have to divide the array in k-1 patitions so that we\\'ll get k subarrays.\\n3. As the score for a sub-array is defined as the W[startIdx] + W[endIdx], so we only care of borders of the subarray.\\n4. if we paritition the sub array at ith index it will increase the score by W[i] + W[i+1]\\n  4.1 In Case of minScore we want to choose min K partition scores.\\n  4.2 In Case of maxScore we want to choose max K partition scores.\\n5. and finally take diff b/w calculated max and min score which will be the result."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is a nice problem, but it becomes even more interesting if we add another constraint, that is `no bag can contain exactly one marble`.\n\nNow the convenience that we were enjoying earlier is all gone as, now if we have chosen $$i$$ and $$i+1$$ indices for $$MaxScore$$ then we can no longer choose $$i+1$$ and $$i+2$$ indices for the same. I don't know the solution yet, but would love to have constructive inputs from the community.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Adding a constraint that no bag can contain exactly one marble does indeed make this problem more complex. It introduces a new dependency in our decisions - if we choose to make a bag using marbles i and i+1, we can\\'t then create another bag with i+1 and i+2. This is because the marble at index i+1 would already be in a bag.\\n\\nWith this additional constraint, the problem becomes a variant of the Interval Scheduling problem, which is typically solved using dynamic programming or greedy algorithms. The Interval Scheduling problem asks for the maximum number of non-overlapping intervals (or in this case, bags) that can be selected. \\n\\nHowever, there\\'s a difference in your problem - we\\'re not trying to maximize the number of bags (it\\'s fixed to k), but instead the difference between the maximum and minimum total weights of the bags. \\n\\nA possible approach might be to first sort all pairs of adjacent marbles by their total weights. Then, apply a modified Interval Scheduling algorithm, but instead of always choosing the next available bag with the earliest end, you could try to make a decision based on the potential impact on the max-min difference. \\n\\nYou\\'d also need to update your definition of \"overlapping\" - now two bags overlap if they share a marble, not just if their ranges overlap.\\n\\nThis would certainly be more complex than the original problem, and might require a more sophisticated data structure to track the potential bags and their overlaps efficiently. It would be a fun challenge though! \\n\\nAs always, you should start by clearly defining the problem and any constraints, and then work through some examples by hand to see if you can spot any patterns or insights that might lead to an algorithm."
                    },
                    {
                        "username": "Kaltu",
                        "content": "then I guess it would require O(n^2) solution because look like it becomes a dp or backtracking problem and the time limit or the constraints on the input should be adjusted"
                    },
                    {
                        "username": "ghanshyamvns7",
                        "content": "I did, however, copy it from the editorial. I discovered that the question was not up to the Hard level after reading and comprehending its prerequisites.\\nWhat say you?\\nComment.\\nhttps://leetcode.com/problems/put-marbles-in-bags/\\nThe URL to my answer is pasted below; if any of you have a better idea, please leave a comment.\\n\\nThank You @"
                    }
                ]
            },
            {
                "id": 1961003,
                "content": [
                    {
                        "username": "user0999B",
                        "content": "1. divide n marbles into k bags means there are k-1 \\u2018cuts\\u2019 of array\\n2. For a \\u2018cut\\u2019 between marble i and i+1. The score of the \\u2018cut\\u2019 is weight[i]+weight[i+1]\\n3. the total score of particular ways of division = first marble weight+ last marble weight + every score of \\u2018cut\\u2019\\n4. calculate all n-1 score among n marbles, sort in ascending order. \\n5. The difference between the sum of last k-1 score and the sum of first k-1 score is the answer\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why I found greedy more difficult than DP"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Because it is"
                    },
                    {
                        "username": "Saphal",
                        "content": " `long long solve1(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[index]+wt[wt.size()-1];\\n        }\\n\\n        long long maxi_ans=INT_MIN;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans += (wt[s]+wt[i]) + solve1(i+1,i+1,k,cnt+1,wt);\\n            maxi_ans=max(maxi_ans,ans);\\n        }\\n\\n        return maxi_ans;\\n    }\\n\\n     long long solve2(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[s]+wt[wt.size()-1];\\n        }\\n\\n        long long mini_ans=INT_MAX;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans+= (wt[s]+wt[i]) + solve2(s+1,i+1,k,cnt+1,wt);\\n            mini_ans=min(mini_ans,ans);\\n        }\\n\\n        return mini_ans;\\n    }\\n    \\n    long long putMarbles(vector<int>& weights, int k) {\\n        k=k-1;\\n        long long maxiAns = solve1(0,0,k,0,weights);\\n        long long miniAns = solve2(0,0,k,0,weights);\\n\\n        cout<<maxiAns<<\\' \\'<<miniAns;\\n        return miniAns;\\n    }`\\n\\nHelp me what\\'s wrong with this dp?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp won\\'t be fast enough for the time limit"
                    },
                    {
                        "username": "dranZerKai",
                        "content": "This should be a medium level question.\nSimilar Question\n(https://codeforces.com/contest/1847/problem/A)"
                    },
                    {
                        "username": "charonme",
                        "content": "Wow, beautiful! If this was labeled \"easy\" I wouldn\\'t even question it, but I\\'d probably have much less satisfaction from the solution.\\n\\nspoiler tips: (hey leetcode, we need a spoiler tag!)\\n1) we\\'re adding the division start and end items to get the min sum and the max sum and they always come in consecutive pairs (end of previous division, start of next division)\\n2) both the min and max sums of all the start and end items always include the first and last weights and they get subtracted from each other at the end, so we can completely ignore those and only consider k-1 pairs of start and end points\\n3) there are n-1 possible pairs to consider and to get the min we need to sum k-1 of the smallest pairs and to get the max we need to sum k-1 of the largest pairs"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Constraints My god"
                    },
                    {
                        "username": "namerror",
                        "content": "This is really interesting. At first glance I also thought it was dp too. Then I was stuck for about half an hour until I looked at the titles of some solutions and immediately realized that I was on the wrong track.\\n\\nAs long as you know it\\'s not dp, it becomes pretty easy to solve."
                    },
                    {
                        "username": "gloom007",
                        "content": "1. As When we pick the ith and jth marble we have to pick all the marbles in the range as well [i...j]\\n2. as no bags can be empty so we have to divide the array in k-1 patitions so that we\\'ll get k subarrays.\\n3. As the score for a sub-array is defined as the W[startIdx] + W[endIdx], so we only care of borders of the subarray.\\n4. if we paritition the sub array at ith index it will increase the score by W[i] + W[i+1]\\n  4.1 In Case of minScore we want to choose min K partition scores.\\n  4.2 In Case of maxScore we want to choose max K partition scores.\\n5. and finally take diff b/w calculated max and min score which will be the result."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is a nice problem, but it becomes even more interesting if we add another constraint, that is `no bag can contain exactly one marble`.\n\nNow the convenience that we were enjoying earlier is all gone as, now if we have chosen $$i$$ and $$i+1$$ indices for $$MaxScore$$ then we can no longer choose $$i+1$$ and $$i+2$$ indices for the same. I don't know the solution yet, but would love to have constructive inputs from the community.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Adding a constraint that no bag can contain exactly one marble does indeed make this problem more complex. It introduces a new dependency in our decisions - if we choose to make a bag using marbles i and i+1, we can\\'t then create another bag with i+1 and i+2. This is because the marble at index i+1 would already be in a bag.\\n\\nWith this additional constraint, the problem becomes a variant of the Interval Scheduling problem, which is typically solved using dynamic programming or greedy algorithms. The Interval Scheduling problem asks for the maximum number of non-overlapping intervals (or in this case, bags) that can be selected. \\n\\nHowever, there\\'s a difference in your problem - we\\'re not trying to maximize the number of bags (it\\'s fixed to k), but instead the difference between the maximum and minimum total weights of the bags. \\n\\nA possible approach might be to first sort all pairs of adjacent marbles by their total weights. Then, apply a modified Interval Scheduling algorithm, but instead of always choosing the next available bag with the earliest end, you could try to make a decision based on the potential impact on the max-min difference. \\n\\nYou\\'d also need to update your definition of \"overlapping\" - now two bags overlap if they share a marble, not just if their ranges overlap.\\n\\nThis would certainly be more complex than the original problem, and might require a more sophisticated data structure to track the potential bags and their overlaps efficiently. It would be a fun challenge though! \\n\\nAs always, you should start by clearly defining the problem and any constraints, and then work through some examples by hand to see if you can spot any patterns or insights that might lead to an algorithm."
                    },
                    {
                        "username": "Kaltu",
                        "content": "then I guess it would require O(n^2) solution because look like it becomes a dp or backtracking problem and the time limit or the constraints on the input should be adjusted"
                    },
                    {
                        "username": "ghanshyamvns7",
                        "content": "I did, however, copy it from the editorial. I discovered that the question was not up to the Hard level after reading and comprehending its prerequisites.\\nWhat say you?\\nComment.\\nhttps://leetcode.com/problems/put-marbles-in-bags/\\nThe URL to my answer is pasted below; if any of you have a better idea, please leave a comment.\\n\\nThank You @"
                    }
                ]
            },
            {
                "id": 1960900,
                "content": [
                    {
                        "username": "user0999B",
                        "content": "1. divide n marbles into k bags means there are k-1 \\u2018cuts\\u2019 of array\\n2. For a \\u2018cut\\u2019 between marble i and i+1. The score of the \\u2018cut\\u2019 is weight[i]+weight[i+1]\\n3. the total score of particular ways of division = first marble weight+ last marble weight + every score of \\u2018cut\\u2019\\n4. calculate all n-1 score among n marbles, sort in ascending order. \\n5. The difference between the sum of last k-1 score and the sum of first k-1 score is the answer\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why I found greedy more difficult than DP"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Because it is"
                    },
                    {
                        "username": "Saphal",
                        "content": " `long long solve1(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[index]+wt[wt.size()-1];\\n        }\\n\\n        long long maxi_ans=INT_MIN;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans += (wt[s]+wt[i]) + solve1(i+1,i+1,k,cnt+1,wt);\\n            maxi_ans=max(maxi_ans,ans);\\n        }\\n\\n        return maxi_ans;\\n    }\\n\\n     long long solve2(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[s]+wt[wt.size()-1];\\n        }\\n\\n        long long mini_ans=INT_MAX;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans+= (wt[s]+wt[i]) + solve2(s+1,i+1,k,cnt+1,wt);\\n            mini_ans=min(mini_ans,ans);\\n        }\\n\\n        return mini_ans;\\n    }\\n    \\n    long long putMarbles(vector<int>& weights, int k) {\\n        k=k-1;\\n        long long maxiAns = solve1(0,0,k,0,weights);\\n        long long miniAns = solve2(0,0,k,0,weights);\\n\\n        cout<<maxiAns<<\\' \\'<<miniAns;\\n        return miniAns;\\n    }`\\n\\nHelp me what\\'s wrong with this dp?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp won\\'t be fast enough for the time limit"
                    },
                    {
                        "username": "dranZerKai",
                        "content": "This should be a medium level question.\nSimilar Question\n(https://codeforces.com/contest/1847/problem/A)"
                    },
                    {
                        "username": "charonme",
                        "content": "Wow, beautiful! If this was labeled \"easy\" I wouldn\\'t even question it, but I\\'d probably have much less satisfaction from the solution.\\n\\nspoiler tips: (hey leetcode, we need a spoiler tag!)\\n1) we\\'re adding the division start and end items to get the min sum and the max sum and they always come in consecutive pairs (end of previous division, start of next division)\\n2) both the min and max sums of all the start and end items always include the first and last weights and they get subtracted from each other at the end, so we can completely ignore those and only consider k-1 pairs of start and end points\\n3) there are n-1 possible pairs to consider and to get the min we need to sum k-1 of the smallest pairs and to get the max we need to sum k-1 of the largest pairs"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Constraints My god"
                    },
                    {
                        "username": "namerror",
                        "content": "This is really interesting. At first glance I also thought it was dp too. Then I was stuck for about half an hour until I looked at the titles of some solutions and immediately realized that I was on the wrong track.\\n\\nAs long as you know it\\'s not dp, it becomes pretty easy to solve."
                    },
                    {
                        "username": "gloom007",
                        "content": "1. As When we pick the ith and jth marble we have to pick all the marbles in the range as well [i...j]\\n2. as no bags can be empty so we have to divide the array in k-1 patitions so that we\\'ll get k subarrays.\\n3. As the score for a sub-array is defined as the W[startIdx] + W[endIdx], so we only care of borders of the subarray.\\n4. if we paritition the sub array at ith index it will increase the score by W[i] + W[i+1]\\n  4.1 In Case of minScore we want to choose min K partition scores.\\n  4.2 In Case of maxScore we want to choose max K partition scores.\\n5. and finally take diff b/w calculated max and min score which will be the result."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is a nice problem, but it becomes even more interesting if we add another constraint, that is `no bag can contain exactly one marble`.\n\nNow the convenience that we were enjoying earlier is all gone as, now if we have chosen $$i$$ and $$i+1$$ indices for $$MaxScore$$ then we can no longer choose $$i+1$$ and $$i+2$$ indices for the same. I don't know the solution yet, but would love to have constructive inputs from the community.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Adding a constraint that no bag can contain exactly one marble does indeed make this problem more complex. It introduces a new dependency in our decisions - if we choose to make a bag using marbles i and i+1, we can\\'t then create another bag with i+1 and i+2. This is because the marble at index i+1 would already be in a bag.\\n\\nWith this additional constraint, the problem becomes a variant of the Interval Scheduling problem, which is typically solved using dynamic programming or greedy algorithms. The Interval Scheduling problem asks for the maximum number of non-overlapping intervals (or in this case, bags) that can be selected. \\n\\nHowever, there\\'s a difference in your problem - we\\'re not trying to maximize the number of bags (it\\'s fixed to k), but instead the difference between the maximum and minimum total weights of the bags. \\n\\nA possible approach might be to first sort all pairs of adjacent marbles by their total weights. Then, apply a modified Interval Scheduling algorithm, but instead of always choosing the next available bag with the earliest end, you could try to make a decision based on the potential impact on the max-min difference. \\n\\nYou\\'d also need to update your definition of \"overlapping\" - now two bags overlap if they share a marble, not just if their ranges overlap.\\n\\nThis would certainly be more complex than the original problem, and might require a more sophisticated data structure to track the potential bags and their overlaps efficiently. It would be a fun challenge though! \\n\\nAs always, you should start by clearly defining the problem and any constraints, and then work through some examples by hand to see if you can spot any patterns or insights that might lead to an algorithm."
                    },
                    {
                        "username": "Kaltu",
                        "content": "then I guess it would require O(n^2) solution because look like it becomes a dp or backtracking problem and the time limit or the constraints on the input should be adjusted"
                    },
                    {
                        "username": "ghanshyamvns7",
                        "content": "I did, however, copy it from the editorial. I discovered that the question was not up to the Hard level after reading and comprehending its prerequisites.\\nWhat say you?\\nComment.\\nhttps://leetcode.com/problems/put-marbles-in-bags/\\nThe URL to my answer is pasted below; if any of you have a better idea, please leave a comment.\\n\\nThank You @"
                    }
                ]
            },
            {
                "id": 1960851,
                "content": [
                    {
                        "username": "user0999B",
                        "content": "1. divide n marbles into k bags means there are k-1 \\u2018cuts\\u2019 of array\\n2. For a \\u2018cut\\u2019 between marble i and i+1. The score of the \\u2018cut\\u2019 is weight[i]+weight[i+1]\\n3. the total score of particular ways of division = first marble weight+ last marble weight + every score of \\u2018cut\\u2019\\n4. calculate all n-1 score among n marbles, sort in ascending order. \\n5. The difference between the sum of last k-1 score and the sum of first k-1 score is the answer\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why I found greedy more difficult than DP"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Because it is"
                    },
                    {
                        "username": "Saphal",
                        "content": " `long long solve1(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[index]+wt[wt.size()-1];\\n        }\\n\\n        long long maxi_ans=INT_MIN;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans += (wt[s]+wt[i]) + solve1(i+1,i+1,k,cnt+1,wt);\\n            maxi_ans=max(maxi_ans,ans);\\n        }\\n\\n        return maxi_ans;\\n    }\\n\\n     long long solve2(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[s]+wt[wt.size()-1];\\n        }\\n\\n        long long mini_ans=INT_MAX;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans+= (wt[s]+wt[i]) + solve2(s+1,i+1,k,cnt+1,wt);\\n            mini_ans=min(mini_ans,ans);\\n        }\\n\\n        return mini_ans;\\n    }\\n    \\n    long long putMarbles(vector<int>& weights, int k) {\\n        k=k-1;\\n        long long maxiAns = solve1(0,0,k,0,weights);\\n        long long miniAns = solve2(0,0,k,0,weights);\\n\\n        cout<<maxiAns<<\\' \\'<<miniAns;\\n        return miniAns;\\n    }`\\n\\nHelp me what\\'s wrong with this dp?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp won\\'t be fast enough for the time limit"
                    },
                    {
                        "username": "dranZerKai",
                        "content": "This should be a medium level question.\nSimilar Question\n(https://codeforces.com/contest/1847/problem/A)"
                    },
                    {
                        "username": "charonme",
                        "content": "Wow, beautiful! If this was labeled \"easy\" I wouldn\\'t even question it, but I\\'d probably have much less satisfaction from the solution.\\n\\nspoiler tips: (hey leetcode, we need a spoiler tag!)\\n1) we\\'re adding the division start and end items to get the min sum and the max sum and they always come in consecutive pairs (end of previous division, start of next division)\\n2) both the min and max sums of all the start and end items always include the first and last weights and they get subtracted from each other at the end, so we can completely ignore those and only consider k-1 pairs of start and end points\\n3) there are n-1 possible pairs to consider and to get the min we need to sum k-1 of the smallest pairs and to get the max we need to sum k-1 of the largest pairs"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Constraints My god"
                    },
                    {
                        "username": "namerror",
                        "content": "This is really interesting. At first glance I also thought it was dp too. Then I was stuck for about half an hour until I looked at the titles of some solutions and immediately realized that I was on the wrong track.\\n\\nAs long as you know it\\'s not dp, it becomes pretty easy to solve."
                    },
                    {
                        "username": "gloom007",
                        "content": "1. As When we pick the ith and jth marble we have to pick all the marbles in the range as well [i...j]\\n2. as no bags can be empty so we have to divide the array in k-1 patitions so that we\\'ll get k subarrays.\\n3. As the score for a sub-array is defined as the W[startIdx] + W[endIdx], so we only care of borders of the subarray.\\n4. if we paritition the sub array at ith index it will increase the score by W[i] + W[i+1]\\n  4.1 In Case of minScore we want to choose min K partition scores.\\n  4.2 In Case of maxScore we want to choose max K partition scores.\\n5. and finally take diff b/w calculated max and min score which will be the result."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is a nice problem, but it becomes even more interesting if we add another constraint, that is `no bag can contain exactly one marble`.\n\nNow the convenience that we were enjoying earlier is all gone as, now if we have chosen $$i$$ and $$i+1$$ indices for $$MaxScore$$ then we can no longer choose $$i+1$$ and $$i+2$$ indices for the same. I don't know the solution yet, but would love to have constructive inputs from the community.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Adding a constraint that no bag can contain exactly one marble does indeed make this problem more complex. It introduces a new dependency in our decisions - if we choose to make a bag using marbles i and i+1, we can\\'t then create another bag with i+1 and i+2. This is because the marble at index i+1 would already be in a bag.\\n\\nWith this additional constraint, the problem becomes a variant of the Interval Scheduling problem, which is typically solved using dynamic programming or greedy algorithms. The Interval Scheduling problem asks for the maximum number of non-overlapping intervals (or in this case, bags) that can be selected. \\n\\nHowever, there\\'s a difference in your problem - we\\'re not trying to maximize the number of bags (it\\'s fixed to k), but instead the difference between the maximum and minimum total weights of the bags. \\n\\nA possible approach might be to first sort all pairs of adjacent marbles by their total weights. Then, apply a modified Interval Scheduling algorithm, but instead of always choosing the next available bag with the earliest end, you could try to make a decision based on the potential impact on the max-min difference. \\n\\nYou\\'d also need to update your definition of \"overlapping\" - now two bags overlap if they share a marble, not just if their ranges overlap.\\n\\nThis would certainly be more complex than the original problem, and might require a more sophisticated data structure to track the potential bags and their overlaps efficiently. It would be a fun challenge though! \\n\\nAs always, you should start by clearly defining the problem and any constraints, and then work through some examples by hand to see if you can spot any patterns or insights that might lead to an algorithm."
                    },
                    {
                        "username": "Kaltu",
                        "content": "then I guess it would require O(n^2) solution because look like it becomes a dp or backtracking problem and the time limit or the constraints on the input should be adjusted"
                    },
                    {
                        "username": "ghanshyamvns7",
                        "content": "I did, however, copy it from the editorial. I discovered that the question was not up to the Hard level after reading and comprehending its prerequisites.\\nWhat say you?\\nComment.\\nhttps://leetcode.com/problems/put-marbles-in-bags/\\nThe URL to my answer is pasted below; if any of you have a better idea, please leave a comment.\\n\\nThank You @"
                    }
                ]
            },
            {
                "id": 1960806,
                "content": [
                    {
                        "username": "user0999B",
                        "content": "1. divide n marbles into k bags means there are k-1 \\u2018cuts\\u2019 of array\\n2. For a \\u2018cut\\u2019 between marble i and i+1. The score of the \\u2018cut\\u2019 is weight[i]+weight[i+1]\\n3. the total score of particular ways of division = first marble weight+ last marble weight + every score of \\u2018cut\\u2019\\n4. calculate all n-1 score among n marbles, sort in ascending order. \\n5. The difference between the sum of last k-1 score and the sum of first k-1 score is the answer\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why I found greedy more difficult than DP"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Because it is"
                    },
                    {
                        "username": "Saphal",
                        "content": " `long long solve1(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[index]+wt[wt.size()-1];\\n        }\\n\\n        long long maxi_ans=INT_MIN;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans += (wt[s]+wt[i]) + solve1(i+1,i+1,k,cnt+1,wt);\\n            maxi_ans=max(maxi_ans,ans);\\n        }\\n\\n        return maxi_ans;\\n    }\\n\\n     long long solve2(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[s]+wt[wt.size()-1];\\n        }\\n\\n        long long mini_ans=INT_MAX;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans+= (wt[s]+wt[i]) + solve2(s+1,i+1,k,cnt+1,wt);\\n            mini_ans=min(mini_ans,ans);\\n        }\\n\\n        return mini_ans;\\n    }\\n    \\n    long long putMarbles(vector<int>& weights, int k) {\\n        k=k-1;\\n        long long maxiAns = solve1(0,0,k,0,weights);\\n        long long miniAns = solve2(0,0,k,0,weights);\\n\\n        cout<<maxiAns<<\\' \\'<<miniAns;\\n        return miniAns;\\n    }`\\n\\nHelp me what\\'s wrong with this dp?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp won\\'t be fast enough for the time limit"
                    },
                    {
                        "username": "dranZerKai",
                        "content": "This should be a medium level question.\nSimilar Question\n(https://codeforces.com/contest/1847/problem/A)"
                    },
                    {
                        "username": "charonme",
                        "content": "Wow, beautiful! If this was labeled \"easy\" I wouldn\\'t even question it, but I\\'d probably have much less satisfaction from the solution.\\n\\nspoiler tips: (hey leetcode, we need a spoiler tag!)\\n1) we\\'re adding the division start and end items to get the min sum and the max sum and they always come in consecutive pairs (end of previous division, start of next division)\\n2) both the min and max sums of all the start and end items always include the first and last weights and they get subtracted from each other at the end, so we can completely ignore those and only consider k-1 pairs of start and end points\\n3) there are n-1 possible pairs to consider and to get the min we need to sum k-1 of the smallest pairs and to get the max we need to sum k-1 of the largest pairs"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Constraints My god"
                    },
                    {
                        "username": "namerror",
                        "content": "This is really interesting. At first glance I also thought it was dp too. Then I was stuck for about half an hour until I looked at the titles of some solutions and immediately realized that I was on the wrong track.\\n\\nAs long as you know it\\'s not dp, it becomes pretty easy to solve."
                    },
                    {
                        "username": "gloom007",
                        "content": "1. As When we pick the ith and jth marble we have to pick all the marbles in the range as well [i...j]\\n2. as no bags can be empty so we have to divide the array in k-1 patitions so that we\\'ll get k subarrays.\\n3. As the score for a sub-array is defined as the W[startIdx] + W[endIdx], so we only care of borders of the subarray.\\n4. if we paritition the sub array at ith index it will increase the score by W[i] + W[i+1]\\n  4.1 In Case of minScore we want to choose min K partition scores.\\n  4.2 In Case of maxScore we want to choose max K partition scores.\\n5. and finally take diff b/w calculated max and min score which will be the result."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is a nice problem, but it becomes even more interesting if we add another constraint, that is `no bag can contain exactly one marble`.\n\nNow the convenience that we were enjoying earlier is all gone as, now if we have chosen $$i$$ and $$i+1$$ indices for $$MaxScore$$ then we can no longer choose $$i+1$$ and $$i+2$$ indices for the same. I don't know the solution yet, but would love to have constructive inputs from the community.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Adding a constraint that no bag can contain exactly one marble does indeed make this problem more complex. It introduces a new dependency in our decisions - if we choose to make a bag using marbles i and i+1, we can\\'t then create another bag with i+1 and i+2. This is because the marble at index i+1 would already be in a bag.\\n\\nWith this additional constraint, the problem becomes a variant of the Interval Scheduling problem, which is typically solved using dynamic programming or greedy algorithms. The Interval Scheduling problem asks for the maximum number of non-overlapping intervals (or in this case, bags) that can be selected. \\n\\nHowever, there\\'s a difference in your problem - we\\'re not trying to maximize the number of bags (it\\'s fixed to k), but instead the difference between the maximum and minimum total weights of the bags. \\n\\nA possible approach might be to first sort all pairs of adjacent marbles by their total weights. Then, apply a modified Interval Scheduling algorithm, but instead of always choosing the next available bag with the earliest end, you could try to make a decision based on the potential impact on the max-min difference. \\n\\nYou\\'d also need to update your definition of \"overlapping\" - now two bags overlap if they share a marble, not just if their ranges overlap.\\n\\nThis would certainly be more complex than the original problem, and might require a more sophisticated data structure to track the potential bags and their overlaps efficiently. It would be a fun challenge though! \\n\\nAs always, you should start by clearly defining the problem and any constraints, and then work through some examples by hand to see if you can spot any patterns or insights that might lead to an algorithm."
                    },
                    {
                        "username": "Kaltu",
                        "content": "then I guess it would require O(n^2) solution because look like it becomes a dp or backtracking problem and the time limit or the constraints on the input should be adjusted"
                    },
                    {
                        "username": "ghanshyamvns7",
                        "content": "I did, however, copy it from the editorial. I discovered that the question was not up to the Hard level after reading and comprehending its prerequisites.\\nWhat say you?\\nComment.\\nhttps://leetcode.com/problems/put-marbles-in-bags/\\nThe URL to my answer is pasted below; if any of you have a better idea, please leave a comment.\\n\\nThank You @"
                    }
                ]
            },
            {
                "id": 1960722,
                "content": [
                    {
                        "username": "user0999B",
                        "content": "1. divide n marbles into k bags means there are k-1 \\u2018cuts\\u2019 of array\\n2. For a \\u2018cut\\u2019 between marble i and i+1. The score of the \\u2018cut\\u2019 is weight[i]+weight[i+1]\\n3. the total score of particular ways of division = first marble weight+ last marble weight + every score of \\u2018cut\\u2019\\n4. calculate all n-1 score among n marbles, sort in ascending order. \\n5. The difference between the sum of last k-1 score and the sum of first k-1 score is the answer\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why I found greedy more difficult than DP"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Because it is"
                    },
                    {
                        "username": "Saphal",
                        "content": " `long long solve1(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[index]+wt[wt.size()-1];\\n        }\\n\\n        long long maxi_ans=INT_MIN;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans += (wt[s]+wt[i]) + solve1(i+1,i+1,k,cnt+1,wt);\\n            maxi_ans=max(maxi_ans,ans);\\n        }\\n\\n        return maxi_ans;\\n    }\\n\\n     long long solve2(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[s]+wt[wt.size()-1];\\n        }\\n\\n        long long mini_ans=INT_MAX;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans+= (wt[s]+wt[i]) + solve2(s+1,i+1,k,cnt+1,wt);\\n            mini_ans=min(mini_ans,ans);\\n        }\\n\\n        return mini_ans;\\n    }\\n    \\n    long long putMarbles(vector<int>& weights, int k) {\\n        k=k-1;\\n        long long maxiAns = solve1(0,0,k,0,weights);\\n        long long miniAns = solve2(0,0,k,0,weights);\\n\\n        cout<<maxiAns<<\\' \\'<<miniAns;\\n        return miniAns;\\n    }`\\n\\nHelp me what\\'s wrong with this dp?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp won\\'t be fast enough for the time limit"
                    },
                    {
                        "username": "dranZerKai",
                        "content": "This should be a medium level question.\nSimilar Question\n(https://codeforces.com/contest/1847/problem/A)"
                    },
                    {
                        "username": "charonme",
                        "content": "Wow, beautiful! If this was labeled \"easy\" I wouldn\\'t even question it, but I\\'d probably have much less satisfaction from the solution.\\n\\nspoiler tips: (hey leetcode, we need a spoiler tag!)\\n1) we\\'re adding the division start and end items to get the min sum and the max sum and they always come in consecutive pairs (end of previous division, start of next division)\\n2) both the min and max sums of all the start and end items always include the first and last weights and they get subtracted from each other at the end, so we can completely ignore those and only consider k-1 pairs of start and end points\\n3) there are n-1 possible pairs to consider and to get the min we need to sum k-1 of the smallest pairs and to get the max we need to sum k-1 of the largest pairs"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Constraints My god"
                    },
                    {
                        "username": "namerror",
                        "content": "This is really interesting. At first glance I also thought it was dp too. Then I was stuck for about half an hour until I looked at the titles of some solutions and immediately realized that I was on the wrong track.\\n\\nAs long as you know it\\'s not dp, it becomes pretty easy to solve."
                    },
                    {
                        "username": "gloom007",
                        "content": "1. As When we pick the ith and jth marble we have to pick all the marbles in the range as well [i...j]\\n2. as no bags can be empty so we have to divide the array in k-1 patitions so that we\\'ll get k subarrays.\\n3. As the score for a sub-array is defined as the W[startIdx] + W[endIdx], so we only care of borders of the subarray.\\n4. if we paritition the sub array at ith index it will increase the score by W[i] + W[i+1]\\n  4.1 In Case of minScore we want to choose min K partition scores.\\n  4.2 In Case of maxScore we want to choose max K partition scores.\\n5. and finally take diff b/w calculated max and min score which will be the result."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is a nice problem, but it becomes even more interesting if we add another constraint, that is `no bag can contain exactly one marble`.\n\nNow the convenience that we were enjoying earlier is all gone as, now if we have chosen $$i$$ and $$i+1$$ indices for $$MaxScore$$ then we can no longer choose $$i+1$$ and $$i+2$$ indices for the same. I don't know the solution yet, but would love to have constructive inputs from the community.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Adding a constraint that no bag can contain exactly one marble does indeed make this problem more complex. It introduces a new dependency in our decisions - if we choose to make a bag using marbles i and i+1, we can\\'t then create another bag with i+1 and i+2. This is because the marble at index i+1 would already be in a bag.\\n\\nWith this additional constraint, the problem becomes a variant of the Interval Scheduling problem, which is typically solved using dynamic programming or greedy algorithms. The Interval Scheduling problem asks for the maximum number of non-overlapping intervals (or in this case, bags) that can be selected. \\n\\nHowever, there\\'s a difference in your problem - we\\'re not trying to maximize the number of bags (it\\'s fixed to k), but instead the difference between the maximum and minimum total weights of the bags. \\n\\nA possible approach might be to first sort all pairs of adjacent marbles by their total weights. Then, apply a modified Interval Scheduling algorithm, but instead of always choosing the next available bag with the earliest end, you could try to make a decision based on the potential impact on the max-min difference. \\n\\nYou\\'d also need to update your definition of \"overlapping\" - now two bags overlap if they share a marble, not just if their ranges overlap.\\n\\nThis would certainly be more complex than the original problem, and might require a more sophisticated data structure to track the potential bags and their overlaps efficiently. It would be a fun challenge though! \\n\\nAs always, you should start by clearly defining the problem and any constraints, and then work through some examples by hand to see if you can spot any patterns or insights that might lead to an algorithm."
                    },
                    {
                        "username": "Kaltu",
                        "content": "then I guess it would require O(n^2) solution because look like it becomes a dp or backtracking problem and the time limit or the constraints on the input should be adjusted"
                    },
                    {
                        "username": "ghanshyamvns7",
                        "content": "I did, however, copy it from the editorial. I discovered that the question was not up to the Hard level after reading and comprehending its prerequisites.\\nWhat say you?\\nComment.\\nhttps://leetcode.com/problems/put-marbles-in-bags/\\nThe URL to my answer is pasted below; if any of you have a better idea, please leave a comment.\\n\\nThank You @"
                    }
                ]
            },
            {
                "id": 1960697,
                "content": [
                    {
                        "username": "user0999B",
                        "content": "1. divide n marbles into k bags means there are k-1 \\u2018cuts\\u2019 of array\\n2. For a \\u2018cut\\u2019 between marble i and i+1. The score of the \\u2018cut\\u2019 is weight[i]+weight[i+1]\\n3. the total score of particular ways of division = first marble weight+ last marble weight + every score of \\u2018cut\\u2019\\n4. calculate all n-1 score among n marbles, sort in ascending order. \\n5. The difference between the sum of last k-1 score and the sum of first k-1 score is the answer\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why I found greedy more difficult than DP"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Because it is"
                    },
                    {
                        "username": "Saphal",
                        "content": " `long long solve1(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[index]+wt[wt.size()-1];\\n        }\\n\\n        long long maxi_ans=INT_MIN;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans += (wt[s]+wt[i]) + solve1(i+1,i+1,k,cnt+1,wt);\\n            maxi_ans=max(maxi_ans,ans);\\n        }\\n\\n        return maxi_ans;\\n    }\\n\\n     long long solve2(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[s]+wt[wt.size()-1];\\n        }\\n\\n        long long mini_ans=INT_MAX;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans+= (wt[s]+wt[i]) + solve2(s+1,i+1,k,cnt+1,wt);\\n            mini_ans=min(mini_ans,ans);\\n        }\\n\\n        return mini_ans;\\n    }\\n    \\n    long long putMarbles(vector<int>& weights, int k) {\\n        k=k-1;\\n        long long maxiAns = solve1(0,0,k,0,weights);\\n        long long miniAns = solve2(0,0,k,0,weights);\\n\\n        cout<<maxiAns<<\\' \\'<<miniAns;\\n        return miniAns;\\n    }`\\n\\nHelp me what\\'s wrong with this dp?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp won\\'t be fast enough for the time limit"
                    },
                    {
                        "username": "dranZerKai",
                        "content": "This should be a medium level question.\nSimilar Question\n(https://codeforces.com/contest/1847/problem/A)"
                    },
                    {
                        "username": "charonme",
                        "content": "Wow, beautiful! If this was labeled \"easy\" I wouldn\\'t even question it, but I\\'d probably have much less satisfaction from the solution.\\n\\nspoiler tips: (hey leetcode, we need a spoiler tag!)\\n1) we\\'re adding the division start and end items to get the min sum and the max sum and they always come in consecutive pairs (end of previous division, start of next division)\\n2) both the min and max sums of all the start and end items always include the first and last weights and they get subtracted from each other at the end, so we can completely ignore those and only consider k-1 pairs of start and end points\\n3) there are n-1 possible pairs to consider and to get the min we need to sum k-1 of the smallest pairs and to get the max we need to sum k-1 of the largest pairs"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Constraints My god"
                    },
                    {
                        "username": "namerror",
                        "content": "This is really interesting. At first glance I also thought it was dp too. Then I was stuck for about half an hour until I looked at the titles of some solutions and immediately realized that I was on the wrong track.\\n\\nAs long as you know it\\'s not dp, it becomes pretty easy to solve."
                    },
                    {
                        "username": "gloom007",
                        "content": "1. As When we pick the ith and jth marble we have to pick all the marbles in the range as well [i...j]\\n2. as no bags can be empty so we have to divide the array in k-1 patitions so that we\\'ll get k subarrays.\\n3. As the score for a sub-array is defined as the W[startIdx] + W[endIdx], so we only care of borders of the subarray.\\n4. if we paritition the sub array at ith index it will increase the score by W[i] + W[i+1]\\n  4.1 In Case of minScore we want to choose min K partition scores.\\n  4.2 In Case of maxScore we want to choose max K partition scores.\\n5. and finally take diff b/w calculated max and min score which will be the result."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is a nice problem, but it becomes even more interesting if we add another constraint, that is `no bag can contain exactly one marble`.\n\nNow the convenience that we were enjoying earlier is all gone as, now if we have chosen $$i$$ and $$i+1$$ indices for $$MaxScore$$ then we can no longer choose $$i+1$$ and $$i+2$$ indices for the same. I don't know the solution yet, but would love to have constructive inputs from the community.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Adding a constraint that no bag can contain exactly one marble does indeed make this problem more complex. It introduces a new dependency in our decisions - if we choose to make a bag using marbles i and i+1, we can\\'t then create another bag with i+1 and i+2. This is because the marble at index i+1 would already be in a bag.\\n\\nWith this additional constraint, the problem becomes a variant of the Interval Scheduling problem, which is typically solved using dynamic programming or greedy algorithms. The Interval Scheduling problem asks for the maximum number of non-overlapping intervals (or in this case, bags) that can be selected. \\n\\nHowever, there\\'s a difference in your problem - we\\'re not trying to maximize the number of bags (it\\'s fixed to k), but instead the difference between the maximum and minimum total weights of the bags. \\n\\nA possible approach might be to first sort all pairs of adjacent marbles by their total weights. Then, apply a modified Interval Scheduling algorithm, but instead of always choosing the next available bag with the earliest end, you could try to make a decision based on the potential impact on the max-min difference. \\n\\nYou\\'d also need to update your definition of \"overlapping\" - now two bags overlap if they share a marble, not just if their ranges overlap.\\n\\nThis would certainly be more complex than the original problem, and might require a more sophisticated data structure to track the potential bags and their overlaps efficiently. It would be a fun challenge though! \\n\\nAs always, you should start by clearly defining the problem and any constraints, and then work through some examples by hand to see if you can spot any patterns or insights that might lead to an algorithm."
                    },
                    {
                        "username": "Kaltu",
                        "content": "then I guess it would require O(n^2) solution because look like it becomes a dp or backtracking problem and the time limit or the constraints on the input should be adjusted"
                    },
                    {
                        "username": "ghanshyamvns7",
                        "content": "I did, however, copy it from the editorial. I discovered that the question was not up to the Hard level after reading and comprehending its prerequisites.\\nWhat say you?\\nComment.\\nhttps://leetcode.com/problems/put-marbles-in-bags/\\nThe URL to my answer is pasted below; if any of you have a better idea, please leave a comment.\\n\\nThank You @"
                    }
                ]
            },
            {
                "id": 1960689,
                "content": [
                    {
                        "username": "user0999B",
                        "content": "1. divide n marbles into k bags means there are k-1 \\u2018cuts\\u2019 of array\\n2. For a \\u2018cut\\u2019 between marble i and i+1. The score of the \\u2018cut\\u2019 is weight[i]+weight[i+1]\\n3. the total score of particular ways of division = first marble weight+ last marble weight + every score of \\u2018cut\\u2019\\n4. calculate all n-1 score among n marbles, sort in ascending order. \\n5. The difference between the sum of last k-1 score and the sum of first k-1 score is the answer\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why I found greedy more difficult than DP"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Because it is"
                    },
                    {
                        "username": "Saphal",
                        "content": " `long long solve1(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[index]+wt[wt.size()-1];\\n        }\\n\\n        long long maxi_ans=INT_MIN;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans += (wt[s]+wt[i]) + solve1(i+1,i+1,k,cnt+1,wt);\\n            maxi_ans=max(maxi_ans,ans);\\n        }\\n\\n        return maxi_ans;\\n    }\\n\\n     long long solve2(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[s]+wt[wt.size()-1];\\n        }\\n\\n        long long mini_ans=INT_MAX;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans+= (wt[s]+wt[i]) + solve2(s+1,i+1,k,cnt+1,wt);\\n            mini_ans=min(mini_ans,ans);\\n        }\\n\\n        return mini_ans;\\n    }\\n    \\n    long long putMarbles(vector<int>& weights, int k) {\\n        k=k-1;\\n        long long maxiAns = solve1(0,0,k,0,weights);\\n        long long miniAns = solve2(0,0,k,0,weights);\\n\\n        cout<<maxiAns<<\\' \\'<<miniAns;\\n        return miniAns;\\n    }`\\n\\nHelp me what\\'s wrong with this dp?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp won\\'t be fast enough for the time limit"
                    },
                    {
                        "username": "dranZerKai",
                        "content": "This should be a medium level question.\nSimilar Question\n(https://codeforces.com/contest/1847/problem/A)"
                    },
                    {
                        "username": "charonme",
                        "content": "Wow, beautiful! If this was labeled \"easy\" I wouldn\\'t even question it, but I\\'d probably have much less satisfaction from the solution.\\n\\nspoiler tips: (hey leetcode, we need a spoiler tag!)\\n1) we\\'re adding the division start and end items to get the min sum and the max sum and they always come in consecutive pairs (end of previous division, start of next division)\\n2) both the min and max sums of all the start and end items always include the first and last weights and they get subtracted from each other at the end, so we can completely ignore those and only consider k-1 pairs of start and end points\\n3) there are n-1 possible pairs to consider and to get the min we need to sum k-1 of the smallest pairs and to get the max we need to sum k-1 of the largest pairs"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Constraints My god"
                    },
                    {
                        "username": "namerror",
                        "content": "This is really interesting. At first glance I also thought it was dp too. Then I was stuck for about half an hour until I looked at the titles of some solutions and immediately realized that I was on the wrong track.\\n\\nAs long as you know it\\'s not dp, it becomes pretty easy to solve."
                    },
                    {
                        "username": "gloom007",
                        "content": "1. As When we pick the ith and jth marble we have to pick all the marbles in the range as well [i...j]\\n2. as no bags can be empty so we have to divide the array in k-1 patitions so that we\\'ll get k subarrays.\\n3. As the score for a sub-array is defined as the W[startIdx] + W[endIdx], so we only care of borders of the subarray.\\n4. if we paritition the sub array at ith index it will increase the score by W[i] + W[i+1]\\n  4.1 In Case of minScore we want to choose min K partition scores.\\n  4.2 In Case of maxScore we want to choose max K partition scores.\\n5. and finally take diff b/w calculated max and min score which will be the result."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is a nice problem, but it becomes even more interesting if we add another constraint, that is `no bag can contain exactly one marble`.\n\nNow the convenience that we were enjoying earlier is all gone as, now if we have chosen $$i$$ and $$i+1$$ indices for $$MaxScore$$ then we can no longer choose $$i+1$$ and $$i+2$$ indices for the same. I don't know the solution yet, but would love to have constructive inputs from the community.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Adding a constraint that no bag can contain exactly one marble does indeed make this problem more complex. It introduces a new dependency in our decisions - if we choose to make a bag using marbles i and i+1, we can\\'t then create another bag with i+1 and i+2. This is because the marble at index i+1 would already be in a bag.\\n\\nWith this additional constraint, the problem becomes a variant of the Interval Scheduling problem, which is typically solved using dynamic programming or greedy algorithms. The Interval Scheduling problem asks for the maximum number of non-overlapping intervals (or in this case, bags) that can be selected. \\n\\nHowever, there\\'s a difference in your problem - we\\'re not trying to maximize the number of bags (it\\'s fixed to k), but instead the difference between the maximum and minimum total weights of the bags. \\n\\nA possible approach might be to first sort all pairs of adjacent marbles by their total weights. Then, apply a modified Interval Scheduling algorithm, but instead of always choosing the next available bag with the earliest end, you could try to make a decision based on the potential impact on the max-min difference. \\n\\nYou\\'d also need to update your definition of \"overlapping\" - now two bags overlap if they share a marble, not just if their ranges overlap.\\n\\nThis would certainly be more complex than the original problem, and might require a more sophisticated data structure to track the potential bags and their overlaps efficiently. It would be a fun challenge though! \\n\\nAs always, you should start by clearly defining the problem and any constraints, and then work through some examples by hand to see if you can spot any patterns or insights that might lead to an algorithm."
                    },
                    {
                        "username": "Kaltu",
                        "content": "then I guess it would require O(n^2) solution because look like it becomes a dp or backtracking problem and the time limit or the constraints on the input should be adjusted"
                    },
                    {
                        "username": "ghanshyamvns7",
                        "content": "I did, however, copy it from the editorial. I discovered that the question was not up to the Hard level after reading and comprehending its prerequisites.\\nWhat say you?\\nComment.\\nhttps://leetcode.com/problems/put-marbles-in-bags/\\nThe URL to my answer is pasted below; if any of you have a better idea, please leave a comment.\\n\\nThank You @"
                    }
                ]
            },
            {
                "id": 1960663,
                "content": [
                    {
                        "username": "user0999B",
                        "content": "1. divide n marbles into k bags means there are k-1 \\u2018cuts\\u2019 of array\\n2. For a \\u2018cut\\u2019 between marble i and i+1. The score of the \\u2018cut\\u2019 is weight[i]+weight[i+1]\\n3. the total score of particular ways of division = first marble weight+ last marble weight + every score of \\u2018cut\\u2019\\n4. calculate all n-1 score among n marbles, sort in ascending order. \\n5. The difference between the sum of last k-1 score and the sum of first k-1 score is the answer\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why I found greedy more difficult than DP"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Because it is"
                    },
                    {
                        "username": "Saphal",
                        "content": " `long long solve1(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[index]+wt[wt.size()-1];\\n        }\\n\\n        long long maxi_ans=INT_MIN;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans += (wt[s]+wt[i]) + solve1(i+1,i+1,k,cnt+1,wt);\\n            maxi_ans=max(maxi_ans,ans);\\n        }\\n\\n        return maxi_ans;\\n    }\\n\\n     long long solve2(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[s]+wt[wt.size()-1];\\n        }\\n\\n        long long mini_ans=INT_MAX;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans+= (wt[s]+wt[i]) + solve2(s+1,i+1,k,cnt+1,wt);\\n            mini_ans=min(mini_ans,ans);\\n        }\\n\\n        return mini_ans;\\n    }\\n    \\n    long long putMarbles(vector<int>& weights, int k) {\\n        k=k-1;\\n        long long maxiAns = solve1(0,0,k,0,weights);\\n        long long miniAns = solve2(0,0,k,0,weights);\\n\\n        cout<<maxiAns<<\\' \\'<<miniAns;\\n        return miniAns;\\n    }`\\n\\nHelp me what\\'s wrong with this dp?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp won\\'t be fast enough for the time limit"
                    },
                    {
                        "username": "dranZerKai",
                        "content": "This should be a medium level question.\nSimilar Question\n(https://codeforces.com/contest/1847/problem/A)"
                    },
                    {
                        "username": "charonme",
                        "content": "Wow, beautiful! If this was labeled \"easy\" I wouldn\\'t even question it, but I\\'d probably have much less satisfaction from the solution.\\n\\nspoiler tips: (hey leetcode, we need a spoiler tag!)\\n1) we\\'re adding the division start and end items to get the min sum and the max sum and they always come in consecutive pairs (end of previous division, start of next division)\\n2) both the min and max sums of all the start and end items always include the first and last weights and they get subtracted from each other at the end, so we can completely ignore those and only consider k-1 pairs of start and end points\\n3) there are n-1 possible pairs to consider and to get the min we need to sum k-1 of the smallest pairs and to get the max we need to sum k-1 of the largest pairs"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Constraints My god"
                    },
                    {
                        "username": "namerror",
                        "content": "This is really interesting. At first glance I also thought it was dp too. Then I was stuck for about half an hour until I looked at the titles of some solutions and immediately realized that I was on the wrong track.\\n\\nAs long as you know it\\'s not dp, it becomes pretty easy to solve."
                    },
                    {
                        "username": "gloom007",
                        "content": "1. As When we pick the ith and jth marble we have to pick all the marbles in the range as well [i...j]\\n2. as no bags can be empty so we have to divide the array in k-1 patitions so that we\\'ll get k subarrays.\\n3. As the score for a sub-array is defined as the W[startIdx] + W[endIdx], so we only care of borders of the subarray.\\n4. if we paritition the sub array at ith index it will increase the score by W[i] + W[i+1]\\n  4.1 In Case of minScore we want to choose min K partition scores.\\n  4.2 In Case of maxScore we want to choose max K partition scores.\\n5. and finally take diff b/w calculated max and min score which will be the result."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is a nice problem, but it becomes even more interesting if we add another constraint, that is `no bag can contain exactly one marble`.\n\nNow the convenience that we were enjoying earlier is all gone as, now if we have chosen $$i$$ and $$i+1$$ indices for $$MaxScore$$ then we can no longer choose $$i+1$$ and $$i+2$$ indices for the same. I don't know the solution yet, but would love to have constructive inputs from the community.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Adding a constraint that no bag can contain exactly one marble does indeed make this problem more complex. It introduces a new dependency in our decisions - if we choose to make a bag using marbles i and i+1, we can\\'t then create another bag with i+1 and i+2. This is because the marble at index i+1 would already be in a bag.\\n\\nWith this additional constraint, the problem becomes a variant of the Interval Scheduling problem, which is typically solved using dynamic programming or greedy algorithms. The Interval Scheduling problem asks for the maximum number of non-overlapping intervals (or in this case, bags) that can be selected. \\n\\nHowever, there\\'s a difference in your problem - we\\'re not trying to maximize the number of bags (it\\'s fixed to k), but instead the difference between the maximum and minimum total weights of the bags. \\n\\nA possible approach might be to first sort all pairs of adjacent marbles by their total weights. Then, apply a modified Interval Scheduling algorithm, but instead of always choosing the next available bag with the earliest end, you could try to make a decision based on the potential impact on the max-min difference. \\n\\nYou\\'d also need to update your definition of \"overlapping\" - now two bags overlap if they share a marble, not just if their ranges overlap.\\n\\nThis would certainly be more complex than the original problem, and might require a more sophisticated data structure to track the potential bags and their overlaps efficiently. It would be a fun challenge though! \\n\\nAs always, you should start by clearly defining the problem and any constraints, and then work through some examples by hand to see if you can spot any patterns or insights that might lead to an algorithm."
                    },
                    {
                        "username": "Kaltu",
                        "content": "then I guess it would require O(n^2) solution because look like it becomes a dp or backtracking problem and the time limit or the constraints on the input should be adjusted"
                    },
                    {
                        "username": "ghanshyamvns7",
                        "content": "I did, however, copy it from the editorial. I discovered that the question was not up to the Hard level after reading and comprehending its prerequisites.\\nWhat say you?\\nComment.\\nhttps://leetcode.com/problems/put-marbles-in-bags/\\nThe URL to my answer is pasted below; if any of you have a better idea, please leave a comment.\\n\\nThank You @"
                    }
                ]
            },
            {
                "id": 1960662,
                "content": [
                    {
                        "username": "user0999B",
                        "content": "1. divide n marbles into k bags means there are k-1 \\u2018cuts\\u2019 of array\\n2. For a \\u2018cut\\u2019 between marble i and i+1. The score of the \\u2018cut\\u2019 is weight[i]+weight[i+1]\\n3. the total score of particular ways of division = first marble weight+ last marble weight + every score of \\u2018cut\\u2019\\n4. calculate all n-1 score among n marbles, sort in ascending order. \\n5. The difference between the sum of last k-1 score and the sum of first k-1 score is the answer\\n"
                    },
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "why I found greedy more difficult than DP"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Because it is"
                    },
                    {
                        "username": "Saphal",
                        "content": " `long long solve1(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[index]+wt[wt.size()-1];\\n        }\\n\\n        long long maxi_ans=INT_MIN;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans += (wt[s]+wt[i]) + solve1(i+1,i+1,k,cnt+1,wt);\\n            maxi_ans=max(maxi_ans,ans);\\n        }\\n\\n        return maxi_ans;\\n    }\\n\\n     long long solve2(int s,int index,int k,int cnt,vector<int> &wt){\\n        //base case\\n        if(cnt==k){\\n            return wt[s]+wt[wt.size()-1];\\n        }\\n\\n        long long mini_ans=INT_MAX;\\n        long long ans=0;\\n        for(int i=index;i<wt.size()-k+cnt;i++){\\n            ans+= (wt[s]+wt[i]) + solve2(s+1,i+1,k,cnt+1,wt);\\n            mini_ans=min(mini_ans,ans);\\n        }\\n\\n        return mini_ans;\\n    }\\n    \\n    long long putMarbles(vector<int>& weights, int k) {\\n        k=k-1;\\n        long long maxiAns = solve1(0,0,k,0,weights);\\n        long long miniAns = solve2(0,0,k,0,weights);\\n\\n        cout<<maxiAns<<\\' \\'<<miniAns;\\n        return miniAns;\\n    }`\\n\\nHelp me what\\'s wrong with this dp?"
                    },
                    {
                        "username": "Kaltu",
                        "content": "dp won\\'t be fast enough for the time limit"
                    },
                    {
                        "username": "dranZerKai",
                        "content": "This should be a medium level question.\nSimilar Question\n(https://codeforces.com/contest/1847/problem/A)"
                    },
                    {
                        "username": "charonme",
                        "content": "Wow, beautiful! If this was labeled \"easy\" I wouldn\\'t even question it, but I\\'d probably have much less satisfaction from the solution.\\n\\nspoiler tips: (hey leetcode, we need a spoiler tag!)\\n1) we\\'re adding the division start and end items to get the min sum and the max sum and they always come in consecutive pairs (end of previous division, start of next division)\\n2) both the min and max sums of all the start and end items always include the first and last weights and they get subtracted from each other at the end, so we can completely ignore those and only consider k-1 pairs of start and end points\\n3) there are n-1 possible pairs to consider and to get the min we need to sum k-1 of the smallest pairs and to get the max we need to sum k-1 of the largest pairs"
                    },
                    {
                        "username": "arghyadas",
                        "content": "Constraints My god"
                    },
                    {
                        "username": "namerror",
                        "content": "This is really interesting. At first glance I also thought it was dp too. Then I was stuck for about half an hour until I looked at the titles of some solutions and immediately realized that I was on the wrong track.\\n\\nAs long as you know it\\'s not dp, it becomes pretty easy to solve."
                    },
                    {
                        "username": "gloom007",
                        "content": "1. As When we pick the ith and jth marble we have to pick all the marbles in the range as well [i...j]\\n2. as no bags can be empty so we have to divide the array in k-1 patitions so that we\\'ll get k subarrays.\\n3. As the score for a sub-array is defined as the W[startIdx] + W[endIdx], so we only care of borders of the subarray.\\n4. if we paritition the sub array at ith index it will increase the score by W[i] + W[i+1]\\n  4.1 In Case of minScore we want to choose min K partition scores.\\n  4.2 In Case of maxScore we want to choose max K partition scores.\\n5. and finally take diff b/w calculated max and min score which will be the result."
                    },
                    {
                        "username": "anuron_das",
                        "content": "This is a nice problem, but it becomes even more interesting if we add another constraint, that is `no bag can contain exactly one marble`.\n\nNow the convenience that we were enjoying earlier is all gone as, now if we have chosen $$i$$ and $$i+1$$ indices for $$MaxScore$$ then we can no longer choose $$i+1$$ and $$i+2$$ indices for the same. I don't know the solution yet, but would love to have constructive inputs from the community.\n"
                    },
                    {
                        "username": "bparanj",
                        "content": "Adding a constraint that no bag can contain exactly one marble does indeed make this problem more complex. It introduces a new dependency in our decisions - if we choose to make a bag using marbles i and i+1, we can\\'t then create another bag with i+1 and i+2. This is because the marble at index i+1 would already be in a bag.\\n\\nWith this additional constraint, the problem becomes a variant of the Interval Scheduling problem, which is typically solved using dynamic programming or greedy algorithms. The Interval Scheduling problem asks for the maximum number of non-overlapping intervals (or in this case, bags) that can be selected. \\n\\nHowever, there\\'s a difference in your problem - we\\'re not trying to maximize the number of bags (it\\'s fixed to k), but instead the difference between the maximum and minimum total weights of the bags. \\n\\nA possible approach might be to first sort all pairs of adjacent marbles by their total weights. Then, apply a modified Interval Scheduling algorithm, but instead of always choosing the next available bag with the earliest end, you could try to make a decision based on the potential impact on the max-min difference. \\n\\nYou\\'d also need to update your definition of \"overlapping\" - now two bags overlap if they share a marble, not just if their ranges overlap.\\n\\nThis would certainly be more complex than the original problem, and might require a more sophisticated data structure to track the potential bags and their overlaps efficiently. It would be a fun challenge though! \\n\\nAs always, you should start by clearly defining the problem and any constraints, and then work through some examples by hand to see if you can spot any patterns or insights that might lead to an algorithm."
                    },
                    {
                        "username": "Kaltu",
                        "content": "then I guess it would require O(n^2) solution because look like it becomes a dp or backtracking problem and the time limit or the constraints on the input should be adjusted"
                    },
                    {
                        "username": "ghanshyamvns7",
                        "content": "I did, however, copy it from the editorial. I discovered that the question was not up to the Hard level after reading and comprehending its prerequisites.\\nWhat say you?\\nComment.\\nhttps://leetcode.com/problems/put-marbles-in-bags/\\nThe URL to my answer is pasted below; if any of you have a better idea, please leave a comment.\\n\\nThank You @"
                    }
                ]
            },
            {
                "id": 1960656,
                "content": [
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Think of it this way, you have to partition the array in k different windows. Since you need all elements, the first and last elements will always be present in the sum. Now whenever you place a partition, the two elements adjacent to partition are added to the sum. So how would you maximize or minimize the sum. "
                    },
                    {
                        "username": "1byte",
                        "content": "Think about partitions instead of marbles."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "As a beginner can someone pls help me with finding the intution for this, all i can understand are: \\n->We have to do partitions according to some rule.\\n->The first and last element are the elements going in the beginning and last of the bag(s)..."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break it down:\\n\\n1. Problem understanding: You\\'re given a list of weights (marbles), and you\\'re allowed to make \\'k\\' partitions in this list. A partition means dividing the list into segments. Each segment will go into a separate bag. The weight of a bag is calculated as the sum of the weight of the first and last marble in the bag.\\n\\n2. Rule for partitions: You need to create the partitions such that you maximize the total weight of all the bags and also minimize the total weight of all the bags.\\n\\n3. The challenge: You have to return the difference between the maximum total weight and the minimum total weight.\\n\\nHere\\'s the key insight: \\n\\n4. Intuition: The first and last marble in the list will always contribute to the total weight (since they will always be the first and last marbles in some bag, no matter how you partition the list). Therefore, we need to think about what happens when we add a partition.\\n\\n5. When we create a partition, we essentially add a new bag. The weight of this new bag is the sum of the first and last marble in it, which are the marbles on either side of the partition in the original list.\\n\\n6. So to maximize the total weight, we want to put partitions next to the heaviest marbles. And to minimize the total weight, we want to put partitions next to the lightest marbles.\\n\\n7. With this intuition, we can create an array of pair weights (each pair is the weight of marbles on either side of a potential partition). Sorting this array, we get the marbles sorted by weight.\\n\\n8. Then we take the k-1 heaviest pair weights for the maximum total weight (since the first and last marbles in the list are always included, we only need k-1 more partitions). Similarly, we take the k-1 lightest pair weights for the minimum total weight.\\n\\n9. The difference between these two sums gives us our final answer. \\n\\nI hope this breakdown helps clarify the problem and how to approach it! It\\'s a tricky one, so don\\'t worry if it doesn\\'t click right away.\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you check the editorial?\\nThe trick is to realize the question is actaully asking you to find where to cut(partition) the marbles, so you are looking for the boundaries between two adjacent marbles that have largest weights (for the maximun) and smallest weights (for the minimum)"
                    },
                    {
                        "username": "kenzgf",
                        "content": "And here I am coming up with memo + backtrack thinking I was so smart until getting annihilated with TLE :("
                    },
                    {
                        "username": "Kaltu",
                        "content": "the large constraint calls for O(n log n) solution. dp, backtracking with memoization can reach the correct answer but they take O(n^2)"
                    },
                    {
                        "username": "noman598",
                        "content": "Finding pattern of the problems is kind of unfair for beginner :)"
                    },
                    {
                        "username": "shah4772",
                        "content": "where can I get similar questions like this?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Ugh, stuck with these heavyweights! "
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "I don\\'t think the question forbids to do something like this:\\nSay we have 2 bags and we \\n1. put i1 to j1 marbles into 1st bag\\n2. put j1+1 to i2-1 marbles into 2nd bag\\n3. put i2 to j2 marbles into 1st bag again...."
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "It does. See the second condition:\\n`If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.`\\nSo accordingly, all marbles between i1 and j2 must be in 1st bag."
                    },
                    {
                        "username": "rickRicardo",
                        "content": "First and last bag will always have first and last marbles, respectively."
                    },
                    {
                        "username": "Kaltu",
                        "content": "and cancel out since we are finding the difference"
                    },
                    {
                        "username": "jason3410",
                        "content": "Imagine we\\'re finding the sum of the gap between each two bags. ie. Consider (bag[i].right+ bag[i+1].left)"
                    }
                ]
            },
            {
                "id": 1960645,
                "content": [
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Think of it this way, you have to partition the array in k different windows. Since you need all elements, the first and last elements will always be present in the sum. Now whenever you place a partition, the two elements adjacent to partition are added to the sum. So how would you maximize or minimize the sum. "
                    },
                    {
                        "username": "1byte",
                        "content": "Think about partitions instead of marbles."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "As a beginner can someone pls help me with finding the intution for this, all i can understand are: \\n->We have to do partitions according to some rule.\\n->The first and last element are the elements going in the beginning and last of the bag(s)..."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break it down:\\n\\n1. Problem understanding: You\\'re given a list of weights (marbles), and you\\'re allowed to make \\'k\\' partitions in this list. A partition means dividing the list into segments. Each segment will go into a separate bag. The weight of a bag is calculated as the sum of the weight of the first and last marble in the bag.\\n\\n2. Rule for partitions: You need to create the partitions such that you maximize the total weight of all the bags and also minimize the total weight of all the bags.\\n\\n3. The challenge: You have to return the difference between the maximum total weight and the minimum total weight.\\n\\nHere\\'s the key insight: \\n\\n4. Intuition: The first and last marble in the list will always contribute to the total weight (since they will always be the first and last marbles in some bag, no matter how you partition the list). Therefore, we need to think about what happens when we add a partition.\\n\\n5. When we create a partition, we essentially add a new bag. The weight of this new bag is the sum of the first and last marble in it, which are the marbles on either side of the partition in the original list.\\n\\n6. So to maximize the total weight, we want to put partitions next to the heaviest marbles. And to minimize the total weight, we want to put partitions next to the lightest marbles.\\n\\n7. With this intuition, we can create an array of pair weights (each pair is the weight of marbles on either side of a potential partition). Sorting this array, we get the marbles sorted by weight.\\n\\n8. Then we take the k-1 heaviest pair weights for the maximum total weight (since the first and last marbles in the list are always included, we only need k-1 more partitions). Similarly, we take the k-1 lightest pair weights for the minimum total weight.\\n\\n9. The difference between these two sums gives us our final answer. \\n\\nI hope this breakdown helps clarify the problem and how to approach it! It\\'s a tricky one, so don\\'t worry if it doesn\\'t click right away.\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you check the editorial?\\nThe trick is to realize the question is actaully asking you to find where to cut(partition) the marbles, so you are looking for the boundaries between two adjacent marbles that have largest weights (for the maximun) and smallest weights (for the minimum)"
                    },
                    {
                        "username": "kenzgf",
                        "content": "And here I am coming up with memo + backtrack thinking I was so smart until getting annihilated with TLE :("
                    },
                    {
                        "username": "Kaltu",
                        "content": "the large constraint calls for O(n log n) solution. dp, backtracking with memoization can reach the correct answer but they take O(n^2)"
                    },
                    {
                        "username": "noman598",
                        "content": "Finding pattern of the problems is kind of unfair for beginner :)"
                    },
                    {
                        "username": "shah4772",
                        "content": "where can I get similar questions like this?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Ugh, stuck with these heavyweights! "
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "I don\\'t think the question forbids to do something like this:\\nSay we have 2 bags and we \\n1. put i1 to j1 marbles into 1st bag\\n2. put j1+1 to i2-1 marbles into 2nd bag\\n3. put i2 to j2 marbles into 1st bag again...."
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "It does. See the second condition:\\n`If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.`\\nSo accordingly, all marbles between i1 and j2 must be in 1st bag."
                    },
                    {
                        "username": "rickRicardo",
                        "content": "First and last bag will always have first and last marbles, respectively."
                    },
                    {
                        "username": "Kaltu",
                        "content": "and cancel out since we are finding the difference"
                    },
                    {
                        "username": "jason3410",
                        "content": "Imagine we\\'re finding the sum of the gap between each two bags. ie. Consider (bag[i].right+ bag[i+1].left)"
                    }
                ]
            },
            {
                "id": 1960632,
                "content": [
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Think of it this way, you have to partition the array in k different windows. Since you need all elements, the first and last elements will always be present in the sum. Now whenever you place a partition, the two elements adjacent to partition are added to the sum. So how would you maximize or minimize the sum. "
                    },
                    {
                        "username": "1byte",
                        "content": "Think about partitions instead of marbles."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "As a beginner can someone pls help me with finding the intution for this, all i can understand are: \\n->We have to do partitions according to some rule.\\n->The first and last element are the elements going in the beginning and last of the bag(s)..."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break it down:\\n\\n1. Problem understanding: You\\'re given a list of weights (marbles), and you\\'re allowed to make \\'k\\' partitions in this list. A partition means dividing the list into segments. Each segment will go into a separate bag. The weight of a bag is calculated as the sum of the weight of the first and last marble in the bag.\\n\\n2. Rule for partitions: You need to create the partitions such that you maximize the total weight of all the bags and also minimize the total weight of all the bags.\\n\\n3. The challenge: You have to return the difference between the maximum total weight and the minimum total weight.\\n\\nHere\\'s the key insight: \\n\\n4. Intuition: The first and last marble in the list will always contribute to the total weight (since they will always be the first and last marbles in some bag, no matter how you partition the list). Therefore, we need to think about what happens when we add a partition.\\n\\n5. When we create a partition, we essentially add a new bag. The weight of this new bag is the sum of the first and last marble in it, which are the marbles on either side of the partition in the original list.\\n\\n6. So to maximize the total weight, we want to put partitions next to the heaviest marbles. And to minimize the total weight, we want to put partitions next to the lightest marbles.\\n\\n7. With this intuition, we can create an array of pair weights (each pair is the weight of marbles on either side of a potential partition). Sorting this array, we get the marbles sorted by weight.\\n\\n8. Then we take the k-1 heaviest pair weights for the maximum total weight (since the first and last marbles in the list are always included, we only need k-1 more partitions). Similarly, we take the k-1 lightest pair weights for the minimum total weight.\\n\\n9. The difference between these two sums gives us our final answer. \\n\\nI hope this breakdown helps clarify the problem and how to approach it! It\\'s a tricky one, so don\\'t worry if it doesn\\'t click right away.\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you check the editorial?\\nThe trick is to realize the question is actaully asking you to find where to cut(partition) the marbles, so you are looking for the boundaries between two adjacent marbles that have largest weights (for the maximun) and smallest weights (for the minimum)"
                    },
                    {
                        "username": "kenzgf",
                        "content": "And here I am coming up with memo + backtrack thinking I was so smart until getting annihilated with TLE :("
                    },
                    {
                        "username": "Kaltu",
                        "content": "the large constraint calls for O(n log n) solution. dp, backtracking with memoization can reach the correct answer but they take O(n^2)"
                    },
                    {
                        "username": "noman598",
                        "content": "Finding pattern of the problems is kind of unfair for beginner :)"
                    },
                    {
                        "username": "shah4772",
                        "content": "where can I get similar questions like this?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Ugh, stuck with these heavyweights! "
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "I don\\'t think the question forbids to do something like this:\\nSay we have 2 bags and we \\n1. put i1 to j1 marbles into 1st bag\\n2. put j1+1 to i2-1 marbles into 2nd bag\\n3. put i2 to j2 marbles into 1st bag again...."
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "It does. See the second condition:\\n`If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.`\\nSo accordingly, all marbles between i1 and j2 must be in 1st bag."
                    },
                    {
                        "username": "rickRicardo",
                        "content": "First and last bag will always have first and last marbles, respectively."
                    },
                    {
                        "username": "Kaltu",
                        "content": "and cancel out since we are finding the difference"
                    },
                    {
                        "username": "jason3410",
                        "content": "Imagine we\\'re finding the sum of the gap between each two bags. ie. Consider (bag[i].right+ bag[i+1].left)"
                    }
                ]
            },
            {
                "id": 1960623,
                "content": [
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Think of it this way, you have to partition the array in k different windows. Since you need all elements, the first and last elements will always be present in the sum. Now whenever you place a partition, the two elements adjacent to partition are added to the sum. So how would you maximize or minimize the sum. "
                    },
                    {
                        "username": "1byte",
                        "content": "Think about partitions instead of marbles."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "As a beginner can someone pls help me with finding the intution for this, all i can understand are: \\n->We have to do partitions according to some rule.\\n->The first and last element are the elements going in the beginning and last of the bag(s)..."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break it down:\\n\\n1. Problem understanding: You\\'re given a list of weights (marbles), and you\\'re allowed to make \\'k\\' partitions in this list. A partition means dividing the list into segments. Each segment will go into a separate bag. The weight of a bag is calculated as the sum of the weight of the first and last marble in the bag.\\n\\n2. Rule for partitions: You need to create the partitions such that you maximize the total weight of all the bags and also minimize the total weight of all the bags.\\n\\n3. The challenge: You have to return the difference between the maximum total weight and the minimum total weight.\\n\\nHere\\'s the key insight: \\n\\n4. Intuition: The first and last marble in the list will always contribute to the total weight (since they will always be the first and last marbles in some bag, no matter how you partition the list). Therefore, we need to think about what happens when we add a partition.\\n\\n5. When we create a partition, we essentially add a new bag. The weight of this new bag is the sum of the first and last marble in it, which are the marbles on either side of the partition in the original list.\\n\\n6. So to maximize the total weight, we want to put partitions next to the heaviest marbles. And to minimize the total weight, we want to put partitions next to the lightest marbles.\\n\\n7. With this intuition, we can create an array of pair weights (each pair is the weight of marbles on either side of a potential partition). Sorting this array, we get the marbles sorted by weight.\\n\\n8. Then we take the k-1 heaviest pair weights for the maximum total weight (since the first and last marbles in the list are always included, we only need k-1 more partitions). Similarly, we take the k-1 lightest pair weights for the minimum total weight.\\n\\n9. The difference between these two sums gives us our final answer. \\n\\nI hope this breakdown helps clarify the problem and how to approach it! It\\'s a tricky one, so don\\'t worry if it doesn\\'t click right away.\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you check the editorial?\\nThe trick is to realize the question is actaully asking you to find where to cut(partition) the marbles, so you are looking for the boundaries between two adjacent marbles that have largest weights (for the maximun) and smallest weights (for the minimum)"
                    },
                    {
                        "username": "kenzgf",
                        "content": "And here I am coming up with memo + backtrack thinking I was so smart until getting annihilated with TLE :("
                    },
                    {
                        "username": "Kaltu",
                        "content": "the large constraint calls for O(n log n) solution. dp, backtracking with memoization can reach the correct answer but they take O(n^2)"
                    },
                    {
                        "username": "noman598",
                        "content": "Finding pattern of the problems is kind of unfair for beginner :)"
                    },
                    {
                        "username": "shah4772",
                        "content": "where can I get similar questions like this?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Ugh, stuck with these heavyweights! "
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "I don\\'t think the question forbids to do something like this:\\nSay we have 2 bags and we \\n1. put i1 to j1 marbles into 1st bag\\n2. put j1+1 to i2-1 marbles into 2nd bag\\n3. put i2 to j2 marbles into 1st bag again...."
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "It does. See the second condition:\\n`If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.`\\nSo accordingly, all marbles between i1 and j2 must be in 1st bag."
                    },
                    {
                        "username": "rickRicardo",
                        "content": "First and last bag will always have first and last marbles, respectively."
                    },
                    {
                        "username": "Kaltu",
                        "content": "and cancel out since we are finding the difference"
                    },
                    {
                        "username": "jason3410",
                        "content": "Imagine we\\'re finding the sum of the gap between each two bags. ie. Consider (bag[i].right+ bag[i+1].left)"
                    }
                ]
            },
            {
                "id": 1960613,
                "content": [
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Think of it this way, you have to partition the array in k different windows. Since you need all elements, the first and last elements will always be present in the sum. Now whenever you place a partition, the two elements adjacent to partition are added to the sum. So how would you maximize or minimize the sum. "
                    },
                    {
                        "username": "1byte",
                        "content": "Think about partitions instead of marbles."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "As a beginner can someone pls help me with finding the intution for this, all i can understand are: \\n->We have to do partitions according to some rule.\\n->The first and last element are the elements going in the beginning and last of the bag(s)..."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break it down:\\n\\n1. Problem understanding: You\\'re given a list of weights (marbles), and you\\'re allowed to make \\'k\\' partitions in this list. A partition means dividing the list into segments. Each segment will go into a separate bag. The weight of a bag is calculated as the sum of the weight of the first and last marble in the bag.\\n\\n2. Rule for partitions: You need to create the partitions such that you maximize the total weight of all the bags and also minimize the total weight of all the bags.\\n\\n3. The challenge: You have to return the difference between the maximum total weight and the minimum total weight.\\n\\nHere\\'s the key insight: \\n\\n4. Intuition: The first and last marble in the list will always contribute to the total weight (since they will always be the first and last marbles in some bag, no matter how you partition the list). Therefore, we need to think about what happens when we add a partition.\\n\\n5. When we create a partition, we essentially add a new bag. The weight of this new bag is the sum of the first and last marble in it, which are the marbles on either side of the partition in the original list.\\n\\n6. So to maximize the total weight, we want to put partitions next to the heaviest marbles. And to minimize the total weight, we want to put partitions next to the lightest marbles.\\n\\n7. With this intuition, we can create an array of pair weights (each pair is the weight of marbles on either side of a potential partition). Sorting this array, we get the marbles sorted by weight.\\n\\n8. Then we take the k-1 heaviest pair weights for the maximum total weight (since the first and last marbles in the list are always included, we only need k-1 more partitions). Similarly, we take the k-1 lightest pair weights for the minimum total weight.\\n\\n9. The difference between these two sums gives us our final answer. \\n\\nI hope this breakdown helps clarify the problem and how to approach it! It\\'s a tricky one, so don\\'t worry if it doesn\\'t click right away.\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you check the editorial?\\nThe trick is to realize the question is actaully asking you to find where to cut(partition) the marbles, so you are looking for the boundaries between two adjacent marbles that have largest weights (for the maximun) and smallest weights (for the minimum)"
                    },
                    {
                        "username": "kenzgf",
                        "content": "And here I am coming up with memo + backtrack thinking I was so smart until getting annihilated with TLE :("
                    },
                    {
                        "username": "Kaltu",
                        "content": "the large constraint calls for O(n log n) solution. dp, backtracking with memoization can reach the correct answer but they take O(n^2)"
                    },
                    {
                        "username": "noman598",
                        "content": "Finding pattern of the problems is kind of unfair for beginner :)"
                    },
                    {
                        "username": "shah4772",
                        "content": "where can I get similar questions like this?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Ugh, stuck with these heavyweights! "
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "I don\\'t think the question forbids to do something like this:\\nSay we have 2 bags and we \\n1. put i1 to j1 marbles into 1st bag\\n2. put j1+1 to i2-1 marbles into 2nd bag\\n3. put i2 to j2 marbles into 1st bag again...."
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "It does. See the second condition:\\n`If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.`\\nSo accordingly, all marbles between i1 and j2 must be in 1st bag."
                    },
                    {
                        "username": "rickRicardo",
                        "content": "First and last bag will always have first and last marbles, respectively."
                    },
                    {
                        "username": "Kaltu",
                        "content": "and cancel out since we are finding the difference"
                    },
                    {
                        "username": "jason3410",
                        "content": "Imagine we\\'re finding the sum of the gap between each two bags. ie. Consider (bag[i].right+ bag[i+1].left)"
                    }
                ]
            },
            {
                "id": 1960606,
                "content": [
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Think of it this way, you have to partition the array in k different windows. Since you need all elements, the first and last elements will always be present in the sum. Now whenever you place a partition, the two elements adjacent to partition are added to the sum. So how would you maximize or minimize the sum. "
                    },
                    {
                        "username": "1byte",
                        "content": "Think about partitions instead of marbles."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "As a beginner can someone pls help me with finding the intution for this, all i can understand are: \\n->We have to do partitions according to some rule.\\n->The first and last element are the elements going in the beginning and last of the bag(s)..."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break it down:\\n\\n1. Problem understanding: You\\'re given a list of weights (marbles), and you\\'re allowed to make \\'k\\' partitions in this list. A partition means dividing the list into segments. Each segment will go into a separate bag. The weight of a bag is calculated as the sum of the weight of the first and last marble in the bag.\\n\\n2. Rule for partitions: You need to create the partitions such that you maximize the total weight of all the bags and also minimize the total weight of all the bags.\\n\\n3. The challenge: You have to return the difference between the maximum total weight and the minimum total weight.\\n\\nHere\\'s the key insight: \\n\\n4. Intuition: The first and last marble in the list will always contribute to the total weight (since they will always be the first and last marbles in some bag, no matter how you partition the list). Therefore, we need to think about what happens when we add a partition.\\n\\n5. When we create a partition, we essentially add a new bag. The weight of this new bag is the sum of the first and last marble in it, which are the marbles on either side of the partition in the original list.\\n\\n6. So to maximize the total weight, we want to put partitions next to the heaviest marbles. And to minimize the total weight, we want to put partitions next to the lightest marbles.\\n\\n7. With this intuition, we can create an array of pair weights (each pair is the weight of marbles on either side of a potential partition). Sorting this array, we get the marbles sorted by weight.\\n\\n8. Then we take the k-1 heaviest pair weights for the maximum total weight (since the first and last marbles in the list are always included, we only need k-1 more partitions). Similarly, we take the k-1 lightest pair weights for the minimum total weight.\\n\\n9. The difference between these two sums gives us our final answer. \\n\\nI hope this breakdown helps clarify the problem and how to approach it! It\\'s a tricky one, so don\\'t worry if it doesn\\'t click right away.\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you check the editorial?\\nThe trick is to realize the question is actaully asking you to find where to cut(partition) the marbles, so you are looking for the boundaries between two adjacent marbles that have largest weights (for the maximun) and smallest weights (for the minimum)"
                    },
                    {
                        "username": "kenzgf",
                        "content": "And here I am coming up with memo + backtrack thinking I was so smart until getting annihilated with TLE :("
                    },
                    {
                        "username": "Kaltu",
                        "content": "the large constraint calls for O(n log n) solution. dp, backtracking with memoization can reach the correct answer but they take O(n^2)"
                    },
                    {
                        "username": "noman598",
                        "content": "Finding pattern of the problems is kind of unfair for beginner :)"
                    },
                    {
                        "username": "shah4772",
                        "content": "where can I get similar questions like this?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Ugh, stuck with these heavyweights! "
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "I don\\'t think the question forbids to do something like this:\\nSay we have 2 bags and we \\n1. put i1 to j1 marbles into 1st bag\\n2. put j1+1 to i2-1 marbles into 2nd bag\\n3. put i2 to j2 marbles into 1st bag again...."
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "It does. See the second condition:\\n`If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.`\\nSo accordingly, all marbles between i1 and j2 must be in 1st bag."
                    },
                    {
                        "username": "rickRicardo",
                        "content": "First and last bag will always have first and last marbles, respectively."
                    },
                    {
                        "username": "Kaltu",
                        "content": "and cancel out since we are finding the difference"
                    },
                    {
                        "username": "jason3410",
                        "content": "Imagine we\\'re finding the sum of the gap between each two bags. ie. Consider (bag[i].right+ bag[i+1].left)"
                    }
                ]
            },
            {
                "id": 1960600,
                "content": [
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Think of it this way, you have to partition the array in k different windows. Since you need all elements, the first and last elements will always be present in the sum. Now whenever you place a partition, the two elements adjacent to partition are added to the sum. So how would you maximize or minimize the sum. "
                    },
                    {
                        "username": "1byte",
                        "content": "Think about partitions instead of marbles."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "As a beginner can someone pls help me with finding the intution for this, all i can understand are: \\n->We have to do partitions according to some rule.\\n->The first and last element are the elements going in the beginning and last of the bag(s)..."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break it down:\\n\\n1. Problem understanding: You\\'re given a list of weights (marbles), and you\\'re allowed to make \\'k\\' partitions in this list. A partition means dividing the list into segments. Each segment will go into a separate bag. The weight of a bag is calculated as the sum of the weight of the first and last marble in the bag.\\n\\n2. Rule for partitions: You need to create the partitions such that you maximize the total weight of all the bags and also minimize the total weight of all the bags.\\n\\n3. The challenge: You have to return the difference between the maximum total weight and the minimum total weight.\\n\\nHere\\'s the key insight: \\n\\n4. Intuition: The first and last marble in the list will always contribute to the total weight (since they will always be the first and last marbles in some bag, no matter how you partition the list). Therefore, we need to think about what happens when we add a partition.\\n\\n5. When we create a partition, we essentially add a new bag. The weight of this new bag is the sum of the first and last marble in it, which are the marbles on either side of the partition in the original list.\\n\\n6. So to maximize the total weight, we want to put partitions next to the heaviest marbles. And to minimize the total weight, we want to put partitions next to the lightest marbles.\\n\\n7. With this intuition, we can create an array of pair weights (each pair is the weight of marbles on either side of a potential partition). Sorting this array, we get the marbles sorted by weight.\\n\\n8. Then we take the k-1 heaviest pair weights for the maximum total weight (since the first and last marbles in the list are always included, we only need k-1 more partitions). Similarly, we take the k-1 lightest pair weights for the minimum total weight.\\n\\n9. The difference between these two sums gives us our final answer. \\n\\nI hope this breakdown helps clarify the problem and how to approach it! It\\'s a tricky one, so don\\'t worry if it doesn\\'t click right away.\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you check the editorial?\\nThe trick is to realize the question is actaully asking you to find where to cut(partition) the marbles, so you are looking for the boundaries between two adjacent marbles that have largest weights (for the maximun) and smallest weights (for the minimum)"
                    },
                    {
                        "username": "kenzgf",
                        "content": "And here I am coming up with memo + backtrack thinking I was so smart until getting annihilated with TLE :("
                    },
                    {
                        "username": "Kaltu",
                        "content": "the large constraint calls for O(n log n) solution. dp, backtracking with memoization can reach the correct answer but they take O(n^2)"
                    },
                    {
                        "username": "noman598",
                        "content": "Finding pattern of the problems is kind of unfair for beginner :)"
                    },
                    {
                        "username": "shah4772",
                        "content": "where can I get similar questions like this?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Ugh, stuck with these heavyweights! "
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "I don\\'t think the question forbids to do something like this:\\nSay we have 2 bags and we \\n1. put i1 to j1 marbles into 1st bag\\n2. put j1+1 to i2-1 marbles into 2nd bag\\n3. put i2 to j2 marbles into 1st bag again...."
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "It does. See the second condition:\\n`If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.`\\nSo accordingly, all marbles between i1 and j2 must be in 1st bag."
                    },
                    {
                        "username": "rickRicardo",
                        "content": "First and last bag will always have first and last marbles, respectively."
                    },
                    {
                        "username": "Kaltu",
                        "content": "and cancel out since we are finding the difference"
                    },
                    {
                        "username": "jason3410",
                        "content": "Imagine we\\'re finding the sum of the gap between each two bags. ie. Consider (bag[i].right+ bag[i+1].left)"
                    }
                ]
            },
            {
                "id": 1960594,
                "content": [
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Think of it this way, you have to partition the array in k different windows. Since you need all elements, the first and last elements will always be present in the sum. Now whenever you place a partition, the two elements adjacent to partition are added to the sum. So how would you maximize or minimize the sum. "
                    },
                    {
                        "username": "1byte",
                        "content": "Think about partitions instead of marbles."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "As a beginner can someone pls help me with finding the intution for this, all i can understand are: \\n->We have to do partitions according to some rule.\\n->The first and last element are the elements going in the beginning and last of the bag(s)..."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break it down:\\n\\n1. Problem understanding: You\\'re given a list of weights (marbles), and you\\'re allowed to make \\'k\\' partitions in this list. A partition means dividing the list into segments. Each segment will go into a separate bag. The weight of a bag is calculated as the sum of the weight of the first and last marble in the bag.\\n\\n2. Rule for partitions: You need to create the partitions such that you maximize the total weight of all the bags and also minimize the total weight of all the bags.\\n\\n3. The challenge: You have to return the difference between the maximum total weight and the minimum total weight.\\n\\nHere\\'s the key insight: \\n\\n4. Intuition: The first and last marble in the list will always contribute to the total weight (since they will always be the first and last marbles in some bag, no matter how you partition the list). Therefore, we need to think about what happens when we add a partition.\\n\\n5. When we create a partition, we essentially add a new bag. The weight of this new bag is the sum of the first and last marble in it, which are the marbles on either side of the partition in the original list.\\n\\n6. So to maximize the total weight, we want to put partitions next to the heaviest marbles. And to minimize the total weight, we want to put partitions next to the lightest marbles.\\n\\n7. With this intuition, we can create an array of pair weights (each pair is the weight of marbles on either side of a potential partition). Sorting this array, we get the marbles sorted by weight.\\n\\n8. Then we take the k-1 heaviest pair weights for the maximum total weight (since the first and last marbles in the list are always included, we only need k-1 more partitions). Similarly, we take the k-1 lightest pair weights for the minimum total weight.\\n\\n9. The difference between these two sums gives us our final answer. \\n\\nI hope this breakdown helps clarify the problem and how to approach it! It\\'s a tricky one, so don\\'t worry if it doesn\\'t click right away.\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you check the editorial?\\nThe trick is to realize the question is actaully asking you to find where to cut(partition) the marbles, so you are looking for the boundaries between two adjacent marbles that have largest weights (for the maximun) and smallest weights (for the minimum)"
                    },
                    {
                        "username": "kenzgf",
                        "content": "And here I am coming up with memo + backtrack thinking I was so smart until getting annihilated with TLE :("
                    },
                    {
                        "username": "Kaltu",
                        "content": "the large constraint calls for O(n log n) solution. dp, backtracking with memoization can reach the correct answer but they take O(n^2)"
                    },
                    {
                        "username": "noman598",
                        "content": "Finding pattern of the problems is kind of unfair for beginner :)"
                    },
                    {
                        "username": "shah4772",
                        "content": "where can I get similar questions like this?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Ugh, stuck with these heavyweights! "
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "I don\\'t think the question forbids to do something like this:\\nSay we have 2 bags and we \\n1. put i1 to j1 marbles into 1st bag\\n2. put j1+1 to i2-1 marbles into 2nd bag\\n3. put i2 to j2 marbles into 1st bag again...."
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "It does. See the second condition:\\n`If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.`\\nSo accordingly, all marbles between i1 and j2 must be in 1st bag."
                    },
                    {
                        "username": "rickRicardo",
                        "content": "First and last bag will always have first and last marbles, respectively."
                    },
                    {
                        "username": "Kaltu",
                        "content": "and cancel out since we are finding the difference"
                    },
                    {
                        "username": "jason3410",
                        "content": "Imagine we\\'re finding the sum of the gap between each two bags. ie. Consider (bag[i].right+ bag[i+1].left)"
                    }
                ]
            },
            {
                "id": 1960581,
                "content": [
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Think of it this way, you have to partition the array in k different windows. Since you need all elements, the first and last elements will always be present in the sum. Now whenever you place a partition, the two elements adjacent to partition are added to the sum. So how would you maximize or minimize the sum. "
                    },
                    {
                        "username": "1byte",
                        "content": "Think about partitions instead of marbles."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "As a beginner can someone pls help me with finding the intution for this, all i can understand are: \\n->We have to do partitions according to some rule.\\n->The first and last element are the elements going in the beginning and last of the bag(s)..."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break it down:\\n\\n1. Problem understanding: You\\'re given a list of weights (marbles), and you\\'re allowed to make \\'k\\' partitions in this list. A partition means dividing the list into segments. Each segment will go into a separate bag. The weight of a bag is calculated as the sum of the weight of the first and last marble in the bag.\\n\\n2. Rule for partitions: You need to create the partitions such that you maximize the total weight of all the bags and also minimize the total weight of all the bags.\\n\\n3. The challenge: You have to return the difference between the maximum total weight and the minimum total weight.\\n\\nHere\\'s the key insight: \\n\\n4. Intuition: The first and last marble in the list will always contribute to the total weight (since they will always be the first and last marbles in some bag, no matter how you partition the list). Therefore, we need to think about what happens when we add a partition.\\n\\n5. When we create a partition, we essentially add a new bag. The weight of this new bag is the sum of the first and last marble in it, which are the marbles on either side of the partition in the original list.\\n\\n6. So to maximize the total weight, we want to put partitions next to the heaviest marbles. And to minimize the total weight, we want to put partitions next to the lightest marbles.\\n\\n7. With this intuition, we can create an array of pair weights (each pair is the weight of marbles on either side of a potential partition). Sorting this array, we get the marbles sorted by weight.\\n\\n8. Then we take the k-1 heaviest pair weights for the maximum total weight (since the first and last marbles in the list are always included, we only need k-1 more partitions). Similarly, we take the k-1 lightest pair weights for the minimum total weight.\\n\\n9. The difference between these two sums gives us our final answer. \\n\\nI hope this breakdown helps clarify the problem and how to approach it! It\\'s a tricky one, so don\\'t worry if it doesn\\'t click right away.\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you check the editorial?\\nThe trick is to realize the question is actaully asking you to find where to cut(partition) the marbles, so you are looking for the boundaries between two adjacent marbles that have largest weights (for the maximun) and smallest weights (for the minimum)"
                    },
                    {
                        "username": "kenzgf",
                        "content": "And here I am coming up with memo + backtrack thinking I was so smart until getting annihilated with TLE :("
                    },
                    {
                        "username": "Kaltu",
                        "content": "the large constraint calls for O(n log n) solution. dp, backtracking with memoization can reach the correct answer but they take O(n^2)"
                    },
                    {
                        "username": "noman598",
                        "content": "Finding pattern of the problems is kind of unfair for beginner :)"
                    },
                    {
                        "username": "shah4772",
                        "content": "where can I get similar questions like this?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Ugh, stuck with these heavyweights! "
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "I don\\'t think the question forbids to do something like this:\\nSay we have 2 bags and we \\n1. put i1 to j1 marbles into 1st bag\\n2. put j1+1 to i2-1 marbles into 2nd bag\\n3. put i2 to j2 marbles into 1st bag again...."
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "It does. See the second condition:\\n`If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.`\\nSo accordingly, all marbles between i1 and j2 must be in 1st bag."
                    },
                    {
                        "username": "rickRicardo",
                        "content": "First and last bag will always have first and last marbles, respectively."
                    },
                    {
                        "username": "Kaltu",
                        "content": "and cancel out since we are finding the difference"
                    },
                    {
                        "username": "jason3410",
                        "content": "Imagine we\\'re finding the sum of the gap between each two bags. ie. Consider (bag[i].right+ bag[i+1].left)"
                    }
                ]
            },
            {
                "id": 1960580,
                "content": [
                    {
                        "username": "anxiousLeetcoder",
                        "content": "Think of it this way, you have to partition the array in k different windows. Since you need all elements, the first and last elements will always be present in the sum. Now whenever you place a partition, the two elements adjacent to partition are added to the sum. So how would you maximize or minimize the sum. "
                    },
                    {
                        "username": "1byte",
                        "content": "Think about partitions instead of marbles."
                    },
                    {
                        "username": "ashurockzz",
                        "content": "As a beginner can someone pls help me with finding the intution for this, all i can understand are: \\n->We have to do partitions according to some rule.\\n->The first and last element are the elements going in the beginning and last of the bag(s)..."
                    },
                    {
                        "username": "bparanj",
                        "content": "Let\\'s break it down:\\n\\n1. Problem understanding: You\\'re given a list of weights (marbles), and you\\'re allowed to make \\'k\\' partitions in this list. A partition means dividing the list into segments. Each segment will go into a separate bag. The weight of a bag is calculated as the sum of the weight of the first and last marble in the bag.\\n\\n2. Rule for partitions: You need to create the partitions such that you maximize the total weight of all the bags and also minimize the total weight of all the bags.\\n\\n3. The challenge: You have to return the difference between the maximum total weight and the minimum total weight.\\n\\nHere\\'s the key insight: \\n\\n4. Intuition: The first and last marble in the list will always contribute to the total weight (since they will always be the first and last marbles in some bag, no matter how you partition the list). Therefore, we need to think about what happens when we add a partition.\\n\\n5. When we create a partition, we essentially add a new bag. The weight of this new bag is the sum of the first and last marble in it, which are the marbles on either side of the partition in the original list.\\n\\n6. So to maximize the total weight, we want to put partitions next to the heaviest marbles. And to minimize the total weight, we want to put partitions next to the lightest marbles.\\n\\n7. With this intuition, we can create an array of pair weights (each pair is the weight of marbles on either side of a potential partition). Sorting this array, we get the marbles sorted by weight.\\n\\n8. Then we take the k-1 heaviest pair weights for the maximum total weight (since the first and last marbles in the list are always included, we only need k-1 more partitions). Similarly, we take the k-1 lightest pair weights for the minimum total weight.\\n\\n9. The difference between these two sums gives us our final answer. \\n\\nI hope this breakdown helps clarify the problem and how to approach it! It\\'s a tricky one, so don\\'t worry if it doesn\\'t click right away.\\n"
                    },
                    {
                        "username": "Kaltu",
                        "content": "Did you check the editorial?\\nThe trick is to realize the question is actaully asking you to find where to cut(partition) the marbles, so you are looking for the boundaries between two adjacent marbles that have largest weights (for the maximun) and smallest weights (for the minimum)"
                    },
                    {
                        "username": "kenzgf",
                        "content": "And here I am coming up with memo + backtrack thinking I was so smart until getting annihilated with TLE :("
                    },
                    {
                        "username": "Kaltu",
                        "content": "the large constraint calls for O(n log n) solution. dp, backtracking with memoization can reach the correct answer but they take O(n^2)"
                    },
                    {
                        "username": "noman598",
                        "content": "Finding pattern of the problems is kind of unfair for beginner :)"
                    },
                    {
                        "username": "shah4772",
                        "content": "where can I get similar questions like this?"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "Ugh, stuck with these heavyweights! "
                    },
                    {
                        "username": "Imqqqqq",
                        "content": "I don\\'t think the question forbids to do something like this:\\nSay we have 2 bags and we \\n1. put i1 to j1 marbles into 1st bag\\n2. put j1+1 to i2-1 marbles into 2nd bag\\n3. put i2 to j2 marbles into 1st bag again...."
                    },
                    {
                        "username": "letsdotutsheet",
                        "content": "It does. See the second condition:\\n`If the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.`\\nSo accordingly, all marbles between i1 and j2 must be in 1st bag."
                    },
                    {
                        "username": "rickRicardo",
                        "content": "First and last bag will always have first and last marbles, respectively."
                    },
                    {
                        "username": "Kaltu",
                        "content": "and cancel out since we are finding the difference"
                    },
                    {
                        "username": "jason3410",
                        "content": "Imagine we\\'re finding the sum of the gap between each two bags. ie. Consider (bag[i].right+ bag[i+1].left)"
                    }
                ]
            },
            {
                "id": 1960492,
                "content": [
                    {
                        "username": "bee365go",
                        "content": "use `long int` to avoid Runtime Error"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Is it look Similar to Book Allocation and Painter\\'s Partition Problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "While the Book Allocation and Painter\\'s Partition Problems do share similarities with this problem in that they involve partitioning a given set into subsets, they are not exactly similar. \\n\\nIn the Book Allocation and Painter\\'s Partition Problems, you\\'re trying to partition a set into k subsets such that the sum of the values in each subset is minimized or maximized. This often involves binary search and dynamic programming.\\n\\nIn this problem, however, you are partitioning the array into bags (subsets), but the way the \"cost\" of each subset is determined (by the sum of the first and last elements) is quite different. Also, you are interested in the difference between the maximum and minimum possible total \"costs\" rather than simply maximizing or minimizing a sum.\\n\\nSo, while the problems are similar in the sense that they involve partitioning a set, the specifics of how this is done and what is being optimized are different."
                    },
                    {
                        "username": "jswang00037",
                        "content": "HARD WEEKEND again"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A very interesting question requires a small epiphany."
                    },
                    {
                        "username": "shivansh157",
                        "content": "How to get the intuition for solving this ??"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Once you have realised that DP won\\'t work, you know there has to be a mathematical trick.  At that point, look at the simplest case (in this case k bags) and work out the answer for that (= 0).  Then see what happens when you add 1 level of complexity (ie. another bad).  What does that to the solution.  What happens when we add a second level.  Can we work out the rule that gives us the answer with n extra bags?"
                    },
                    {
                        "username": "abhi2616",
                        "content": "this test case will fail\\narr=1,3,1,2\\nk=2\\nwith this approach(in solution section) we will get ans=1\\nbut actually it is 3"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "You have 3 possible divisions:\\n[1] + [3,1,2] score = 2+5=7\\n[1,3] + [1,2] score = 4+3=7\\n[1,3,1] + [2] score = 2+4=6 (2 is counted twice)\\nso ans = 1 is correct"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can anyone share DP solution (TLE one)?"
                    },
                    {
                        "username": "alin99",
                        "content": "Here\\'s a crude implementation.  Basically, use backtracking to add the marbles to ```k``` bags.  When the last bag is reached, dump the remaining marbles into it.  Once all bags are filled, compute the maxSum and minSum for all bags.  Finally, return the difference between them.\\n\\n```\\nvar putMarbles = function(weights, k) {\\n    const {minSum, maxSum} = solve(weights, k, 0, {});\\n    return maxSum - minSum;\\n};\\n\\nconst solve = (weights, k, start, memo) => {\\n    if (k === 0) {\\n        return {minSum: 0, maxSum: 0};\\n    }\\n    \\n    const key = `${k},${start}`;\\n    if (key in memo) {\\n        return memo[key];\\n    }\\n\\n    const bag = [];\\n    let min = Infinity;\\n    let max = -Infinity;\\n    for (let i = start; i < weights.length; i++) {\\n        if (k === 1) {\\n            bag.push(...weights.slice(i));\\n            i = weights.length;\\n        } else {\\n            bag.push(weights[i]);\\n        }\\n        const bagSum = bag[0] + bag[bag.length - 1];\\n        const {minSum, maxSum} = solve(weights, k - 1, i + 1, memo);\\n        min = Math.min(min, bagSum + minSum);\\n        max = Math.max(max, bagSum + maxSum);\\n    }\\n\\n    memo[key] = {minSum: min, maxSum: max};\\n    return memo[key];\\n}\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why for testcase [54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72], k = 4\\n243 is wrong?"
                    },
                    {
                        "username": "math3846",
                        "content": "289 is right.\nmax score: [54,6,34,66], [63,52,39,62,46], [75,28,65,18,37,18,13,33,69,19,40,13,10,43,61], [72]\nmin score: [54,6], [34,66,63,52,39,62,46,75,28,65,18,37,18], [13,33,69,19,40,13], [10,43,61,72]"
                    },
                    {
                        "username": "Lorins",
                        "content": "Hard? I think not\n\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        pos = sorted([weights[i] + weights[i + 1] for i in range(len(weights) - 1)])\n        return 0 if k == 1 else sum(pos[-1 * k + 1:]) - sum(pos[:k - 1])\n\nTwo liner"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Can bag be empty?\\n[1,2,3,3,5,6,7,8,9]\\nk=2;\\nhow the the answer is 17? can anyone explain"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Kaltu](/Kaltu) got it thank you It's 14 i wrote  17 by mistake"
                    },
                    {
                        "username": "Kaltu",
                        "content": "I copy paste it to the testcase and leetcode says the exapected answer is 14 not 17\nwhich is true becasue\n[[1,2,3,3,5,6,7,8], [9]] => (1 + 8) + (9 + 9) = 27\n[[1], [2,3,3,5,6,7,8,9]] => (1 + 1) + (2 + 9) = 13\n27 - 13 = 14"
                    }
                ]
            },
            {
                "id": 1960471,
                "content": [
                    {
                        "username": "bee365go",
                        "content": "use `long int` to avoid Runtime Error"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Is it look Similar to Book Allocation and Painter\\'s Partition Problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "While the Book Allocation and Painter\\'s Partition Problems do share similarities with this problem in that they involve partitioning a given set into subsets, they are not exactly similar. \\n\\nIn the Book Allocation and Painter\\'s Partition Problems, you\\'re trying to partition a set into k subsets such that the sum of the values in each subset is minimized or maximized. This often involves binary search and dynamic programming.\\n\\nIn this problem, however, you are partitioning the array into bags (subsets), but the way the \"cost\" of each subset is determined (by the sum of the first and last elements) is quite different. Also, you are interested in the difference between the maximum and minimum possible total \"costs\" rather than simply maximizing or minimizing a sum.\\n\\nSo, while the problems are similar in the sense that they involve partitioning a set, the specifics of how this is done and what is being optimized are different."
                    },
                    {
                        "username": "jswang00037",
                        "content": "HARD WEEKEND again"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A very interesting question requires a small epiphany."
                    },
                    {
                        "username": "shivansh157",
                        "content": "How to get the intuition for solving this ??"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Once you have realised that DP won\\'t work, you know there has to be a mathematical trick.  At that point, look at the simplest case (in this case k bags) and work out the answer for that (= 0).  Then see what happens when you add 1 level of complexity (ie. another bad).  What does that to the solution.  What happens when we add a second level.  Can we work out the rule that gives us the answer with n extra bags?"
                    },
                    {
                        "username": "abhi2616",
                        "content": "this test case will fail\\narr=1,3,1,2\\nk=2\\nwith this approach(in solution section) we will get ans=1\\nbut actually it is 3"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "You have 3 possible divisions:\\n[1] + [3,1,2] score = 2+5=7\\n[1,3] + [1,2] score = 4+3=7\\n[1,3,1] + [2] score = 2+4=6 (2 is counted twice)\\nso ans = 1 is correct"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can anyone share DP solution (TLE one)?"
                    },
                    {
                        "username": "alin99",
                        "content": "Here\\'s a crude implementation.  Basically, use backtracking to add the marbles to ```k``` bags.  When the last bag is reached, dump the remaining marbles into it.  Once all bags are filled, compute the maxSum and minSum for all bags.  Finally, return the difference between them.\\n\\n```\\nvar putMarbles = function(weights, k) {\\n    const {minSum, maxSum} = solve(weights, k, 0, {});\\n    return maxSum - minSum;\\n};\\n\\nconst solve = (weights, k, start, memo) => {\\n    if (k === 0) {\\n        return {minSum: 0, maxSum: 0};\\n    }\\n    \\n    const key = `${k},${start}`;\\n    if (key in memo) {\\n        return memo[key];\\n    }\\n\\n    const bag = [];\\n    let min = Infinity;\\n    let max = -Infinity;\\n    for (let i = start; i < weights.length; i++) {\\n        if (k === 1) {\\n            bag.push(...weights.slice(i));\\n            i = weights.length;\\n        } else {\\n            bag.push(weights[i]);\\n        }\\n        const bagSum = bag[0] + bag[bag.length - 1];\\n        const {minSum, maxSum} = solve(weights, k - 1, i + 1, memo);\\n        min = Math.min(min, bagSum + minSum);\\n        max = Math.max(max, bagSum + maxSum);\\n    }\\n\\n    memo[key] = {minSum: min, maxSum: max};\\n    return memo[key];\\n}\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why for testcase [54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72], k = 4\\n243 is wrong?"
                    },
                    {
                        "username": "math3846",
                        "content": "289 is right.\nmax score: [54,6,34,66], [63,52,39,62,46], [75,28,65,18,37,18,13,33,69,19,40,13,10,43,61], [72]\nmin score: [54,6], [34,66,63,52,39,62,46,75,28,65,18,37,18], [13,33,69,19,40,13], [10,43,61,72]"
                    },
                    {
                        "username": "Lorins",
                        "content": "Hard? I think not\n\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        pos = sorted([weights[i] + weights[i + 1] for i in range(len(weights) - 1)])\n        return 0 if k == 1 else sum(pos[-1 * k + 1:]) - sum(pos[:k - 1])\n\nTwo liner"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Can bag be empty?\\n[1,2,3,3,5,6,7,8,9]\\nk=2;\\nhow the the answer is 17? can anyone explain"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Kaltu](/Kaltu) got it thank you It's 14 i wrote  17 by mistake"
                    },
                    {
                        "username": "Kaltu",
                        "content": "I copy paste it to the testcase and leetcode says the exapected answer is 14 not 17\nwhich is true becasue\n[[1,2,3,3,5,6,7,8], [9]] => (1 + 8) + (9 + 9) = 27\n[[1], [2,3,3,5,6,7,8,9]] => (1 + 1) + (2 + 9) = 13\n27 - 13 = 14"
                    }
                ]
            },
            {
                "id": 1960467,
                "content": [
                    {
                        "username": "bee365go",
                        "content": "use `long int` to avoid Runtime Error"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Is it look Similar to Book Allocation and Painter\\'s Partition Problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "While the Book Allocation and Painter\\'s Partition Problems do share similarities with this problem in that they involve partitioning a given set into subsets, they are not exactly similar. \\n\\nIn the Book Allocation and Painter\\'s Partition Problems, you\\'re trying to partition a set into k subsets such that the sum of the values in each subset is minimized or maximized. This often involves binary search and dynamic programming.\\n\\nIn this problem, however, you are partitioning the array into bags (subsets), but the way the \"cost\" of each subset is determined (by the sum of the first and last elements) is quite different. Also, you are interested in the difference between the maximum and minimum possible total \"costs\" rather than simply maximizing or minimizing a sum.\\n\\nSo, while the problems are similar in the sense that they involve partitioning a set, the specifics of how this is done and what is being optimized are different."
                    },
                    {
                        "username": "jswang00037",
                        "content": "HARD WEEKEND again"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A very interesting question requires a small epiphany."
                    },
                    {
                        "username": "shivansh157",
                        "content": "How to get the intuition for solving this ??"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Once you have realised that DP won\\'t work, you know there has to be a mathematical trick.  At that point, look at the simplest case (in this case k bags) and work out the answer for that (= 0).  Then see what happens when you add 1 level of complexity (ie. another bad).  What does that to the solution.  What happens when we add a second level.  Can we work out the rule that gives us the answer with n extra bags?"
                    },
                    {
                        "username": "abhi2616",
                        "content": "this test case will fail\\narr=1,3,1,2\\nk=2\\nwith this approach(in solution section) we will get ans=1\\nbut actually it is 3"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "You have 3 possible divisions:\\n[1] + [3,1,2] score = 2+5=7\\n[1,3] + [1,2] score = 4+3=7\\n[1,3,1] + [2] score = 2+4=6 (2 is counted twice)\\nso ans = 1 is correct"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can anyone share DP solution (TLE one)?"
                    },
                    {
                        "username": "alin99",
                        "content": "Here\\'s a crude implementation.  Basically, use backtracking to add the marbles to ```k``` bags.  When the last bag is reached, dump the remaining marbles into it.  Once all bags are filled, compute the maxSum and minSum for all bags.  Finally, return the difference between them.\\n\\n```\\nvar putMarbles = function(weights, k) {\\n    const {minSum, maxSum} = solve(weights, k, 0, {});\\n    return maxSum - minSum;\\n};\\n\\nconst solve = (weights, k, start, memo) => {\\n    if (k === 0) {\\n        return {minSum: 0, maxSum: 0};\\n    }\\n    \\n    const key = `${k},${start}`;\\n    if (key in memo) {\\n        return memo[key];\\n    }\\n\\n    const bag = [];\\n    let min = Infinity;\\n    let max = -Infinity;\\n    for (let i = start; i < weights.length; i++) {\\n        if (k === 1) {\\n            bag.push(...weights.slice(i));\\n            i = weights.length;\\n        } else {\\n            bag.push(weights[i]);\\n        }\\n        const bagSum = bag[0] + bag[bag.length - 1];\\n        const {minSum, maxSum} = solve(weights, k - 1, i + 1, memo);\\n        min = Math.min(min, bagSum + minSum);\\n        max = Math.max(max, bagSum + maxSum);\\n    }\\n\\n    memo[key] = {minSum: min, maxSum: max};\\n    return memo[key];\\n}\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why for testcase [54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72], k = 4\\n243 is wrong?"
                    },
                    {
                        "username": "math3846",
                        "content": "289 is right.\nmax score: [54,6,34,66], [63,52,39,62,46], [75,28,65,18,37,18,13,33,69,19,40,13,10,43,61], [72]\nmin score: [54,6], [34,66,63,52,39,62,46,75,28,65,18,37,18], [13,33,69,19,40,13], [10,43,61,72]"
                    },
                    {
                        "username": "Lorins",
                        "content": "Hard? I think not\n\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        pos = sorted([weights[i] + weights[i + 1] for i in range(len(weights) - 1)])\n        return 0 if k == 1 else sum(pos[-1 * k + 1:]) - sum(pos[:k - 1])\n\nTwo liner"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Can bag be empty?\\n[1,2,3,3,5,6,7,8,9]\\nk=2;\\nhow the the answer is 17? can anyone explain"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Kaltu](/Kaltu) got it thank you It's 14 i wrote  17 by mistake"
                    },
                    {
                        "username": "Kaltu",
                        "content": "I copy paste it to the testcase and leetcode says the exapected answer is 14 not 17\nwhich is true becasue\n[[1,2,3,3,5,6,7,8], [9]] => (1 + 8) + (9 + 9) = 27\n[[1], [2,3,3,5,6,7,8,9]] => (1 + 1) + (2 + 9) = 13\n27 - 13 = 14"
                    }
                ]
            },
            {
                "id": 1899349,
                "content": [
                    {
                        "username": "bee365go",
                        "content": "use `long int` to avoid Runtime Error"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Is it look Similar to Book Allocation and Painter\\'s Partition Problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "While the Book Allocation and Painter\\'s Partition Problems do share similarities with this problem in that they involve partitioning a given set into subsets, they are not exactly similar. \\n\\nIn the Book Allocation and Painter\\'s Partition Problems, you\\'re trying to partition a set into k subsets such that the sum of the values in each subset is minimized or maximized. This often involves binary search and dynamic programming.\\n\\nIn this problem, however, you are partitioning the array into bags (subsets), but the way the \"cost\" of each subset is determined (by the sum of the first and last elements) is quite different. Also, you are interested in the difference between the maximum and minimum possible total \"costs\" rather than simply maximizing or minimizing a sum.\\n\\nSo, while the problems are similar in the sense that they involve partitioning a set, the specifics of how this is done and what is being optimized are different."
                    },
                    {
                        "username": "jswang00037",
                        "content": "HARD WEEKEND again"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A very interesting question requires a small epiphany."
                    },
                    {
                        "username": "shivansh157",
                        "content": "How to get the intuition for solving this ??"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Once you have realised that DP won\\'t work, you know there has to be a mathematical trick.  At that point, look at the simplest case (in this case k bags) and work out the answer for that (= 0).  Then see what happens when you add 1 level of complexity (ie. another bad).  What does that to the solution.  What happens when we add a second level.  Can we work out the rule that gives us the answer with n extra bags?"
                    },
                    {
                        "username": "abhi2616",
                        "content": "this test case will fail\\narr=1,3,1,2\\nk=2\\nwith this approach(in solution section) we will get ans=1\\nbut actually it is 3"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "You have 3 possible divisions:\\n[1] + [3,1,2] score = 2+5=7\\n[1,3] + [1,2] score = 4+3=7\\n[1,3,1] + [2] score = 2+4=6 (2 is counted twice)\\nso ans = 1 is correct"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can anyone share DP solution (TLE one)?"
                    },
                    {
                        "username": "alin99",
                        "content": "Here\\'s a crude implementation.  Basically, use backtracking to add the marbles to ```k``` bags.  When the last bag is reached, dump the remaining marbles into it.  Once all bags are filled, compute the maxSum and minSum for all bags.  Finally, return the difference between them.\\n\\n```\\nvar putMarbles = function(weights, k) {\\n    const {minSum, maxSum} = solve(weights, k, 0, {});\\n    return maxSum - minSum;\\n};\\n\\nconst solve = (weights, k, start, memo) => {\\n    if (k === 0) {\\n        return {minSum: 0, maxSum: 0};\\n    }\\n    \\n    const key = `${k},${start}`;\\n    if (key in memo) {\\n        return memo[key];\\n    }\\n\\n    const bag = [];\\n    let min = Infinity;\\n    let max = -Infinity;\\n    for (let i = start; i < weights.length; i++) {\\n        if (k === 1) {\\n            bag.push(...weights.slice(i));\\n            i = weights.length;\\n        } else {\\n            bag.push(weights[i]);\\n        }\\n        const bagSum = bag[0] + bag[bag.length - 1];\\n        const {minSum, maxSum} = solve(weights, k - 1, i + 1, memo);\\n        min = Math.min(min, bagSum + minSum);\\n        max = Math.max(max, bagSum + maxSum);\\n    }\\n\\n    memo[key] = {minSum: min, maxSum: max};\\n    return memo[key];\\n}\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why for testcase [54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72], k = 4\\n243 is wrong?"
                    },
                    {
                        "username": "math3846",
                        "content": "289 is right.\nmax score: [54,6,34,66], [63,52,39,62,46], [75,28,65,18,37,18,13,33,69,19,40,13,10,43,61], [72]\nmin score: [54,6], [34,66,63,52,39,62,46,75,28,65,18,37,18], [13,33,69,19,40,13], [10,43,61,72]"
                    },
                    {
                        "username": "Lorins",
                        "content": "Hard? I think not\n\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        pos = sorted([weights[i] + weights[i + 1] for i in range(len(weights) - 1)])\n        return 0 if k == 1 else sum(pos[-1 * k + 1:]) - sum(pos[:k - 1])\n\nTwo liner"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Can bag be empty?\\n[1,2,3,3,5,6,7,8,9]\\nk=2;\\nhow the the answer is 17? can anyone explain"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Kaltu](/Kaltu) got it thank you It's 14 i wrote  17 by mistake"
                    },
                    {
                        "username": "Kaltu",
                        "content": "I copy paste it to the testcase and leetcode says the exapected answer is 14 not 17\nwhich is true becasue\n[[1,2,3,3,5,6,7,8], [9]] => (1 + 8) + (9 + 9) = 27\n[[1], [2,3,3,5,6,7,8,9]] => (1 + 1) + (2 + 9) = 13\n27 - 13 = 14"
                    }
                ]
            },
            {
                "id": 1795720,
                "content": [
                    {
                        "username": "bee365go",
                        "content": "use `long int` to avoid Runtime Error"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Is it look Similar to Book Allocation and Painter\\'s Partition Problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "While the Book Allocation and Painter\\'s Partition Problems do share similarities with this problem in that they involve partitioning a given set into subsets, they are not exactly similar. \\n\\nIn the Book Allocation and Painter\\'s Partition Problems, you\\'re trying to partition a set into k subsets such that the sum of the values in each subset is minimized or maximized. This often involves binary search and dynamic programming.\\n\\nIn this problem, however, you are partitioning the array into bags (subsets), but the way the \"cost\" of each subset is determined (by the sum of the first and last elements) is quite different. Also, you are interested in the difference between the maximum and minimum possible total \"costs\" rather than simply maximizing or minimizing a sum.\\n\\nSo, while the problems are similar in the sense that they involve partitioning a set, the specifics of how this is done and what is being optimized are different."
                    },
                    {
                        "username": "jswang00037",
                        "content": "HARD WEEKEND again"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A very interesting question requires a small epiphany."
                    },
                    {
                        "username": "shivansh157",
                        "content": "How to get the intuition for solving this ??"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Once you have realised that DP won\\'t work, you know there has to be a mathematical trick.  At that point, look at the simplest case (in this case k bags) and work out the answer for that (= 0).  Then see what happens when you add 1 level of complexity (ie. another bad).  What does that to the solution.  What happens when we add a second level.  Can we work out the rule that gives us the answer with n extra bags?"
                    },
                    {
                        "username": "abhi2616",
                        "content": "this test case will fail\\narr=1,3,1,2\\nk=2\\nwith this approach(in solution section) we will get ans=1\\nbut actually it is 3"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "You have 3 possible divisions:\\n[1] + [3,1,2] score = 2+5=7\\n[1,3] + [1,2] score = 4+3=7\\n[1,3,1] + [2] score = 2+4=6 (2 is counted twice)\\nso ans = 1 is correct"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can anyone share DP solution (TLE one)?"
                    },
                    {
                        "username": "alin99",
                        "content": "Here\\'s a crude implementation.  Basically, use backtracking to add the marbles to ```k``` bags.  When the last bag is reached, dump the remaining marbles into it.  Once all bags are filled, compute the maxSum and minSum for all bags.  Finally, return the difference between them.\\n\\n```\\nvar putMarbles = function(weights, k) {\\n    const {minSum, maxSum} = solve(weights, k, 0, {});\\n    return maxSum - minSum;\\n};\\n\\nconst solve = (weights, k, start, memo) => {\\n    if (k === 0) {\\n        return {minSum: 0, maxSum: 0};\\n    }\\n    \\n    const key = `${k},${start}`;\\n    if (key in memo) {\\n        return memo[key];\\n    }\\n\\n    const bag = [];\\n    let min = Infinity;\\n    let max = -Infinity;\\n    for (let i = start; i < weights.length; i++) {\\n        if (k === 1) {\\n            bag.push(...weights.slice(i));\\n            i = weights.length;\\n        } else {\\n            bag.push(weights[i]);\\n        }\\n        const bagSum = bag[0] + bag[bag.length - 1];\\n        const {minSum, maxSum} = solve(weights, k - 1, i + 1, memo);\\n        min = Math.min(min, bagSum + minSum);\\n        max = Math.max(max, bagSum + maxSum);\\n    }\\n\\n    memo[key] = {minSum: min, maxSum: max};\\n    return memo[key];\\n}\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why for testcase [54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72], k = 4\\n243 is wrong?"
                    },
                    {
                        "username": "math3846",
                        "content": "289 is right.\nmax score: [54,6,34,66], [63,52,39,62,46], [75,28,65,18,37,18,13,33,69,19,40,13,10,43,61], [72]\nmin score: [54,6], [34,66,63,52,39,62,46,75,28,65,18,37,18], [13,33,69,19,40,13], [10,43,61,72]"
                    },
                    {
                        "username": "Lorins",
                        "content": "Hard? I think not\n\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        pos = sorted([weights[i] + weights[i + 1] for i in range(len(weights) - 1)])\n        return 0 if k == 1 else sum(pos[-1 * k + 1:]) - sum(pos[:k - 1])\n\nTwo liner"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Can bag be empty?\\n[1,2,3,3,5,6,7,8,9]\\nk=2;\\nhow the the answer is 17? can anyone explain"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Kaltu](/Kaltu) got it thank you It's 14 i wrote  17 by mistake"
                    },
                    {
                        "username": "Kaltu",
                        "content": "I copy paste it to the testcase and leetcode says the exapected answer is 14 not 17\nwhich is true becasue\n[[1,2,3,3,5,6,7,8], [9]] => (1 + 8) + (9 + 9) = 27\n[[1], [2,3,3,5,6,7,8,9]] => (1 + 1) + (2 + 9) = 13\n27 - 13 = 14"
                    }
                ]
            },
            {
                "id": 1789381,
                "content": [
                    {
                        "username": "bee365go",
                        "content": "use `long int` to avoid Runtime Error"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Is it look Similar to Book Allocation and Painter\\'s Partition Problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "While the Book Allocation and Painter\\'s Partition Problems do share similarities with this problem in that they involve partitioning a given set into subsets, they are not exactly similar. \\n\\nIn the Book Allocation and Painter\\'s Partition Problems, you\\'re trying to partition a set into k subsets such that the sum of the values in each subset is minimized or maximized. This often involves binary search and dynamic programming.\\n\\nIn this problem, however, you are partitioning the array into bags (subsets), but the way the \"cost\" of each subset is determined (by the sum of the first and last elements) is quite different. Also, you are interested in the difference between the maximum and minimum possible total \"costs\" rather than simply maximizing or minimizing a sum.\\n\\nSo, while the problems are similar in the sense that they involve partitioning a set, the specifics of how this is done and what is being optimized are different."
                    },
                    {
                        "username": "jswang00037",
                        "content": "HARD WEEKEND again"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A very interesting question requires a small epiphany."
                    },
                    {
                        "username": "shivansh157",
                        "content": "How to get the intuition for solving this ??"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Once you have realised that DP won\\'t work, you know there has to be a mathematical trick.  At that point, look at the simplest case (in this case k bags) and work out the answer for that (= 0).  Then see what happens when you add 1 level of complexity (ie. another bad).  What does that to the solution.  What happens when we add a second level.  Can we work out the rule that gives us the answer with n extra bags?"
                    },
                    {
                        "username": "abhi2616",
                        "content": "this test case will fail\\narr=1,3,1,2\\nk=2\\nwith this approach(in solution section) we will get ans=1\\nbut actually it is 3"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "You have 3 possible divisions:\\n[1] + [3,1,2] score = 2+5=7\\n[1,3] + [1,2] score = 4+3=7\\n[1,3,1] + [2] score = 2+4=6 (2 is counted twice)\\nso ans = 1 is correct"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can anyone share DP solution (TLE one)?"
                    },
                    {
                        "username": "alin99",
                        "content": "Here\\'s a crude implementation.  Basically, use backtracking to add the marbles to ```k``` bags.  When the last bag is reached, dump the remaining marbles into it.  Once all bags are filled, compute the maxSum and minSum for all bags.  Finally, return the difference between them.\\n\\n```\\nvar putMarbles = function(weights, k) {\\n    const {minSum, maxSum} = solve(weights, k, 0, {});\\n    return maxSum - minSum;\\n};\\n\\nconst solve = (weights, k, start, memo) => {\\n    if (k === 0) {\\n        return {minSum: 0, maxSum: 0};\\n    }\\n    \\n    const key = `${k},${start}`;\\n    if (key in memo) {\\n        return memo[key];\\n    }\\n\\n    const bag = [];\\n    let min = Infinity;\\n    let max = -Infinity;\\n    for (let i = start; i < weights.length; i++) {\\n        if (k === 1) {\\n            bag.push(...weights.slice(i));\\n            i = weights.length;\\n        } else {\\n            bag.push(weights[i]);\\n        }\\n        const bagSum = bag[0] + bag[bag.length - 1];\\n        const {minSum, maxSum} = solve(weights, k - 1, i + 1, memo);\\n        min = Math.min(min, bagSum + minSum);\\n        max = Math.max(max, bagSum + maxSum);\\n    }\\n\\n    memo[key] = {minSum: min, maxSum: max};\\n    return memo[key];\\n}\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why for testcase [54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72], k = 4\\n243 is wrong?"
                    },
                    {
                        "username": "math3846",
                        "content": "289 is right.\nmax score: [54,6,34,66], [63,52,39,62,46], [75,28,65,18,37,18,13,33,69,19,40,13,10,43,61], [72]\nmin score: [54,6], [34,66,63,52,39,62,46,75,28,65,18,37,18], [13,33,69,19,40,13], [10,43,61,72]"
                    },
                    {
                        "username": "Lorins",
                        "content": "Hard? I think not\n\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        pos = sorted([weights[i] + weights[i + 1] for i in range(len(weights) - 1)])\n        return 0 if k == 1 else sum(pos[-1 * k + 1:]) - sum(pos[:k - 1])\n\nTwo liner"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Can bag be empty?\\n[1,2,3,3,5,6,7,8,9]\\nk=2;\\nhow the the answer is 17? can anyone explain"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Kaltu](/Kaltu) got it thank you It's 14 i wrote  17 by mistake"
                    },
                    {
                        "username": "Kaltu",
                        "content": "I copy paste it to the testcase and leetcode says the exapected answer is 14 not 17\nwhich is true becasue\n[[1,2,3,3,5,6,7,8], [9]] => (1 + 8) + (9 + 9) = 27\n[[1], [2,3,3,5,6,7,8,9]] => (1 + 1) + (2 + 9) = 13\n27 - 13 = 14"
                    }
                ]
            },
            {
                "id": 1783439,
                "content": [
                    {
                        "username": "bee365go",
                        "content": "use `long int` to avoid Runtime Error"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Is it look Similar to Book Allocation and Painter\\'s Partition Problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "While the Book Allocation and Painter\\'s Partition Problems do share similarities with this problem in that they involve partitioning a given set into subsets, they are not exactly similar. \\n\\nIn the Book Allocation and Painter\\'s Partition Problems, you\\'re trying to partition a set into k subsets such that the sum of the values in each subset is minimized or maximized. This often involves binary search and dynamic programming.\\n\\nIn this problem, however, you are partitioning the array into bags (subsets), but the way the \"cost\" of each subset is determined (by the sum of the first and last elements) is quite different. Also, you are interested in the difference between the maximum and minimum possible total \"costs\" rather than simply maximizing or minimizing a sum.\\n\\nSo, while the problems are similar in the sense that they involve partitioning a set, the specifics of how this is done and what is being optimized are different."
                    },
                    {
                        "username": "jswang00037",
                        "content": "HARD WEEKEND again"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A very interesting question requires a small epiphany."
                    },
                    {
                        "username": "shivansh157",
                        "content": "How to get the intuition for solving this ??"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Once you have realised that DP won\\'t work, you know there has to be a mathematical trick.  At that point, look at the simplest case (in this case k bags) and work out the answer for that (= 0).  Then see what happens when you add 1 level of complexity (ie. another bad).  What does that to the solution.  What happens when we add a second level.  Can we work out the rule that gives us the answer with n extra bags?"
                    },
                    {
                        "username": "abhi2616",
                        "content": "this test case will fail\\narr=1,3,1,2\\nk=2\\nwith this approach(in solution section) we will get ans=1\\nbut actually it is 3"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "You have 3 possible divisions:\\n[1] + [3,1,2] score = 2+5=7\\n[1,3] + [1,2] score = 4+3=7\\n[1,3,1] + [2] score = 2+4=6 (2 is counted twice)\\nso ans = 1 is correct"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can anyone share DP solution (TLE one)?"
                    },
                    {
                        "username": "alin99",
                        "content": "Here\\'s a crude implementation.  Basically, use backtracking to add the marbles to ```k``` bags.  When the last bag is reached, dump the remaining marbles into it.  Once all bags are filled, compute the maxSum and minSum for all bags.  Finally, return the difference between them.\\n\\n```\\nvar putMarbles = function(weights, k) {\\n    const {minSum, maxSum} = solve(weights, k, 0, {});\\n    return maxSum - minSum;\\n};\\n\\nconst solve = (weights, k, start, memo) => {\\n    if (k === 0) {\\n        return {minSum: 0, maxSum: 0};\\n    }\\n    \\n    const key = `${k},${start}`;\\n    if (key in memo) {\\n        return memo[key];\\n    }\\n\\n    const bag = [];\\n    let min = Infinity;\\n    let max = -Infinity;\\n    for (let i = start; i < weights.length; i++) {\\n        if (k === 1) {\\n            bag.push(...weights.slice(i));\\n            i = weights.length;\\n        } else {\\n            bag.push(weights[i]);\\n        }\\n        const bagSum = bag[0] + bag[bag.length - 1];\\n        const {minSum, maxSum} = solve(weights, k - 1, i + 1, memo);\\n        min = Math.min(min, bagSum + minSum);\\n        max = Math.max(max, bagSum + maxSum);\\n    }\\n\\n    memo[key] = {minSum: min, maxSum: max};\\n    return memo[key];\\n}\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why for testcase [54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72], k = 4\\n243 is wrong?"
                    },
                    {
                        "username": "math3846",
                        "content": "289 is right.\nmax score: [54,6,34,66], [63,52,39,62,46], [75,28,65,18,37,18,13,33,69,19,40,13,10,43,61], [72]\nmin score: [54,6], [34,66,63,52,39,62,46,75,28,65,18,37,18], [13,33,69,19,40,13], [10,43,61,72]"
                    },
                    {
                        "username": "Lorins",
                        "content": "Hard? I think not\n\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        pos = sorted([weights[i] + weights[i + 1] for i in range(len(weights) - 1)])\n        return 0 if k == 1 else sum(pos[-1 * k + 1:]) - sum(pos[:k - 1])\n\nTwo liner"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Can bag be empty?\\n[1,2,3,3,5,6,7,8,9]\\nk=2;\\nhow the the answer is 17? can anyone explain"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Kaltu](/Kaltu) got it thank you It's 14 i wrote  17 by mistake"
                    },
                    {
                        "username": "Kaltu",
                        "content": "I copy paste it to the testcase and leetcode says the exapected answer is 14 not 17\nwhich is true becasue\n[[1,2,3,3,5,6,7,8], [9]] => (1 + 8) + (9 + 9) = 27\n[[1], [2,3,3,5,6,7,8,9]] => (1 + 1) + (2 + 9) = 13\n27 - 13 = 14"
                    }
                ]
            },
            {
                "id": 1778481,
                "content": [
                    {
                        "username": "bee365go",
                        "content": "use `long int` to avoid Runtime Error"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Is it look Similar to Book Allocation and Painter\\'s Partition Problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "While the Book Allocation and Painter\\'s Partition Problems do share similarities with this problem in that they involve partitioning a given set into subsets, they are not exactly similar. \\n\\nIn the Book Allocation and Painter\\'s Partition Problems, you\\'re trying to partition a set into k subsets such that the sum of the values in each subset is minimized or maximized. This often involves binary search and dynamic programming.\\n\\nIn this problem, however, you are partitioning the array into bags (subsets), but the way the \"cost\" of each subset is determined (by the sum of the first and last elements) is quite different. Also, you are interested in the difference between the maximum and minimum possible total \"costs\" rather than simply maximizing or minimizing a sum.\\n\\nSo, while the problems are similar in the sense that they involve partitioning a set, the specifics of how this is done and what is being optimized are different."
                    },
                    {
                        "username": "jswang00037",
                        "content": "HARD WEEKEND again"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A very interesting question requires a small epiphany."
                    },
                    {
                        "username": "shivansh157",
                        "content": "How to get the intuition for solving this ??"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Once you have realised that DP won\\'t work, you know there has to be a mathematical trick.  At that point, look at the simplest case (in this case k bags) and work out the answer for that (= 0).  Then see what happens when you add 1 level of complexity (ie. another bad).  What does that to the solution.  What happens when we add a second level.  Can we work out the rule that gives us the answer with n extra bags?"
                    },
                    {
                        "username": "abhi2616",
                        "content": "this test case will fail\\narr=1,3,1,2\\nk=2\\nwith this approach(in solution section) we will get ans=1\\nbut actually it is 3"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "You have 3 possible divisions:\\n[1] + [3,1,2] score = 2+5=7\\n[1,3] + [1,2] score = 4+3=7\\n[1,3,1] + [2] score = 2+4=6 (2 is counted twice)\\nso ans = 1 is correct"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can anyone share DP solution (TLE one)?"
                    },
                    {
                        "username": "alin99",
                        "content": "Here\\'s a crude implementation.  Basically, use backtracking to add the marbles to ```k``` bags.  When the last bag is reached, dump the remaining marbles into it.  Once all bags are filled, compute the maxSum and minSum for all bags.  Finally, return the difference between them.\\n\\n```\\nvar putMarbles = function(weights, k) {\\n    const {minSum, maxSum} = solve(weights, k, 0, {});\\n    return maxSum - minSum;\\n};\\n\\nconst solve = (weights, k, start, memo) => {\\n    if (k === 0) {\\n        return {minSum: 0, maxSum: 0};\\n    }\\n    \\n    const key = `${k},${start}`;\\n    if (key in memo) {\\n        return memo[key];\\n    }\\n\\n    const bag = [];\\n    let min = Infinity;\\n    let max = -Infinity;\\n    for (let i = start; i < weights.length; i++) {\\n        if (k === 1) {\\n            bag.push(...weights.slice(i));\\n            i = weights.length;\\n        } else {\\n            bag.push(weights[i]);\\n        }\\n        const bagSum = bag[0] + bag[bag.length - 1];\\n        const {minSum, maxSum} = solve(weights, k - 1, i + 1, memo);\\n        min = Math.min(min, bagSum + minSum);\\n        max = Math.max(max, bagSum + maxSum);\\n    }\\n\\n    memo[key] = {minSum: min, maxSum: max};\\n    return memo[key];\\n}\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why for testcase [54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72], k = 4\\n243 is wrong?"
                    },
                    {
                        "username": "math3846",
                        "content": "289 is right.\nmax score: [54,6,34,66], [63,52,39,62,46], [75,28,65,18,37,18,13,33,69,19,40,13,10,43,61], [72]\nmin score: [54,6], [34,66,63,52,39,62,46,75,28,65,18,37,18], [13,33,69,19,40,13], [10,43,61,72]"
                    },
                    {
                        "username": "Lorins",
                        "content": "Hard? I think not\n\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        pos = sorted([weights[i] + weights[i + 1] for i in range(len(weights) - 1)])\n        return 0 if k == 1 else sum(pos[-1 * k + 1:]) - sum(pos[:k - 1])\n\nTwo liner"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Can bag be empty?\\n[1,2,3,3,5,6,7,8,9]\\nk=2;\\nhow the the answer is 17? can anyone explain"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Kaltu](/Kaltu) got it thank you It's 14 i wrote  17 by mistake"
                    },
                    {
                        "username": "Kaltu",
                        "content": "I copy paste it to the testcase and leetcode says the exapected answer is 14 not 17\nwhich is true becasue\n[[1,2,3,3,5,6,7,8], [9]] => (1 + 8) + (9 + 9) = 27\n[[1], [2,3,3,5,6,7,8,9]] => (1 + 1) + (2 + 9) = 13\n27 - 13 = 14"
                    }
                ]
            },
            {
                "id": 1960568,
                "content": [
                    {
                        "username": "bee365go",
                        "content": "use `long int` to avoid Runtime Error"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Is it look Similar to Book Allocation and Painter\\'s Partition Problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "While the Book Allocation and Painter\\'s Partition Problems do share similarities with this problem in that they involve partitioning a given set into subsets, they are not exactly similar. \\n\\nIn the Book Allocation and Painter\\'s Partition Problems, you\\'re trying to partition a set into k subsets such that the sum of the values in each subset is minimized or maximized. This often involves binary search and dynamic programming.\\n\\nIn this problem, however, you are partitioning the array into bags (subsets), but the way the \"cost\" of each subset is determined (by the sum of the first and last elements) is quite different. Also, you are interested in the difference between the maximum and minimum possible total \"costs\" rather than simply maximizing or minimizing a sum.\\n\\nSo, while the problems are similar in the sense that they involve partitioning a set, the specifics of how this is done and what is being optimized are different."
                    },
                    {
                        "username": "jswang00037",
                        "content": "HARD WEEKEND again"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A very interesting question requires a small epiphany."
                    },
                    {
                        "username": "shivansh157",
                        "content": "How to get the intuition for solving this ??"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Once you have realised that DP won\\'t work, you know there has to be a mathematical trick.  At that point, look at the simplest case (in this case k bags) and work out the answer for that (= 0).  Then see what happens when you add 1 level of complexity (ie. another bad).  What does that to the solution.  What happens when we add a second level.  Can we work out the rule that gives us the answer with n extra bags?"
                    },
                    {
                        "username": "abhi2616",
                        "content": "this test case will fail\\narr=1,3,1,2\\nk=2\\nwith this approach(in solution section) we will get ans=1\\nbut actually it is 3"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "You have 3 possible divisions:\\n[1] + [3,1,2] score = 2+5=7\\n[1,3] + [1,2] score = 4+3=7\\n[1,3,1] + [2] score = 2+4=6 (2 is counted twice)\\nso ans = 1 is correct"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can anyone share DP solution (TLE one)?"
                    },
                    {
                        "username": "alin99",
                        "content": "Here\\'s a crude implementation.  Basically, use backtracking to add the marbles to ```k``` bags.  When the last bag is reached, dump the remaining marbles into it.  Once all bags are filled, compute the maxSum and minSum for all bags.  Finally, return the difference between them.\\n\\n```\\nvar putMarbles = function(weights, k) {\\n    const {minSum, maxSum} = solve(weights, k, 0, {});\\n    return maxSum - minSum;\\n};\\n\\nconst solve = (weights, k, start, memo) => {\\n    if (k === 0) {\\n        return {minSum: 0, maxSum: 0};\\n    }\\n    \\n    const key = `${k},${start}`;\\n    if (key in memo) {\\n        return memo[key];\\n    }\\n\\n    const bag = [];\\n    let min = Infinity;\\n    let max = -Infinity;\\n    for (let i = start; i < weights.length; i++) {\\n        if (k === 1) {\\n            bag.push(...weights.slice(i));\\n            i = weights.length;\\n        } else {\\n            bag.push(weights[i]);\\n        }\\n        const bagSum = bag[0] + bag[bag.length - 1];\\n        const {minSum, maxSum} = solve(weights, k - 1, i + 1, memo);\\n        min = Math.min(min, bagSum + minSum);\\n        max = Math.max(max, bagSum + maxSum);\\n    }\\n\\n    memo[key] = {minSum: min, maxSum: max};\\n    return memo[key];\\n}\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why for testcase [54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72], k = 4\\n243 is wrong?"
                    },
                    {
                        "username": "math3846",
                        "content": "289 is right.\nmax score: [54,6,34,66], [63,52,39,62,46], [75,28,65,18,37,18,13,33,69,19,40,13,10,43,61], [72]\nmin score: [54,6], [34,66,63,52,39,62,46,75,28,65,18,37,18], [13,33,69,19,40,13], [10,43,61,72]"
                    },
                    {
                        "username": "Lorins",
                        "content": "Hard? I think not\n\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        pos = sorted([weights[i] + weights[i + 1] for i in range(len(weights) - 1)])\n        return 0 if k == 1 else sum(pos[-1 * k + 1:]) - sum(pos[:k - 1])\n\nTwo liner"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Can bag be empty?\\n[1,2,3,3,5,6,7,8,9]\\nk=2;\\nhow the the answer is 17? can anyone explain"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Kaltu](/Kaltu) got it thank you It's 14 i wrote  17 by mistake"
                    },
                    {
                        "username": "Kaltu",
                        "content": "I copy paste it to the testcase and leetcode says the exapected answer is 14 not 17\nwhich is true becasue\n[[1,2,3,3,5,6,7,8], [9]] => (1 + 8) + (9 + 9) = 27\n[[1], [2,3,3,5,6,7,8,9]] => (1 + 1) + (2 + 9) = 13\n27 - 13 = 14"
                    }
                ]
            },
            {
                "id": 1961194,
                "content": [
                    {
                        "username": "bee365go",
                        "content": "use `long int` to avoid Runtime Error"
                    },
                    {
                        "username": "ekansh1309",
                        "content": "Is it look Similar to Book Allocation and Painter\\'s Partition Problem??"
                    },
                    {
                        "username": "bparanj",
                        "content": "While the Book Allocation and Painter\\'s Partition Problems do share similarities with this problem in that they involve partitioning a given set into subsets, they are not exactly similar. \\n\\nIn the Book Allocation and Painter\\'s Partition Problems, you\\'re trying to partition a set into k subsets such that the sum of the values in each subset is minimized or maximized. This often involves binary search and dynamic programming.\\n\\nIn this problem, however, you are partitioning the array into bags (subsets), but the way the \"cost\" of each subset is determined (by the sum of the first and last elements) is quite different. Also, you are interested in the difference between the maximum and minimum possible total \"costs\" rather than simply maximizing or minimizing a sum.\\n\\nSo, while the problems are similar in the sense that they involve partitioning a set, the specifics of how this is done and what is being optimized are different."
                    },
                    {
                        "username": "jswang00037",
                        "content": "HARD WEEKEND again"
                    },
                    {
                        "username": "czjnbb",
                        "content": "A very interesting question requires a small epiphany."
                    },
                    {
                        "username": "shivansh157",
                        "content": "How to get the intuition for solving this ??"
                    },
                    {
                        "username": "user3954sk",
                        "content": "Once you have realised that DP won\\'t work, you know there has to be a mathematical trick.  At that point, look at the simplest case (in this case k bags) and work out the answer for that (= 0).  Then see what happens when you add 1 level of complexity (ie. another bad).  What does that to the solution.  What happens when we add a second level.  Can we work out the rule that gives us the answer with n extra bags?"
                    },
                    {
                        "username": "abhi2616",
                        "content": "this test case will fail\\narr=1,3,1,2\\nk=2\\nwith this approach(in solution section) we will get ans=1\\nbut actually it is 3"
                    },
                    {
                        "username": "tsun_ud",
                        "content": "You have 3 possible divisions:\\n[1] + [3,1,2] score = 2+5=7\\n[1,3] + [1,2] score = 4+3=7\\n[1,3,1] + [2] score = 2+4=6 (2 is counted twice)\\nso ans = 1 is correct"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Can anyone share DP solution (TLE one)?"
                    },
                    {
                        "username": "alin99",
                        "content": "Here\\'s a crude implementation.  Basically, use backtracking to add the marbles to ```k``` bags.  When the last bag is reached, dump the remaining marbles into it.  Once all bags are filled, compute the maxSum and minSum for all bags.  Finally, return the difference between them.\\n\\n```\\nvar putMarbles = function(weights, k) {\\n    const {minSum, maxSum} = solve(weights, k, 0, {});\\n    return maxSum - minSum;\\n};\\n\\nconst solve = (weights, k, start, memo) => {\\n    if (k === 0) {\\n        return {minSum: 0, maxSum: 0};\\n    }\\n    \\n    const key = `${k},${start}`;\\n    if (key in memo) {\\n        return memo[key];\\n    }\\n\\n    const bag = [];\\n    let min = Infinity;\\n    let max = -Infinity;\\n    for (let i = start; i < weights.length; i++) {\\n        if (k === 1) {\\n            bag.push(...weights.slice(i));\\n            i = weights.length;\\n        } else {\\n            bag.push(weights[i]);\\n        }\\n        const bagSum = bag[0] + bag[bag.length - 1];\\n        const {minSum, maxSum} = solve(weights, k - 1, i + 1, memo);\\n        min = Math.min(min, bagSum + minSum);\\n        max = Math.max(max, bagSum + maxSum);\\n    }\\n\\n    memo[key] = {minSum: min, maxSum: max};\\n    return memo[key];\\n}\\n```"
                    },
                    {
                        "username": "danila_egorenko",
                        "content": "Why for testcase [54,6,34,66,63,52,39,62,46,75,28,65,18,37,18,13,33,69,19,40,13,10,43,61,72], k = 4\\n243 is wrong?"
                    },
                    {
                        "username": "math3846",
                        "content": "289 is right.\nmax score: [54,6,34,66], [63,52,39,62,46], [75,28,65,18,37,18,13,33,69,19,40,13,10,43,61], [72]\nmin score: [54,6], [34,66,63,52,39,62,46,75,28,65,18,37,18], [13,33,69,19,40,13], [10,43,61,72]"
                    },
                    {
                        "username": "Lorins",
                        "content": "Hard? I think not\n\nclass Solution:\n    def putMarbles(self, weights: List[int], k: int) -> int:\n        pos = sorted([weights[i] + weights[i + 1] for i in range(len(weights) - 1)])\n        return 0 if k == 1 else sum(pos[-1 * k + 1:]) - sum(pos[:k - 1])\n\nTwo liner"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "Can bag be empty?\\n[1,2,3,3,5,6,7,8,9]\\nk=2;\\nhow the the answer is 17? can anyone explain"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "[@Kaltu](/Kaltu) got it thank you It's 14 i wrote  17 by mistake"
                    },
                    {
                        "username": "Kaltu",
                        "content": "I copy paste it to the testcase and leetcode says the exapected answer is 14 not 17\nwhich is true becasue\n[[1,2,3,3,5,6,7,8], [9]] => (1 + 8) + (9 + 9) = 27\n[[1], [2,3,3,5,6,7,8,9]] => (1 + 1) + (2 + 9) = 13\n27 - 13 = 14"
                    }
                ]
            }
        ]
    }
]